## com.apple.fskit.apfs

> `/System/Library/ExtensionKit/Extensions/com.apple.fskit.apfs.appex/com.apple.fskit.apfs`

```diff

-2332.120.31.0.2
-  __TEXT.__text: 0x5fa94
-  __TEXT.__auth_stubs: 0xad0
-  __TEXT.__objc_stubs: 0x4e0
-  __TEXT.__objc_methlist: 0x1d4
-  __TEXT.__cstring: 0x14f2d
-  __TEXT.__const: 0x8138
-  __TEXT.__gcc_except_tab: 0x14
-  __TEXT.__oslogstring: 0xd1
-  __TEXT.__objc_classname: 0x59
-  __TEXT.__objc_methname: 0x4fa
-  __TEXT.__objc_methtype: 0x209
-  __TEXT.__unwind_info: 0xa08
-  __DATA_CONST.__auth_got: 0x578
-  __DATA_CONST.__got: 0x78
-  __DATA_CONST.__auth_ptr: 0x40
-  __DATA_CONST.__const: 0x600
-  __DATA_CONST.__cfstring: 0x240
+2632.0.15.0.1
+  __TEXT.__text: 0xa6ff4
+  __TEXT.__auth_stubs: 0xe90
+  __TEXT.__objc_stubs: 0x5c0
+  __TEXT.__objc_methlist: 0x1ec
+  __TEXT.__const: 0x88f0
+  __TEXT.__cstring: 0x2de6f
+  __TEXT.__gcc_except_tab: 0x78
+  __TEXT.__oslogstring: 0x11b
+  __TEXT.__objc_classname: 0x5b
+  __TEXT.__objc_methname: 0x51d
+  __TEXT.__objc_methtype: 0x21e
+  __TEXT.__unwind_info: 0x1380
+  __DATA_CONST.__auth_got: 0x758
+  __DATA_CONST.__got: 0xc0
+  __DATA_CONST.__auth_ptr: 0x80
+  __DATA_CONST.__const: 0xbe8
+  __DATA_CONST.__cfstring: 0x360
   __DATA_CONST.__objc_classlist: 0x8
   __DATA_CONST.__objc_protolist: 0x18
   __DATA_CONST.__objc_imageinfo: 0x8
-  __DATA.__objc_const: 0x240
-  __DATA.__objc_selrefs: 0x210
+  __DATA.__objc_const: 0x278
+  __DATA.__objc_selrefs: 0x248
+  __DATA.__objc_ivar: 0x4
   __DATA.__objc_data: 0x50
-  __DATA.__data: 0x2e0
-  __DATA.__bss: 0xa9
-  __DATA.__common: 0x430
+  __DATA.__data: 0x1068
+  __DATA.__common: 0xad8
+  __DATA.__bss: 0x1e221
   - /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation
   - /System/Library/Frameworks/Foundation.framework/Foundation
   - /System/Library/Frameworks/IOKit.framework/Versions/A/IOKit

   - /usr/lib/libSystem.B.dylib
   - /usr/lib/libobjc.A.dylib
   - /usr/lib/libutil.dylib
-  UUID: BCBFB40F-AD07-3C9E-9C58-F9D962F7EEAC
-  Functions: 1190
-  Symbols:   714
-  CStrings:  1970
+  UUID: E0D4800B-D13F-3992-9447-18702080A360
+  Functions: 2324
+  Symbols:   1191
+  CStrings:  3953
 
Symbols:
+ _CC_SHA256_Final
+ _CC_SHA256_Init
+ _CC_SHA256_Update
+ _CFStringCreateWithBytesNoCopy
+ _CFStringCreateWithCString
+ _CacheBlockSize
+ _CacheDestroy
+ _CacheDevFuncs
+ _CacheEvict
+ _CacheFlush
+ _CacheInit
+ _CacheRead
+ _CacheReadFinish
+ _CacheReadRelease
+ _CacheRelease
+ _CacheRemove
+ _CacheTransactionAbort
+ _CacheTransactionEnd
+ _CacheTransactionStart
+ _CacheUpdateDevBlockSize
+ _CacheWrite
+ _DumpData
+ _FSKitCheckContainerStart
+ _FSKitCheckDone
+ _FSKitCheckStart
+ _FSKitCheckUpdate
+ _FSKitErrorDomain
+ _IOConnectCallStructMethod
+ _IOPMAssertionCreateWithName
+ _IORegistryEntryCreateCFProperty
+ _IORegistryEntryGetChildIterator
+ _IOServiceClose
+ _IOServiceOpen
+ _OBJC_CLASS_$_NSError
+ _OBJC_CLASS_$_NSProgress
+ __DefaultRuneLocale
+ ___NSArray0__struct
+ ___exp10
+ ___maskrune
+ ___sprintf_chk
+ ___stdinp
+ __apfs_calloc_typed
+ __apfs_malloc_typed
+ __apfs_realloc_typed
+ __apfs_type_to_str
+ __omap_delete_obj
+ __omap_insert_obj
+ __omap_lookup_obj
+ __xf_type_to_str
+ __xp_lookup_obj
+ _add_overlapped_extent
+ _add_xfield
+ _apfs_clonegroup_key_cmp
+ _apfs_container_iouc
+ _apfs_crypto_io_disable
+ _apfs_crypto_io_enable
+ _apfs_crypto_io_getset_locker_data
+ _apfs_deletefs_ext
+ _apfs_do_update_last_modified_by
+ _apfs_parse_version
+ _appexPrintFixed
+ _appexPrintInternal
+ _asprintf
+ _authapfs_hash_comparison_size
+ _bCompar
+ _bitmap_copy
+ _bitmap_shift_down
+ _bitmap_store
+ _bitmap_store_destroy
+ _bitmap_store_init
+ _bitmap_store_inited
+ _bitmap_store_iterate
+ _block0_sb_agrees_with_checkpoint_sb
+ _bsearch
+ _btree_node_update_maybe
+ _cache_stats_enabled
+ _cdevname
+ _check_object_overlap
+ _check_range
+ _clone_mapping_abort
+ _clone_mapping_finalize
+ _clone_mapping_found_corruptions_and_aborted
+ _clone_mapping_get_file_ids_of_private_id
+ _clone_mapping_init
+ _clone_mapping_register
+ _clone_mapping_register_inode
+ _clone_mapping_register_resource_fork
+ _clonegroup_finalize
+ _clonegroup_register
+ _clonegroup_register_inode
+ _clonegroup_tree_compare
+ _clonegroup_validate_repair_key_val
+ _compute_attr_tag_hash
+ _container_cleanup
+ _container_crypto_prepare
+ _container_crypto_setup
+ _container_freeze
+ _container_get_info
+ _container_is_internal_embedded
+ _container_is_internal_mac
+ _container_open
+ _container_status_is_corrupt
+ _convertfmt
+ _copy_obj
+ _copy_obj_async
+ _copy_obj_finish
+ _crypto_abort
+ _crypto_finalize
+ _crypto_init
+ _crypto_register
+ _crypto_register_dstream
+ _crypto_register_fext
+ _crypto_unregister_fext
+ _ctime
+ _dev_cleanup
+ _dev_init_with_fd
+ _dev_reload
+ _dev_reload_validate
+ _device_basename
+ _device_is_encrypted
+ _device_is_multikey_encrypted
+ _devname
+ _dir_abort
+ _dir_finalize
+ _dir_increment_drec_count
+ _dir_register
+ _dir_register_nchildren
+ _dir_register_nlink
+ _dir_repair_drec_hash
+ _dir_stats_abort
+ _dir_stats_finalize
+ _dir_stats_init
+ _dir_stats_register_clone
+ _dir_stats_register_descendant
+ _dir_stats_register_dir_stats
+ _dir_stats_register_expanded_dir_stats
+ _dir_stats_register_origin
+ _dir_stats_register_purgeable
+ _dir_stats_register_purgeable_rsrc
+ _dir_stats_register_resource_fork
+ _dir_stats_unregister_clone
+ _disable_idle_sleep
+ _dispatch_async
+ _dispatch_get_global_queue
+ _doCheck
+ _doFormat
+ _double_uint64_key_compare
+ _dstream_abort
+ _dstream_delete
+ _dstream_finalize
+ _dstream_init
+ _dstream_is_cow_exempt
+ _dstream_register
+ _dstream_register_dstream_id
+ _dstream_register_fext
+ _dstream_register_hash
+ _dstream_register_purgeable_ts
+ _dstream_reset
+ _dstream_update_uncompressed_size
+ _dup
+ _evict_mapping_tree_validate_key_val
+ _extent_does_not_contain_range_cb
+ _extent_is_valid_range_cb
+ _extent_list_tree_iterate
+ _fclose
+ _fdopen
+ _fext_tree_compare
+ _fext_validate_repair_key_val
+ _fflush
+ _ffsctl
+ _fgetln
+ _file_extent_register
+ _file_extent_unregister
+ _file_info_abort
+ _file_info_delete
+ _file_info_finalize
+ _file_info_init
+ _file_info_register
+ _file_info_register_clone
+ _file_info_register_inode
+ _file_info_register_resource_fork
+ _file_info_unregister_clone
+ _findmessage
+ _fixup_cow_exempt_phys_extent
+ _fputc
+ _fputs
+ _fsckAddMessages
+ _fsckAskPrompt
+ _fsckCreate
+ _fsckDestroy
+ _fsckPrint
+ _fsckPrintGUI
+ _fsckPrintNothing
+ _fsckPrintString
+ _fsckPrintToString
+ _fsckPrintXML
+ _fsckSetDefaultResponse
+ _fsckSetLogger
+ _fsckSetOutputStyle
+ _fsckSetWriter
+ _fsck_allocate_blocks
+ _fsck_apfs_check_fs
+ _fsck_apfs_ctx
+ _fsck_apfs_init
+ _fsck_apfs_state_init
+ _fsck_blockcopy
+ _fsck_btree_get_info
+ _fsck_btree_validate_node
+ _fsck_clonegroup_tree
+ _fsck_compare_snapshots
+ _fsck_container_reload
+ _fsck_dev_init
+ _fsck_dev_init_ext
+ _fsck_dev_init_with_dev_handle_ext
+ _fsck_dev_init_with_fd
+ _fsck_dev_init_with_fd_ext
+ _fsck_dev_raw_read
+ _fsck_dev_raw_write
+ _fsck_dev_transaction_abort
+ _fsck_dev_transaction_end
+ _fsck_dev_transaction_flush
+ _fsck_dev_transaction_start
+ _fsck_disk_bitmap_iter_finish
+ _fsck_disk_bitmap_iter_init
+ _fsck_disk_bitmap_iter_next
+ _fsck_doc_id_cleanup
+ _fsck_doc_id_finalize
+ _fsck_doc_id_init
+ _fsck_doc_id_trees
+ _fsck_encryption_rolling
+ _fsck_fail_add_iteration
+ _fsck_fail_add_repair
+ _fsck_fail_func
+ _fsck_fail_init
+ _fsck_fail_num_failures
+ _fsck_fail_num_warnings
+ _fsck_fail_set_dev_node
+ _fsck_fail_set_phase
+ _fsck_fail_set_uuid
+ _fsck_fragmented_metadata
+ _fsck_free_range
+ _fsck_global_container_get
+ _fsck_global_volume_cleanup_all
+ _fsck_global_volume_get_by_fs_oid
+ _fsck_global_volume_get_by_index
+ _fsck_global_volume_get_by_uuid
+ _fsck_global_volume_get_range
+ _fsck_integrity_meta
+ _fsck_ios_encryption_rolling
+ _fsck_is_seal_intact
+ _fsck_iterate
+ _fsck_iterate_compare
+ _fsck_messages_apfs
+ _fsck_messages_common
+ _fsck_meta_crypto_state_destroy
+ _fsck_meta_crypto_state_unwrap
+ _fsck_nx_efi_jumpstart
+ _fsck_nx_keybag_orphans
+ _fsck_nx_keybags
+ _fsck_nx_superblock
+ _fsck_obj_phys
+ _fsck_omap
+ _fsck_omap_snap
+ _fsck_omap_snap_delete_snapshot
+ _fsck_print_cache_stats
+ _fsck_printf
+ _fsck_printf_debug
+ _fsck_printf_err
+ _fsck_printf_warn
+ _fsck_progress_done
+ _fsck_progress_init_for_container
+ _fsck_progress_init_for_volume
+ _fsck_progress_update
+ _fsck_reaper
+ _fsck_repairs_add
+ _fsck_repairs_init
+ _fsck_repairs_perform
+ _fsck_should_repair_unknown_flags
+ _fsck_snap_meta_delete_snapshot
+ _fsck_spaceman
+ _fsck_spaceman_free_queue_trees
+ _fsck_spaceman_with_context
+ _fsck_tree
+ _fsck_tree_node_allocate
+ _fsck_tree_node_deallocate
+ _fsck_tree_node_read
+ _fsck_tree_node_repair_abort
+ _fsck_tree_node_repair_add_maybe
+ _fsck_tree_node_repair_finalize
+ _fsck_tree_node_repair_init
+ _fsck_tree_node_repair_volume
+ _fsck_tree_node_write
+ _fsck_userfs_get_keybag
+ _fsck_validate_node_hash
+ _fsck_verify_space
+ _fsck_volume_reload
+ _fsindex_parse
+ _fsroot_iterate
+ _fsroot_jobj_abort
+ _fsroot_jobj_advance
+ _fsroot_jobj_finalize
+ _fsroot_jobj_init
+ _fwrite
+ _get_apfs_io_object
+ _get_bitmap_for_range
+ _get_cib_for_chunk
+ _get_clonegroup_tree
+ _get_disk_bitmap
+ _get_doc_id_tree
+ _get_extentref_tree
+ _get_extentref_tree_at_xid
+ _get_fext_tree
+ _get_first_child_of_class
+ _get_fsroot_tree
+ _get_inode_xfield
+ _get_jobj_xfields_ptr
+ _get_key_and_value_at_index
+ _get_key_range
+ _get_latest_checkpoint
+ _get_latest_snap_xid
+ _get_nx_reaper
+ _get_nx_superblock
+ _get_omap
+ _get_omap_snap_tree
+ _get_omap_tree
+ _get_pfkur_tree
+ _get_secondary_fsroot_tree
+ _get_snap_meta_tree
+ _get_spaceman
+ _get_spaceman_fq_tree
+ _get_tree_for_jobj
+ _get_volume_io_object
+ _get_volume_io_object_from_snapshot
+ _get_xfield
+ _getfsstat
+ _getpagesize
+ _has_overlapped_extents
+ _ilog10
+ _inode_finalize
+ _inode_init
+ _inode_register
+ _inode_register_xattr
+ _inode_repair_clear_internal_flags
+ _inode_repair_set_internal_flags
+ _inode_repairs_add_xf_deletion
+ _is_file_in_purgatory
+ _is_snapshot_in_purgatory
+ _iterate_free_blocks
+ _iterate_free_blocks_in_range
+ _iterate_reaper
+ _jkey_compare
+ _jkey_ranges_find_overlap
+ _jkey_validate_len
+ _jobj_type_to_str
+ _jobj_validate_repair_key_val
+ _jval_validate_len
+ _kCFAllocatorNull
+ _lflag
+ _live_fsck
+ _logstring
+ _lookup_in_dir
+ _lookup_obj
+ _mach_task_self_
+ _mark_extent_maybe
+ _mark_object_allocated
+ _mark_range
+ _mark_range_allocated
+ _mark_range_free
+ _mark_reserved_space_as_allocated
+ _memchr
+ _memory_storage_create
+ _memory_storage_destroy
+ _memory_storage_limit
+ _memory_storage_limit_reached
+ _memory_storage_read
+ _memory_storage_register_tree
+ _memory_storage_write
+ _memset
+ _mmap
+ _modify_spaceman_bitmap
+ _msgCompar
+ _munmap
+ _nx_reaper_add_ext
+ _objc_alloc_init
+ _objc_getProperty
+ _objc_opt_isKindOfClass
+ _objc_release_x27
+ _objc_release_x9
+ _objc_retain
+ _objc_retain_x1
+ _objc_retain_x23
+ _objc_retain_x27
+ _objc_retain_x28
+ _objc_retain_x9
+ _objc_setProperty_atomic
+ _omap_in_reaper
+ _omap_info
+ _omap_key_compare
+ _omap_sv_disable
+ _omap_sv_finalize
+ _omap_sv_init
+ _omap_sv_mark
+ _omap_sv_mark_reaper_entry
+ _omap_sv_process_orphans
+ _outputString
+ _outstring
+ _overlap_info
+ _path_iterator_init
+ _path_iterator_init_ext
+ _pfkur_finalize
+ _pfkur_register_file_id
+ _pfkur_validate_repair_key_val
+ _phys_ext_backref_tree
+ _phys_extent_cleanup
+ _phys_extent_diff_iterator_init
+ _phys_extent_finalize
+ _phys_extent_init
+ _phys_extent_register
+ _physical_store_to_container
+ _print_fext_tree_key_val_info
+ _print_jobj_key_val_info
+ _print_overlapped_extents
+ _print_pfkur_tree_key_val_info
+ _print_snapshot_warning
+ _print_wrapped_crypto_state
+ _printargs
+ _printv
+ _pthread_cond_signal
+ _pthread_create
+ _purgeable_abort
+ _purgeable_finalize
+ _purgeable_init
+ _purgeable_register
+ _purgeable_register_inode
+ _purgeable_register_ts
+ _random
+ _range_ffc
+ _range_ffs
+ _rc_to_errno
+ _reallocf
+ _remove_xfield
+ _repair_bitmap_maybe
+ _repair_ip_bitmap_maybe
+ _repair_overlapped_extents
+ _safely_open_log_file
+ _set_inode_xfield
+ _setlinebuf
+ _setup_logging
+ _snap_meta_repair_name
+ _snap_name_insert
+ _snap_name_remove
+ _snapshot_finalize
+ _snapshot_init
+ _snapshot_register_meta
+ _snapshot_register_name
+ _space_verification_cleanup
+ _space_verification_init
+ _spaceman_datazone_iterate
+ _spaceman_free_tree
+ _spaceman_free_tree_key_compare
+ _spaceman_metazone
+ _spaceman_metazone_iterate
+ _split_range_maybe
+ _sprintf
+ _srandomdev
+ _state
+ _strchr
+ _time
+ _tree_create
+ _tree_destroy
+ _tree_init_ext
+ _tree_insert
+ _tree_iterator_init
+ _tree_key_count
+ _tree_lookup
+ _tree_lookup_min
+ _tree_node_count
+ _tree_remove
+ _tree_remove_at_level
+ _typestring
+ _uint32_key_compare
+ _uint64_key_compare
+ _update_dir_stats_xfield
+ _update_inode_sparse_bytes
+ _validate_doc_id_tree_record
+ _validate_snap_name
+ _vasprintf
+ _verify_bitmap
+ _verify_ip_bitmap
+ _verify_overallocation
+ _vfprintf
+ _vm_page_size
+ _volume_alloc_count_get
+ _volume_cleanup
+ _volume_crypto_close
+ _volume_crypto_open
+ _volume_reset_snapshot
+ _vsnprintf
+ _write_apfs_superblock
+ _write_nx_superblock
+ _write_obj
- __NSConcreteGlobalBlock
- __apfs_malloc
- __apfs_realloc
- _apfs_check_for_spillover
- _authapfs_hash_size
- _btree_check
- _btree_check_ext
- _btree_debug_stats_print
- _btree_node_check
- _btree_node_debug_stats
- _btree_node_key_len
- _btree_node_key_off
- _btree_node_space_stats
- _btree_node_toc_entry_size
- _btree_node_val_off
- _cst_from_fvkey
- _dev_set_tier2_device
- _fusion_mt_key_cmp
- _nx_check
- _nx_fusion_superblock_write
- _nx_obj_cache_reset
- _objc_retain_x22
- _objc_retain_x3
- _objc_retain_x4
CStrings:
+ "\t\t\t<dict><key>%s</key> <string>%s</string></dict>\n"
+ "\t\t\t<integer>%d</integer>\n"
+ "\t\t\t<integer>%ld</integer>\n"
+ "\t\t\t<integer>%llu</integer>\n"
+ "\t\t\t<integer>%p</integer>\n"
+ "\t\t\t<string>%s</string>\n"
+ "\t\t</array>\n"
+ "\t\t<array>\n"
+ "\t\t<key>%s</key>\n"
+ "\t\t<key>%s</key> <integer>%s</integer>\n"
+ "\t\t<key>%s</key> <integer>%u</integer>\n"
+ "\t\t<key>%s</key> <string>%s</string>\n"
+ "\t\t[%4llu - %4llu) [%4s] = %d\n"
+ "\t%-14s: %s\n"
+ "\t%-32s %.2lf [usec]\n"
+ "\t%-32s %u\n"
+ "\t</dict>\n"
+ "\t<dict>\n"
+ "\tCache %s histogram:\n"
+ "\n%s: fsck_apfs started at %s"
+ "\nSpace allocation summary:\n\n"
+ "\nTotal blocks marked by fsck: %llu\n"
+ "\ndir-stats %llu (has dir-stats? %d)%s:\nflags: 0x%x\nchained-key: %llu (computed: %llu)\norigin-id: %llu (computed: %llu)\nshadow-key: %llu (exists? %d)\ndescendants: %llu (computed: %llu)\nSAF descendants: %llu\ndir-stats descendants: %llu\nphysical size: %llu (computed: %llu)\nresource fork size: %llu (computed: %llu)\nclone size: %llu (exists? %d; computed: %llu)\npurgeable size: %llu (exists? %d; computed: %llu)\npurgeable resource fork size: %llu (exists? %d; computed: %llu)\nhas calculating dir-stats? %d\norigin is SAF? %d (parent is SAF? %d)\norigin is purgeable? %d\n\n"
+ "\nfsck_apfs started at %s"
+ "  "
+ "   "
+ "    |"
+ " %s tree (%llu)%s"
+ " * * * cannot allocate memory * * *\n"
+ " *****"
+ " [reconstructed]"
+ " atime: %llu file_id: %llu file_size: %llu dstream_id: %llu flags: 0x%x owning_uid: %u\n"
+ " chained-key: %lld\n"
+ " descendants: %llu phys_size: %llu resource_fork_size: %llu gen_count: %llu chained_key: %llu flags: 0x%x\n"
+ " embedded data size: %d\n"
+ " extentref_Tree_type: %u flags: %u name: '%.*s' name_len: %u\n"
+ " extentref_tree_oid: %lld sblock_oid: %lld change_time: %llu create_time: %llu\n"
+ " file_id: %llu dstream_id: %llu\n"
+ " name: '%.*s' name_len: %u snap_xid: %lld\n"
+ " out-of-line data size: %lld (under obj-id: %lld / crypto-id: %lld)\n"
+ " private_id: %llu, file_id: %llu\n"
+ " revision: %u key len: %u"
+ " type: %u\n"
+ " type: %u hash: 0x%llx total_count: %llu physical_size: %llu flags: 0x%x\n"
+ " type: %u logical addr: %lld\n"
+ "!(tag->IO_Flags & META_IO_TWEAK_SET) || (cache->BlockSize == cache->DevBlockSize)"
+ "!(val.flags & FSCK_CLONE_MAPPING_RECREATE_MAPPING)"
+ "!_is_sealed(volume)"
+ "!curr_crypto_val.has_cryptostate"
+ "!curr_dir_stats.chained_to_itself"
+ "!curr_dir_stats.has_dir_stats"
+ "!curr_dir_stats.shadow_key_exists"
+ "!dir_stats->has_dir_stats"
+ "!dir_stats_repair_inited()"
+ "!error"
+ "!newbtn2"
+ "!newbtn2 || !new_minkey"
+ "!newbtn2 || newbtn"
+ "!path || *path"
+ "!snapshot_val.has_meta"
+ "!snapshot_val.has_name"
+ "!split || successful"
+ "!update || index < btn->btn_nkeys"
+ "%-20s%-15llu\n"
+ "%-20s%-15s\n"
+ "%02x "
+ "%04x:  "
+ "%d\n"
+ "%d %%"
+ "%d failures and %d warnings issued; failing execution as requested.\n"
+ "%d$@"
+ "%d%d-%d"
+ "%ld\n"
+ "%llu"
+ "%llu\n"
+ "%llu "
+ "%p\n"
+ "%s"
+ "%s\n"
+ "%s %llu/%llu repairs of this type in total.\n"
+ "%s (%llu+%llu): %s records entry %u contains invalid keybag\n"
+ "%s (%llu+%llu): %s records entry %u contains invalid range %llu+%llu\n"
+ "%s (%llu+%llu): %s records entry %u does not contain a range (size %u)\n"
+ "%s (%llu+%llu): UUID %s of entry %u (tag %u) does not reference any volume\n"
+ "%s (%llu+%llu): UUID %s of entry %u (tag %u) is not the container UUID %s\n"
+ "%s (%llu+%llu): UUID of entry %u is null\n"
+ "%s (%llu+%llu): block range isn't a valid keybag, aborting\n"
+ "%s (%llu+%llu): block range isn't a valid keybag, skipping checks\n"
+ "%s (%llu+%llu): entry %u has 'unknown' tag type\n"
+ "%s (%llu+%llu): entry %u has blob size %u > maximum blob size %u\n"
+ "%s (%llu+%llu): entry %u has blob size == 0\n"
+ "%s (%llu+%llu): entry %u has invalid blob\n"
+ "%s (%llu+%llu): entry %u has invalid blob range %llu+%llu\n"
+ "%s (%llu+%llu): entry %u has invalid padding\n"
+ "%s (%llu+%llu): entry %u has size %u > maximum size %u\n"
+ "%s (%llu+%llu): entry %u has size %u > remaining size %u (keybag size %u)\n"
+ "%s (%llu+%llu): entry %u with size %u brings total size %u beyond object size %u\n"
+ "%s (%llu+%llu): failed to allocate memory\n"
+ "%s (%llu+%llu): failed to get keybag data: %s\n"
+ "%s (%llu+%llu): failed to put keybag: %s\n"
+ "%s (%llu+%llu): invalid padding\n"
+ "%s (%llu+%llu): number of bytes %u does not match sum of all entries %u\n"
+ "%s (%llu+%llu): number of bytes %u exceeds object size %u\n"
+ "%s (%llu+%llu): number of entries %u exceeds object capacity %lu\n"
+ "%s (%llu+%llu): number of keys %u does not match number of entries found %u\n"
+ "%s (%llu+%llu): oti_ke_blob_cksum (0x%llx) is invalid for blob\n"
+ "%s (%llu+%llu): oti_ke_blob_len (%u) is too large\n"
+ "%s (%llu+%llu): size is too large\n"
+ "%s (%llu+%llu): unknown version %u\n, skipping checks\n"
+ "%s (%llu+%llu): version cannot be 0\n"
+ "%s (id %llu): Bad phys_block_num + len (%llu + %llu) for physical file extent record\n"
+ "%s (id %llu): Bad phys_block_num + len (%llu) for physical extent record\n"
+ "%s (id %llu): Found data hash on unsealed volume\n"
+ "%s (id %llu): ID larger than MAX_JOBJ_ID (%llu)\n"
+ "%s (id %llu): Invalid hash at offset %llu\n"
+ "%s (id %llu): Invalid type (0x%x)\n"
+ "%s (id %llu): Length %llu of file extent not a multiple of the block size (%u)\n"
+ "%s (id %llu): Logical address %llu not a multiple of the block size (%u)\n"
+ "%s (id %llu): Logical address %llu of data hash not a multiple of the hash chunk size (%u)\n"
+ "%s (id %llu): Logical address %llu of file extent not a multiple of the block size (%u)\n"
+ "%s (id %llu): Unexpected hash size (%u != %u)\n"
+ "%s (id %llu): Unknown type (0x%x)\n"
+ "%s (id %llu): attribution tag xf does not exist, despite internal_flags (0x%llx)\n"
+ "%s (id %llu): attribution tag xf exists, despite internal_flags (0x%llx)\n"
+ "%s (id %llu): com.apple.ResourceFork is expected to be stream based\n"
+ "%s (id %llu): dir-stats key xf does not exist, despite internal_flags (0x%llx)\n"
+ "%s (id %llu): directory nlink value %d is greater than nchildren (%d)\n"
+ "%s (id %llu): doc_id xf does not exist, despite bsd_flags (0x%x)\n"
+ "%s (id %llu): dstream xf does not exist, despite existence of sparse bytes xf\n"
+ "%s (id %llu): dstream.alloced_size (%llu) is not a multiple of the block size (%u)\n"
+ "%s (id %llu): dstream.size (%llu) is greater than dstream.alloced_size (%llu)\n"
+ "%s (id %llu): expected physical block number for extent at offset %lld\n"
+ "%s (id %llu): extent crypto flag missing on encrypted volume\n"
+ "%s (id %llu): extent crypto flag set on sparse extent\n"
+ "%s (id %llu): extent crypto flag set on unencrypted volume\n"
+ "%s (id %llu): failed to register attribution tag: %d\n"
+ "%s (id %llu): failed to register dir-stats (%llu) descendant: %d\n"
+ "%s (id %llu): failed to register dir-stats (%llu) purgeable_size: %d\n"
+ "%s (id %llu): failed to register file info (hash %llu): %d\n"
+ "%s (id %llu): failed to update dstream (%llu)\n"
+ "%s (id %llu): fext tree record present on non-sealed volume\n"
+ "%s (id %llu): file extent record present on sealed volume\n"
+ "%s (id %llu): file_id (%llu) and name (%.*s) mismatch for private directory\n"
+ "%s (id %llu): file_id (%llu) and name (%.*s) mismatch for root directory\n"
+ "%s (id %llu): found attribution tag on a volume that doesn't support them\n"
+ "%s (id %llu): found dir-stats object (chained-key %llu) that is unexpectedly being moved\n"
+ "%s (id %llu): found dstream with unassigned default_crypto_id\n"
+ "%s (id %llu): invalid atime (0)\n"
+ "%s (id %llu): invalid bsd_flags (0x%x)\n"
+ "%s (id %llu): invalid chained_key (%llu)\n"
+ "%s (id %llu): invalid crypto_id (%llu)\n"
+ "%s (id %llu): invalid default_protection_class (%u)\n"
+ "%s (id %llu): invalid dir-stats flags (0x%x) on volume without attribution tags\n"
+ "%s (id %llu): invalid dir_nlink (%d)\n"
+ "%s (id %llu): invalid dstream\n"
+ "%s (id %llu): invalid dstream.default_crypto_id (%llu)\n"
+ "%s (id %llu): invalid dstream.default_crypto_id (%llu) on encrypted volume\n"
+ "%s (id %llu): invalid dstream.default_crypto_id (%llu) on encrypted volume, given apfs_fs_flags (0x%llx)\n"
+ "%s (id %llu): invalid dstream.default_crypto_id (%llu) on unencrypted volume, given apfs_fs_flags (0x%llx)\n"
+ "%s (id %llu): invalid dstream_id (%llu)\n"
+ "%s (id %llu): invalid extentref_tree_type (0x%x)\n"
+ "%s (id %llu): invalid file_id (%llu)\n"
+ "%s (id %llu): invalid file_id (%llu) (%s)\n"
+ "%s (id %llu): invalid flag: (0x%02x)\n"
+ "%s (id %llu): invalid flags (0x%x)\n"
+ "%s (id %llu): invalid flags (0x%x), given name (<%.*s> ; name_len %d)\n"
+ "%s (id %llu): invalid flags: (0x%02x)\n"
+ "%s (id %llu): invalid full clone size (%llu) for hash (%llu)\n"
+ "%s (id %llu): invalid gen_count (%llu)\n"
+ "%s (id %llu): invalid hash (0)\n"
+ "%s (id %llu): invalid hash (0x%x, expected 0x%x) of name (%.*s)\n"
+ "%s (id %llu): invalid hdr.obj_id\n"
+ "%s (id %llu): invalid internal_flags (0x%llx) given apfs_fs_flags (0x%llx) PFK bit\n"
+ "%s (id %llu): invalid internal_flags (0x%llx) given unassigned default_crypto_id\n"
+ "%s (id %llu): invalid internal_flags (0x%llx) given volume readonly compatible features (0x%llx)\n"
+ "%s (id %llu): invalid internal_flags (0x%llx), (dir-stats SAF but not dir-stats maintained)\n"
+ "%s (id %llu): invalid internal_flags (0x%llx), (dir-stats origin but not dir-stats maintained)\n"
+ "%s (id %llu): invalid internal_flags (0x%llx), given type (0%o)\n"
+ "%s (id %llu): invalid internal_flags (0x%llx), inconsistent protection class\n"
+ "%s (id %llu): invalid inum (%llu)\n"
+ "%s (id %llu): invalid key length (%u)\n"
+ "%s (id %llu): invalid key length (%u), given name_len (%u)\n"
+ "%s (id %llu): invalid key on expanded-records volume\n"
+ "%s (id %llu): invalid length (%u), given state.key_len (%u)\n"
+ "%s (id %llu): invalid length (%u), given xdata_len (%u)\n"
+ "%s (id %llu): invalid name (%.*s)\n"
+ "%s (id %llu): invalid name (%.*s), given name_len (%u)\n"
+ "%s (id %llu): invalid name_len (%u)\n"
+ "%s (id %llu): invalid name_len (%u), given key length (%u)\n"
+ "%s (id %llu): invalid name_len (%u), given value length (%u)\n"
+ "%s (id %llu): invalid nchildren (%d)\n"
+ "%s (id %llu): invalid nlink (%d)\n"
+ "%s (id %llu): invalid nonzero crypto_id (%llu) on unencrypted volume\n"
+ "%s (id %llu): invalid owning_obj_id (%llu) for update extent\n"
+ "%s (id %llu): invalid pad1 (0x%hx)\n"
+ "%s (id %llu): invalid pad2 (0x%x)\n"
+ "%s (id %llu): invalid parent_id (%llu)\n"
+ "%s (id %llu): invalid parent_id (%llu) for private directory\n"
+ "%s (id %llu): invalid parent_id (%llu) for regular directory\n"
+ "%s (id %llu): invalid parent_id (%llu) for root directory\n"
+ "%s (id %llu): invalid physical size (%llu) for hash (%llu)\n"
+ "%s (id %llu): invalid private_id (%llu)\n"
+ "%s (id %llu): invalid sblock_oid (%llu)\n"
+ "%s (id %llu): invalid sibling_id (%llu)\n"
+ "%s (id %llu): invalid snap_xid (%llu)\n"
+ "%s (id %llu): invalid sparse extent with nonzero crypto_id (%llu)\n"
+ "%s (id %llu): invalid state.cpflags (%u)\n"
+ "%s (id %llu): invalid state.key_len (%u)\n"
+ "%s (id %llu): invalid state.key_os_version (%u)\n"
+ "%s (id %llu): invalid state.key_revision (%u)\n"
+ "%s (id %llu): invalid state.major_version (%u)\n"
+ "%s (id %llu): invalid state.minor_version (%u)\n"
+ "%s (id %llu): invalid state.persistent_class (%u)\n"
+ "%s (id %llu): invalid type (%u)\n"
+ "%s (id %llu): invalid type (0%o)\n"
+ "%s (id %llu): invalid value length (%u)\n"
+ "%s (id %llu): invalid value length (%u), given name_len (%u)\n"
+ "%s (id %llu): invalid xattr_obj_id (%llu)\n"
+ "%s (id %llu): invalid xdata_len (%u), given flags (0x%x)\n"
+ "%s (id %llu): invalid xfields\n"
+ "%s (id %llu): invalid zero crypto_id on encrypted volume\n"
+ "%s (id %llu): length is 0\n"
+ "%s (id %llu): no rdev xf on char/block device (mode %u)\n"
+ "%s (id %llu): number of sparse bytes (%llu) is larger than alloced_size (%llu)\n"
+ "%s (id %llu): owning_obj_id is '%s'\n"
+ "%s (id %llu): owning_obj_id is 0\n"
+ "%s (id %llu): physical size (%llu) is less than full clone size (%llu) for hash (%llu)\n"
+ "%s (id %llu): present on sealed volume\n"
+ "%s (id %llu): purgeable resource fork size (%llu) is larger than resource fork size (%llu)\n"
+ "%s (id %llu): signing id does not exist\n"
+ "%s (id %llu): signing id hash (%llu) for signing id (%s) with length (%zu) does not match attribution tag hash (%llu)\n"
+ "%s (id %llu): sparse bytes mismatch for a file in the purgatory\n"
+ "%s (id %llu): unable to remove dstream of inode %llu\n"
+ "%s (id %llu): uncompressed size is set (%llu) but has-uncompressed-size flag is not set (flags: 0x%llx)\n"
+ "%s (id %llu): uncompressed_size/rdev/dir_nlink union field is set (%llu) but inode flags and mode do not indicate it should (flags: 0x%llx, mode %u)\n"
+ "%s (id %llu): unknown flags (0x%hx / known flags are: 0x%hx)\n"
+ "%s (id %llu): unknown flags (0x%x / known flags are: 0x%x)\n"
+ "%s (id %llu): unknown flags: (0x%02x / known flags are: 0x%02x)\n"
+ "%s (id %llu): unknown internal_flags (0x%llx / known flags are: 0x%llx)\n"
+ "%s (id %llu): unknown kind (%u)\n"
+ "%s (id %llu): xf %u/%u: %s: directory nlink value %lld is greater than nchildren (%d)\n"
+ "%s (id %llu): xf %u/%u: %s: directory nlink value is invalid (%llu)\n"
+ "%s (id %llu): xf %u/%u: %s: doc_id exists (%u), despite bsd_flags (0x%x)\n"
+ "%s (id %llu): xf %u/%u: %s: extended field at offset %u+%u extends beyond xf_used_data (%u)\n"
+ "%s (id %llu): xf %u/%u: %s: extended field type is no longer used\n"
+ "%s (id %llu): xf %u/%u: %s: failed to register dir-stats (%llu) origin: %d\n"
+ "%s (id %llu): xf %u/%u: %s: failed to register dstream for crypto state tracking: %d\n"
+ "%s (id %llu): xf %u/%u: %s: failed to register dstream: %d\n"
+ "%s (id %llu): xf %u/%u: %s: found attribution tag on a volume that doesn't support them\n"
+ "%s (id %llu): xf %u/%u: %s: found attribution tag on an inode with unsupported flags\n"
+ "%s (id %llu): xf %u/%u: %s: found in an unsupported volume\n"
+ "%s (id %llu): xf %u/%u: %s: found nlink field but volume doesn't support it\n"
+ "%s (id %llu): xf %u/%u: %s: found nlink field even though inode is not a directory\n"
+ "%s (id %llu): xf %u/%u: %s: found nlink x-field but volume has dir-nlink in core-inode\n"
+ "%s (id %llu): xf %u/%u: %s: found rdev x-field but volume has rdev in core-inode\n"
+ "%s (id %llu): xf %u/%u: %s: found rdev x-field even though inode is not a char/block device\n"
+ "%s (id %llu): xf %u/%u: %s: found unexpected dstream associated with non-regular file\n"
+ "%s (id %llu): xf %u/%u: %s: found zero rdev on char/block device (mode %u)\n"
+ "%s (id %llu): xf %u/%u: %s: inode is expected to be an SAF dir-stats origin\n"
+ "%s (id %llu): xf %u/%u: %s: invalid attribution hash (%llu)\n"
+ "%s (id %llu): xf %u/%u: %s: invalid clonegroup_id (%llu), less than MIN_CLONEGROUP_ID (%u)\n"
+ "%s (id %llu): xf %u/%u: %s: invalid dir_stats_key (%llu)\n"
+ "%s (id %llu): xf %u/%u: %s: invalid doc_id (%u), less than MIN_DOC_ID (%u)\n"
+ "%s (id %llu): xf %u/%u: %s: invalid doc_id index\n"
+ "%s (id %llu): xf %u/%u: %s: invalid dstream\n"
+ "%s (id %llu): xf %u/%u: %s: invalid extended field size %u for type %u, expected %lu\n"
+ "%s (id %llu): xf %u/%u: %s: invalid extended field size %u for type %u, expected %u"
+ "%s (id %llu): xf %u/%u: %s: invalid extended field size %u for type %u, expected %u\n"
+ "%s (id %llu): xf %u/%u: %s: invalid extended field size %u, expected %u\n"
+ "%s (id %llu): xf %u/%u: %s: invalid extended field size %u, max %u\n"
+ "%s (id %llu): xf %u/%u: %s: invalid hash: (0)\n"
+ "%s (id %llu): xf %u/%u: %s: invalid name (%.*s), given name_len (%u)\n"
+ "%s (id %llu): xf %u/%u: %s: invalid name (%s)\n"
+ "%s (id %llu): xf %u/%u: %s: invalid shadow_key (%llu)\n"
+ "%s (id %llu): xf %u/%u: %s: invalid sibling_id (%llu)\n"
+ "%s (id %llu): xf %u/%u: %s: invalid x_type (%u)\n"
+ "%s (id %llu): xf %u/%u: %s: sparse_bytes set even though inode is not sparse\n"
+ "%s (id %llu): xf %u/%u: %s: unable to add repair for unexpected xfield: %s\n"
+ "%s (id %llu): xf %u/%u: %s: unable to remove dstream of non-regular inode\n"
+ "%s (id %llu): xf %u/%u: %s: unknown x_type (%u)\n"
+ "%s (id %llu): xf %u/%u: %s: uuid is NULL\n"
+ "%s (id %llu): zero rdev on char/block device (mode %u)\n"
+ "%s BTNODE_LEAF flag? "
+ "%s BTNODE_LEAF flags? "
+ "%s BTNODE_ROOT flag? "
+ "%s xfield of dir-stats object (id %llu) does not match expected value (%llu)\n"
+ "%s xfield of dir-stats object (id %llu) exists unexpectedly\n"
+ "%s%s"
+ "%s%s%llx"
+ "%s%s%s\n"
+ "%s: "
+ "%s: %llu orphan mappings found\n"
+ "%s: %s%s"
+ "%s: Failed to read, error %ld"
+ "%s: could not iterate reaper for omap space verification\n"
+ "%s: loaded resource with ID (%@)"
+ "%s: started to format resource"
+ "%s:%d: %s Fusion is not supported anymore\n"
+ "%s:%d: %s clonegroup tree creation failed: %s\n"
+ "%s:%d: %s clonegroups enabled for this volume\n"
+ "%s:%d: %s entitled reserve: reserved space underflow: %lld (%lld)\n"
+ "%s:%d: %s failed to delete fs clonegroup tree after fs creation failed: %d\n"
+ "%s:%d: %s superblock container size %lld greater than device size %lld\n"
+ "%s:%d: %s this volume requires valid UUID option specified\n"
+ "%s:%d: %s unentitled reserve: reserved space underflow: %lld (%lld)\n"
+ "%s:%d: %s<->superblock mismatch on fusion uuid\n"
+ "%s:%d: Invalid options can't have -n (check only) and -y (repair) together \n"
+ "%s:%d: Volume role 0x%x is not supported"
+ "%s:%d: failed to validate node %p (oid:%llu, xid:%llu) of fs %p (%llu) - %d\n"
+ "%s:%d: found MT ghost offset %d but length is %u\n"
+ "%s:%d: found ghost value %d but length %u != 0\n"
+ "%s:%d: key %d length %u not equal to fixed key length %u\n"
+ "%s:%d: key %d offset %u is not aligned\n"
+ "%s:%d: key %d offset+length %u+%u exceeds key space %u\n"
+ "%s:%d: key free list elem length %u is impossibly low\n"
+ "%s:%d: key free list elem offset+length %u+%u exceeds key space %u\n"
+ "%s:%d: key free list entry at offset %u+%lu exceeds key space %u\n"
+ "%s:%d: sum of key free list lengths %u is greater than key free list space %u\n"
+ "%s:%d: sum of key lengths %u + total free list space %u != key space %u\n"
+ "%s:%d: sum of key lengths %u is greater than key space %u\n"
+ "%s:%d: sum of val free list lengths %u is greater than val free list space %u\n"
+ "%s:%d: sum of val lengths %u + total free list space %u != val space %u\n"
+ "%s:%d: sum of val lengths %u is greater than val space %u\n"
+ "%s:%d: val %d length %u in non-leaf is not %u\n"
+ "%s:%d: val %d length %u not equal to fixed val length %u\n"
+ "%s:%d: val %d offset %u is not aligned\n"
+ "%s:%d: val %d offset-length %u-%u exceeds val space %u\n"
+ "%s:%d: val free list elem length %u is impossibly low\n"
+ "%s:%d: val free list elem offset+length %u+%u exceeds val space %u\n"
+ "%s:%d: val free list entry at offset %u+%lu exceeds val space %u\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s %s %s unlock %s (%d)%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s %s%s%s[%04zu,%04zu): %s%s%s%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s %sdump %s (len = %zd)%s%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s %sresult: %d; oti: %d; passcode_change: %d; cf: 0x%x; of: 0x%x; nf: 0x%x%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s Internal Error: Null KEK, file radar%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s Internal Error: Null VEK, file radar%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s error %d%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s failed REQUIRE condition (%s:%d)\n%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s failed to decode blob%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s failed to decode kek%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s failed to decode vek%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s failed to generate valid kek group uuid after 16 attempts%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s icloud recovery key%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s institutional recovery key%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s kek and unmanaged vek device protection mismatch vek:%x, kek:%x%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s kek constraint violation 1%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s kek constraint violation 2%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s kek failed to unwrap vek; mix-n-match?%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s personal recovery key%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s sep managed vek cannot have flag_no_ephdm%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s unknown blob type %i%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s unsupported vek type for sys disable%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s unsupported vek type for sys enable%s\n"
+ "%s:%spid:%d,%s:%s%s%s%s%s%u:%s user uuid unexpectedly match new kek uuid%s\n"
+ "%s:start"
+ "(%c,\"%s\",%d)\n"
+ "(%d %%)\n"
+ "((!kv1.klen && !kv1.vlen) || (kv1.klen == sizeof *disk_sfq_key && kv1.vlen == sizeof *disk_sfq_val)) && ((!kv2.klen && !kv2.vlen) || (kv2.klen == sizeof *mem_sfq_key && kv2.vlen == sizeof *mem_sfq_val))"
+ "(flags & (SM_ALLOC_ENTITLED | SM_ALLOC_UNENTITLED)) != (SM_ALLOC_ENTITLED | SM_ALLOC_UNENTITLED)"
+ "(fr_key->fr_op == FSCK_REPAIR_OP_DELETION && fr_key->fr_update_field == FSCK_REPAIR_UPDATE_NONE) || (fr_key->fr_op == FSCK_REPAIR_OP_UPDATE && fr_key->fr_update_field == FSCK_REPAIR_UPDATE_DREC_HASH)"
+ "(fr_key->fr_op == FSCK_REPAIR_OP_UPDATE) == (fr_key->fr_update_field != FSCK_REPAIR_UPDATE_NONE)"
+ "(fr_key->fr_op == FSCK_REPAIR_OP_UPDATE) || (fr_key->fr_op == FSCK_REPAIR_OP_INSERTION) || (fr_key->fr_op == FSCK_REPAIR_OP_DELETION)"
+ "(jobj_type == APFS_TYPE_DIR_STATS) || (jobj_type == APFS_EXPANDED_TYPE_DIR_STATS)"
+ "(key != NULL) == (klen != 0)"
+ "(key && val) || update"
+ "(oid 0x%llx) %s: %s(%llu, %u): %s\n"
+ "(oid 0x%llx) %s: _omap_lookup_obj(0x%llx, 0x%llx): %s\n"
+ "(oid 0x%llx) %s: _xp_lookup_obj(0x%llx): %s\n"
+ "(oid 0x%llx) %s: could not repair object to match checksum: too many bit flip candidates (%d)\n"
+ "(oid 0x%llx) %s: dev_write(%llu, %u): %s\n"
+ "(oid 0x%llx) %s: found a bit flip at index 0x%x\n"
+ "(oid 0x%llx) %s: found a bit flip in the header\n"
+ "(oid 0x%llx) %s: found zeroed-out block\n"
+ "(oid 0x%llx) %s: invalid crypto key index (%u) given obj_subtype\n"
+ "(oid 0x%llx) %s: invalid crypto key index (%u), expected (%u)\n"
+ "(oid 0x%llx) %s: invalid encryption type ov_flags (0x%x)\n"
+ "(oid 0x%llx) %s: invalid o_cksum (0x%llx)\n"
+ "(oid 0x%llx) %s: invalid o_oid (0x%llx)\n"
+ "(oid 0x%llx) %s: invalid o_subtype (0x%x, expected 0x%x)\n"
+ "(oid 0x%llx) %s: invalid o_type (0x%x, expected 0x%x)\n"
+ "(oid 0x%llx) %s: invalid o_xid (0x%llx)\n"
+ "(oid 0x%llx) %s: invalid o_xid (0x%llx, expected 0x%llx)\n"
+ "(oid 0x%llx) %s: invalid object address (0x%llx)\n"
+ "(oid 0x%llx) %s: invalid object size (0x%x)\n"
+ "(oid 0x%llx) %s: invalid ov_flags (0x%x)\n"
+ "(oid 0x%llx) %s: invalid ov_flags (0x%x), crypto key index set for unencrypted object\n"
+ "(oid 0x%llx) %s: invalid ov_flags (0x%x), tweak type set for unencrypted object\n"
+ "(oid 0x%llx) %s: malloc(%u)\n"
+ "(oid 0x%llx) %s: object is %s but omap says it's %s\n"
+ "(oid 0x%llx) %s: object is %s but should be %s\n"
+ "(oid 0x%llx) %s: object is encrypted with crypto key index (%u) but should be encrypted with crypto key index (%u)\n"
+ "(oid 0x%llx) %s: object is encrypted with crypto key index (%u)but omap says it's encrypted with crypto key index (%u)\n"
+ "(oid 0x%llx) %s: should be encrypted (ov_flags 0x%x)\n"
+ "(oid 0x%llx) %s: should not be encrypted (ov_flags 0x%x)\n"
+ "(oid 0x%llx) %s: using old subtype (0x%x, expected 0x%x)\n"
+ "(space == BTNODE_SPACE_KEY && off < key_total && len <= key_total - off) || (space == BTNODE_SPACE_VAL && off <= val_total && len <= off)"
+ "(val != NULL) || (vlen == 0)"
+ "(void *)fmt == (void *)m->msg"
+ "(void *)m->msg == (void *)fmt"
+ "* * * cannot allocate memory * * *\n"
+ "** "
+ "*snap_name_key_len == sizeof *snap_name_key + snap_name_key->name_len"
+ "*snap_name_key_len >= sizeof(j_snap_name_key_t)"
+ "*xattr_key_len == sizeof *xattr_key + xattr_key->name_len"
+ "*xattr_key_len >= sizeof(j_xattr_key_t)"
+ "--------"
+ "-----------"
+ "-A"
+ "-D"
+ "-E"
+ "-S"
+ "-[APFSFileSystem loadResource:options:replyHandler:]"
+ "-[APFSFileSystem startCheckWithTask:options:error:]"
+ "-[APFSFileSystem startCheckWithTask:options:error:]_block_invoke"
+ "-[APFSFileSystem startFormatWithTask:options:error:]"
+ "-[APFSFileSystem startFormatWithTask:options:error:]_block_invoke"
+ "-[APFSFileSystem syncRead:into:startingAt:length:]"
+ "-e"
+ "-i"
+ "-n"
+ "-q"
+ "-v"
+ "-y"
+ ". . .\n"
+ ".%llu"
+ ".DocumentRevisions-V100"
+ ".cxx_destruct"
+ "/dev/r%ss%d"
+ "/var/log/fsck_apfs.log"
+ "0x%016llx"
+ "0x%08x"
+ "0x%llx-dead"
+ "1"
+ "2632.0.15.0.1"
+ "61706673-7575-6964-0300-766f6c756d00"
+ "</plist>\n"
+ "<plist version=\"1.0\">\n"
+ "?"
+ "??? (id %llu): invalid key length (%u)\n"
+ "??? (id %llu): invalid key type (%u)\n"
+ "??? (id ???): invalid key length (%u)\n"
+ "@\"FSBlockDeviceResource\""
+ "Allocate new doc-id %u for file-id %llu? "
+ "Allocated (%llu) MB for cached btrees in %u blocks, limit is (%llu) MB\n"
+ "Any"
+ "AppleAPFSContainer"
+ "AppleAPFSMedia"
+ "AppleAPFSSnapshot"
+ "Applied"
+ "BT_KEY_COUNT(&dir_stats_tree) > 0"
+ "CLONEGROUP_EXT_TYPE_ATTRIBUTION_TAG"
+ "CLONEGROUP_EXT_TYPE_DIR_STATS_KEY"
+ "CLONE_MAPPING_EXT_DIR_STATS_KEY"
+ "CLONE_MAPPING_EXT_TYPE_ATTR_TAG"
+ "Cache %s count:"
+ "Cache %s time:"
+ "Cache average %s time:"
+ "CacheRawRead"
+ "CacheRawWrite"
+ "CacheReadAsync"
+ "Checking deleted snapshot residual state."
+ "Checking if the parent's minkey can be updated...\n"
+ "Checking snapshot %ld of %ld (%s, transaction ID %ld)"
+ "Checking the APFS volume superblock."
+ "Checking the EFI jumpstart record."
+ "Checking the NX evict mapping tree."
+ "Checking the checkpoint with transaction ID %ld."
+ "Checking the clone group tree."
+ "Checking the container superblock."
+ "Checking the document ID tree."
+ "Checking the encryption key structures."
+ "Checking the extent ref tree."
+ "Checking the file extent tree."
+ "Checking the file key rolling tree."
+ "Checking the fragmented metadata trees."
+ "Checking the fsroot tree."
+ "Checking the object map."
+ "Checking the snapshot metadata tree."
+ "Checking the snapshot metadata."
+ "Checking the space manager free queue trees."
+ "Checking the space manager."
+ "Checking volume %s."
+ "Clear"
+ "Clear invalid flag? "
+ "Clear uncompressed size/rdev/dir_nlink? "
+ "Clear uncompressed size? "
+ "Clear unexpected flags? "
+ "Clear volume inconsistent bit? "
+ "Clone group tree is invalid."
+ "CloneMap"
+ "Container superblock is invalid."
+ "Corrupt"
+ "Could not initialize APFS-specific messages\n"
+ "Could not initialize extentref tree (oid 0x%llx): %s\n"
+ "Could not initialize gbitmap tree (oid 0x%llx): %s\n"
+ "Could not initialize message output\n"
+ "Could not initialize omap tree (oid 0x%llx): %s\n"
+ "Could not initialize snap meta tree (oid 0x%llx): %s\n"
+ "Could not iterate extentref tree to read reaper objects(oid 0x%llx): %s\n"
+ "Could not iterate gbitmap tree to read reaper objects (oid 0x%llx): %s\n"
+ "Could not iterate omap tree to read reaper objects (oid 0x%llx): %s\n"
+ "Could not iterate snap meta tree to read reaper objects (oid 0x%llx): %s\n"
+ "Could not lookup cached extent_ref_tree information at snap xid (0x%llx): %s\n"
+ "Could not read nx_reaper_list object (oid (0x%llx)): %s\n"
+ "CryptoState"
+ "DAMAGEINFO"
+ "DIR_STATS_EXT_TYPE_CLONE_SIZE"
+ "DIR_STATS_EXT_TYPE_PURGEABLE_RSRC_SIZE"
+ "DIR_STATS_EXT_TYPE_PURGEABLE_SIZE"
+ "DIR_STATS_EXT_TYPE_SHADOW_KEY"
+ "DIR_STATS_VALID_ORIGIN_ID(dir_stats->origin_id)"
+ "DREC_EXT_TYPE_DIR_GEN_COUNT"
+ "DREC_EXT_TYPE_SIBLING_ID"
+ "Deferred repairs failed."
+ "Deferred repairs skipped."
+ "Delete omap_snap entries? "
+ "Delete snap_meta entries? "
+ "Device does not contain a valid APFS container.\n"
+ "DirRecord"
+ "DirSize"
+ "DirStats"
+ "Disabling fsck cross checks of %s tree\n"
+ "Disabling idle sleep, %s\n"
+ "Document ID tree is invalid."
+ "DstreamID"
+ "EFI jumpstart record is invalid."
+ "ERROR"
+ "EXPANDED_TYPE_FROM_LARGE_KEY(*(j_large_key_t *)jobj_key) == APFS_EXPANDED_TYPE_CLONE_MAPPING"
+ "EXPANDED_TYPE_FROM_LARGE_KEY(*(j_large_key_t *)jobj_key) == APFS_EXPANDED_TYPE_PURGEABLE"
+ "EXPANDED_TYPE_FROM_LARGE_KEY(ts_key->hdr) == APFS_EXPANDED_TYPE_PURGEABLE_TS"
+ "Encrypted"
+ "Encryption Rolling data structures are invalid."
+ "Encryption key structures are invalid."
+ "Executing %s (version %s)."
+ "Expanded"
+ "Extent ref tree is invalid."
+ "FAIL"
+ "FILE_INFO_TAG_EXT_TYPE_SIGNING_ID"
+ "Failed to allocate memory\n"
+ "Failed to allocate memory for cab\n"
+ "Failed to allocate memory for keybag\n"
+ "Failed to fix %s\n"
+ "Failed to get keybag : %s\n"
+ "Failed to get keybag entry with tag %d for volume %s\n"
+ "Failed to get password for encrypted volume from provided file descriptor: %s\n"
+ "Failed to unwrap encrypted volume keybag using the provided password: %s\n"
+ "File extent tree is invalid."
+ "File key rolling tree is invalid."
+ "File/folder %s could not be repaired."
+ "File/folder %s may be damaged."
+ "FileExtent"
+ "FileInfo"
+ "Fix %s (0x%llx+%llu) bitmap address (0x%llx)? "
+ "Fix apfs_clonegroup_next_id(oid 0x%llx, xid 0x%llx)? "
+ "Fix apfs_doc_id_fixup_cursor? "
+ "Fix apfs_doc_id_tree_type? "
+ "Fix apfs_formatted_by.id(oid 0x%llx, xid 0x%llx)? "
+ "Fix apfs_fs_alloc_count(oid 0x%llx, xid 0x%llx)? "
+ "Fix apfs_fs_index(oid 0x%llx, xid 0x%llx)? "
+ "Fix apfs_fs_reserve_block_count(oid 0x%llx, xid 0x%llx)? "
+ "Fix apfs_modified_by[%d].id(oid 0x%llx, xid 0x%llx)? "
+ "Fix apfs_next_doc_id(oid 0x%llx, xid 0x%llx)? "
+ "Fix apfs_next_obj_id(oid 0x%llx, xid 0x%llx)? "
+ "Fix apfs_num_directories(oid 0x%llx, xid 0x%llx)? "
+ "Fix apfs_num_files(oid 0x%llx, xid 0x%llx)? "
+ "Fix apfs_num_other_fsobjects(oid 0x%llx, xid 0x%llx)? "
+ "Fix apfs_num_snapshots(oid 0x%llx, xid 0x%llx)? "
+ "Fix apfs_num_symlinks(oid 0x%llx, xid 0x%llx)? "
+ "Fix apfs_volname(oid 0x%llx, xid 0x%llx)? "
+ "Fix btn_level (%u)? "
+ "Fix btree: bt_key_count (%llu)? "
+ "Fix btree: bt_longest_key (%u)? "
+ "Fix btree: bt_longest_val (%u)? "
+ "Fix btree: bt_node_count (%llu)? "
+ "Fix ci_free_count (%u)? "
+ "Fix corrupt container superblock? "
+ "Fix crypto_id (%llu)? "
+ "Fix crypto_id? "
+ "Fix default_crypto_id (%llu)? "
+ "Fix inode_val: internal_flags (0x%llx)? "
+ "Fix inode_val: parent_id (%llu)? "
+ "Fix internal flags (0x%llx)? "
+ "Fix object (oid 0x%llx) bit flip? "
+ "Fix object (oid 0x%llx) checksum? "
+ "Fix object (oid 0x%llx) crypto key index? "
+ "Fix object (oid 0x%llx) encryption and omap flags? "
+ "Fix object (oid 0x%llx) encryption? "
+ "Fix object (oid 0x%llx) flags? "
+ "Fix object (oid 0x%llx) header bit flip? "
+ "Fix object (oid 0x%llx) omap flags? "
+ "Fix object (oid 0x%llx) subtype? "
+ "Fix om_most_recent_snap (oid 0x%llx)? "
+ "Fix om_snap_count (oid 0x%llx)? "
+ "Fix overlapped extents? "
+ "Fix sm_free_count (%llu)? "
+ "Fix sm_fs_reserve_alloc_count? "
+ "Fix sm_fs_reserve_block_count? "
+ "Fix sme_snap_xid (xid 0x%llx)? "
+ "Fix snapshot meta name (%.*s) from snap name entry? "
+ "Fix snapshot meta name_len (%u) from snap name entry? "
+ "Fix spaceman free queue tree sfq_count (oid 0x%llx)? "
+ "Fix spaceman free queue tree sfq_oldest_xid (oid 0x%llx)? "
+ "Fix the keybag size? "
+ "Fix the number of bytes? "
+ "Fix the number of keys? "
+ "Fix unassigned default_crypto_id? "
+ "Fix xf_used_data? "
+ "Fragmented metadata trees are invalid."
+ "INFORMATION"
+ "INO_EXT_TYPE_ATTRIBUTION_TAG"
+ "INO_EXT_TYPE_CLONEGROUP_ID"
+ "INO_EXT_TYPE_CONFORMANCE_NLINK"
+ "INO_EXT_TYPE_DELTA_TREE_OID"
+ "INO_EXT_TYPE_DIR_STATS_KEY"
+ "INO_EXT_TYPE_DOCUMENT_ID"
+ "INO_EXT_TYPE_DSTREAM"
+ "INO_EXT_TYPE_FILE_DATA"
+ "INO_EXT_TYPE_FINDER_INFO"
+ "INO_EXT_TYPE_FS_UUID"
+ "INO_EXT_TYPE_NAME"
+ "INO_EXT_TYPE_ORIG_SYNC_ROOT_ID"
+ "INO_EXT_TYPE_PREV_FSIZE"
+ "INO_EXT_TYPE_PURGEABLE_FLAGS"
+ "INO_EXT_TYPE_RDEV"
+ "INO_EXT_TYPE_SNAP_XID"
+ "INO_EXT_TYPE_SOURCE_PURGE_ID"
+ "INO_EXT_TYPE_SPARSE_BYTES"
+ "INO_EXT_TYPE_SPEC_TELEM_FLAGS"
+ "INO_EXT_TYPE_UNRAW_SIZE"
+ "IOMatchCategory"
+ "IOStorage"
+ "IP"
+ "Inode"
+ "Insert missing %s objects? "
+ "Invalid"
+ "Invalid object type/subtype (type : %u) (subtype : %u)\n"
+ "Invalidate spaceman ip bm free list at index at index %u? "
+ "J_FILE_INFO_GET_TYPE(fi_key) == APFS_FILE_ATTRIBUTION_TAG"
+ "J_FILE_INFO_GET_TYPE(fi_key) == APFS_FILE_INFO_DATA_HASH"
+ "Keybag size is too large\n"
+ "Limited repair mode, not all repairs available"
+ "Look for links to corrupt files in %s directory."
+ "Look for missing items in %s directory."
+ "Mark volume for doc-id tree building on next mount? "
+ "Mark volume for doc-id tree cleanup on next mount? "
+ "Most recent checkpoint is invalid."
+ "NO\n"
+ "NO-NAME"
+ "NX blocked out range is invalid: 0x%llx+%llu\n"
+ "NX checkpoint data area fragmented metadata tree is invalid\n"
+ "NX checkpoint data blocks field is %u, but sum of ranges is %llu\n"
+ "NX checkpoint data range is invalid: 0x%llx+0x%x\n"
+ "NX checkpoint desc blocks field is %u, but sum of ranges is %llu\n"
+ "NX checkpoint desc range is invalid: 0x%llx+0x%x\n"
+ "NX checkpoint descriptor area fragmented metadata tree is invalid\n"
+ "NX evict mapping tree is invalid."
+ "NX jumpstart record range is invalid: 0x%llx+%llu\n"
+ "NX keybag data range is invalid: 0x%llx+%llu\n"
+ "NX media keylocker data range is invalid: 0x%llx+%llu\n"
+ "Node counts:"
+ "OBJ_TYPE_FROM_KEY(*cs_key) == APFS_TYPE_CRYPTO_STATE"
+ "OBJ_TYPE_FROM_KEY(*dsid_key) == APFS_TYPE_DSTREAM_ID"
+ "OBJ_TYPE_FROM_KEY(*jobj_key) == APFS_TYPE_CRYPTO_STATE"
+ "OBJ_TYPE_FROM_KEY(*jobj_key) == APFS_TYPE_DIR_REC"
+ "OBJ_TYPE_FROM_KEY(*jobj_key) == APFS_TYPE_INODE && jobj_key_len == sizeof(j_key_t)"
+ "OBJ_TYPE_FROM_KEY(*key) == APFS_TYPE_SNAP_METADATA"
+ "OBJ_TYPE_FROM_KEY(*key) == APFS_TYPE_SNAP_NAME && OBJ_ID_FROM_KEY(*key) == APFS_SNAPSHOT_NAME_OBJ_ID"
+ "OBJ_TYPE_FROM_KEY(*key) == APFS_TYPE_XATTR"
+ "OBJ_TYPE_FROM_KEY(fe_key->hdr) == APFS_TYPE_FILE_EXTENT"
+ "OBJ_TYPE_FROM_KEY(fi_key->hdr) == APFS_TYPE_FILE_INFO"
+ "OBJ_TYPE_FROM_KEY(fr_jobj_key->fr_j_key) != APFS_TYPE_EXPANDED || fr_key_len >= FSCK_REPAIR_J_LARGE_KEY_SIZE"
+ "OBJ_TYPE_FROM_KEY(phys_ext_key->hdr) == APFS_TYPE_EXTENT"
+ "OBJ_TYPE_FROM_KEY(ts_key->hdr) == APFS_TYPE_EXPANDED"
+ "OTI"
+ "OTI blob"
+ "OTI keybag"
+ "Object map is invalid."
+ "Overlap repair pass...\n"
+ "Overlapping object: (oid : 0x%llx) (type : %u) (subtype : %u), (%llu + %llu)\n"
+ "PROGRESS"
+ "PURGEABLE_EXT_TYPE_DIR_GEN_COUNT"
+ "PURGEABLE_EXT_TYPE_START_TIME"
+ "Performing deferred repairs."
+ "PhysExtent"
+ "PreventUserIdleDisplaySleep"
+ "Purgeable"
+ "PurgeableTombstone"
+ "QUICKCHECK ONLY; FILESYSTEM CLEAN"
+ "QUICKCHECK ONLY; FILESYSTEM DIRTY"
+ "REPAIR"
+ "Reached max number of fsck passes during repair\n"
+ "Rechecking volume."
+ "Remove entry with invalid blob range? "
+ "Remove entry with invalid blob? "
+ "Remove entry with invalid keybag? "
+ "Remove entry with invalid range? "
+ "Remove entry with null UUID? "
+ "Remove invalid flag (0x%02x)? "
+ "Remove invalid flags (0x%02x)? "
+ "Remove orphan entry? "
+ "Remove orphan/invalid %s objects? "
+ "Repairing volume."
+ "Requested cache size: %lluMB (%uk blocks * %ukB)\n"
+ "Restarting after deferred repairs...\n"
+ "Restarting tree validation in case more minkey errors exist...\n"
+ "Round %s length (%llu) to block size? "
+ "Round down logical address (%llu) to block size? "
+ "Running FSCK"
+ "SAF descendants"
+ "SAF descendants (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n"
+ "SAF descendants (%llu) of dir-stats object (id %llu) is greater than expected (0)\n"
+ "SUCCESS"
+ "Set"
+ "Set bsd_flags to 0x%x? "
+ "Set internal_flags to 0x%llx? "
+ "Set missing flag? "
+ "Set missing flags? "
+ "SiblingLink"
+ "SiblingMap"
+ "Skipped"
+ "SnapMetadata"
+ "SnapName"
+ "Snapshot (0x%llx): apfs_integrity_meta_oid is invalid\n"
+ "Snapshot is invalid."
+ "Snapshot metadata tree is invalid."
+ "Space Allocation: failed to allocate memory\n"
+ "Space Verification failed."
+ "Space Verification: failed to allocate memory for the bitmap block\n"
+ "Space Verification: failed to insert paddr (%llu) error : %s\n"
+ "Space Verification: failed to lookup paddr (%llu) : error %s\n"
+ "Space Verification: failed to remove paddr (%llu) error : %s\n"
+ "Space manager free queue trees are invalid."
+ "Space manager is invalid."
+ "Spaceman IP free queue tree has sfq_count (%llu) greater than IP block count (%llu)\n"
+ "Spaceman Repair: Cannot modify more than a block's worth of bitmap\n"
+ "Spaceman Repair: failed to allocate memory for the bitmap block\n"
+ "Spaceman free queue tree of type [%d] is invalid\n"
+ "Spaceman free queue tree of type [%s] has sfq_count (%llu) mismatch with cumulative counts in the tree (%llu)\n"
+ "Spaceman free queue tree of type [%s] has sfq_oldest_xid (%llu) greater than the oldest xid in the free tree (%llu)\n"
+ "Spaceman internal pool bitmap fragmented metadata tree is invalid\n"
+ "Spaceman internal pool fragmented metadata tree is invalid\n"
+ "Status"
+ "T@\"FSBlockDeviceResource\",&,V_resource"
+ "The container %s appears to be OK."
+ "The container %s could not be verified completely."
+ "The volume %s cannot be repaired when it is in use."
+ "The volume %s cannot be verified when it is in use."
+ "The volume %s was formatted by %s and last modified by %s."
+ "The volume %s with UUID %s appears to be OK."
+ "The volume %s with UUID %s could not be repaired."
+ "The volume %s with UUID %s could not be verified completely and can not be repaired."
+ "The volume %s with UUID %s could not be verified completely."
+ "The volume %s with UUID %s was found to be corrupt and cannot be repaired."
+ "The volume %s with UUID %s was found to be corrupt and needs to be repaired."
+ "The volume %s with UUID %s was repaired successfully."
+ "The volume name is %s"
+ "The volume was modified"
+ "Too many warnings of this type generated; suppressing subsequent ones.\n"
+ "Total blocks allocated by spaceman: %llu\n\n"
+ "Tree node repair failed."
+ "Trimming unused blocks."
+ "Truncate alloced_size to block size? "
+ "Truncate size to alloced size? "
+ "Try running fsck against the entire APFS container instead of a volume\n"
+ "UNKNOWN"
+ "UNKNOWN-DEV"
+ "Unable to perform deferred repairs without full space verification\n"
+ "Unknown type %d"
+ "Unset unknown flags? (0x%llx) "
+ "Update %s objects? "
+ "Update the parent's minkey? "
+ "VERIFY"
+ "Verifying allocated space."
+ "Verifying volume object map space."
+ "Volume %s has revert_to_xid set, skipping the fsroot tree.\n"
+ "Volume %s is encrypted and crypto I/O failed/was skipped, skipping the fsroot tree.\n"
+ "Volume %s is incompletely restored, skipping the fsroot tree.\n"
+ "Volume object map space verification failed."
+ "Volume superblock is invalid."
+ "Xattr"
+ "YES\n"
+ "_INO_EXT_TYPE_VOLNAME"
+ "_dev_for_obj_io"
+ "_has_expanded_records(volume)"
+ "_resource"
+ "_xp_lookup_obj"
+ "a"
+ "a leaf"
+ "a root"
+ "aborting jobj validations for current fsck pass - trying to repair fsroot tree with invalid nodes\n"
+ "aborting purgeable cross checks - out of memory\n"
+ "add_xfield"
+ "added > removed"
+ "advance"
+ "allocated_memory <= UINT64_MAX - block_size"
+ "allocated_memory >= block_size"
+ "alloced_size (%llu) of dstream (id %llu) does not match calculated size (%llu)\n"
+ "alloced_size (%llu) of dstream (id %llu, object-id %llu) does not match minimum found size (%llu)\n"
+ "alloced_size of dstream (object-id %llu) does not match minimum found size (%llu)\n"
+ "an origin and "
+ "any"
+ "apfs object (oid 0x%llx): cpflags (%u) should be 0\n"
+ "apfs object (oid 0x%llx): crypto major version (%u) is not CP_CURRENT (%u)\n"
+ "apfs superblock at index %u: apfs reserve alloc count (%llu) is greater than spaceman reserve alloc count (%llu) for a guaranteed-minimum space FS\n"
+ "apfs superblock at index %u: apfs_doc_id_fixup_cursor (%llu) is greater than or equal to apfs_next_obj_id (%llu)\n"
+ "apfs superblock at index %u: apfs_doc_id_fixup_cursor is set (%llu), despite apfs_doc_id_index_flags (0x%x)\n"
+ "apfs superblock at index %u: apfs_doc_id_index_flags has unrecognized flags (0x%x)\n"
+ "apfs superblock at index %u: apfs_doc_id_index_xid (%llu) is greater than or equal to container nx_next_xid (%llu)\n"
+ "apfs superblock at index %u: apfs_doc_id_tree_type is invalid: %u\n"
+ "apfs superblock at index %u: apfs_extentref_tree_oid is invalid.\n"
+ "apfs superblock at index %u: apfs_extentref_tree_type is invalid: 0x%x\n"
+ "apfs superblock at index %u: apfs_features has unrecognized features (0x%llX)\n"
+ "apfs superblock at index %u: apfs_fext_tree_oid is invalid.\n"
+ "apfs superblock at index %u: apfs_fext_tree_type is invalid: %u\n"
+ "apfs superblock at index %u: apfs_formatted_by.id (%.*s) is not NULL terminated.\n"
+ "apfs superblock at index %u: apfs_formatted_by.last_xid (0x%llx) is greater than nx_next_xid (0x%llx)\n"
+ "apfs superblock at index %u: apfs_formatted_by.timestamp (%llu) is greater than current time (%llu)\n"
+ "apfs superblock at index %u: apfs_fs_alloc_count (%llu) is greater than container wide allocated count (%llu)\n"
+ "apfs superblock at index %u: apfs_fs_alloc_count (%llu) must not be greater than apfs_fs_quota_block_count (%llu)\n"
+ "apfs superblock at index %u: apfs_fs_flags (0x%llx) PFK bit inconsistent with apfs_incompatible_features (0x%llx) PFK bit\n"
+ "apfs superblock at index %u: apfs_fs_flags (0x%llx) inconsistent with apfs_incompatible_features secondary fsroot bit (0x%llx)\n"
+ "apfs superblock at index %u: apfs_fs_flags (0x%llx) indicates sealed volume is not fully unencrypted\n"
+ "apfs superblock at index %u: apfs_fs_flags (0x%llx) previously sealed bit inconsistent with apfs_incompatible_features (0x%llx) / apfs_integrity_meta_oid (%llu) / apfs_fext_tree_oid (%llu)\n"
+ "apfs superblock at index %u: apfs_fs_flags has an unknown flag set 0x%llx\n"
+ "apfs superblock at index %u: apfs_fs_flags has conflicting encryption flags 0x%llx\n"
+ "apfs superblock at index %u: apfs_fs_quota_block_count (%llu) should not be greater than nx_block_count (%llu) for an FS with quota\n"
+ "apfs superblock at index %u: apfs_fs_reserve_block_count (%llu) is greater than spaceman reserve block count (%llu) for a guaranteed-minimum space FS\n"
+ "apfs superblock at index %u: apfs_fs_reserve_block_count (%llu) is greater than the container block count (%llu)\n"
+ "apfs superblock at index %u: apfs_fs_reserve_block_count (%llu) must not be greater than apfs_fs_quota_block_count (%llu)\n"
+ "apfs superblock at index %u: apfs_incompatible_features has unsupported flags: (0x%llX)\n"
+ "apfs superblock at index %u: apfs_integrity_meta_oid is invalid.\n"
+ "apfs superblock at index %u: apfs_last_mod_time (%llu) is greater than current time (%llu)\n"
+ "apfs superblock at index %u: apfs_magic invalid: %d\n"
+ "apfs superblock at index %u: apfs_modified_by[%d].id (%.*s) is not NULL terminated.\n"
+ "apfs superblock at index %u: apfs_modified_by[%d].last_xid (0x%llx) is greater than nx_next_xid (0x%llx)\n"
+ "apfs superblock at index %u: apfs_modified_by[%d].timestamp (%llu) is greater than current time (%llu)\n"
+ "apfs superblock at index %u: apfs_next_doc_id (%u) should not be less than MIN_DOC_ID (%d)\n"
+ "apfs superblock at index %u: apfs_omap_oid is invalid.\n"
+ "apfs superblock at index %u: apfs_pfkur_tree_oid is invalid.\n"
+ "apfs superblock at index %u: apfs_pfkur_tree_type is invalid: 0x%x\n"
+ "apfs superblock at index %u: apfs_prev_doc_id_tree_oid is set (%llu), despite apfs_doc_id_index_flags (0x%x)\n"
+ "apfs superblock at index %u: apfs_readonly_compatible_features has unsupported flags: (0x%llX)\n"
+ "apfs superblock at index %u: apfs_revert_to_xid (%llu) should be less than nx_next_xid (%llu)\n"
+ "apfs superblock at index %u: apfs_revert_to_xid is %llu, but sblock oid is invalid\n"
+ "apfs superblock at index %u: apfs_root_tree_oid is invalid.\n"
+ "apfs superblock at index %u: apfs_root_tree_type is invalid: 0x%x\n"
+ "apfs superblock at index %u: apfs_sec_root_tree_oid (%llu) set on incompatible volume\n"
+ "apfs superblock at index %u: apfs_sec_root_tree_oid is invalid\n"
+ "apfs superblock at index %u: apfs_sec_root_tree_type is invalid\n"
+ "apfs superblock at index %u: apfs_snap_meta_tree_type is invalid: 0x%x\n"
+ "apfs superblock at index %u: apfs_total_blocks_freed (%llu) should not be greater than apfs_total_blocks_alloced (%llu)\n"
+ "apfs superblock at index %u: apfs_unmount_time (%llu) is greater than current time (%llu)\n"
+ "apfs superblock at index %u: apfs_vol_uuid is NULL\n"
+ "apfs superblock at index %u: apfs_volname (%.*s) is not NULL terminated.\n"
+ "apfs superblock at index %u: apfs_volname[0] == 0\n"
+ "apfs superblock at index %u: incompatible features set (apfs_readonly_compatible_features: (0x%llX), apfs_incompatible_features: (0x%llX))\n"
+ "apfs superblock at index %u: unknown clone group tree flags: 0x%x\n"
+ "apfs-clonegroup-lock-mutex"
+ "apfs_clonegroup_next_id is not valid (expected %llu, actual %llu)\n"
+ "apfs_deletefs_ext"
+ "apfs_extentref: "
+ "apfs_fs_alloc_count is not valid (expected %llu, actual %llu)\n"
+ "apfs_fs_index (%d) is not valid (%d)\n"
+ "apfs_fs_reserve_block_count brings total reserve block count beyond the container block count (max %llu, actual %llu)\n"
+ "apfs_next_doc_id is not valid (expected %u, actual %u)\n"
+ "apfs_next_obj_id is not valid (expected %llu, actual %llu)\n"
+ "apfs_num_directories is not valid (expected %llu, actual %llu)\n"
+ "apfs_num_files is not valid (expected %llu, actual %llu)\n"
+ "apfs_num_other_fsobjects is not valid (expected %llu, actual %llu)\n"
+ "apfs_num_snapshots is not valid (expected %llu, actual %llu)\n"
+ "apfs_num_symlinks is not valid (expected %llu, actual %llu)\n"
+ "apfs_root: "
+ "apfs_sb: object (oid 0x%llx): apfs_snap_meta_ext_oid invalid\n"
+ "apfs_sec_root: "
+ "apfs_snap_meta: "
+ "appexPrintInternal"
+ "bitmap store: address %llu is beyond maximum allowed %llu\n"
+ "bitmap store: reached limit of %llu B-tree nodes\n"
+ "bitmap was not entirely set, stopping deallocation\n"
+ "bitmap was not entirely unset, stopping allocation\n"
+ "bitmap_store.c"
+ "bits_per_spaceman_bitmap % bits_per_word == 0"
+ "block 0 superblock"
+ "block count"
+ "block_size != 0"
+ "blockcopy: unable to allocate memory for buffer_size 0x%zx.\n"
+ "blockcopy: unable to read paddr 0x%llx block_count 0x%llx: %s\n"
+ "blockcopy: unable to write paddr 0x%llx block_count 0x%llx: %s\n"
+ "bm_bit_count %llu is not an integer multiple of container block count %llu\n"
+ "bt"
+ "btn->btn_table_space.len / sizeof *toc > btn->btn_nkeys"
+ "btn->btn_table_space.len / sizeof *toc >= btn->btn_nkeys"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_fixed.bt_flags (0x%x)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_fixed.bt_flags (0x%x), given mt_btflags\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_fixed.bt_key_size (%u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_fixed.bt_key_size (%u), given btn_btree.bt_fixed.bt_flags (0x%x)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_fixed.bt_key_size (%u), given btn_flags (0x%x)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_fixed.bt_key_size (%u), given mt_key_size (%u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_fixed.bt_node_size (%u), given mt_node_size (%u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_fixed.bt_val_size (%u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_fixed.bt_val_size (%u), given btn_flags (0x%x)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_fixed.bt_val_size (%u), given mt_val_size (%u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_key_count (expected %llu, actual %llu)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_key_count (overflow)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_longest_key (%u), given btn_btree.bt_fixed.bt_key_size (%u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_longest_key (expected %u, actual %u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_longest_val (%u), given btn_btree.bt_fixed.bt_val_size (%u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_longest_val (expected %u, actual %u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_node_count (expected %llu, actual %llu)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_node_count (overflow)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_flags (0x%x), given btn_btree.bt_fixed.bt_key_size (%u) and btn_btree.bt_fixed.bt_val_size (%u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_flags (0x%x), given btn_level (%u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_flags (0x%x), given btree node is %s\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_free_space (%u, %u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_free_space (%u, %u), given total key length (%u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_free_space (%u, %u), given total value length (%u) (%d %d %d = %d)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_key_free_list entry (%u, %u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_key_free_list length (%u), given total key length (%u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_key_free_list offset %u\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_key_free_list, btn_val_free_list, or btn_free_space: %s\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_level (%u), given btree node is %s\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_level (expected %u, actual %u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_nkeys (%u), given btn_flags (0x%x)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_nkeys (%u), given btn_table_space.len (%u) and toc_entry_size (%u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_table_space (%u, %u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_table_space (%u, %u), given btn_flags (0x%x)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_table_space.len (%u), given toc_entry_size (%u) and btn_flags (0x%x)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_val_free_list entry (%u, %u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_val_free_list length (%u), given total value length (%u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_val_free_list offset %u\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid key (%u, %u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid key order: index %u is %s index %u (should be less than)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid key order: index %u is %s maxkey (should be less than)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid key order: minkey is %s index 0 (should be equal)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid value (%u, %u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: key (%u) compare error: %d\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: missing btn_flags (expected 0x%x, actual 0x%x)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: parent doesn't have enough space to update the minkey\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: unable to repair minkey\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: unexpected btn_btree.bt_fixed.bt_flags (0x%x)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: unexpected btn_flags (0x%x)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: validate_loc_ctx_alloc failed for btn_nkeys (%u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nwarning: btn: can't compare key (%u) with key (%u)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nwarning: btn: invalid btn_btree.bt_fixed.bt_flags (0x%x)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nwarning: btn: invalid btn_flags (0x%x)\n"
+ "btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nwarning: btn: invalid cpm_size or ov_size (%u), given btn_btree.bt_fixed.bt_node_size (%u)\n"
+ "btree node"
+ "btree node (oid (0%llx)) being reaped has invalid val_len (%u) at index (%d) \n"
+ "btree node (oid (0%llx)) being reaped is hashed\n"
+ "btree_height_decrease"
+ "btree_height_increase"
+ "btree_info->bt_hash_size"
+ "btree_info->bt_hash_type"
+ "btree_insert"
+ "btree_insert_internal"
+ "btree_lookup"
+ "btree_node_free_list_get"
+ "btree_node_insert_entry"
+ "btree_node_insert_maybe"
+ "btree_node_insert_multiple"
+ "btree_node_is_leaf(btn)"
+ "btree_node_is_leaf(root) || !newbtn2"
+ "btree_node_key_len"
+ "btree_node_key_off"
+ "btree_node_move_entries"
+ "btree_node_remove_entry"
+ "btree_node_split"
+ "btree_node_toc_insert"
+ "btree_node_toc_key_set"
+ "btree_node_toc_remove"
+ "btree_node_toc_val_set"
+ "btree_node_update_maybe"
+ "btree_node_val_len"
+ "btree_node_val_off"
+ "btree_node_validate"
+ "btree_node_write"
+ "btree_remove_rec"
+ "buffer != NULL"
+ "cab"
+ "can't add attribution tag for clone mapping: %s (%d)\n"
+ "can't add clone mapping (private_id %llu, file_id %llu) for repairs: %s (%d)\n"
+ "can't add clone size for dir-stats: %s (%d)\n"
+ "can't add dir stats key for clone mapping: %s (%d)\n"
+ "can't add orphan clone mapping (private_id %llu, file_id %llu) to the fsck repairs: %s (%d)\n"
+ "can't add purgeable resource fork size for dir-stats: %s (%d)\n"
+ "can't add purgeable size for dir-stats: %s (%d)\n"
+ "can't allocate memory to insert a new clone mapping value\n"
+ "can't remove orphan clone mapping (private_id %llu, file_id %llu): %s (%d)\n"
+ "can't unmark purgeable (file_id %llu) for cross checks\n"
+ "cannot find checkpoint area because container superblock is too damaged\n"
+ "category"
+ "chained key of dir-stats object (id %llu) does not match expected value (%llu)\n"
+ "checkpoint %d (xid %llu) checkpoint map is invalid\n"
+ "checkpoint %d (xid %llu) failed consistency check\n"
+ "checkpoint %d (xid %llu) fsck_obj_phys failed\n"
+ "checkpoint %d (xid %llu) superblock disagrees with block 0\n"
+ "checkpoint %d (xid %llu) superblock is invalid\n"
+ "checkpoint %d fsck_obj_phys failed\n"
+ "checkpoint %d obj->o_type is invalid: (0x%x)\n"
+ "checkpoint map o_xid (0x%llx) doesn't match checkpoint superblock o_xid (0x%llx)\n"
+ "checkpoint<->%s mismatch on fusion uuid\n"
+ "checkpoint<->%s mismatch on nx_block_count: %lld %lld\n"
+ "checkpoint<->%s mismatch on nx_block_size: %d %d\n"
+ "checkpoint<->%s mismatch on nx_xp_data_base: %lld %lld\n"
+ "checkpoint<->%s mismatch on nx_xp_data_blocks: %d %d\n"
+ "checkpoint<->%s mismatch on nx_xp_desc_base: %lld %lld\n"
+ "checkpoint<->%s mismatch on nx_xp_desc_blocks: %d %d\n"
+ "checkpoint<->%s mismatch on uuid\n"
+ "checksum block size is invalid, checksum_block_size enum: %llu\n"
+ "checksum_count (%u) exceeds max checksums (%u)\n"
+ "childbtn->btn_nkeys != 0 || !newbtn"
+ "childbtn->btn_nkeys == 0"
+ "cib"
+ "cib: ci_free_count (%u) is not valid (%llu) (ci_addr 0x%llx)\n"
+ "clone group mapping record exists for (group_id %llu, private_id %llu, file_id %llu), but no inode refers to it\n"
+ "clone group tree (id %llu): invalid key length (%u)\n"
+ "clone group tree: group_id (%llu) is invalid\n"
+ "clone group tree: invalid key length (%u)\n"
+ "clone group tree: unknown type (%u)\n"
+ "clone mapping"
+ "clone mapping (private_id %llu, file_id %llu) is missing\n"
+ "clone mapping (private_id %llu, file_id %llu) is orphan\n"
+ "clone mapping (private_id %llu, file_id %llu): attribution tag (%llu) != inode (id %llu) attribution tag (%llu)\n"
+ "clone mapping (private_id %llu, file_id %llu): compressed physical size (%llu) != inode (id %llu) compressed physical size (%llu)\n"
+ "clone mapping (private_id %llu, file_id %llu): dir stats key (%llu) != inode (id %llu) dir stats key (%llu)\n"
+ "clone mapping (private_id %llu, file_id %llu): failed to update attribution tag %llu: %s (%d)\n"
+ "clone mapping (private_id %llu, file_id %llu): failed to update dir stats %llu: %s (%d)\n"
+ "clone mapping (private_id %llu, file_id %llu): invalid file_id\n"
+ "clone mapping (private_id %llu, file_id %llu): invalid physical_size (%llu)\n"
+ "clone mapping (private_id %llu, file_id %llu): invalid private_id\n"
+ "clone mapping (private_id %llu, file_id %llu): invalid xfields\n"
+ "clone mapping (private_id %llu, file_id %llu): physical size (%llu) != inode (id %llu) physical size (%llu)\n"
+ "clone mapping (private_id %llu, file_id %llu): purgeable status is different than inode (id %llu) purgeable status\n"
+ "clone mapping (private_id %llu, file_id %llu): unknown flags (0x%x / known flags are: 0x%x)\n"
+ "clone size (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n"
+ "clone size xfield is missing from dir-stats object (id %llu)\n"
+ "clone size xfield of dir-stats object (id %llu) exists unexpectedly\n"
+ "clone_mapping_finalize"
+ "cloned dstream (id %llu, object-ids %s) is being truncated\n"
+ "clonegroup"
+ "clonegroup (group id %llu, private_id %llu, file id %llu): can't register for cross checks: %d (%s)\n"
+ "clonegroup (group id %llu, private_id %llu, file id %llu): inum is invalid\n"
+ "clonegroup (group id %llu, private_id %llu, file id %llu): invalid physical_size (%llu)\n"
+ "clonegroup (group id %llu, private_id %llu, file id %llu): invalid value length (%u)\n"
+ "clonegroup (group id %llu, private_id %llu, file id %llu): invalid xfields\n"
+ "clonegroup (group id %llu, private_id %llu, file id %llu): private_id is invalid\n"
+ "clonegroup (group id %llu, private_id %llu, file id %llu): unknown flags (0x%x / known flags are: 0x%x)"
+ "clonegroup_tree: "
+ "cmp_map[%d].cpm_subtype object type (0x%x) is invalid!\n"
+ "code"
+ "com.apple.FinderInfo"
+ "com.apple.ResourceFork"
+ "com.apple.apfs."
+ "com.apple.decmpfs"
+ "com.apple.fs.altlink"
+ "com.apple.fs.cow-exempt-file-count"
+ "com.apple.fs.firmlink"
+ "com.apple.fs.graft-jobj-id-base"
+ "com.apple.fs.graft-jobj-id-len"
+ "com.apple.fs.graft-vol-uuid"
+ "com.apple.fs.symlink"
+ "com.apple.system.Security"
+ "com.apple.system.apfs.ierso"
+ "com.apple.system.fs.speculative_telemetry"
+ "component->index < component->btn->btn_nkeys"
+ "compression xattr (id %llu): compression magic is unknown: 0x%x\n"
+ "compression xattr (id %llu): internal flags are invalid (0x%x)\n"
+ "compression xattr (id %llu): size is too small, actual: %u, minimum: %lu\n"
+ "connection"
+ "container"
+ "container %s is mounted with write access.\n"
+ "container %s is mounted with write access; please re-run with -l.\n"
+ "container %s is mounted.\n"
+ "container %s is mounted. repairs in a mounted container is not supported yet.\n"
+ "container has been mounted by APFS version %s, which is newer than %s\n"
+ "container keybag"
+ "container omap"
+ "container->spaceman->sm_fq[q].sfq_tree_oid == sfqt->t_root_oid"
+ "containerID"
+ "container_freeze"
+ "container_info.any_volume_mount_point == NULL"
+ "container_info.volume_mount_point == NULL"
+ "context->fs_oid == _fs_oid(fsck_btree->volume)"
+ "context->fs_oid == _fs_oid(volume)"
+ "could not cache physical extent repair at %llu error: %s\n"
+ "could not freeze volume: %s\n"
+ "could not insert extent with range (%llu + %llu) for physical extent repair: %s\n"
+ "could not look up cpm_map[%d].cpm_paddr (%llu) in checkpoint data area\n"
+ "could not lookup extent at %llu for physical extent repair: %s\n"
+ "could not open %s to freeze the volume: %s\n"
+ "could not remove extent at %llu for physical extent repair: %s\n"
+ "could not retrieve er_state_phys_t\n"
+ "could not retrieve erb, oid 0x%llx\n"
+ "could not retrieve gbitmap from er_state_phys_t\n"
+ "could not sync and freeze volume: %s\n"
+ "count"
+ "count % bits_per_word == 0"
+ "cpm"
+ "cpm_count (%u) is larger than the max that this block size can accommodate (%u)\n"
+ "cpm_count is 0\n"
+ "cpm_flags has an unknown flag set 0x%x\n"
+ "cpm_flags has invalid flags set: 0x%x\n"
+ "cpm_map[%d].cpm_fs_oid (%llu) is less than minimum oid (%u)!\n"
+ "cpm_map[%d].cpm_oid object type is invalid!\n"
+ "cpm_map[%d].cpm_paddr (%llu) + cpm_size (%u) is not in the checkpoint data area\n"
+ "cpm_map[%d].cpm_subtype has nonzero storage type (0x%x)\n"
+ "cpm_map[%d].cpm_type object type (0x%x) is invalid!\n"
+ "cpm_map[%d].cpm_type storage type (0x%x) != OBJ_EPHEMERAL\n"
+ "cpm_o.o_oid (0x%llx) doesn't match the physical address (0x%llx)\n"
+ "crypto"
+ "crypto state"
+ "crypto_finalize"
+ "crypto_id_from_fext"
+ "crypto_key != jobj_id"
+ "crypto_key_index >= APFS_FS_CRYPTO_KEY_INDEX_MIN && crypto_key_index <= APFS_FS_CRYPTO_KEY_INDEX_MAX"
+ "crypto_port == IO_OBJECT_NULL"
+ "crypto_register"
+ "crypto_repair_missing_cs"
+ "crypto_val.computed_refcnt >= 0"
+ "crypto_val.cryptostate_refcnt == 0"
+ "crypto_val.cryptostate_refcnt > crypto_val.computed_refcnt"
+ "ctx != NULL"
+ "ctx == NULL"
+ "curr_dir_stats.SAF_descendants >= tree_dir_stats.SAF_descendants"
+ "curr_dir_stats.chained_key.computed == 0"
+ "curr_dir_stats.chained_key.present == 0"
+ "curr_dir_stats.clone_size.computed >= tree_dir_stats.clone_size.computed"
+ "curr_dir_stats.descendants.computed >= tree_dir_stats.descendants.computed"
+ "curr_dir_stats.descendants.present == 0"
+ "curr_dir_stats.dir_stats_descendants >= tree_dir_stats.dir_stats_descendants"
+ "curr_dir_stats.origin_id.present == 0"
+ "curr_dir_stats.physical_size.computed >= tree_dir_stats.physical_size.computed"
+ "curr_dir_stats.physical_size.present == 0"
+ "curr_dir_stats.purgeable_rsrc_size.computed >= tree_dir_stats.purgeable_rsrc_size.computed"
+ "curr_dir_stats.purgeable_size.computed >= tree_dir_stats.purgeable_size.computed"
+ "curr_dir_stats.resource_fork_size.computed >= tree_dir_stats.resource_fork_size.computed"
+ "curr_dir_stats.resource_fork_size.present == 0"
+ "curr_dir_stats.shadow_key == 0"
+ "curr_dir_stats_id == dir_stats_id"
+ "curr_dstream_id && curr_dstream_id == OBJ_ID_FROM_KEY(*dsid_key)"
+ "curr_dstream_id && curr_dstream_id == OBJ_ID_FROM_KEY(fe_key->hdr)"
+ "curr_dstream_id && curr_dstream_id == OBJ_ID_FROM_KEY(fi_key->hdr)"
+ "data_hash: object (oid 0x%llx): Found unexpected hash at offset %llu (expected length %llu)\n"
+ "data_hash: object (oid 0x%llx): Invalid length at offset %llu\n"
+ "data_hash: object (oid 0x%llx): Missing hash at offset %llu (found %llu)\n"
+ "def-prot-class: %d \n"
+ "descendants (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n"
+ "descendants of dir-stats object (id %llu) does not match expected value (%llu)\n"
+ "detected chained-key loop involving dir-stats %llu\n"
+ "detected invalid fsroot tree nodes (& thus data loss), pruning the nodes to make the system usable\n"
+ "dev_is_mounted(%s) failed with error: %s\n"
+ "dev_read"
+ "dev_read(%llu, 1): %s\n"
+ "dev_read_async"
+ "dev_read_finish"
+ "dev_reload_validate"
+ "device %s failed to open with error: %s\n"
+ "didCompleteWithError:"
+ "dir stats"
+ "dir stats repairs"
+ "dir-stats (id %llu) is missing\n"
+ "dir-stats descendants"
+ "dir-stats object (id %llu) is SAF, but its origin isn't\n"
+ "dir-stats object (id %llu) is purgeable, but it doesn't track purgeable size\n"
+ "dir-stats object (id %llu) is purgeable, but its origin isn't\n"
+ "dir-stats object (id %llu) unexpectedly marked as having origin-id\n"
+ "dir-stats object (id %llu) unexpectedly unmarked as having origin-id\n"
+ "dir-stats object (id %llu): %s overflow\n"
+ "dir_id == current_dir.dir_id"
+ "dir_nlink of inode object (id %llu) does not match expected value (%d)\n"
+ "dir_register_nchildren"
+ "dir_register_nlink"
+ "dir_stats (id %llu) already has a registered origin (id %llu), but we found another one (id %llu)\n"
+ "dir_stats_finalize"
+ "dir_stats_finalize_sort_entries"
+ "dir_stats_insert"
+ "dir_stats_is_expanded"
+ "dir_stats_mark_chain_as_needing_reconciliation"
+ "dir_stats_register_any_dir_stats"
+ "dir_stats_register_descendant"
+ "dir_stats_register_origin"
+ "dir_stats_register_purgeable"
+ "dir_stats_register_purgeable_rsrc"
+ "dir_stats_register_resource_fork"
+ "dir_stats_reset"
+ "dir_stats_update_clone_size"
+ "dir_stats_verify_no_shadow_key"
+ "dir_stats_verify_not_calculating(dir_stats)"
+ "directory"
+ "directory record"
+ "directory stats"
+ "directory valence check: directory (oid 0x%llx): nchildren (%d) does not match drec count (%d)\n"
+ "directory valence check: directory (oid 0x%llx): nlink (%d) does not match subdirectory count (%d)\n"
+ "directory valence check: directory (oid 0x%llx): orphan directory record\n"
+ "disabling overallocation repairs by default; use -o to override\n"
+ "dispatchAsyncBlock:"
+ "doc id"
+ "doc-id tree record exists for doc-id %u, but no inode references this doc-id\n"
+ "doc-id tree: record exists for doc-id %u, file-id %llu but no inode references this doc-id\n"
+ "down"
+ "drec count overflow (%d)\n"
+ "dstream"
+ "dstream (id %llu) does not have an associated dstream id object\n"
+ "dstream (id %llu) is older than the current dstream (id %llu)\n"
+ "dstream id"
+ "dstream.dstream_id_refcnt == 0"
+ "dstream_field != NULL"
+ "dstream_finalize"
+ "dstream_id"
+ "dstream_register_dstream_id"
+ "dstream_register_fext"
+ "dstream_register_hash"
+ "dstream_register_purgeable_ts"
+ "dstream_scan_fexts"
+ "dstream_scan_inodes"
+ "dstream_update_uncompressed_size"
+ "efi_jumpstart"
+ "enabling overallocation repairs because -o was passed; this may cause data loss\n"
+ "encryption rolling"
+ "encryption rolling gbitmap tree is invalid\n"
+ "encryption rolling recovery block offset mismatch, oid 0x%llx, expected %llu, actual %llu\n"
+ "encryption rolling recovery block with data size 0, oid 0x%llx, nx_block_size %u, recovery length %llu\n"
+ "encryption rolling recovery data extends past recovery length, oid 0x%llx, ersb_recovery_length %llu, accumulated length %llu\n"
+ "entry && entry->off != BTOFF_INVALID && entry->off != BTOFF_MT_GHOST"
+ "equal to"
+ "er_state"
+ "er_state magic number is %d, should be %d\n"
+ "er_state->ersb_version is %d, should be at most %d\n"
+ "error %d from cond wait\n"
+ "error (%d) getting cab %u @ %lld\n"
+ "error (%d) getting cib %d bitmap %d @ %lld\n"
+ "error (%d) getting cib %u @ %lld\n"
+ "error (%d) getting cib bitmap %d @ %lld\n"
+ "error (%d) getting spaceman IP bitmap block %u @ %lld\n"
+ "error (%d) looking up spaceman IP bitmap block %u\n"
+ "error (%d) looking up spaceman IP bitmap block at index %u\n"
+ "error (%d) looking up spaceman IP block %llu\n"
+ "error (%d) looking up spaceman IP block address at index %llu\n"
+ "error (%d) looking up spaceman IP block address at index %u\n"
+ "error (%d) reading spaceman IP bitmap block at index %u, addr 0x%llx\n"
+ "error (%d) writing bitmap @ %lld\n"
+ "error (%d) writing cib\n"
+ "error (%d) writing cib %u @ %lld\n"
+ "error (%d) writing cib during deallocation\n"
+ "error (%d) writing spaceman IP bitmap %d @ %lld\n"
+ "error (%s) failed to get cib for chunk index %llu \n"
+ "error (%s) failed to populate free queue trees \n"
+ "error == 0"
+ "error aborting transaction: %s\n"
+ "error allocating encryption rolling recovery data buffer, ersb_recovery_length %llu\n"
+ "error copying on-disk free queue tree into reordered tree in memory: %s\n"
+ "error ending transaction: %s\n"
+ "error iterating fsroot tree (xid %llu) for tree node repairs: %s\n"
+ "error iterating fsroot tree during dstream repair: %s\n"
+ "error iterating fsroot tree for file lookup in directory: %s\n"
+ "error iterating omap tree for repair: %s\n"
+ "error iterating physical extent tree: %s\n"
+ "error iterating snapshot tree: %s\n"
+ "error iterating trees during free queue tree repair: %s\n"
+ "error iterating trees during snapshot repair: %s\n"
+ "error starting transaction: %s\n"
+ "error updating omap entry: %s\n"
+ "error updating omap_snap entry: %s\n"
+ "error updating snap_meta entry: %s\n"
+ "error updating the reap list: %s\n"
+ "error writing object: %s\n"
+ "error: "
+ "errorWithDomain:code:userInfo:"
+ "ersb_flags (0x%llx) has ERSB_FLAG_PAUSED on but checksum count is non-zero (%u)\n"
+ "ersb_flags (0x%llx) has ERSB_FLAG_PAUSED on but ersb_recovery_extents_count is non-zero (%llu)\n"
+ "ersb_progress (%llu) exceeds ersb_total_blk_to_encrypt (%llu)\n"
+ "ersb_recovery_extents_count == 0, but ersb_recovery_length is non-zero (%llu)\n"
+ "ersb_recovery_extents_count == 0, but ersb_recovery_list_oid is non-zero (0x%llx)\n"
+ "ersb_recovery_extents_count is %llu, extent descriptor size is %zu, expected descriptors length is %llu > ersb_recovery_length %llu\n"
+ "ersb_recovery_extents_count is non-zero (%llu), but ersb_recovery_length == 0\n"
+ "ersb_recovery_extents_count is non-zero (%llu), but ersb_recovery_list_oid == 0\n"
+ "ersb_recovery_length (%llu) exceeds recovery length limit (%llu), some checks will be disabled\n"
+ "ersb_snap_xid (%llu) is greater than or equal to container next xid (%llu)\n"
+ "ersb_total_blk_to_encrypt (%llu) exceeds bm_bit_count (%llu)\n"
+ "ersb_total_blk_to_encrypt (%llu) exceeds device block count (%llu)\n"
+ "ersb_version is %d, unsupported\n"
+ "evict mapping range is invalid: (0x%llx+%llu --> 0x%llx+%llu)\n"
+ "evict_mapping_tree: "
+ "expanded directory stats"
+ "expanded key (id %llu) on incompatible volume\n"
+ "extended attribute"
+ "extended attribute (id %llu, name %.*s) is orphan\n"
+ "extent"
+ "extent ref tree"
+ "extent_list: "
+ "extract_clonegroup_key"
+ "extract_doc_id_key"
+ "extract_jobj_key"
+ "extract_omap_key"
+ "extract_omap_snap_key"
+ "extract_pfkur_key"
+ "extract_phys_ext_snap_xid"
+ "extract_snap_meta_key"
+ "extract_snap_name_key"
+ "extract_xattr_key"
+ "failed to add doc-id repair (deletion), doc-id %u : %s\n"
+ "failed to add doc-id tree repair record, doc-id %u : %s\n"
+ "failed to allocate dir-stack memory for lookup in directory\n"
+ "failed to allocate dir-stack memory for lookup in directory: %s; results may be incomplete\n"
+ "failed to allocate memory for bitmap store\n"
+ "failed to allocate memory for device path\n"
+ "failed to allocate memory for dir-stats lookup\n"
+ "failed to allocate memory for file lookup in purgatory directory\n"
+ "failed to allocate memory for fsck_state\n"
+ "failed to allocate memory for insertion of dir-stats\n"
+ "failed to allocate memory for lookup in directory\n"
+ "failed to allocate memory for repair\n"
+ "failed to allocate memory for snapshot repair\n"
+ "failed to allocate memory for snapshot tracking\n"
+ "failed to allocate memory for snapshot validation\n"
+ "failed to allocate memory for the bitmap block\n"
+ "failed to allocate memory for the extentref tree\n"
+ "failed to allocate memory to add an xfield\n"
+ "failed to allocate memory to find dir-stats %llu\n"
+ "failed to allocate memory to mark dir-stats chain as inconsistent\n"
+ "failed to allocate memory to read the container superblock\n"
+ "failed to cross check purgeable inode: %d (%s)\n"
+ "failed to cross check purgeable record: %d (%s)\n"
+ "failed to enable crypto I/O mode for container %s: %s\n"
+ "failed to enqueue clone group mapping (group_id %llu, private_id %llu, file_id %llu) for deletion: %s\n"
+ "failed to enqueue purgeable record (file id %llu, atime %llu) for remove\n"
+ "failed to find node at segment (%llu) : error %s\n"
+ "failed to finish pending reads from the bitmap iterator: %d (%s)"
+ "failed to get cib for chunk index %llu: %s\n"
+ "failed to get fsroot tree for jobj type %d: %s\n"
+ "failed to get fsroot tree to find expanded dir-stats %llu: %s\n"
+ "failed to get inode (id %llu) dstream: %s\n"
+ "failed to init fsroot tree for file lookup in directory\n"
+ "failed to init fsroot tree for file lookup in purgatory directory\n"
+ "failed to init fsroot tree for lookup in directory\n"
+ "failed to init fsroot tree to mark dir-stats chain as inconsistent\n"
+ "failed to init fsroot tree to repair dir-stats chained key\n"
+ "failed to init the dir stats repair tree\n"
+ "failed to initialize the clone group tree: %s\n"
+ "failed to initialize the clone-group tree: %s\n"
+ "failed to initialize the doc-id tree: %s\n"
+ "failed to initialize the extentref tree: %s\n"
+ "failed to initialize the fext tree: %s\n"
+ "failed to initialize the fsroot tree: %s\n"
+ "failed to initialize the omap snap tree: %s\n"
+ "failed to initialize the omap tree: %s\n"
+ "failed to initialize the pfkur tree: %s\n"
+ "failed to initialize the prev doc-id tree: %s\n"
+ "failed to initialize the secondary fsroot tree: %s\n"
+ "failed to initialize the snap meta tree: %s\n"
+ "failed to initialize the spaceman free queue tree %d: %s\n"
+ "failed to initialize tree for container repairs\n"
+ "failed to initialize tree for volume repairs\n"
+ "failed to insert %s object: %s\n"
+ "failed to insert cached doc-id record, doc-id %u,file-id %llu : %s\n"
+ "failed to insert clone mapping (private_id %llu,  file_id %llu, flags 0x%x): %s (%d)\n"
+ "failed to insert dir-stats entry %llu into the repair tree\n"
+ "failed to insert doc-id tree repair for doc-id %u, file-id %llu : %s\n"
+ "failed to insert node at segment (%llu) error : %s\n"
+ "failed to insert purgeable (file_id %llu): %s (%d)\n"
+ "failed to insert snap_name entry: %s\n"
+ "failed to iterate the spaceman free queue tree: %s\n"
+ "failed to look up checkpoint block address %d: %s\n"
+ "failed to look up checkpoint block address: %s\n"
+ "failed to look up crypto state object (id %llu): %s\n"
+ "failed to look up dir-stats object (id %llu): %s\n"
+ "failed to look up dstream id object (id %llu): %s\n"
+ "failed to lookup %s object: %s\n"
+ "failed to lookup doc-id %u error : %s\n"
+ "failed to lookup extentref tree oid at snap_xid %llu : %s\n"
+ "failed to mark cached doc-id tree record %d as verified error : %s\n"
+ "failed to populate cached doc-id tree : %s\n"
+ "failed to read container superblock\n"
+ "failed to read object (oid (0x%llx)) being reaped from disk \n"
+ "failed to read spaceman cab %u at address 0x%llx\n"
+ "failed to read spaceman cib %u at address 0x%llx\n"
+ "failed to register the clone mapping tree in the fsck memory storage\n"
+ "failed to register the clonegroup tree in the fsck memory storage\n"
+ "failed to register the crypto tree in the fsck memory storage\n"
+ "failed to register the dir stats repair tree in the fsck memory storage\n"
+ "failed to register the dir stats tree in the fsck memory storage\n"
+ "failed to register the doc id tree in the fsck memory storage\n"
+ "failed to register the dstream tree in the fsck memory storage\n"
+ "failed to register the file info tree in the fsck memory storage\n"
+ "failed to register the phys extent tree in the fsck memory storage\n"
+ "failed to register the prev phys extent tree in the fsck memory storage\n"
+ "failed to register the purgeable tree in the fsck memory storage\n"
+ "failed to remove %s object (id %llu): %s\n"
+ "failed to remove %s object: %s\n"
+ "failed to remove dir stats (id %llu) %s xfield: %s (%d)"
+ "failed to remove inode (oid 0x%llx) xfield (type %u): %s\n"
+ "failed to remove node at segment (%llu) error : %s\n"
+ "failed to remove snap_name entry: %s\n"
+ "failed to repair inode nlink (id %llu): %s\n"
+ "failed to repair inode sparse bytes (id %llu): %s\n"
+ "failed to run predicate callback on inode (oid 0x%llx) for lookup in directory: %s\n"
+ "failed to search for clone mapping (private_id %llu,  file_id %llu) to update compressed clone size: %s (%d)\n"
+ "failed to search for clone mapping (private_id %llu,  file_id %llu): %s (%d)\n"
+ "failed to search purgeable record (file id %llu) in the fsck_apfs tree: %d (%s)\n"
+ "failed to traverse doc-id tree : %s\n"
+ "failed to traverse prev doc-id tree : %s\n"
+ "failed to update %s object: %s\n"
+ "failed to update allocation counts: %s\n"
+ "failed to update clone mapping (private_id %llu,  file_id %llu) with compressed clone size: %s (%d)\n"
+ "failed to validate %s object, retrying as %s\n"
+ "failed to validate object with crypto key index (%u), retrying with (%u)\n"
+ "failed to write apfs superblock : %s\n"
+ "failed!"
+ "fcmd_fd == -1"
+ "fe_val->phys_block_num != 0"
+ "fi_type == APFS_FILE_INFO_DATA_HASH || fi_type == APFS_FILE_ATTRIBUTION_TAG"
+ "file"
+ "file data"
+ "file extent"
+ "file extent length %llu does not fit inside %u bits, refusing to repair\n"
+ "file extents"
+ "file info"
+ "file info: attribution tag (hash %llu) skipping clone size repair because the clone mapping repairs were aborted\n"
+ "file info: attribution tag (hash %llu) skipping clone size repair because the computed clone size is negative\n"
+ "file info: attribution tag (hash %llu) skipping clone size repair: full clone size %llu > %llu\n"
+ "file info: attribution tag (hash %llu) with invalid jobj_id (%llu)\n"
+ "file info: attribution tag (hash %llu): full clone size (%llu) does not match computed size (%llu)\n"
+ "file info: attribution tag (hash %llu): full clone size does not match expected value (%llu)\n"
+ "file info: attribution tag (hash %llu): physical size (%llu) does not match computed size (%llu)\n"
+ "file info: attribution tag (hash %llu): physical size does not match expected value (%llu)\n"
+ "file info: attribution tag (hash %llu): total count (%llu) does not match computed count (%llu)\n"
+ "file info: attribution tag (hash %llu): total count does not match expected value (%llu)\n"
+ "file info: attribution tag with invalid hash (%llu)\n"
+ "file info: clone size overflow for hash (%llu)\n"
+ "file info: computed count overflow for hash (%llu)\n"
+ "file info: computed size overflow for hash (%llu)\n"
+ "file info: failed to allocate memory\n"
+ "file info: found more than one attribution tag with matching computed hash, invalid entry (hash %llu)\n"
+ "file info: found orphan attribution tag with hash (%llu)\n"
+ "file info: found orphan data hash (id %llu) at logical address %llu\n"
+ "file info: inode (jobj_id 0x%llx) has unexpected attribution tag with hash (%llu)\n"
+ "file info: orphan attribution tag with hash (%llu)\n"
+ "file key rolling"
+ "file-id: %6lld flags: %d date-added: %lld hash: 0x%x name-len: %d name: %.*s\n"
+ "file-id: %6lld flags: %d date-added: %lld name-len: %d name: %.*s\n"
+ "file_extent_register_cb"
+ "file_extent_unregister_cb"
+ "fixup_cow_exempt_phys_extent_cb"
+ "flags of dir-stats object (id %llu) does not match expected value (0x%x)\n"
+ "flags: 0x%x data-len: %d name: %.*s\n"
+ "found %s file extent object (id %llu) at logical address %llu\n"
+ "found EFI jumpstart record of unknown version %d (max known: %d)\n"
+ "found a snapshot in the purgatory (xid %llu) with no corresponding omap entry\n"
+ "found an orphan clone mapping (private_id %llu, file_id %llu)\n"
+ "found an orphan purgeable record (atime %llu, file_id %llu)\n"
+ "found clone group tree in invalid volume format\n"
+ "found clone mapping in an unsupported volume format\n"
+ "found cloned xattr dstream (id %llu, object-ids %s)\n"
+ "found dir-stats object (id %llu) that is both shadow and calculating\n"
+ "found dir-stats object (id %llu; flags 0x%x) with bad chained key (%llu/%llu)\n"
+ "found dstream (id %llu) with missing crypto state object (id %llu)\n"
+ "found fext (id %llu) with missing crypto state object (id %llu)\n"
+ "found file extent (id %llu) at logical address %llu beyond the end of the dstream %llu\n"
+ "found file extent gap (id %llu) at logical address %llu (expected %llu)\n"
+ "found file extent gap (id %llu) at logical address %llu+%llu\n"
+ "found file extent overlap (id %llu) at logical address %llu (expected %llu)\n"
+ "found file extent overlap (id %llu) with next extent / end of dstream at logical address %llu+%llu\n"
+ "found invalid dir-stats object (id %llu)\n"
+ "found invalid directory record object (id %llu)\n"
+ "found invalid fsroot btree node key id (%llu)\n"
+ "found non-shadow dir-stats object (id %llu) that has calculating dir-stats\n"
+ "found orphan %s (id %llu, size %llu)\n"
+ "found orphan clone group mapping: (group_id %llu, private_id %llu, file_id %llu)\n"
+ "found orphan crypto state object (id %llu, refcnt %u)\n"
+ "found orphan dir-stats object (id %llu)\n"
+ "found orphan directory record object (id %llu)\n"
+ "found orphan dstream id object (id %llu)\n"
+ "found orphan dstream id object (id %llu, refcnt %u)\n"
+ "found orphan file extent (id %llu) at logical address %llu\n"
+ "found orphan omap mapping (oid %llu xid %llu)\n"
+ "found orphan/invalid clone mapping (private_id %llu, file_id %llu)\n"
+ "found orphan/invalid purgeable record (file_id %llu, atime %llu)\n"
+ "found orphan/invalid xattr (id %llu, name %.*s)\n"
+ "found orphan/unexpected crypto state object (id %llu)\n"
+ "found shadow dir-stats object (id %llu) but did not find its calculating dir-stats (%llu)\n"
+ "found shadow dir-stats object (id %llu) with origin (id %llu)\n"
+ "found shadow key (%llu) on non-calculating dir-stats object (id %llu)\n"
+ "found spaceman free queue tree entry (0x%llx+%llu, xid %llu) which overlaps with existing range (0x%llx+%llu)\n"
+ "found spaceman free queue tree entry (0x%llx, xid %llu) which overlaps with existing range\n"
+ "found unexpected %s xfield associated with inode (object-id %llu)\n"
+ "found unexpected EFI jumpstart record\n"
+ "found unexpected crypto state object (id %llu, refcnt %u)\n"
+ "found xattr (id %llu, name %.*s) with missing crypto state\n"
+ "found xattr dstream (id %llu, name %.*s) that references a missing crypto state\n"
+ "fr_key->fr_mandatory == false"
+ "fr_key->fr_op == FSCK_REPAIR_OP_DELETION"
+ "fr_key->fr_op == FSCK_REPAIR_OP_DELETION || fr_key->fr_op == FSCK_REPAIR_OP_INSERTION"
+ "fr_key->fr_op == FSCK_REPAIR_OP_DELETION || fr_key->fr_op == FSCK_REPAIR_OP_UPDATE"
+ "fr_key->fr_op == FSCK_REPAIR_OP_DELETION || fr_key->fr_op == FSCK_REPAIR_OP_UPDATE || fr_key->fr_op == FSCK_REPAIR_OP_INSERTION"
+ "fr_key->fr_op == FSCK_REPAIR_OP_INSERTION"
+ "fr_key->fr_op == FSCK_REPAIR_OP_UPDATE"
+ "fr_key->fr_tree == FSCK_REPAIR_TREE_CLONEGROUP"
+ "fr_key->fr_tree == FSCK_REPAIR_TREE_DOC_ID"
+ "fr_key->fr_tree == FSCK_REPAIR_TREE_EXTENTREF"
+ "fr_key->fr_tree == FSCK_REPAIR_TREE_FSROOT"
+ "fr_key->fr_tree == FSCK_REPAIR_TREE_FSROOT_NODES"
+ "fr_key->fr_tree == FSCK_REPAIR_TREE_OMAP"
+ "fr_key->fr_tree == FSCK_REPAIR_TREE_OMAP_SNAP || fr_key->fr_tree == FSCK_REPAIR_TREE_SNAP_META"
+ "fr_key->fr_tree == FSCK_REPAIR_TREE_PFKUR"
+ "fr_key->fr_tree == FSCK_REPAIR_TREE_SFQ_IP || fr_key->fr_tree == FSCK_REPAIR_TREE_SFQ_MAIN"
+ "fr_key->fr_tree == FSCK_REPAIR_TREE_SNAP_META"
+ "fr_key->fr_update_field == FSCK_REPAIR_UPDATE_CRYPTO_REFCOUNT || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_INC_CRYPTO_REFCOUNT"
+ "fr_key->fr_update_field == FSCK_REPAIR_UPDATE_DIR_STATS_CHAINED_KEY || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_DIR_STATS_DESCENDANTS || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_DIR_STATS_FLAGS || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_DIR_STATS_ORIGIN_ID || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_DIR_STATS_PHYS_SIZE || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_DIR_STATS_REMOVE_XFIELD || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_DIR_STATS_RESOURCE_FORK_SIZE || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_DIR_STATS_UPDATE_XFIELD"
+ "fr_key->fr_update_field == FSCK_REPAIR_UPDATE_DREC_HASH"
+ "fr_key->fr_update_field == FSCK_REPAIR_UPDATE_DSTREAM_ID_REFCOUNT"
+ "fr_key->fr_update_field == FSCK_REPAIR_UPDATE_FEXT_LEN_AND_FLAGS || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_FEXT_MAKE_SPARSE"
+ "fr_key->fr_update_field == FSCK_REPAIR_UPDATE_FILE_INFO_OBJ_ID || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_FILE_INFO_TOTAL_COUNT || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_FILE_INFO_PHYS_SIZE || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_FILE_INFO_CLONE_SIZE || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_FILE_INFO_HASH"
+ "fr_key->fr_update_field == FSCK_REPAIR_UPDATE_INODE_NCHILDREN || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_INODE_ALLOCED_SIZE || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_INODE_DEFAULT_CRYPTO_ID || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_INODE_REMOVE_XFIELD || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_INODE_SPARSE_BYTES || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_INODE_FLAGS_SET || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_INODE_FLAGS_CLEAR || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_INODE_BSD_FLAGS_SET || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_INODE_BSD_FLAGS_CLEAR || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_INODE_DIR_NLINK"
+ "fr_key->fr_update_field == FSCK_REPAIR_UPDATE_XATTR_DEFAULT_CRYPTO_ID"
+ "fr_key_len == fr_jobj_key->fr_j_key_len + offsetof(fsck_repair_j_key_t, fr_j_key)"
+ "fr_key_len == sizeof(fsck_repair_clonegroup_key_t)"
+ "fr_key_len == sizeof(fsck_repair_doc_id_key_t)"
+ "fr_key_len == sizeof(fsck_repair_omap_key_t)"
+ "fr_key_len == sizeof(fsck_repair_omap_snap_key_t)"
+ "fr_key_len == sizeof(fsck_repair_pfkur_key_t)"
+ "fr_key_len == sizeof(fsck_repair_phys_ext_key_t)"
+ "fr_key_len >= sizeof *fr_key"
+ "fr_key_len >= sizeof(fsck_repair_j_key_t)"
+ "fr_val == NULL && fr_val_len == 0"
+ "fr_val_len == (fr_key->fr_op == FSCK_REPAIR_OP_DELETION ? 0 : sizeof(doc_id_tree_val_t))"
+ "fr_val_len == (fr_key->fr_op == FSCK_REPAIR_OP_DELETION ? 0 : sizeof(j_snap_name_val_t))"
+ "fr_val_len == (fr_key->fr_op == FSCK_REPAIR_OP_DELETION ? 0 : sizeof(spaceman_free_queue_val_t))"
+ "fr_val_len == 0"
+ "fr_val_len == sizeof(fsck_repair_xfield_value_t) + xfield_repair->fr_xfield_len"
+ "fr_val_len == sizeof(j_dstream_t)"
+ "fr_val_len == sizeof(j_file_info_val_t)"
+ "fr_val_len == sizeof(j_inode_val_t)"
+ "fr_val_len == sizeof(j_phys_ext_val_t)"
+ "fr_val_len == sizeof(j_snap_metadata_val_t) + snap_meta_val->name_len"
+ "fr_val_len == sizeof(omap_snapshot_t)"
+ "fr_val_len == sizeof(omap_val_t)"
+ "fr_val_len == sizeof(pfkur_tree_val_t)"
+ "fr_val_len == sizeof(uint16_t)"
+ "fr_val_len == sizeof(uint32_t)"
+ "fr_val_len == sizeof(uint64_t)"
+ "fr_val_len == sizeof(uint8_t)"
+ "fr_val_len >= sizeof(fsck_repair_xfield_value_t)"
+ "fr_val_len >= sizeof(j_clone_mapping_val_t)"
+ "fr_val_len >= sizeof(j_snap_metadata_val_t)"
+ "free_overlapped_range: free space for source_paddr 0x%llx block_count 0x%llx\n"
+ "free_overlapped_range: unable to free space for source_paddr 0x%llx block_count 0x%llx (leak): %s\n"
+ "fs root tree"
+ "fs_oid != OID_INVALID"
+ "fsck cache stats:\n"
+ "fsck may bail out with overallocation - could not mark space allocated in fsck's version of the bitmap (%lld + %lld)\n"
+ "fsckPrint"
+ "fsckPrintGUI"
+ "fsckPrintString"
+ "fsckPrintXML"
+ "fsck_apfs"
+ "fsck_apfs is out of memory - some cross checks are skipped\n"
+ "fsck_apfs.c"
+ "fsck_apfs_check_fs"
+ "fsck_authapfs.c"
+ "fsck_btree->t_tree_subtype == OBJECT_TYPE_FSTREE"
+ "fsck_btree_children_async"
+ "fsck_btree_children_full_async"
+ "fsck_btree_children_sync"
+ "fsck_btree_node"
+ "fsck_btree_repair_minkey"
+ "fsck_cache.c"
+ "fsck_compare_snapshots_helper"
+ "fsck_dev.c"
+ "fsck_is_seal_intact"
+ "fsck_iterate_compare"
+ "fsck_jobj.c"
+ "fsck_jobj_clone_mapping.c"
+ "fsck_jobj_crypto.c"
+ "fsck_jobj_dir_stats.c"
+ "fsck_jobj_dirs.c"
+ "fsck_jobj_dstreams.c"
+ "fsck_jobj_extents.c"
+ "fsck_jobj_impl.c"
+ "fsck_jobj_inodes.c"
+ "fsck_jobj_snapshots.c"
+ "fsck_messages.c"
+ "fsck_msg_number"
+ "fsck_msg_string"
+ "fsck_msg_type"
+ "fsck_nx_impl.c"
+ "fsck_nx_impl.h"
+ "fsck_obj.h"
+ "fsck_obj_read"
+ "fsck_obj_write"
+ "fsck_repairs_apply"
+ "fsck_repairs_apply_btree_node"
+ "fsck_repairs_apply_clone_mapping"
+ "fsck_repairs_apply_clonegroup_mapping"
+ "fsck_repairs_apply_crypto"
+ "fsck_repairs_apply_dir_stats"
+ "fsck_repairs_apply_directory_records"
+ "fsck_repairs_apply_doc_id"
+ "fsck_repairs_apply_dstreams"
+ "fsck_repairs_apply_file_info"
+ "fsck_repairs_apply_free_queue"
+ "fsck_repairs_apply_inodes"
+ "fsck_repairs_apply_omap"
+ "fsck_repairs_apply_pfkur"
+ "fsck_repairs_apply_phys_extents"
+ "fsck_repairs_apply_purgeable"
+ "fsck_repairs_apply_snap_meta"
+ "fsck_repairs_apply_snapshots"
+ "fsck_repairs_apply_xattrs"
+ "fsck_repairs_update_jobj"
+ "fsck_snap_meta_delete_snapshot"
+ "fsck_snapshots.c"
+ "fsck_spaceman_impl.c"
+ "fsck_tree.c"
+ "fsck_tree_impl.c"
+ "fsck_tree_io.c"
+ "fsck_tree_node_add"
+ "fsck_tree_node_allocate"
+ "fsck_tree_node_deallocate"
+ "fsck_tree_node_repair.c"
+ "fsck_tree_node_repair_add_maybe"
+ "fsck_tree_node_repair_init"
+ "fsck_tree_node_repair_volume"
+ "fsck_tree_repairs.c"
+ "fsck_types.c"
+ "fsck_validate_node_hash"
+ "fsck_verbosity"
+ "fsck_verify_space.c"
+ "fsroot tree is invalid."
+ "fstype"
+ "gbitmap"
+ "gbitmap: "
+ "gbitmap_blk"
+ "gen-count: %u nchildren: %d \n"
+ "get_bitmap_for_range"
+ "get_fext_tree() called on unsealed volume\n"
+ "get_key_and_value_at_index"
+ "get_key_range"
+ "get_pfkur_tree() called on non-pfk volume\n"
+ "get_xfield(xfields, xfields_size, xfield_type, NULL, NULL, NULL, NULL) == ENOENT"
+ "greater"
+ "greater than"
+ "hash validation: invalid node %llu (root %llu)\n"
+ "hash validation: invalid node hash for node %llu (root oid: %llu, seal xid: %lld, broken xid: %lld)\n"
+ "hash_size"
+ "hit"
+ "hw.memsize"
+ "iOS encryption rolling state object: (version %u) current_state unset, yet non-zero current_id (%llu)"
+ "iOS encryption rolling state object: (version %u) full rolling has unrecognized current_state (%u)\n"
+ "iOS encryption rolling state object: (version %u) invalid policy (%u)\n"
+ "iOS encryption rolling state object: (version %u) lite rolling has invalid current_state (%u)\n"
+ "iOS encryption rolling state object: (version %u) timestamps unordered: start_time (%llu) <= end_time (%llu) <= current_time (%llu)\n"
+ "iOS encryption rolling state object: cannot determine absence of ierso xattr\n"
+ "iOS encryption rolling state object: cannot get ierso xattr\n"
+ "iOS encryption rolling state object: current_offset (%llu) too large\n"
+ "iOS encryption rolling state object: current_xattr is unterminated\n"
+ "iOS encryption rolling state object: epoch unordered: current_id (%llu) <= epoch (%llu) < apfs_next_obj_id (%llu) <= MAX_JOBJ_ID (%llu)\n"
+ "iOS encryption rolling state object: failed to allocate ierso\n"
+ "iOS encryption rolling state object: ierso version (%u) unrecognized\n"
+ "iOS encryption rolling state object: non-iOS content protected volume unexpectedly has ierso\n"
+ "iOS encryption rolling state object: size (%u), version (%u) does not match expected size (%zu)\n"
+ "iOS encryption rolling state object: xattr invalid storage type, flags (%hu)\n"
+ "iOS encryption rolling state object: xattr payload (%hu) does not match record size (%zu)\n"
+ "iOS encryption rolling state object: xattr payload (%hu) is too small\n"
+ "iOS encryption rolling state object: xattr record too small (%zu)\n"
+ "index %u key"
+ "index < parent->btn_nkeys"
+ "index >= 0 && index < btn->btn_nkeys"
+ "index >= 0 && index <= btn->btn_nkeys"
+ "index1 < btree->btn_nkeys && index2 < btree->btn_nkeys"
+ "inode"
+ "inode (id %llu): Resource Fork xattr is missing or empty for compressed file\n"
+ "inode (id %llu): can't add internal flags repair: %d (%s)\n"
+ "inode (id %llu): compression type is dataless, but the dataless bsd_flag is not set\n"
+ "inode (id %llu): dataless bsd_flag is set, but compression bsd_flag is not\n"
+ "inode (id %llu): dataless bsd_flag is set, but the compression type is different: 0x%x\n"
+ "inode (id %llu): dataless bsd_flag is set, but the compression xattr is missing\n"
+ "inode (id %llu): failed to enqueue to the repairs\n"
+ "inode (id %llu): has the compression bsdflag, but doesn't have the compression xattr\n"
+ "inode (id %llu): need to clear internal_flags 0x%llx\n"
+ "inode (id %llu): need to set internal_flags 0x%llx\n"
+ "inode (id %llu): unable to add repair to unmark purgeable: %d (%s)\n"
+ "inode (id %llu): unknown compression type: %u\n"
+ "inode (jobj_id %llu): unable to add repair for unexpected xfield: %s\n"
+ "inode with file-id %llu has doc-id %u but doc-id is already in use\n"
+ "inode with file-id %llu has doc-id %u but doc-id tree record has file-id %llu\n"
+ "inode with file-id %llu has doc-id %u but doc-id tree record is missing\n"
+ "inode with file-id %llu has doc-id %u but doc-id tree record is missing or points to another inode\n"
+ "inode_id != current_inode.id"
+ "inode_register"
+ "inode_val || OBJ_TYPE_FROM_KEY(*hdr) == APFS_TYPE_XATTR"
+ "integrity_meta: (0x%llx:0x%llx): invalid root hash\n"
+ "integrity_meta: (0x%llx:0x%llx): invalid root hash offset (%u+%u) > %u\n"
+ "integrity_meta: (0x%llx:0x%llx): invalid version\n"
+ "integrity_meta: (0x%llx:0x%llx): unexpected flags (0x%x) for xid (%llu)\n"
+ "integrity_meta: (0x%llx:0x%llx): unknown flags (0x%x)\n"
+ "integrity_meta: (0x%llx:0x%llx): unknown hash type (%u)\n"
+ "integrity_meta: failed to copy object (0x%llx:0x%llx)\n"
+ "inum: %8lld version: %u flags: %u current_offset: %8llu current_ns_offset: %8llu\n"
+ "invalid"
+ "invalid EFI jumpstart record file length: %d\n"
+ "invalid EFI jumpstart record number of extents: %d\n"
+ "invalid btree node address range (0x%llx+%llu)\n"
+ "invalid checksum block size, enum: %llu\n"
+ "invalid doc-id record, file-id is 0 for doc-id %u\n"
+ "invalid ersb_flags (0x%llx), ERSB_FLAG_CID_IS_TWEAK is set but ersb_fext_cid == 0\n"
+ "invalid ersb_flags (0x%llx), exactly one of ERSB_FLAG_ENCRYPTING and ERSB_FLAG_DECRYPTING bits must be set\n"
+ "invalid extent (%llu + %llu) with reference count (0)\n"
+ "invalid extent address range (0x%llx+%llu)\n"
+ "invalid gbitmap block oid 0x%llx\n"
+ "invalid gbitmap block oid 0x%llx for key 0x%llx\n"
+ "invalid kind (expected %u, actual %u) for extent (%llu + %llu)\n"
+ "invalid range: 0x%llx+%llu\n"
+ "invalid sblock_oid (%llu)\n"
+ "invalid zero-length extent (id %llu) at logical address %llu\n"
+ "is_file_id_in_purgatory"
+ "jobj_key_len == sizeof(j_clone_mapping_key_t)"
+ "jobj_key_len == sizeof(j_dir_stats_key_t)"
+ "jobj_key_len == sizeof(j_exp_dir_stats_key_t)"
+ "jobj_key_len == sizeof(j_file_extent_key_t) && jobj_val_len == (fr_key->fr_op == FSCK_REPAIR_OP_DELETION ? 0 : sizeof(j_file_extent_val_t))"
+ "jobj_key_len == sizeof(j_key_t) && jobj_val_len == ((fr_key->fr_op == FSCK_REPAIR_OP_DELETION || fr_key->fr_update_field == FSCK_REPAIR_UPDATE_INC_CRYPTO_REFCOUNT) ? 0 : sizeof(j_crypto_val_t))"
+ "jobj_key_len == sizeof(j_key_t) && jobj_val_len == (fr_key->fr_op == FSCK_REPAIR_OP_DELETION ? 0 : sizeof(j_dstream_id_val_t))"
+ "jobj_key_len == sizeof(j_purgeable_key_t)"
+ "jobj_key_len >= (APFS_IS_FULLY_SENSITIVE(volume->apfs) ? sizeof(j_drec_key_t) : sizeof(j_drec_hashed_key_t))"
+ "jobj_type == APFS_EXPANDED_TYPE_DIR_STATS"
+ "jobj_type == APFS_TYPE_DSTREAM_ID || jobj_type == APFS_TYPE_FILE_EXTENT"
+ "jobj_type == APFS_TYPE_FILE_INFO && jobj_key_len == sizeof(j_file_info_key_t)"
+ "jobj_val_len == sizeof(j_dir_stats_val_t)"
+ "jobj_val_len >= sizeof(j_exp_dir_stats_val_t)"
+ "k_occupies(btif, klen) + v_occupies(btif, vlen) <= btn->btn_free_space.len"
+ "key && val && klen > 0"
+ "key size (%u)/val size (%u) is invalid\n"
+ "key size is too small, actual: %u, minimum: %u\n"
+ "key_len == sizeof(j_snap_metadata_key_t)"
+ "klen == sizeof(uint64_t) && vlen == sizeof(prange_t)"
+ "kvmoved <= new_avail"
+ "last reap list object 0x%llx doesn't match tail 0x%llx\n"
+ "len != 0 && len != BTLEN_MT_GHOST"
+ "len <= btn->btn_free_space.len"
+ "len <= next->len && len <= list->len"
+ "less"
+ "less than"
+ "live repair of a volume in mounted container %s is not supported yet.\n"
+ "logical addr: %lld  phys-block-num: %lld  crypto-id: %lld  len: %lld  flags: %x\n"
+ "logical addr: %lld  phys-block-num: %lld  len: %lld  flags: %x\n"
+ "malloc(%u)\n"
+ "mark_object_allocated_cb"
+ "media keybag"
+ "mem_storage.c"
+ "memory_storage_create"
+ "memory_storage_destroy"
+ "memory_storage_register_tree"
+ "min_key && ((max_key != NULL) == (max_klen != 0))"
+ "mismatch between extentref entry reference count (%d) and calculated fsroot entry reference count (%d) for extent (%llu + %llu)\n"
+ "mismatch between extentref entry reference count (%d) and calculated fsroot entry reference count (0) for extent (%llu + %llu)\n"
+ "mismatch between extentref entry reference count (0) and calculated fsroot entry reference count (%d) for extent (%llu + %llu)\n"
+ "miss"
+ "missing clone group record for file_id %llu\n"
+ "missing crypto state object (id %llu) referenced by %u file extents / dstreams\n"
+ "missing dir-stats object (id %llu) referenced by %s%llu files / directories\n"
+ "missing encryption rolling recovery data, actual length %llu, ersb_recovery_length %llu\n"
+ "missing upgrade-rolling entry for inode (%llu)\n"
+ "missing/invalid physical extent (%llu + %llu) with refcnt %d\n"
+ "missing/invalid physical extent (%llu + %llu) with refcnt %d at snapshot %llu\n"
+ "more than %d inodes tracked as rolling, disabling pfkur tracking repairs\n"
+ "moveindex < btn->btn_nkeys"
+ "moveindex < btn->btn_nkeys || (key && val)"
+ "msec"
+ "msg != NULL"
+ "multiKeyEncryption"
+ "name_len < sizeof name"
+ "nchildren of inode object (id %llu) does not match expected value (%d)\n"
+ "need to clear bsd flags (0x%x) in inode (object-id %llu)\n"
+ "need to clear flags (0x%llx) in inode (object-id %llu)\n"
+ "need to increment crypto state object (id %llu) refcount (%u)\n"
+ "need to insert key at id (%llu) to repair invalid internal node\n"
+ "need to insert missing clone mapping (private_id %llu, file_id %llu)\n"
+ "need to insert spaceman free queue tree entry (0x%llx+%llu, xid %llu) to replace existing overlapping ranges\n"
+ "need to make file extent with missing crypto state (id %llu) at logical address %llu+%llu sparse\n"
+ "need to mark dir-stats %llu as needing reconciliation, due to an issue with dir-stats %llu\n"
+ "need to set bsd flags (0x%x) in inode (object-id %llu)\n"
+ "need to set flags (0x%llx) in inode (object-id %llu)\n"
+ "need to update default_crypto_id (%llu) of dstream (object-id %llu) with missing crypto state\n"
+ "need to update inode (object-id %llu) sparse bytes with (%llu)\n"
+ "new_off <= old_off"
+ "new_off > old_off"
+ "next_issue - next_wait < MAX_INFLIGHT_OBJECTS + invalid_objects"
+ "nlink: %d \n"
+ "no file key rolling entry found for inode object (%llu)\n"
+ "no omap_snap tree entry found for snap_meta entry with xid %llu\n"
+ "no snap_meta entry found for snap_name entry with name %.*s\n"
+ "no snap_meta entry found for snap_name entry with xid %llu and name %.*s\n"
+ "no snap_meta tree entry found for omap_snap entry with xid %llu\n"
+ "no snap_name entry found for snap_meta entry with xid %llu and name %.*s\n"
+ "no valid checkpoint\n"
+ "no valid checkpoint found\n"
+ "non-multikey volume"
+ "not a leaf"
+ "not a root"
+ "nr"
+ "nrl"
+ "num children: %lld total size: %lld gen-count: %lld\n"
+ "num_files > 1"
+ "number of files in the clone mapping (%u) != dstream reference count (%u)\n"
+ "nx_block_count is %llu, while device block count is %llu\n"
+ "nx_block_size of %u is invalid\n"
+ "nx_checkpoint_desc_index_add"
+ "nx_ephemeral_info %d: invalid info (0x%llx)\n"
+ "nx_ephemeral_info 0: invalid minimum block count per structure (%u), should be less than: (%d)\n"
+ "nx_ephemeral_info 0: invalid structures per fs (%u), should be: (%d)\n"
+ "nx_ephemeral_info 0: invalid version (%u), should be: (%d)\n"
+ "nx_features has unsupported flags: (0x%llX)\n"
+ "nx_flags (0x%llx) has an unknown flag set \n"
+ "nx_fs_oid (%llu) at index (%d) is less than minimum OID (%d)\n"
+ "nx_fusion_mt_oid should be invalid but isn't\n"
+ "nx_fusion_wbc should be empty but isn't\n"
+ "nx_fusion_wbc_oid should be invalid but isn't\n"
+ "nx_incompatible_features has unsupported flags: (0x%llX)\n"
+ "nx_max_file_systems (%u) is invalid\n"
+ "nx_newest_mounted_version is greater than expected: %s\n"
+ "nx_newest_mounted_version is less than expected: %s\n"
+ "nx_newest_mounted_version should not start with a 0: %s\n"
+ "nx_next_oid (%llu) is less than the minimum (%u)\n"
+ "nx_omap_oid is invalid\n"
+ "nx_read_only_compatible_features has unsupported flags: (0x%llX)\n"
+ "nx_reaper_add_ext"
+ "nx_reaper_oid (%llu) is less than minimum OID (%d)\n"
+ "nx_sb->nx_o.o_oid != OID_NX_SUPERBLOCK, %llu\n"
+ "nx_spaceman_oid is invalid\n"
+ "nx_superblock magic number invalid: 0x%X\n"
+ "nx_uuid is NULL\n"
+ "nx_xp_data_blocks (%u) is less than 8\n"
+ "nx_xp_data_index (%u) is is larger than nx_xp_data_blocks (%u)\n"
+ "nx_xp_data_index (%u) puts the checkpoint data outside of its range\n"
+ "nx_xp_data_len (%u) is larger than nx_xp_data_blocks (%u)\n"
+ "nx_xp_data_len (%u) is less than 2\n"
+ "nx_xp_data_next (%u) is larger than the # of nx_xp_data_blocks (%u)\n"
+ "nx_xp_desc_blocks (%u) is less than 8\n"
+ "nx_xp_desc_index (%u) is larger than nx_xp_desc_blocks (%u)\n"
+ "nx_xp_desc_len (%u) is larger than nx_xp_desc_blocks (%u)\n"
+ "nx_xp_desc_len (%u) is less than 2\n"
+ "nx_xp_desc_next (%u) is larger than the # of nx_xp_desc_blocks (%u)\n"
+ "obj-id: %8lld type: %-11s\n"
+ "obj-id: %8lld type: ???\n"
+ "obj-id: ??? type: ???\n"
+ "obj_info.size % _block_size(container) == 0"
+ "obj_type == APFS_EXPANDED_TYPE_DIR_STATS"
+ "obj_type == APFS_TYPE_CRYPTO_STATE"
+ "obj_type == APFS_TYPE_DIR_REC"
+ "obj_type == APFS_TYPE_DIR_STATS || obj_type == APFS_EXPANDED_TYPE_DIR_STATS"
+ "obj_type == APFS_TYPE_DSTREAM_ID"
+ "obj_type == APFS_TYPE_FILE_EXTENT"
+ "obj_type == APFS_TYPE_FILE_INFO"
+ "obj_type == APFS_TYPE_FILE_INFO && J_FILE_INFO_GET_TYPE((j_file_info_key_t *)search_key) == APFS_FILE_ATTRIBUTION_TAG"
+ "obj_type == APFS_TYPE_INODE"
+ "obj_type == APFS_TYPE_XATTR"
+ "object (oid (0%llx)) being reaped : Invalid tree subtype (%u)\n"
+ "object (oid 0x%llx): Unable to mark nx checkpoint data range (0x%llx + %u) allocated for space verification\n"
+ "object (oid 0x%llx): Unable to mark nx checkpoint desc range (0x%llx + %u) allocated for space verification\n"
+ "object (oid 0x%llx): Unable to mark omap entry for omap space verification \n"
+ "object (oid 0x%llx): Unable to mark omap entry in use for omap space verification \n"
+ "object (oid 0x%llx): Unable to mark omap entry in usefor omap space verification \n"
+ "object (oid 0x%llx): Unable to mark spaceman ip bitmap range (0x%llx + %u) allocated for space verification\n"
+ "object (oid 0x%llx): Unable to mark spaceman ip range (0x%llx + %llu) allocated for space verification\n"
+ "object (oid 0x%llx): Unable to mark the omap entry of the apfs_sb at index (%u) in use for omap space verification\n"
+ "object (oid 0x%llx): Unable to mark the omap entry of the apfs_snap_meta_ext_oid in use for omap space verification\n"
+ "object (oid 0x%llx): o_cksum (0x%llx) is invalid for object\n"
+ "object (oid 0x%llx): o_oid invalid\n"
+ "object (oid 0x%llx): o_subtype invalid, o_subtype 0x%x should be 0x%x\n"
+ "object (oid 0x%llx): o_type invalid, o_type 0x%x should be 0x%x\n"
+ "object (oid 0x%llx): o_xid invalid, o_xid %llu is greater than nx_next_xid: %llu\n"
+ "object (oid 0x%llx): o_xid invalid, o_xid is 0\n"
+ "object (oid 0x%llx): unable to add omap repair: %s\n"
+ "object oid %llu/xid %llu/type 0x%x/subtype 0x%x: unable to mark range %llu+%llu allocated for space verification: %s\n"
+ "objectAtIndexedSubscript:"
+ "offsets[i].off != BTOFF_INVALID && offsets[i].off != BTOFF_MT_GHOST"
+ "offsets[i].off != BTOFF_MT_GHOST"
+ "oid == btn->btn_o.o_oid"
+ "om"
+ "om: "
+ "om: invalid om_snap_count (overflow)\n"
+ "om: om_most_recent_snap (%llu) is not equal to the largest snapshot xid (%llu)\n"
+ "om: om_snap_count (%u) is not equal to the number of snapshots found (%llu)\n"
+ "omap"
+ "omap (oid 0x%llx): invalid om_flags (0x%x)\n"
+ "omap (oid 0x%llx): invalid om_most_recent_snap (0x%llx), given om_flags (0x%x)\n"
+ "omap (oid 0x%llx): invalid om_pending_revert_max (0x%llx), given om_flags (0x%x)\n"
+ "omap (oid 0x%llx): invalid om_pending_revert_min (0x%llx), given om_flags (0x%x)\n"
+ "omap (oid 0x%llx): invalid om_snap_count (%u), given om_flags (0x%x)\n"
+ "omap (oid 0x%llx): invalid om_snapshot_tree_oid (0x%llx), given om_flags (0x%x)\n"
+ "omap (oid 0x%llx): invalid om_snapshot_tree_type (0x%x)\n"
+ "omap (oid 0x%llx): invalid om_tree_type (0x%x)\n"
+ "omap entry (oid 0x%llx): invalid crypto key index (%u) given ov_flags (0x%x)\n"
+ "omap entry (oid 0x%llx): invalid crypto key index (%u) on %s\n"
+ "omap entry (oid 0x%llx): invalid ok_xid (0x%llx)\n"
+ "omap entry (oid 0x%llx): invalid ov_flags (0x%x)\n"
+ "omap entry (oid 0x%llx): invalid ov_paddr (%llu)\n"
+ "omap entry (oid 0x%llx): invalid ov_range (0x%llx+%llu)\n"
+ "omap entry (oid 0x%llx): invalid ov_size (%u)\n"
+ "omap entry (oid 0x%llx): invalid tweak type (%u) given ov_flags (0x%x)\n"
+ "omap has %llu snaphots but snap meta tree has %llu\n"
+ "omap mapping"
+ "omap snapshot: invalid key (0x%llx)\n"
+ "omap snapshot: invalid oms_flags (0x%x)\n"
+ "omap snapshot: invalid oms_pad (0x%x)\n"
+ "omap snapshot: oms_oid should be unused but has value (0x%llx)\n"
+ "omap_snap_key || snap_meta_key"
+ "oms: "
+ "origin_id (%llu) of dir-stats object (id %llu) is not as expected (%llu)\n"
+ "origin_id of dir-stats object (id %llu) does not match expected value (%llu)\n"
+ "orphan"
+ "orphan omap mapping found for oid %llu\n"
+ "orphan omap mappings found for oid range %llu --> %llu\n"
+ "orphan/invalid physical extent (%llu)\n"
+ "orphan/invalid physical extent (%llu) at snapshot %llu\n"
+ "other"
+ "overallocation"
+ "overallocation detected in internal pool: (0x%llx+%llu) bitmap address (0x%llx)\n"
+ "overallocation detected on %s device: (0x%llx+%llu) bitmap address (0x%llx)\n"
+ "pad1: 0x%x \n"
+ "paddr == cib->cib_chunk_info[cib_chunk_info_index].ci_addr"
+ "parameters"
+ "parent_val"
+ "pass"
+ "path"
+ "path_iterator_advance"
+ "performed too many chained-key iterations (current id %llu); aborting dir-stats repairs\n"
+ "performed too many chained-key iterations (current id %llu); can't mark the entire chain as needing reconciliation\n"
+ "pfk_val : object (oid 0x%llx): invalid current_ns_offset (%llu)\n"
+ "pfk_val : object (oid 0x%llx): invalid current_offset (%llu)\n"
+ "pfk_val : object (oid 0x%llx): unknown flags (%u)\n"
+ "pfk_val : object (oid 0x%llx): unknown version (%u)\n"
+ "pfkur_key : object (oid 0x%llx): invalid oid (0x%llx)\n"
+ "pfkur_tree_key : object (oid 0x%llx): pfkur tree record present on non-pfkur volume\n"
+ "phys extent"
+ "physical extent"
+ "physical size of dir-stats object (id %llu) does not match expected value (%llu)\n"
+ "physical_size (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n"
+ "prev phys extent"
+ "private-id: %lld parent-id: %lld cr/mtime: %lld/%lld \n"
+ "purgatory."
+ "purgatory_name_len < sizeof purgatory_name"
+ "purgeable"
+ "purgeable inode (id %llu) is missing a purgeable record\n"
+ "purgeable inode (id %llu) was unexpectedly registered twice\n"
+ "purgeable record (atime %llu, file_id %llu) is different than inode atime (%llu)\n"
+ "purgeable resource fork size (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n"
+ "purgeable resource fork size xfield is missing from dir-stats object (id %llu)\n"
+ "purgeable resource fork size xfield of dir-stats object (id %llu) exists unexpectedly\n"
+ "purgeable resource forks are maintained on dir-stats object (id %llu) but not purgeable data forks\n"
+ "purgeable resource forks are maintained on dir-stats object (id %llu) but not rsrc forks\n"
+ "purgeable size (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n"
+ "purgeable size xfield is missing from dir-stats object (id %llu)\n"
+ "purgeable size xfield of dir-stats object (id %llu) exists unexpectedly\n"
+ "purgeable tombstone"
+ "purgeable_diff >= 0"
+ "purgeable_rsrc_diff >= 0"
+ "range_ffc"
+ "range_ffs"
+ "reached invalid tree node limit %llu for fs_oid %llu\n"
+ "readInto:startingAt:length:error:"
+ "ready"
+ "reap list expected %u objects, but got last reap list object with %u more objects left\n"
+ "reap list expected %u objects, but haven't seen last reap list object yet\n"
+ "reap list object (oid 0x%llx) expected %u entries, found %u\n"
+ "reap list object 0x%llx first index %u larger than max %u\n"
+ "reap list object 0x%llx free index %u larger than max %u\n"
+ "reap list object 0x%llx last index %u larger than max %u\n"
+ "reap list object 0x%llx max record count %u different than expected %lu\n"
+ "reap list object 0x%llx record count %u larger than max %u\n"
+ "reap list tail 0x%llx is not last reap list object, next 0x%llx\n"
+ "reaper completed ID 0x%llx not less than next reap ID 0x%llx\n"
+ "reaper head (0x%llx) and tail (0x%llx) should be both valid or both invalid\n"
+ "reaper list entry (index (%u) list oid (0x%llx)) : cycle detected\n"
+ "reaper list entry (index (%u) list oid (0x%llx)) : entry is both occupied and free!\n"
+ "reaper list entry (index (%u) list oid (0x%llx)) : entry is not referenced\n"
+ "reaper list entry (index (%u) list oid (0x%llx)) : index not less than nrl_max (%u)\n"
+ "reaper list entry (index (%u) list oid (0x%llx)) : invalid flags (0x%x) set\n"
+ "reaper list entry (index (%u) list oid (0x%llx)) : invalid nrle_fs_oid (0x%llx)\n"
+ "reaper list entry (index (%u) list oid (0x%llx)) : is not valid as per flags(0x%x)\n"
+ "reaper needs more cowbell, flags 0x%x\n"
+ "recovery extent #%llu: checksums at offset %llu, length %llu exceed ersb_recovery_length %llu\n"
+ "recovery extent #%llu: fext_laddr (0x%llx) exceeds nx_block_count (%llu), fs_bsize %u\n"
+ "recovery extent #%llu: invalid ersb_flags (0x%llx), ERSB_FLAG_CID_IS_TWEAK is set but fext_cid == 0\n"
+ "recovery extent #%llu: invalid fext_pbn (0x%llx)\n"
+ "recovery extent #%llu: invalid prange (0x%llx+%llu), dev_bsize %u\n"
+ "refcnt %d\n"
+ "refcnt %d len %lld owning_obj_id %lld\n"
+ "refcnt (%u) of crypto state object (id %llu) is greater than expected (%u)\n"
+ "refcnt (%u) of crypto state object (id %llu) is less than expected (%u)\n"
+ "refcnt (%u) of dstream id object (id %llu) is greater than expected (%u)\n"
+ "refcnt (%u) of dstream id object (id %llu) is less than expected (%u)\n"
+ "refcnt of crypto state object (id %llu) is %s than expected (%u)\n"
+ "refcnt of dstream id object (id %llu) less than expected\n"
+ "refcnt: %d \n"
+ "repair_free_queue_tree"
+ "repair_free_queue_tree_helper"
+ "repair_overlapped_extents: allocate space for block_count 0x%llx\n"
+ "repair_overlapped_extents: copy paddr 0x%llx to paddr 0x%llx, block_count 0x%llx\n"
+ "repair_overlapped_extents: encryption is rolling for fs_oid 0x%llx\n"
+ "repair_overlapped_extents: failed to copy paddr 0x%llx to paddr 0x%llx, block_count 0x%llx: %s\n"
+ "repair_overlapped_extents: free space for target_paddr 0x%llx block_count 0x%llx\n"
+ "repair_overlapped_extents: insert target pext 0x%llx\n"
+ "repair_overlapped_extents: load fext 0x%llx 0x%llx\n"
+ "repair_overlapped_extents: remove source pext 0x%llx\n"
+ "repair_overlapped_extents: remove target pext 0x%llx\n"
+ "repair_overlapped_extents: unable to allocate space for block_count 0x%llx: %s\n"
+ "repair_overlapped_extents: unable to find volume for fs_oid 0x%llx\n"
+ "repair_overlapped_extents: unable to free space for target_paddr 0x%llx block_count 0x%llx: %s\n"
+ "repair_overlapped_extents: unable to init extentref tree for fs_oid 0x%llx\n"
+ "repair_overlapped_extents: unable to init fsroot for fs_oid 0x%llx\n"
+ "repair_overlapped_extents: unable to insert target pext 0x%llx for fs_oid 0x%llx: %s\n"
+ "repair_overlapped_extents: unable to load fext 0x%llx 0x%llx for fs_oid 0x%llx: %s\n"
+ "repair_overlapped_extents: unable to load pext 0x%llx for fs_oid 0x%llx: %s\n"
+ "repair_overlapped_extents: unable to remove source pext 0x%llx for fs_oid 0x%llx (pext leak): %s\n"
+ "repair_overlapped_extents: unable to remove target pext 0x%llx for fs_oid 0x%llx (pext leak): %s\n"
+ "repair_overlapped_extents: unable to target update target pext 0x%llx for fs_oid 0x%llx (refcnt leak): %s\n"
+ "repair_overlapped_extents: unable to update fext 0x%llx 0x%llx for fs_oid 0x%llx: %s\n"
+ "repair_overlapped_extents: unable to update source pext 0x%llx for fs_oid 0x%llx (refcnt leak): %s\n"
+ "repair_overlapped_extents: update fext 0x%llx 0x%llx\n"
+ "repair_overlapped_extents: update source pext 0x%llx\n"
+ "repair_overlapped_extents: update target pext 0x%llx\n"
+ "resource"
+ "resource fork size (%llu) of dir-stats object (id %llu) exists unexpectedly\n"
+ "resource fork size (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n"
+ "resource fork size of dir-stats object (id %llu) does not match expected value (%llu)\n"
+ "result"
+ "root->btn_nkeys == 0"
+ "root_device"
+ "sealed volume fsroot corruptions cannot be repaired and will automatically be skipped\n"
+ "sealed volume hash records"
+ "sealed volume hash records (id %llu, size %llu) do not match size of dstream (%llu)\n"
+ "sec"
+ "sec fs root tree"
+ "set missing flag? (0x%x) "
+ "setResource:"
+ "sfqe_entry : (range 0x%llx+0x%llx, xid 0x%llx) : Range in free queue tree is not a valid address range on disk\n"
+ "sfqe_entry : (range 0x%llx+0x%llx, xid 0x%llx) : Range in free queue tree lies in the internal pool\n"
+ "sfqe_entry : (range 0x%llx+0x%llx, xid 0x%llx) : Range in ip free queue tree does not lie in the internal pool\n"
+ "sfqe_entry : (range 0x%llx+0x%llx, xid 0x%llx) : key out of order (last paddr 0x%llx, last xid 0x%llx)\n"
+ "sfqe_key : (paddr 0x%llx, xid 0x%llx) : invalid xid\n"
+ "shadow dir-stats object (id %llu) unexpectedly has origin-id\n"
+ "shadow dir-stats object (id %llu) unexpectedly marked as having origin-id\n"
+ "sib-id: %lld parent-id: %lld name: %.*s\n"
+ "sib-map: %lld\n"
+ "sibling link"
+ "sibling map"
+ "skipping dir stats clone sizes repair because the clone mapping repairs were aborted\n"
+ "skipping dir stats clone sizes repair because the computed clone size is negative\n"
+ "skipping dir stats clone sizes repair: present clone size %llu > %llu\n"
+ "skipping purgeable cross checks\n"
+ "sm"
+ "sm : free queue tree has sfq_count (%llu) greater than available block count (%llu)\n"
+ "sm: sm_free_count (%llu) is not valid (%llu) (sm_dev %d)\n"
+ "sm_fs_reserve_alloc_count is not valid (expected %llu, actual %llu)\n"
+ "sm_fs_reserve_block_count is not valid (expected %llu, actual %llu)\n"
+ "sm_ip"
+ "smp == container->spaceman"
+ "snap_meta_ext"
+ "snap_meta_ext: (0x%llx:0x%llx): invalid xid (0x%llx)\n"
+ "snap_meta_ext: (0x%llx:0x%llx): sme_uuid is NULL\n"
+ "snap_meta_ext: (0x%llx:0x%llx): unknown flags (%u)\n"
+ "snap_meta_ext: (0x%llx:0x%llx): unknown version (%u)\n"
+ "snap_meta_ext: object (oid 0x%llx): no record for snapshot (xid 0x%llx)\n"
+ "snapshot fsroot / file key rolling / doc-id / clone group tree corruptions are not repaired; they'll go away once the snapshot is deleted\n"
+ "snapshot metadata"
+ "snapshot name"
+ "snapshot_insert_maybe"
+ "space == BTNODE_SPACE_KEY || space == BTNODE_SPACE_VAL"
+ "spaceman"
+ "spaceman IP bitmap blocks field is %u, but sum of ranges is %llu\n"
+ "spaceman IP bitmap range is invalid: 0x%llx+0x%x\n"
+ "spaceman IP blocks field is %llu, but sum of ranges is %llu\n"
+ "spaceman IP range is invalid: 0x%llx+0x%llx\n"
+ "spaceman block count %llu doesn't match NX superblock block count %llu\n"
+ "spaceman block size %u doesn't match NX superblock block size %u\n"
+ "spaceman blocks per chunk %u is inconsistent with block size %u\n"
+ "spaceman cab %u address 0x%llx is not in the internal pool\n"
+ "spaceman cab %u wrong number of cibs: %u, expected %u\n"
+ "spaceman cab count %u is inconsistent with cib count %u and cibs per cab %u\n"
+ "spaceman cab out of order: %u, expected %u\n"
+ "spaceman chunk %llu bitmap address 0x%llx is not in the internal pool\n"
+ "spaceman chunk %llu disk address out of order: 0x%llx, expected 0x%llx\n"
+ "spaceman chunk %llu free count %u > block count %u\n"
+ "spaceman chunk %llu free count %u of unallocated bitmap != block count %u\n"
+ "spaceman chunk %llu wrong free count: %u, expected %u\n"
+ "spaceman chunk %llu wrong number of blocks: %u, expected %u\n"
+ "spaceman chunk %llu xid is invalid: %llu > %llu\n"
+ "spaceman chunk count %llu is inconsistent with block count %llu and blocks per chunk %u\n"
+ "spaceman chunks per cib %u is inconsistent with block size %u\n"
+ "spaceman cib %u address 0x%llx is not in the internal pool\n"
+ "spaceman cib %u wrong number of chunks: %u, expected %u\n"
+ "spaceman cib count %u is inconsistent with chunk count %llu and chunks per cib %u\n"
+ "spaceman cib out of order: %u, expected %u\n"
+ "spaceman cibs per cab %u is inconsistent with block size %u\n"
+ "spaceman datazone current boundaries (%llu -> %llu) is not a valid address range on disk\n"
+ "spaceman datazone duplicate zone id (%hu) for allocation zones at indices (%hu, %hu)\n"
+ "spaceman datazone invalid previous boundary index (%hu)\n"
+ "spaceman datazone previous boundaries (%llu -> %llu) is not a valid address range on disk\n"
+ "spaceman datazone unknown zone id (%hu)\n"
+ "spaceman datazone zone id is zero but other fields are initialized\n"
+ "spaceman free count %llu does not match sum of free counts %llu\n"
+ "spaceman free count is too large: %llu > %llu\n"
+ "spaceman fs_reserve_alloc_count %llu is greater than sm_fs_reserve_block_count %llu\n"
+ "spaceman fs_reserve_block_count %llu is greater than nx_block_count %llu\n"
+ "spaceman ip bitmap %u at index %u is not invalidated on the free list\n"
+ "spaceman ip bitmap %u at index %u was on the free list\n"
+ "spaceman ip bitmap %u at index %u was referenced by a previous entry in sm_ip_bitmap \n"
+ "spaceman ip bitmap block address is invalid: %hu > %u\n"
+ "spaceman ip bitmap block at index [%u] is neither on the sm_ip_bitmap[] nor on the free list\n"
+ "spaceman ip bitmap block xid is invalid: %llu > %llu\n"
+ "spaceman ip block count is bad: %lld\n"
+ "spaceman ip bm block count is bad: %d\n"
+ "spaceman ip bm list has a loop\n"
+ "spaceman ip bm range (%llu, %llu) overlaps with spaceman ip range (%llu, %llu)\n"
+ "spaceman sm_ip_bm_block_count %u is too large\n"
+ "spaceman sm_ip_bm_free_head %u and sm_ip_bm_free_tail %u do not point to a valid list\n"
+ "spaceman sm_ip_bm_free_next index %u does not lie in ip bm range\n"
+ "spaceman sm_ip_bm_free_tail %u does not point to the last index on the free list %u\n"
+ "spaceman struct is versioned but version is 0\n"
+ "spaceman struct range %u+%u lies outside the struct itself (size %u)\n"
+ "spaceman struct ranges %u+%u and %u+%u overlap\n"
+ "spaceman tier2 fields should be empty but they aren't\n"
+ "spaceman_free_handle_entitled_reserve"
+ "spaceman_metazone[dev].inited && type < ALLOCATION_TYPE_META_COUNT && spaceman_metazone[dev].division[type].enabled"
+ "spaceman_metazone_set_alloc_index"
+ "spaceman_zone_set_alloc_index"
+ "sparse bytes overflow (current %llu, update %llu)\n"
+ "speculative download xattr (id %llu): found outside of an SAF dir stats hierarchy\n"
+ "speculative download xattr (id %llu): invalid flags: 0x%x\n"
+ "speculative download xattr (id %llu): pristine time (%llu) is greater than current time (%llu)\n"
+ "speculative download xattr (id %llu): shouldn't be stream based\n"
+ "speculative download xattr (id %llu): size is too small, actual: %u, minimum: %lu\n"
+ "speculative download xattr (id %llu): unknown flags: %x\n"
+ "speculative download xattr (id %llu): unknown purge reason: %u\n"
+ "speculative download xattr (id %llu): unknown version: %u\n"
+ "split_for_overlap_cb"
+ "start_bit % bits_per_word == 0"
+ "state->disk_fd == -1"
+ "storage_type != OBJ_VIRTUAL || volume != NULL"
+ "subdir count overflow (%d)\n"
+ "succeeded."
+ "t->t_node_size % _block_size(t->container) == 0"
+ "the EFI jumpstart entry has length %u but occupies %llu blocks of size %u\n"
+ "the EFI jumpstart record magic number is invalid: 0x%x\n"
+ "the checkpoint superblock has a lower o_xid (%lld) than the %s (%lld)\n"
+ "tmp-ino-clone-"
+ "tree_entries == NULL"
+ "tree_init_ext"
+ "tried to remove %s object but it wasn't there!\n"
+ "tried to remove oid %llu from the omap but it wasn't there\n"
+ "tried to remove snap_name entry but it's not there!\n"
+ "tweak_type >= CRYPTO_TWEAK_TYPE_LBA && tweak_type <= CRYPTO_TWEAK_TYPE_OID_XID"
+ "type < ALLOCATION_TYPE_COUNT"
+ "uid/gid/mode: %d/%d/0x%x bsd_flags: 0x%x internal_flags: 0x%llx name: %s\n"
+ "unable to access the tree repairs structure: %s\n"
+ "unable to add tree node repair at key id %llu : %s\n"
+ "unable to add tree repair at key at id %llu : %s\n"
+ "unable to allocate memory for tree repairs\n"
+ "unable to allocate memory to repair dir-stats chained key\n"
+ "unable to allocate memory to repair missing crypto state\n"
+ "unable to enqueue tree node insertion repairs: %s\n"
+ "unable to enqueue tree node prune repairs: %s\n"
+ "unable to find inode (id %llu): %d (%s)\n"
+ "unable to fix overlaps in candidate tree: %s\n"
+ "unable to flush deferred repairs: %s\n"
+ "unable to get dir-stats key of inode (id %llu) to repair dir-stats chained key: %s\n"
+ "unable to get fsroot tree to repair missing crypto state\n"
+ "unable to get the file ids of dstream_id %llu\n"
+ "unable to init fsroot tree for dstream repair\n"
+ "unable to init fsroot tree iterator for dstream repair: %s\n"
+ "unable to init fsroot tree iterator: %s\n"
+ "unable to init fsroot tree to enque purgeable repairs\n"
+ "unable to init fsroot tree: %s\n"
+ "unable to init iterators for free queue tree repair: %s\n"
+ "unable to init omap_snap tree for snapshot repair\n"
+ "unable to init omap_snap tree iterator for snapshot repair: %s\n"
+ "unable to init physical extent tree iterator for repairs: %s\n"
+ "unable to init snap_meta tree for extentref_tree_oid lookup: %s\n"
+ "unable to init snap_meta tree for snapshot repair\n"
+ "unable to init snap_meta tree iterator for snapshot repair: %s\n"
+ "unable to initialize fsroot tree iterator for file lookup in directory: %s\n"
+ "unable to initialize iterator for snapshot validation: %s\n"
+ "unable to initialize omap tree iterator for repair: %s\n"
+ "unable to insert tree node at key id %llu for repairs : %s\n"
+ "unable to iterate fsroot tree (xid %llu) for tree node repairs: %s\n"
+ "unable to iterate snap fsroot tree for tree node repairs: %s\n"
+ "unable to iterate tree for tree node repairs: %s\n"
+ "unable to load dir-stats %llu to retrieve attributes: %s\n"
+ "unable to load drec (oid 0x%llx) for file lookup in directory\n: %s\n"
+ "unable to load inode (id %llu) to repair dir-stats chained key: %s\n"
+ "unable to load inode (oid 0x%llx) for file lookup in purgatory directory: %s\n"
+ "unable to load inode (oid 0x%llx) for lookup in purgatory directory: %s\n"
+ "unable to lookup latest snap xid: %s\n"
+ "unable to mark allocated blocks for volume oid %llu\n"
+ "unable to open the volume for repairs: %s\n"
+ "unable to remove tree node at key id %llu for repairs : %s\n"
+ "unable to setup snapshot tree iteration: %s\n"
+ "uncompressed-size: 0x%llx \n"
+ "underallocation"
+ "underallocation detected in internal pool: (0x%llx+%llu) bitmap address (0x%llx)\n"
+ "underallocation detected on %s device: (0x%llx+%llu) bitmap address (0x%llx)\n"
+ "unencrypted"
+ "unexpected end of iteration while repairing free queue tree\n"
+ "unexpected key (%u) / val (%u) size in evict mapping tree\n"
+ "unexpected key (%u) / val (%u) size in extent list tree\n"
+ "unexpected on-disk range 0x%llx+%llu xid %llu and in-memory range 0x%llx+%llu xid %llu while repairing free queue tree\n"
+ "unexpected spaceman struct size %u != %u\n"
+ "unexpected: space verification data structure not initialized"
+ "unknown"
+ "unknown keybag"
+ "unknown obj type (%u) to add xfields\n"
+ "unknown spaceman struct version %u > %u\n"
+ "unlock"
+ "up"
+ "update_alloc_counts"
+ "update_inode_sparse_bytes_cb"
+ "usec"
+ "userfs_crypto_io.c"
+ "v24@0:8@16"
+ "v24@0:8@?16"
+ "v24@?0@\"FSProbeResult\"8@\"NSError\"16"
+ "v8@?0"
+ "val"
+ "val < (int32_t) NX_METADATA_BLOCK_COUNT(nx->nx_xp_desc_blocks) && val >= -((int32_t) NX_METADATA_BLOCK_COUNT(nx->nx_xp_desc_blocks))"
+ "val size is too small, actual: %u, minimum: %u\n"
+ "val_len != NULL"
+ "val_len == sizeof(fsck_repair_xfield_value_t) + new_xfield_value->fr_xfield_len"
+ "val_len == sizeof(j_inode_val_t)"
+ "val_len == sizeof(uint32_t)"
+ "val_len == sizeof(uint64_t)"
+ "val_len == sizeof(uint8_t)"
+ "val_len >= sizeof(fsck_repair_xfield_value_t)"
+ "validate_data_hash"
+ "validate_dstream"
+ "verification/reading of the EFI jumpstart record failed\n"
+ "verification/reading of the nx_reaper object failed\n"
+ "verification/reading of the nx_reaper object failed: %s\n"
+ "verification/reading of the omap object failed: %s\n"
+ "verification/reading of the spaceman object failed: %s\n"
+ "verify_bitmap"
+ "verify_overallocation == true"
+ "vers: %u.%u flags: %#x class: %c os: "
+ "volume == NULL"
+ "volume keybag"
+ "volume metadata"
+ "volume omap (fs_oid 0x%llx)"
+ "volume_alloc_count_index"
+ "volumename"
+ "warning: "
+ "xf: xf total size (%u) is larger than UINT16_MAX\n"
+ "xf: xf_num_exts (%u) extended fields do not fit in the given xf_used_data (%u)\n"
+ "xf: xf_used_data (%u) is larger than expected (%u)\n"
+ "xfield_size == sizeof(uint64_t)"
+ "xfield_type == DIR_STATS_EXT_TYPE_CLONE_SIZE || xfield_type == DIR_STATS_EXT_TYPE_PURGEABLE_SIZE || xfield_type == DIR_STATS_EXT_TYPE_PURGEABLE_RSRC_SIZE || xfield_type == DIR_STATS_EXT_TYPE_SHADOW_KEY"
+ "xp_map->cpm_map[%d].cpm_size (%u) is not a multiple of nx_block_size (%u)\n"
+ "xp_map->cpm_map[%d].cpm_size is 0\n"
+ "xp_sb->nx_xp_desc_index (%d) doesn't match index block (%d)\n"
+ "|\n"
- "    keys: %9.2f %9.2f %9.2f %9.2f %9.2f %9.2f\n"
- "    keys: %9d %9d %9d %9d %9d %9d\n"
- "    keys: %9s %9s %9s %9s %9s %9s\n"
- "  values: %9.2f %9.2f %9.2f %9.2f %9.2f %9.2f\n"
- "  values: %9d %9d %9d %9d %9d %9d\n"
- "  values: %9s %9s %9s %9s %9s %9s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s %s %s unlock %s (%d)%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s %s%s%s[%04zu,%04zu): %s%s%s%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s %sdump %s (len = %zd)%s%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s %sresult: %d; passcode_change: %d; cf: 0x%x; of: 0x%x; nf: 0x%x%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s Internal Error: Null KEK, file radar%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s Internal Error: Null VEK, file radar%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s error %d%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s failed REQUIRE condition (%s:%d)\n%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s failed to decode blob%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s failed to decode kek%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s failed to decode vek%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s failed to generate valid kek group uuid after 16 attempts%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s icloud recovery key%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s institutional recovery key%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s kek and unmanaged vek device protection mismatch%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s kek constraint violation 1%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s kek constraint violation 2%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s kek failed to unwrap vek; mix-n-match?%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s personal recovery key%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s unknown blob type %i%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s unsupported vek type for sys disable%s\n"
- "%s%s:%s%s%s%s%u:%s%u:%s unsupported vek type for sys enable%s\n"
- "%s: Failed to read, error %@"
- "%s:%d: %s WBC area was not allocated on main device\n"
- "%s:%d: %s btree check called with non-root btree node: %d\n"
- "%s:%d: %s btree_node is null\n"
- "%s:%d: %s cab %d @ %lld cab_cib_count %d invalid\n"
- "%s:%d: %s cab %d cib count %d should be %d\n"
- "%s:%d: %s cab %d index %d should be %d\n"
- "%s:%d: %s cab %d xid %lld > spaceman xid %lld\n"
- "%s:%d: %s cib %lld chunk %d unable to get bitmap block @ %lld: %d\n"
- "%s:%d: %s cib %lld chunk info %d addr %lld should be %lld\n"
- "%s:%d: %s cib %lld chunk info %d block count %d should be %d\n"
- "%s:%d: %s cib %lld chunk info %d free count %d > chunk block count %d\n"
- "%s:%d: %s cib %lld chunk info %d xid %lld > cib xid %lld\n"
- "%s:%d: %s cib %lld chunk info count %d should be %lld\n"
- "%s:%d: %s cib %lld ci %d bm addr %lld not within IP block range\n"
- "%s:%d: %s cib %lld ci %d free count %d doesn't match free bits in bitmap block %lld\n"
- "%s:%d: %s cib %lld cib_chunk_info_count %d invalid\n"
- "%s:%d: %s cib %lld index %d should be %lld\n"
- "%s:%d: %s cib %lld xid %lld > spaceman xid %lld\n"
- "%s:%d: %s container block size too small for tier2 device block size (%d < %d)\n"
- "%s:%d: %s couldn't read tier2 device superblock of size %d\n"
- "%s:%d: %s doc-id tree sanity check failed: %d\n"
- "%s:%d: %s doc-id tree xid %lld > spaceman xid %lld\n"
- "%s:%d: %s error getting IP block index for cib %lld ci %d bm addr %lld\n"
- "%s:%d: %s error getting IP block index for spaceman IP free queue tree entry %lld:%lld %lld\n"
- "%s:%d: %s error getting IP block index for spaceman chunk info block %lld addr %lld\n"
- "%s:%d: %s error getting end block index for spaceman IP free queue tree entry %lld:%lld %lld\n"
- "%s:%d: %s failed nx_check sanity: %d\n"
- "%s:%d: %s failed to set tier2 device: %d\n"
- "%s:%d: %s failed to write superblock to fusion tier2 device block 0: %d\n"
- "%s:%d: %s fs extentref tree sanity check failed: %d\n"
- "%s:%d: %s fs extentref tree xid %lld > spaceman xid %lld\n"
- "%s:%d: %s fs root tree sanity check failed: %d\n"
- "%s:%d: %s fs root tree xid %lld > spaceman xid %lld\n"
- "%s:%d: %s fs snap meta tree sanity check failed: %d\n"
- "%s:%d: %s fs snap meta tree xid %lld > spaceman xid %lld\n"
- "%s:%d: %s last reap list object 0x%llx doesn't match tail 0x%llx\n"
- "%s:%d: %s oid 0x%llx (level %d): can't get child %d oid: %d\n"
- "%s:%d: %s oid 0x%llx (level %d): can't get child: 0x%llx\n"
- "%s:%d: %s oid 0x%llx (level %d): can't get key %d: %d\n"
- "%s:%d: %s oid 0x%llx (level %d): couldn't allocate bitmap to check btree node space usage\n"
- "%s:%d: %s oid 0x%llx (level %d): free space extends beyond end of node\n"
- "%s:%d: %s oid 0x%llx (level %d): free space offset too large\n"
- "%s:%d: %s oid 0x%llx (level %d): freespace %u larger than nodespace %u\n"
- "%s:%d: %s oid 0x%llx (level %d): index %d key length %d longer than tree longest %d\n"
- "%s:%d: %s oid 0x%llx (level %d): index %d val length %d longer than tree longest %d\n"
- "%s:%d: %s oid 0x%llx (level %d): invalid TOC[] pointer\n"
- "%s:%d: %s oid 0x%llx (level %d): invalid child oid: 0x%llx\n"
- "%s:%d: %s oid 0x%llx (level %d): invalid key offset\n"
- "%s:%d: %s oid 0x%llx (level %d): invalid keys[] pointer\n"
- "%s:%d: %s oid 0x%llx (level %d): invalid table space offset\n"
- "%s:%d: %s oid 0x%llx (level %d): invalid val offset has non-zero length\n"
- "%s:%d: %s oid 0x%llx (level %d): invalid vals[] pointer\n"
- "%s:%d: %s oid 0x%llx (level %d): key %d compare error: %d\n"
- "%s:%d: %s oid 0x%llx (level %d): key count larger than TOC space\n"
- "%s:%d: %s oid 0x%llx (level %d): key count larger than gross key space\n"
- "%s:%d: %s oid 0x%llx (level %d): key count larger than possible\n"
- "%s:%d: %s oid 0x%llx (level %d): key entry overlaps with free space\n"
- "%s:%d: %s oid 0x%llx (level %d): key entry overlaps with other entries\n"
- "%s:%d: %s oid 0x%llx (level %d): key free list entries total space exceeds free list space\n"
- "%s:%d: %s oid 0x%llx (level %d): key free list entry extends beyond key space available\n"
- "%s:%d: %s oid 0x%llx (level %d): key free list entry len value too small\n"
- "%s:%d: %s oid 0x%llx (level %d): key free list entry overlaps with other free space\n"
- "%s:%d: %s oid 0x%llx (level %d): key free list entry points to itself\n"
- "%s:%d: %s oid 0x%llx (level %d): key free list entry starts beyond key space available\n"
- "%s:%d: %s oid 0x%llx (level %d): key free list head beyond key space available\n"
- "%s:%d: %s oid 0x%llx (level %d): key free list space larger than key space available\n"
- "%s:%d: %s oid 0x%llx (level %d): key location extends beyond key space\n"
- "%s:%d: %s oid 0x%llx (level %d): key location not within key space\n"
- "%s:%d: %s oid 0x%llx (level %d): key size greater than longest recorded for tree\n"
- "%s:%d: %s oid 0x%llx (level %d): keys out of order: %d\n"
- "%s:%d: %s oid 0x%llx (level %d): leaf node has non-zero level\n"
- "%s:%d: %s oid 0x%llx (level %d): minkey compare error: %d\n"
- "%s:%d: %s oid 0x%llx (level %d): minkey not correct\n"
- "%s:%d: %s oid 0x%llx (level %d): minkey not in sync\n"
- "%s:%d: %s oid 0x%llx (level %d): node level greater than root level %d\n"
- "%s:%d: %s oid 0x%llx (level %d): node level should be %d\n"
- "%s:%d: %s oid 0x%llx (level %d): node says kv size is fixed, but tree says key size is variable\n"
- "%s:%d: %s oid 0x%llx (level %d): node says kv size is fixed, but tree says val size is variable\n"
- "%s:%d: %s oid 0x%llx (level %d): node's max key is not less than next sibling's entry in parent\n"
- "%s:%d: %s oid 0x%llx (level %d): non-leaf node has no children?\n"
- "%s:%d: %s oid 0x%llx (level %d): root node has a parent 0x%llx (level %d)\n"
- "%s:%d: %s oid 0x%llx (level %d): table space length larger than available data space\n"
- "%s:%d: %s oid 0x%llx (level %d): table space length smaller than minimum\n"
- "%s:%d: %s oid 0x%llx (level %d): tree says key size is fixed, but node says kv size is variable\n"
- "%s:%d: %s oid 0x%llx (level %d): tree says kv sizes are fixed, but leaf says kv size is variable\n"
- "%s:%d: %s oid 0x%llx (level %d): val entry overlaps with free space\n"
- "%s:%d: %s oid 0x%llx (level %d): val entry overlaps with other entries\n"
- "%s:%d: %s oid 0x%llx (level %d): val free list entries total space exceeds free list space\n"
- "%s:%d: %s oid 0x%llx (level %d): val free list entry beyond end of node\n"
- "%s:%d: %s oid 0x%llx (level %d): val free list entry extends beyond val space available\n"
- "%s:%d: %s oid 0x%llx (level %d): val free list entry overlaps with other free space\n"
- "%s:%d: %s oid 0x%llx (level %d): val free list entry starts beyond val space available\n"
- "%s:%d: %s oid 0x%llx (level %d): val free list head beyond end of node\n"
- "%s:%d: %s oid 0x%llx (level %d): val free list head beyond val space available\n"
- "%s:%d: %s oid 0x%llx (level %d): val free list space larger than val space available\n"
- "%s:%d: %s oid 0x%llx (level %d): val location extends beyond val space\n"
- "%s:%d: %s oid 0x%llx (level %d): val location not within val space\n"
- "%s:%d: %s oid 0x%llx (level %d): val size greater than longest recorded for tree\n"
- "%s:%d: %s oid 0x%llx: btree key count (%llu) doesn't match # leaf entries (%u)\n"
- "%s:%d: %s oid 0x%llx: btree node count (%llu) doesn't match # nodes traversed (%u)\n"
- "%s:%d: %s omap entry %lld:%lld addr %lld size %d is bad\n"
- "%s:%d: %s omap entry %lld:%lld beyond deletion entry @ xid %lld\n"
- "%s:%d: %s omap entry %lld:%lld marks deletion of object with no earlier mappings\n"
- "%s:%d: %s omap entry %lld:%lld size %d seems excessive\n"
- "%s:%d: %s omap entry %lld:%lld unknown flags are set: 0x%x\n"
- "%s:%d: %s omap entry %lld:%lld xid > spaceman xid %lld\n"
- "%s:%d: %s omap snapshot count %d doesn't match snapshot tree record count %lld\n"
- "%s:%d: %s omap snapshot count %d seems excessive\n"
- "%s:%d: %s omap snapshot tree sanity check failed: %d\n"
- "%s:%d: %s omap snapshot tree type 0x%x is bad\n"
- "%s:%d: %s omap snapshot tree xid %lld > spaceman xid %lld\n"
- "%s:%d: %s omap tree entries out of order: oid %lld < %lld\n"
- "%s:%d: %s omap tree entries out of order: oid %lld xid %lld <= lastxid %lld\n"
- "%s:%d: %s omap tree sanity check failed: %d\n"
- "%s:%d: %s omap tree type 0x%x is bad\n"
- "%s:%d: %s omap tree xid %lld > spaceman xid %lld\n"
- "%s:%d: %s omap xid %lld > spaceman xid %lld\n"
- "%s:%d: %s prev doc-id tree sanity check failed: %d\n"
- "%s:%d: %s prev doc-id tree xid %lld > spaceman xid %lld\n"
- "%s:%d: %s reap list object 0x%llx first index %u larger than max %u\n"
- "%s:%d: %s reap list object 0x%llx free index %u larger than max %u\n"
- "%s:%d: %s reap list object 0x%llx last index %u larger than max %u\n"
- "%s:%d: %s reap list object 0x%llx max record count %u not expected value %u\n"
- "%s:%d: %s reap list object 0x%llx record count %d larger than max %d\n"
- "%s:%d: %s reap list tail 0x%llx is not last reap list object, next 0x%llx\n"
- "%s:%d: %s reaper check failed with error: %d\n"
- "%s:%d: %s reaper completed ID 0x%llx not less than next reap ID 0x%llx\n"
- "%s:%d: %s reaper has tail with no head\n"
- "%s:%d: %s reaper needs more cowbell, flags 0x%x\n"
- "%s:%d: %s sanity checking all container state... please be patient.\n"
- "%s:%d: %s skipping check of fs[%d] oid %lld fs root tree because it's encrypted\n"
- "%s:%d: %s spaceman IP base address is bad: %lld\n"
- "%s:%d: %s spaceman IP bitmap block %d index %d out of range\n"
- "%s:%d: %s spaceman IP bitmap block %d xid %lld > spaceman xid %lld\n"
- "%s:%d: %s spaceman IP bitmap block count is bad: %d\n"
- "%s:%d: %s spaceman IP bitmap block count is too large: %d\n"
- "%s:%d: %s spaceman IP bitmap block count is too low: %d\n"
- "%s:%d: %s spaceman IP bitmap block count per tx is too small: %d\n"
- "%s:%d: %s spaceman IP bitmap free head %d out of range\n"
- "%s:%d: %s spaceman IP bitmap free list corrupted, too long, count %lld\n"
- "%s:%d: %s spaceman IP bitmap free list corrupted, too short, count %lld\n"
- "%s:%d: %s spaceman IP bitmap free next %d, value %d invalid\n"
- "%s:%d: %s spaceman IP bitmap has too many free blocks %lld > %lld\n"
- "%s:%d: %s spaceman IP bitmap next array free count is wrong, %lld != %d\n"
- "%s:%d: %s spaceman IP bitmap tx multiplier is too small: %d\n"
- "%s:%d: %s spaceman IP bitmap unable to get bitmap block %d @ %lld: %d\n"
- "%s:%d: %s spaceman IP block count is bad: %lld\n"
- "%s:%d: %s spaceman IP bm base address is bad: %lld\n"
- "%s:%d: %s spaceman IP bm block count is bad: %d\n"
- "%s:%d: %s spaceman IP free block count is wrong %lld != %lld\n"
- "%s:%d: %s spaceman IP free queue count %lld doesn't match count in the free queue: %lld\n"
- "%s:%d: %s spaceman IP free queue count is too large: %lld > %lld\n"
- "%s:%d: %s spaceman IP free queue tree entries out of order: addr %lld < %lld\n"
- "%s:%d: %s spaceman IP free queue tree entries out of order: xid %lld < %lld\n"
- "%s:%d: %s spaceman IP free queue tree entry %lld:%lld %lld addr is bad\n"
- "%s:%d: %s spaceman IP free queue tree entry %lld:%lld %lld end addr is bad\n"
- "%s:%d: %s spaceman IP free queue tree entry %lld:%lld xid larger than spaceman xid %lld\n"
- "%s:%d: %s spaceman IP free queue tree iteration aborted with error %d\n"
- "%s:%d: %s spaceman IP free queue tree sanity check failed: %d\n"
- "%s:%d: %s spaceman block count %lld doesn't match nx superblock block count %lld\n"
- "%s:%d: %s spaceman block size %d doesn't match nx superblock block size %d\n"
- "%s:%d: %s spaceman blocks per chunk is bad: %d\n"
- "%s:%d: %s spaceman cab count is bad: %d\n"
- "%s:%d: %s spaceman chunk count is bad: %lld\n"
- "%s:%d: %s spaceman chunk info block %lld addr %lld not within IP block range\n"
- "%s:%d: %s spaceman chunks per cib is bad: %d\n"
- "%s:%d: %s spaceman cib count is bad: %d\n"
- "%s:%d: %s spaceman cibs per cab is bad: %d\n"
- "%s:%d: %s spaceman free count %lld doesn't match free count in bitmap %lld\n"
- "%s:%d: %s spaceman free count %lld doesn't match free count in chunks %lld\n"
- "%s:%d: %s spaceman free count is too large: %lld > %lld\n"
- "%s:%d: %s spaceman free queue count %lld doesn't match count in the free queue: %lld\n"
- "%s:%d: %s spaceman free queue count is too large: %lld > %lld\n"
- "%s:%d: %s spaceman free queue tree entries out of order: addr %lld < %lld\n"
- "%s:%d: %s spaceman free queue tree entries out of order: xid %lld < %lld\n"
- "%s:%d: %s spaceman free queue tree entry %lld:%lld %lld addr is bad\n"
- "%s:%d: %s spaceman free queue tree entry %lld:%lld %lld range is bad\n"
- "%s:%d: %s spaceman free queue tree entry %lld:%lld xid larger than spaceman xid %lld\n"
- "%s:%d: %s spaceman free queue tree iteration aborted with error %d\n"
- "%s:%d: %s spaceman free queue tree sanity check failed: %d\n"
- "%s:%d: %s spaceman tier2 cab count is bad: %d\n"
- "%s:%d: %s spaceman tier2 chunk count is bad: %lld\n"
- "%s:%d: %s spaceman tier2 cib count is bad: %d\n"
- "%s:%d: %s spaceman tier2 free count is too large: %lld > %lld\n"
- "%s:%d: %s superblock container size %lld greater than device size(s) %lld\n"
- "%s:%d: %s tier2 device superblock doesn't agree with main superblock\n"
- "%s:%d: %s unable to get doc-id tree: %d\n"
- "%s:%d: %s unable to get fs extentref tree: %d\n"
- "%s:%d: %s unable to get fs root tree: %d\n"
- "%s:%d: %s unable to get fs snap meta tree: %d\n"
- "%s:%d: %s unable to get prev doc-id tree: %d\n"
- "%s:%d: %s unable to get reaper: %d\n"
- "%s:%d: %s unable to get spaceman IP free queue tree: %d\n"
- "%s:%d: %s unable to get spaceman free queue tree: %d\n"
- "%s:%d: %s xid %lld failed to write superblock to fusion tier2 device block 0: %d\n"
- "%s:%d: %s<->superblock mismatch on fusion uuid, tier2=%d\n"
- "%s:%d: apfs.appex doesn't support fusion\n"
- "%s:%d: tier2 device initialization failed: %d\n"
- "(fs->apfs_sb->apfs_fs_quota_block_count == 0) || (fs->apfs_sb->apfs_fs_alloc_count <= fs->apfs_sb->apfs_fs_quota_block_count)"
- "-[APFSFileSystem formatResource:options:connection:taskID:progress:replyHandler:]"
- "-[APFSFileSystem syncRead:into:startingAt:length:]_block_invoke"
- "2332.120.31.0.2"
- "<%d"
- "<100"
- "<20"
- "<40"
- "<60"
- "<80"
- "=%d"
- "A"
- "D"
- "E"
- "FULL"
- "S"
- "apfs_deletefs"
- "appexPrint"
- "btree_check_ext"
- "btree_node_check"
- "btree_node_debug_stats"
- "btree_node_space_stats"
- "capacity: %9.2f %9.2f %9.2f %9.2f %9.2f %9.2f\n"
- "capacity: %9d %9d %9d %9d %9d %9d\n"
- "capacity: %9s %9s %9s %9s %9s %9s\n"
- "capacity: all    %llu / %llu => %.2f %% used\n"
- "capacity: leaves %llu / %llu => %.2f %% used\n"
- "capacity: nodes  %llu / %llu => %.2f %% used\n"
- "checkResource:options:connection:taskID:progress:replyHandler:"
- "completed:replyHandler:"
- "e"
- "failed to validate node %p (oid:%llu, xid:%llu) of fs %p (%llu) - %d\n"
- "formatResource:options:connection:taskID:progress:replyHandler:"
- "fusionlc=no"
- "fusionlc=yes"
- "i"
- "key/val sizes:  tree max k:%d v:%d  max k:%d v:%d  avg k:%llu v:%llu\n"
- "level %d: %d nodes\n"
- "level %d: %d nodes %.2f average descendents\n"
- "levels: %d  keys: %lld  nodes: total %d  internal: %d (%.2f%%)  leaves: %d (%.2f%%)  usage: %.2f%% (%.2f%% %.2f%%)\n"
- "nodesize: %d  dataspace: %d  key size: %d  val size: %d  max keys: node %d leaf %d  avg keys: node %d leaf %d\n"
- "nx-fusion-mt-lock"
- "nx_check"
- "nx_check_omap"
- "nx_check_reaper"
- "nx_rc_allocation_lock"
- "nx_reaper_add"
- "option"
- "optionValue"
- "options"
- "synchronousReadInto:startingAt:length:replyHandler:"
- "userfs_crypto.c"
- "v"
- "v20@?0i8@\"NSError\"12"
- "v24@?0Q8@\"NSError\"16"
- "v64@0:8@16@24@32@40@48@?56"
- "wbcsize="

```
