## VFX

> `/System/Library/PrivateFrameworks/VFX.framework/VFX`

```diff

-184.120.1.0.0
-  __TEXT.__text: 0xb4fcc4
-  __TEXT.__auth_stubs: 0x62a0
-  __TEXT.__objc_methlist: 0x1aaa4
-  __TEXT.__const: 0x86228
-  __TEXT.__gcc_except_tab: 0x59e8
-  __TEXT.__cstring: 0x9ddc0
-  __TEXT.__ustring: 0x282
-  __TEXT.__oslogstring: 0x2b8
-  __TEXT.__swift5_typeref: 0xc98e
-  __TEXT.__swift5_fieldmd: 0x1a9e8
-  __TEXT.__constg_swiftt: 0x22998
-  __TEXT.__swift5_reflstr: 0x11400
-  __TEXT.__swift5_builtin: 0x107c
-  __TEXT.__swift5_assocty: 0x3628
-  __TEXT.__swift5_protos: 0x1e0
-  __TEXT.__swift5_proto: 0x6aa8
-  __TEXT.__swift5_types: 0x214c
-  __TEXT.__swift5_capture: 0xc9c8
-  __TEXT.__swift5_mpenum: 0x28c
-  __TEXT.__swift_as_entry: 0x54
-  __TEXT.__swift_as_ret: 0x5c
-  __TEXT.__unwind_info: 0x26820
-  __TEXT.__eh_frame: 0x33c08
-  __TEXT.__objc_classname: 0x1c6b
-  __TEXT.__objc_methname: 0x29487
-  __TEXT.__objc_methtype: 0x12d8b
-  __TEXT.__objc_stubs: 0x1ede0
-  __DATA_CONST.__got: 0x1bb8
-  __DATA_CONST.__const: 0x5db8
-  __DATA_CONST.__objc_classlist: 0x1b70
-  __DATA_CONST.__objc_catlist: 0xa0
-  __DATA_CONST.__objc_protolist: 0x508
+203.0.15.502.1
+  __TEXT.__text: 0xd32824
+  __TEXT.__auth_stubs: 0x6d40
+  __TEXT.__objc_methlist: 0x1d5ec
+  __TEXT.__const: 0x8d418
+  __TEXT.__gcc_except_tab: 0x6848
+  __TEXT.__cstring: 0xbb771
+  __TEXT.__oslogstring: 0x11b7d
+  __TEXT.__ustring: 0x22
+  __TEXT.__constg_swiftt: 0x27924
+  __TEXT.__swift5_typeref: 0xdd78
+  __TEXT.__swift5_fieldmd: 0x1d8b0
+  __TEXT.__swift5_builtin: 0x1374
+  __TEXT.__swift5_reflstr: 0x13e2f
+  __TEXT.__swift5_assocty: 0x3aa8
+  __TEXT.__swift5_capture: 0x11790
+  __TEXT.__swift5_proto: 0x6f04
+  __TEXT.__swift5_types: 0x24a8
+  __TEXT.__swift5_mpenum: 0x27c
+  __TEXT.__swift5_protos: 0x1f4
+  __TEXT.__swift_as_entry: 0x68
+  __TEXT.__swift5_types2: 0x8
+  __TEXT.__swift_as_ret: 0x78
+  __TEXT.__unwind_info: 0x27e38
+  __TEXT.__eh_frame: 0x2d694
+  __TEXT.__objc_classname: 0x210c
+  __TEXT.__objc_methname: 0x2c630
+  __TEXT.__objc_methtype: 0x158b7
+  __TEXT.__objc_stubs: 0x20da0
+  __DATA_CONST.__got: 0x1e60
+  __DATA_CONST.__const: 0x7128
+  __DATA_CONST.__objc_classlist: 0x1fe0
+  __DATA_CONST.__objc_catlist: 0xb8
+  __DATA_CONST.__objc_protolist: 0x5f8
   __DATA_CONST.__objc_imageinfo: 0x8
-  __DATA_CONST.__objc_selrefs: 0xb0f0
-  __DATA_CONST.__objc_protorefs: 0x300
-  __DATA_CONST.__objc_superrefs: 0x5b8
-  __DATA_CONST.__objc_arraydata: 0x330
-  __AUTH_CONST.__auth_got: 0x3168
-  __AUTH_CONST.__const: 0x7c698
-  __AUTH_CONST.__cfstring: 0x21260
-  __AUTH_CONST.__objc_const: 0x41bc8
-  __AUTH_CONST.__objc_intobj: 0x438
-  __AUTH_CONST.__objc_arrayobj: 0xf0
+  __DATA_CONST.__objc_selrefs: 0xbd60
+  __DATA_CONST.__objc_protorefs: 0x378
+  __DATA_CONST.__objc_superrefs: 0x658
+  __DATA_CONST.__objc_arraydata: 0x368
+  __AUTH_CONST.__auth_got: 0x36b8
+  __AUTH_CONST.__const: 0x8c9b8
+  __AUTH_CONST.__cfstring: 0x194a0
+  __AUTH_CONST.__objc_const: 0x47e10
+  __AUTH_CONST.__objc_arrayobj: 0x108
+  __AUTH_CONST.__objc_intobj: 0x570
+  __AUTH_CONST.__objc_floatobj: 0x10
   __AUTH_CONST.__objc_doubleobj: 0x10
   __AUTH_CONST.__objc_dictobj: 0xf0
-  __AUTH_CONST.__objc_floatobj: 0x10
-  __AUTH.__objc_data: 0x50
-  __AUTH.__data: 0x20
+  __AUTH.__objc_data: 0xc468
+  __AUTH.__data: 0x36668
   __AUTH.__thread_vars: 0x90
   __AUTH.__thread_data: 0x8
   __AUTH.__thread_bss: 0x20
-  __DATA.__objc_ivar: 0x1b9c
-  __DATA.__data: 0xea9c
-  __DATA.__bss: 0x69e40
-  __DATA.__common: 0xa31
-  __DATA_DIRTY.__objc_data: 0xd508
-  __DATA_DIRTY.__data: 0x3d220
-  __DATA_DIRTY.__bss: 0x165f0
-  __DATA_DIRTY.__common: 0x960
+  __DATA.__objc_ivar: 0x1d18
+  __DATA.__data: 0x13814
+  __DATA.__bss: 0x7bf80
+  __DATA.__common: 0xf89
+  __DATA_DIRTY.__objc_data: 0x3fb0
+  __DATA_DIRTY.__data: 0x10e60
+  __DATA_DIRTY.__bss: 0xbbf0
+  __DATA_DIRTY.__common: 0x618
   - /System/Library/Frameworks/AVFAudio.framework/AVFAudio
   - /System/Library/Frameworks/AVFoundation.framework/AVFoundation
   - /System/Library/Frameworks/Accelerate.framework/Accelerate

   - /System/Library/Frameworks/CoreGraphics.framework/CoreGraphics
   - /System/Library/Frameworks/CoreImage.framework/CoreImage
   - /System/Library/Frameworks/CoreMedia.framework/CoreMedia
+  - /System/Library/Frameworks/CoreMotion.framework/CoreMotion
   - /System/Library/Frameworks/CoreServices.framework/CoreServices
   - /System/Library/Frameworks/CoreText.framework/CoreText
   - /System/Library/Frameworks/CoreVideo.framework/CoreVideo
+  - /System/Library/Frameworks/CryptoKit.framework/CryptoKit
   - /System/Library/Frameworks/Foundation.framework/Foundation
   - /System/Library/Frameworks/IOKit.framework/Versions/A/IOKit
   - /System/Library/Frameworks/IOSurface.framework/IOSurface
   - /System/Library/Frameworks/ImageIO.framework/ImageIO
+  - /System/Library/Frameworks/JavaScriptCore.framework/JavaScriptCore
   - /System/Library/Frameworks/Metal.framework/Metal
   - /System/Library/Frameworks/MetalFX.framework/MetalFX
   - /System/Library/Frameworks/MetalKit.framework/MetalKit
   - /System/Library/Frameworks/MetalPerformanceShaders.framework/MetalPerformanceShaders
   - /System/Library/Frameworks/ModelIO.framework/ModelIO
+  - /System/Library/Frameworks/Network.framework/Network
   - /System/Library/Frameworks/QuartzCore.framework/QuartzCore
   - /System/Library/Frameworks/SceneKit.framework/SceneKit
+  - /System/Library/Frameworks/Security.framework/Security
   - /System/Library/Frameworks/UIKit.framework/UIKit
   - /System/Library/Frameworks/UniformTypeIdentifiers.framework/UniformTypeIdentifiers
   - /System/Library/PrivateFrameworks/CoreSymbolication.framework/CoreSymbolication
   - /System/Library/PrivateFrameworks/CoreUI.framework/CoreUI
-  - /System/Library/PrivateFrameworks/UIKitCore.framework/UIKitCore
+  - /System/Library/PrivateFrameworks/UIFoundation.framework/UIFoundation
   - /usr/lib/libMobileGestalt.dylib
   - /usr/lib/libSystem.B.dylib
   - /usr/lib/libc++.1.dylib

   - /usr/lib/swift/libswiftCoreAudio.dylib
   - /usr/lib/swift/libswiftCoreFoundation.dylib
   - /usr/lib/swift/libswiftCoreImage.dylib
+  - /usr/lib/swift/libswiftCoreLocation.dylib
   - /usr/lib/swift/libswiftCoreMIDI.dylib
   - /usr/lib/swift/libswiftCoreMedia.dylib
   - /usr/lib/swift/libswiftDarwin.dylib
-  - /usr/lib/swift/libswiftDataDetection.dylib
   - /usr/lib/swift/libswiftDispatch.dylib
   - /usr/lib/swift/libswiftGLKit.dylib
   - /usr/lib/swift/libswiftMetal.dylib

   - /usr/lib/swift/libswiftQuartzCore.dylib
   - /usr/lib/swift/libswiftRegexBuilder.dylib
   - /usr/lib/swift/libswiftSceneKit.dylib
+  - /usr/lib/swift/libswiftSpatial.dylib
   - /usr/lib/swift/libswiftUniformTypeIdentifiers.dylib
   - /usr/lib/swift/libswiftXPC.dylib
   - /usr/lib/swift/libswift_Builtin_float.dylib
   - /usr/lib/swift/libswift_Concurrency.dylib
+  - /usr/lib/swift/libswift_DarwinFoundation1.dylib
+  - /usr/lib/swift/libswift_DarwinFoundation2.dylib
+  - /usr/lib/swift/libswift_DarwinFoundation3.dylib
   - /usr/lib/swift/libswift_StringProcessing.dylib
-  - /usr/lib/swift/libswift_errno.dylib
-  - /usr/lib/swift/libswift_math.dylib
-  - /usr/lib/swift/libswift_signal.dylib
-  - /usr/lib/swift/libswift_stdio.dylib
-  - /usr/lib/swift/libswift_time.dylib
   - /usr/lib/swift/libswiftos.dylib
   - /usr/lib/swift/libswiftsimd.dylib
-  - /usr/lib/swift/libswiftsys_time.dylib
-  - /usr/lib/swift/libswiftunistd.dylib
-  UUID: 58583DB8-9740-3C27-A82A-D537A11B4857
-  Functions: 59928
-  Symbols:   2356
-  CStrings:  24072
+  UUID: E585B030-113D-39DC-B3CC-6972D1308133
+  Functions: 65908
+  Symbols:   2601
+  CStrings:  24889
 
Symbols:
+ OBJC_IVAR_$_VFXCameraEffect._world
+ OBJC_IVAR_$_VFXCameraEffect._worldReferenceCounter
+ _AVCaptureDeviceTypeBuiltInDualCamera
+ _AVCaptureDeviceTypeBuiltInLiDARDepthCamera
+ _AVCaptureDeviceTypeBuiltInTelephotoCamera
+ _AVCaptureDeviceTypeBuiltInTripleCamera
+ _AVCaptureDeviceTypeBuiltInTrueDepthCamera
+ _AVCaptureDeviceTypeBuiltInUltraWideCamera
+ _AVCaptureDeviceTypeBuiltInWideAngleCamera
+ _AVCaptureDeviceTypeContinuityCamera
+ _AVCaptureDeviceTypeDeskViewCamera
+ _AVCaptureDeviceTypeExternal
+ _AVVideoAverageBitRateKey
+ _AVVideoCompressionPropertiesKey
+ _AVVideoMaxKeyFrameIntervalKey
+ _AVVideoProfileLevelH264HighAutoLevel
+ _AVVideoProfileLevelKey
+ _CFArrayGetValues
+ _CFStringCreateWithCStringNoCopy
+ _CFXBufferAllocatorGetAlignment
+ _CFXBufferAllocatorPerFrameAlignedSize
+ _CFXBufferAllocatorPerFrameAllocateWithBytes
+ _CFXBufferAllocatorPerFrameAllocateWithLength
+ _CFXBufferAllocatorPerFrameClear
+ _CFXBufferAllocatorPerFrameCreate
+ _CFXBufferAllocatorPerFrameFree
+ _CFXBufferAllocatorPerFrameGetCurrentFrameBufferCount
+ _CFXBufferAllocatorPerFrameGetCurrentFrameBufferSize
+ _CFXBufferAllocatorPerFrameGetUnusedFrameCountBeforeFree
+ _CFXBufferAllocatorPerFrameNextFrame
+ _CFXBufferAllocatorSetAlignment
+ _CFXBufferSliceDidModify
+ _CFXBufferSliceGetCPUPointer
+ _CFXBufferSliceGetGPUAddress
+ _CFXBufferSliceGetMTLBuffer
+ _CFXBufferSliceMake
+ _CFXColorGetLinearExtendedSRGBComponents
+ _CFXDepthStencilDescCopyDescription
+ _CFXDepthStencilDescMakeDefault
+ _CFXGPUDeviceCreate
+ _CFXGPUDeviceCreateBuffer
+ _CFXGPUDeviceCreateBufferWithBytes
+ _CFXGPUDeviceCreateBufferWithLength
+ _CFXGPUDeviceCreateDepthStencil
+ _CFXGPUDeviceCreateDepthStencilWithLabel
+ _CFXGPUDeviceCreateSampler
+ _CFXGPUDeviceCreateSamplerWithLabel
+ _CFXGPUDeviceCreateTemporaryBufferWithBytes
+ _CFXGPUDeviceCreateTexture
+ _CFXGPUDeviceCreateTextureWithIOSurface
+ _CFXGPUDeviceCreateTextureWithIOSurfaceAndDesc
+ _CFXGPUDeviceCreateWithOptions
+ _CFXGPUDeviceFetchAllNewlyCreatedBuffers
+ _CFXGPUDeviceFetchAllNewlyCreatedTextures
+ _CFXGPUDeviceFetchAllNewlyDestroyedBuffers
+ _CFXGPUDeviceFetchAllNewlyDestroyedTextures
+ _CFXGPUDeviceGetCounterStorage
+ _CFXGPUDeviceGetDepthStencilDesc
+ _CFXGPUDeviceGetFrameworkLibrary
+ _CFXGPUDeviceGetMTLDevice
+ _CFXGPUDeviceGetMinConstantBufferAlignment
+ _CFXGPUDeviceGetSamplerDesc
+ _CFXGPUDeviceSupportsMemoryLess
+ _CFXStencilDescMakeDefault
+ _CFXStencilDescMakeDisabled
+ _CFXTextureAllocatorPerFrameAllocate
+ _CFXTextureAllocatorPerFrameClear
+ _CFXTextureAllocatorPerFrameCreate
+ _CFXTextureAllocatorPerFrameFree
+ _CFXTextureAllocatorPerFrameNextFrame
+ _CFXTextureDescriptorByDiscardingMultisampling
+ _CFXTextureDescriptorByPromotingToMultisampledIfNeeded
+ _CFXTextureDescriptorComputeBytesPerTexture
+ _CFXTextureDescriptorComputeMaxMipLevelCount
+ _CFXTextureDescriptorFillMTLDescriptor
+ _CFXTextureDescriptorFromMTLTexture
+ _CFXTextureDescriptorFromMTLTextureDescriptor
+ _CFXTextureDescriptorIsValid
+ _CFXTextureDescriptorMake1D
+ _CFXTextureDescriptorMake2D
+ _CFXTextureDescriptorMake2DArray
+ _CFXTextureDescriptorMake2DMultisampledIfNeeded
+ _CFXTextureDescriptorMake3D
+ _CFXTextureDescriptorMakeCube
+ _CFXTextureDescriptorMakeDefault
+ _CGBitmapContext_unpremultiply
+ _CGColorSpaceCreateDeviceRGB
+ _CGColorSpaceEqualToColorSpaceIgnoringRange
+ _CGContextRestoreGState
+ _CGContextSaveGState
+ _CGContextSetBlendMode
+ _CGImageDestinationCreateWithData
+ _CGPathApplyWithBlock
+ _CGPathCreateCopy
+ _CGPathCreateWithRect
+ _CGPathGetBoundingBox
+ _CGRectGetMaxX
+ _CGRectGetMaxY
+ _CGRectGetMinX
+ _CGRectGetMinY
+ _CStackAllocatorCheckIsReset
+ _CStackAllocatorGetStackIndex
+ _CTFrameDraw
+ _CTParagraphStyleCreate
+ _CVBufferCopyAttachments
+ _CVImageBufferCreateColorSpaceFromAttachments
+ _CVPixelBufferRetain
+ _IOServiceGetMatchingService
+ _JSObjectGetArrayBufferBytesPtr
+ _JSObjectGetTypedArrayBuffer
+ _JSObjectGetTypedArrayByteLength
+ _JSObjectMakeTypedArray
+ _MPSRectNoClip
+ _NSBackgroundColorAttributeName
+ _NSSelectorFromString
+ _OBJC_CLASS_$_AVCaptureDeviceDiscoverySession
+ _OBJC_CLASS_$_AVURLAsset
+ _OBJC_CLASS_$_CAMetalDisplayLink
+ _OBJC_CLASS_$_CFXRemoteArgumentEncoder
+ _OBJC_CLASS_$_CFXRemoteRenderCommandEncoder
+ _OBJC_CLASS_$_CMMotionManager
+ _OBJC_CLASS_$_JSContext
+ _OBJC_CLASS_$_JSValue
+ _OBJC_CLASS_$_MPSImageAreaMax
+ _OBJC_CLASS_$_MPSImageAreaMin
+ _OBJC_CLASS_$_MPSImageBox
+ _OBJC_CLASS_$_MPSImageCanny
+ _OBJC_CLASS_$_MPSImageConvolution
+ _OBJC_CLASS_$_MPSImageDilate
+ _OBJC_CLASS_$_MPSImageErode
+ _OBJC_CLASS_$_MPSImageLaplacian
+ _OBJC_CLASS_$_MPSImageSobel
+ _OBJC_CLASS_$_MPSImageTent
+ _OBJC_CLASS_$_MTLCommandBufferDescriptor
+ _OBJC_CLASS_$_MTLVertexAttributeDescriptor
+ _OBJC_CLASS_$_MTLVertexBufferLayoutDescriptor
+ _OBJC_CLASS_$_NSInvocation
+ _OBJC_CLASS_$_NSNull
+ _OBJC_CLASS_$_NSXPCInterface
+ _OBJC_CLASS_$_SCNBezierCurveGeometry
+ _OBJC_CLASS_$_VFXARKitGazeTracker
+ _OBJC_CLASS_$_VFXARKitHandTracker
+ _OBJC_CLASS_$_VFXAudioAsset
+ _OBJC_CLASS_$_VFXBezierCurveGeometry
+ _OBJC_CLASS_$_VFXDrawCall
+ _OBJC_CLASS_$_VFXMetalLibraryProvider
+ _OBJC_CLASS_$_VFXREWorldSimulation
+ _OBJC_CLASS_$_VFXRemotePreviewPlayerPeer
+ _OBJC_CLASS_$_VFXRemoteRendererProxy
+ _OBJC_CLASS_$_VFXRemoteRendererProxyRegistry
+ _OBJC_CLASS_$_VFXRendererRayMap
+ _OBJC_CLASS_$_VFXShaderCacheConfiguration
+ _OBJC_CLASS_$_VFXStateTransition
+ _OBJC_CLASS_$_VFXWorldProvider
+ _OBJC_CLASS_$__TtC3VFX20EntityPropertyHelper
+ _OBJC_METACLASS_$_CFXRemoteArgumentEncoder
+ _OBJC_METACLASS_$_CFXRemoteRenderCommandEncoder
+ _OBJC_METACLASS_$_VFXARKitGazeTracker
+ _OBJC_METACLASS_$_VFXARKitHandTracker
+ _OBJC_METACLASS_$_VFXAudioAsset
+ _OBJC_METACLASS_$_VFXBezierCurveGeometry
+ _OBJC_METACLASS_$_VFXDrawCall
+ _OBJC_METACLASS_$_VFXMetalLibraryProvider
+ _OBJC_METACLASS_$_VFXREWorldSimulation
+ _OBJC_METACLASS_$_VFXRemotePreviewPlayerPeer
+ _OBJC_METACLASS_$_VFXRemoteRendererProxy
+ _OBJC_METACLASS_$_VFXRemoteRendererProxyRegistry
+ _OBJC_METACLASS_$_VFXRendererRayMap
+ _OBJC_METACLASS_$_VFXShaderCacheConfiguration
+ _OBJC_METACLASS_$_VFXStateTransition
+ _OBJC_METACLASS_$_VFXWorldProvider
+ _OBJC_METACLASS_$__TtC3VFX20EntityPropertyHelper
+ _RGContextTransferResources
+ _RGCrossFrameResourceManagerTransferResources
+ _RGGPUResourceManagerGetPreviousFrameTexture
+ _RGPassIsNull
+ _RGResourceIsEqual
+ _RGTextureReferenceDescriptorClearTextureType
+ _RGTextureReferenceDescriptorCopy
+ _RGTextureReferenceDescriptorGetTextureType
+ _RGTextureReferenceDescriptorIsNull
+ _RGTextureReferenceDescriptorSetTextureType
+ _UTTypeHEIC
+ _VFXCoreGetRecordingShaderArchive
+ _VFXCoreGetShaderCache
+ _VFXCoreSetBinaryArchives
+ _VFXGetRemoteRendererInterface
+ _VFXMTLTexturePixelFormatIsStencil
+ _VFXRenderGraphMainColorAttachment
+ _VFXRenderGraphMainDepthAttachment
+ _VFXRendererInitForRemoteDecoding
+ _VFXRendererInitForRemoteEncoding
+ _VFXRendererInitOptionForRE
+ _VFXTriggerTypeCollisionBegan
+ _VFXTriggerTypeCollisionEnded
+ _VFXTriggerTypeCollisionUpdate
+ _VFXTriggerTypeGazeTracking
+ _VFXTriggerTypeHandTracking
+ _VFXTriggerTypeMotionTracking
+ _VFXTriggerTypeParticleCollision
+ _VFXTriggerTypeTapBegan
+ _VFXTriggerTypeTapCancelled
+ _VFXTriggerTypeTapDragged
+ _VFXTriggerTypeTapEnded
+ _VFXVersionNumber
+ _VFXWorldExportCompressMeshElements
+ _VFXWorldExportOptimize
+ _VFXWorldInitOptionForRE
+ _VFXWorldLoaderAllowLoadingEffectFromTheFuture
+ _VFXWorldLoaderCompileGraphsCallback
+ _VFXWorldLoaderConformToSubdivisionScheme
+ _VFXWorldLoaderLoadForRE
+ __CFIsObjC
+ __VFXMaterialIdentifierKey
+ __VFXShadableInterfaceDidChangeNotificationName
+ __Z22RGBuilderCreateTexture9RGBuilderPKc20CFXTextureDescriptor
+ __Z27RGBuilderCreateCopyIfNeeded9RGBuilderPKc10RGResource6RGPass20CFXTextureDescriptor
+ __Z30RGBuilderCreateExternalTexture9RGBuilderPKc20CFXTextureDescriptorU13block_pointerFPU22objcproto11MTLResource11objc_objecthEU13block_pointerFvS4_E
+ __Z30RGBuilderCreateExternalTexture9RGBuilderPKc28RGTextureReferenceDescriptorU13block_pointerFPU22objcproto11MTLResource11objc_objecthEU13block_pointerFvS4_E
+ __Z34RGTextureReferenceDescriptorCreate20CFXTextureDescriptor
+ __ZN3CFX18GPUResourceManager10getTextureEPKNS_2RG8ResourceENS1_8TemporalE
+ __ZN3CFX18GPUResourceManager12transferFromEPS0_
+ __ZN3CFX18GPUResourceManager34incrementLastWriteIndexForResourceEPNS_2RG8ResourceE
+ __ZN3CFX18GPUResourceManager9getBufferEPKNS_2RG8ResourceENS1_8TemporalE
+ __ZN3CFX18GPUResourceManagerC1EP14__CFXGPUDevicej
+ __ZN3CFX18GPUResourceManagerC2EP14__CFXGPUDevicej
+ __ZN3CFX25CrossFrameResourceManagerC1Ev
+ __ZN3CFX25CrossFrameResourceManagerC2Ev
+ __ZN3CFX25CrossFrameResourceManagerD1Ev
+ __ZN3CFX25CrossFrameResourceManagerD2Ev
+ __ZN3CFX2RG11RenderGraph21passesReadingResourceEPNS0_8ResourceENS_14StackAllocatorEh
+ __ZN3CFX2RG11RenderGraph7executeERKNS0_18RenderGraphContextE16RGExecutionPhaseRKNS0_9ArgumentsE
+ __ZN3CFX2RG17BlitPassArgumentsC1EPU32objcproto21MTLBlitCommandEncoder11objc_object
+ __ZN3CFX2RG17BlitPassArgumentsC1ERKS1_
+ __ZN3CFX2RG17BlitPassArgumentsC2EPU32objcproto21MTLBlitCommandEncoder11objc_object
+ __ZN3CFX2RG17BlitPassArgumentsC2ERKS1_
+ __ZN3CFX2RG17BlitPassArgumentsD1Ev
+ __ZN3CFX2RG17BlitPassArgumentsD2Ev
+ __ZN3CFX2RG17IncrementTemporalEPNS0_11RenderGraphERNS0_18RenderGraphContextE
+ __ZN3CFX2RG18AttachmentProvider20textureForAttachmentENS0_18ResourceIdentifierE20CFXTextureDescriptor
+ __ZN3CFX2RG18RenderGraphBuilder12registerPassEyPNS0_4PassE
+ __ZN3CFX2RG18RenderGraphBuilder16validateTemporalERKNS0_18RenderGraphContextE
+ __ZN3CFX2RG18RenderGraphBuilder29passesMatchingClassIdentifierEyNS_14StackAllocatorE
+ __ZN3CFX2RG18RenderGraphContext12transferFromEPS1_
+ __ZN3CFX2RG18RenderGraphContext25computeResourceDescriptorEPKNS0_8ResourceER20CFXTextureDescriptor
+ __ZN3CFX2RG18RenderGraphContext27tryResolveTextureDescriptorERKNS0_26TextureDescriptorReferenceER20CFXTextureDescriptor
+ __ZN3CFX2RG18RenderGraphContextC1EP14__CFXGPUDevicej
+ __ZN3CFX2RG18RenderGraphContextC2EP14__CFXGPUDevicej
+ __ZN3CFX2RG19RenderGraphProvider12generateTestEP14__CFXGPUDevicePNS0_29RenderGraphProviderParametersE
+ __ZN3CFX2RG19RenderGraphProvider14encodeIfNeededERNS0_18RenderGraphContextEPNS0_18RenderGraphBuilderEPNS0_29RenderGraphProviderParametersERNSt3__112basic_stringIcNS8_11char_traitsIcEENS8_9allocatorIcEEEE
+ __ZN3CFX2RG19RenderGraphProvider20logNonOptimisedGraphEP14__CFXGPUDevice
+ __ZN3CFX2RG19RenderGraphProvider5buildEPNS0_18RenderGraphBuilderERNS0_18RenderGraphContextEPNS0_29RenderGraphProviderParametersERNSt3__112basic_stringIcNS8_11char_traitsIcEENS8_9allocatorIcEEEE
+ __ZN3CFX2RG19RenderPassArgumentsC1EP28RGCachedRenderCommandEncoderP23MTLRenderPassDescriptorhh
+ __ZN3CFX2RG19RenderPassArgumentsC1ERKS1_
+ __ZN3CFX2RG19RenderPassArgumentsC2EP28RGCachedRenderCommandEncoderP23MTLRenderPassDescriptorhh
+ __ZN3CFX2RG19RenderPassArgumentsC2ERKS1_
+ __ZN3CFX2RG19RenderPassArgumentsD1Ev
+ __ZN3CFX2RG19RenderPassArgumentsD2Ev
+ __ZN3CFX2RG19isBuildInResourceIdEj
+ __ZN3CFX2RG20ComputePassArgumentsC1EP29RGCachedComputeCommandEncoder
+ __ZN3CFX2RG20ComputePassArgumentsC1ERKS1_
+ __ZN3CFX2RG20ComputePassArgumentsC2EP29RGCachedComputeCommandEncoder
+ __ZN3CFX2RG20ComputePassArgumentsC2ERKS1_
+ __ZN3CFX2RG20ComputePassArgumentsD1Ev
+ __ZN3CFX2RG20ComputePassArgumentsD2Ev
+ __ZN3CFX2RG20ExternalResourceDescC1E18RGBufferDescriptorU13block_pointerFPU22objcproto11MTLResource11objc_objecthEU13block_pointerFvS4_E
+ __ZN3CFX2RG20ExternalResourceDescC1ENS0_26TextureDescriptorReferenceEU13block_pointerFPU22objcproto11MTLResource11objc_objecthEU13block_pointerFvS4_E
+ __ZN3CFX2RG20ExternalResourceDescC2E18RGBufferDescriptorU13block_pointerFPU22objcproto11MTLResource11objc_objecthEU13block_pointerFvS4_E
+ __ZN3CFX2RG20ExternalResourceDescC2ENS0_26TextureDescriptorReferenceEU13block_pointerFPU22objcproto11MTLResource11objc_objecthEU13block_pointerFvS4_E
+ __ZN3CFX2RG20RegisterResourcePass12storeManagedERNSt3__110unique_ptrINS0_8ResourceENS4_14ManagedDeleterEEE
+ __ZN3CFX2RG21RendererPassArgumentsC1EPU19objcproto9MTLDevice11objc_objectPU26objcproto15MTLCommandQueue11objc_objectPU27objcproto16MTLCommandBuffer11objc_object
+ __ZN3CFX2RG21RendererPassArgumentsC1ERKS1_
+ __ZN3CFX2RG21RendererPassArgumentsC2EPU19objcproto9MTLDevice11objc_objectPU26objcproto15MTLCommandQueue11objc_objectPU27objcproto16MTLCommandBuffer11objc_object
+ __ZN3CFX2RG21RendererPassArgumentsC2ERKS1_
+ __ZN3CFX2RG21RendererPassArgumentsD1Ev
+ __ZN3CFX2RG21RendererPassArgumentsD2Ev
+ __ZN3CFX2RG24sortSubgraphDependenciesERNS0_18RenderGraphContextERNS_5ArrayIPNS0_8SubgraphELj0ENS_15MallocAllocatorEEEPNSt3__112basic_stringIcNS9_11char_traitsIcEENS9_9allocatorIcEEEE
+ __ZN3CFX2RG26TextureDescriptorReferenceC1ERK20CFXTextureDescriptor
+ __ZN3CFX2RG26TextureDescriptorReferenceC2ERK20CFXTextureDescriptor
+ __ZN3CFX2RG29RenderGraphProviderParameters10enablePassEy
+ __ZN3CFX2RG29RenderGraphProviderParameters11disablePassEy
+ __ZN3CFX2RG33UpdateResourceUsageAndStorageModeERNS0_18RenderGraphContextEPNS0_11RenderGraphEPNS0_4PassEPNS0_8ResourceE
+ __ZN3CFX2RG4Pass12replaceReadsEONS_5ArrayINS1_4ReadELj8ENS_16ScratchAllocatorEEE
+ __ZN3CFX2RG4Pass8readFromEPNS0_8ResourceENS0_8TemporalE
+ __ZN3CFX2RG8Resource17transferDeleterToEPNS_18GPUResourceManagerE
+ __ZN3CFX2RG8ResourceC1EPKc18RGBufferDescriptor11VFXLifetimeh
+ __ZN3CFX2RG8ResourceC1EPKcNS0_17ResourceReferenceE11VFXLifetimeh
+ __ZN3CFX2RG8ResourceC1EPKcNS0_20ExternalResourceDescE11VFXLifetimeh
+ __ZN3CFX2RG8ResourceC1EPKcNS0_26TextureDescriptorReferenceE11VFXLifetimeh
+ __ZN3CFX2RG8ResourceC2EPKc18RGBufferDescriptor11VFXLifetimeh
+ __ZN3CFX2RG8ResourceC2EPKcNS0_17ResourceReferenceE11VFXLifetimeh
+ __ZN3CFX2RG8ResourceC2EPKcNS0_20ExternalResourceDescE11VFXLifetimeh
+ __ZN3CFX2RG8ResourceC2EPKcNS0_26TextureDescriptorReferenceE11VFXLifetimeh
+ __ZN3CFX2RG8Subgraph11requirementERNS0_18RenderGraphContextE
+ __ZN3CFX2RG8Subgraph23buildResourceIdentifierEtj
+ __ZN3CFX2RG8Subgraph4hashERNS0_18RenderGraphContextERKNS0_22SubgraphBuildArgumentsE
+ __ZN3CFX2RG8Subgraph4initERNS0_18RenderGraphContextE
+ __ZN3CFX2RG8Subgraph5buildERNS0_18RenderGraphContextERNS0_18RenderGraphBuilderERKNS0_22SubgraphBuildArgumentsE
+ __ZN3CFX2RG8Subgraph6outputERNS0_18RenderGraphContextE
+ __ZN3CFX2RG8SubgraphC1EPKc
+ __ZN3CFX2RG8SubgraphC2EPKc
+ __ZN3CFX2RG8Temporal12currentFrameEv
+ __ZN3CFX2RG8Temporal13previousFrameEv
+ __ZNK3CFX18GPUResourceManager9gpuDeviceEv
+ __ZNK3CFX2RG17BlitPassArguments7encoderEv
+ __ZNK3CFX2RG18RenderGraphBuilder8findPassEy
+ __ZNK3CFX2RG18RenderGraphContext5statsEv
+ __ZNK3CFX2RG19RenderPassArguments10sliceIndexEv
+ __ZNK3CFX2RG19RenderPassArguments14passDescriptorEv
+ __ZNK3CFX2RG19RenderPassArguments7encoderEv
+ __ZNK3CFX2RG19RenderPassArguments8mipIndexEv
+ __ZNK3CFX2RG20ComputePassArguments7encoderEv
+ __ZNK3CFX2RG21RendererPassArguments13commandBufferEv
+ __ZNK3CFX2RG21RendererPassArguments5queueEv
+ __ZNK3CFX2RG21RendererPassArguments6deviceEv
+ __ZNK3CFX2RG22SubgraphBuildArguments10isDisabledEy
+ __ZNK3CFX2RG26TextureDescriptorReference11withWidthIfEbt
+ __ZNK3CFX2RG26TextureDescriptorReference18partialResolveIntoER20CFXTextureDescriptor
+ __ZNK3CFX2RG29RenderGraphProviderParameters10isDisabledEy
+ __ZNK3CFX2RG8Resource10frameCountEv
+ __ZNK3CFX2RG8Resource10hasDeleterEv
+ __ZNK3CFX2RG8Resource10setDeleterENS1_7DeleterE
+ __ZNK3CFX2RG8Resource18validateFrameCountEv
+ __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6resizeEmc
+ __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc
+ __ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEb
+ __ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEl
+ __ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEy
+ __ZNSt3__15mutex4lockEv
+ __ZNSt3__15mutex6unlockEv
+ __ZNSt3__15mutexD1Ev
+ __ZNSt3__16localeC1Ev
+ __ZNSt3__1plIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_12basic_stringIT_T0_T1_EEPKS6_RKS9_
+ __ZSt7nothrow
+ __ZTVN3CFX2RG8SubgraphE
+ __ZTVNSt3__115basic_streambufIcNS_11char_traitsIcEEEE
+ __ZnwmRKSt9nothrow_t
+ __os_log_debug_impl
+ __os_log_fault_impl
+ __os_log_impl
+ __swift_FORCE_LOAD_$_swiftCoreLocation
+ __swift_FORCE_LOAD_$_swiftSpatial
+ __swift_FORCE_LOAD_$_swift_DarwinFoundation1
+ __swift_FORCE_LOAD_$_swift_DarwinFoundation2
+ __swift_FORCE_LOAD_$_swift_DarwinFoundation3
+ _compute_fog_parameters
+ _exp2
+ _getpagesize
+ _ivar_getOffset
+ _kCVImageBufferColorPrimariesKey
+ _kCVImageBufferTransferFunctionKey
+ _kCVImageBufferYCbCrMatrixKey
+ _mach_error_string
+ _matrix_identity_float3x3
+ _modf
+ _objc_exception_throw
+ _object_getInstanceVariable
+ _prof_eventTimeRangeDynamicString
+ _prof_flag_main
+ _prof_resumeCollectProfilers
+ _prof_stopCollectProfilers
+ _sec_protocol_options_add_pre_shared_key
+ _sec_protocol_options_append_tls_ciphersuite
+ _sec_protocol_options_set_min_tls_protocol_version
+ _sel_isEqual
+ _swift_coroFrameAlloc
+ _swift_getFunctionTypeMetadata
+ _swift_getFunctionTypeMetadata2
+ _swift_isEscapingClosureAtFileLocation
+ _swift_runtimeSupportsNoncopyableTypes
+ _swift_task_getMainExecutor
+ _swift_task_isCurrentExecutor
+ _swift_task_reportUnexpectedExecutor
+ _task_info
+ _vfx_counters_add_counter_recorded
+ _vfx_script_create_buffer_from_array
+ _vfx_script_get_ecs_value
+ _vfx_script_get_gaze_data
+ _vfx_script_get_hand_data
+ _vfx_script_get_hand_data_tracked
+ _vfx_script_get_motion_data
+ _vfx_script_get_particle_collision
+ _vfx_script_get_world
+ _vfx_script_get_world_renderer
+ _vfx_script_get_world_value
+ _vfx_script_invalidate_render_target
+ _vfx_script_is_key_down
+ _vfx_script_is_run_mode
+ _vfx_script_set_ecs_value
+ _vfx_script_set_world_value
+ _vfx_script_start_timer
+ _vfx_script_stop_timer
+ _vfx_script_string_join
+ _vfx_script_string_to_objc
+ _xpc_shmem_create
+ _xpc_shmem_map
- _CFDictionaryGetTypeID
- _CFSetGetValue
- _CGBitmapContext_gammaizeAlpha
- _CGPathAddRect
- _NSInternalInconsistencyException
- _NSURLContentModificationDateKey
- _OBJC_CLASS_$_AVAsset
- _OBJC_CLASS_$_CADisplayLink
- _OBJC_CLASS_$_CIFilter
- _OBJC_CLASS_$_CIImage
- _OBJC_CLASS_$_MTLStencilDescriptor
- _OBJC_CLASS_$_NSPropertyListSerialization
- _OBJC_CLASS_$_OS_os_log
- _OBJC_CLASS_$_RGCachedComputeCommandEncoder
- _OBJC_CLASS_$_UIFocusSystem
- _OBJC_CLASS_$_VFXCameraControlEventHandler
- _OBJC_CLASS_$_VFXCameraEffectSSAO
- _OBJC_CLASS_$_VFXCompositorRenderer
- _OBJC_CLASS_$_VFXMetalLayer
- _OBJC_CLASS_$__TtC3VFX23VFXSceneLightParameters
- _OBJC_CLASS_$__TtC3VFX24VFXRemotePreviewEndpoint
- _OBJC_METACLASS_$_CAMetalLayer
- _OBJC_METACLASS_$_RGCachedComputeCommandEncoder
- _OBJC_METACLASS_$_VFXCameraControlEventHandler
- _OBJC_METACLASS_$_VFXCameraEffectSSAO
- _OBJC_METACLASS_$_VFXCompositorRenderer
- _OBJC_METACLASS_$_VFXMetalLayer
- _OBJC_METACLASS_$__TtC3VFX23VFXSceneLightParameters
- _OBJC_METACLASS_$__TtC3VFX24VFXRemotePreviewEndpoint
- _RGBuilderCreateExternalTexture
- _RGTextureDescriptorByDiscardingMultisampling
- _RGTextureDescriptorByPromotingToMultisampledIfNeeded
- _RGTextureDescriptorComputeMaxMipLevelCount
- _RGTextureDescriptorFillMTLDescriptor
- _RGTextureDescriptorFromMTLTexture
- _RGTextureDescriptorFromMTLTextureDescriptor
- _RGTextureDescriptorIsValid
- _RGTextureDescriptorMake1D
- _RGTextureDescriptorMake2D
- _RGTextureDescriptorMake2DMultisampledIfNeeded
- _RGTextureDescriptorMake3D
- _RGTextureDescriptorMakeCube
- _RGTextureDescriptorMakeDefault
- _VFXAnimationCommitOnCompletion
- _VFXCompositorRendererLayoutKey
- _VFXHitTestFirstFoundOnlyKey
- _VFXHitTestSortResultsKey
- _VFXModelTransform
- _VFXModelViewProjectionTransform
- _VFXModelViewTransform
- _VFXNormalTransform
- _VFXProgramMappingChannelKey
- _VFXProjectionTransform
- _VFXTriggerTypeMouseDown
- _VFXTriggerTypeMouseDragged
- _VFXTriggerTypeMouseUp
- _VFXTriggerTypeTouchBegan
- _VFXTriggerTypeTouchCanceled
- _VFXTriggerTypeTouchEnded
- _VFXTriggerTypeTouchMoved
- _VFXVFXVersionNumber
- _VFXViewTransform
- _VFXWorldExportCompressGeometryElements
- _VFXWorldInitOptionForAuthoring
- _VFXWorldLoaderAssumeLinearDisplayP3SourceColorSpaceKey
- _VFXWorldLoaderIgnoreVertexColorsKey
- __VFXShadableGeometryKey
- __VFXShadableMaterialKey
- __Z22RGBuilderCreateTexture9RGBuilderPKc19RGTextureDescriptor
- __Z27RGBuilderCreateCopyIfNeeded9RGBuilderPKc10RGResource6RGPass19RGTextureDescriptor
- __Z34RGTextureReferenceDescriptorCreate19RGTextureDescriptor
- __ZN3CFX10BufferPool4freeE13VFXBufferView
- __ZN3CFX10BufferPool5Frame15prepareForReuseEv
- __ZN3CFX10BufferPool8allocateE18RGBufferDescriptor
- __ZN3CFX10BufferPool9nextFrameEv
- __ZN3CFX10BufferPoolC1EPNS_12GPUAllocatorE14MTLStorageModej
- __ZN3CFX10BufferPoolC2EPNS_12GPUAllocatorE14MTLStorageModej
- __ZN3CFX10BufferPoolD1Ev
- __ZN3CFX10BufferPoolD2Ev
- __ZN3CFX18GPUResourceManager10getTextureEPKNS_2RG8ResourceE
- __ZN3CFX18GPUResourceManager9getBufferEPKNS_2RG8ResourceE
- __ZN3CFX18GPUResourceManagerC1EPNS_12GPUAllocatorEj
- __ZN3CFX18GPUResourceManagerC2EPNS_12GPUAllocatorEj
- __ZN3CFX23ConstantBufferAlignSizeEm
- __ZN3CFX2RG11RenderGraph21passesReadingResourceEPNS0_8ResourceENS_14StackAllocatorE
- __ZN3CFX2RG11RenderGraph7executeERKNS0_18RenderGraphContextE16RGExecutionPhase
- __ZN3CFX2RG18AttachmentProvider20textureForAttachmentENS0_18ResourceIdentifierE19RGTextureDescriptor
- __ZN3CFX2RG18RenderGraphContext25computeResourceDescriptorEPKNS0_8ResourceER19RGTextureDescriptor
- __ZN3CFX2RG18RenderGraphContext27tryResolveTextureDescriptorERKNS0_26TextureDescriptorReferenceER19RGTextureDescriptor
- __ZN3CFX2RG18RenderGraphContextC1EPNS_12GPUAllocatorEj
- __ZN3CFX2RG18RenderGraphContextC2EPNS_12GPUAllocatorEj
- __ZN3CFX2RG19RenderGraphProvider14encodeIfNeededERNS0_18RenderGraphContextEPNS0_18RenderGraphBuilderERNSt3__112basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEE
- __ZN3CFX2RG20ExternalResourceDescC1E18RGBufferDescriptorU13block_pointerFPU22objcproto11MTLResource11objc_objectvEU13block_pointerFvS4_E
- __ZN3CFX2RG20ExternalResourceDescC1ENS0_26TextureDescriptorReferenceEU13block_pointerFPU22objcproto11MTLResource11objc_objectvEU13block_pointerFvS4_E
- __ZN3CFX2RG20ExternalResourceDescC2E18RGBufferDescriptorU13block_pointerFPU22objcproto11MTLResource11objc_objectvEU13block_pointerFvS4_E
- __ZN3CFX2RG20ExternalResourceDescC2ENS0_26TextureDescriptorReferenceEU13block_pointerFPU22objcproto11MTLResource11objc_objectvEU13block_pointerFvS4_E
- __ZN3CFX2RG26TextureDescriptorReferenceC1ERK19RGTextureDescriptor
- __ZN3CFX2RG26TextureDescriptorReferenceC2ERK19RGTextureDescriptor
- __ZN3CFX2RG4Pass12replaceReadsEONS_5ArrayIPNS0_8ResourceELj8ENS_16ScratchAllocatorEEE
- __ZN3CFX2RG4Pass8readFromEPNS0_8ResourceE
- __ZN3CFX2RG8ResourceC1EPKc18RGBufferDescriptor11VFXLifetime
- __ZN3CFX2RG8ResourceC1EPKcNS0_17ResourceReferenceE11VFXLifetime
- __ZN3CFX2RG8ResourceC1EPKcNS0_20ExternalResourceDescE11VFXLifetime
- __ZN3CFX2RG8ResourceC1EPKcNS0_26TextureDescriptorReferenceE11VFXLifetime
- __ZN3CFX2RG8ResourceC2EPKc18RGBufferDescriptor11VFXLifetime
- __ZN3CFX2RG8ResourceC2EPKcNS0_17ResourceReferenceE11VFXLifetime
- __ZN3CFX2RG8ResourceC2EPKcNS0_20ExternalResourceDescE11VFXLifetime
- __ZN3CFX2RG8ResourceC2EPKcNS0_26TextureDescriptorReferenceE11VFXLifetime
- __ZNK3CFX10BufferPool15resourceOptionsEv
- __ZNK3CFX10BufferPool22frameCountWithoutReuseEv
- __ZNK3CFX18GPUResourceManager9allocatorEv
- __ZNK3CFX2RG26TextureDescriptorReference18partialResolveIntoER19RGTextureDescriptor
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEPKc
- __ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEt
- __ZNSt3__115basic_streambufIcNS_11char_traitsIcEEEC2Ev
- __ZNSt3__115basic_streambufIcNS_11char_traitsIcEEED2Ev
- __dispatch_source_type_data_add
- __swift_FORCE_LOAD_$_swiftDataDetection
- __swift_FORCE_LOAD_$_swift_errno
- __swift_FORCE_LOAD_$_swift_math
- __swift_FORCE_LOAD_$_swift_signal
- __swift_FORCE_LOAD_$_swift_stdio
- __swift_FORCE_LOAD_$_swift_time
- __swift_FORCE_LOAD_$_swiftsys_time
- __swift_FORCE_LOAD_$_swiftunistd
- __vfx_swift_has_weak_ref
- _dispatch_async_and_wait
- _dispatch_once_f
- _dispatch_retain
- _dispatch_source_merge_data
- _dlsym_default
- _dlsym_self
- _meshopt_initialize
- _objc_retain_x12
- _os_workgroup_attr_set_flags
- _os_workgroup_create
- _os_workgroup_join
- _os_workgroup_leave
- _ptr_auth_strip
- _swift_continuation_throwingResume
- _swift_continuation_throwingResumeWithError
- _swift_cvw_assignWithCopy
- _swift_cvw_assignWithTake
- _swift_cvw_destroy
- _swift_cvw_initWithCopy
- _swift_cvw_initializeBufferWithCopyOfBuffer
- _vfx_script_set_current_state
- _vfx_swift_deimmortalize
- _vfx_swift_is_immortal
- _vfx_swift_release_dealloc
- _wmemchr
CStrings:
+ "\t_lightingContribution.add_spot(vfx_lights[%@], u_shadowTexture%d, u_shadowKernel, %d, u_goboTexture%d, u_goboTexture%dSampler);\n"
+ "\n\n\n\n\n\n\n\n#define CFX_OSD_RT_TESS_GRID_POINTS_PER_EDGE 5\n#define CFX_OSD_RT_TESS_GRID_SEGMENTS_PER_EDGE (CFX_OSD_RT_TESS_GRID_POINTS_PER_EDGE-1)\n\n#define kOpenSubdivRaytracingVertexStrideFunctionConstantIndex          1\n#define kOpenSubdivRaytracingVertexPositionOffsetFunctionConstantIndex  2\n#define kOpenSubdivRaytracingVertexNormalOffsetFunctionConstantIndex    3\n\n#define kOpenSubdivRaytracingVertexTexcoord0OffsetFunctionConstantIndex 4\n#define kOpenSubdivRaytracingVertexTexcoord1OffsetFunctionConstantIndex 5\n#define kOpenSubdivRaytracingVertexTexcoord2OffsetFunctionConstantIndex 6\n#define kOpenSubdivRaytracingVertexTexcoord3OffsetFunctionConstantIndex 7\n\n#define kOpenSubdivRaytracingGenerateTexcoord0FunctionConstantIndex     8\n#define kOpenSubdivRaytracingGenerateTexcoord1FunctionConstantIndex     9\n#define kOpenSubdivRaytracingGenerateTexcoord2FunctionConstantIndex    10\n#define kOpenSubdivRaytracingGenerateTexcoord3FunctionConstantIndex    11\n\ntypedef struct __attribute__((__packed__)) {\n    uint32_t patchID;\n#if defined(__METAL_VERSION__)\n    packed_float2 UV;\n#else\n    simd_packed_float2 UV;\n#endif\n} osd_rt_extra_point;\n"
+ "\n\n\n\n\n\n\n\n#import <metal_stdlib>\nusing namespace metal;\n\n#import \"CFX-OpenSubdiv-Raytracing.h\"\n\nconstant short vertexStride     [[ function_constant(kOpenSubdivRaytracingVertexStrideFunctionConstantIndex) ]];\n\nconstant short positionOffset   [[ function_constant(kOpenSubdivRaytracingVertexPositionOffsetFunctionConstantIndex)  ]];\nconstant short normalOffset     [[ function_constant(kOpenSubdivRaytracingVertexNormalOffsetFunctionConstantIndex)    ]];\nconstant short texcoord0Offset  [[ function_constant(kOpenSubdivRaytracingVertexTexcoord0OffsetFunctionConstantIndex) ]];\nconstant short texcoord1Offset  [[ function_constant(kOpenSubdivRaytracingVertexTexcoord1OffsetFunctionConstantIndex) ]];\nconstant short texcoord2Offset  [[ function_constant(kOpenSubdivRaytracingVertexTexcoord2OffsetFunctionConstantIndex) ]];\nconstant short texcoord3Offset  [[ function_constant(kOpenSubdivRaytracingVertexTexcoord3OffsetFunctionConstantIndex) ]];\n\nconstant bool generateTexcoord0 [[ function_constant(kOpenSubdivRaytracingGenerateTexcoord0FunctionConstantIndex) ]];\nconstant bool generateTexcoord1 [[ function_constant(kOpenSubdivRaytracingGenerateTexcoord1FunctionConstantIndex) ]];\nconstant bool generateTexcoord2 [[ function_constant(kOpenSubdivRaytracingGenerateTexcoord2FunctionConstantIndex) ]];\nconstant bool generateTexcoord3 [[ function_constant(kOpenSubdivRaytracingGenerateTexcoord3FunctionConstantIndex) ]];\n\nstatic int OsdGetPatchNumControlVertices(int patchType) {\n    switch(patchType) {\n        case 3: return 4;\n        case 6: return 16;\n        case 9: return 20;\n        default: return 0;\n    }\n}\n\n\n\nstatic void osd_rt_eval_vertex(device float*      dstData,\n                               OsdVertexBufferSet osdBuffers,\n                               uint               patchID,\n                               float2             UV)\n{\n    int3 patchParam = osdBuffers.patchParamBuffer[patchID];\n    device OsdPerPatchVertexBezier *cv = osdBuffers.perPatchVertexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH;\n    \n    float3 P, dPu, dPv;\n    float3 N, dNu, dNv;\n    float2 vSegments;\n    \n    OsdEvalPatchBezier(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv, vSegments);\n    \n    *(device packed_float3 *)(dstData + positionOffset) = P;\n    *(device packed_float3 *)(dstData + normalOffset)   = N;\n}\n\n\n\n#if defined(OSD_FVAR_WIDTH)\n\nstatic void osd_rt_eval_fvar(device float*                dstData,\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n                             constant uint32_t&           osdFaceVaryingChannelCount,\n                             constant OsdFVarChannelDesc* osdFaceVaryingChannelDescriptors,\n                             constant uint32_t&           osdFaceVaryingPatchArrayIndex,\n                             constant void*               osdFaceVaryingChannelsPackedData,\n#else\n                             constant float*              osdFaceVaryingData,\n                             constant int*                osdFaceVaryingIndices,\n                             constant packed_int3*        osdFaceVaryingPatchParams,\n                             constant packed_int4&        osdFaceVaryingPatchArray,\n#endif \n                             uint                         patchID,\n                             float2                       UV)\n{\n    float2 texcoord0 = 0.f;\n    \n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n    \n    \n    \n#else \n    \n    int3 fvarPatchParam = osdFaceVaryingPatchParams[patchID];\n    bool isRegular = OsdGetPatchIsRegular(fvarPatchParam);\n    \n    int4 patchArray = osdFaceVaryingPatchArray;\n    int patchStride = OsdGetPatchNumControlVertices(patchArray.x);\n    int patchType = select(patchArray.x, int(6), isRegular);\n    int patchCVs = OsdGetPatchNumControlVertices(patchType);\n    \n    float wP[20], wDs[20], wDt[20], wDss[20], wDst[20], wDtt[20];\n    \n    if (patchType == 3) {\n        OsdGetBilinearPatchWeights(UV.x, UV.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);\n    } else if (patchType == 6) {\n        int boundaryMask = OsdGetPatchBoundaryMask(fvarPatchParam);\n        OsdGetBSplinePatchWeights(UV.x, UV.y, 1.0f, boundaryMask, wP, wDs, wDt, wDss, wDst, wDtt);\n    } else if (patchType == 9) {\n        OsdGetGregoryPatchWeights(UV.x, UV.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);\n    }\n    \n    for (int i = 0; i < patchCVs; ++i) {\n        int dataIdx = osdFaceVaryingIndices[patchID * patchStride + i] * OSD_FVAR_WIDTH + 0 ;\n#if OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING\n        dataIdx += 4;\n#endif\n#if OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING\n        if (generateTexcoord0) {\n            texcoord0 += wP[i] * float2(osdFaceVaryingData[dataIdx], osdFaceVaryingData[dataIdx+1]);\n        }\n        dataIdx += 2;\n#endif\n#if OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING\n        dataIdx += 2;\n#endif\n#if OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING\n        dataIdx += 2;\n#endif\n#if OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING\n        dataIdx += 2;\n#endif\n#if OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING\n        dataIdx += 2;\n#endif\n#if OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING\n        dataIdx += 2;\n#endif\n#if OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING\n        dataIdx += 2;\n#endif\n#if OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING\n        dataIdx += 2;\n#endif\n    }\n    \n#endif \n    \n    if (generateTexcoord0) {\n        *(device packed_float2 *)(dstData + texcoord0Offset) = texcoord0;\n    }\n}\n\n#endif \n\n\n\nkernel void osd_rt_eval_regular_point_vertex(uint               index      [[ thread_position_in_grid ]],\n                                             constant uint&     pointCount [[ buffer(0) ]],\n                                             device float*      dstData    [[ buffer(1) ]],\n                                             OsdVertexBufferSet osdBuffers)\n{\n    if (index >= pointCount)\n        return;\n    \n    \n    \n    uint patchID      = index / (CFX_OSD_RT_TESS_GRID_POINTS_PER_EDGE * CFX_OSD_RT_TESS_GRID_POINTS_PER_EDGE);\n    uint gridVertexID = index % (CFX_OSD_RT_TESS_GRID_POINTS_PER_EDGE * CFX_OSD_RT_TESS_GRID_POINTS_PER_EDGE);\n    float2 UV         = float2(gridVertexID % CFX_OSD_RT_TESS_GRID_POINTS_PER_EDGE, gridVertexID / CFX_OSD_RT_TESS_GRID_POINTS_PER_EDGE) / (float)(CFX_OSD_RT_TESS_GRID_POINTS_PER_EDGE - 1);\n    \n    osd_rt_eval_vertex(dstData + index * vertexStride, osdBuffers, patchID, UV);\n}\n\nkernel void osd_rt_eval_extra_point_vertex(uint                         index       [[ thread_position_in_grid ]],\n                                           constant uint&               pointCount  [[ buffer(0) ]],\n                                           device float*                dstData     [[ buffer(1) ]],\n                                           constant osd_rt_extra_point* extraPoints [[ buffer(2) ]],\n                                           OsdVertexBufferSet           osdBuffers)\n{\n    if (index >= pointCount)\n        return;\n    \n    \n    \n    osd_rt_extra_point extraPoint = extraPoints[index];\n    \n    osd_rt_eval_vertex(dstData + index * vertexStride, osdBuffers, extraPoint.patchID, extraPoint.UV);\n}\n\n#if defined(OSD_FVAR_WIDTH)\n\nkernel void osd_rt_eval_regular_point_fvar(uint                         index                            [[ thread_position_in_grid ]],\n                                           constant uint&               pointCount                       [[ buffer(0) ]],\n                                           device float*                dstData                          [[ buffer(1) ]],\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n                                           constant uint32_t&           osdFaceVaryingChannelCount       [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_COUNT_INDEX) ]],\n                                           constant OsdFVarChannelDesc* osdFaceVaryingChannelDescriptors [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_DESCRIPTORS_INDEX) ]],\n                                           constant uint32_t&           osdFaceVaryingPatchArrayIndex    [[ buffer(OSD_FVAR_CHANNELS_PATCH_ARRAY_INDEX_BUFFER_INDEX) ]],\n                                           constant void*               osdFaceVaryingChannelsPackedData [[ buffer(OSD_FVAR_CHANNELS_PACKED_DATA_BUFFER_INDEX) ]]\n#else\n                                           constant float*              osdFaceVaryingData               [[ buffer(OSD_FVAR_DATA_BUFFER_INDEX) ]],\n                                           constant int*                osdFaceVaryingIndices            [[ buffer(OSD_FVAR_INDICES_BUFFER_INDEX) ]],\n                                           constant packed_int3*        osdFaceVaryingPatchParams        [[ buffer(OSD_FVAR_PATCHPARAM_BUFFER_INDEX) ]],\n                                           constant packed_int4&        osdFaceVaryingPatchArray         [[ buffer(OSD_FVAR_PATCH_ARRAY_BUFFER_INDEX) ]]\n#endif\n                                           )\n{\n    if (index >= pointCount)\n        return;\n    \n    \n    \n    uint patchID      = index / (CFX_OSD_RT_TESS_GRID_POINTS_PER_EDGE * CFX_OSD_RT_TESS_GRID_POINTS_PER_EDGE);\n    uint gridVertexID = index % (CFX_OSD_RT_TESS_GRID_POINTS_PER_EDGE * CFX_OSD_RT_TESS_GRID_POINTS_PER_EDGE);\n    float2 UV         = float2(gridVertexID % CFX_OSD_RT_TESS_GRID_POINTS_PER_EDGE, gridVertexID / CFX_OSD_RT_TESS_GRID_POINTS_PER_EDGE) / (float)(CFX_OSD_RT_TESS_GRID_POINTS_PER_EDGE - 1);\n    \n    osd_rt_eval_fvar(dstData + index * vertexStride,\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n                     osdFaceVaryingChannelCount,\n                     osdFaceVaryingChannelDescriptors,\n                     osdFaceVaryingPatchArrayIndex,\n                     osdFaceVaryingChannelsPackedData,\n#else\n                     osdFaceVaryingData,\n                     osdFaceVaryingIndices,\n                     osdFaceVaryingPatchParams,\n                     osdFaceVaryingPatchArray,\n#endif\n                     patchID,\n                     UV);\n}\n\nkernel void osd_rt_eval_extra_point_fvar(uint                         index                            [[ thread_position_in_grid ]],\n                                         constant uint&               pointCount                       [[ buffer(0) ]],\n                                         device float*                dstData                          [[ buffer(1) ]],\n                                         constant osd_rt_extra_point* extraPoints                      [[ buffer(2) ]],\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n                                         constant uint32_t&           osdFaceVaryingChannelCount       [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_COUNT_INDEX) ]],\n                                         constant OsdFVarChannelDesc* osdFaceVaryingChannelDescriptors [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_DESCRIPTORS_INDEX) ]],\n                                         constant uint32_t&           osdFaceVaryingPatchArrayIndex    [[ buffer(OSD_FVAR_CHANNELS_PATCH_ARRAY_INDEX_BUFFER_INDEX) ]],\n                                         constant void*               osdFaceVaryingChannelsPackedData [[ buffer(OSD_FVAR_CHANNELS_PACKED_DATA_BUFFER_INDEX) ]]\n#else\n                                         constant float*              osdFaceVaryingData               [[ buffer(OSD_FVAR_DATA_BUFFER_INDEX) ]],\n                                         constant int*                osdFaceVaryingIndices            [[ buffer(OSD_FVAR_INDICES_BUFFER_INDEX) ]],\n                                         constant packed_int3*        osdFaceVaryingPatchParams        [[ buffer(OSD_FVAR_PATCHPARAM_BUFFER_INDEX) ]],\n                                         constant packed_int4&        osdFaceVaryingPatchArray         [[ buffer(OSD_FVAR_PATCH_ARRAY_BUFFER_INDEX) ]]\n#endif\n                                         )\n{\n    if (index >= pointCount)\n        return;\n    \n    \n    \n    osd_rt_extra_point extraPoint = extraPoints[index];\n    \n    osd_rt_eval_fvar(dstData + index * vertexStride,\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n                     osdFaceVaryingChannelCount,\n                     osdFaceVaryingChannelDescriptors,\n                     osdFaceVaryingPatchArrayIndex,\n                     osdFaceVaryingChannelsPackedData,\n#else\n                     osdFaceVaryingData,\n                     osdFaceVaryingIndices,\n                     osdFaceVaryingPatchParams,\n                     osdFaceVaryingPatchArray,\n#endif\n                     extraPoint.patchID,\n                     extraPoint.UV);\n    \n}\n\n#endif \n"
+ "\n\n\n\n\n#include <TargetConditionals.h>\n\n\n#if TARGET_OS_OSX || TARGET_OS_MACCATALYST\n    \n    \n    #define SHOULD_CHECK_IF_OUTSIDE_TEXTURE  0\n    #define RETURN_IF_OUTSIDE_TEXTURE(dst)\n    #define RETURN_IF_OUTSIDE_TEXTURE3D(dst)\n#else\n    #define SHOULD_CHECK_IF_OUTSIDE_TEXTURE  1\n    #define RETURN_IF_OUTSIDE_TEXTURE(dst)   if ((index.x >= dst.get_width()) || (index.y >= dst.get_height())) return;\n    #define RETURN_IF_OUTSIDE_TEXTURE3D(dst) if ((index.x >= dst.get_width()) || (index.y >= dst.get_height()) || (index.z >= dst.get_depth())) return;\n#endif\n\n#if __METAL_VERSION__ >= 220\n    #define SUPPORTS_LAYERED_RENDERING           1\n    #define SUPPORTS_MULTIPLE_VIEWPORT_RENDERING 1\n#else\n    #if TARGET_OS_OSX || TARGET_OS_MACCATALYST\n        #define SUPPORTS_LAYERED_RENDERING           (__METAL_VERSION__ >= 200)\n        #define SUPPORTS_MULTIPLE_VIEWPORT_RENDERING (__METAL_VERSION__ >= 200)\n    #else\n        #define SUPPORTS_LAYERED_RENDERING           (__METAL_VERSION__ >= 210)\n        #define SUPPORTS_MULTIPLE_VIEWPORT_RENDERING (__METAL_VERSION__ >= 210)\n    #endif\n#endif\n\n\n#define GOLDEN_RATIO 1.61803398875\n#define GOLDEN_RATIO_H 1.61803398875h\n#define GOLDEN_ANGLE 2.399963229728\n#define GOLDEN_ANGLE_H 2.399963229728h\n\n\n\n\nnamespace vfx {\n    \n    \n    static inline float4 reduce_op(float4 d0, float4 d1)\n    {\n        d0.x = min(d0.x, d1.x);\n        d0.y = max(d0.y, d1.y);\n        d0.z += d1.z;\n        d0.w += d1.w;\n        return d0;\n    }\n    \n    inline float vector_reduce_min(float4 v)\n    {\n        float2 min_lh = min(v.xy, v.zw);\n        return min(min_lh.x, min_lh.y);\n    }\n    \n    inline float vector_reduce_max(float4 v)\n    {\n        float2 max_lh = max(v.xy, v.zw);\n        return max(max_lh.x, max_lh.y);\n    }\n    \n    inline int vector_reduce_add(int4 v)\n    {\n        int2 add_lh = v.xy + v.zw;\n        return add_lh.x + add_lh.y;\n    }\n    \n    inline float3x3 mat3(float4x4 mat4)\n    {\n        return float3x3(mat4[0].xyz, mat4[1].xyz, mat4[2].xyz);\n    }\n    \n    inline float3 mat4_mult_float3_normalized(float4x4 matrix, float3 src)\n    {\n        float3 dst  =  src.xxx * matrix[0].xyz;\n        dst         += src.yyy * matrix[1].xyz;\n        dst         += src.zzz * matrix[2].xyz;\n        return normalize(dst);\n    }\n    \n    inline float3 mat4_mult_float3(float4x4 matrix, float3 src)\n    {\n        float3 dst  =  src.xxx * matrix[0].xyz;\n        dst         += src.yyy * matrix[1].xyz;\n        dst         += src.zzz * matrix[2].xyz;\n        return dst;\n    }\n\n    inline float3 matrix_rotate(float4x4 mat, float3 dir)\n    {\n        return  dir.xxx * mat[0].xyz +\n                dir.yyy * mat[1].xyz +\n                dir.zzz * mat[2].xyz;\n    }\n\n    inline float4 matrix_transform(float4x4 mat, float3 pos)\n    {\n        return  pos.xxxx * mat[0] +\n                pos.yyyy * mat[1] +\n                pos.zzzz * mat[2] +\n                           mat[3];\n    }\n\n    inline float3 quaternion_rotate_vector(float4 q, float3 v)\n    {\n        float3 t = 2.f * cross(q.xyz, v);\n        return v + q.w * t + cross(q.xyz, t);\n    }\n\n    \n    template <class T>\n    inline vec<T, 3> robust_normalize(vec<T, 3> v)\n    {\n        vec<T, 3> zero = 0.;\n        return all(v == zero) ? zero : normalize(v);\n    }\n\n    template <class T>\n    inline void generate_basis(vec<T, 3> inR, thread vec<T, 3> *outS, thread vec<T, 3> *outT)\n    {\n        \n        T x  = -inR.x;\n        T y  = inR.y;\n        T z  = inR.z;\n        T sz = copysign(T(1.), z);\n        T a  = y / (abs(z) + T(1.));\n        T b  = y * a;\n        T c  = x * a;\n        *outS = (vec<T, 3>){ z + sz * b,  sz * c,       x       };\n        *outT = (vec<T, 3>){ c,           T(1.) - b,    -sz * y };\n    }\n    \n    \n    \n    inline float3 blend_add(float3 base, float3 blend)\n    {\n        return min(base + blend, 1.0);\n    }\n    \n    inline float3 blend_lighten(float3 base, float3 blend)\n    {\n        return max(blend, base);\n    }\n    \n    inline float3 blend_screen(float3 base, float3 blend)\n    {\n        return (1.0 - ((1.0 - base) * (1.0 - blend)));\n    }\n\n    \n    \n    inline half sq(half f) {\n        return f * f;\n    }\n\n    inline float sq(float f) {\n        return f * f;\n    }\n    \n    inline float2 sincos(float angle) {\n        float cs;\n        float sn = ::sincos(angle, cs);\n        return float2(sn, cs);\n    }\n    \n    \n    inline float acos_fast(float f) {\n        float x = abs(f);\n        float res = -0.156583f * x + M_PI_2_F;\n        res *= sqrt(1.0f - x);\n        return (f >= 0.f) ? res : M_PI_F - res;\n    }\n\n    inline float asin_fast(float f)\n    {\n        return M_PI_2_F - acos_fast(f);\n    }\n\n    \n    inline float atan_fast(float inX)\n    {\n        float  x = inX;\n        return x*(-0.1784f * abs(x) - 0.0663f * x * x + 1.0301f);\n    }\n    \n    inline float atan2_fast(float y, float x)\n    {\n        float sx = x > 0.f ? -1.f : 1.f;\n        float abs_y = abs(y) + 1e-10f; \n        float r = (x + abs_y*sx) / (abs_y - x*sx);\n        float angle = sx * M_PI_4_F + M_PI_2_F;\n        angle      += (0.1963f * r * r - 0.9817f) * r;\n        return y > 0.f ? angle : -angle;\n    }\n    \n    \n    template <class T>\n    inline vec<T, 3> cartesian_from_spherical(vec<T, 2> uv)\n    {\n        \n        \n        T cos_phi;\n        T phi = uv.x * 2.0f * M_PI_F;\n        T sin_phi = ::sincos(phi, cos_phi);\n        \n        T cos_theta;\n        T theta     = uv.y * M_PI_F;\n        T sin_theta = ::sincos(theta, cos_theta);\n\n        return vec<T, 3>(cos_phi * sin_theta,\n                         cos_theta,\n                         -sin_phi * sin_theta);\n    }\n\n    inline float2 spherical_from_cartesian(float3 dir)\n    {\n        return float2( atan2(-dir.z, dir.x) * (0.5f * M_1_PI_F), acos(dir.y) * M_1_PI_F);\n    }\n\n    inline half2 spherical_from_cartesian(half3 dir)\n    {\n        return half2(atan2(-dir.z, dir.x) * 0.5h, acos(dir.y)) * M_1_PI_H;\n    }\n\n    inline float2 spherical_from_cartesian_fast(float3 dir)\n    {\n        return float2( atan2_fast(-dir.z, dir.x) * (0.5f * M_1_PI_F), acos_fast(dir.y) * M_1_PI_F);\n    }\n\n    inline half2 spherical_from_cartesian_fast(half3 dir)\n    {\n        return half2( atan2_fast(-dir.z, dir.x) * 0.5h, acos_fast(dir.y)) * M_1_PI_H;\n    }\n\n    #define dual_contract_factor  1.0\n\n    template <class T>\n    inline vec<T, 2> dual_paraboloid_from_cartesian(vec<T, 3> dir)\n    {\n        dir.xy /= abs(dir.z) + 1.0;\n\n        dir.y = 0.5 - dir.y * 0.5;\n        T s   = sign(dir.z) * 0.25;\n        dir.x = s * (dir.x - 1.0) + 0.5;\n        return dir.xy;\n    }\n    \n    \n    template <class T>\n    inline vec<T, 3> cartesian_from_dual_paraboloid(vec<T, 2>  uv)\n    {\n        \n        T zside = 0.5 * sign(0.5 - uv.x);\n        uv.x = 1.0 - abs(4.0 * uv.x - 2.0); \n        uv.y   = 1.0 - uv.y * 2.0;\n        T z = length_squared(uv); \n        z = (1.0 - z) * zside;\n        \n        return vec<T, 3>(uv.x, uv.y, z);\n    }\n\n    \n    template <class T>\n    inline vec<T, 2> signNotZero(vec<T, 2> v) {\n        return vec<T, 2>((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n    }\n\n    template <class T>\n    inline vec<T, 2> octEncode(vec<T, 3> v) {\n        float2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n        return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n    }\n\n    template <class T>\n    inline vec<T, 3> octDecode(vec<T, 2> p) {\n        float3 v = float3(p.xy, 1.0 - abs(p.x) - abs(p.y));\n        if (v.z < 0) v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);\n        return normalize(v);\n    }\n\n    inline float reduce_min(float3 v) {\n        return min(v.x, min(v.y, v.z));\n    }\n    \n    inline float reduce_min(float4 v) {\n        return min(min(v.x, v.y), min(v.z, v.w));\n    }\n\n    inline float reduce_max(float3 v) {\n        return max(v.x, max(v.y, v.z));\n    }\n\n    inline float reduce_max(float4 v) {\n        return max(max(v.x, v.y), max(v.z, v.w));\n    }\n\n    \n    inline float3 randomSphereDir(float2 rnd)\n    {\n        float s = rnd.x * M_PI_F * 2.f;\n        float t = rnd.y * 2.f - 1.f;\n        return float3( float2(sin(s), cos(s)) * sqrt(1.f-t*t), t );\n    }\n    \n    \n    template <class T>\n    inline T interleaved_gradient_noise(vec<T, 2> pos)\n    {\n        vec<T, 3> magic( 0.06711056f, 0.00583715f, 52.9829189f );\n        return fract( magic.z * fract( dot( pos, magic.xy ) ) );\n    }\n    \n    inline float3 hemisphere_reflect(float3 v, float3 nrm)\n    {\n        \n        \n        \n        float k = dot(v,nrm);\n        return (k>0.0) ? v : v-2.0*nrm*k;\n    }\n\n    \n    inline float3 randomHemisphereDir(float3 dir, float2 rnd)\n    {\n        return hemisphere_reflect(randomSphereDir( rnd ), dir);\n    }\n    \n    inline void orthogonal_basis(float3 n, thread float3& xp, thread float3& yp)\n    {\n        \n        float sz = n.z >= 0.f ? 1.f : -1.f;\n        float a  =  n.y / (1.f + abs(n.z));\n        float b  =  n.y * a;\n        float c  = -n.x * a;\n        \n        xp = float3(n.z + sz * b,   sz * c,     -n.x);\n        yp = float3(c,              1.f - b,    -sz * n.y);\n    }\n\n    template <class U>\n    inline float2 normalized_coordinate(ushort2 index, U texture)\n    {\n        uint width  = texture.get_width();\n        uint height = texture.get_height();\n        \n        float u = width  == 1 ? 0.5f : float(index.x) / float(width - 1);\n        float v = height == 1 ? 0.5f : float(index.y) / float(height - 1);\n        \n        return float2(u, v);\n    }\n\n    template <class U>\n    inline float2 normalized_coordinate(uint2 index, U texture)\n    {\n        uint width  = texture.get_width();\n        uint height = texture.get_height();\n        \n        float u = width  == 1 ? 0.5f : float(index.x) / float(width - 1);\n        float v = height == 1 ? 0.5f : float(index.y) / float(height - 1);\n        \n        return float2(u, v);\n    }\n\n    template <class U>\n    inline half2 normalized_coordinate_half(uint2 index, U texture)\n    {\n        uint width  = texture.get_width();\n        uint height = texture.get_height();\n        \n        half u = width  == 1 ? 0.5h : half(index.x) / half(width - 1);\n        half v = height == 1 ? 0.5h : half(index.y) / half(height - 1);\n        \n        return half2(u, v);\n    }\n\n    \n    \n    \n    inline float2 R2(float2 jitt, float i) {\n        const float2 a = float2(0.245122333753, 0.4301597090025);\n        return fract(a * i + jitt);\n    }\n\n    \n\n    template <class T>\n    inline vec<T, 3> cubemap_dir_from_sampleCoord(uint face, vec<T, 2> sampleCoord) \n    {\n        switch(face) {\n            case 0: \n                return vec<T, 3>( 1.0, -sampleCoord.y, -sampleCoord.x);\n\n            case 1: \n                return vec<T, 3>(-1.0, -sampleCoord.y,  sampleCoord.x);\n\n            case 2: \n                return vec<T, 3>(sampleCoord.x,  1.0,  sampleCoord.y);\n\n            case 3: \n                return vec<T, 3>(sampleCoord.x, -1.0, -sampleCoord.y);\n\n            case 4: \n                return vec<T, 3>( sampleCoord.x, -sampleCoord.y,  1.0);\n\n            default: \n                return vec<T, 3>(-sampleCoord.x, -sampleCoord.y, -1.0);\n        }\n    }\n\n    \n    template <class T>\n    inline T signed_unit(T uv) {\n        return uv * 2.0 - 1.0;\n    }\n\n    \n    template <class T>\n    inline T unsigned_unit(T uv) {\n        return uv * 0.5 + 0.5;\n    }\n\n    template <class T>\n    inline vec<T, 3> cubemap_dir_from_uv(uint face, vec<T, 2> uv) \n    {\n        return cubemap_dir_from_sampleCoord(face, signed_unit(uv));\n    }\n\n    template <class T>\n    inline vec<T, 3> cubemap_dir_from_uv_unit(uint face, vec<T, 2> uv) \n    {\n        return normalize(cubemap_dir_from_uv(face, uv));\n    }\n\n    \n    \n    inline float2 barycentric_mix(float2 __x, float2 __y, float2 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }\n    inline float3 barycentric_mix(float3 __x, float3 __y, float3 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }\n    inline float4 barycentric_mix(float4 __x, float4 __y, float4 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }\n    \n    static inline float rect(float2 lt, float2 rb, float2 uv)\n    {\n        float2 borders = step(lt, uv) * step(uv, rb);\n        return borders.x * borders.y;\n    }\n    \n    inline half4 debugColorForCascade(int cascade)\n    {\n        switch (cascade) {\n            case 0:\n            return half4(1.h, 0.h, 0.h, 1.h);\n            case 1:\n            return half4(0.9, 0.5, 0., 1.);\n            case 2:\n            return half4(1., 1., 0., 1.);\n            case 3:\n            return half4(0., 1., 0., 1.);\n            default:\n            return half4(0., 0., 0., 1.);\n        }\n    }\n\n    inline half3 debugColorForFace(int count)\n    {\n        switch (count) {\n            case 0:  return half3(1.0h, 0.1h, 0.1h);\n            case 1:  return half3(0.1h, 1.0h, 1.0h);\n            case 2:  return half3(0.1h, 1.0h, 0.1h);\n            case 3:  return half3(1.0h, 0.1h, 1.0h);\n            case 4:  return half3(0.1h, 0.1h, 1.0h);\n            default: return half3(1.0h, 1.0h, 0.1h);\n        }\n    }\n\n    inline half4 debugColorForCount(int count)\n    {\n        switch (count) {\n            case 0: return half4(0.0h, 0.0h, 0.0h, 1.h);\n            case 1: return half4(0.0h, 0.0h, 0.4h, 1.h);\n            case 2: return half4(0.0h, 0.0h, 0.9h, 1.h);\n            case 3: return half4(0.0h, 0.4h, 0.7h, 1.h);\n            case 4: return half4(0.0h, 0.9h, 0.4h, 1.h);\n            case 5: return half4(0.0h, 0.9h, 0.0h, 1.h);\n            case 6: return half4(0.4h, 0.7h, 0.0h, 1.h);\n            case 7: return half4(0.9h, 0.7h, 0.0h, 1.h);\n            default: return half4(1., 0., 0., 1.);\n        }\n    }\n\n    inline float grid(float2 lt, float2 rb, float2 gridSize, float thickness, float2 uv)\n    {\n        float insideRect = rect(lt, rb + thickness, uv);\n        float2 gt = thickness * gridSize;\n        float2 lines = step(abs(lt - fract(uv * gridSize)), gt);\n        return insideRect * (lines.x + lines.y);\n    }\n\n    inline float checkerboard(float2 gridSize, float2 uv)\n    {\n        float2 check = floor(uv * gridSize);\n        return step(fmod(check.x + check.y, 2.f), 0.f);\n    }\n\n    \n\n    inline float luminance(float3 color)\n    {\n        \n        \n        return dot(color, float3(0.212671, 0.715160, 0.072169));\n    }\n    inline half luminance(half3 color)\n    {\n        \n        \n        return dot(color, half3(0.212671h, 0.715160h, 0.072169h));\n    }\n    \n    inline float srgb_to_linear(float c)\n    {\n        return (c <= 0.04045f) ? c / 12.92f : powr((c + 0.055f) / 1.055f, 2.4f);\n    }\n    \n    inline half srgb_to_linear_fast(half c)\n    {\n        return powr(c, 2.2h);\n    }\n    \n    inline half3 srgb_to_linear_fast(half3 c)\n    {\n        return powr(c, 2.2h);\n    }\n    \n    inline half srgb_to_linear(half c)\n    {\n        \n        return (c <= 0.04045h) ? (c * 0.0773993808h) :  powr(0.9478672986h * c + 0.05213270142h, 2.4h);\n    }\n    \n    inline float3 srgb_to_linear(float3 c)\n    {\n        return float3(srgb_to_linear(c.x), srgb_to_linear(c.y), srgb_to_linear(c.z));\n    }\n    \n    inline float linear_to_srgb(float c)\n    {\n        return (c < 0.0031308f) ? (12.92f * c) : (1.055f * powr(c, 1.f/2.4f) - 0.055f);\n    }\n    \n    inline float3 linear_to_srgb(float3 v) { \n        return float3(linear_to_srgb(v.x), linear_to_srgb(v.y), linear_to_srgb(v.z));\n    }\n    \n}\n\n\n\ninline float4 texture2DProj(texture2d<float> tex, sampler smp, float4 uv)\n{\n    return tex.sample(smp, uv.xy / uv.w);\n}\n\ninline half4 texture2DProj(texture2d<half> tex, sampler smp, float4 uv)\n{\n    return tex.sample(smp, uv.xy / uv.w);\n}\n\nstatic constexpr sampler vfx_shadow_sampler_rev_z = sampler(coord::normalized, filter::linear, mip_filter::none, address::clamp_to_zero, compare_func::less_equal);\n\nstatic constexpr sampler vfx_shadow_sampler = vfx_shadow_sampler_rev_z;\n\ninline float shadow2DProj(sampler shadow_sampler, depth2d<float> tex, float4 uv, float4 tile)\n{\n    float3 uvp = uv.xyz / uv.w;\n    uvp.xy = tile.xy + uvp.xy * tile.zw;\n    return tex.sample_compare(shadow_sampler, uvp.xy, uvp.z);\n}\n\ninline float shadow2DArray(sampler shadow_sampler, depth2d_array<float> tex, float3 uv, uint slice)\n{\n    return tex.sample_compare(shadow_sampler, uv.xy, slice, uv.z);\n}\n\ninline float shadow2DArrayProj(sampler shadow_sampler, depth2d_array<float> tex, float4 uv, uint slice)\n{\n    float3 uvp = uv.xyz / uv.w;\n    return tex.sample_compare(shadow_sampler, uvp.xy, slice, uvp.z);\n}\n\n\n\ninline float4 transformViewPosInShadowSpace(float3 pos, float4x4 shadowMatrix)\n{\n    \n    float4 lightScreen =  shadowMatrix * float4(pos, 1.f);\n\n    return lightScreen;\n}\n\ninline float ComputeCascadeBlendAmount(float3 shadowPos, bool cascadeBlending)\n{\n    const float cascadeBlendingFactor = 0.1f; \n\n    float3 cascadePos = abs(shadowPos.xyz * 2.f - 1.f);\n    \n    if (cascadeBlending) {\n#if 0\n        const float edge = 1.f - cascadeBlendingFactor;\n        \n        cascadePos = 1.f - saturate((cascadePos - edge) / cascadeBlendingFactor);\n        return cascadePos.x * cascadePos.y * cascadePos.z; \n#else\n        \n        float distToEdge = 1.0f - max(max(cascadePos.x, cascadePos.y), cascadePos.z);\n        return smoothstep(0.0f, cascadeBlendingFactor, distToEdge);\n#endif\n    } else {\n        return step(cascadePos.x, 1.f) * step(cascadePos.y, 1.f) * step(cascadePos.z, 1.f);\n    }\n}\n\ntemplate <class T>\ninline void applyFog(thread vec<T, 4>& color, float eye_distance, float3 fogParameters, vec<T, 4> fogColor) {\n    float factor = eye_distance * fogParameters.x + fogParameters.y;\n    T fogFactor = pow(clamp(T(factor), T(0), fogColor.a), T(fogParameters.z));\n    color.rgb = mix(color.rgb, fogColor.rgb * color.a, fogFactor);\n}\n\n\n\n#pragma mark Pack/Unpack\n\ninline ushort packHalf2ToUShort(half2 v) {\n    v = saturate(v);\n    v = round(v*255);\n    ushort2 uv = ushort2(v);\n    ushort res = (uv.x & 0x00ff) | ((uv.y & 0x00ff) << 8);\n    return res;\n}\n\ninline half2 unpackHalf2FromUShort(ushort v) {\n    half2 res;\n    \n    res.x = half(v & 0x00ff);\n    res.y = half( (v & 0xff00) >> 8);\n    \n    return res/255.;\n}\n"
+ "\n\nfloat2 _grid(float2 uv, float2 lineWidth)\n{\n    float4 uvDDXY = float4(dfdx(uv), dfdy(uv));\n    float2 uvDeriv = float2(length(uvDDXY.xz), length(uvDDXY.yw));\n    bool invertLineX = lineWidth.x > 0.5;\n    bool invertLineY = lineWidth.y > 0.5;\n    float2 targetWidth = float2(invertLineX ? 1.0 - lineWidth.x : lineWidth.x, invertLineY ? 1.0 - lineWidth.y : lineWidth.y);\n    float2 drawWidth = clamp(targetWidth, uvDeriv, 0.5);\n    float2 lineAA = uvDeriv * 1.5;\n    float2 gridUV = abs(fract(uv) * 2.0 - 1.0);\n    gridUV = float2( invertLineX ? gridUV.x : 1.0 - gridUV.x, invertLineY ? gridUV.y : 1.0 - gridUV.y );\n    float2 grid2 = smoothstep(drawWidth + lineAA, drawWidth - lineAA, gridUV);\n    grid2 *= saturate(targetWidth / drawWidth);\n    grid2 = mix(grid2, targetWidth, saturate(uvDeriv * 2.0 - 1.0));\n    grid2 = float2( invertLineX ? 1.0 - grid2.x : grid2.x, invertLineY ? 1.0 - grid2.y : grid2.y);\n    return grid2;\n}\n\n\nfloat2 _gridFast(float2 uv, float2 lineWidth)\n{\n    float4 uvDDXY = float4(dfdx(uv), dfdy(uv));\n    float2 uvDeriv = float2(length(uvDDXY.xz), length(uvDDXY.yw));\n    float2 drawWidth = clamp(lineWidth, uvDeriv, 0.5);\n    float2 lineAA = uvDeriv * 1.5;\n    float2 gridUV = 1. - abs(fract(uv) * 2.0 - 1.0);\n    float2 grid2 = smoothstep(drawWidth + lineAA, drawWidth - lineAA, gridUV);\n    grid2 *= saturate(lineWidth / drawWidth);\n    grid2 = mix(grid2, lineWidth, saturate(uvDeriv * 2.0 - 1.0));\n    return grid2;\n}\n\nfloat grid(float2 uv, float2 lineWidth)\n{\n    float2 grid2 = _gridFast(uv, lineWidth);\n    return mix(grid2.x, 1.0, grid2.y);\n}\n\n#pragma arguments\n\nfloat4 colorU;\nfloat4 colorV;\n\n#pragma body\n\nfloat2 uv0 = (_surface.diffuseTexcoord.xy - float2(0.5)) * 2.;\nfloat2 uv = uv0 * 500;\nfloat2 uv2 = uv * 10;\nfloat s1 = 0.002;\nfloat s2 = 0.0012;\nfloat g = grid(uv, float2(s1));\nfloat g2 = grid(uv2, float2(s2));\n\nfloat4 color = float4(0.5, 0.5, 0.5, 0.8);\n\nfloat2 g0 = _gridFast(uv0, float2(s1)*0.003);\ng0 = smoothstep(0., 0.01, g0);\n\ncolor = mix(color, colorU, g0.x);\ncolor = mix(color, colorV, g0.y);\n\n\nfloat border = max(0., 1 - length(uv0));\n\n\nfloat p = min(1.0, -(_surface.position.z + 0.1));\n\n_output.color = color * max(g, g2) * pow(border, 0.5) * p;\n"
+ "\n\ninline float shadow2D(sampler shadow_sampler, depth2d<float> tex, float3 uv, float4 tile)\n{\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    float2 mapSize = float2(tex.get_width(), tex.get_height());\n    float2 duv = 0.5f / mapSize;\n    float2 uv0 = tile.xy;\n    float2 uvs = tile.zw;\n\n    float2 b = uv0 + duv;\n    float2 s = uvs - 2 * duv;\n\n    uv.xy = uv.xy * s + b;\n#endif\n\n    return tex.sample_compare(shadow_sampler, uv.xy, uv.z);\n}\n\n\ninline float ComputeSoftShadowGrid(sampler shadow_sampler, float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap, int sampleCount, float4 tile)\n{\n    float4 lightScreen =  transformViewPosInShadowSpace(worldPos, shadowMatrix);\n    lightScreen.xyz /= lightScreen.w;\n\n    if (any(lightScreen.xy < 0.0 || lightScreen.xy > 1.0)) {\n        return 0.0;\n    }\n\n    \n    float shadow;\n    if (sampleCount <= 1) {\n        shadow = shadow2D(shadow_sampler, shadowMap, lightScreen.xyz, tile);\n    } else {\n\n        lightScreen.z += 0.005f; \n\n        float2 texelSize = 2.f / float2(shadowMap.get_width(), shadowMap.get_height());\n        float2 origin    = lightScreen.xy - (sampleCount * 0.5f) * texelSize;\n\n        \n        if (sampleCount <= 4) { \n            half totalAccum = 0.h;\n            for (int y = 0; y < sampleCount; ++y) {\n                for (int x = 0; x < sampleCount; ++x) {\n                    totalAccum  += half(shadowMap.sample_compare(shadow_sampler, origin, lightScreen.z, 2 * int2(x,y)));\n                }\n            }\n            shadow = totalAccum / half(sampleCount * sampleCount);\n        } else {\n            float totalAccum = 0.f;\n            for (int y = 0; y < sampleCount; ++y) {\n                for (int x = 0; x < sampleCount; ++x) {\n                    float2 samplePos = origin + texelSize * float2(x, y);\n                    totalAccum  += shadowMap.sample_compare(shadow_sampler, samplePos, lightScreen.z);\n                }\n            }\n            shadow = totalAccum / float(sampleCount * sampleCount);\n        }\n    }\n\n    \n    shadow *= step(0., lightScreen.w);\n\n    return shadow;\n}\n\ninline float ComputeSoftShadow(sampler shadow_sampler, float3 lightScreen, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount, float shadowRadius, float4 tile)\n{\n    if (any(lightScreen.xyz < 0.0 || lightScreen.xyz > 1.0)) {\n        return 0.0;\n    }\n\n    \n    float shadow;\n    if (sampleCount <= 1) {\n        shadow = shadow2D(shadow_sampler, shadowMap, lightScreen.xyz, tile);\n    } else {\n        \n\n        \n        float3 duvdist_dx = dfdx(lightScreen.xyz);\n        float3 duvdist_dy = dfdy(lightScreen.xyz);\n\n        \n        \n        \n        \n        \n        \n\n        float inv_det_J = 1.0 / ((duvdist_dx.x * duvdist_dy.y) - (duvdist_dx.y * duvdist_dy.x));\n        float2 ddist_duv = inv_det_J * float2(duvdist_dy.y * duvdist_dx.z - duvdist_dx.y * duvdist_dy.z,\n                                              duvdist_dx.x * duvdist_dy.z - duvdist_dy.x * duvdist_dx.z);\n\n        float totalAccum = 0.0;\n\n        for (int i = 0; i < sampleCount; i++) {\n            float3 uvOffset = shadowKernel[i].xyz * shadowRadius;\n\n            float2 uvWithOffset = lightScreen.xy + uvOffset.xy;\n            if (any(uvWithOffset < 0.0 || uvWithOffset > 1.0)) {\n                continue;\n            }\n            float dist = lightScreen.z * (1.0 + uvOffset.z) + (ddist_duv.x * uvOffset.x + ddist_duv.y * uvOffset.y);\n            if (dist < 0.0) {\n                continue;\n            }\n\n            totalAccum += shadow2D(shadow_sampler, shadowMap, float3(uvWithOffset, dist), tile);\n        }\n\n        shadow = totalAccum / float(sampleCount);\n    }\n\n    return shadow;\n}\n\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\ninline float4 SampleShadowCascade(sampler shadow_sampler, depth2d<float> shadowMaps, float3 shadowPosition, uint cascadeIndex, constant float4* shadowKernel, int sampleCount, float shadowRadius, float4 tile)\n#else\ninline float4 SampleShadowCascade(sampler shadow_sampler, depth2d_array<float> shadowMaps, float3 shadowPosition, uint cascadeIndex, constant float4* shadowKernel, int sampleCount, float shadowRadius)\n#endif\n{\n    \n    float2 gridSize = float2(shadowMaps.get_width(), shadowMaps.get_height()) / 32;\n    float gd = vfx::checkerboard(shadowPosition.xy, gridSize);\n    float3 gridCol = mix(float3(vfx::debugColorForCascade(cascadeIndex).rgb), float3(0.f), float3(gd > 0.f));\n\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    float shadow = ComputeSoftShadow(shadow_sampler, shadowPosition, shadowMaps, shadowKernel, sampleCount, shadowRadius, tile);\n#else\n    float shadow = 0.0;\n    if (sampleCount > 1) {\n\n        \n        for (int i = 0; i < sampleCount; ++i) {\n            shadow += shadow2DArray(shadow_sampler, shadowMaps, shadowKernel[i].xyz * shadowRadius + shadowPosition, cascadeIndex);\n        }\n        shadow /= float(sampleCount);\n    } else {\n        \n        shadow = shadow2DArray(shadow_sampler, shadowMaps, shadowPosition, cascadeIndex);\n    }\n#endif\n    return float4(gridCol, shadow);\n}\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\ninline float4 ComputeCascadedShadow(sampler shadow_sampler, float3 viewPos, float4x4 shadowMatrix, constant float4 *cascadeScale, constant float4 *cascadeBias, int cascadeCount, depth2d<float> shadowMaps, bool enableCascadeBlending, constant float4* shadowKernel, int sampleCount, float shadowRadius, constant float4* tiles)\n#else\ninline float4 ComputeCascadedShadow(sampler shadow_sampler, float3 viewPos, float4x4 shadowMatrix, constant float4 *cascadeScale, constant float4 *cascadeBias, int cascadeCount, depth2d_array<float> shadowMaps, bool enableCascadeBlending, constant float4* shadowKernel, int sampleCount, float shadowRadius)\n#endif\n{\n    float4 shadow = 0.f;\n    float shadowSum = 0.f;\n    \n    \n    float3 pos_ls =  (shadowMatrix * float4(viewPos, 1.f)).xyz;\n    for (int c = 0; c < cascadeCount; ++c) {\n        \n        float3 pos_cs =  pos_ls * cascadeScale[c].xyz + cascadeBias[c].xyz;\n\n        \n        float cascadeRadius = shadowRadius * cascadeScale[c].x;\n\n        float opacity = ComputeCascadeBlendAmount(pos_cs, enableCascadeBlending);\n\n\n        if (shadowSum >= 1.f && opacity <= 0.0) \n            break;                              \n                                                \n\n        if (opacity > 0.f) { \n            \n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n            shadow += SampleShadowCascade(shadow_sampler, shadowMaps, pos_cs, c, shadowKernel, sampleCount, cascadeRadius, tiles[c]) * opacity;\n#else\n            shadow += SampleShadowCascade(shadow_sampler, shadowMaps, pos_cs, c, shadowKernel, sampleCount, cascadeRadius) * opacity;\n#endif\n            shadowSum += opacity;\n        }\n    }\n\n    if (shadowSum > 0) {\n        shadow /= shadowSum;\n    }\n    return shadow;\n}\n\ninline float ComputeShadow(sampler shadow_sampler, float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap, float4 tile)\n{\n    float4 lightScreen =  transformViewPosInShadowSpace(worldPos, shadowMatrix);\n    lightScreen.xyz /= lightScreen.w;\n\n    if (any(lightScreen.xy < 0.0 || lightScreen.xy > 1.0)) {\n        return 0.0;\n    }\n\n    float shadow = shadow2D(shadow_sampler, shadowMap, lightScreen.xyz, tile);\n\n    \n    shadow *= step(0., lightScreen.w);\n\n    return shadow;\n}\n"
+ "\n#pragma mark - Includes begin\n\n#import <metal_stdlib>\n\nusing namespace metal;\n\n#import \"vfx_metal\"\n#import \"vfx_util.h\"\n#import \"CFX-PBR.metal\"\n\n#ifdef USE_RE_SYSTEM_TREATMENTS\n#import \"vfx_re_shaders.h\"\n#import \"vfx_re_shaders_internal.h\"\n#import \"vfx_render_options.h\"\n#import \"vfx_shader_api_v2.h\"\n#endif \n\n#pragma mark - Includes end\n\n#pragma mark - Namespace Begin\n\n\n#import \"vfx_shadowmap_util.h\"\n#import \"vfx_tessellation.h\"\n\n\n\n\n#ifdef USE_LAYERED_RENDERING\n#define texture2d_layer texture2d_array\n#define sampleLayer(a,b) sample(a,b,in.sliceIndex)\n#else\n#define texture2d_layer texture2d\n#define sampleLayer(a,b) sample(a,b)\n#endif\n\n#ifdef CFX_USE_TEXTURE_FOR_LIGHT_INDICES\n#define LightIndex(lid) u_lightIndicesTexture.read((ushort)lid).x\n#else\n#define LightIndex(lid) u_lightIndicesBuffer[lid]\n#endif\n\n#ifdef IS_BEZIER_CURVE\n[[visible]] bool vfx_is_inside_bezier_curve(float2 p, device void const* curveData, device packed_float3 const* controlPoints);\n[[visible]] float vfx_distance_to_bezier_curve(float2 p, thread float2& directionToCurve, float maximumDistance, device void const* curveData, device packed_float3 const* controlPoints);\n#endif\n\n#ifdef USE_GBUFFER_OUTPUT\n    #undef USE_PER_VERTEX_LIGHTING\n    #undef USE_PER_PIXEL_LIGHTING\n    #undef USE_LIGHTING\n#endif\n\n\n\ntypedef struct {\n\n#ifdef USE_MODELTRANSFORM\n    float4x4 modelTransform;\n#endif\n#ifdef USE_INVERSEMODELTRANSFORM\n    float4x4 inverseModelTransform;\n#endif\n#ifdef USE_MODELVIEWTRANSFORM\n    float4x4 modelViewTransform;\n#endif\n#ifdef USE_INVERSEMODELVIEWTRANSFORM\n    float4x4 inverseModelViewTransform;\n#endif\n#ifdef USE_NORMALTRANSFORM\n    float4x4 normalTransform;\n#endif\n#ifdef USE_INVERSEMODELVIEWPROJECTIONTRANSFORM\n    float4x4 inverseModelViewProjectionTransform;\n#endif\n#ifdef USE_MODELVIEWPROJECTIONTRANSFORM\n    float4x4 modelViewProjectionTransform;\n#endif\n#ifdef USE_LASTFRAMETRANSFORM\n    float4x4 lastFrameModelTransform;\n#endif\n#ifdef USE_MOTIONBLUR\n    float motionBlurIntensity;\n#endif\n#ifdef USE_BOUNDINGBOX\n    float2x3 boundingBox;\n#endif\n#ifdef USE_WORLDBOUNDINGBOX\n    float2x3 worldBoundingBox;\n#endif\n#ifdef USE_NODE_OPACITY\n    float nodeOpacity;\n#endif\n#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)\n    sh2_coefficients shCoefficients;\n#elif defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 3)\n    sh3_coefficients shCoefficients;\n#endif\n#ifdef USE_CLUSTERED_LIGHTING\n    uint8_t categoryBitmask;\n#endif\n} commonprofile_node;\n\nstatic commonprofile_node compute_view_dependant_uniforms(device commonprofile_node& vfx_node, constant VFXWorldBuffer& vfx_frame) {\n    \n#ifdef USE_LATE_LATCHING\n#ifdef USE_MODELVIEWTRANSFORM\n    vfx_node.modelViewTransform = vfx_frame.viewTransform * vfx_node.modelTransform;\n#endif\n#if defined(USE_INVERSEMODELVIEWTRANSFORM) || defined(USE_NORMALTRANSFORM)\n    vfx_node.inverseModelViewTransform = vfx_node.inverseModelTransform * vfx_frame.inverseViewTransform;\n#endif\n#ifdef USE_NORMALTRANSFORM\n    vfx_node.normalTransform = transpose(vfx_node.inverseModelViewTransform);\n#endif\n#ifdef USE_MODELVIEWPROJECTIONTRANSFORM\n    vfx_node.modelViewProjectionTransform = vfx_frame.viewProjectionTransform * vfx_node.modelTransform;\n#endif\n#ifdef USE_INVERSEMODELVIEWPROJECTIONTRANSFORM\n    vfx_node.inverseModelViewProjectionTransform = vfx_node.inverseModelTransform * vfx_frame.inverseViewProjectionTransform;\n#endif\n#endif \n    return vfx_node;\n}\n\ntypedef struct {\n    float3 position         [[attribute(VFXVertexSemanticPosition)]];\n#ifdef HAS_NORMAL\n    float3 normal           [[attribute(VFXVertexSemanticNormal)]];\n#endif\n#ifdef USE_TANGENT\n    float4 tangent          [[attribute(VFXVertexSemanticTangent)]];\n#endif\n#ifdef USE_VERTEX_COLOR\n    float4 color            [[attribute(VFXVertexSemanticColor)]];\n#endif\n#if defined(NEED_IN_TEXCOORD0) || defined(DEBUG_PIXEL)\n    float2 texcoord0        [[attribute(VFXVertexSemanticTexcoord0)]];\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    float2 texcoord1        [[attribute(VFXVertexSemanticTexcoord1)]];\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    float2 texcoord2        [[attribute(VFXVertexSemanticTexcoord2)]];\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    float2 texcoord3        [[attribute(VFXVertexSemanticTexcoord3)]];\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    float2 texcoord4        [[attribute(VFXVertexSemanticTexcoord4)]];\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    float2 texcoord5        [[attribute(VFXVertexSemanticTexcoord5)]];\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    float2 texcoord6        [[attribute(VFXVertexSemanticTexcoord6)]];\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    float2 texcoord7        [[attribute(VFXVertexSemanticTexcoord7)]];\n#endif\n} vfx_vertex_t; \n\ntypedef struct {\n    float4 fragmentPosition [[position]]; \n#ifdef USE_POINT_RENDERING\n    float fragmentSize [[point_size]];\n#endif\n#ifdef USE_VERTEX_COLOR\n    float4 vertexColor;\n#endif\n#ifdef USE_PER_VERTEX_LIGHTING\n    float3 diffuse;\n#ifdef USE_SPECULAR\n    float3 specular;\n#endif\n#ifdef USE_CLEARCOAT\n    float clearCoat;\n#endif\n#ifdef USE_CLEARCOATROUGHNESS\n    float clearCoatRoughness;\n#endif\n#ifdef USE_CLEARCOATNORMAL\n    float clearCoatNormal;\n#endif\n#endif\n#if defined(USE_POSITION) && (USE_POSITION == 2)\n    float3 position;\n#endif\n#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)\n    float3 normal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    float3 tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    float3 bitangent;\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n    float2 displacementTexcoord;   \n#endif\n#ifdef USE_CLEARCOAT_MAP\n    float2 clearCoatTexcoord;   \n#endif\n#ifdef USE_CLEARCOATROUGHNESS_MAP\n    float2 clearCoatRoughnessTexcoord;   \n#endif\n#ifdef USE_CLEARCOATNORMAL_MAP\n    float2 clearCoatNormalTexcoord;   \n#endif\n#ifdef USE_NODE_OPACITY\n    float nodeOpacity;\n#endif\n#ifdef USE_TEXCOORD\n    __TexcoordDecl__\n#endif\n    \n#ifdef USE_EXTRA_VARYINGS\n    __ExtraVaryingsDecl__\n#endif\n#ifdef USE_LASTFRAMETRANSFORM\n    float3 mv_lastFragment;\n    float3 mv_fragment;\n#endif\n#ifdef USE_OUTLINE\n    float outlineHash [[ flat ]];\n#endif\n#ifdef USE_INSTANCING\n    uint   instanceID [[ flat ]];\n#endif\n#ifndef USE_VERTEX_AMPLIFICATION \n#ifdef USE_LAYERED_RENDERING\n    uint   sliceIndex [[render_target_array_index]];\n#endif\n#ifdef USE_MULTIPLE_VIEWPORTS_RENDERING\n    uint   sliceIndex [[viewport_array_index]];\n#endif\n#endif\n#if DEBUG_PIXEL\n    float2 uv0;\n#endif\n#if USE_SCREEN_UV\n    float2 screen_uv [[ center_no_perspective ]];\n#endif\n#ifdef USE_CR_WORLD_POSITION\n    float3 crworldPosition;\n#endif\n} commonprofile_io;\n\n\n#ifdef USE_SHADER_MODIFIERS\n__ShaderModifiersDecl__\n#endif\n\n\n#import \"CFX-Lighting.metal\"\n\nenum CFXColorMask {\n    kCFXColorMaskRed    = 0x1 << 3,\n    kCFXColorMaskGreen  = 0x1 << 2,\n    kCFXColorMaskBlue   = 0x1 << 1,\n    kCFXColorMaskAlpha  = 0x1 << 0\n};\n\ninline float4 colorFromMask(float4 col, int mask)\n{\n    switch (mask) {\n\n        case kCFXColorMaskRed:                      return col.r;\n        case kCFXColorMaskRed|kCFXColorMaskGreen:   return float4(col.rg, 0.f, 1.f);\n        case kCFXColorMaskRed|kCFXColorMaskBlue:    return float4(col.rb, 0.f, 1.f);\n        case kCFXColorMaskRed|kCFXColorMaskAlpha:   return float4(col.ra, 0.f, 1.f);\n\n        case kCFXColorMaskGreen:                    return col.g;\n        case kCFXColorMaskGreen|kCFXColorMaskBlue:  return float4(col.bg, 0.f, 1.f);\n        case kCFXColorMaskGreen|kCFXColorMaskAlpha: return float4(col.ag, 0.f, 1.f);\n\n        case kCFXColorMaskBlue:     return col.b;\n        case kCFXColorMaskBlue|kCFXColorMaskAlpha:  return float4(col.ab, 0.f, 1.f);\n\n        case kCFXColorMaskAlpha:    return col.a;\n    }\n    return col;\n}\n\n#ifndef USE_PBR\n\ninline float3 illuminate(VFXShaderSurface surface, VFXShaderLightingContribution lighting)\n{\n    float3 albedo = surface.diffuse.rgb * surface.ambientOcclusion;\n    float3 color = lighting.diffuse * albedo;\n#if defined(USE_AMBIENT_LIGHTING)\n    color +=  lighting.ambient * albedo;\n#endif\n#ifdef USE_SELFILLUMINATION\n    color += surface.diffuse.rgb * surface.selfIllumination.rgb;\n#endif\n    \n    \n    \n#ifdef USE_SPECULAR\n    float3 S = lighting.specular;\n#elif defined(USE_REFLECTIVE)\n    float3 S = float3(0.);\n#endif\n#ifdef USE_REFLECTIVE\n    S += surface.reflective.rgb * surface.ambientOcclusion;\n#endif\n#ifdef USE_SPECULAR\n    S *= surface.specular.rgb;\n#endif\n#if (defined(USE_SPECULAR) || defined(USE_REFLECTIVE)) && !defined(DISABLE_SPECULAR)\n    color += S;\n#endif\n#ifdef USE_EMISSION\n    color += surface.emission.rgb;\n#endif\n#ifdef USE_MULTIPLY\n    color *= surface.multiply.rgb;\n#endif\n#ifdef USE_MODULATE\n    color *= lighting.modulate;\n#endif\n    return color;\n}\n#endif\n\nstruct VFXShaderGeometry\n{\n    float4 position;\n    float3 normal;\n    float4 tangent;\n    float4 color;\n    float pointSize;\n    float2 texcoords[8]; \n#ifdef USE_CLIP_DISTANCE0\n    float clipDistance0;\n#endif\n#ifdef USE_CLIP_DISTANCE1\n    float clipDistance1;\n#endif\n#ifdef USE_CLIP_DISTANCE2\n    float clipDistance2;\n#endif\n#ifdef USE_CLIP_DISTANCE3\n    float clipDistance3;\n#endif\n};\n\nstruct commonprofile_uniforms {\n    \n    float4 diffuseColor;\n    float4 specularColor;\n    float4 ambientOcclusionColor;\n    float4 emissionColor;\n    float4 selfIlluminationColor;\n    float4 reflectiveColor;\n    float4 multiplyColor;\n    float4 transparentColor;\n    float clearCoat;\n    float clearCoatRoughness;\n    float3 clearCoatNormal;\n    float subsurface;\n    float4 subsurfaceRadius;\n    float transmission;\n    float4 transmissionColor;\n    float indexOfRefraction;\n    float metalness;\n    \n    float roughness;\n    float diffuseIntensity;\n    float specularIntensity;\n    float normalIntensity;\n    float ambientOcclusionIntensity;\n    float emissionIntensity;\n    float selfIlluminationIntensity;\n    float reflectiveIntensity;\n    float multiplyIntensity;\n    float transparentIntensity;\n    \n    float metalnessIntensity;\n    float roughnessIntensity;\n    float clearCoatIntensity;\n    float clearCoatRoughnessIntensity;\n    float clearCoatNormalIntensity;\n    float subsurfaceIntensity;\n    float subsurfaceRadiusIntensity;\n    float transmissionIntensity;\n    float transmissionColorIntensity;\n    float displacementIntensity;\n    float materialShininess;\n    float selfIlluminationOcclusion;\n    float alphaCutoff;\n    float3 fresnel; \n    \n#if USE_ARGUMENT_BUFFERS\n    texture2d<float>    emissionTexture;\n    sampler             emissionSampler;\n    texture2d<float>    ambientOcclusionTexture;\n    sampler             ambientOcclusionSampler;\n    texture2d<float>    diffuseTexture;\n    sampler             diffuseSampler;\n    texture2d<float>    specularTexture;\n    sampler             specularSampler;\n#if defined(USE_REFLECTIVE_CUBEMAP)\n    texturecube<float>  reflectiveTexture;\n#else\n    texture2d<float>    reflectiveTexture;\n#endif\n    sampler             reflectiveSampler;\n    texture2d<float>    transparentTexture;\n    sampler             transparentSampler;\n    texture2d<float>    multiplyTexture;\n    sampler             multiplySampler;\n    texture2d<float>    normalTexture;\n    sampler             normalSampler;\n    texture2d<float>    selfIlluminationTexture;\n    sampler             selfIlluminationSampler;\n    texture2d<float>    metalnessTexture;\n    sampler             metalnessSampler;\n    texture2d<float>    roughnessTexture;\n    sampler             roughnessSampler;\n    texture2d<float>    displacementTexture;\n    sampler             displacementSampler;\n    \n#endif \n#ifdef TEXTURE_TRANSFORM_COUNT\n    float4x4 textureTransforms[TEXTURE_TRANSFORM_COUNT];\n#endif\n};\n\n#ifdef USE_OPENSUBDIV\n\n__OpenSubdivDeclPerGeometry__\n__OpenSubdivDeclPerPatchType__\n__OpenSubdivDeclShared__\n\nstruct osd_packed_vertex {\n    packed_float3 position;\n#if defined(OSD_USER_VARYING_DECLARE_PACKED)\n    OSD_USER_VARYING_DECLARE_PACKED\n#endif\n};\n\n#endif\n\n\n#ifdef USE_DISPLACEMENT_MAP\nstatic void applyDisplacement(texture2d<float>                 displacementTexture,\n                              sampler                          displacementTextureSampler,\n                              float2                           displacementTexcoord,\n                              thread VFXShaderGeometry&        geometry,\n                              constant commonprofile_uniforms& vfx_commonprofile)\n{\n#ifdef USE_DISPLACEMENT_TEXTURE_COMPONENT\n\tfloat altitude = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n#ifdef USE_DISPLACEMENT_INTENSITY\n\taltitude *= vfx_commonprofile.displacementIntensity;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n\tfloat3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));\n\tgeometry.position.xyz += geometry.normal * altitude;\n\t\n\tfloat3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);\n\tfloat3 h;\n\th.x = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\th.y = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\th.z = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord-offset.zy), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\t\n#ifdef USE_DISPLACEMENT_INTENSITY\n\th *= vfx_commonprofile.displacementIntensity;\n#endif\n\t\n\tfloat3 n = normalize( float3( (h.x - h.y)/offset.x, 1., (h.x - h.z)/offset.y) );\n\tgeometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;\n\tgeometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));\n#endif \n#else \n\tfloat3 displacement = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;\n#ifdef USE_DISPLACEMENT_INTENSITY\n\tdisplacement *= vfx_commonprofile.displacementIntensity;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n\tfloat3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));\n\tgeometry.position.xyz += geometry.tangent.xyz * displacement.x + geometry.normal.xyz * displacement.y + bitangent.xyz * displacement.z;\n\t\n\tfloat3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);\n\tfloat3 a = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;\n\tfloat3 b = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz).rgb;\n\tfloat3 c = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.zy).rgb;\n\t\n#ifdef USE_DISPLACEMENT_INTENSITY\n\ta *= vfx_commonprofile.displacementIntensity;\n\tb *= vfx_commonprofile.displacementIntensity;\n\tc *= vfx_commonprofile.displacementIntensity;\n#endif\n\t\n\tb += offset.xzz;\n\tc -= offset.zzy;\n\tfloat3 n = (normalize( cross( b-a, c-a ) ));\n\tgeometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;\n\tgeometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));\n#endif \n#endif \n}\n#endif \n\n#ifdef USE_OUTLINE\nstatic inline float hash(float2 p)\n{\n    const float2 kMod2 = float2(443.8975f, 397.2973f);\n    p  = fract(p * kMod2);\n    p += dot(p.xy, p.yx+19.19f);\n    return fract(p.x * p.y);\n}\n#endif\n    \n\n\n\n\n#if defined(USE_TESSELLATION)\nstruct vfx_patch_t {\n    patch_control_point<vfx_vertex_t> controlPoints;\n};\n#endif\n\n#if defined(USE_OPENSUBDIV)\n#if OSD_IS_ADAPTIVE\n[[ patch(quad, VERTEX_CONTROL_POINTS_PER_PATCH) ]]\n#endif\n#elif defined(USE_TESSELLATION)\n[[ patch(triangle, 3) ]]\n#endif\n    \n    \nvertex commonprofile_io commonprofile_vert(\n#if !defined(USE_TESSELLATION)\n                                           vfx_vertex_t                       in                               [[ stage_in ]]\n                                           , uint                             vfx_vertexID                     [[ vertex_id ]]\n#else \n                                           \n#ifdef USE_OPENSUBDIV\n#if OSD_IS_ADAPTIVE\n#if USE_STAGE_IN\n                                           PatchInput                         patchInput                       [[ stage_in ]]\n#else\n                                           OsdVertexBufferSet                 patchInput\n#endif\n                                           , float2                           patchCoord                       [[ position_in_patch ]]\n                                           , uint                             patchID                          [[ patch_id ]]\n                                           , constant float&                  osdTessellationLevel             [[ buffer(TESSELLATION_LEVEL_BUFFER_INDEX) ]]\n#else \n                                           constant unsigned*                 osdIndicesBuffer                 [[ buffer(INDICES_BUFFER_INDEX) ]]\n                                           , constant osd_packed_vertex*      osdVertexBuffer                  [[ buffer(VERTEX_BUFFER_INDEX) ]]\n                                           , uint                             vertexID                         [[ vertex_id ]]\n#endif \n#if defined(OSD_FVAR_WIDTH)\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n                                           , constant uint32_t&               osdFaceVaryingChannelCount       [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_COUNT_INDEX) ]]\n                                           , constant OsdFVarChannelDesc*     osdFaceVaryingChannelDescriptors [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_DESCRIPTORS_INDEX) ]]\n                                           , constant uint32_t&               osdFaceVaryingPatchArrayIndex    [[ buffer(OSD_FVAR_CHANNELS_PATCH_ARRAY_INDEX_BUFFER_INDEX) ]]\n                                           , constant void*                   osdFaceVaryingChannelsPackedData [[ buffer(OSD_FVAR_CHANNELS_PACKED_DATA_BUFFER_INDEX) ]]\n#else\n                                           , constant float*                  osdFaceVaryingData               [[ buffer(OSD_FVAR_DATA_BUFFER_INDEX) ]]\n                                           , constant int*                    osdFaceVaryingIndices            [[ buffer(OSD_FVAR_INDICES_BUFFER_INDEX) ]]\n#if OSD_IS_ADAPTIVE\n                                           , constant packed_int3*            osdFaceVaryingPatchParams        [[ buffer(OSD_FVAR_PATCHPARAM_BUFFER_INDEX) ]]\n                                           , constant packed_int4&            osdFaceVaryingPatchArray         [[ buffer(OSD_FVAR_PATCH_ARRAY_BUFFER_INDEX) ]]\n#endif\n#endif \n#endif \n#else \n                                           vfx_patch_t                        in                               [[ stage_in ]]\n                                           , float3                           patchCoord                       [[ position_in_patch ]]\n#endif \n#endif \n                                           \n#ifdef USE_MULTIPLE_RENDERING\n                                           , constant VFXWorldBuffer*         vfx_frame_multi                  [[ buffer(0) ]]\n#else\n                                           , constant VFXWorldBuffer&         vfx_frame                        [[ buffer(0) ]]\n#endif\n#if defined(USE_INSTANCING) || defined(USE_MULTIPLE_RENDERING)\n                                           , device commonprofile_node*     vfx_nodes_in                     [[ buffer(1) ]]\n#else\n                                           , device commonprofile_node&     vfx_node_in                      [[ buffer(1) ]]\n#endif\n#ifdef USE_PER_VERTEX_LIGHTING\n                                           , constant vfx_light*              vfx_lights                       [[ buffer(2) ]]\n                                           , constant float4*                 u_shadowKernel\n                                           , texture2d_array<float>           u_areaLightBakedDataTexture\n#endif\n                                           \n                                           , constant commonprofile_uniforms& vfx_commonprofile\n#ifdef USE_RE_SYSTEM_TREATMENTS\n                                           , constant GlobalConstants&        u_re_globalConstants\n#endif\n#ifdef USE_INSTANCING\n                                           , uint                             vfx_instanceID                   [[ instance_id ]]\n#endif\n#ifdef USE_VERTEX_AMPLIFICATION\n                                           , ushort                           amplificationID                  [[ amplification_id ]]\n#endif\n\n#ifdef USE_POINT_RENDERING\n                                           \n                                           , constant float3&                 vfx_pointSize\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n#if USE_ARGUMENT_BUFFERS\n#define u_displacementTexture           vfx_commonprofile.displacementTexture\n#define u_displacementTextureSampler    vfx_commonprofile.displacementSampler\n#else\n                                           , texture2d<float>                 u_displacementTexture\n                                           , sampler                          u_displacementTextureSampler\n#endif \n#endif \n#ifdef USE_VERTEX_EXTRA_ARGUMENTS\n                                           __VertexExtraArguments__\n#endif\n                                           )\n{\n    commonprofile_io out;\n    \n#ifdef USE_MULTIPLE_RENDERING\n\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant VFXWorldBuffer& vfx_frame = vfx_frame_multi[amplificationID];\n#else\n    out.instanceID = vfx_instanceID / USE_MULTIPLE_RENDERING;\n    out.sliceIndex = vfx_instanceID % USE_MULTIPLE_RENDERING;\n    constant VFXWorldBuffer& vfx_frame = vfx_frame_multi[out.sliceIndex];\n#endif\n    \n#ifdef USE_INSTANCING\n#ifdef USE_VERTEX_AMPLIFICATION\n    device commonprofile_node& vfx_node_in = vfx_nodes_in[USE_MULTIPLE_RENDERING * vfx_instanceID + amplificationID];\n#else\n    \n    \n    device commonprofile_node& vfx_node_in = vfx_nodes_in[vfx_instanceID];\n#endif\n#else\n#ifdef USE_VERTEX_AMPLIFICATION\n    device commonprofile_node& vfx_node_in = vfx_nodes_in[amplificationID];\n#else\n    device commonprofile_node& vfx_node_in = vfx_nodes_in[out.sliceIndex];\n#endif\n#endif\n    \n#else \n    \n#ifdef USE_INSTANCING\n    out.instanceID = vfx_instanceID;\n    device commonprofile_node& vfx_node_in = vfx_nodes_in[vfx_instanceID];\n#endif\n    \n#endif \n    \n    commonprofile_node vfx_node = compute_view_dependant_uniforms(vfx_node_in, vfx_frame);\n    \n#ifdef USE_TESSELLATION\n    uint vfx_vertexID; \n    vfx_vertexID = 0;\n#endif\n    \n    \n    \n    \n    \n    VFXShaderGeometry _geometry;\n    \n#if !defined(USE_TESSELLATION)\n    \n    \n    _geometry.position = float4(in.position, 1.f);\n#if defined(USE_NORMAL) && defined(HAS_NORMAL)\n    _geometry.normal = in.normal;\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = in.tangent;\n#endif\n#if defined(NEED_IN_TEXCOORD0) || defined(DEBUG_PIXEL)\n    _geometry.texcoords[0] = in.texcoord0;\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    _geometry.texcoords[1] = in.texcoord1;\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    _geometry.texcoords[2] = in.texcoord2;\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    _geometry.texcoords[3] = in.texcoord3;\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    _geometry.texcoords[4] = in.texcoord4;\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    _geometry.texcoords[5] = in.texcoord5;\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    _geometry.texcoords[6] = in.texcoord6;\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    _geometry.texcoords[7] = in.texcoord7;\n#endif\n#ifdef HAS_VERTEX_COLOR\n    _geometry.color = in.color;\n#elif USE_VERTEX_COLOR\n    _geometry.color = float4(1.);\n#endif\n    \n#else \n    \n#ifdef USE_OPENSUBDIV\n#if OSD_IS_ADAPTIVE\n#if USE_STAGE_IN\n    int3 patchParam = patchInput.patchParam;\n#else\n    int3 patchParam = patchInput.patchParamBuffer[patchID];\n#endif\n    \n    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);\n    float tessellationLevel = min(osdTessellationLevel, (float)OSD_MAX_TESS_LEVEL) / exp2((float)refinementLevel - 1);\n    \n    OsdPatchVertex patchVertex = OsdComputePatch(tessellationLevel, patchCoord, patchID, patchInput);\n    \n#if defined(OSD_FVAR_WIDTH)\n    int patchIndex = OsdGetPatchIndex(patchID);\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);\n#else\n    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingIndices, osdFaceVaryingData, osdFaceVaryingPatchParams, osdFaceVaryingPatchArray);\n#endif\n#endif\n    \n    _geometry.position = float4(patchVertex.position, 1.f);\n    \n#if defined(USE_NORMAL)\n    _geometry.normal = patchVertex.normal;\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = float4(patchVertex.tangent, -1.f);\n    \n#endif\n#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[0] = patchVertex.texcoord0;\n#endif\n#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[1] = patchVertex.texcoord1;\n#endif\n#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[2] = patchVertex.texcoord2;\n#endif\n#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[3] = patchVertex.texcoord3;\n#endif\n#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[4] = patchVertex.texcoord4;\n#endif\n#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[5] = patchVertex.texcoord5;\n#endif\n#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[6] = patchVertex.texcoord6;\n#endif\n#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[7] = patchVertex.texcoord7;\n#endif\n#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.color = patchVertex.color;\n#endif\n    \n#else \n    \n#if OSD_PATCH_QUADS\n    const uint primitiveIndex = vertexID / 6;\n#ifdef USE_NORMAL\n    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 0]].position;\n    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 1]].position;\n    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 2]].position;\n    float3 normal = normalize(cross(p2 - p1, p0 - p1));\n#endif\n    const uint triangleIndices[6] = { 0, 1, 2, 0, 2, 3 };\n    const uint quadVertexIndex = triangleIndices[vertexID % 6];\n    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + quadVertexIndex]];\n#elif OSD_PATCH_TRIANGLES\n    const uint primitiveIndex = vertexID / 3;\n#ifdef USE_NORMAL\n    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 0]].position;\n    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 1]].position;\n    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 2]].position;\n    float3 normal = normalize(cross(p2 - p1, p0 - p1));\n#endif\n    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[vertexID]];\n#endif\n    \n    float3 position = osdVertex.position;\n    \n#if defined(OSD_FVAR_WIDTH)\n    int patchIndex = OsdGetPatchIndex(primitiveIndex);\n#if OSD_PATCH_QUADS\n    float2 quadUVs[4] = { float2(0,0), float2(1,0), float2(1,1), float2(0,1) };\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);\n#else\n    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingIndices, osdFaceVaryingData);\n#endif\n#elif OSD_PATCH_TRIANGLES\n    \n#endif\n#endif \n    \n#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[0] = osdVertex.texcoord0;\n#endif\n#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[1] = osdVertex.texcoord1;\n#endif\n#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[2] = osdVertex.texcoord2;\n#endif\n#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[3] = osdVertex.texcoord3;\n#endif\n#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[4] = osdVertex.texcoord4;\n#endif\n#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[5] = osdVertex.texcoord5;\n#endif\n#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[6] = osdVertex.texcoord6;\n#endif\n#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[7] = osdVertex.texcoord7;\n#endif\n#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.color = osdVertex.color;\n#endif\n    \n    _geometry.position = float4(position, 1.f);\n#ifdef USE_NORMAL\n    _geometry.normal = normal;\n#endif\n    \n#endif \n    \n#else \n    \n    \n    \n    \n    \n#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE) || defined(TESSELLATION_SMOOTHING_MODE_PHONG)\n    float3 P0 = in.controlPoints[0].position;\n    float3 P1 = in.controlPoints[1].position;\n    float3 P2 = in.controlPoints[2].position;\n    float3 N0 = in.controlPoints[0].normal;\n    float3 N1 = in.controlPoints[1].normal;\n    float3 N2 = in.controlPoints[2].normal;\n#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE)\n    float3 position, normal;\n    vfx_smooth_geometry_pn_triangle(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);\n#elif defined(TESSELLATION_SMOOTHING_MODE_PHONG)\n    float3 position, normal;\n    vfx_smooth_geometry_phong(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);\n#endif\n    _geometry.position = float4(position, 1.f);\n#ifdef USE_NORMAL\n    _geometry.normal = normal;\n#endif\n#else \n    \n    _geometry.position = float4(vfx::barycentric_mix(in.controlPoints[0].position, in.controlPoints[1].position, in.controlPoints[2].position, patchCoord), 1.f);\n#if defined(USE_NORMAL) && defined(HAS_NORMAL)\n    _geometry.normal = normalize(vfx::barycentric_mix(in.controlPoints[0].normal, in.controlPoints[1].normal, in.controlPoints[2].normal, patchCoord));\n#endif\n#endif \n    \n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = normalize(vfx::barycentric_mix(in.controlPoints[0].tangent, in.controlPoints[1].tangent, in.controlPoints[2].tangent, patchCoord));\n#endif\n#ifdef NEED_IN_TEXCOORD0\n    _geometry.texcoords[0] = vfx::barycentric_mix(in.controlPoints[0].texcoord0, in.controlPoints[1].texcoord0, in.controlPoints[2].texcoord0, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    _geometry.texcoords[1] = vfx::barycentric_mix(in.controlPoints[0].texcoord1, in.controlPoints[1].texcoord1, in.controlPoints[2].texcoord1, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    _geometry.texcoords[2] = vfx::barycentric_mix(in.controlPoints[0].texcoord2, in.controlPoints[1].texcoord2, in.controlPoints[2].texcoord2, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    _geometry.texcoords[3] = vfx::barycentric_mix(in.controlPoints[0].texcoord3, in.controlPoints[1].texcoord3, in.controlPoints[2].texcoord3, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    _geometry.texcoords[4] = vfx::barycentric_mix(in.controlPoints[0].texcoord4, in.controlPoints[1].texcoord4, in.controlPoints[2].texcoord4, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    _geometry.texcoords[5] = vfx::barycentric_mix(in.controlPoints[0].texcoord5, in.controlPoints[1].texcoord5, in.controlPoints[2].texcoord5, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    _geometry.texcoords[6] = vfx::barycentric_mix(in.controlPoints[0].texcoord6, in.controlPoints[1].texcoord6, in.controlPoints[2].texcoord6, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    _geometry.texcoords[7] = vfx::barycentric_mix(in.controlPoints[0].texcoord7, in.controlPoints[1].texcoord7, in.controlPoints[2].texcoord7, patchCoord);\n#endif\n#ifdef HAS_VERTEX_COLOR\n    _geometry.color = vfx::barycentric_mix(in.controlPoints[0].color, in.controlPoints[1].color, in.controlPoints[2].color, patchCoord);\n#elif USE_VERTEX_COLOR\n    _geometry.color = float4(1.);\n#endif\n    \n#endif \n    \n#endif \n    \n#ifdef USE_POINT_RENDERING\n    _geometry.pointSize = vfx_pointSize.x;\n#endif\n    \n#ifdef USE_TEXCOORD\n    __VertexDoVertexOnlyTexcoord__\n#endif\n    \n#ifdef USE_DISPLACEMENT_MAP\n    applyDisplacement(u_displacementTexture, u_displacementTextureSampler, _displacementTexcoord, _geometry, vfx_commonprofile);\n    out.displacementTexcoord = _displacementTexcoord;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_GEOMETRY_MODIFIER\n    \n    __DoGeometryModifier__\n    \n#endif\n    \n#ifdef USE_CLIP_DISTANCE0\n    out.clipDistance[0] = _geometry.clipDistance0;\n#endif\n#ifdef USE_CLIP_DISTANCE1\n    out.clipDistance[1] = _geometry.clipDistance1;\n#endif\n#ifdef USE_CLIP_DISTANCE2\n    out.clipDistance[2] = _geometry.clipDistance2;\n#endif\n#ifdef USE_CLIP_DISTANCE3\n    out.clipDistance[3] = _geometry.clipDistance3;\n#endif\n    \n    \n    \n    \n    \n    \n#if defined(USE_POSITION) || (defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)) || defined(USE_TANGENT) || defined(USE_BITANGENT) || defined(USE_INSTANCING)\n    VFXShaderSurface _surface;\n#endif\n#if defined(USE_POSITION) || defined(USE_INSTANCING)\n    _surface.position = (vfx_node.modelViewTransform * _geometry.position).xyz;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n#ifdef HINT_UNIFORM_SCALE\n    float3x3 nrmTransform = vfx::mat3(vfx_node.modelViewTransform);\n    _surface.normal = nrmTransform * _geometry.normal;\n#else\n    float3x3 modelViewTransform = vfx::mat3(vfx_node.modelViewTransform);\n    float3 invScaleSquared = 1.f / float3(length_squared(modelViewTransform[0]),\n                                          length_squared(modelViewTransform[1]),\n                                          length_squared(modelViewTransform[2]));\n    _surface.normal = normalize(modelViewTransform * (_geometry.normal * invScaleSquared));\n#endif\n#ifdef USE_GBUFFER_OUTPUT\n    _surface.normal = vfx::mat3(vfx_node.modelTransform) * _geometry.normal;\n#endif\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _surface.tangent = normalize(vfx::mat3(vfx_node.modelViewTransform) * _geometry.tangent.xyz);\n    _surface.bitangent = _geometry.tangent.w * cross(_surface.tangent, _surface.normal); \n    \n#endif\n    \n    \n#ifdef USE_VIEW\n    _surface.view = normalize(-_surface.position);\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_PER_VERTEX_LIGHTING\n    \n    VFXShaderLightingContribution _lightingContribution(_surface, out);\n    _lightingContribution.diffuse = 0.;\n  #ifdef USE_SPECULAR\n    _lightingContribution.specular = 0.;\n    _surface.shininess = vfx_commonprofile.materialShininess;\n  #endif\n    \n    __VertexDoLighting__\n    \n    out.diffuse = _lightingContribution.diffuse;\n  #ifdef USE_SPECULAR\n    out.specular = _lightingContribution.specular;\n  #endif\n#endif\n#if defined(USE_POSITION) && (USE_POSITION == 2)\n    out.position = _surface.position;\n#endif\n#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)\n    out.normal = _surface.normal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    out.tangent = _surface.tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    out.bitangent = _surface.bitangent;\n#endif\n#ifdef USE_VERTEX_COLOR\n    out.vertexColor = _geometry.color;\n#endif\n    \n#if DEBUG_PIXEL\n    out.uv0 = _geometry.texcoords[0];\n#endif\n\n#ifdef USE_TEXCOORD\n    __VertexDoTexcoord__\n#endif\n    \n#ifdef IS_BEZIER_CURVE\n    out.bezierCurveUV = in.texcoord0;\n#endif\n    \n    \n    \n    \n    \n#if defined(USE_POSITION) || defined(USE_INSTANCING)\n    out.fragmentPosition = vfx_frame.projectionTransform * float4(_surface.position, 1.);\n#elif defined(USE_MODELVIEWPROJECTIONTRANSFORM) \n    out.fragmentPosition = vfx_node.modelViewProjectionTransform * _geometry.position;\n#endif\n    \n#ifdef USE_NODE_OPACITY\n    out.nodeOpacity = vfx_node.nodeOpacity;\n#endif\n    \n#ifdef USE_POINT_RENDERING\n    float screenSize = _geometry.pointSize / out.fragmentPosition.w;\n    out.fragmentSize = clamp(screenSize, vfx_pointSize.y, vfx_pointSize.z);\n#endif\n    \n#ifdef USE_LASTFRAMETRANSFORM\n    float4 lastFrameFragmentPosition = vfx_frame.lastFrameViewProjectionTransform * vfx_node.lastFrameModelTransform * _geometry.position;\n    out.mv_fragment = out.fragmentPosition.xyw;\n    out.mv_lastFragment = lastFrameFragmentPosition.xyw;\n#endif\n    \n#ifdef USE_OUTLINE\n\tout.outlineHash = hash(vfx_node.modelTransform[3].xy)+1.f/255.f;\n#endif\n    \n#if USE_SCREEN_UV\n    float2 ndc = out.fragmentPosition.xy / out.fragmentPosition.w;\n    out.screen_uv = float2(ndc * float2(0.5f, -0.5f) + 0.5f);\n#endif\n\n#ifdef USE_CR_WORLD_POSITION\n    float3 worldPosition = (vfx_node.modelTransform * _geometry.position).xyz;\n#ifdef USE_RE_SYSTEM_TREATMENTS\n    out.crworldPosition = vfx::api_v2::crws_position(worldPosition, u_re_globalConstants);\n#else\n    \n#endif\n#endif\n\n    return out;\n}\n\n\n\n\n\nstruct VFXOutput\n{\n    float4 color [[ color(0) ]];\n#ifdef USE_COLOR1_OUTPUT\n    half4 color1 [[ color(1) ]];\n#endif\n#ifdef USE_NORMAL_ROUGHNESS_OUTPUT\n    half4 normalRoughness [[ color(2) ]];\n#endif\n#if defined(USE_MOTIONBLUR) && !defined(USE_GBUFFER_OUTPUT)\n    half4 motionblur [[ color(3) ]];\n#endif\n#ifdef USE_ALBEDO_METALNESS_OUTPUT\n    half4 albedoMetalnessOutput [[ color(4) ]];\n#endif\n#ifdef USE_RADIANCE_AO_OUTPUT\n    half4 radianceAOOutput [[ color(5) ]];\n#endif\n#ifdef USE_GBUFFER_OUTPUT\n    float4 albedo [[ color(VFXGBufferAttachmentAlbedo) ]];\n    float4 normals [[ color(VFXGBufferAttachmentNormal) ]];\n    float4 roughmetal [[ color(VFXGBufferAttachmentRoughnessMetalness) ]];\n    \n#ifdef USE_MOTIONBLUR\n    float4 velocity [[ color(VFXGBufferAttachmentVelocity) ]];\n#else\n    float2 velocity [[ color(VFXGBufferAttachmentVelocity) ]];\n#endif\n    half4 clearCoat [[ color(VFXGBufferAttachmentClearCoat) ]];\n    half4 subsurface [[ color(VFXGBufferAttachmentSubsurface) ]];\n    ushort4 transmission [[ color(VFXGBufferAttachmentTransmission) ]];\n#endif\n};\n    \n#ifdef USE_MODIFIER_FRAMEBUFFER\nstruct VFXFramebuffer\n{\n    float4 color;\n};\n#endif\n\nfragment VFXOutput commonprofile_frag(commonprofile_io                   in                          [[ stage_in  ]]\n                                      , constant commonprofile_uniforms& vfx_commonprofile           [[ buffer(0) ]]\n#ifdef USE_MULTIPLE_RENDERING\n                                      , constant VFXWorldBuffer*         vfx_frame_multi             [[ buffer(1) ]]\n#else\n                                      , constant VFXWorldBuffer&         vfx_frame                   [[ buffer(1) ]]\n#endif\n#if defined(USE_INSTANCING) || defined(USE_MULTIPLE_RENDERING)\n                                      , device commonprofile_node*     vfx_nodes_in                [[ buffer(2) ]]\n#else\n                                      , device commonprofile_node&     vfx_node_in                 [[ buffer(2) ]]\n#endif\n#ifdef USE_PER_PIXEL_LIGHTING\n                                      , constant vfx_light*              vfx_lights                  [[ buffer(3) ]]\n                                      , constant float4*                 u_shadowKernel\n                                      , texture2d_array<float>           u_areaLightBakedDataTexture\n#ifdef CFX_SUPPORT_CUBE_ARRAY\n                                      , texturecube_array<half>          u_reflectionProbeTexture\n#else\n                                      , texture2d_array<half>            u_reflectionProbeTexture\n#endif\n                                      , texture3d<ushort>                u_clusterTexture\n#ifdef CFX_USE_TEXTURE_FOR_LIGHT_INDICES\n                                      , texture1d<ushort>                u_lightIndicesTexture\n#else\n                                      , constant CFXLightIndexType*      u_lightIndicesBuffer\n#endif\n#endif\n#ifdef USE_RE_SYSTEM_TREATMENTS\n                                      , constant EntityConstants&           u_re_entityConstants\n                                      , constant ViewConstants&             u_re_viewConstants\n                                      , constant GlobalConstants&           u_re_globalConstants\n                                      , constant re_vfx_object_constants&   u_re_vfx_objectConstants\n                                      , constant re_entity_argument_buffer& u_re_vfx_entityArgumentBuffer\n                                      , constant re_scene_argument_buffer&  u_re_vfx_sceneArgumentBuffer\n#ifdef USE_RE_SYSTEM_TREATMENTS_TIER_1_AB\n                                      , constant VirtualEnvironmentProbeLighting::TextureArgumentBuffer& u_re_vfx_virtualEnvProbeTextures\n#endif\n#endif\n#if defined(CFX_SUPPORTS_PROGRAMMABLE_BLENDING) && defined(USE_MODIFIER_FRAMEBUFFER_COLOR0)\n                                      , float4                           framebufferColor0           [[ color(0) ]]\n#endif\n#if USE_ARGUMENT_BUFFERS\n\n#define u_emissionTexture               vfx_commonprofile.emissionTexture\n#define u_emissionTextureSampler        vfx_commonprofile.emissionSampler\n#define u_ambientOcclusionTexture       vfx_commonprofile.ambientOcclusionTexture\n#define u_ambientOcclusionTextureSampler vfx_commonprofile.ambientOcclusionSampler\n#define u_diffuseTexture                vfx_commonprofile.diffuseTexture\n#define u_diffuseTextureSampler         vfx_commonprofile.diffuseSampler\n#define u_specularTexture               vfx_commonprofile.specularTexture\n#define u_specularTextureSampler        vfx_commonprofile.specularSampler\n#define u_reflectiveTexture             vfx_commonprofile.reflectiveTexture\n#define u_reflectiveTextureSampler      vfx_commonprofile.reflectiveSampler\n#define u_transparentTexture            vfx_commonprofile.transparentTexture\n#define u_transparentTextureSampler     vfx_commonprofile.transparentSampler\n#define u_multiplyTexture               vfx_commonprofile.multiplyTexture\n#define u_multiplyTextureSampler        vfx_commonprofile.multiplySampler\n#define u_normalTexture                 vfx_commonprofile.normalTexture\n#define u_normalTextureSampler          vfx_commonprofile.normalSampler\n#define u_selfIlluminationTexture       vfx_commonprofile.selfIlluminationTexture\n#define u_selfIlluminationTextureSampler vfx_commonprofile.selfIlluminationSampler\n#define u_metalnessTexture              vfx_commonprofile.metalnessTexture\n#define u_metalnessTextureSampler       vfx_commonprofile.metalnessSampler\n#define u_roughnessTexture              vfx_commonprofile.roughnessTexture\n#define u_roughnessTextureSampler       vfx_commonprofile.roughnessSampler\n\n#else\n#ifdef USE_EMISSION_MAP\n                                      , texture2d<float>              u_emissionTexture\n                                      , sampler                       u_emissionTextureSampler\n#endif\n#ifdef USE_AMBIENTOCCLUSION_MAP\n                                      , texture2d<float>              u_ambientOcclusionTexture\n                                      , sampler                       u_ambientOcclusionTextureSampler\n#endif\n#ifdef USE_DIFFUSE_MAP\n                                      , texture2d<float>              u_diffuseTexture\n                                      , sampler                       u_diffuseTextureSampler\n#endif\n#ifdef USE_SPECULAR_MAP\n                                      , texture2d<float>              u_specularTexture\n                                      , sampler                       u_specularTextureSampler\n#endif\n#ifdef USE_REFLECTIVE_MAP\n                                      , texture2d<float>              u_reflectiveTexture\n                                      , sampler                       u_reflectiveTextureSampler\n#elif defined(USE_REFLECTIVE_CUBEMAP)\n                                      , texturecube<float>            u_reflectiveTexture\n                                      , sampler                       u_reflectiveTextureSampler\n#endif\n#ifdef USE_TRANSPARENT_MAP\n                                      , texture2d<float>              u_transparentTexture\n                                      , sampler                       u_transparentTextureSampler\n#endif\n#ifdef USE_MULTIPLY_MAP\n                                      , texture2d<float>              u_multiplyTexture\n                                      , sampler                       u_multiplyTextureSampler\n#endif\n#ifdef USE_NORMAL_MAP\n                                      , texture2d<float>              u_normalTexture\n                                      , sampler                       u_normalTextureSampler\n#endif\n#ifdef USE_SELFILLUMINATION_MAP\n                                      , texture2d<float>              u_selfIlluminationTexture\n                                      , sampler                       u_selfIlluminationTextureSampler\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n                                      , texture2d<float>              u_displacementTexture\n                                      , sampler                       u_displacementTextureSampler\n#endif\n#ifdef USE_PBR\n#ifdef USE_METALNESS_MAP\n                                      , texture2d<float>              u_metalnessTexture\n                                      , sampler                       u_metalnessTextureSampler\n#endif\n#ifdef USE_ROUGHNESS_MAP\n                                      , texture2d<float>              u_roughnessTexture\n                                      , sampler                       u_roughnessTextureSampler\n#endif\n#ifdef USE_CLEARCOAT_MAP\n                                      , texture2d<float>              u_clearCoatTexture\n                                      , sampler                       u_clearCoatTextureSampler\n#endif\n#ifdef USE_CLEARCOATROUGHNESS_MAP\n                                      , texture2d<float>              u_clearCoatRoughnessTexture\n                                      , sampler                       u_clearCoatRoughnessTextureSampler\n#endif\n#ifdef USE_CLEARCOATNORMAL_MAP\n                                      , texture2d<float>              u_clearCoatNormalTexture\n                                      , sampler                       u_clearCoatNormalTextureSampler\n#endif\n#ifdef USE_SUBSURFACE_MAP\n                                      , texture2d<float>              u_subsurfaceTexture\n                                      , sampler                       u_subsurfaceTextureSampler\n#endif\n#ifdef USE_SUBSURFACERADIUS_MAP\n                                      , texture2d<float>              u_subsurfaceRadiusTexture\n                                      , sampler                       u_subsurfaceRadiusTextureSampler\n#endif\n#ifdef USE_TRANSMISSION_MAP\n                                      , texture2d<float>              u_transmissionTexture\n                                      , sampler                       u_transmissionTextureSampler\n#endif\n#ifdef USE_TRANSMISSIONCOLOR_MAP\n                                      , texture2d<float>              u_transmissionColorTexture\n                                      , sampler                       u_transmissionColorTextureSampler\n#endif\n#endif \n#endif \n#ifdef USE_PBR\n                                      , texturecube<float>            u_radianceTexture\n                                      , texture2d<float>              u_specularDFGDiffuseHammonTexture\n#if !defined(USE_SELFILLUMINATION_MAP)\n                                      , texturecube<float>            u_irradianceTexture\n#endif\n#endif \n#ifdef USE_SSAO\n                                      , texture2d<float>              u_ssaoTexture\n#endif\n#ifdef USE_FRAGMENT_EXTRA_ARGUMENTS\n                                      __FragmentExtraArguments__\n#endif\n#if defined(USE_DOUBLE_SIDED)\n                                      , bool                          isFrontFacing                    [[front_facing]]\n#endif\n#ifdef USE_POINT_RENDERING\n                                      , float2                        pointCoord                       [[point_coord]]\n#endif\n#ifdef USE_VERTEX_AMPLIFICATION\n                                      , ushort                        amplificationID                  [[amplification_id]]\n#endif\n#ifdef USE_BARYCENTRIC_COORD\n                                      , float3                        u_barycentricCoord                 [[barycentric_coord]]\n#endif\n                                      )\n{\n#ifdef USE_MULTIPLE_RENDERING\n    \n#ifdef USE_VERTEX_AMPLIFICATION\n    constant VFXWorldBuffer& vfx_frame = vfx_frame_multi[amplificationID];\n#else\n    constant VFXWorldBuffer& vfx_frame = vfx_frame_multi[in.sliceIndex];\n#endif\n    \n#ifdef USE_INSTANCING\n#ifdef USE_VERTEX_AMPLIFICATION\n    device commonprofile_node& vfx_node_in = vfx_nodes_in[USE_MULTIPLE_RENDERING * in.instanceID + amplificationID];\n#else\n    device commonprofile_node& vfx_node_in = vfx_nodes_in[USE_MULTIPLE_RENDERING * in.instanceID + in.sliceIndex];\n#endif\n#else\n#ifdef USE_VERTEX_AMPLIFICATION\n    device commonprofile_node& vfx_node_in = vfx_nodes_in[amplificationID];\n#else\n    device commonprofile_node& vfx_node_in = vfx_nodes_in[in.sliceIndex];\n#endif\n#endif\n    \n#else \n    \n#ifdef USE_INSTANCING\n    device commonprofile_node& vfx_node_in = vfx_nodes_in[in.instanceID];\n#endif\n    \n#endif \n    \n    commonprofile_node vfx_node = vfx_node_in;\n    \n#ifdef IS_BEZIER_CURVE\n    int vfx_bezierCurveCoverage = 0;\n    for (uint sampleID = 0; sampleID < get_num_samples(); ++sampleID) {\n        float2 uv = in.bezierCurveUV.interpolate_at_sample(sampleID);\n        bool insideCurve = vfx_is_inside_bezier_curve(uv, vfx_bezier_curve_data, vfx_bezier_curve_controlPoints);\n        vfx_bezierCurveCoverage += insideCurve;\n    }\n    if (vfx_bezierCurveCoverage == 0) {\n        discard_fragment();\n    }\n#endif\n    \n    VFXOutput _output;\n\n    \n    \n    \n    \n    VFXShaderSurface _surface;\n#ifdef USE_TEXCOORD\n    __FragmentDoTexcoord__\n#endif\n    _surface.ambientOcclusion = 1.f; \n\n#ifdef USE_AMBIENTOCCLUSION_MAP\n#if defined(USE_AMBIENTOCCLUSION_TEXTURE_COMPONENT)\n    _surface.ambientOcclusion = colorFromMask(u_ambientOcclusionTexture.sample(u_ambientOcclusionTextureSampler, _surface.ambientOcclusionTexcoord), USE_AMBIENTOCCLUSION_TEXTURE_COMPONENT).r;\n#else\n    _surface.ambientOcclusion = u_ambientOcclusionTexture.sample(u_ambientOcclusionTextureSampler, _surface.ambientOcclusionTexcoord).r;\n#endif \n#ifdef USE_AMBIENTOCCLUSION_INTENSITY\n    _surface.ambientOcclusion = saturate(mix(1.f, _surface.ambientOcclusion, vfx_commonprofile.ambientOcclusionIntensity));\n#endif\n#endif\n\n\n#if defined(USE_SSAO)\n    \n    \n    float2 uvSSAO = in.fragmentPosition.xy * vfx_frame.inverseResolution.xy;\n#if defined(USE_BENTNORMALS)\n    float4 aoBent = u_ssaoTexture.sample(sampler(filter::linear), uvSSAO).rgba;\n    _surface.ambientOcclusion *= aoBent.r;\n    _surface.bentNormal = aoBent.gba*2.0 - 1.0;\n#else\n    _surface.ambientOcclusion *= u_ssaoTexture.sample( sampler(filter::linear), uvSSAO).r;\n#endif\n#endif\n    \n#ifdef USE_DIFFUSE_MAP\n    _surface.diffuse = u_diffuseTexture.sample(u_diffuseTextureSampler, _surface.diffuseTexcoord);\n#if defined(USE_DIFFUSE_TEXTURE_COMPONENT)\n    _surface.diffuse = colorFromMask(_surface.diffuse, USE_DIFFUSE_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_DIFFUSE_INTENSITY\n    _surface.diffuse.rgb *= vfx_commonprofile.diffuseIntensity;\n#endif\n#elif defined(USE_DIFFUSE_COLOR)\n    _surface.diffuse = vfx_commonprofile.diffuseColor;\n#else\n    _surface.diffuse = float4(0.f,0.f,0.f,1.f);\n#endif\n#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)\n    _surface.diffuse.rgb    *= in.vertexColor.rgb;\n    _surface.diffuse        *= in.vertexColor.a; \n#endif\n#ifdef USE_SPECULAR_MAP\n    _surface.specular = u_specularTexture.sample(u_specularTextureSampler, _surface.specularTexcoord);\n#if defined(USE_SPECULAR_TEXTURE_COMPONENT)\n    _surface.specular = colorFromMask(_surface.specular, USE_SPECULAR_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_SPECULAR_INTENSITY\n    _surface.specular *= vfx_commonprofile.specularIntensity;\n#endif\n#elif defined(USE_SPECULAR_COLOR)\n    _surface.specular = vfx_commonprofile.specularColor;\n#elif defined(USE_SPECULAR)\n    _surface.specular = float4(0.f);\n#endif\n    \n#ifdef USE_CLEARCOAT_MAP\n    _surface.clearCoat = u_clearCoatTexture.sample(u_clearCoatTextureSampler, _surface.clearCoatTexcoord).r;\n#if defined(USE_CLEARCOAT_TEXTURE_COMPONENT)\n    _surface.clearCoat = colorFromMask(_surface.clearCoat, USE_CLEARCOAT_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_CLEARCOAT_INTENSITY\n    _surface.clearCoat *= vfx_commonprofile.clearCoatIntensity;\n#endif\n#elif defined(USE_CLEARCOAT_COLOR)\n    _surface.clearCoat = vfx_commonprofile.clearCoat;\n#else\n    _surface.clearCoat = 0.f;\n#endif\n    \n#ifdef USE_CLEARCOATROUGHNESS_MAP\n#if defined(USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT)\n    _surface.clearCoatRoughness = colorFromMask(u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord), USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.clearCoatRoughness = u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord).r;\n#endif\n#ifdef USE_CLEARCOATROUGHNESS_INTENSITY\n    _surface.clearCoatRoughness *= vfx_commonprofile.clearCoatRoughnessIntensity;\n#endif\n#elif defined(USE_CLEARCOATROUGHNESS_COLOR)\n    _surface.clearCoatRoughness = vfx_commonprofile.clearCoatRoughness;\n#else\n    _surface.clearCoatRoughness = 0.03f;\n#endif\n    \n#ifdef USE_SUBSURFACE\n#ifdef USE_SUBSURFACE_MAP\n    _surface.subsurface = u_subsurfaceTexture.sample(u_subsurfaceTextureSampler, _surface.subsurfaceTexcoord).r;\n#if defined(USE_SUBSURFACE_TEXTURE_COMPONENT)\n    _surface.subsurface = colorFromMask(_surface.subsurface, USE_SUBSURFACE_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_SUBSURFACE_INTENSITY\n    _surface.subsurface *= vfx_commonprofile.subsurfaceIntensity;\n#endif\n#elif defined(USE_SUBSURFACE_COLOR)\n    _surface.subsurface = vfx_commonprofile.subsurface;\n#else\n    _surface.subsurface = 0.f;\n#endif\n    \n#ifdef USE_SUBSURFACERADIUS_MAP\n    _surface.subsurfaceRadius = u_subsurfaceRadiusTexture.sample(u_subsurfaceRadiusTextureSampler, _surface.subsurfaceRadiusTexcoord).rgb;\n#if defined(USE_SUBSURFACERADIUS_TEXTURE_COMPONENT)\n    _surface.subsurfaceRadius = colorFromMask(_surface.subsurfaceRadius, USE_SUBSURFACERADIUS_TEXTURE_COMPONENT).rgb;\n#endif\n#ifdef USE_SUBSURFACERADIUS_INTENSITY\n    _surface.subsurfaceRadius *= vfx_commonprofile.subsurfaceRadiusIntensity;\n#endif\n#elif defined(USE_SUBSURFACERADIUS_COLOR)\n    _surface.subsurfaceRadius = vfx_commonprofile.subsurfaceRadius.rgb;\n#else\n    _surface.subsurfaceRadius = float3(0.f);\n#endif\n#endif\n    \n    \n#ifdef USE_TRANSMISSION\n#ifdef USE_TRANSMISSION_MAP\n    _surface.transmission = u_transmissionTexture.sample(u_transmissionTextureSampler, _surface.transmissionTexcoord).r;\n#if defined(USE_TRANSMISSION_TEXTURE_COMPONENT)\n    _surface.transmission = colorFromMask(_surface.transmission, USE_TRANSMISSION_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_TRANSMISSION_INTENSITY\n    _surface.transmission *= vfx_commonprofile.transmissionIntensity;\n#endif\n#elif defined(USE_TRANSMISSION_COLOR)\n    _surface.transmission = vfx_commonprofile.transmission;\n#else\n    _surface.transmission = 0.f;\n#endif\n    \n#ifdef USE_TRANSMISSIONCOLOR_MAP\n    _surface.transmissionColor = u_transmissionColorTexture.sample(u_transmissionColorTextureSampler, _surface.transmissionColorTexcoord).rgb;\n#if defined(USE_TRANSMISSIONCOLOR_TEXTURE_COMPONENT)\n    _surface.transmissionColor = colorFromMask(_surface.transmissionColor, USE_TRANSMISSIONCOLOR_TEXTURE_COMPONENT).rgb;\n#endif\n#ifdef USE_TRANSMISSIONCOLOR_INTENSITY\n    _surface.transmissionColor *= vfx_commonprofile.transmissionColorIntensity;\n#endif\n#elif defined(USE_TRANSMISSIONCOLOR_COLOR)\n    _surface.transmissionColor = vfx_commonprofile.transmissionColor.rgb;\n#else\n    _surface.transmissionColor = float3(0.f);\n#endif\n#endif\n    \n#ifdef USE_EMISSION_MAP\n    _surface.emission = u_emissionTexture.sample(u_emissionTextureSampler, _surface.emissionTexcoord);\n#if defined(USE_EMISSION_TEXTURE_COMPONENT)\n    _surface.emission = colorFromMask(_surface.emission, USE_EMISSION_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_EMISSION_INTENSITY\n    _surface.emission *= vfx_commonprofile.emissionIntensity;\n#endif\n#elif defined(USE_EMISSION_COLOR)\n    _surface.emission = vfx_commonprofile.emissionColor;\n#elif defined(USE_EMISSION)\n    _surface.emission = float4(0.);\n#endif\n#ifdef USE_SELFILLUMINATION_MAP\n    _surface.selfIllumination = u_selfIlluminationTexture.sample(u_selfIlluminationTextureSampler, _surface.selfIlluminationTexcoord);\n#if defined(USE_SELFILLUMINATION_TEXTURE_COMPONENT)\n    _surface.selfIllumination = colorFromMask(_surface.selfIllumination, USE_SELFILLUMINATION_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_SELFILLUMINATION_INTENSITY\n    _surface.selfIllumination *= vfx_commonprofile.selfIlluminationIntensity;\n#endif\n#elif defined(USE_SELFILLUMINATION_COLOR)\n    _surface.selfIllumination = vfx_commonprofile.selfIlluminationColor;\n#elif defined(USE_SELFILLUMINATION)\n    _surface.selfIllumination = float4(0.);\n#endif\n#ifdef USE_MULTIPLY_MAP\n    _surface.multiply = u_multiplyTexture.sample(u_multiplyTextureSampler, _surface.multiplyTexcoord);\n#if defined(USE_MULTIPLY_TEXTURE_COMPONENT)\n    _surface.multiply = colorFromMask(_surface.multiply, USE_MULTIPLY_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_MULTIPLY_INTENSITY\n    _surface.multiply = mix(float4(1.), _surface.multiply, vfx_commonprofile.multiplyIntensity);\n#endif\n#elif defined(USE_MULTIPLY_COLOR)\n    _surface.multiply = vfx_commonprofile.multiplyColor;\n#elif defined(USE_MULTIPLY)\n    _surface.multiply = float4(1.);\n#endif\n#ifdef USE_TRANSPARENT_MAP\n    _surface.transparent = u_transparentTexture.sample(u_transparentTextureSampler, _surface.transparentTexcoord);\n#if defined(USE_TRANSPARENT_TEXTURE_COMPONENT)\n    _surface.transparent = colorFromMask(_surface.transparent, USE_TRANSPARENT_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_TRANSPARENT_INTENSITY\n    _surface.transparent *= vfx_commonprofile.transparentIntensity;\n#endif\n#elif defined(USE_TRANSPARENT_COLOR)\n    _surface.transparent = vfx_commonprofile.transparentColor;\n#elif defined(USE_TRANSPARENT)\n    _surface.transparent = float4(1.f);\n#endif\n    \n#ifdef USE_METALNESS_MAP\n#if defined(USE_METALNESS_TEXTURE_COMPONENT)\n    _surface.metalness = colorFromMask(u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord), USE_METALNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.metalness = u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord).r;\n#endif\n#ifdef USE_METALNESS_INTENSITY\n    _surface.metalness *= vfx_commonprofile.metalnessIntensity;\n#endif\n#elif defined(USE_METALNESS_COLOR)\n    _surface.metalness = vfx_commonprofile.metalness;\n#else\n    _surface.metalness = 0.f;\n#endif\n    \n#ifdef USE_ROUGHNESS_MAP\n#if defined(USE_ROUGHNESS_TEXTURE_COMPONENT)\n    _surface.roughness = colorFromMask(u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord), USE_ROUGHNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.roughness = u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord).r;\n#endif\n#ifdef USE_ROUGHNESS_INTENSITY\n    _surface.roughness *= vfx_commonprofile.roughnessIntensity;\n#endif\n#elif defined(USE_ROUGHNESS_COLOR)\n    _surface.roughness = vfx_commonprofile.roughness;\n#else\n    _surface.roughness = 0.f;\n#endif\n#if (defined USE_POSITION) && (USE_POSITION == 2)\n    _surface.position = in.position;\n#endif\n#if (defined USE_NORMAL) && (USE_NORMAL == 2)\n#if defined(HAS_NORMAL) || defined(USE_OPENSUBDIV)\n#ifdef USE_DOUBLE_SIDED\n    _surface.geometryNormal = normalize(in.normal.xyz) * (isFrontFacing ? 1.f : -1.f );\n#else\n    _surface.geometryNormal = normalize(in.normal.xyz);\n#endif\n#else \n    _surface.geometryNormal = normalize( cross(dfdy( _surface.position ), dfdx( _surface.position ) ));\n#ifdef USE_GBUFFER_OUTPUT\n    _surface.geometryNormal = vfx::mat3(vfx_frame.inverseViewTransform) * _surface.geometryNormal;\n#endif\n#endif\n    _surface.normal = _surface.geometryNormal;\n    _surface.clearCoatNormal = _surface.geometryNormal;\n#ifdef USE_BENTNORMALS\n    _surface.aoDirectionnal = mix(0., _surface.ambientOcclusion, dot(_surface.bentNormal, _surface.normal)*0.5+0.5);\n#endif\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    _surface.tangent = in.tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    _surface.bitangent = in.bitangent;\n#endif\n#if (defined USE_VIEW) && (USE_VIEW == 2)\n    _surface.view = normalize(-in.position);\n    {\n        \n        float NoV = dot(_surface.geometryNormal, _surface.view);\n        _surface.view = _surface.view + max(0.f, -2.f * NoV) * _surface.geometryNormal;         \n        \n    }\n#endif\n#if defined(USE_NORMAL_MAP)\n    {\n        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.normal);\n#ifdef USE_NORMAL_MAP\n#if defined(USE_NORMAL_TEXTURE_COMPONENT)\n        _surface._normalTS.xy = colorFromMask(u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord), USE_NORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;\n        _surface._normalTS.z = sqrt(1.f - saturate(length_squared(_surface._normalTS.xy)));\n#else\n        _surface._normalTS = u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord).rgb;\n        _surface._normalTS = _surface._normalTS * 2.f - 1.f;\n#endif\n#ifdef USE_NORMAL_INTENSITY\n        _surface._normalTS = normalize(mix(float3(0.f, 0.f, 1.f), _surface._normalTS, vfx_commonprofile.normalIntensity));\n#endif\n#else\n        _surface._normalTS = float3(0.f, 0.f, 1.f);\n#endif\n        _surface.normal.rgb = normalize(ts2vs * _surface._normalTS.xyz );\n    }\n#else\n    _surface._normalTS = float3(0.f, 0.f, 1.f);\n#endif\n#if defined(USE_PBR) && !defined(USE_GBUFFER_OUTPUT)\n    {\n        _surface.rawRoughness = _surface.roughness;\n        float roughness = clamp(_surface.roughness, PBR_MIN_ROUGHNESS, 1.0);\n        float alpha = vfx_filteredAlphaFromRoughness(_surface.normal, roughness);\n        _surface.roughness = sqrt(alpha);\n    }\n#endif\n#if defined(USE_CLEARCOATNORMAL_MAP)\n    {\n        \n        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.geometryNormal);\n#ifdef USE_CLEARCOATNORMAL_MAP\n#if defined(USE_CLEARCOATNORMAL_TEXTURE_COMPONENT)\n        _surface._clearCoatNormalTS.xy = colorFromMask(u_clearCoatNormalTexture.sample(u_clearCoatnormalTextureSampler, _surface.clearCoatNormalTexcoord), USE_CLEARCOATNORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;\n        _surface._clearCoatNormalTS.z = sqrt(1.f - saturate(length_squared(_surface._clearCoatNormalTS.xy)));\n#else\n        _surface._clearCoatNormalTS = u_clearCoatNormalTexture.sample(u_clearCoatNormalTextureSampler, _surface.clearCoatNormalTexcoord).rgb;\n        _surface._clearCoatNormalTS = _surface._clearCoatNormalTS * 2.f - 1.f;\n#endif\n#ifdef USE_CLEARCOATNORMAL_INTENSITY\n        _surface._clearCoatNormalTS = mix(float3(0.f, 0.f, 1.f), _surface._clearCoatNormalTS, vfx_commonprofile.clearCoatNormalIntensity);\n#endif\n#else\n        _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);\n#endif\n        _surface.clearCoatNormal.rgb = normalize(ts2vs * _surface._clearCoatNormalTS.xyz );\n    }\n#else\n    _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);\n#endif\n    \n#ifdef USE_REFLECTIVE_MAP\n    float3 refl = reflect( -_surface.view, _surface.normal );\n    float m = 2.f * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.f)*(refl.z+1.f));\n    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, float2(float2(refl.x,-refl.y) / m) + 0.5f);\n#if defined(USE_REFLECTIVE_TEXTURE_COMPONENT)\n    _surface.reflective = colorFromMask(_surface.reflective, USE_REFLECTIVE_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_REFLECTIVE_INTENSITY\n    _surface.reflective *= vfx_commonprofile.reflectiveIntensity;\n#endif\n#elif defined(USE_REFLECTIVE_CUBEMAP)\n    float3 refl = reflect( _surface.position, _surface.normal );\n    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, vfx::mat4_mult_float3(vfx_frame.viewToCubeTransform, refl)); \n#ifdef USE_REFLECTIVE_INTENSITY\n    _surface.reflective *= vfx_commonprofile.reflectiveIntensity;\n#endif\n#elif defined(USE_REFLECTIVE_COLOR)\n    _surface.reflective = vfx_commonprofile.reflectiveColor;\n#elif defined(USE_REFLECTIVE)\n    _surface.reflective = float4(0.);\n#endif\n#ifdef USE_FRESNEL\n    _surface.fresnel = vfx_commonprofile.fresnel.x + vfx_commonprofile.fresnel.y * pow(1.f - saturate(dot(_surface.view, _surface.normal)), vfx_commonprofile.fresnel.z);\n    _surface.reflective *= _surface.fresnel;\n#endif\n#ifdef USE_SHININESS\n    _surface.shininess = vfx_commonprofile.materialShininess;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_SURFACE_MODIFIER\n    \n    __DoSurfaceModifier__\n    \n#endif\n    \n    \n    \n    \n    \n    VFXShaderLightingContribution _lightingContribution(_surface, in);\n#ifdef USE_LIGHT_MODIFIER\n    __LightModifierCopyDecl__\n#endif\n#ifdef USE_AMBIENT_LIGHTING\n    _lightingContribution.ambient = vfx_frame.ambientLightingColor.rgb;\n#endif\n#ifdef USE_LIGHTING\n#ifdef USE_PER_PIXEL_LIGHTING\n#ifdef USE_CLUSTERED_LIGHTING\n    uint3 clusterIndex;\n    clusterIndex.xy = uint2(in.fragmentPosition.xy * vfx_frame.clusterScale.xy); \n    clusterIndex.z = in.position.z * vfx_frame.clusterScale.z + vfx_frame.clusterScale.w; \n    \n    \n    ushort4 cluster_offset_count = u_clusterTexture.read(clusterIndex);\n    int lid = cluster_offset_count.x;\n#endif\n\n#ifdef USE_PBR\n    _lightingContribution.prepareForPBR(u_specularDFGDiffuseHammonTexture, vfx_commonprofile.selfIlluminationOcclusion);\n    \n    \n#ifdef USE_SELFILLUMINATION\n    _lightingContribution.add_irradiance_from_selfIllum();\n#else\n#ifdef USE_PROBES_LIGHTING \n\n#ifdef USE_IBL_TRANSFORM\n    _lightingContribution.add_global_irradiance_from_sh(vfx_frame.environmentTransform * vfx_frame.viewToCubeTransform, vfx_node.shCoefficients);\n#else\n    _lightingContribution.add_global_irradiance_from_sh(vfx_frame.viewToCubeTransform, vfx_node.shCoefficients);\n#endif \n\n#else\n\n#ifdef USE_IBL_TRANSFORM\n    _lightingContribution.add_global_irradiance_probe(u_irradianceTexture, vfx_frame.environmentTransform * vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#else\n    _lightingContribution.add_global_irradiance_probe(u_irradianceTexture, vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#endif \n\n#endif \n#endif\n\n    \n#ifdef CFX_USE_REFLECTION_PROBES\n    int probe_count = (cluster_offset_count.z & 0xff);\n    for (int i = 0 ; i < probe_count; ++i, ++lid) {\n        if ((vfx_node.categoryBitmask & vfx_lights[LightIndex(lid)].categoryBitmask) == 0) continue;\n        _lightingContribution.add_local_probe(vfx_lights[LightIndex(lid)], u_reflectionProbeTexture);\n    }\n#if PROBES_NORMALIZATION\n    float3 probesNormalization = 0;\n#if PROBES_OUTER_BLENDING\n    probesNormalization = _lightingContribution.probesWeightedSum.rgb / max(1.f, _lightingContribution.probesWeightedSum.a);\n#else\n    probesNormalization = _lightingContribution.probesWeightedSum.rgb / _lightingContribution.probesWeightedSum.a;\n#endif \n#ifdef DISABLE_SPECULAR\n    _lightingContribution.pbr.envDiffuse += probesNormalization;\n#else\n    _lightingContribution.specular += probesNormalization;\n#endif\n\n    float globalFactor = saturate(1.f - _lightingContribution.probesWeightedSum.a);\n#else\n    float globalFactor = _lightingContribution.probeRadianceRemainingFactor;\n#endif \n\n#ifndef DISABLE_SPECULAR\n#ifdef USE_IBL_TRANSFORM\n    _lightingContribution.add_global_probe(vfx_frame.environmentTransform * vfx_frame.viewToCubeTransform, globalFactor * vfx_frame.environmentIntensity,\n                                           u_reflectionProbeTexture);\n#else\n    _lightingContribution.add_global_probe(vfx_frame.viewToCubeTransform, globalFactor * vfx_frame.environmentIntensity,\n                                           u_reflectionProbeTexture);\n#endif \n#endif \n    \n#else \n\n#ifndef DISABLE_SPECULAR\n\n#ifdef USE_IBL_TRANSFORM\n    _lightingContribution.add_global_probe(u_radianceTexture, vfx_frame.environmentTransform * vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#else\n   _lightingContribution.add_global_probe(u_radianceTexture, vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#endif \n    \n#ifdef USE_CLEARCOAT\n    \n#ifdef USE_IBL_TRANSFORM\n    _lightingContribution.add_global_probeClearCoat(u_radianceTexture, vfx_frame.environmentTransform * vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#else\n    _lightingContribution.add_global_probeClearCoat(u_radianceTexture, vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#endif \n    \n#endif \n\n    \n#endif \n#endif \n\n#endif \n    #if DEBUG_PIXEL\n        switch (DEBUG_PIXEL) {\n            case 1: _output.color = float4(_surface.normal * 0.5f + 0.5f, 1.f); break;\n            case 2: _output.color = float4(_surface.geometryNormal * 0.5f + 0.5f, 1.f); break;\n            case 3: _output.color = float4(_surface.tangent * 0.5f + 0.5f, 1.f); break;\n            case 4: _output.color = float4(in.uv0, 0.f, 1.f); break;\n            case 5: _output.color = float4(_surface.diffuse.rgb, 1.f); break;\n            case 6: _output.color = float4(float3(_surface.roughness), 1.f); break;\n            case 7: _output.color = float4(float3(_surface.metalness), 1.f); break;\n            case 8: _output.color = float4(float3(_surface.ambientOcclusion), 1.f); break;\n                \n            #ifdef USE_BENTNORMALS\n                case 9: _output.color = float4(float3(_surface.bentNormal * 0.5f + 0.5f), 1.f); break;\n            #else\n                case 9: _output.color = float4(float3(_surface.normal * 0.5f + 0.5f), 1.f); break;\n            #endif\n            default: break;\n        }\n        return _output;\n    #endif\n    \n    __FragmentDoLighting__\n    \n    #ifdef USE_CLUSTERED_LIGHTING\n        \n        int omni_count = cluster_offset_count.y & 0xff;\n        for (int i = 0 ; i < omni_count; ++i, ++lid) {\n            if ((vfx_node.categoryBitmask & vfx_lights[LightIndex(lid)].categoryBitmask) == 0) continue;\n            _lightingContribution.add_local_omni(vfx_lights[LightIndex(lid)]);\n        }\n\n        \n        int spot_count = (cluster_offset_count.y >> 8);\n        for (int i = 0 ; i < spot_count; ++i, ++lid) {\n            if ((vfx_node.categoryBitmask & vfx_lights[LightIndex(lid)].categoryBitmask) == 0) continue;\n            _lightingContribution.add_local_spot(vfx_lights[LightIndex(lid)]);\n        }\n\n    #endif\n#else \n        _lightingContribution.diffuse = in.diffuse;\n    #ifdef USE_SPECULAR\n        _lightingContribution.specular = in.specular;\n    #endif\n#endif \n    #ifdef AVOID_OVERLIGHTING\n        _lightingContribution.diffuse = saturate(_lightingContribution.diffuse);\n    #ifdef USE_SPECULAR\n        _lightingContribution.specular = saturate(_lightingContribution.specular);\n    #endif \n    #endif \n#else \n    _lightingContribution.diffuse = float3(0.);\n#endif \n\n    \n    \n    \n    \n#ifndef USE_GBUFFER_OUTPUT\n#ifdef USE_PBR\n    { \n        float3 diffuseAlbedo = mix(_lightingContribution.pbr.albedo, float3(0.0), _surface.metalness);\n        \n        \n#ifdef USE_PBR_TRANSPARENCY\n        float3 color = (_lightingContribution.ambient * _surface.ambientOcclusion) * _lightingContribution.pbr.albedo;\n#else\n        float3 color = (_lightingContribution.ambient * _surface.ambientOcclusion) * _surface.diffuse.rgb;\n#endif\n        \n        color += _lightingContribution.pbr.envDiffuse;\n        color += _lightingContribution.diffuse * diffuseAlbedo;\n#ifndef DISABLE_SPECULAR\n#ifndef DISABLE_SPECULAR_IBL\n        color += _lightingContribution.pbr.envSpecular;\n#endif\n        color += _lightingContribution.specular;\n#endif\n#ifdef USE_EMISSION\n        color += _surface.emission.rgb;\n#endif\n#ifdef USE_MULTIPLY\n        color *= _surface.multiply.rgb;\n#endif\n#ifdef USE_MODULATE\n        color *= _lightingContribution.modulate;\n#endif\n#ifndef USE_GBUFFER_OUTPUT\n        _output.color.rgb = color;\n#endif\n    }\n#else \n\n#ifdef USE_SHADOWONLY\n    _output.color.rgb = float3(0.0);\n    _output.color.a = 1. - _lightingContribution.shadowFactor;\n#else\n#ifdef USE_CONSTANT\n    _output.color.rgb = _surface.diffuse.rgb;\n    \n#ifdef USE_EMISSION\n    _output.color.rgb += _surface.emission.rgb;\n#endif\n#ifdef USE_MULTIPLY\n    _output.color.rgb *= _surface.multiply.rgb;\n#endif\n    \n#else\n    _output.color.rgb = illuminate(_surface, _lightingContribution);\n#endif\n#endif \n#endif \n\n#ifndef USE_SHADOWONLY\n  #ifdef USE_PBR_TRANSPARENCY\n    _output.color.a = _lightingContribution.pbr.transparency;\n  #else\n    _output.color.a = _surface.diffuse.a;\n  #endif\n#endif\n\n#ifdef USE_FOG\n    applyFog(_output.color, length(_surface.position.xyz), vfx_frame.fogParameters, vfx_frame.fogColor);\n#endif\n\n#if !defined(DIFFUSE_PREMULTIPLIED) && !defined(USE_PBR_TRANSPARENCY)\n    _output.color.rgb *= _surface.diffuse.a;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_SHADOWONLY\n    float transparencyFactor = 1.0;\n  #ifdef USE_NODE_OPACITY\n    transparencyFactor *= in.nodeOpacity;\n  #endif\n    _output.color.a *= transparencyFactor; \n\n#else \n\n#ifdef USE_TRANSPARENT \n    \n#ifndef USE_PBR_TRANSPARENCY\n  _output.color *= _surface.transparent.a;\n#endif\n\n#endif \n    \n#ifdef USE_NODE_OPACITY\n    _output.color *= in.nodeOpacity;\n#endif\n    \n#endif \n#endif \n\n    \n    \n    \n    \n#ifdef USE_MODIFIER_FRAMEBUFFER\n    const VFXFramebuffer _framebuffer = {\n#if defined(CFX_SUPPORTS_PROGRAMMABLE_BLENDING) && defined(USE_MODIFIER_FRAMEBUFFER_COLOR0)\n        .color = framebufferColor0\n#else\n        .color = 0.f\n#endif\n    };\n#endif\n    \n#ifdef USE_FRAGMENT_MODIFIER\n    \n    __DoFragmentModifier__\n    \n#endif\n#if defined(USE_CLUSTERED_LIGHTING) && defined(DEBUG_CLUSTER_TILE)\n    _output.color.rgb = mix(_output.color.rgb, float3(vfx::debugColorForCount(clusterIndex.z).xyz), 0.1f);\n    _output.color.rgb = mix(_output.color.rgb, float3(clusterIndex.x & 0x1 ^ clusterIndex.y & 0x1).xyz, 0.01f);\n#endif\n    \n#ifdef USE_ALPHA_CUTOFF\n    if (_output.color.a <= vfx_commonprofile.alphaCutoff)\n        discard_fragment();\n#endif\n\n#ifdef USE_POINT_RENDERING\n    if ((dfdx(pointCoord.x) < 0.5f) && (length_squared(pointCoord * 2.f - 1.f) > 1.f)) {\n        discard_fragment();\n    }\n#endif\n    \n    \n#ifdef USE_OUTLINE\n    _output.color.rgb = in.outlineHash;\n#endif\n    \n\n#if defined(USE_MOTIONBLUR) && !defined(USE_GBUFFER_OUTPUT)\n#ifdef USE_MULTIPLE_RENDERING\n    _output.motionblur.xy = half2((in.mv_fragment.xy - vfx_frame.viewportSize.zw) / in.mv_fragment.z - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * vfx_frame.motionBlurIntensity;\n#else\n    _output.motionblur.xy = half2((in.mv_fragment.xy / in.mv_fragment.z) - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * vfx_frame.motionBlurIntensity;\n#endif\n    _output.motionblur.z = length(_output.motionblur.xy);\n    _output.motionblur.w = half(-_surface.position.z);\n#endif\n\n#ifdef USE_NORMAL_ROUGHNESS_OUTPUT\n#ifdef USE_PBR\n    _output.normalRoughness = half4( half3(_surface.normal.xyz), half(_surface.rawRoughness) );\n#else\n    _output.normalRoughness = half4( half3(_surface.normal.xyz), 0.h );\n#endif\n#endif\n                                 \n#ifdef USE_ALBEDO_METALNESS_OUTPUT\n#ifdef USE_PBR\n    _output.albedoMetalnessOutput = half4( half3(_surface.diffuse.rgb), half(_surface.metalness) );\n#else \n    _output.albedoMetalnessOutput = half4( 0.h );\n#endif\n#endif\n    \n#ifdef USE_RADIANCE_AO_OUTPUT\n#ifdef USE_PBR\n    _output.radianceAOOutput = half4(half3(_lightingContribution.pbr.envSpecular.rgb), half(_surface.ambientOcclusion));\n#else\n    _output.radianceAOOutput = half4(0.h, 0.h, 0.h, 0.h);\n#endif\n#endif\n    \n#ifdef USE_BARYCENTRIC_WIREFRAME\n#ifdef USE_BARYCENTRIC_COORD\n    const float3 d = 1.0f * fwidth(baryCoord);\n    const float3 s = smoothstep(d * 0.25f, d * 0.75, u_barycentricCoord);\n    _output.color = mix(float4(1.0), _output.color, min3(s.x, s.y, s.z));\n#endif\n#endif\n    \n#ifdef USE_GBUFFER_OUTPUT\n    float opacity = _surface.diffuse.a;\n#ifdef USE_NODE_OPACITY\n    opacity *= in.nodeOpacity;\n#endif\n    \n    float dither = vfx::interleaved_gradient_noise(in.fragmentPosition.xy);\n    dither = fract(dither + in.fragmentPosition.z * 1.61803398875);\n    dither = fract(dither + vfx_frame.frame * 1.61803398875);\n    if (opacity < dither) discard_fragment();\n    if (opacity < 0.01) discard_fragment();\n    \n    float3 emission = float3(0.);\n#ifdef USE_EMISSION\n    emission = _surface.emission.rgb;\n#endif\n    _output.albedo = float4(_surface.diffuse.rgb, opacity);\n    _output.normals = float4(_surface.normal.xyz, -_surface.position.z);\n    _output.roughmetal = float4(_surface.roughness, _surface.metalness, _surface.ambientOcclusion, 1.);\n    _output.color = float4(emission, 1.);\n    \n    float2 vfx_prevUv = (in.mv_lastFragment.xy / in.mv_lastFragment.z);\n    float2 vfx_uv = (in.mv_fragment.xy / in.mv_fragment.z);\n    _output.velocity.xy = (vfx_prevUv - vfx_uv) * float2(.5,-.5);\n    \n#ifdef USE_MOTIONBLUR\n    _output.velocity.z = length(_output.velocity.xy);\n    _output.velocity.w = -_surface.position.z;\n#endif\n    ushort clearcoatIR = packHalf2ToUShort(half2(_surface.clearCoat, _surface.clearCoatRoughness));\n    _output.clearCoat = half4(half3(_surface.clearCoatNormal), as_type<half>(clearcoatIR));\n    \n    _output.subsurface = half4(half3(_surface.subsurfaceRadius), half(_surface.subsurface));\n    \n    float transmissionColorLength = length(_surface.transmissionColor);\n    _surface.transmissionColor /= max(1e-4, transmissionColorLength);\n    ushort transmissionRG = packHalf2ToUShort(half2(_surface.transmissionColor.r, _surface.transmissionColor.g));\n    ushort transmissionBW = packHalf2ToUShort(half2(_surface.transmissionColor.b, _surface.transmission));\n    _output.transmission = ushort4(transmissionRG, transmissionBW,\n                                 as_type<ushort>(half(transmissionColorLength)), as_type<ushort>(half(vfx_commonprofile.indexOfRefraction)));\n#endif\n\n#ifdef USE_RE_SYSTEM_TREATMENTS\n\n#ifdef USE_MULTIPLE_RENDERING\n#ifdef USE_VERTEX_AMPLIFICATION\n    uint cameraIndex = amplificationID;\n#else\n    uint cameraIndex = in.sliceIndex;\n#endif\n#else\n    uint cameraIndex = 0;\n#endif \n\n    uint sampleMask = 0;\n\n    vfx::api_v2::re_buffers buffers = vfx::api_v2::re_buffers {\n        .entityConstants      = u_re_entityConstants,\n        .viewConstants        = u_re_viewConstants,\n        .globalConstants      = u_re_globalConstants,\n        .objectConstants      = u_re_vfx_objectConstants,\n        .entityArgumentBuffer = u_re_vfx_entityArgumentBuffer,\n        .sceneArgumentBuffer  = u_re_vfx_sceneArgumentBuffer,\n#ifdef USE_RE_SYSTEM_TREATMENTS_TIER_1_AB\n        .probeTextures        = u_re_vfx_virtualEnvProbeTextures\n#endif\n    };\n\n    auto params = vfx::api_v2::make_system_treatment_parameters(in.crworldPosition, in.fragmentPosition, cameraIndex, in.screen_uv);\n    _output.color = float4(vfx::api_v2::apply_system_treatments(half4(_output.color), params, buffers, sampleMask));\n#endif \n\n    return _output;\n}\n\n#pragma mark - Namespace End\n\n    \n"
+ "       .allowGPUOptimizedContents = "
+ "       .arrayLength = "
+ "       .compressionType = MTLTextureCompressionType("
+ "       .cpuCacheMode = MTLCPUCacheMode("
+ "       .depth = "
+ "       .hazardTrackingMode = MTLHazardTrackingMode("
+ "       .height = "
+ "       .mipmapLevelCount = "
+ "       .pixelFormat = MTLPixelFormat("
+ "       .sampleCount = "
+ "       .storageMode = MTLStorageMode("
+ "       .swizzle = MTLTextureSwizzleChannelsDefault,\n"
+ "       .textureType = MTLTextureType("
+ "       .usage = "
+ "       .width = "
+ "     .length = "
+ "     .options = "
+ "    %@ %@;\n"
+ "    (CFXTextureDescriptor){\n"
+ "    (RGBufferDescriptor){\n"
+ "    .length = "
+ "    .options = "
+ "    ^(uint8_t _){ id<MTLResource> r = nil; return r; }\n"
+ "    return first->classIdentifier() < second->classIdentifier();\n"
+ "    return first->instanceIdentifier() < second->instanceIdentifier();\n"
+ "    }\n"
+ "    },\n"
+ "   (RGBufferDescriptor){\n"
+ "   .allowGPUOptimizedContents = "
+ "   .arrayLength = "
+ "   .compressionType = MTLTextureCompressionType("
+ "   .cpuCacheMode = MTLCPUCacheMode("
+ "   .depth = "
+ "   .hazardTrackingMode = MTLHazardTrackingMode("
+ "   .height = "
+ "   .mipmapLevelCount = "
+ "   .pixelFormat = MTLPixelFormat("
+ "   .sampleCount = "
+ "   .storageMode = MTLStorageMode("
+ "   .swizzle = MTLTextureSwizzleChannelsDefault,\n"
+ "   .textureType = MTLTextureType("
+ "   .usage = "
+ "   .width = "
+ "  maxInf:%d\n"
+ "  model: %@\n"
+ " * float(%range.y - %range.x))"
+ " + \" \" + %1);\n#r0=%1"
+ " + \" \" + %2);\n#r0=%2"
+ " - vfx_cos((%0 * VFX_PI) / "
+ " - vfx_exp(%exponent * %t)) / ("
+ " - vfx_exp(%exponent))"
+ " - vfx_float3_half_one())"
+ " - vfx_float3_half_one()) * vfx_sqrt("
+ " = $subgraph_outputs["
+ " = CFX::RG::makeCopyPass(*builder, \""
+ " = builder->"
+ " = builder->createPass<CFX::RG::Pass>("
+ " Add TextureLoadRequestCPU on #"
+ " Add TextureLoadRequestGPU on #"
+ " doesn't match input texture  "
+ " expects a depth texture with same size as color texture"
+ " for cache entry in non loading state. Current state is "
+ " from "
+ " from frame n - "
+ " from previous frame\n"
+ " hasn't been ingested yet"
+ " in a timely manner."
+ " in binary archive"
+ " missing in library "
+ " name "
+ " not used with mode 'Per Eval'"
+ " reached timeout"
+ " remotePreviewProtocolVersion: "
+ " requires static input object"
+ " should be flagged as compute heavy"
+ " unsupported semantic for present node"
+ "!CFSetContainsValue(model->_trackedNodes, node)"
+ "!model->_trackedNodes || !CFSetGetCount(model->_trackedNodes)"
+ "\")))\nstatic struct { uint64_t magic; const char *name; void *fn; }\n__vfx_script_table_ref = { "
+ "\",\n"
+ "\", "
+ "\", (CFX::RG::CopyPass::Parameters){\n"
+ "#%d [%p:%s] add:%g sum:%g record:%d\n"
+ "#24@0:8^{__CFXGeometry=}16"
+ "#define USE_QUAT_FOR_IES 1\n#define USE_PBR_DOMINANT_DIRECTION 1\n\n#define PBR_INTENSITY_FACTOR M_PI_2_F\n#define BoostFactor (20.0f * PBR_INTENSITY_FACTOR)\n\n\nstruct vfx_light\n{\n    float4 color; \n    float3 pos; \n    float3 dir; \n    float shadowRadius; \n    uint8_t lightType; \n    uint8_t shadowSampleCount; \n                                \n    union {\n        struct {\n            float4      cascadeScale[4]; \n            float4      cascadeBias[4];\n        } directional; \n        struct {\n            float4      attenuationFactors; \n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n            float4x4    projection;\n            float       depthBias;\n#else\n            float3      shadowScaleBias; \n#endif\n        } omni;\n        struct {\n            float4      _attenuationFactors; \n            float2      scaleBias; \n        } spot;\n        struct {\n            float4      _attenuationFactors; \n            float2      scaleBias; \n#if USE_QUAT_FOR_IES\n            float4      light_from_view_quat; \n#else\n            float4x4    light_from_view; \n#endif\n        } ies;\n        union {\n            struct {\n                float2 halfExtents;\n                float doubleSided;\n            } rectangle;\n            struct {\n                uint32_t vertexCount;\n                float doubleSided;\n            } polygon;\n            struct {\n                float halfLength;\n            } line;\n            struct {\n                float2 halfExtents;\n                float doubleSided;\n            } ellipse;\n            struct {\n                float3 halfExtents;\n            } ellipsoid;\n        } area;\n        struct {\n            float3  offset;\n            float4  halfExtents; \n            float3  parallaxCenter;\n            float3  parallaxExtents;\n            int32_t index; \n            int32_t parallaxCorrection; \n        } probe;\n    } parameters; \n\n    float4x4    shadowMatrix; \n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    float4 tiles[6]; \n#endif\n\tuint8_t categoryBitmask;\n};\n\n#if defined(__METAL_VERSION__) \n\nusing namespace metal;\n\nnamespace vfx_lighting {\n    static constexpr sampler linearSampler = sampler(filter::linear, mip_filter::linear);\n}\n\nstruct VFXShaderSurface {\n    float3 view;                \n    float3 position;            \n    float3 normal;              \n#ifdef USE_BENTNORMALS\n    float3 bentNormal;          \n    float aoDirectionnal;       \n#endif\n    float3 geometryNormal;      \n    float2 normalTexcoord;      \n    float3 tangent;             \n    float3 bitangent;           \n    float4 diffuse;             \n    float2 diffuseTexcoord;     \n    float4 specular;            \n    float2 specularTexcoord;    \n    float4 emission;            \n    float2 emissionTexcoord;    \n    float4 selfIllumination;            \n    float2 selfIlluminationTexcoord;    \n    float4 multiply;            \n    float2 multiplyTexcoord;    \n    float4 transparent;         \n    float2 transparentTexcoord; \n    float4 reflective;          \n    float  metalness;           \n    float2 metalnessTexcoord;   \n    float  roughness;           \n    float2 roughnessTexcoord;   \n    float  rawRoughness;        \n    float clearCoat;            \n    float2 clearCoatTexcoord;   \n    float clearCoatRoughness;   \n    float2 clearCoatRoughnessTexcoord;\n    float3 clearCoatNormal;     \n    float2 clearCoatNormalTexcoord;\n#ifdef USE_SUBSURFACE\n    float subsurface;\n    float2 subsurfaceTexcoord;\n    float3 subsurfaceRadius;\n    float2 subsurfaceRadiusTexcoord;\n#endif\n#ifdef USE_TRANSMISSION\n    float transmission;\n    float2 transmissionTexcoord;\n    float3 transmissionColor;\n    float2 transmissionColorTexcoord;\n#endif\n    float shininess;            \n    float fresnel;              \n    float ambientOcclusion;     \n    float2 ambientOcclusionTexcoord;   \n    float3 _normalTS;           \n    float3 _clearCoatNormalTS;  \n#ifdef USE_SURFACE_EXTRA_DECL\n    __SurfaceExtraDecl__\n#endif\n};\n\n\n\nstruct VFXShaderLight {\n    float4 intensity;\n    float3 direction;\n\n    float  _att;\n    float3 _spotDirection;\n    float  _distance;\n};\n\nenum VFXShadingModel\n{\n    VFXShadingModelConstant,\n    VFXShadingModelPhong,\n    VFXShadingModelNone,\n    VFXShadingModelPhysicallyBased,\n    VFXShadingModelShadowOnly,\n\n    VFXShadingModelCustom \n};\n\n#define PROBES_NORMALIZATION 0\n#define PROBES_OUTER_BLENDING 1\n\nstruct VFXShaderLightingContribution\n{\n    float3 ambient;\n    float3 diffuse;\n    float3 specular;\n    float3 modulate;\n\n#ifdef USE_SHADOWONLY\n    float shadowFactor;\n#endif\n\n#if PROBES_NORMALIZATION\n    float4 probesWeightedSum; \n#else\n    float  probeRadianceRemainingFactor;\n#endif\n\n    thread VFXShaderSurface& surface;\n\n#ifdef USE_PER_VERTEX_LIGHTING\n    commonprofile_io out;\n#else\n    commonprofile_io in;\n#endif\n\n#ifdef USE_PBR\n    struct {\n        float3 albedo;\n        float3 envDiffuse;\n        float3 envSpecular;\n        float3 reflectance;\n        float3 probeReflectance;\n#ifndef USE_PBR_LAMBERTIAN_REFLECTION\n        float2 diffuseHammonFactors;\n#endif\n#ifdef USE_PBR_TRANSPARENCY\n        float  transparency;\n#endif\n        float  NoV;\n        float  selfIlluminationOcclusion;\n#ifdef USE_CLEARCOAT\n        float  NoVClearCoat;\n        float3 probeReflectanceClearCoat;\n#endif\n    } pbr;\n#endif\n    \n    VFXShaderLightingContribution(thread VFXShaderSurface& iSurface, commonprofile_io io):surface(iSurface)\n#ifdef USE_PER_VERTEX_LIGHTING\n    ,out(io)\n#else\n    ,in(io)\n#endif\n    {\n        ambient = 0.f;\n        diffuse = 0.f;\n        specular = 0.f;\n#ifdef USE_SHADOWONLY\n        shadowFactor = 1.f;\n#endif\n\n#if PROBES_NORMALIZATION\n#if PROBES_OUTER_BLENDING\n        probesWeightedSum = float4(0.f);\n#else\n        probesWeightedSum = float4(0.f, 0.f, 0.f, 0.000001f); \n#endif\n#else\n        probeRadianceRemainingFactor = 1.f;\n#endif\n\n#ifdef USE_MODULATE\n        modulate = 1.f;\n#else\n        modulate = 0.f;\n#endif\n    }\n\n#ifdef USE_PBR\n    void prepareForPBR(texture2d<float, access::sample> specularDFGDiffuseHammonTexture, float occ)\n    {\n        pbr.envDiffuse = 0.f;\n        pbr.envSpecular = 0.f;\n        pbr.selfIlluminationOcclusion = occ;\n      \n        pbr.albedo = surface.diffuse.rgb;\n#ifdef USE_PBR_TRANSPARENCY\n  #ifdef DIFFUSE_PREMULTIPLIED\n        \n        pbr.transparency = 1.f;\n  #else\n        pbr.transparency = surface.diffuse.a;\n  #endif\n  #ifdef USE_TRANSPARENCY\n    #ifdef USE_PER_VERTEX_LIGHTING\n        pbr.transparency *= out.transparency;\n    #else\n        pbr.transparency *= in.transparency;\n    #endif\n  #endif\n  #ifdef USE_TRANSPARENT\n        pbr.transparency *= surface.transparent.a;\n  #endif\n        pbr.albedo *= pbr.transparency;\n  #ifdef DIFFUSE_PREMULTIPLIED\n        \n        \n        pbr.transparency *= surface.diffuse.a;\n  #endif\n#endif\n        \n        float3 n = surface.normal;\n        float3 v = surface.view;\n        pbr.NoV = abs(dot(n, v));\n        \n        float roughness = surface.roughness;\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        float2 specularDFG = specularDFGDiffuseHammonTexture.sample(vfx_lighting::linearSampler, float2(pbr.NoV, roughness)).rg;\n#else\n#ifdef USE_RE_RADIANCE_IRRADIANCE_MAP_SAMPLING\n        float4 env = specularDFGDiffuseHammonTexture.sample(vfx_lighting::linearSampler, float2(roughness, 1.0f - pbr.NoV));\n#else\n        float4 env = specularDFGDiffuseHammonTexture.sample(vfx_lighting::linearSampler, float2(pbr.NoV, roughness));\n#endif\n        float2 specularDFG = env.xy;\n        pbr.diffuseHammonFactors = env.zw;\n#endif\n        \n        pbr.reflectance = mix(PBR_F0_NON_METALLIC, pbr.albedo, surface.metalness);\n        pbr.probeReflectance = pbr.reflectance * specularDFG.r + specularDFG.g;\n                                \n#ifdef USE_CLEARCOAT\n        pbr.NoVClearCoat = abs(dot(surface.clearCoatNormal, v));\n        float2 DFGClearCoat = specularDFGDiffuseHammonTexture.sample(vfx_lighting::linearSampler, float2(pbr.NoVClearCoat, surface.clearCoatRoughness)).rg;\n        pbr.probeReflectanceClearCoat = 0.04 * DFGClearCoat.r + DFGClearCoat.g;\n#endif\n    }\n#endif\n\n\n#ifdef USE_LIGHT_MODIFIER\n    __LightModifierExtraDecl__\n#endif\n\n    float4 debug_pixel(float2 fragmentPosition)\n    {\n        const int width = 64;\n        switch (int(fragmentPosition.x + fragmentPosition.y ) / width) {\n            case 0: return float4(surface.view, 1.f);\n            case 1: return float4(surface.position, 1.f);\n            case 2: return float4(surface.normal, 1.f);\n            case 3: return float4(surface.geometryNormal, 1.f);\n            case 4: return float4(float3(surface.ambientOcclusion), 1.f);\n            case 5: return surface.diffuse;\n            case 6: return float4(float3(surface.metalness), 1.f);\n            case 7: return float4(float3(surface.roughness), 1.f);\n            case 8: return float4(ambient, 1.f);\n            case 9: return float4(diffuse, 1.f);\n            default: return float4(specular, 1.f);\n        }\n    }\n\n    \n\n    static inline float3 lambert_diffuse(float3 l, float3 n, float3 color, float intensity) {\n        return color * (intensity * saturate(dot(n, l)));\n    }\n\n    void phong(float3 l, float3 color, float intensity)\n    {\n        float3 D = lambert_diffuse(l, surface.normal, color, intensity);\n        diffuse += D;\n\n        float3 r = reflect(-l, surface.normal);\n        specular += powr(saturate(dot(r, surface.view)), surface.shininess) * D;\n    }\n\n#ifdef USE_PBR\n    void physicallyBased(float3 l, float3 color, float intensity)\n    {\n        float3 n         = surface.normal;\n        float3 v         = surface.view;\n        float  roughness = surface.roughness;\n        float  alpha     = roughness * roughness;\n\n        float3 h = normalize(l + v);\n\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n        \n        float D   = vfx_brdf_D(alpha, NoH);\n        float3 F  = vfx_brdf_F_opt(pbr.reflectance, LoH);\n        float Vis = vfx_brdf_V(alpha, NoL, pbr.NoV);\n\n        \n        diffuse  += color * (NoL * M_1_PI_F * intensity);\n        specular += color * F * (NoL * D * Vis * intensity);\n        \n        #ifdef USE_CLEARCOAT\n            n = surface.clearCoatNormal;\n\n            roughness = max(surface.clearCoatRoughness, 0.089f);\n            alpha = roughness * roughness; \n        \n            \n            \n            float NoH_coat = saturate(dot(n, h));\n            float NoL_coat = saturate(dot(n, l));\n            D   = vfx_brdf_D(alpha, NoH_coat);\n            F   = vfx_brdf_F_opt(0.04, LoH) * surface.clearCoat;\n            Vis = vfx_brdf_V(alpha, NoL_coat, saturate(dot(n,v)));\n        \n            float attenuation = 1.0 - F.r;\n            specular *=  (attenuation * attenuation);\n            specular += color * F * ( NoL_coat * D * Vis * intensity);\n        #endif\n    }\n#endif\n\n    void custom(float3 _l, float3 _color, float _intensity)\n    {\n#ifdef USE_LIGHT_MODIFIER\n        thread VFXShaderLightingContribution &_lightingContribution = *this;\n        thread VFXShaderSurface& _surface = surface;\n        VFXShaderLight _light = {.direction = _l, .intensity = float4(_color, 1.f), ._att = _intensity };\n        \n        __DoLightModifier__\n        \n#endif\n    }\n\n    void shade(float3 l, float3 color, float intensity)\n    {\n#ifdef LIGHTING_MODEL\n        switch (LIGHTING_MODEL) {\n#ifdef USE_SHADOWONLY\n            case VFXShadingModelShadowOnly:      shadowFactor *= intensity; break;\n#endif\n            case VFXShadingModelPhong:           phong(l, color, intensity); break;\n#ifdef USE_PBR\n            case VFXShadingModelPhysicallyBased: physicallyBased(l, color, intensity); break;\n#endif\n            case VFXShadingModelCustom:          custom(l, color, intensity); break;\n            default:  break; \n        }\n#endif\n    }\n\n    \n    \n    \n    float pbr_dist_attenuation_alternate(float3 l, float cutoff) {\n        \n        float radius = 0.1f; \n        float factor = 1.f / (1.f + length(l)/radius);\n        float attenuation = saturate(factor * factor); \n        return saturate((attenuation - cutoff) / (1.f - cutoff));\n    }\n\n    float pbr_dist_attenuation(float3 l, float inv_square_radius) {\n        float sqr_dist = length_squared(l);\n        float atten = 1.f / max(sqr_dist, 0.0001f);\n\n        \n        float factor = saturate(1.f - vfx::sq(sqr_dist * inv_square_radius));\n        return atten * factor * factor;\n    }\n\n    float non_pbr_dist_attenuation(float3 l, float4 att)\n    {\n        return powr(saturate(length(l) * att.x + att.y), att.z);\n    }\n\n    float dist_attenuation(float3 unnormalized_l, vfx_light light)\n    {\n#ifdef USE_PBR\n        return pbr_dist_attenuation(unnormalized_l, light.parameters.omni.attenuationFactors.w);\n        \n        \n#else\n#ifdef USE_SHADOWONLY\n        return 1.f;\n#endif\n        return non_pbr_dist_attenuation(unnormalized_l, light.parameters.omni.attenuationFactors);\n#endif\n    }\n\n    float spot_attenuation(float3 l, vfx_light light)\n    {\n#ifdef USE_SHADOWONLY\n        return 1.f;\n#endif\n        \n        return saturate(dot(l, light.dir) * light.parameters.spot.scaleBias.x + light.parameters.spot.scaleBias.y);\n    }\n\n    void shade_modulate(float3 l, float4 color, float intensity)\n    {\n        constexpr half3 white = half3(1.h);\n        \n        modulate *= float3(mix(white, half3(color.rgb), half(color.a * intensity)));\n    }\n\n    float3 gobo(float3 pos, vfx_light light, texture2d<half> goboTexture, sampler goboSampler)\n    {\n        half3 g = texture2DProj(goboTexture, goboSampler, (light.shadowMatrix * float4(pos, 1.f))).rgb;\n        return light.color.rgb * float3(mix(1.h, g, half(light.color.a)));\n    }\n\n    float shadow(float3 pos, vfx_light light, depth2d<float> shadowMap)\n    {\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n        float4 tile = light.tiles[0];\n#else\n        float4 tile = {0.0, 0.0, 1.0, 1.0};\n#endif\n        float shadow = ComputeShadow(vfx_shadow_sampler, pos, light.shadowMatrix, shadowMap, tile);\n        return 1.f - shadow * light.color.a; \n    }\n\n    \n    float shadow(float3 pos, vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel)\n    {\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n        float4 tile = light.tiles[0];\n#else\n        float4 tile = {0.0, 0.0, 1.0, 1.0};\n#endif\n        float4 lightScreen = transformViewPosInShadowSpace(pos, light.shadowMatrix);\n        lightScreen.xyz /= lightScreen.w;\n        float shadow = ComputeSoftShadow(vfx_shadow_sampler, lightScreen.xyz, shadowMap, shadowKernel, light.shadowSampleCount, light.shadowRadius, tile);\n        return 1.f - shadow * light.color.a; \n    }\n\n    float shadow(float3 pos, vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int shadowSampleCount)\n    {\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n        float4 tile = light.tiles[0];\n#else\n        float4 tile = {0.0, 0.0, 1.0, 1.0};\n#endif\n        float4 lightScreen = transformViewPosInShadowSpace(pos, light.shadowMatrix);\n        lightScreen.xyz /= lightScreen.w;\n        float shadow = ComputeSoftShadow(vfx_shadow_sampler, lightScreen.xyz, shadowMap, shadowKernel, shadowSampleCount, light.shadowRadius, tile);\n        return 1.f - shadow * light.color.a; \n    }\n\n    float shadow(float3 pos, vfx_light light, depth2d<float> shadowMap, int shadowSampleCount)\n    {\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n        float4 tile = light.tiles[0];\n#else\n        float4 tile = {0.0, 0.0, 1.0, 1.0};\n#endif\n        float shadow = ComputeSoftShadowGrid(vfx_shadow_sampler, pos, light.shadowMatrix, shadowMap, shadowSampleCount, tile);\n        return 1.f - shadow * light.color.a; \n    }\n\n\nushort getCubeFace(float3 dir)\n{\n    \n    float3 absDir = abs(dir);\n    float maxAxis = max(absDir.x, max(absDir.y, absDir.z));\n    if (absDir.z == maxAxis) {\n        \n        return dir.z > 0.0f ? 4 : 5;\n    } else if (absDir.y == maxAxis) {\n        \n        return dir.y > 0.0f ? 2 : 3;\n    } else {\n        \n        \n        return dir.x > 0.0f ? 0 : 1;\n    }\n}\n\n\nfloat4x4 getFaceRotation(ushort face) {\n    float4 xAxis(1.0, 0.0, 0.0, 0.0);\n    float4 yAxis(0.0, 1.0, 0.0, 0.0);\n    float4 zAxis(0.0, 0.0, 1.0, 0.0);\n    float4 zero (0.0, 0.0, 0.0, 1.0);\n    switch (face) {\n        case 0: return float4x4(-zAxis, yAxis,  xAxis, zero); \n        case 1: return float4x4( zAxis, yAxis, -xAxis, zero); \n        case 2: return float4x4( xAxis,-zAxis,  yAxis, zero); \n        case 3: return float4x4( xAxis, zAxis, -yAxis, zero); \n        case 4: return float4x4(-xAxis, yAxis, -zAxis, zero); \n        default:  return float4x4( xAxis, yAxis,  zAxis, zero); \n    }\n}\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    float shadow_omni(float3 pos_vs, float3 nrm_vs, vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n#else\n    float shadow_omni(float3 pos_vs, float3 nrm_vs, vfx_light light, depthcube<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n#endif\n    {\n        \n#define USE_TANGENT_SAMPLING 0\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n        float  depthBias = light.parameters.omni.depthBias;\n#else\n        float2 scaleBias = light.parameters.omni.shadowScaleBias.xy;\n        float  depthBias = light.parameters.omni.shadowScaleBias.z;\n#endif\n\n        \n        pos_vs += nrm_vs * depthBias;\n\n        \n        float4 pos_ls = (light.shadowMatrix * float4(pos_vs, 1.f));\n\n#if !CFX_USE_ATLAS_FOR_SHADOW_MAP\n        \n        float z_lin = vfx::reduce_max(abs(pos_ls));\n\n        \n        \n        \n        \n        float z_ndc = (z_lin * scaleBias.x + scaleBias.y) / z_lin - depthBias;\n#endif\n\n        \n        float shadow;\n        if (sampleCount <= 1) {\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n            ushort face = getCubeFace(normalize(pos_ls.xyz));\n            float4 tile = light.tiles[face];\n            shadow = ComputeShadow(vfx_shadow_sampler, (getFaceRotation(face) * pos_ls).xyz, light.parameters.omni.projection, shadowMap, tile);\n#else\n            shadow = shadowMap.sample_compare(vfx_shadow_sampler, pos_ls.xyz, z_ndc);\n#endif\n        } else {\n\n            \n            float filteringSizeFactor = light.shadowRadius;\n\n#if USE_TANGENT_SAMPLING\n            float3 tgt_x, tgt_y;\n            vfx::orthogonal_basis(pos_ls, tgt_x, tgt_y);\n#else\n            float3 nrm_ls = (light.shadowMatrix * float4(nrm_vs, 0.f)).xyz;\n#endif\n\n            \n            float totalAccum = 0.0;\n            for(int i=0; i < sampleCount; i++){\n\n#if USE_TANGENT_SAMPLING\n                float2 scale = shadowKernel[i].xy * filteringSizeFactor * 2.f;\n                float3 smp_ls = pos_ls.xyz + tgt_x * scale.x + tgt_y * scale.y;\n#else\n                float3 smp_ls = pos_ls.xyz + vfx::randomHemisphereDir(nrm_ls, shadowKernel[i].xy * 0.5 + 0.5) * filteringSizeFactor;\n#endif\n\n                \n                \n                \n\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n                ushort face = getCubeFace(normalize(smp_ls.xyz));\n                float4 tile = light.tiles[face];\n                totalAccum += ComputeShadow(vfx_shadow_sampler, (getFaceRotation(face) * float4(smp_ls, 1.0)).xyz, light.parameters.omni.projection, shadowMap, tile);\n#else\n                totalAccum += shadowMap.sample_compare(vfx_shadow_sampler, smp_ls, z_ndc);\n#endif\n\n            }\n            shadow = totalAccum / float(sampleCount);\n        }\n\n        return 1.f - shadow * light.color.a; \n    }\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    float shadow(float3 pos, constant vfx_light& light, depth2d<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount)\n    {\n        float shadow = ComputeCascadedShadow(vfx_shadow_sampler, pos, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius, light.tiles).a;\n        return 1.f - shadow * light.color.a; \n    }\n#else\n    float shadow(float3 pos, constant vfx_light& light, depth2d_array<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount)\n    {\n        float shadow = ComputeCascadedShadow(vfx_shadow_sampler, pos, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius).a;\n        return 1.f - shadow * light.color.a; \n    }\n#endif\n\n    \n\n    void add_directional(vfx_light light)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n    void add_directional(vfx_light light, texture2d<half> goboTexture, sampler goboSampler)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n    void add_directional(vfx_light light, depth2d<float> shadowMap)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        intensity *= shadow(surface.position, light, shadowMap);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n    void add_directional(vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        intensity *= shadow(surface.position, light, shadowMap, shadowKernel);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    void add_directional(vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        intensity *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n    void add_directional(vfx_light light, depth2d<float> shadowMap, int sampleCount)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        intensity *= shadow(surface.position, light, shadowMap, sampleCount);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    void add_directional(constant vfx_light& light, depth2d<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount, bool debugCascades)\n#else\n    void add_directional(constant vfx_light& light, depth2d_array<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount, bool debugCascades)\n#endif\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        if (debugCascades) {\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n            float4 shadowDebug = ComputeCascadedShadow(vfx_shadow_sampler, surface.position, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius, light.tiles);\n#else\n            float4 shadowDebug = ComputeCascadedShadow(vfx_shadow_sampler, surface.position, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius);\n#endif\n            intensity *= (1.f - shadowDebug.a);\n            shade(light.dir, light.color.rgb, intensity);\n            diffuse.rgb = mix(diffuse.rgb, shadowDebug.rgb, light.color.a);\n        } else {\n            intensity *= shadow(surface.position, light, shadowMaps, cascadeCount, blendCascade, shadowKernel, sampleCount);\n            shade(light.dir, light.color.rgb, intensity);\n        }\n    }\n\n    \n\n    void add_omni(vfx_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        shade(l, light.color.rgb, dist_attenuation(unnormalized_l, light) * BoostFactor);\n    }\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    void add_omni(vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n#else\n    void add_omni(vfx_light light, depthcube<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n#endif\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light) * BoostFactor;\n        intensity *= shadow_omni(surface.position, surface.normal, light, shadowMap, shadowKernel, sampleCount);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    void add_local_omni(vfx_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        shade(l, light.color.rgb, dist_attenuation(unnormalized_l, light) * BoostFactor);\n    }\n\n    \n\n    void add_spot(vfx_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light) * BoostFactor;\n        intensity      *= spot_attenuation(l, light);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    void add_spot(vfx_light light, texture2d<half> goboTexture, sampler goboSampler)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light) * BoostFactor;\n        intensity      *= spot_attenuation(l, light);\n        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);\n\n        \n        \n        \n              shade(l, light.color.rgb, intensity);\n        \n    }\n\n    void add_local_spot(vfx_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light) * BoostFactor;\n        intensity      *= spot_attenuation(l, light);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    \n    void add_spot(vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light) * BoostFactor;;\n        intensity      *= spot_attenuation(l, light);\n        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        shade(l, light.color.rgb, intensity);\n    }\n    \n    void add_spot(vfx_light light, \n                  depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount,\n                  texture2d<half> goboTexture, sampler goboSampler)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= spot_attenuation(l, light);\n        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    \n\n#ifdef USE_PBR\n\n    \n\n#ifdef CFX_SUPPORT_CUBE_ARRAY\n    void add_local_probe(vfx_light light, texturecube_array<half> probeTextureArray)\n#else\n    void add_local_probe(vfx_light light, texture2d_array<half> probeTextureArray)\n#endif\n    {\n#if !PROBES_NORMALIZATION\n        if (probeRadianceRemainingFactor <= 0.f)\n            return;\n#endif\n\n        bool parallaxCorrection = light.parameters.probe.parallaxCorrection;\n        int    probeIndex       = light.parameters.probe.index;\n        float3 probeExtents     = light.parameters.probe.halfExtents.xyz;\n        float  blendDist        = light.parameters.probe.halfExtents.w;\n        float3 probeOffset      = light.parameters.probe.offset;\n        float3 parallaxExtents  = light.parameters.probe.parallaxExtents;\n        float3 parallaxCenter   = light.parameters.probe.parallaxCenter;\n\n        float3 n = surface.normal;\n        float3 v = surface.view;\n        float3 r = reflect(-v, n); \n\n        float3 specDir = vfx::mat4_mult_float3(light.shadowMatrix, r);\n\n        \n        float3 pos_ls = (light.shadowMatrix * float4(surface.position, 1.f)).xyz;\n\n        \n        float3 d = abs(pos_ls) - probeExtents;\n#if PROBES_OUTER_BLENDING\n        if (any(d > blendDist))\n#else\n        if (any(d > 0.f))\n#endif\n        {\n            return;\n        }\n\n#if PROBES_NORMALIZATION\n        \n        \n#if PROBES_OUTER_BLENDING\n        float3 nd = saturate(-(d / blendDist) * 0.5f + 0.5f);\n#else\n        float3 nd = saturate(-(d / blendDist));\n#endif\n        float probeFactor = (nd.x * nd.y * nd.z) * light.color.r;\n#else\n        \n        float sd = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n#if PROBES_OUTER_BLENDING\n        float probeFactor = saturate(1.f - sd / blendDist);\n#else\n        float probeFactor = saturate(-sd / blendDist);\n#endif\n        \n        \n        \n        probeFactor *= probeRadianceRemainingFactor * light.color.r; \n#endif\n\n        if (parallaxCorrection ) {\n            \n            float3 pos_off = pos_ls + parallaxCenter;\n            float3 t1 = ( parallaxExtents - pos_off) / specDir;\n            float3 t2 = (-parallaxExtents - pos_off) / specDir;\n            float3 tmax = max(max(0, t1), t2); \n            float t = min(tmax.x, min(tmax.y, tmax.z));\n\n            \n            float3 hit_ls = pos_ls + specDir * t;\n            specDir = hit_ls - probeOffset;\n        }\n\n        \n        specDir.z *= -1.0;\n        \n        \n        \n        float ao = surface.ambientOcclusion;\n#ifdef USE_BENTNORMALS\n        ao = mix(mix(max(dot(surface.bentNormal, r), 0.), 1., ao), ao, surface.roughness*surface.roughness);\n#endif\n        \n        float mipd = float(probeTextureArray.get_num_mip_levels()) - 1.f;\n        const float intensity = ao * probeFactor;\n\n        float mips = surface.roughness * mipd;\n#ifdef CFX_SUPPORT_CUBE_ARRAY\n        float3 LD = float3(probeTextureArray.sample(vfx_lighting::linearSampler, specDir, probeIndex, level(mips)).rgb);\n#else\n        float2 specUV = vfx::dual_paraboloid_from_cartesian(normalize(specDir));\n        float3 LD = float3(probeTextureArray.sample(vfx_lighting::linearSampler, specUV, probeIndex, level(mips)).rgb);\n#endif\n\n        \n\n        \n#if PROBES_NORMALIZATION\n        probesWeightedSum += float4(LD * intensity * pbr.probeReflectance, probeFactor);\n#else\n        probeRadianceRemainingFactor = saturate(probeRadianceRemainingFactor - probeFactor);\n#ifdef DISABLE_SPECULAR\n        pbr.envDiffuse += LD * intensity * pbr.probeReflectance;\n#else\n        pbr.envSpecular += LD * intensity * pbr.probeReflectance;\n#endif\n#endif\n        \n#ifdef USE_CLEARCOAT\n        n = surface.clearCoatNormal;\n        r = reflect(-v, n);\n        specDir = vfx::mat4_mult_float3(light.shadowMatrix, r);\n        \n        specDir.z *= -1.0;\n        if (parallaxCorrection ) {\n            float3 pos_off = pos_ls + parallaxCenter;\n            \n            float3 t1 = ( parallaxExtents - pos_off) / specDir;\n            float3 t2 = (-parallaxExtents - pos_off) / specDir;\n            float3 tmax = max(max(0, t1), t2); \n            float t = min(tmax.x, min(tmax.y, tmax.z));\n            \n            \n            float3 hit_ls = pos_ls + specDir * t;\n            specDir = hit_ls - probeOffset;\n        }\n        mips = surface.clearCoatRoughness * mipd;\n#ifdef CFX_SUPPORT_CUBE_ARRAY\n        LD = float3(probeTextureArray.sample(vfx_lighting::linearSampler, specDir, probeIndex, level(mips)).rgb);\n#else\n        specUV = vfx::dual_paraboloid_from_cartesian(normalize(specDir));\n        LD = float3(probeTextureArray.sample(vfx_lighting::linearSampler, specUV, probeIndex, level(mips)).rgb);\n#endif\n#if PROBES_NORMALIZATION\n        probesWeightedSum += float4(LD * intensity * pbr.probeReflectanceClearCoat, probeFactor) * surface.clearCoat;\n#else\n\n#ifdef DISABLE_SPECULAR\n        pbr.envDiffuse += LD * intensity * pbr.probeReflectanceClearCoat  * surface.clearCoat;\n#else\n        specular += LD * intensity * pbr.probeReflectanceClearCoat  * surface.clearCoat;\n#endif\n#endif\n#endif\n    }\n\n    void add_global_probe(float4x4 localDirToWorldCubemapDir,\n                          float environmentIntensity,\n#ifdef CFX_SUPPORT_CUBE_ARRAY\n                          texturecube_array<half> probeTextureArray\n#else\n                          texture2d_array<half> probeTextureArray\n#endif\n                          )\n    {\n        float3 n = surface.normal;\n        float3 v = surface.view;\n        float3 r = reflect(-v, n); \n        \n        float3 specDir = vfx::mat4_mult_float3(localDirToWorldCubemapDir, r);\n        float mips = surface.roughness * float(probeTextureArray.get_num_mip_levels() - 1);\n        \n#ifdef CFX_SUPPORT_CUBE_ARRAY\n        float3 LD = float3(probeTextureArray.sample(vfx_lighting::linearSampler, specDir, 0, level(mips)).rgb);\n#else\n        float2 specUV = vfx::dual_paraboloid_from_cartesian(normalize(specDir));\n        float3 LD = float3(probeTextureArray.sample(vfx_lighting::linearSampler, specUV, 0, level(mips)).rgb);\n#endif\n        \n        \n        specular += pbr.probeReflectance * LD * surface.ambientOcclusion * environmentIntensity;\n    }\n\n    void add_global_probe(texturecube<float, access::sample> specularLD,\n                          float4x4                           localDirToWorldCubemapDir,\n                          float                              environmentIntensity)\n    {\n        float3 n        = surface.normal;\n        float3 v        = surface.view;\n        float3 r        = reflect(-v, n); \n        float roughness = surface.roughness;\n\n#if USE_PBR_DOMINANT_DIRECTION\n        float alpha = roughness * roughness;\n        float smoothness = 1.0f - alpha;\n        \n        float specularLerpFactor = (1. - smoothness * (sqrt(smoothness) + alpha));\n        \n        float3 specularDominantNDirection = mix(r, n, specularLerpFactor); \n#else\n        float3 specularDominantNDirection = r;\n#endif\n        \n        float ao = surface.ambientOcclusion;\n        \n        \n        \n#ifdef USE_BENTNORMALS\n        ao = mix(mix(max(dot(surface.bentNormal, r), 0.), 1., ao), ao, roughness*roughness);\n#endif\n        \n        \n#ifdef USE_RE_RADIANCE_IRRADIANCE_MAP_SAMPLING\n        float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);\n#else\n        float mipLevel = sqrt(roughness) * float(specularLD.get_num_mip_levels() - 1);\n#endif\n        float3 dir = vfx::mat4_mult_float3(localDirToWorldCubemapDir, specularDominantNDirection);\n        float3 LD = specularLD.sample(vfx_lighting::linearSampler, dir, level(mipLevel)).rgb;\n        pbr.envSpecular += pbr.probeReflectance * LD * ao * environmentIntensity;\n    }\n\n#ifdef USE_CLEARCOAT\n    void add_global_probeClearCoat(texturecube<float, access::sample> specularLD,\n                          float4x4                           localDirToWorldCubemapDir,\n                          float                              environmentIntensity)\n    {\n        float3 n = surface.clearCoatNormal;\n        \n        float3 v        = surface.view;\n        float3 r        = reflect(-v, n); \n        float roughness = surface.clearCoatRoughness;\n\n        \n        \n        float ao = surface.ambientOcclusion;\n        \n        \n#ifdef USE_BENTNORMALS\n        ao = mix(mix(max(dot(surface.bentNormal, r), 0.), 1., ao), ao, roughness*roughness);\n#endif\n        \n        \n        float mipLevel = sqrt(roughness) * float(specularLD.get_num_mip_levels() - 1);\n        float3 LD = specularLD.sample(vfx_lighting::linearSampler, vfx::mat4_mult_float3(localDirToWorldCubemapDir, r), level(mipLevel)).rgb;\n\n        \n        float Fc = vfx_brdf_F_opt(0.04f, pbr.NoVClearCoat).r * surface.clearCoat;\n        float attenuation = 1.0f - Fc;\n        specular *= (attenuation * attenuation);\n        \n        specular += pbr.probeReflectanceClearCoat * LD  * surface.clearCoat * ao * environmentIntensity;\n    }\n#endif\n    \n    \n\n    void add_irradiance_from_selfIllum()\n    {\n        float selfIlluminationAO = saturate(mix(1.f, surface.ambientOcclusion, pbr.selfIlluminationOcclusion));\n        float3 irradiance = surface.selfIllumination.rgb;\n        \n        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        pbr.envDiffuse += selfIlluminationAO * irradiance * diffuseAlbedo;\n#else\n        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);\n        pbr.envDiffuse += selfIlluminationAO * irradiance * diffuseReflectance;\n#endif\n    }\n\n    void add_global_irradiance_from_sh(float4x4         localDirToWorldCubemapDir,\n#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)\n                                       sh2_coefficients shCoefficients)\n#else\n    sh3_coefficients shCoefficients)\n#endif\n    {\n#ifdef USE_BENTNORMALS\n        float3 n = surface.bentNormal;\n        float ao = surface.aoDirectionnal;\n#else\n        float3 n = surface.normal;\n        float ao = surface.ambientOcclusion;\n#endif\n        float3 n_sh_space = vfx::mat4_mult_float3(localDirToWorldCubemapDir, n);\n        float3 irradiance = shEvalDirection(float4(n_sh_space.xy, -n_sh_space.z, 1.), shCoefficients);\n        \n        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        pbr.envDiffuse += ao * irradiance * diffuseAlbedo;\n#else\n        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);\n        pbr.envDiffuse += ao * irradiance * diffuseReflectance;\n#endif\n    }\n\n    void add_global_irradiance_probe(texturecube<float, access::sample> irradianceTexture,\n                                     float4x4                           localDirToWorldCubemapDir,\n                                     float                              environmentIntensity)\n    {\n#if USE_PBR_DOMINANT_DIRECTION\n#ifdef USE_BENTNORMALS\n        float3 n = surface.bentNormal;\n        float ao = surface.aoDirectionnal;\n#else\n        float3 n = surface.normal;\n        float ao = surface.ambientOcclusion;\n#endif\n        float3 v = surface.view;\n        \n        \n        const half a = 1.02341h * surface.roughness - 1.51174h; \n        const half b = -0.511705h * surface.roughness + 0.755868h;\n        const half diffuseBendFactor = saturate((pbr.NoV * a + b) * surface.roughness);\n        float3 diffuseDominantNDirection = mix(n, v, diffuseBendFactor);\n#else\n        float3 diffuseDominantNDirection = n;\n#endif\n        \n        float3 n_cube_space = vfx::mat4_mult_float3(localDirToWorldCubemapDir, diffuseDominantNDirection);\n        float3 irradiance = irradianceTexture.sample(vfx_lighting::linearSampler, n_cube_space).rgb;\n        \n        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);\n        \n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        pbr.envDiffuse += (ao * environmentIntensity) * irradiance * diffuseAlbedo;\n#else\n        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);\n        pbr.envDiffuse += (ao * environmentIntensity) * irradiance * diffuseReflectance;\n#endif\n    }\n\n#endif \n\n    \n\n    static constexpr sampler iesSampler = sampler(filter::linear, mip_filter::none, address::clamp_to_edge);\n    \n    float ies_attenuation(float3 l, vfx_light light, texture2d<half> iesTexture)\n    {\n#if USE_QUAT_FOR_IES\n        float3 v    = vfx::quaternion_rotate_vector(light.parameters.ies.light_from_view_quat, -l);\n#else\n        float3 v    = vfx::matrix_rotate(light.parameters.ies.light_from_view, -l);\n#endif\n        float phi   = (v.z * light.parameters.ies.scaleBias.x + light.parameters.ies.scaleBias.y);\n        float theta = atan2(v.y, v.x) * 0.5f * M_1_PI_F;\n        return iesTexture.sample(iesSampler, float2(phi, abs(theta))).r;\n    }\n\n    void add_ies(vfx_light light, texture2d<half> iesTexture)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= ies_attenuation(l, light, iesTexture);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    void add_ies(vfx_light light, texture2d<half> iesTexture, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= ies_attenuation(l, light, iesTexture);\n        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    \n\n    void add_area_rectangle(vfx_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n        float3 v = surface.view;\n        float3 n = surface.normal;\n        float3 p = surface.position;\n\n        \n        float3 tangent = normalize(v - n * dot(v, n));\n        float3 bitangent = cross(n, tangent);\n        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));\n\n        float3 lightCenter = light.shadowMatrix[3].xyz;\n        \n        \n        float sidedness = dot(light.dir, lightCenter - p);\n        if (light.parameters.area.rectangle.doubleSided == false && sidedness <= 0.f)\n            return;\n        \n        float3 lightRight = light.shadowMatrix[0].xyz * light.parameters.area.rectangle.halfExtents.x * sign(sidedness);\n        float3 lightTop   = light.shadowMatrix[1].xyz * light.parameters.area.rectangle.halfExtents.y;\n        \n        float4x3 cornerDirections = float4x3((lightCenter + lightRight + lightTop) - p,\n                                             (lightCenter + lightRight - lightTop) - p,\n                                             (lightCenter - lightRight - lightTop) - p,\n                                             (lightCenter - lightRight + lightTop) - p);\n\n        cornerDirections[0] = shadingSpaceTransform * cornerDirections[0];\n        cornerDirections[1] = shadingSpaceTransform * cornerDirections[1];\n        cornerDirections[2] = shadingSpaceTransform * cornerDirections[2];\n        cornerDirections[3] = shadingSpaceTransform * cornerDirections[3];\n\n        float diffuseAmount = pbr_area_light_eval_rectangle(cornerDirections);\n\n        float brdfNorm = 1.f;\n        float3x3 inverseLTCMatrix = vfx_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);\n\n        cornerDirections[0] = inverseLTCMatrix * cornerDirections[0];\n        cornerDirections[1] = inverseLTCMatrix * cornerDirections[1];\n        cornerDirections[2] = inverseLTCMatrix * cornerDirections[2];\n        cornerDirections[3] = inverseLTCMatrix * cornerDirections[3];\n\n        float specularAmount = brdfNorm * pbr_area_light_eval_rectangle(cornerDirections);\n\n        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); \n        \n        float3 lightColor = light.color.rgb;\n        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;\n        specular += specularAmount * lightColor * pbr.reflectance;\n#endif\n    }\n\n    void add_area_polygon(vfx_light light, texture2d_array<float> bakedDataTexture, device packed_float2 *vertexPositions)\n    {\n#ifdef USE_PBR\n        float3 v = surface.view;\n        float3 n = surface.normal;\n        float3 p = surface.position;\n\n        \n        float3 tangent = normalize(v - n * dot(v, n));\n        float3 bitangent = cross(n, tangent);\n        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));\n\n        float3 lightCenter = light.shadowMatrix[3].xyz;\n        \n        \n        float sidedness = dot(light.dir, lightCenter - p);\n        if (light.parameters.area.polygon.doubleSided == false && sidedness <= 0.f)\n            return;\n        \n        float3 lightRight = light.shadowMatrix[0].xyz * sign(sidedness);\n        float3 lightTop   = light.shadowMatrix[1].xyz;\n\n        p           = shadingSpaceTransform * p;\n        lightCenter = shadingSpaceTransform * lightCenter;\n        lightRight  = shadingSpaceTransform * lightRight;\n        lightTop    = shadingSpaceTransform * lightTop;\n\n        float diffuseAmount = pbr_area_light_eval_polygon(p, lightCenter, lightRight, lightTop, light.parameters.area.polygon.vertexCount, vertexPositions);\n\n        float brdfNorm = 1.f;\n        float3x3 inverseLTCMatrix = vfx_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);\n\n        p           = inverseLTCMatrix * p;\n        lightCenter = inverseLTCMatrix * lightCenter;\n        lightRight  = inverseLTCMatrix * lightRight;\n        lightTop    = inverseLTCMatrix * lightTop;\n\n        float specularAmount = brdfNorm * pbr_area_light_eval_polygon(p, lightCenter, lightRight, lightTop, light.parameters.area.polygon.vertexCount, vertexPositions);\n        \n        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); \n\n        float3 lightColor = light.color.rgb;\n        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;\n        specular += specularAmount * lightColor * pbr.reflectance;\n#endif\n    }\n\n    void add_area_line(vfx_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n        float3 v = surface.view;\n        float3 n = surface.normal;\n        float3 p = surface.position;\n\n        \n        float3 tangent = normalize(v - n * dot(v, n));\n        float3 bitangent = cross(n, tangent);\n        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));\n\n        float3 lightCenter = light.shadowMatrix[3].xyz;\n        float3 lightRight  = light.shadowMatrix[0].xyz * light.parameters.area.line.halfLength;\n\n        float2x3 cornerDirections = float2x3((lightCenter + lightRight) - p,\n                                             (lightCenter - lightRight) - p);\n\n        cornerDirections[0] = shadingSpaceTransform * cornerDirections[0];\n        cornerDirections[1] = shadingSpaceTransform * cornerDirections[1];\n\n        float diffuseAmount = pbr_area_light_eval_line(cornerDirections);\n\n        float brdfNorm = 1.f;\n        float3x3 inverseLTCMatrix = vfx_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);\n\n        cornerDirections[0] = inverseLTCMatrix * cornerDirections[0];\n        cornerDirections[1] = inverseLTCMatrix * cornerDirections[1];\n\n        float specularAmount = brdfNorm * pbr_area_light_eval_line(cornerDirections);\n\n        float3 ortho = normalize(cross(cornerDirections[0], cornerDirections[1]));\n        float ltcWidthFactor = 1.0 / length(vfx_ltc_matrix_invert_transpose(inverseLTCMatrix) * ortho);\n        specularAmount *= ltcWidthFactor;\n        \n        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); \n\n        float3 lightColor = light.color.rgb;\n        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;\n        specular += specularAmount * lightColor * pbr.reflectance;\n#endif\n    }\n\n    void add_area_ellipse(vfx_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n#endif\n    }\n\n    void add_area_ellipsoid(vfx_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n#endif\n    }\n};\n\n#endif \n"
+ "#endif // USE_LINKED_FUNCTIONS"
+ "#if USE_LINKED_FUNCTIONS"
+ "#ifndef __VFXMetalDefines__\n#define __VFXMetalDefines__\n\nenum {\n    VFXVertexSemanticPosition,\n    VFXVertexSemanticNormal,\n    VFXVertexSemanticTangent,\n    VFXVertexSemanticColor,\n    VFXVertexSemanticBoneIndices,\n    VFXVertexSemanticBoneWeights,\n    VFXVertexSemanticTexcoord0,\n    VFXVertexSemanticTexcoord1,\n    VFXVertexSemanticTexcoord2,\n    VFXVertexSemanticTexcoord3,\n    VFXVertexSemanticTexcoord4,\n    VFXVertexSemanticTexcoord5,\n    VFXVertexSemanticTexcoord6,\n    VFXVertexSemanticTexcoord7\n};\n\nenum {\n    VFXGBufferAttachmentEmission,\n    VFXGBufferAttachmentNormal,\n    VFXGBufferAttachmentRoughnessMetalness,\n    VFXGBufferAttachmentAlbedo,\n    VFXGBufferAttachmentVelocity,\n    VFXGBufferAttachmentClearCoat,\n    VFXGBufferAttachmentSubsurface,\n    VFXGBufferAttachmentTransmission\n};\n\n\n\nstruct VFXWorldBuffer {\n    float4x4    viewTransform;\n    float4x4    inverseViewTransform; \n    float4x4    projectionTransform;\n    float4x4    viewProjectionTransform;\n    float4x4    viewToCubeTransform; \n    float4x4    lastFrameViewProjectionTransform;\n    float4      ambientLightingColor;\n    float4\t\tfogColor;\n    float3\t\tfogParameters; \n    float2      inverseResolution;\n    float       time;\n    float       timeFract;\n    float       deltaTime;\n    float       motionBlurIntensity;\n\n    float       environmentIntensity;\n    float4x4    environmentTransform;\n    float4x4    inverseProjectionTransform;\n    float4x4    inverseViewProjectionTransform;\n\n    float2      nearFar; \n    float4      viewportSize; \n\n    float4x4    inverseTransposeViewTransform;\n\n    \n    float4      clusterScale; \n    \n    uint32_t    frame;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#endif \n"
+ "#ifndef __VFX_RENDER_OPTIONS_H__\n#define __VFX_RENDER_OPTIONS_H__\n\n#ifndef VFX_ENUM \n#define VFX_ENUM(type) enum __attribute__((enum_extensibility(closed))) : type\n#endif\n\ntypedef VFX_ENUM(uint16_t) {\n    vfx_render_option_enable_clipping                             = (0x1 << 0),\n    vfx_render_option_enable_breakthrough                         = (0x1 << 1),\n    vfx_render_option_enable_dither_fade                          = (0x1 << 2),\n    vfx_render_option_enable_nearfield_vignetting                 = (0x1 << 3),\n    vfx_render_option_enable_portal_clipping                      = (0x1 << 4),\n    vfx_render_option_enable_depth_mitigation                     = (0x1 << 5),\n    vfx_render_option_render_for_blur                             = (0x1 << 6),\n    vfx_render_option_enable_spatial_focus                        = (0x1 << 7),\n    vfx_render_option_enable_visual_depth_static_occlusion        = (0x1 << 8),\n    vfx_render_option_enable_scene_understanding_static_occlusion = (0x1 << 9),\n} vfx_render_options;\n\nstatic inline uint16_t renderOptionsEnableClipping(uint16_t flags) {\n    return flags | vfx_render_option_enable_clipping;\n}\n\nstatic inline uint16_t renderOptionsEnableBreakthrough(uint16_t flags) {\n    return flags | vfx_render_option_enable_breakthrough;\n}\n\nstatic inline uint16_t renderOptionsEnableDitherFade(uint16_t flags) {\n    return flags | vfx_render_option_enable_dither_fade;\n}\n\nstatic inline uint16_t renderOptionsEnableNearfieldVignetting(uint16_t flags) {\n    return flags | vfx_render_option_enable_nearfield_vignetting;\n}\n\nstatic inline uint16_t renderOptionsEnablePortalClipping(uint16_t flags) {\n    return flags | vfx_render_option_enable_portal_clipping;\n}\n\nstatic inline uint16_t renderOptionsEnableDepthMitigation(uint16_t flags) {\n    return flags | vfx_render_option_enable_depth_mitigation;\n}\n\nstatic inline uint16_t renderOptionsRenderForBlur(uint16_t flags) {\n    return flags | vfx_render_option_render_for_blur;\n}\n\nstatic inline uint16_t renderOptionsEnableSpatialFocus(uint16_t flags) {\n    return flags | vfx_render_option_enable_spatial_focus;\n}\n\nstatic inline uint16_t renderOptionsEnableVisualDepthStaticOcclusion(uint16_t flags) {\n    return flags | vfx_render_option_enable_visual_depth_static_occlusion;\n}\n\nstatic inline uint16_t renderOptionsEnableSceneUnderstandingStaticOcclusion(uint16_t flags) {\n    return flags | vfx_render_option_enable_scene_understanding_static_occlusion;\n}\n\nstatic inline bool renderOptionsIsClippingEnabled(uint16_t flags) {\n    return (flags & vfx_render_option_enable_clipping) != 0;\n}\n\nstatic inline bool renderOptionsIsBreakthroughEnabled(uint16_t flags) {\n    return (flags & vfx_render_option_enable_breakthrough) != 0;\n}\n\nstatic inline bool renderOptionsIsNearfieldVignettingEnabled(uint16_t flags) {\n    return false;\n    return (flags & vfx_render_option_enable_nearfield_vignetting) != 0;\n}\n\nstatic inline bool renderOptionsIsDitherFadeEnabled(uint16_t flags) {\n    return (flags & vfx_render_option_enable_dither_fade) != 0;\n}\n\nstatic inline bool renderOptionsPortalClipPlaneEnabled(uint16_t flags) {\n    return (flags & vfx_render_option_enable_portal_clipping) != 0;\n}\n\nstatic inline bool renderOptionsIsDepthMitigationEnabled(uint16_t flags) {\n    return (flags & vfx_render_option_enable_depth_mitigation) != 0;\n}\n\nstatic inline bool renderOptionsIsSpatialFocusEnabled(uint16_t flags) {\n    return (flags & vfx_render_option_enable_spatial_focus) != 0;\n}\n\nstatic inline bool renderOptionsIsRenderingForBlur(uint16_t flags) {\n    return (flags & vfx_render_option_render_for_blur) != 0;\n}\n\nstatic inline bool renderOptionsIsVisualDepthStaticOcclusionEnabled(uint16_t flags) {\n    return (flags & vfx_render_option_enable_visual_depth_static_occlusion) != 0;\n}\n\nstatic inline bool renderOptionsIsSceneUnderstandingStaticOcclusionEnabled(uint16_t flags) {\n    return (flags & vfx_render_option_enable_scene_understanding_static_occlusion) != 0;\n}\n\n#ifdef __cplusplus\nstruct render_options_override {\n    uint16_t overrideBits = 0;\n    uint16_t overrideValues = 0;\n\n    void disableClipping() {\n        disable(vfx_render_option_enable_clipping);\n    }\n\n    void disableDitherFade() {\n        disable(vfx_render_option_enable_dither_fade);\n    }\n\n    void enableDitherFade() {\n        enable(vfx_render_option_enable_dither_fade);\n    }\n\n    void disableBreakthrough() {\n        disable(vfx_render_option_enable_breakthrough);\n    }\n\n    void enableNearFieldVignetting() {\n        enable(vfx_render_option_enable_nearfield_vignetting);\n    }\n\n    uint16_t applyOverrideOn(uint16_t optionFlags) const {\n        return (optionFlags | (overrideValues & overrideBits)) & (overrideValues | ~overrideBits);\n    }\n\n    void enable(uint16_t flag) {\n        overrideBits |= flag;\n        overrideValues |= flag;\n    }\n\n    void disable(uint16_t flag) {\n        overrideBits |= flag;\n        overrideValues &= ~flag;\n    }\n};\n#endif\n\n#endif \n"
+ "#ifndef __VFX_RE_SHADERS_H__\n#define __VFX_RE_SHADERS_H__\n\n#if IMPORT_IN_CFX_COMMON_PROFILE\nusing simd_float3x3 = metal::float3x3;\nusing simd_float3   = metal::float3;\n#endif\n\n#if VFX_USES_RE_SHADERS\n#   define VFX_RE_SHADERS_AVAILABLE 1\n#else\n#   define VFX_RE_SHADERS_AVAILABLE 0\n#endif \n\n#ifndef IMPORT_IN_CFX_COMMON_PROFILE\n#   define VFX_IMPORT_RE_SHADERS_ENGINE_CONSTANTS ( VFX_RE_SHADERS_AVAILABLE && __METAL_VERSION__ )\n#   define VFX_IMPORT_RE_SHADERS_SHARED_LIGHTING ( VFX_RE_SHADERS_AVAILABLE && __cplusplus )\n#   define VFX_IMPORT_RE_SHADERS_CLIPPING ( VFX_RE_SHADERS_AVAILABLE && __METAL_VERSION__ )\n#   define VFX_IMPORT_RE_SHADERS_SHARED_PROBES ( VFX_RE_SHADERS_AVAILABLE && __METAL_VERSION__ )\n#   define VFX_IMPORT_RE_SHADERS_SHARED_VIRTUAL_ENV_PROBES ( VFX_RE_SHADERS_AVAILABLE && __METAL_VERSION__ )\n#   define VFX_IMPORT_RE_SHADERS_SHARED_BREAKTHROUGH ( VFX_RE_SHADERS_AVAILABLE && __cplusplus )\n#endif \n\n#ifdef __METAL_VERSION__\n#   define vfx_half half\n#else\n#   define vfx_half uint16_t\n#endif\n\ntypedef struct\n{\n    uint16_t offset;\n    uint16_t count;\n} VFX_RE_C_ClippingIndexSlice;\n\ntypedef struct VFX_RE_C_ClippingConstants_s VFX_RE_C_ClippingConstants;\ntypedef struct VFX_RE_C_EntityConstants_s VFX_RE_C_EntityConstants;\ntypedef struct VFX_RE_C_ViewConstants_s VFX_RE_C_ViewConstants;\ntypedef struct VFX_RE_C_GlobalConstants_s VFX_RE_C_GlobalConstants;\n\n#if VFX_IMPORT_RE_SHADERS_ENGINE_CONSTANTS\nnamespace re {\n    struct ClippingConstants;\n    struct ClippingIndexSlice;\n    struct EntityConstants;\n    struct ViewConstants;\n    struct GlobalConstants;\n}\ntypedef re::ClippingConstants ClippingConstants;\ntypedef re::ClippingIndexSlice ClippingIndexSlice;\ntypedef re::EntityConstants EntityConstants;\ntypedef re::ViewConstants ViewConstants;\ntypedef re::GlobalConstants GlobalConstants;\n#else\ntypedef VFX_RE_C_ClippingConstants ClippingConstants;\ntypedef VFX_RE_C_ClippingIndexSlice ClippingIndexSlice;\ntypedef VFX_RE_C_EntityConstants EntityConstants;\ntypedef VFX_RE_C_ViewConstants ViewConstants;\ntypedef VFX_RE_C_GlobalConstants GlobalConstants;\n#endif \n\ntypedef struct VFX_RE_C_LightConstantBuffer_s VFX_RE_C_LightConstantBuffer;\ntypedef struct VFX_RE_C_IBLConstants_s\n{\n    simd_float3x3 rotation;\n    float intensityScale;\n    float mixFactor;\n    simd_float3 mixColor;\n    simd_float3x3 whitePointCorrection;\n    float wpcStrength;\n    \n    simd_float3x3 rotationBlend;\n    float blendFactor;\n    float postBlendSumFactor;\n} VFX_RE_C_IBLConstants;\n\n#if VFX_IMPORT_RE_SHADERS_SHARED_LIGHTING\nnamespace re {\n    struct LightConstantBuffer;\n    struct IBLConstants;\n}\ntypedef re::LightConstantBuffer LightConstantBuffer;\ntypedef re::IBLConstants IBLConstants;\n#else\ntypedef VFX_RE_C_LightConstantBuffer LightConstantBuffer;\ntypedef VFX_RE_C_IBLConstants IBLConstants;\n#endif \n\ntypedef struct VFX_RE_C_ProbeConstantBuffer_s VFX_RE_C_ProbeConstantBuffer;\n\n#if VFX_IMPORT_RE_SHADERS_SHARED_PROBES\nnamespace re {\n    struct ProbeConstantBuffer;\n}\ntypedef re::ProbeConstantBuffer ProbeConstantBuffer;\n#else\ntypedef VFX_RE_C_ProbeConstantBuffer ProbeConstantBuffer;\n#endif \n\n#  ifdef __cplusplus\nnamespace VirtualEnvironmentProbeLighting {\n    typedef struct VFX_RE_C_TextureArgumentBuffer_s VFX_RE_C_TextureArgumentBuffer;\n    typedef struct VFX_RE_C_ProbeConstantBuffer_s VFX_RE_C_ProbeConstantBuffer;\n}\n#  endif\n\n#if VFX_IMPORT_RE_SHADERS_SHARED_VIRTUAL_ENV_PROBES\nnamespace re { namespace VirtualEnvironmentProbeLighting {\n    struct TextureArgumentBuffer;\n    struct ProbeConstantBuffer;\n}}\nnamespace VirtualEnvironmentProbeLighting {\n    typedef re::VirtualEnvironmentProbeLighting::TextureArgumentBuffer TextureArgumentBuffer;\n    typedef re::VirtualEnvironmentProbeLighting::ProbeConstantBuffer ProbeConstantBuffer;\n}\n#else\n#  ifdef __cplusplus\nnamespace VirtualEnvironmentProbeLighting {\n    typedef VFX_RE_C_TextureArgumentBuffer TextureArgumentBuffer;\n    typedef VFX_RE_C_ProbeConstantBuffer ProbeConstantBuffer;\n}\n#  endif\n#endif \n\n#if VFX_IMPORT_RE_SHADERS_SHARED_BREAKTHROUGH\nnamespace re {\n    struct BreakthroughGPUData;\n}\ntypedef re::BreakthroughGPUData BreakthroughGPUData;\n#elif defined(__cplusplus)\nstruct BreakthroughGPUData;\n#endif \n\n#ifdef __cplusplus\nstruct re_entity_argument_buffer;\nstruct re_scene_argument_buffer;\nstruct re_vfx_object_constants;\n#endif\n\n#endif \n"
+ "#ifndef __VFX_RE_SHADERS_INTERNAL_H__\n#define __VFX_RE_SHADERS_INTERNAL_H__\n\n#import <simd/simd.h>\n#import <TargetConditionals.h>\n\n#ifdef __METAL_VERSION__\n#include <metal_texture>\n#endif\n\n#ifdef __OBJC__\n#   import <Foundation/Foundation.h>\n#endif \n\n#ifndef IMPORT_IN_CFX_COMMON_PROFILE\n#import \"vfx_re_shaders.h\"\n#endif\n\n#ifdef __cplusplus\n#   define VFX_RE_SHADERS_ALIGN_AS(n) alignas(n)\n#else\n#   define VFX_RE_SHADERS_ALIGN_AS(n) __attribute__((aligned(__alignof__(n))))\n#endif\n\n#define VFX_RE_SHADERS_ENUM(type) enum __attribute__((enum_extensibility(closed))) : type\n\n\n\n\n#if VFX_IMPORT_RE_SHADERS_ENGINE_CONSTANTS\n#   import \"REShaders/EngineConstants.h\"\n#endif\n\n#if defined(__OBJC__) && !defined(__cplusplus)\ntypedef NS_ENUM(int32_t, VFX_RE_C_ViewConstantsConstants)\n{\n    kViewConstantsArraySize = 2,\n};\n#elif __METAL_VERSION__\nconstant int kViewConstantsArraySize = 2;\n#else\nconstexpr int kViewConstantsArraySize = 2;\n#endif\n\ntypedef struct VFX_RE_SHADERS_ALIGN_AS(256) VFX_RE_C_InstanceConstants_s\n{\n    simd_float4x4 objectToCrWorld;\n    simd_float3x3 normalToCrWorld; \n    float povcControl; \n    float screenSpaceDepthBias;\n    uint userInstanceIndex;\n} VFX_RE_C_InstanceConstants;\n\ntypedef struct VFX_RE_SHADERS_ALIGN_AS(32) VFX_RE_C_EntityConstants_s\n{\n    uint lodDrawInfo;\n\n    \n    float fadeOpacity;\n\n    \n    float tintFactor;\n\n    uint debugMode;\n\n    ClippingIndexSlice clippingIndexSlice;\n    uint samplerIndexCount;  \n    float sfFactor;\n    uint instanceCount;\n\n    float fakeFresnelOpacityBasedBoostFactor;   \n    uint8_t btTextureReadIndex;\n    uint8_t stencilReferenceValue;\n    bool receivesIBLShadow;\n    \n    float environmentLightingWeight;\n\n    simd_float4 portalPlane;\n    simd_float4 dfColor;\n    simd_float4 dfColorStraight;\n\n    uint64_t entityIdentifier;\n    uint64_t meshPartIdentifier;\n\n    bool btUIBreakthroughEnabled;\n    vfx_half btUIBreakthroughInfluence;\n\n    \n    \n    float meshShadowIntensity;\n\n    uint16_t lightGroupIdentifier;\n\n    float depthMitigationTransitionFactor;\n    float sceneUnderstandingTransitionFactor;\n    float visualDepthStaticOcclusionTransitionFactor;\n    vfx_half invPortalLightBlendDistance;\n\n    \n    \n    \n    \n    \n    \n    \n    bool automaticallyInstanced;\n\n    vfx_half visualDepthStaticOcclusionDepthBias;\n} VFX_RE_C_EntityConstants;\n\ntypedef struct VFX_RE_SHADERS_ALIGN_AS(256) VFX_RE_C_ViewConstants_s\n{\n    simd_float4x4 crWorldToViewArray[kViewConstantsArraySize];\n    simd_float4x4 crWorldToPhysicalCameraArray[kViewConstantsArraySize];\n    simd_float4x4 crWorldToProjArray[kViewConstantsArraySize];\n    simd_float4x4 crWorldToHomographyArray[kViewConstantsArraySize];\n    simd_float4x4 viewToProjArray[kViewConstantsArraySize];\n    simd_float4x4 projToViewArray[kViewConstantsArraySize];\n    simd_float3 crwsCameraPositionArray[kViewConstantsArraySize]; \n    simd_float4 vrrMapPhysicalSizeArray[kViewConstantsArraySize];\n    simd_float4 viewportPercentsArray[kViewConstantsArraySize];\n\n    simd_float4 viewportPercents; \n    simd_float4 renderTargetSize; \n\n    simd_float4 vrrMapScreenSize;\n\n    simd_int4 renderTargetColorFormats;\n    simd_int2 renderTargetDepthStencilFormatSampleCount;\n\n    uint tonemapInPlace;\n    uint viewportCount;\n\n    uint useVertexAmplification;\n\n    float povcClipDistance; \n    uint cameraEye;\n    simd_float3 additiveTintColor;\n\n    vfx_half vignettingFadeoutDistanceNormalization;\n    vfx_half vignettingTotalFadeoutDistance;\n    simd_float3 vignettingPivotPosition;\n\n    simd_float4 portalClipPlane; \n} VFX_RE_C_ViewConstants;\n\ntypedef struct VFX_RE_SHADERS_ALIGN_AS(16) VFX_RE_C_GlobalConstants_s\n{\n    simd_float3 crwsReferencePosition; \n    float time;\n    uint frameCount;\n    simd_float4 dfColor; \n    simd_float4 dfColorStraight; \n} VFX_RE_C_GlobalConstants;\n\n#if VFX_IMPORT_RE_SHADERS_ENGINE_CONSTANTS\ntypedef re::ClippingIndexSlice ClippingIndexSlice;\ntypedef re::InstanceConstants InstanceConstants;\ntypedef re::EntityConstants EntityConstants;\ntypedef re::ViewConstants ViewConstants;\ntypedef re::GlobalConstants GlobalConstants;\n#else\ntypedef VFX_RE_C_ClippingIndexSlice ClippingIndexSlice;\ntypedef VFX_RE_C_InstanceConstants InstanceConstants;\ntypedef VFX_RE_C_EntityConstants EntityConstants;\ntypedef VFX_RE_C_ViewConstants ViewConstants;\ntypedef VFX_RE_C_GlobalConstants GlobalConstants;\n#endif \n\n#if VFX_IMPORT_RE_SHADERS_ENGINE_CONSTANTS && VFX_CHECK_RE_SHADERS_STRUCT_SIZE\nstatic_assert(sizeof(VFX_RE_C_ClippingIndexSlice) == sizeof(re::ClippingIndexSlice), \"vfx_re_shaders: struct size mismatch\");\nstatic_assert(sizeof(VFX_RE_C_InstanceConstants) == sizeof(re::InstanceConstants), \"vfx_re_shaders: struct size mismatch\");\nstatic_assert(sizeof(VFX_RE_C_EntityConstants) == sizeof(re::EntityConstants), \"vfx_re_shaders: struct size mismatch\");\nstatic_assert(sizeof(VFX_RE_C_ViewConstants) == sizeof(re::ViewConstants), \"vfx_re_shaders: struct size mismatch\");\nstatic_assert(sizeof(VFX_RE_C_GlobalConstants) == sizeof(re::GlobalConstants), \"vfx_re_shaders: struct size mismatch\");\n\nstatic_assert(alignof(VFX_RE_C_ClippingIndexSlice) == alignof(re::ClippingIndexSlice), \"vfx_re_shaders: struct alignof mismatch\");\nstatic_assert(alignof(VFX_RE_C_InstanceConstants) == alignof(re::InstanceConstants), \"vfx_re_shaders: struct alignof mismatch\");\nstatic_assert(alignof(VFX_RE_C_EntityConstants) == alignof(re::EntityConstants), \"vfx_re_shaders: struct alignof mismatch\");\nstatic_assert(alignof(VFX_RE_C_ViewConstants) == alignof(re::ViewConstants), \"vfx_re_shaders: struct alignof mismatch\");\nstatic_assert(alignof(VFX_RE_C_GlobalConstants) == alignof(re::GlobalConstants), \"vfx_re_shaders: struct alignof mismatch\");\n#endif \n\n\n\n\n\n#if VFX_IMPORT_RE_SHADERS_SHARED_LIGHTING\n#   import \"REShaders/SharedLighting.h\"\n#endif \n\n#define VFX_SUPPORTS_CASCADED_SHADOW_MAPS 0\n\n#if defined(__OBJC__) && !defined(__cplusplus)\ntypedef NS_ENUM(NSInteger, VFX_RE_C_MaxLightCounts)\n{\n    kVFXMaxLightCount = 8,\n    kVFXMaxDirectionalLightCount = 8,\n    kVFXMaxDirectionalUnshadowedLightCount = 8,\n    kVFXMaxPointLightCount = 1,\n    kVFXMaxPointUnshadowedLightCount = 8,\n    kVFXMaxSpotLightCount = 8,\n    kVFXMaxSpotUnshadowedLightCount = 8,\n    kVFXMaxAmbientLightCount = 8,\n    kVFXMaxRectangleUnshadowedLightCount = 8,\n    kVFXMaxRealWorldProxyLightCount = 1,\n    kVFXMaxSpotFilteredLightCount = 8,\n    kVFXMaxSpotFilteredUnshadowedLightCount = 8,\n    kVFXMaxPointFilteredLightCount = 1,\n    kVFXMaxPointFilteredUnshadowedLightCount = 8,\n#if VFX_SUPPORTS_CASCADED_SHADOW_MAPS\n    kVFXMaxCascadesPerLight = 3\n#else\n    kVFXMaxCascadesPerLight = 1\n#endif\n};\n#elif __METAL_VERSION__\nconstant int kVFXMaxLightCount = 8;\nconstant int kVFXMaxDirectionalLightCount = 8;\nconstant int kVFXMaxDirectionalUnshadowedLightCount = 8;\nconstant int kVFXMaxPointLightCount = 1;\nconstant int kVFXMaxPointUnshadowedLightCount = 8;\nconstant int kVFXMaxSpotLightCount = 8;\nconstant int kVFXMaxSpotUnshadowedLightCount = 8;\nconstant int kVFXMaxAmbientLightCount = 8;\nconstant int kVFXMaxRectangleUnshadowedLightCount = 8;\nconstant int kVFXMaxRealWorldProxyLightCount = 1;\nconstant int kVFXMaxSpotFilteredLightCount = 8;\nconstant int kVFXMaxSpotFilteredUnshadowedLightCount = 8;\nconstant int kVFXMaxPointFilteredLightCount = 1;\nconstant int kVFXMaxPointFilteredUnshadowedLightCount = 8;\n#if VFX_SUPPORTS_CASCADED_SHADOW_MAPS\nconstant int kVFXMaxCascadesPerLight = 3;\n#else\nconstant int kVFXMaxCascadesPerLight = 1;\n#endif\n\n#else\nconstexpr int kVFXMaxLightCount = 8;\nconstexpr int kVFXMaxDirectionalLightCount = 8;\nconstexpr int kVFXMaxDirectionalUnshadowedLightCount = 8;\nconstexpr int kVFXMaxPointLightCount = 1;\nconstexpr int kVFXMaxPointUnshadowedLightCount = 8;\nconstexpr int kVFXMaxSpotLightCount = 8;\nconstexpr int kVFXMaxSpotUnshadowedLightCount = 8;\nconstexpr int kVFXMaxAmbientLightCount = 8;\nconstexpr int kVFXMaxRectangleUnshadowedLightCount = 8;\nconstexpr int kVFXMaxRealWorldProxyLightCount = 1;\nconstexpr int kVFXMaxSpotFilteredLightCount = 8;\nconstexpr int kVFXMaxSpotFilteredUnshadowedLightCount = 8;\nconstexpr int kVFXMaxPointFilteredLightCount = 1;\nconstexpr int kVFXMaxPointFilteredUnshadowedLightCount = 8;\n#if VFX_SUPPORTS_CASCADED_SHADOW_MAPS\nconstexpr int kVFXMaxCascadesPerLight = 3;\n#else\nconstexpr int kVFXMaxCascadesPerLight = 1;\n#endif\n#endif \n\ntypedef struct\n{\n    int directionalUnshadowedLightsCount;\n    int directionalLightsCount;\n    int pointUnshadowedLightsCount;\n    int pointLightsCount;\n    int spotUnshadowedLightsCount;\n    int spotLightsCount;\n    int ambientLightsCount;\n    int rectangularLightsCount;\n    int realWorldProxyLightsCount;\n    int spotFilteredUnshadowedLightsCount;\n    int spotFilteredLightsCount;\n    int pointFilteredUnshadowedLightsCount;\n    int pointFilteredLightsCount;\n    int globalDirectionalLightCount;\n} VFX_RE_C_LightCounts;\n\n\ntypedef struct\n{\n    simd_float3 intensity;\n    simd_float3 direction;\n    simd_float4x4 lightViewFromCrWorldMatrix;\n    simd_float4x4 lightProjFromViewMatrix;\n    \n    \n    simd_float4 shadowMapTile;\n    float shadowBias;\n    float texelSize;\n\n    \n    \n    simd_float4x4 lightProjFromCrWorldMatrix;\n\n#if REVFX_SUPPORTS_CASCADED_SHADOW_MAPS\n    \n    \n    \n    struct {\n        simd_float4x4 lightProjFromViewMatrix;\n        simd_float4 shadowMapTile;\n        float texelSize;\n        simd_float4x4 lightProjFromCrWorldMatrix;\n    } cascades[kVFXMaxCascadesPerLight - 1];\n\n    \n    int cascadeCount;\n#endif \n} VFX_RE_C_LightDirectional;\n\ntypedef struct\n{\n    simd_float3 intensity;\n    simd_float3 crWorldPosition;\n    simd_float4x4 lightViewFromCrWorldMatrices[6];\n    simd_float4x4 lightProjFromViewMatrix;\n    \n    \n    simd_float4 shadowMapTiles[6];\n    float shadowBias;\n    \n    float inverseAttenuationRadiusSquared;\n    \n    \n    simd_float4 filterMapTiles[1];\n    float near;\n    bool nearAttenuation;\n} VFX_RE_C_LightPoint;\n\ntypedef struct\n{\n    simd_float3 intensity;\n    simd_float3 crWorldPosition;\n    simd_float4x4 lightViewFromCrWorldMatrix;\n    simd_float4x4 lightProjFromViewMatrix;\n    simd_float4x4 lightProjFromCrWorldMatrix;\n    \n    \n    simd_float4 shadowMapTile;\n    float shadowBias;\n    \n    float inverseAttenuationRadiusSquared;\n    \n    float spotAngleAttenuationScale;\n    float spotAngleAttenuationOffset;\n    \n    \n    simd_float4 filterMapTile;\n    float near;\n    bool nearAttenuation;\n} VFX_RE_C_LightSpot;\n\n\ntypedef struct\n{\n    simd_float3 intensity;\n    simd_float3 direction;\n    simd_float4x4 lightViewFromCrWorldMatrix;\n    simd_float4x4 lightProjFromViewMatrix;\n    \n    \n    simd_float4 shadowMapTile;\n    float shadowBias;\n    float texelSize;\n    simd_float4x4 lightProjFromCrWorldMatrix;\n} VFX_RE_C_LightRealWorldProxy;\n\ntypedef struct\n{\n    simd_float3 intensity;\n} VFX_RE_C_LightAmbient;\n\ntypedef struct\n{\n    simd_float3 intensity;\n    \n    \n    \n    \n    \n    simd_float4x3 crwsRectVerts;\n    bool doubleSided;\n} VFX_RE_C_LightRectangle;\n\ntypedef struct VFX_RE_C_LightConstantBuffer_s\n{\n    VFX_RE_C_LightCounts counts;\n    VFX_RE_C_LightDirectional directionalUnshadowedLights[kVFXMaxDirectionalUnshadowedLightCount];\n    VFX_RE_C_LightDirectional directionalLights[kVFXMaxDirectionalLightCount];\n    VFX_RE_C_LightPoint pointUnshadowedLights[kVFXMaxPointUnshadowedLightCount];\n    VFX_RE_C_LightPoint pointLights[kVFXMaxPointLightCount];\n    VFX_RE_C_LightSpot spotUnshadowedLights[kVFXMaxSpotUnshadowedLightCount];\n    VFX_RE_C_LightSpot spotLights[kVFXMaxSpotLightCount];\n    VFX_RE_C_LightAmbient ambientLights[kVFXMaxAmbientLightCount];\n    VFX_RE_C_LightRectangle rectangularLights[kVFXMaxRectangleUnshadowedLightCount];\n    VFX_RE_C_LightRealWorldProxy realWorldProxyLights[kVFXMaxRealWorldProxyLightCount];\n    VFX_RE_C_LightSpot spotFilteredUnshadowedLights[kVFXMaxSpotFilteredUnshadowedLightCount];\n    VFX_RE_C_LightSpot spotFilteredLights[kVFXMaxSpotFilteredLightCount];\n    VFX_RE_C_LightPoint pointFilteredUnshadowedLights[kVFXMaxPointFilteredUnshadowedLightCount];\n    VFX_RE_C_LightPoint pointFilteredLights[kVFXMaxPointFilteredLightCount];\n    VFX_RE_C_LightDirectional globalDirectionalLight;\n    uint32_t unshadowedLightsDropped;\n    uint32_t shadowedLightsDropped;\n    \n#if VFX_SUPPORTS_CASCADED_SHADOW_MAPS\n    \n#else\n    uint8_t padding[16];\n#endif\n#if TARGET_OS_SIMULATOR\n#if TARGET_OS_VISION\n    \n#else\n    \n    \n#if VFX_SUPPORTS_CASCADED_SHADOW_MAPS\n    \n#else\n    uint8_t paddingForIOSSimulator[64];\n#endif\n#endif\n#endif\n} VFX_RE_C_LightConstantBuffer;\n\n#if defined(__cplusplus)\nstatic_assert(sizeof(struct VFX_RE_C_LightConstantBuffer_s) % 32 == 0, \"LightConstantBuffer requires a multiple of 32-byte size for use in Metal Constant Buffers\");\n#endif\n\n#if VFX_IMPORT_RE_SHADERS_SHARED_LIGHTING\ntypedef re::LightSpot LightSpot;\ntypedef re::LightDirectional LightDirectional;\ntypedef re::LightPoint LightPoint;\ntypedef re::LightCounts LightCounts;\ntypedef re::LightRealWorldProxy LightRealWorldProxy;\ntypedef re::LightAmbient LightAmbient;\ntypedef re::LightRectangle LightRectangle;\ntypedef re::LightConstantBuffer LightConstantBuffer;\ntypedef re::IBLConstants IBLConstants;\n#else\ntypedef VFX_RE_C_LightSpot LightSpot;\ntypedef VFX_RE_C_LightDirectional LightDirectional;\ntypedef VFX_RE_C_LightPoint LightPoint;\ntypedef VFX_RE_C_LightCounts LightCounts;\ntypedef VFX_RE_C_LightRealWorldProxy LightRealWorldProxy;\ntypedef VFX_RE_C_LightAmbient LightAmbient;\ntypedef VFX_RE_C_LightRectangle LightRectangle;\ntypedef VFX_RE_C_LightConstantBuffer LightConstantBuffer;\ntypedef VFX_RE_C_IBLConstants IBLConstants;\n#endif \n\n\n#if !VFX_IMPORT_RE_SHADERS_SHARED_LIGHTING\n#   if defined(__OBJC__) && !defined(__cplusplus)\ntypedef NS_ENUM(int32_t, MaxLightCounts)\n{\n    kMaxLightCount = kVFXMaxLightCount,\n    kMaxDirectionalLightCount = kVFXMaxDirectionalLightCount,\n    kMaxDirectionalUnshadowedLightCount = kVFXMaxDirectionalUnshadowedLightCount,\n    kMaxPointLightCount = kVFXMaxPointLightCount,\n    kMaxPointUnshadowedLightCount = kVFXMaxPointUnshadowedLightCount,\n    kMaxSpotLightCount = kVFXMaxSpotLightCount,\n    kMaxSpotUnshadowedLightCount = kVFXMaxSpotUnshadowedLightCount,\n    kMaxAmbientLightCount = kVFXMaxAmbientLightCount,\n    kMaxRectangleUnshadowedLightCount = kVFXMaxRectangleUnshadowedLightCount,\n    kMaxRealWorldProxyLightCount = kVFXMaxRealWorldProxyLightCount,\n    kMaxSpotFilteredLightCount = kVFXMaxSpotFilteredLightCount,\n    kMaxSpotFilteredUnshadowedLightCount = kVFXMaxSpotFilteredUnshadowedLightCount,\n    kMaxPointFilteredLightCount = kVFXMaxPointFilteredLightCount,\n    kMaxPointFilteredUnshadowedLightCount = kVFXMaxPointFilteredUnshadowedLightCount\n};\n#   elif __METAL_VERSION__\nconstant int kMaxLightCount = kVFXMaxLightCount;\nconstant int kMaxDirectionalLightCount = kVFXMaxDirectionalLightCount;\nconstant int kMaxDirectionalUnshadowedLightCount = kVFXMaxDirectionalUnshadowedLightCount;\nconstant int kMaxPointLightCount = kVFXMaxPointLightCount;\nconstant int kMaxPointUnshadowedLightCount = kVFXMaxPointUnshadowedLightCount;\nconstant int kMaxSpotLightCount = kVFXMaxSpotLightCount;\nconstant int kMaxSpotUnshadowedLightCount = kVFXMaxSpotUnshadowedLightCount;\nconstant int kMaxAmbientLightCount = kVFXMaxAmbientLightCount;\nconstant int kMaxRectangleUnshadowedLightCount = kVFXMaxRectangleUnshadowedLightCount;\nconstant int kMaxRealWorldProxyLightCount = kVFXMaxRealWorldProxyLightCount;\nconstant int kMaxSpotFilteredLightCount = kVFXMaxSpotFilteredLightCount;\nconstant int kMaxSpotFilteredUnshadowedLightCount = kVFXMaxSpotFilteredUnshadowedLightCount;\nconstant int kMaxPointFilteredLightCount = kVFXMaxPointFilteredLightCount;\nconstant int kMaxPointFilteredUnshadowedLightCount = kVFXMaxPointFilteredUnshadowedLightCount;\n#   else\nconstexpr int kMaxLightCount = kVFXMaxLightCount;\nconstexpr int kMaxDirectionalLightCount = kVFXMaxDirectionalLightCount;\nconstexpr int kMaxDirectionalUnshadowedLightCount = kVFXMaxDirectionalUnshadowedLightCount;\nconstexpr int kMaxPointLightCount = kVFXMaxPointLightCount;\nconstexpr int kMaxPointUnshadowedLightCount = kVFXMaxPointUnshadowedLightCount;\nconstexpr int kMaxSpotLightCount = kVFXMaxSpotLightCount;\nconstexpr int kMaxSpotUnshadowedLightCount = kVFXMaxSpotUnshadowedLightCount;\nconstexpr int kMaxAmbientLightCount = kVFXMaxAmbientLightCount;\nconstexpr int kMaxRectangleUnshadowedLightCount = kVFXMaxRectangleUnshadowedLightCount;\nconstexpr int kMaxRealWorldProxyLightCount = kVFXMaxRealWorldProxyLightCount;\nconstexpr int kMaxSpotFilteredLightCount = kVFXMaxSpotFilteredLightCount;\nconstexpr int kMaxSpotFilteredUnshadowedLightCount = kVFXMaxSpotFilteredUnshadowedLightCount;\nconstexpr int kMaxPointFilteredLightCount = kVFXMaxPointFilteredLightCount;\nconstexpr int kMaxPointFilteredUnshadowedLightCount = kVFXMaxPointFilteredUnshadowedLightCount;\n#   endif \n\n#endif \n\n\n\n#if VFX_IMPORT_RE_SHADERS_SHARED_LIGHTING && defined(__cplusplus) && VFX_CHECK_RE_SHADERS_STRUCT_SIZE\nstatic_assert(sizeof(VFX_RE_C_LightCounts) == sizeof(re::LightCounts), \"vfx_re_shaders: struct size mismatch\");\nstatic_assert(sizeof(VFX_RE_C_LightDirectional) == sizeof(re::LightDirectional), \"vfx_re_shaders: struct size mismatch\");\nstatic_assert(sizeof(VFX_RE_C_LightPoint) == sizeof(re::LightPoint), \"vfx_re_shaders: struct size mismatch\");\nstatic_assert(sizeof(VFX_RE_C_LightSpot) == sizeof(re::LightSpot), \"vfx_re_shaders: struct size mismatch\");\nstatic_assert(sizeof(VFX_RE_C_LightRealWorldProxy) == sizeof(re::LightRealWorldProxy), \"vfx_re_shaders: struct size mismatch\");\nstatic_assert(sizeof(VFX_RE_C_LightAmbient) == sizeof(re::LightAmbient), \"vfx_re_shaders: struct size mismatch\");\nstatic_assert(sizeof(VFX_RE_C_LightRectangle) == sizeof(re::LightRectangle), \"vfx_re_shaders: struct size mismatch\");\nstatic_assert(sizeof(VFX_RE_C_IBLConstants) == sizeof(re::IBLConstants), \"vfx_re_shaders: struct size mismatch\");\nstatic_assert(sizeof(VFX_RE_C_LightConstantBuffer) == sizeof(re::LightConstantBuffer), \"vfx_re_shaders: struct size mismatch\");\n\nstatic_assert(alignof(VFX_RE_C_LightCounts) == alignof(re::LightCounts), \"vfx_re_shaders: struct alignof mismatch\");\nstatic_assert(alignof(VFX_RE_C_LightDirectional) == alignof(re::LightDirectional), \"vfx_re_shaders: struct alignof mismatch\");\nstatic_assert(alignof(VFX_RE_C_LightPoint) == alignof(re::LightPoint), \"vfx_re_shaders: struct alignof mismatch\");\nstatic_assert(alignof(VFX_RE_C_LightSpot) == alignof(re::LightSpot), \"vfx_re_shaders: struct alignof mismatch\");\nstatic_assert(alignof(VFX_RE_C_LightAmbient) == alignof(re::LightAmbient), \"vfx_re_shaders: struct alignof mismatch\");\nstatic_assert(alignof(VFX_RE_C_LightRectangle) == alignof(re::LightRectangle), \"vfx_re_shaders: struct alignof mismatch\");\nstatic_assert(alignof(VFX_RE_C_IBLConstants) == alignof(re::IBLConstants), \"vfx_re_shaders: struct alignof mismatch\");\nstatic_assert(alignof(VFX_RE_C_LightConstantBuffer) == alignof(re::LightConstantBuffer), \"vfx_re_shaders: struct size mismatch\");\n\nstatic_assert(kVFXMaxLightCount == kMaxLightCount, \"vfx_re_shaders: light count mismatch\");\nstatic_assert(kVFXMaxDirectionalLightCount == kMaxDirectionalLightCount, \"vfx_re_shaders: light count mismatch\");\nstatic_assert(kVFXMaxDirectionalUnshadowedLightCount == kMaxDirectionalUnshadowedLightCount, \"vfx_re_shaders: light count mismatch\");\nstatic_assert(kVFXMaxPointLightCount == kMaxPointLightCount, \"vfx_re_shaders: light count mismatch\");\nstatic_assert(kVFXMaxPointUnshadowedLightCount == kMaxPointUnshadowedLightCount, \"vfx_re_shaders: light count mismatch\");\nstatic_assert(kVFXMaxSpotLightCount == kMaxSpotLightCount, \"vfx_re_shaders: light count mismatch\");\nstatic_assert(kVFXMaxSpotUnshadowedLightCount == kMaxSpotUnshadowedLightCount, \"vfx_re_shaders: light count mismatch\");\nstatic_assert(kVFXMaxAmbientLightCount == kMaxAmbientLightCount, \"vfx_re_shaders: light count mismatch\");\nstatic_assert(kVFXMaxRectangleUnshadowedLightCount == kMaxRectangleUnshadowedLightCount, \"vfx_re_shaders: light count mismatch\");\nstatic_assert(kVFXMaxRealWorldProxyLightCount == kMaxRealWorldProxyLightCount, \"vfx_re_shaders: light count mismatch\");\nstatic_assert(kVFXMaxSpotFilteredLightCount == kMaxSpotFilteredLightCount, \"vfx_re_shaders: light count mismatch\");\nstatic_assert(kVFXMaxSpotFilteredUnshadowedLightCount == kMaxSpotFilteredUnshadowedLightCount, \"vfx_re_shaders: light count mismatch\");\nstatic_assert(kVFXMaxPointFilteredLightCount == kMaxPointFilteredLightCount, \"vfx_re_shaders: light count mismatch\");\nstatic_assert(kVFXMaxPointFilteredUnshadowedLightCount == kMaxPointFilteredUnshadowedLightCount, \"vfx_re_shaders: light count mismatch\");\n#endif \n\n\n\n\n\n#if VFX_IMPORT_RE_SHADERS_CLIPPING\n#  import \"REShaders/Clipping.h\"\n#endif \n\ntypedef struct\n{\n    simd_float4 toUnitClippingSpaceXAndOriginX;\n    simd_float4 toUnitClippingSpaceYAndOriginY;\n    simd_float4 toUnitClippingSpaceZAndOriginZ;\n\n    \n    \n    simd_float3 padding;\n} VFX_RE_C_ClippingParametersEntry;\n#if defined(__OBJC__) && !defined(__cplusplus)\ntypedef NS_ENUM(int32_t, VFX_RE_C_ClippingConstantsConstants)\n{\n    kREVFXMaxNumClippingParameters = 1024,\n    kREVFXMaxNumClippingIndices = 16384,\n    kREVFXMaxDynamicClippingPrimitivesPerMesh = 32\n};\n#elif __METAL_VERSION__\nconstant int kREVFXMaxNumClippingParameters = 1024;\nconstant int kREVFXMaxNumClippingIndices = 16384;\nconstant ushort kREVFXMaxDynamicClippingPrimitivesPerMesh = 32;\n#else\nconstexpr int kREVFXMaxNumClippingParameters = 1024;\nconstexpr int kREVFXMaxNumClippingIndices = 16384;\nconstexpr ushort kREVFXMaxDynamicClippingPrimitivesPerMesh = 32;\n#endif\n\ntypedef struct REVFXClippingRoundedCornerParametersEntry_s\n{\n    simd_float4 dimensionFactors;\n    simd_ushort4 textureIndices;\n    simd_float2 blendWeights;\n} VFX_RE_C_ClippingRoundedCornerParametersEntry;\n\ntypedef struct VFX_RE_SHADERS_ALIGN_AS(256) VFX_RE_C_ClippingConstants_s\n{\n    VFX_RE_C_ClippingParametersEntry clippingParameters[kREVFXMaxNumClippingParameters];\n    uint16_t indexIndirection[kREVFXMaxNumClippingIndices];\n    VFX_RE_C_ClippingRoundedCornerParametersEntry roundedCornerParameters[kREVFXMaxNumClippingParameters];\n} VFX_RE_C_ClippingConstants;\n\n#if VFX_IMPORT_RE_SHADERS_CLIPPING\ntypedef re::ClippingParametersEntry ClippingParametersEntry;\ntypedef re::ClippingRoundedCornerParametersEntry ClippingRoundedCornerParametersEntry;\ntypedef re::ClippingConstants ClippingConstants;\n#else\ntypedef VFX_RE_C_ClippingParametersEntry ClippingParametersEntry;\ntypedef VFX_RE_C_ClippingRoundedCornerParametersEntry ClippingRoundedCornerParametersEntry;\ntypedef VFX_RE_C_ClippingConstants ClippingConstants;\n#endif \n\n#if VFX_IMPORT_RE_SHADERS_CLIPPING && VFX_CHECK_RE_SHADERS_STRUCT_SIZE\nstatic_assert(sizeof(VFX_RE_C_ClippingParametersEntry) == sizeof(re::ClippingParametersEntry), \"vfx_re_shaders: struct size mismatch\");\nstatic_assert(sizeof(VFX_RE_C_ClippingRoundedCornerParametersEntry) == sizeof(re::ClippingRoundedCornerParametersEntry), \"vfx_re_shaders: struct size mismatch\");\nstatic_assert(sizeof(VFX_RE_C_ClippingConstants) == sizeof(re::ClippingConstants), \"vfx_re_shaders: struct size mismatch\");\n\nstatic_assert(alignof(VFX_RE_C_ClippingParametersEntry) == alignof(re::ClippingParametersEntry), \"vfx_re_shaders: struct alignof mismatch\");\nstatic_assert(alignof(VFX_RE_C_ClippingRoundedCornerParametersEntry) == alignof(re::ClippingRoundedCornerParametersEntry), \"vfx_re_shaders: struct alignof mismatch\");\nstatic_assert(alignof(VFX_RE_C_ClippingConstants) == alignof(re::ClippingConstants), \"vfx_re_shaders: struct alignof mismatch\");\n#endif \n\n\n\n\n\n#if VFX_IMPORT_RE_SHADERS_SHARED_PROBES\n#  import \"REShaders/SharedProbeConstants.h\"\n#  import \"REShaders/SharedProbe.h\"\n#endif\n\n\n\n\n#if __METAL_VERSION__\n\nconstant uint kVFXMaxLocalizedProbeCountDefault = 4;\n\nconstant uint kVFXMaxGlobalProbeCountDefault = 3;\n#elif defined(__cplusplus)\nconstexpr uint kVFXMaxLocalizedProbeCountDefault = 4;\nconstexpr uint kVFXMaxGlobalProbeCountDefault = 3;\n#else\ntypedef NS_ENUM(NSInteger, VFX_RE_C_MaxProbeCountDefault)\n{\n    kVFXMaxLocalizedProbeCountDefault = 4,\n    kVFXMaxGlobalProbeCountDefault = 3\n};\n#endif \n\n\n\n#if TARGET_OS_VISION\n\n#if __METAL_VERSION__\n\nconstant uint kVFXMaxLocalizedProbeCount = 0;\n\nconstant uint kVFXMaxGlobalProbeCount = 2;\n#elif defined(__cplusplus)\nconstexpr uint kVFXMaxLocalizedProbeCount = 0;\nconstexpr uint kVFXMaxGlobalProbeCount = 2;\n#else\ntypedef NS_ENUM(NSInteger, VFX_RE_C_MaxProbeCount)\n{\n    kVFXMaxLocalizedProbeCount = 0,\n    kVFXMaxGlobalProbeCount = 2\n};\n#endif \n\n#else \n\n#if __METAL_VERSION__\nconstant uint kVFXMaxLocalizedProbeCount = kVFXMaxLocalizedProbeCountDefault;\nconstant uint kVFXMaxGlobalProbeCount = kVFXMaxGlobalProbeCountDefault;\n#elif defined(__cplusplus)\nconstexpr uint kVFXMaxLocalizedProbeCount = kVFXMaxLocalizedProbeCountDefault;\nconstexpr uint kVFXMaxGlobalProbeCount = kVFXMaxGlobalProbeCountDefault;\n#else\ntypedef NS_ENUM(NSInteger, VFX_RE_C_MaxProbeCount)\n{\n    kVFXMaxLocalizedProbeCount = kVFXMaxLocalizedProbeCountDefault,\n    kVFXMaxGlobalProbeCount = kVFXMaxGlobalProbeCountDefault\n};\n#endif \n\n#endif \n\ntypedef struct\n{\n    uint32_t localizedProbeCount;\n    uint32_t globalProbeCount;\n} VFX_RE_C_ProbeCounts;\n\ntypedef struct\n{\n    simd_float3x3 axes;\n    simd_float3 parallaxCenter;\n    simd_float3 parallaxScale;\n    float minScale; \n    float fadeDistance;\n    \n    float weight;\n    \n    float crossWeight;\n    float clippingPointLux;\n    uint32_t textureSlice;\n    uint32_t crossSlice;\n    float crossClippingPointLux;\n} VFX_RE_C_LocalizedProbeConstant;\n\ntypedef struct\n{\n    simd_float3x3 axes;\n    simd_float3 parallaxCenter;\n    simd_float3 parallaxScale;\n    float radius; \n    \n    float weight;\n    \n    float crossWeight;\n    float clippingPointLux;\n    uint32_t textureSlice;\n    uint32_t crossSlice;\n    float crossClippingPointLux;\n} VFX_RE_C_GlobalProbeConstant;\n\ntypedef struct VFX_RE_C_ProbeConstantBuffer_s\n{\n    VFX_RE_C_ProbeCounts counts;\n    bool enableLegacyBlur;\n    float probeIntensityScale;\n    VFX_RE_C_LocalizedProbeConstant localizedProbes[kVFXMaxLocalizedProbeCountDefault];\n    VFX_RE_C_GlobalProbeConstant globalProbes[kVFXMaxGlobalProbeCountDefault];\n    \n    simd_float3x3 combinedMatrix;\n    float probeClampFloor;\n    float probeClampCeil;\n} VFX_RE_C_ProbeConstantBuffer;\n\n#if VFX_IMPORT_RE_SHADERS_SHARED_PROBES\ntypedef re::ProbeCounts ProbeCounts;\ntypedef re::LocalizedProbeConstant LocalizedProbeConstant;\ntypedef re::GlobalProbeConstant GlobalProbeConstant;\ntypedef re::ProbeConstantBuffer ProbeConstantBuffer;\nconstant uint32_t kMaxLocalizedProbeCount = re::kMaxLocalizedProbeCount;\nconstant uint32_t kMaxGlobalProbeCount = re::kMaxGlobalProbeCount;\n#else\ntypedef VFX_RE_C_ProbeCounts ProbeCounts;\ntypedef VFX_RE_C_LocalizedProbeConstant LocalizedProbeConstant;\ntypedef VFX_RE_C_GlobalProbeConstant GlobalProbeConstant;\ntypedef VFX_RE_C_ProbeConstantBuffer ProbeConstantBuffer;\n#  if __METAL_VERSION__\nconstant uint32_t kMaxLocalizedProbeCount = kVFXMaxLocalizedProbeCount;\nconstant uint32_t kMaxGlobalProbeCount = kVFXMaxGlobalProbeCount;\n#  elif defined(__cplusplus)\nconstexpr uint32_t kMaxLocalizedProbeCount = kVFXMaxLocalizedProbeCount;\nconstexpr uint32_t kMaxGlobalProbeCount = kVFXMaxGlobalProbeCount;\n#  endif\n#endif \n\n#if VFX_IMPORT_RE_SHADERS_SHARED_PROBES && VFX_CHECK_RE_SHADERS_STRUCT_SIZE\nstatic_assert(sizeof(VFX_RE_C_ProbeCounts) == sizeof(re::ProbeCounts), \"vfx_re_shaders: struct size mismatch\");\nstatic_assert(sizeof(VFX_RE_C_LocalizedProbeConstant) == sizeof(re::LocalizedProbeConstant), \"vfx_re_shaders: struct size mismatch\");\nstatic_assert(sizeof(VFX_RE_C_GlobalProbeConstant) == sizeof(re::GlobalProbeConstant), \"vfx_re_shaders: struct size mismatch\");\nstatic_assert(sizeof(VFX_RE_C_ProbeConstantBuffer) == sizeof(re::ProbeConstantBuffer), \"vfx_re_shaders: struct size mismatch\");\n\nstatic_assert(alignof(VFX_RE_C_ProbeCounts) == alignof(re::ProbeCounts), \"vfx_re_shaders: struct alignof mismatch\");\nstatic_assert(alignof(VFX_RE_C_LocalizedProbeConstant) == alignof(re::LocalizedProbeConstant), \"vfx_re_shaders: struct alignof mismatch\");\nstatic_assert(alignof(VFX_RE_C_GlobalProbeConstant) == alignof(re::GlobalProbeConstant), \"vfx_re_shaders: struct alignof mismatch\");\nstatic_assert(alignof(VFX_RE_C_ProbeConstantBuffer) == alignof(re::ProbeConstantBuffer), \"vfx_re_shaders: struct alignof mismatch\");\n\nstatic_assert(kVFXMaxLocalizedProbeCount == re::kMaxLocalizedProbeCount, \"vfx_re_shaders: max probe count mismatch\");\nstatic_assert(kVFXMaxGlobalProbeCount == re::kMaxGlobalProbeCount, \"vfx_re_shaders: max probe count mismatch\");\n#endif \n\n\n\n\n\n#if VFX_IMPORT_RE_SHADERS_SHARED_VIRTUAL_ENV_PROBES\n#  import <REShaders/SharedVirtualEnvironmentProbes.h>\n#endif\n\n\n\n\n#if VFX_IMPORT_RE_SHADERS_SHARED_BREAKTHROUGH\n#  import <REShaders/SharedBreakthrough.h>\n#endif\n\n#if VFX_IMPORT_RE_SHADERS_SHARED_BREAKTHROUGH\ntypedef re::BreakthroughGPUData BreakthroughGPUData;\n#elif defined(__METAL_VERSION__)\nstruct BreakthroughGPUData;\n#endif\n\n\n\n\ntypedef VFX_RE_SHADERS_ENUM(int32_t) {\n    revfx_portal_clipping_mode_none                 = 0,\n    revfx_portal_clipping_mode_clipping             = 1,\n    revfx_portal_clipping_mode_crossing_inside      = 2,\n    revfx_portal_clipping_mode_crossing_outside     = 3,\n    revfx_portal_clipping_mode_no_clipping_inside   = 4,\n    revfx_portal_clipping_mode_count\n} revfx_portal_clipping_mode;\n\n#define VFX_RE_IMMERSIVE_MEDIA_SUPPORT_ENABLED 1\n#define VFX_RE_RUNTIME_SUPPORTS_VISUAL_DEPTH_STATIC_OCCLUSION 1\n\n\ntypedef VFX_RE_SHADERS_ENUM(int32_t)\n{\n    revfx_function_constants_EdgeBevelShadowMode,\n    revfx_function_constants_EnableGlow,\n    revfx_function_constants_EnableNormalMap,\n    revfx_function_constants_EnableDetailMapping,\n    revfx_function_constants_EnableIBL,\n    revfx_function_constants_EnableAreaLight,\n    revfx_function_constants_EnableRMAS,\n    revfx_function_constants_EnableSeparateRMAS,\n    revfx_function_constants_EnableSRGBOutput,\n    revfx_function_constants_EnableTransparency,\n    revfx_function_constants_DiffuseOption,\n    revfx_function_constants_EnableLightmap,\n    revfx_function_constants_EnableDynamicLighting,\n    revfx_function_constants_EnableNdfFiltering,\n    revfx_function_constants_LodCrossFading,\n    revfx_function_constants_EnableAlphaCutoutShadows,\n    revfx_function_constants_EnableScreenSpaceAdaptiveTessellation,\n    revfx_function_constants_EnableUnlitTexture,\n    revfx_function_constants_EnableAREnvProbe,\n    revfx_function_constants_EnableSRGBToLinearConversion,\n    revfx_function_constants_EnableBaseColorMap,\n    revfx_function_constants_EnableEmissiveMap,\n    revfx_function_constants_EnableRoughnessMap,\n    revfx_function_constants_EnableMetallicMap,\n    revfx_function_constants_EnableAOMap,\n    revfx_function_constants_EnableSpecularMap,\n    revfx_function_constants_EnableClearcoat,\n    revfx_function_constants_EnableVertexColor,\n    revfx_function_constants_VertexColorOption,\n    revfx_function_constants_ShadowPcfFilterOption,\n    revfx_function_constants_EnableOpacityMap,\n    revfx_function_constants_UseBaseColorMapAsTintMask,\n    revfx_function_constants_EnableTension,\n    revfx_function_constants_EnableOpacityThreshold,\n    revfx_function_constants_EnablePerTileLightCulling,\n    revfx_function_constants_EnableClipping,\n    revfx_function_constants_EnableCloth,\n    revfx_function_constants_EnableCustomBlend,\n    revfx_function_constants_EnablePassthrough,\n    revfx_function_constants_EnableSSAO,\n    revfx_function_constants_EnableSSDO,\n    revfx_function_constants_EnableDebug,\n    revfx_function_constants_EnableSphericalSkybox,\n    revfx_function_constants_MeshShadow,\n    revfx_function_constants_EnableSamplerArray,\n    revfx_function_constants_EnablePassthroughBlurPlane,\n    revfx_function_constants_EnableDitherFade,\n    revfx_function_constants_EnableProjectiveShadow,\n    revfx_function_constants_EnablePostProcessBlur,\n    revfx_function_constants_BaseColorHasPremultipliedAlpha,\n    revfx_function_constants_EnableMultiUVs,\n    revfx_function_constants_EnableVRROnCapableDevice,\n    revfx_function_constants_AllowAlphaBlendingWithOpacityThreshold,\n    revfx_function_constants_EnableAnisotropy,\n    revfx_function_constants_EnablePlanarReflection,\n    revfx_function_constants_SupportsCubeArray,\n    revfx_function_constants_EnableBlurMeshScaling,\n    revfx_function_constants_SupportsPrefilteredProbes,\n    revfx_function_constants_EnableMultiscatter,\n    revfx_function_constants_EnableShaderColorToLinearConversion,\n    revfx_function_constants_EnablePtCrossing,\n    revfx_function_constants_EnableFoveatedCARendering,\n    revfx_function_constants_EnableInstancing,\n    revfx_function_constants_EnableIBLRotation,\n    revfx_function_constants_EnableIBLDirectionsBend,\n    revfx_function_constants_EnableWorldSpaceNormalMap,\n    revfx_function_constants_EnablePlatter,\n    revfx_function_constants_EnableVCABlurPlane,\n    revfx_function_constants_SpecularOption,\n    revfx_function_constants_EnableShadowedDynamicLight,\n    revfx_function_constants_EnableCAEdgeBevel,\n    revfx_function_constants_EnableCAShaderDebug,\n    revfx_function_constants_EnableCAPerEyeTransform,\n    revfx_function_constants_EnableInset,\n    revfx_function_constants_VideoPlaybackOption,\n    revfx_function_constants_EnableTriPlanarVideoSupport,\n    revfx_function_constants_EnableInverseToneMapping,\n#if VFX_RE_IMMERSIVE_MEDIA_SUPPORT_ENABLED\n    revfx_function_constants_EyeFilter,\n    revfx_function_constants_ExperienceMode,\n    revfx_function_constants_EnableHDRCroppingUVRemapping,\n#endif\n    revfx_function_constants_EnableSurfaceShaderCustomParams,\n    revfx_function_constants_EnableSurfaceShaderWithCustomParams,\n    revfx_function_constants_EnableGeometryModifierWithCustomParams,\n    revfx_function_constants_CAEdgeSpecularMode,\n    revfx_function_constants_EnableVideoColorSpaceConversion,\n    revfx_function_constants_EnableVideoColorSpaceTransformation,\n    revfx_function_constants_IsPtSurface,\n    revfx_function_constants_EnableSurfaceShaderPremultipliedOutput,\n    revfx_function_constants_RenderToCompositeLayer,\n    revfx_function_constants_EnableDepthMitigation,\n    revfx_function_constants_EnableBtMask,\n    revfx_function_constants_EnableTonemapInPlace,\n    revfx_function_constants_EnableDragUIShadow,\n    revfx_function_constants_EnableVideoColorTransformation,\n    revfx_function_constants_EnableBtTransition,\n    revfx_function_constants_UseFullscreenQuadForImmersionMask,\n    revfx_function_constants_UseDirectionalLight,\n    revfx_function_constants_EnableUserEnvironment,\n    revfx_function_constants_DisableFoveatedCA,\n    revfx_function_constants_EnableRuntimeFunctionConstants,\n    revfx_function_constants_EnableScreenVideoLetterBoxPadding,\n    revfx_function_constants_EnableREShadersTonemapInPlace,\n    revfx_function_constants_RenderForBlur,\n    revfx_function_constants_EnableNearFieldVignetting,\n    revfx_function_constants_EnableCAPreSamplerDegamma,\n    revfx_function_constants_GlobalProbeCount,\n    revfx_function_constants_LocalProbeCount,\n    revfx_function_constants_EnableCrossBlending,\n    revfx_function_constants_EnableSpecularPerQuadRoughness,\n    revfx_function_constants_EnableCAVertexObjPos,\n    revfx_function_constants_PerceptualBlendingMode,\n    revfx_function_constants_MatchUnlitColor,\n    revfx_function_constants_EnableEdgeAnalyticAA,\n    revfx_function_constants_EnableSpatialFocus,\n    revfx_function_constants_EnableNonVRRAnisotropy,\n    revfx_function_constants_EnableSurfaceShaderColorDithering,\n    revfx_function_constants_EnablePlatterFakeFresnel,\n    revfx_function_constants_SurfaceShaderAttributeSet,\n    revfx_function_constants_EnablePlatterContainerSDF,\n    revfx_function_constants_EnableCALayerSurfaceShaderConstants,\n    revfx_function_constants_EnableSurfaceShaderVideo,\n    revfx_function_constants_EnableSurfaceShaderEnvInputs,\n    revfx_function_constants_EnablePlatterSpecularViewAngleFade,\n    revfx_function_constants_DitherMode,\n    revfx_function_constants_EnableSampleMaskReadWrite,\n    revfx_function_constants_DisableFadeOpacity,\n    revfx_function_constants_EnableDitherFadeOverride,\n    revfx_function_constants_DisableSystemTreatmentOpacity,\n    revfx_function_constants_EnablePtClipPlane,\n    revfx_function_constants_EnableVideoEdgeAnalyticAA,\n    revfx_function_constants_PortalClippingMode,\n    revfx_function_constants_EnableDepthDither,\n    revfx_function_constants_EnableSurfaceShaderMeshShadow,\n    revfx_function_constants_IsPointPrimitive,\n    revfx_function_constants_EnableProgrammableBlending,\n    revfx_function_constants_EnableManualVertexFetch,\n    revfx_function_constants_EnableAdditiveBlending,\n#if VFX_RE_CARE_CG_COMPONENTS_ENABLED\n    revfx_function_constants_EnableEscapedLayer,\n#else\n    revfx_function_constants_FunctionConstantPlaceholderIndex11,\n#endif\n    revfx_function_constants_VideoSamplingMode,\n    revfx_function_constants_FunctionConstantPlaceholderIndex12,\n    revfx_function_constants_EnableSurfaceShaderLighting,\n    revfx_function_constants_EnableVirtualEnvironmentProbes,\n#if VFX_RE_CARE_CG_COMPONENTS_ENABLED\n    revfx_function_constants_EnableTexturePlatterMask,\n#else\n    revfx_function_constants_FunctionConstantPlaceholderIndex13,\n#endif\n    revfx_function_constants_EnableClearcoatNormalMap,\n    revfx_function_constants_EnableIBLBlending,\n#if VFX_RE_IMMERSIVE_MEDIA_SUPPORT_ENABLED\n    revfx_function_constants_EnableIMDynamicMask,\n    revfx_function_constants_EnableIMMonoMask,\n#else\n    revfx_function_constants_FunctionConstantPlaceholderIndex14,\n    revfx_function_constants_FunctionConstantPlaceholderIndex15,\n#endif\n    revfx_function_constants_EnableBarycentricCoordinates,\n    revfx_function_constants_EnableISPTonemap,\n#if VFX_RE_RE_VIDEO_VRR_SUPPORTED\n    revfx_function_constants_EnableVideoVrrRendering,\n#else\n    revfx_function_constants_FunctionConstantPlaceholderIndex16,\n#endif\n    revfx_function_constants_UseSDFVertDistanceForFakeFresnel,\n    revfx_function_constants_EnableShaderGraphLightSpill,\n    revfx_function_constants_EnableVideoColorInvert,\n    revfx_function_constants_SupportsQuadReduction,\n    revfx_function_constants_EnableVideoLegacyMode,\n    revfx_function_constants_EnableCustomTextureArray,\n    revfx_function_constants_EnableInvertColors,\n    revfx_function_constants_EnableInvertBlurColorMatrix,\n    revfx_function_constants_ImmersivePortalShadersFastPath,\n#if UNAUDITED_SUPPORTS_XR_RENDER_SERVER_OR_TOOLS\n    revfx_function_constants_EnableDitherFadeNFV,\n#else\n    revfx_function_constants_FunctionConstantPlaceholderIndex17,\n#endif\n    revfx_function_constants_EnableOpenSubDivViewBasedCulling,\n#if VFX_RE_CARE_CG_COMPONENTS_ENABLED\n    revfx_function_constants_EnableVideoSpecularAndFresnel,\n#else\n    revfx_function_constants_FunctionConstantPlaceholderIndex18,\n#endif\n    revfx_function_constants_UseVCOnlyBlur,\n    revfx_function_constants_EnableLightClustering,\n    revfx_function_constants_PortalEnableProbeLightingBlend,\n    revfx_function_constants_FunctionConstantEnableVideoSpatialRendering,\n#if VFX_RE_RUNTIME_SUPPORTS_VISUAL_DEPTH_STATIC_OCCLUSION\n    revfx_function_constants_IsVisualDepthStaticOcclusionTextureAvailable,\n    revfx_function_constants_EnableVisualDepthStaticOcclusion,\n#else\n    revfx_function_constants_FunctionConstantPlaceholderIndex19,\n    revfx_function_constants_FunctionConstantPlaceholderIndex21,\n#endif\n    revfx_function_constants_VideoTriangleFillMode,\n#if VFX_RE_CARE_CG_COMPONENTS_ENABLED\n    revfx_function_constants_EnableImageSpecularAndFresnel,\n#else\n    revfx_function_constants_FunctionConstantPlaceholderIndex20,\n#endif\n    revfx_function_constants_EnableWrapLighting,\n    revfx_function_constants_EnableThicknessMap,\n    revfx_function_constants_EnableSphericalGaussian,\n    revfx_function_constants_EnableSSS,\n    revfx_function_constants_EnableSSSAndIBL,\n    revfx_function_constants_SystemEnvironmentsFastPath,\n#if VFX_RE_CARE_CG_COMPONENTS_ENABLED\n    revfx_function_constants_EnableCAStereoContent,\n#else\n    revfx_function_constants_FunctionConstantPlaceholderIndex22,\n#endif\n    revfx_function_constants_EnableVideoFoveaRendering,\n    revfx_function_constants_EnableUIShadowReceiver,\n    revfx_function_constants_EnableOpenSubDivOutputTessellationFactors,\n    revfx_function_constants_EnablePrimitiveIdentifier,\n#if VFX_RE_RUNTIME_SUPPORTS_VISUAL_DEPTH_STATIC_OCCLUSION\n    revfx_function_constants_EnableSceneUnderstandingStaticOcclusion,\n#else\n    revfx_function_constants_FunctionConstantPlaceholderIndex23,\n#endif\n#if VFX_RE_UNAUDITED_SUPPORTS_XR_RENDER_SERVER_OR_TOOLS\n    revfx_function_constants_EnableBreakthroughMaskGeneration,\n    revfx_function_constants_EnableBlendingMaskGeneration,\n#else\n    revfx_function_constants_FunctionConstantPlaceholderIndex24,\n    revfx_function_constants_FunctionConstantPlaceholderIndex25,\n#endif\n    revfx_function_constants_SharedFunctionConstantCount\n} revfx_function_constants;\n\n#if VFX_IMPORT_RE_SHADERS_ENGINE_CONSTANTS && VFX_CHECK_RE_SHADERS_STRUCT_SIZE\n#  pragma clang diagnostic push\n#  pragma clang diagnostic ignored \"-Wdeprecated-declarations\"\n\n#define IMMERSIVE_MEDIA_SUPPORT_ENABLED VFX_RE_IMMERSIVE_MEDIA_SUPPORT_ENABLED\n#define RUNTIME_SUPPORTS_VISUAL_DEPTH_STATIC_OCCLUSION VFX_RE_RUNTIME_SUPPORTS_VISUAL_DEPTH_STATIC_OCCLUSION\n\n#  import \"REShaders/SharedFunctionConstants.h\"\n\nstatic_assert((int32_t)revfx_function_constants_EnableNdfFiltering == (int32_t)kEnableNdfFilteringIndex, \"vfx_re_shaders: function constant mismatch\");\nstatic_assert((int32_t)revfx_function_constants_EnableAREnvProbe == (int32_t)kEnableAREnvProbeIndex, \"vfx_re_shaders: function constant mismatch\");\nstatic_assert((int32_t)revfx_function_constants_SupportsCubeArray == (int32_t)kSupportsCubeArrayIndex, \"vfx_re_shaders: function constant mismatch\");\nstatic_assert((int32_t)revfx_function_constants_SpecularOption == (int32_t)kSpecularOptionIndex, \"vfx_re_shaders: function constant mismatch\");\nstatic_assert((int32_t)revfx_function_constants_EnableRuntimeFunctionConstants == (int32_t)kEnableRuntimeFunctionConstantsIndex, \"vfx_re_shaders: function constant mismatch\");\nstatic_assert((int32_t)revfx_function_constants_EnableClipping == (int32_t)kEnableClippingIndex, \"vfx_re_shaders: function constant mismatch\");\nstatic_assert((int32_t)revfx_function_constants_EnableBtMask == (int32_t)kEnableBtMaskIndex, \"vfx_re_shaders: function constant mismatch\");\nstatic_assert((int32_t)revfx_function_constants_EnableDepthMitigation == (int32_t)kEnableDepthMitigationIndex, \"vfx_re_shaders: function constant mismatch\");\nstatic_assert((int32_t)revfx_function_constants_EnableVisualDepthStaticOcclusion == (int32_t)kEnableVisualDepthStaticOcclusionIndex, \"vfx_re_shaders: function constant mismatch\");\nstatic_assert((int32_t)revfx_function_constants_EnableSceneUnderstandingStaticOcclusion == (int32_t)kEnableSceneUnderstandingStaticOcclusionIndex, \"vfx_re_shaders: function constant mismatch\");\n\n#undef IMMERSIVE_MEDIA_SUPPORT_ENABLED\n#undef RUNTIME_SUPPORTS_VISUAL_DEPTH_STATIC_OCCLUSION\n\n\n\n#  pragma clang diagnostic pop\n#endif \n\n#undef VFX_RE_SHADERS_ALIGN_AS\n#undef VFX_RE_SHADERS_ENUM\n\nstruct re_entity_argument_buffer {\n#ifdef __METAL_VERSION__\n    metal::texture2d_array<half> breakthroughTextureArray;\n    constant BreakthroughGPUData* breakthroughData;\n    metal::texture2d<ushort> textureBreakthroughSDFMeshScene;\n    metal::texture2d<half> textureBreakthroughDepth;\n#else\n#if !TARGET_OS_SIMULATOR\n    MTLResourceID breakthroughTextureArray;\n    uint64_t breakthroughData;\n    MTLResourceID textureBreakthroughSDFMeshScene;\n    MTLResourceID textureBreakthroughDepth;\n#endif\n#endif\n};\n\nstruct re_scene_argument_buffer {\n#ifdef __METAL_VERSION__\n    metal::texture2d<half> textureSpecMaxEss;\n    constant half* specMaxEssAvgTable;\n\n    constant ClippingConstants& clippingConstants;\n    metal::texture2d_array<float> clippingSdfTextureArray;\n\n    metal::texture2d<half> blueNoiseTexture;\n\n    metal::texture1d<half> ispTonemapLUT;\n    metal::texture2d<half> textureFilter;\n\n    constant ProbeConstantBuffer& probes;\n#if TARGET_OS_SIMULATOR\n    metal::texturecube<half> envProbeCube;\n    metal::texturecube<half> envProbeDiffuse;\n#else\n    metal::texturecube_array<half> envProbeCubeArray;\n    metal::texturecube_array<half> envProbeDiffuseArray;\n    metal::texture2d_array<half> envProbeTextureArray;\n    constant VirtualEnvironmentProbeLighting::TextureArgumentBuffer& virtualEnvProbeTextures;\n#endif\n    constant VirtualEnvironmentProbeLighting::ProbeConstantBuffer& virtualEnvProbeConstants;\n\n    metal::depth2d<float> textureShadow;\n\n    metal::texture2d_array<half> dmWarpedAlphaMask;\n\n    metal::texture2d_array<half> textureVisualDepth;\n    metal::texture2d_array<half> textureImmersiveEnvironmentMask;\n    metal::texture2d_array<half> textureSUOcclusionAlphaMask;\n\n#else \n#if !TARGET_OS_SIMULATOR\n    MTLResourceID textureSpecMaxEss;\n    uint64_t specMaxEssAvgTable;\n\n    uint64_t clippingConstants;\n    MTLResourceID clippingSdfTextureArray;\n\n    MTLResourceID blueNoiseTexture;\n\n    MTLResourceID ispTonemapLUT;\n    MTLResourceID textureFilter;\n\n    uint64_t probes;\n    MTLResourceID envProbeCubeArray;\n    MTLResourceID envProbeDiffuseArray;\n    MTLResourceID envProbeTextureArray;\n    uint64_t virtualEnvProbeTextures;\n    uint64_t virtualEnvProbeConstants;\n\n    MTLResourceID textureShadow;\n\n    MTLResourceID dmWarpedAlphaMask;\n    \n    MTLResourceID textureVisualDepth;\n    MTLResourceID textureImmersiveEnvironmentMask;\n    MTLResourceID textureSUOcclusionAlphaMask;\n#endif\n#endif \n};\n\nstruct re_vfx_object_constants {\n    uint16_t render_options;\n    uint16_t perceptual_blending_mode;\n};\n\n#endif \n"
+ "#ifndef __VFX_SHADER_API_V2_H__\n#define __VFX_SHADER_API_V2_H__\n\n#ifndef IMPORT_IN_CFX_COMMON_PROFILE\n#import \"vfx_re_shaders.h\"\n#import \"vfx_render_options.h\"\n#endif\n\n#if __METAL_VERSION__\n\nnamespace vfx { namespace api_v2 {\n\n#if VFX_RE_SHADERS_AVAILABLE\n\nstruct system_treatment_parameters {\n    float3 crWorldPosition;\n    uint16_t cameraIndex;\n    render_options_override renderOptionsOverride;\n\n    float2 screenUV;\n    float4 screenPosition;\n};\n\nstruct re_buffers {\n    constant EntityConstants& entityConstants;\n    constant ViewConstants& viewConstants;\n    constant GlobalConstants& globalConstants;\n    constant re_vfx_object_constants& objectConstants;\n    constant re_entity_argument_buffer& entityArgumentBuffer;\n    constant re_scene_argument_buffer& sceneArgumentBuffer;\n#if TARGET_OS_SIMULATOR\n    constant VirtualEnvironmentProbeLighting::TextureArgumentBuffer& probeTextures;\n#endif\n};\n\n[[visible]]\nsystem_treatment_parameters make_system_treatment_parameters(float3 crWorldPosition, float4 position,\n                                                             uint16_t cameraIndex, float2 screenUV);\n\n[[visible]]\nhalf4 apply_system_treatments(half4 color,\n                              thread const system_treatment_parameters& params,\n                              thread re_buffers& re_data,\n                              thread uint& sample_mask);\n\n[[visible]]\nfloat3 crws_position(float3 world_position, constant GlobalConstants& globalConstants);\n\n#else\n[[visible]]\nvoid make_system_treatment_parameters();\n\n[[visible]]\nvoid apply_system_treatments();\n\n[[visible]]\nvoid crws_position();\n#endif\n\n}} \n\n#endif \n#endif \n"
+ "#import \"CFX-OpenSubdiv-Raytracing.h\""
+ "#import \"vfx_render.h\"\n#import \"vfx_render_options.h\"\n\n#ifndef __METAL_VERSION__\ntypedef struct {} pbr_surface_parameters;\ntypedef struct {} pbr_lighting_parameters;\n#else\n\nstruct global_constants;\n\nstruct external_constants {\n    constant external_scene_constants& sceneConstants    [[ buffer(vfx_buffer_binding_index_external_scene_constants), function_constant(use_api_v1_in_re) ]];\n    constant external_scene_buffers& sceneBuffers        [[ buffer(vfx_buffer_binding_index_external_scene_buffers), function_constant(use_api_v1_in_re) ]];\n    constant external_entity_constants& entityConstants  [[ buffer(vfx_buffer_binding_index_external_entity_constants), function_constant(use_api_v1) ]]; \n};\n\nstruct system_treatment_parameters {\n    float3 crWorldPosition;\n    uint16_t cameraIndex;\n    render_options_override renderOptionsOverride;\n\n    external_constants externals;\n\n    float2 screenUV             [[ function_constant(enable_breakthrough) ]];\n    float4 screenPosition       [[ function_constant(enable_dither_fade) ]];\n};\n\nstruct pbr_surface_parameters {\n    half3 baseColor = half3(0.827h, 0.827h, 0.827h);\n    half roughness = .5h;\n    half metallic = 0.h;\n    half3 emissive = 0.h;\n    float3 normal; \n    float3 tangent; \n    half alpha = 1.h;\n    half ambientOcclusion = 1.h;\n    half thickness = 1.h;\n};\n\nstruct pbr_lighting_parameters {\n    float3 crWorldPosition;\n    float3 worldViewDir;\n\n    pbr_surface_parameters surface;\n    bool useAnalyticalLights = true;\n    bool useIBL = true;\n    bool useEnvProbes = true;\n\n    constant global_constants& globals;\n    external_constants externals;\n};\n\n\n\n\n\n#if USE_LINKED_FUNCTIONS\nnamespace vfx { namespace api {\n\n[[visible]]\nhalf3 computePbrLighting(thread const pbr_lighting_parameters& params);\n\n[[visible]]\nhalf4 applySystemTreatments(half4 color,\n                            thread const system_treatment_parameters& params,\n                            thread uint& sampleMask);\n}} \n#endif \n\n#endif \n"
+ "#import \"vfx_shadowmap_util.h\""
+ "#import \"vfx_shared.h\"\n#import \"vfx_re_shaders.h\"\n\ntypedef VFX_ENUM(int32_t)\n{\n    argument_buffer_index_zero          = 0,\n\n    \n    argument_buffer_index_ibl           = 10, \n    argument_buffer_index_lights        = 11,\n    argument_buffer_index_vrr_map       = 12,\n\n    \n    argument_buffer_index_irradiance    = 20,\n    argument_buffer_index_radiance      = 21,\n    argument_buffer_index_brdfLUT       = 22,\n    argument_buffer_index_shadowMap     = 23,\n    argument_buffer_index_ssao          = 24,\n\n    \n    argument_buffer_index_linear_depth  = 30,\n    argument_buffer_index_opaque_zbuffer= 31,\n    argument_buffer_index_normal_buffer = 32,\n    argument_buffer_index_voxel_data    = 33,\n    argument_buffer_index_gi_tex        = 34,\n\n    \n    argument_buffer_index_albedo_map    = 100,\n    argument_buffer_index_roughness_map = 101,\n    argument_buffer_index_metalness_map = 102,\n    argument_buffer_index_occlusion_map = 103,\n    argument_buffer_index_normal_map    = 104,\n    argument_buffer_index_emissive_map  = 105,\n\n    \n    argument_buffer_index_sampler       = 200,\n    argument_buffer_index_texture       = 201,\n\n    \n    argument_buffer_index_prebaked_lighting_posXYZ = 230,\n    argument_buffer_index_prebaked_lighting_negXYZ = 231,\n\n    \n    argument_buffer_index_ribbon_cap_begin_texture = 240,\n    argument_buffer_index_ribbon_cap_end_texture   = 241,\n\n    \n    argument_buffer_index_env_probe_constants        = 500,\n    argument_buffer_index_env_probe_cube_array       = 501,\n    argument_buffer_index_env_probe_diffuse_array    = 502,\n    argument_buffer_index_env_probe_texture_array    = 503,\n    argument_buffer_index_spec_max_ess_map           = 504,\n    argument_buffer_index_spec_max_ess_avg_table     = 505,\n    argument_buffer_index_clipping_constants         = 506,\n    argument_buffer_index_blue_noise_texture         = 507,\n    argument_buffer_index_breakthrough_texture_array_deprecated = 508,\n    argument_buffer_index_env_probe_cube             = 509,\n    argument_buffer_index_env_probe_diffuse          = 510,\n    argument_buffer_index_blend_irradiance           = 511,\n    argument_buffer_index_blend_radiance             = 512,\n    argument_buffer_index_isp_tonemap_lut            = 513,\n    argument_buffer_index_texture_filter             = 514,\n    argument_buffer_index_virtual_env_probe_constants   = 525,\n    argument_buffer_index_virtual_env_probe_textures    = 526,\n\n    argument_buffer_index_portal_opacity                            = 530,\n    argument_buffer_index_vignetting_fadeout_distance_normalization = 531,\n    argument_buffer_index_vignetting_total_fadeout_distance         = 532,\n    argument_buffer_index_vignetting_pivot_crws_position            = 533,\n    argument_buffer_index_crws_reference_position                   = 534,\n\n    argument_buffer_index_render_options             = 550,\n    argument_buffer_index_breakthrough_read_index    = 551,\n\n    argument_buffer_index_fade_opacity               = 553,\n    argument_buffer_index_clipping_index_slice       = 554,\n    argument_buffer_index_portal_plane               = 556,\n    argument_buffer_index_env_lighting_weight        = 557,\n    argument_buffer_index_breakthrough_ui_breakthrough_enabled   = 558,\n    argument_buffer_index_breakthrough_ui_breakthrough_influence = 559,\n    argument_buffer_index_breakthrough_texture_array = 570,\n    argument_buffer_index_breakthrough_gpu_data      = 571\n} argument_buffer_index;\n\nstruct global_constants {\n\n    float     dt;\n    float     time;\n\n#ifdef __METAL_VERSION__\n\n    constant IBLConstants& ibl              [[ id(argument_buffer_index_ibl) ]];\n    constant LightConstantBuffer& lights    [[ id(argument_buffer_index_lights) ]];\n    constant rasterization_rate_map_data& vrr_map [[ id(argument_buffer_index_vrr_map)]];\n\n#if 1 \n    texturecube<half> irradiance            [[ id(argument_buffer_index_irradiance) ]];\n    texturecube<half> radiance              [[ id(argument_buffer_index_radiance) ]];\n    texture2d<half> brdfLUT                 [[ id(argument_buffer_index_brdfLUT) ]];\n    depth2d<float> shadowMap                [[ id(argument_buffer_index_shadowMap) ]];\n    texture2d<half> ssaoTex                 [[ id(argument_buffer_index_ssao) ]];\n    constant VoxelDataUniforms& voxelUni    [[ id(argument_buffer_index_voxel_data) ]];\n    texture3d<half> scattTex                [[ id(argument_buffer_index_gi_tex) ]];\n#else\n    uint64_t irradiance;\n    uint64_t radiance;\n    uint64_t brdfLUT;\n    uint64_t shadowMap;\n    uint64_t ssaoTex;\n    uint64_t voxelUni;\n    uint64_t scattTex;\n#endif\n#endif\n};\n\n#define VFX_CORE_UNIFORMS_CAMERA_COUNT 2\n\nstruct view_constants {\n\n    matrix_float4x4 view_from_crworld[VFX_CORE_UNIFORMS_CAMERA_COUNT];   \n    matrix_float4x4 proj_from_crworld[VFX_CORE_UNIFORMS_CAMERA_COUNT];   \n    matrix_float4x4 proj_from_view[VFX_CORE_UNIFORMS_CAMERA_COUNT];      \n    matrix_float4x4 view_from_proj[VFX_CORE_UNIFORMS_CAMERA_COUNT];      \n\n    \n    simd_float3     crws_camera_pos[VFX_CORE_UNIFORMS_CAMERA_COUNT];     \n\n    \n    \n\n    matrix_float4x4 inverseViewProjectionMatrix;\n    \n    \n    \n    \n    \n    \n    matrix_float4x4 crInverseViewProjectionMatrix; \n\n    \n    \n    \n    \n    \n    \n    \n    matrix_float4x4 crws_from_viewport[VFX_CORE_UNIFORMS_CAMERA_COUNT];\n\n    \n    \n    \n    \n    simd_float3     worldReferencePosition; \n\n    \n    simd_float4     renderTargetSize;\n    \n    uint32_t        cameraCount;\n    \n    \n    uint32_t        useVertexAmplification;\n\n    \n    simd_float4     ndcFromScreen; \n    simd_float2     nearFar;\n    \n    \n    \n    \n    simd_float2     linearizationFactors;\n\n    uint32_t        padding;     \n    float           fadeOpacity;\n\n    simd_int2       renderTargetDepthStencilFormatSampleCount;\n    simd_float4     vrrMapPhysicalSizeArray[VFX_CORE_UNIFORMS_CAMERA_COUNT];\n    \n    \n    simd_float4     viewport_percents[VFX_CORE_UNIFORMS_CAMERA_COUNT];\n    \n    simd_float4     vrrMapScreenSize;\n\n    simd_float4     portal_clip_plane_deprecated;\n\n    matrix_float4x4 lastframe_proj_from_crworld[VFX_CORE_UNIFORMS_CAMERA_COUNT];   \n\n    \n    simd_float3      fogParameters; \n\n#ifdef __METAL_VERSION__\n    simd_half4       fogColor;\n#else\n    simd_short4      fogColor;\n#endif\n};\n\n\n\n\nstruct object_constants {\n    matrix_float4x4 world_from_local;\n    \n    \n    float world_uniform_scale;\n};\n\n#ifdef __METAL_VERSION__\n#define VFX_ABID(a) [[ id(a) ]]\n#else\n#define VFX_ABID(a)\n#endif\n\nstruct external_scene_constants {\n    float portal_opacity                                VFX_ABID(argument_buffer_index_portal_opacity);\n    vfx_half vignetting_fadeout_distance_normalization  VFX_ABID(argument_buffer_index_vignetting_fadeout_distance_normalization);\n    vfx_half vignetting_total_fadeout_distance          VFX_ABID(argument_buffer_index_vignetting_total_fadeout_distance);\n    simd_float3 vignetting_pivot_crws_position          VFX_ABID(argument_buffer_index_vignetting_pivot_crws_position);\n    simd_float3 crws_reference_position                 VFX_ABID(argument_buffer_index_crws_reference_position);\n};\n\nstruct external_entity_constants {\n    uint16_t render_options                             VFX_ABID(argument_buffer_index_render_options);\n\n    uint8_t breakthrough_read_index                     VFX_ABID(argument_buffer_index_breakthrough_read_index);\n    uint8_t padding;\n    float fade_opacity                                  VFX_ABID(argument_buffer_index_fade_opacity);\n    VFX_RE_C_ClippingIndexSlice clipping_index_slice    VFX_ABID(argument_buffer_index_clipping_index_slice);\n\n    simd_float4 portal_plane                            VFX_ABID(argument_buffer_index_portal_plane);\n    float environment_lighting_weight                   VFX_ABID(argument_buffer_index_env_lighting_weight);\n\n    bool bt_ui_breakthrough_enabled                     VFX_ABID(argument_buffer_index_breakthrough_ui_breakthrough_enabled);\n    vfx_half bt_ui_breakthrough_influence               VFX_ABID(argument_buffer_index_breakthrough_ui_breakthrough_influence);\n\n#ifdef __METAL_VERSION__\n    texture2d_array<half> breakthroughTextureArray  [[ id(argument_buffer_index_breakthrough_texture_array) ]];\n    constant BreakthroughGPUData* breakthroughData  [[ id(argument_buffer_index_breakthrough_gpu_data) ]];\n#endif\n};\n\n#ifdef __METAL_VERSION__\nconstant int kMaxProbeSources = 2;\n#endif\n\nstruct external_scene_buffers {\n#ifdef __METAL_VERSION__\n    constant ProbeConstantBuffer& probes            [[ id(argument_buffer_index_env_probe_constants) ]];\n    texturecube_array<half> envProbeCubeArray       [[ id(argument_buffer_index_env_probe_cube_array) ]];\n    texturecube_array<half> envProbeDiffuseArray    [[ id(argument_buffer_index_env_probe_diffuse_array) ]];\n    texture2d_array<half> envProbeTextureArray      [[ id(argument_buffer_index_env_probe_texture_array) ]];\n    texture2d<half> textureSpecMaxEss               [[ id(argument_buffer_index_spec_max_ess_map) ]];\n    constant half* specMaxEssAvgTable               [[ id(argument_buffer_index_spec_max_ess_avg_table) ]];\n\n    constant ClippingConstants& clippingConstants   [[ id(argument_buffer_index_clipping_constants) ]];\n    texture2d<half> blueNoiseTexture                [[ id(argument_buffer_index_blue_noise_texture) ]];\n\n    texture2d_array<half> breakthroughTextureArray_deprecated  [[ id(argument_buffer_index_breakthrough_texture_array_deprecated) ]]; \n\n    metal::texturecube<half> envProbeCube           [[ id(argument_buffer_index_env_probe_cube) ]];\n    metal::texturecube<half> envProbeDiffuse        [[ id(argument_buffer_index_env_probe_diffuse) ]];\n\n    texturecube<half> blendIrradiance               [[ id(argument_buffer_index_blend_irradiance) ]];\n    texturecube<half> blendRadiance                 [[ id(argument_buffer_index_blend_radiance) ]];\n\n    texture1d<half> ispTonemapLUT                   [[ id(argument_buffer_index_isp_tonemap_lut) ]];\n    texture2d<half> textureFilter                   [[ id(argument_buffer_index_texture_filter) ]];\n\n    constant VirtualEnvironmentProbeLighting::ProbeConstantBuffer& virtualEnvProbeConstants     [[ id(argument_buffer_index_virtual_env_probe_constants) ]];\n#if !TARGET_OS_SIMULATOR\n    constant VirtualEnvironmentProbeLighting::TextureArgumentBuffer& virtualEnvProbeTextures    [[ id(argument_buffer_index_virtual_env_probe_textures) ]];\n#endif \n#endif \n};\n\n\n\ntypedef VFX_ENUM(size_t)\n{\n    blend_mode_constants_opaque = 0,\n    blend_mode_constants_alpha = 1,\n    blend_mode_constants_additive = 2,\n    blend_mode_constants_mask = 3 \n} blend_mode_constants;\n\n\n\n\n\ntypedef VFX_ENUM(int32_t)\n{\n    mesh_constants_has_vertex_position  = 400,\n    mesh_constants_has_vertex_normal    = 401,\n    mesh_constants_has_vertex_uv0       = 402,\n    mesh_constants_has_vertex_uv1       = 403,\n    mesh_constants_has_vertex_uv2       = 404,\n    mesh_constants_has_vertex_uv3       = 405,\n    mesh_constants_has_vertex_color     = 406,\n    mesh_constants_has_vertex_tangent   = 407\n\n} mesh_constants;\n\ntypedef VFX_BINDING_ENUM\n{\n    vfx_vertex_attribute_position     = 0,\n    vfx_vertex_attribute_normal       = 1,\n    vfx_vertex_attribute_uv0          = 2,\n    vfx_vertex_attribute_uv1          = 3,\n    vfx_vertex_attribute_color        = 4,\n    vfx_vertex_attribute_tangent      = 5,\n    vfx_vertex_attribute_uv2          = 6,\n    vfx_vertex_attribute_uv3          = 7,\n    vfx_vertex_attribute_weights      = 8,\n    vfx_vertex_attribute_joints       = 9\n} vfx_vertex_attribute;\n\n\ntypedef VFX_BINDING_ENUM\n{\n    deferred_attachments_emission               = 0,\n    deferred_attachments_normal                 = 1,\n    deferred_attachments_roughness_metalness_ao = 2,\n    deferred_attachments_albedo                 = 3,\n    deferred_attachments_velocity               = 4\n} deferred_attachments;\n\n#ifdef __METAL_VERSION__\n\nconstant bool has_vertex_position       [[ function_constant(mesh_constants_has_vertex_position) ]];\nconstant bool has_vertex_normal         [[ function_constant(mesh_constants_has_vertex_normal) ]];\nconstant bool has_vertex_uv0            [[ function_constant(mesh_constants_has_vertex_uv0) ]];\nconstant bool has_vertex_uv1            [[ function_constant(mesh_constants_has_vertex_uv1) ]];\nconstant bool has_vertex_uv2            [[ function_constant(mesh_constants_has_vertex_uv2) ]];\nconstant bool has_vertex_uv3            [[ function_constant(mesh_constants_has_vertex_uv3) ]];\nconstant bool has_vertex_color          [[ function_constant(mesh_constants_has_vertex_color) ]];\nconstant bool has_vertex_tangent        [[ function_constant(mesh_constants_has_vertex_tangent) ]];\n\ntypedef struct __Vertex \n{\n    float3 position [[ attribute(vfx_vertex_attribute_position), function_constant(has_vertex_position) ]];\n    float3 normal   [[ attribute(vfx_vertex_attribute_normal), function_constant(has_vertex_normal) ]];\n    float2 uv0      [[ attribute(vfx_vertex_attribute_uv0), function_constant(has_vertex_uv0) ]];\n    float2 uv1      [[ attribute(vfx_vertex_attribute_uv1), function_constant(has_vertex_uv1) ]];\n    float2 uv2      [[ attribute(vfx_vertex_attribute_uv2), function_constant(has_vertex_uv2) ]];\n    float2 uv3      [[ attribute(vfx_vertex_attribute_uv3), function_constant(has_vertex_uv3) ]];\n    float4 color    [[ attribute(vfx_vertex_attribute_color), function_constant(has_vertex_color) ]];\n    float4 tangent  [[ attribute(vfx_vertex_attribute_tangent), function_constant(has_vertex_tangent) ]];\n\n    float3 get_position() { return has_vertex_position ? position : float3(0); }\n    float3 get_normal() { return has_vertex_normal ? normal : float3(0, 0, 1); }\n    float2 get_uv0() { return has_vertex_uv0 ? uv0 : float2(0); }\n    float2 get_uv1() { return has_vertex_uv1 ? uv1 : float2(0); }\n    float2 get_uv2() { return has_vertex_uv2 ? uv2 : float2(0); }\n    float2 get_uv3() { return has_vertex_uv3 ? uv3 : float2(0); }\n    float4 get_color() { return has_vertex_color ? color : float4(1); }\n    float4 get_tangent() { return has_vertex_tangent ? tangent : float4(0, 0, 0, 1); }\n\n} Vertex;\n\nconstant int  blending_mode              [[ function_constant(particle_constants_render_blending_mode) ]];\nconstant bool enable_texture_2d          [[ function_constant(particle_constants_render_enable_texture_2d) ]];\nconstant bool enable_texture_3d          [[ function_constant(particle_constants_render_enable_texture_3d) ]];\nconstant bool enable_texture_2d_array    [[ function_constant(particle_constants_render_enable_texture_2d_array) ]];\nconstant bool enable_texture_cube        [[ function_constant(particle_constants_render_enable_texture_cube) ]];\nconstant bool enable_texture_prelighted  [[ function_constant(particle_constants_render_enable_texture_prelighted) ]];\nconstant bool has_particle_transform     [[ function_constant(particle_constants_render_has_particle_transform) ]];\nconstant bool texture_is_not_alphapremultiplied [[ function_constant(particle_constants_render_texture_is_not_alphapremultiplied) ]];\nconstant bool has_pbr_lighting           [[ function_constant(particle_constants_render_has_pbr_lighting) ]];\nconstant bool disable_specular           [[ function_constant(particle_constants_render_disable_specular) ]];\nconstant int animation_mode              [[ function_constant(particle_constants_render_animation_mode) ]];\nconstant bool inter_frame_interpolation  [[ function_constant(particle_constants_render_inter_frame_interpolation) ]];\nconstant bool enable_cutoff              [[ function_constant(particle_constants_render_enable_cutoff) ]];\nconstant bool enable_sorting             [[ function_constant(particle_constants_render_enable_sorting) ]];\nconstant bool enable_thick_lines         [[ function_constant(particle_constants_render_enable_thick_lines) ]];\nconstant bool enable_soft_particles      [[ function_constant(particle_constants_render_enable_soft_particles) ]];\nconstant bool need_opaque_zbuffer        [[ function_constant(particle_constants_render_need_opaque_zbuffer) ]];\nconstant bool need_normal_buffer         [[ function_constant(particle_constants_render_need_normal_buffer) ]];\n\n\nconstant bool enable_scattering            [[ function_constant(particle_constants_render_enable_scattering) ]];\n\n\n\n\n\n\nconstant bool is_layered_rendering          [[ function_constant(renderer_constants_enable_layered_rendering) ]];\nconstant bool is_multi_viewport_rendering   [[ function_constant(renderer_constants_enable_multi_viewport_rendering) ]];\nconstant bool _enable_vertex_amplification  [[ function_constant(renderer_constants_enable_vertex_amplification) ]];\nconstant bool enable_vertex_amplification = is_function_constant_defined(_enable_vertex_amplification) ? _enable_vertex_amplification : false;\n\nconstant bool _use_api_v2                   [[ function_constant(renderer_constants_use_api_v2) ]];\nconstant bool use_api_v2 = is_function_constant_defined(_use_api_v2) ? _use_api_v2 : false;\nconstant bool use_api_v1 = !use_api_v2;\n\nconstant bool enable_clipping               [[ function_constant(renderer_constants_enable_clipping) ]];\nconstant bool enable_alpha_fade             [[ function_constant(renderer_constants_enable_alpha_fade) ]];\nconstant bool enable_dither_fade            [[ function_constant(renderer_constants_enable_dither_fade) ]];\nconstant bool enable_depth_mitigation       [[ function_constant(renderer_constants_enable_depth_mitigation) ]];\nconstant bool enable_sample_mask_read  = enable_dither_fade;\nconstant bool enable_sample_mask_write = enable_dither_fade;\n\nconstant bool enable_auto_alpha             [[ function_constant(renderer_constants_enable_auto_alpha) ]];\n\nconstant bool outputs_normal_roughness      [[ function_constant(renderer_constants_outputs_normal_roughness) ]];\nconstant bool outputs_albedo_metalness      [[ function_constant(renderer_constants_outputs_albedo_metalness) ]];\nconstant bool outputs_radiance_ao           [[ function_constant(renderer_constants_outputs_radiance_ao) ]];\nconstant int rendering_mode                 [[ function_constant(renderer_constants_rendering_mode) ]];\nconstant bool enable_ssao                   [[ function_constant(renderer_constants_enable_ssao) ]];\n\nconstant bool need_inter_frame_interpolation = (animation_mode != -1) && inter_frame_interpolation;\n\nconstant bool is_opaque = (blending_mode == blend_mode_constants_opaque) || (blending_mode == blend_mode_constants_mask);\nconstant bool need_worldPos = enable_scattering || has_pbr_lighting || enable_clipping;\nconstant bool need_worldNrm = has_pbr_lighting || enable_texture_cube || is_opaque;\nconstant bool need_point_coord = enable_texture_2d || enable_texture_3d || has_pbr_lighting;\nconstant bool need_box_normal = enable_texture_2d || enable_texture_3d;\n\n\nconstant bool gamma_blending             [[ function_constant(renderer_constants_gamma_blending) ]];\nconstant bool re_uniforms                [[ function_constant(renderer_constants_inside_re) ]];\n\nconstant bool vfx_uniforms = !re_uniforms;\nconstant bool use_api_v1_in_re = use_api_v1 && re_uniforms;\n\n#if VFX_RE_SHADERS_AVAILABLE\nconstant bool enable_re_pbr_lighting = re_uniforms;\n#else\nconstant bool enable_re_pbr_lighting = false;\n#endif\nconstant bool enable_env_probes = re_uniforms;\nconstant bool enable_multiscatter_brdf = re_uniforms;\nconstant bool enable_breakthrough = re_uniforms;\nconstant bool enable_nearfield_vignetting = re_uniforms;\nconstant bool enable_fog = !re_uniforms;\n\nconstant bool need_screen_uv = enable_breakthrough;\n\nconstant bool use_interpolated_crworld   [[ function_constant(renderer_constants_use_interpolated_crworld) ]];\n\nconstant bool might_use_vrr_map = false;\n\nconstant bool enable_texture_prelighted_array = enable_texture_prelighted && enable_texture_2d_array;\nconstant bool enable_texture_prelighted_2d = enable_texture_prelighted && !enable_texture_2d_array;\n\nconstant bool uniform_sphere = has_size1D && !has_particle_transform;\nconstant bool non_uniform_sphere = !uniform_sphere;\n\n#if TARGET_OS_VISION\nconstant bool enable_depth_as_color = re_uniforms;\n#else\nconstant bool enable_depth_as_color = false;\n#endif\n\n#endif\n"
+ "#import <metal_stdlib>\nusing namespace metal;\n\n"
+ "#import <simd/simd.h>\n#import \"vfx_base.h\"\n#import \"vfx_math.h\"\n\n\n#ifdef __METAL_VERSION__\n#define vfx_binding_index int32_t\n#define VFX_PARTICLE_INVALID UINT_MAX\ntypedef uint32_t vfx_script_particle_index_t;\n#else\n\n#define vfx_binding_index size_t\n#define VFX_PARTICLE_INVALID UINT64_MAX\n#import <stdbool.h>\n#import <stddef.h>\n#endif\n\n#define VFX_BINDING_ENUM VFX_ENUM(vfx_binding_index)\n\n\n\n#ifndef USE_LINKED_FUNCTIONS\n#  define USE_LINKED_FUNCTIONS 1\n#endif\n\n\nstruct frame_constants {\n    float     dt;\n    float     time;\n    bool      isFirstFrame;\n    uint32_t  simulationIndex;\n};\n\ntypedef VFX_BINDING_ENUM\n{\n    \n    vfx_buffer_binding_index_compute_spawn_id              = 0,\n    vfx_buffer_binding_index_compute_uniforms             = 1,\n    vfx_buffer_binding_index_compute_extra_buffer         = 6, \n    \n    \n    vfx_buffer_binding_index_particle_header              = 4,\n    vfx_buffer_binding_index_particle_data                = 5,\n    \n    \n    vfx_buffer_binding_index_global_constants             = 0,\n    vfx_buffer_binding_index_view_constants               = 1,\n    vfx_buffer_binding_index_material_constants           = 2,\n    \n    vfx_buffer_binding_index_sdf_debug_data               = 2,\n    vfx_buffer_binding_index_voxel_debug_data             = 2,\n\n    vfx_buffer_binding_index_scattering                   = 3,\n    vfx_buffer_binding_index_object_constants             = 3,\n    \n    vfx_buffer_binding_index_instance_transforms          = 4,\n    vfx_buffer_binding_index_instance_colors              = 5,\n\n    vfx_buffer_binding_index_light_matrix                 = 5,\n    vfx_buffer_binding_index_pass_constants               = 6,\n    vfx_buffer_binding_index_instance_clipping            = 7,\n\n    vfx_buffer_binding_index_ribbon_profile               = 8,\n    \n    vfx_buffer_binding_index_data_sort_order              = 9,\n    vfx_buffer_binding_index_external_scene_constants     = 10,\n    vfx_buffer_binding_index_external_scene_buffers       = 11,\n    vfx_buffer_binding_index_external_entity_constants    = 12,\n    vfx_buffer_binding_index_data_prev_next               = 13,\n    vfx_buffer_binding_index_virtual_env_probe_textures   = 14,\n\n    vfx_buffer_binding_index_re_entity_constants          = 15,\n    vfx_buffer_binding_index_re_view_constants            = 16,\n    vfx_buffer_binding_index_re_global_constants          = 17,\n    vfx_buffer_binding_index_re_entity_argument_buffer    = 18,\n    vfx_buffer_binding_index_re_scene_argument_buffer     = 19,\n    vfx_buffer_binding_index_re_vfx_object_constants      = 20,\n#if TARGET_OS_SIMULATOR\n    vfx_buffer_binding_index_virtual_env_probe_textures_sim = 21,\n#endif\n    \n    \n    vfx_buffer_binding_index_voxel_cone_tracing           = 3,\n    vfx_buffer_binding_index_voxel_lod                    = 4,\n    vfx_buffer_binding_index_voxel_inv_size               = 5,\n    \n    vfx_buffer_binding_index_voxel_data                   = 22,\n    vfx_buffer_binding_index_voxel_uniforms               = 23,\n    vfx_buffer_binding_index_voxel_matrix                 = 24,\n\n} vfx_buffer_binding_index;\n\ntypedef VFX_BINDING_ENUM\n{\n    vfx_texture_binding_index_main                          = 0,\n    vfx_texture_binding_index_linear_zbuffer                = 1,\n    vfx_texture_binding_index_gi_tex                        = 2,\n    \n    vfx_texture_binding_index_opaque_zbuffer                = 9,\n    vfx_texture_binding_index_normal_buffer                 = 10,\n\n    vfx_texture_binding_index_voxel                         = 11,\n\n    vfx_texture_binding_index_noise_3d                      = 11, \n\n    vfx_texture_binding_index_blue_noise_dithering          = 13,\n    vfx_texture_binding_index_depth_mitigation_alpha_mask   = 14,\n} vfx_texture_binding_index;\n\ntypedef VFX_BINDING_ENUM\n{\n    vfx_sampler_binding_index_main                   = 0,\n} vfx_sampler_binding_index;\n\n\ntypedef VFX_ENUM(int8_t)\n{\n    particle_data_index_counters              = 0,\n\n    particle_data_index_positions             = 4,\n    particle_data_index_colors                = 5,\n    particle_data_index_velocities            = 6,\n    particle_data_index_sizes                 = 7,\n    particle_data_index_orientations          = 8,\n    \n    particle_data_index_ages                  = 10,\n    particle_data_index_frames                = 11,\n    particle_data_index_angles                = 12,\n    particle_data_index_pivots                = 13,\n    particle_data_index_targets               = 14,\n    particle_data_index_masses                = 15,\n    particle_data_index_user_data1s           = 16,\n    particle_data_index_user_data2s           = 17,\n    particle_data_index_user_data3s           = 18,\n    particle_data_index_user_data4s           = 19,\n    particle_data_index_lifetimes             = 20,\n    particle_data_index_parent_ids            = 21,\n    particle_data_index_roughness             = 22,\n    particle_data_index_metalness             = 23,\n    particle_data_index_emission              = 24,\n    particle_data_index_ribbon_lengths        = 25,\n    particle_data_index_angular_velocities    = 26,\n    particle_data_index_angle_velocities      = 27,\n    particle_data_index_linear_factors        = 28,\n    particle_data_index_angular_factors       = 29,\n    particle_data_index_ids                   = 30,\n    particle_data_index_index_from_id         = 31,\n    particle_data_index_free_ids              = 32,\n    particle_data_index_neighbor_grid_heads   = 33,\n    particle_data_index_neighbor_grid_nexts   = 34,\n    particle_data_index_max_count             = 35\n} particle_data_index;\n\ntypedef VFX_ENUM(int32_t)\n{\n    renderer_constants_gamma_blending = 450,\n    renderer_constants_inside_re = 451,\n    renderer_constants_enable_clipping = 452,\n    renderer_constants_enable_dither_fade = 453,\n\n    renderer_constants_enable_alpha_fade = 455,\n    renderer_constants_enable_depth_mitigation = 456,\n    renderer_constants_enable_auto_alpha = 457,\n    renderer_constants_use_interpolated_crworld = 458,\n    renderer_constants_enable_layered_rendering = 459,\n    renderer_constants_enable_multi_viewport_rendering = 460,\n    \n    renderer_constants_outputs_normal_roughness = 461,\n    renderer_constants_rendering_mode = 462,\n\n    renderer_constants_enable_portal_clip_plane = 463,\n    renderer_constants_enable_vertex_amplification = 464,\n    renderer_constants_enable_ssao = 465,\n    renderer_constants_outputs_albedo_metalness = 466,\n    renderer_constants_outputs_radiance_ao = 467,\n    renderer_constants_use_api_v2 = 468\n} renderer_constants;\n\n\ntypedef VFX_ENUM(int32_t)\n{\n    \n    \n\n    particle_constants_has_velocity         = 500,  \n\n    particle_constants_has_age              = 501,\n\n    particle_constants_has_lifetime         = 502,\n    particle_constants_uniform_lifetime     = 503,\n\n    particle_constants_has_color            = 504,\n\n    particle_constants_has_orientation      = 506,\n    particle_constants_has_angular_velocity = 507,\n\n    \n    particle_constants_has_angle            = 508,\n    particle_constants_has_angle_velocity   = 509,\n\n    particle_constants_has_pivot            = 510,\n    particle_constants_has_target           = 511,\n    particle_constants_has_mass             = 512,\n    particle_constants_has_texture_frame    = 513,\n\n    particle_constants_has_linear_factor    = 514,\n\n    particle_constants_has_angular_factor   = 515,\n\n    particle_constants_has_ribbon_length    = 516,\n\n    particle_constants_has_user_data1       = 517,\n    particle_constants_has_user_data2       = 518,\n    particle_constants_has_user_data3       = 519,\n    particle_constants_has_user_data4       = 520,\n\n    particle_constants_has_size1D           = 521,\n    particle_constants_has_size2D           = 522,\n    particle_constants_has_size3D           = 523,\n    particle_constants_use_half_size        = 524,\n\n    particle_constants_is_local             = 526,\n\n    particle_constants_has_particle_id      = 527,\n    particle_constants_has_parent_id        = 528,\n\n    \n    \n\n    particle_constants_size_over_life_mode  = 530, \n\n    particle_constants_drag_use_size,\n\n    particle_constants_attach_use_over_life,\n\n    particle_constants_noise_use_transform,\n\n    particle_constants_plane_collider_infinite,\n    \n    particle_constants_plane_collider_sphere,\n    \n    particle_constants_plane_collider_double_sided,\n\n    particle_constants_enable_gravity,\n\n    particle_constants_box_collider_inside,\n\n    particle_constants_force_field_kind,\n\n    \n    \n\n    particle_constants_emitter_shape_type  = 540, \n    particle_constants_emitter_shape_distribution, \n    particle_constants_emitter_shape_orientation, \n    particle_constants_emitter_shape_direction, \n    particle_constants_emitter_shape_has_texture_2D,\n\n    particle_constants_emitter_pointcache_inherit_position = 550,\n    particle_constants_emitter_pointcache_inherit_color,\n    particle_constants_emitter_pointcache_inherit_velocity,\n    particle_constants_emitter_pointcache_inherit_orientation,\n    particle_constants_emitter_pointcache_inherit_size,\n    particle_constants_emitter_pointcache_has_transform,\n    particle_constants_emitter_pointcache_init_stage,\n\n    particle_constants_set_color_mode = 560,\n\n    \n    particle_constants_render_blending_mode = 600,\n    particle_constants_render_enable_texture_2d = 601,\n    particle_constants_render_enable_texture_3d = 602,\n    particle_constants_render_enable_texture_2d_array = 603,\n    particle_constants_render_enable_texture_cube = 604,\n    particle_constants_render_enable_texture_prelighted = 605,\n    particle_constants_render_texture_is_not_alphapremultiplied = 606,\n    particle_constants_render_texture_channel = 607,\n    particle_constants_render_local_transform_LEGACY = 608,\n    particle_constants_render_has_particle_transform = 609,\n    particle_constants_render_has_pbr_lighting = 610,\n    particle_constants_render_disable_specular = 611,\n    particle_constants_render_animation_mode = 612,\n    particle_constants_render_inter_frame_interpolation = 613,\n    particle_constants_render_enable_scattering = 614,\n    particle_constants_render_orientation_mode = 615,\n    particle_constants_render_shape_mode = 616,\n\n    particle_constants_render_enable_cutoff = 618,\n    particle_constants_render_enable_sorting = 619,\n    particle_constants_render_enable_thick_lines = 620,\n    particle_constants_render_enable_soft_particles,\n    particle_constants_render_need_opaque_zbuffer,\n    particle_constants_render_need_normal_buffer,\n    particle_constants_render_voxelDataChannelCount,\n    particle_constants_render_voxelizeOpacity = 625,\n    particle_constants_render_voxelizeColor,\n    particle_constants_render_enable_per_vertex_color = 627,\n\n\n\n\n\n    particle_constants_has_ribbon_cap_begin_texture = 633,\n    particle_constants_has_ribbon_cap_end_texture = 634,\n    particle_constants_render_use_particle_orientation_for_lighting = 635\n\n} particle_constants;\n\n\ntypedef VFX_ENUM(int16_t)\n{\n    particle_data_type_float = 3,\n    particle_data_type_float2 = 4,\n    particle_data_type_float3 = 5,\n    particle_data_type_float4 = 6,\n\n    particle_data_type_int  = 29,\n    particle_data_type_int2 = 30,\n    particle_data_type_int3 = 31,\n    particle_data_type_int4 = 32,\n    \n    particle_data_type_uint  = 33,\n    particle_data_type_uint2 = 34,\n    particle_data_type_uint3 = 35,\n    particle_data_type_uint4 = 36,\n    \n} particle_data_type;\n\ntypedef struct {\n    int32_t offset;\n    int16_t type; \n    int16_t stride;\n} particle_data_description;\n\nstruct particle_data_header {\n    particle_data_description descriptions[particle_data_index_max_count];\n};\n\n#ifdef __METAL_VERSION__\n\n\n\n\n\nconstant bool has_velocity              [[ function_constant(particle_constants_has_velocity) ]];\n\nconstant bool has_age                   [[ function_constant(particle_constants_has_age) ]];\n\nconstant bool has_lifetime              [[ function_constant(particle_constants_has_lifetime) ]];\n\nconstant bool has_color                 [[ function_constant(particle_constants_has_color) ]];\n\nconstant bool has_orientation           [[ function_constant(particle_constants_has_orientation) ]];\nconstant bool has_angular_velocity      [[ function_constant(particle_constants_has_angular_velocity) ]];\n\nconstant bool has_angle                 [[ function_constant(particle_constants_has_angle) ]];\nconstant bool has_angle_velocity        [[ function_constant(particle_constants_has_angle_velocity) ]];\n\nconstant bool has_texture_frame         [[ function_constant(particle_constants_has_texture_frame) ]];\n\nconstant bool has_particle_id           [[ function_constant(particle_constants_has_particle_id) ]];\nconstant bool has_parent_id             [[ function_constant(particle_constants_has_parent_id) ]];\n\nconstant bool has_user_data1            [[ function_constant(particle_constants_has_user_data1) ]];\nconstant bool has_user_data2            [[ function_constant(particle_constants_has_user_data2) ]];\nconstant bool has_user_data3            [[ function_constant(particle_constants_has_user_data3) ]];\nconstant bool has_user_data4            [[ function_constant(particle_constants_has_user_data4) ]];\n\nconstant bool has_size1D                [[ function_constant(particle_constants_has_size1D) ]];\nconstant bool has_size2D                [[ function_constant(particle_constants_has_size2D) ]];\nconstant bool has_size3D                [[ function_constant(particle_constants_has_size3D) ]];\nconstant bool use_half_size             [[ function_constant(particle_constants_use_half_size) ]];\n\nconstant bool has_linear_factor         [[ function_constant(particle_constants_has_linear_factor) ]];\n\nconstant bool has_angular_factor        [[ function_constant(particle_constants_has_angular_factor) ]];\n\nconstant bool has_ribbon_length         [[ function_constant(particle_constants_has_ribbon_length) ]];\n\nconstant bool has_ribbon_cap_begin_texture [[ function_constant(particle_constants_has_ribbon_cap_begin_texture) ]];\nconstant bool has_ribbon_cap_end_texture   [[ function_constant(particle_constants_has_ribbon_cap_end_texture) ]];\nconstant bool has_ribbon_caps_textures     = has_ribbon_cap_begin_texture || has_ribbon_cap_end_texture;\n\nconstant bool has_pivot                 [[ function_constant(particle_constants_has_pivot) ]];\n\nconstant bool has_target                [[ function_constant(particle_constants_has_target) ]];\n\nconstant bool has_mass                  [[ function_constant(particle_constants_has_mass) ]];\n\nconstant bool is_local                  [[ function_constant(particle_constants_is_local) ]];\n\n#endif \n\n\n#define MAX_SPAWNID 16\n\nNS_ASSUME_NONNULL_BEGIN\n\ntypedef struct {\n    uint32_t threadgroupsPerGrid[3];\n} DispatchThreadgroupsIndirectArguments;\n\n\nstruct particle_counters {\n    uint32_t  active_count;\n#ifdef __METAL_VERSION__\n    atomic_uint  dead_count;\n    atomic_uint  live_count;\n#else\n    uint32_t  dead_count;\n    uint32_t  live_count;\n#endif\n    uint32_t  added_count;\n    uint32_t  generated_count;\n    uint32_t  allocated_count;\n   \n    uint32_t  current_seed;\n    \n    uint32_t visible_count;         \n    \n    simd_float4x4 world_from_emitter;    \n    \n    DispatchThreadgroupsIndirectArguments active_dispatch_args;\n    DispatchThreadgroupsIndirectArguments newly_created_dispatch_args;\n\n    bool     has_transient_color;\n    bool     has_transient_size;\n    \n    \n    bool has_spawn_id;\n    uint32_t spawn_id_offsets[MAX_SPAWNID];\n    uint32_t spawn_id_counts[MAX_SPAWNID];\n    \n    uint32_t spawn_id_added_count[MAX_SPAWNID];\n    uint32_t spawn_id_previous_offsets[MAX_SPAWNID];\n    \n#ifdef __METAL_VERSION__\n    atomic_uint  spawn_id_dead_count[MAX_SPAWNID];\n    atomic_uint  spawn_id_live_count[MAX_SPAWNID];\n#else\n    uint32_t  spawn_id_dead_count[MAX_SPAWNID];\n    uint32_t  spawn_id_live_count[MAX_SPAWNID];\n#endif\n    \n    DispatchThreadgroupsIndirectArguments spawn_id_active_dispatch_args[MAX_SPAWNID];\n    DispatchThreadgroupsIndirectArguments spawn_id_newly_created_dispatch_args[MAX_SPAWNID];\n    \n    uint32_t  free_ids_count;\n    \n    \n    bool has_neighbor_grid;\n    simd_uint3 grid_dimensions;\n    simd_float3 grid_origin;\n    float grid_cell_size;\n    simd_uint3 grid_cell_stride;\n    uint32_t max_neighbors_per_cell;\n\n\n#ifdef __METAL_VERSION__\n    uint32_t get_active_count() device {\n        return active_count;\n    }\n    \n    void set_active_count(uint32_t v) device {\n        active_count = v;\n    }\n\n    uint32_t get_live_count() device {\n        return atomic_load_explicit(&live_count, memory_order_relaxed);\n    }\n\n    void set_live_count(uint32_t v) device {\n        atomic_store_explicit(&live_count, v, memory_order_relaxed);\n    }\n\n    uint32_t get_dead_count() device {\n        return atomic_load_explicit(&dead_count, memory_order_relaxed);\n    }\n    \n    void set_dead_count(uint32_t v) device {\n        atomic_store_explicit(&dead_count, v, memory_order_relaxed);\n    }\n\n    uint32_t get_added_count() device {\n        return added_count; \n    }\n    \n    void set_added_count(uint32_t v) device {\n        added_count = v; \n    }\n    \n    uint32_t get_generated_count() device {\n        return generated_count;\n    }\n\n    void add_generated_count(uint32_t v) device {\n        generated_count += v;\n    }\n    \n    void set_generated_count(uint32_t v) device {\n        generated_count = v;\n    }\n    \n    uint32_t get_allocated_count() device {\n        return allocated_count;\n    }\n    \n    void set_allocated_count(uint32_t v) device {\n        allocated_count = v;\n    }\n    \n    uint32_t get_free_ids_count() device {\n        return free_ids_count;\n    }\n    \n    void set_free_ids_count(uint32_t v) device {\n        free_ids_count = v;\n    }\n\n    uint32_t get_current_seed() device {\n        return current_seed;\n    }\n    \n    void set_current_seed(uint32_t v) device {\n        current_seed = v;\n    }\n    \n    uint32_t get_visible_count() device {\n        return visible_count;\n    }\n    \n    void set_visible_count(uint32_t v) device {\n        visible_count = v;\n    }\n\n    uint32_t increment_live_count() device {\n        return atomic_fetch_add_explicit(&live_count, 1, memory_order_relaxed);\n    }\n\n    uint32_t increment_dead_count() device {\n        return atomic_fetch_add_explicit(&dead_count, 1, memory_order_relaxed);\n    }\n\n    bool is_outside(uint index) device {\n        return index >= active_count;\n    }\n    \n    bool is_outside(thread uint* index, int spawnid) device {\n        if (spawnid == -1){\n            return is_outside(*index);\n        } else {\n            if (*index >= spawn_id_counts[spawnid]) return true;\n            *index += spawn_id_offsets[spawnid];\n            return false;\n        }\n    }\n    \n    uint index_from_added(uint index) device {\n        uint added_start = active_count - added_count;\n        return index + added_start;\n    }\n\n    bool newly_created_is_outside(thread uint* index) device {\n        if (*index >= added_count) return true;\n        \n        uint added_start = active_count - added_count;\n        *index += added_start;\n        return false;\n    }\n    \n    bool newly_created_is_outside(thread uint* index, int spawnid) device {\n        if(spawnid == -1) {\n            return newly_created_is_outside(index);\n        } else {\n            if (*index >= spawn_id_added_count[spawnid]) return true;\n            \n            uint added_start = spawn_id_offsets[spawnid] + spawn_id_counts[spawnid] - spawn_id_added_count[spawnid];\n            *index += added_start;\n            return false;\n        }\n    }\n    \n    \n    uint32_t get_live_count_spawn_id(uint spawnid) device {\n        return atomic_load_explicit(&spawn_id_live_count[spawnid], memory_order_relaxed);\n    }\n\n    void set_live_count_spawn_id(uint32_t v, uint spawnid) device {\n        atomic_store_explicit(&spawn_id_live_count[spawnid], v, memory_order_relaxed);\n    }\n\n    uint32_t get_dead_count_spawn_id(uint spawnid) device {\n        return atomic_load_explicit(&spawn_id_dead_count[spawnid], memory_order_relaxed);\n    }\n    \n    void set_dead_count_spawn_id(uint32_t v, uint spawnid) device {\n        atomic_store_explicit(&spawn_id_dead_count[spawnid], v, memory_order_relaxed);\n    }\n    \n    uint32_t increment_live_count_spawn_id(uint spawnid) device {\n        return atomic_fetch_add_explicit(&spawn_id_live_count[spawnid], 1, memory_order_relaxed);\n    }\n\n    uint32_t increment_dead_count_spawn_id(uint spawnid) device {\n        return atomic_fetch_add_explicit(&spawn_id_dead_count[spawnid], 1, memory_order_relaxed);\n    }\n\n    int32_t get_spawn_id(uint index) device {\n        for (int i = 1; i < MAX_SPAWNID; i++){\n            if(index < spawn_id_offsets[i]){\n                return i - 1;\n            }\n        }\n        return MAX_SPAWNID - 1;\n    }\n    \n    \n    int32_t get_spawn_id_if_present(uint index, int32_t dispatch_spawn_id) device {\n        int32_t sid;\n        if (!has_spawn_id) {\n            return -1;\n        } else {\n            sid = dispatch_spawn_id != -1 ? dispatch_spawn_id : get_spawn_id(index);\n        }\n        return sid == MAX_SPAWNID - 1 ? -1 : sid;\n    }\n    \n    \n    uint3 get_grid_dimensions(){\n        return grid_dimensions;\n    }\n    \n    uint32_t get_grid_cell_count() device {\n        return grid_dimensions.x * grid_dimensions.y * grid_dimensions.z;\n    }\n    \n    \n\n#endif \n};\n\n#ifdef __METAL_VERSION__\n\n\n\n#define DEFAULT_POSITION float3(0.f)\n#define DEFAULT_VELOCITY float3(0.f)\n#define DEFAULT_AGE 0.f\n#define DEFAULT_LIFETIME 1.f\n#define DEFAULT_COLOR float4(1.f)\n#define DEFAULT_COLOR_H half4(1.h)\n#define DEFAULT_ORIENTATION vfx_float4_unit_w()\n#define DEFAULT_ANGULAR_VELOCITY 0.f\n#define DEFAULT_ANGLE 0.f\n#define DEFAULT_ANGLE_VELOCITY 0.f\n#define DEFAULT_TEXTURE_FRAME 0.f\n#define DEFAULT_SIZE 1.0f\n#define DEFAULT_LINEAR_FACTOR 1.f\n#define DEFAULT_ANGULAR_FACTOR 1.f\n#define DEFAULT_PIVOT 0x80808080\n#define DEFAULT_PIVOT_F float3(0.5f) \n#define DEFAULT_TARGET 0.f\n#define DEFAULT_MASS 1.f\n#define DEFAULT_ROUGHNESS 0.5f\n#define DEFAULT_METALNESS 0.f\n#define DEFAULT_EMISSION 0.f\n#define DEFAULT_USER_DATA 0.f\n\n#define is_defined_and_true(a) (is_function_constant_defined(a) && a)\n\n#define has_data(fc, index) (is_function_constant_defined(fc) ? fc : has(index))\n\n#define get_data_u(fc, index, def) has_data(fc, index) ? get_uint32(index)[pid] : def;\n#define get_data_i(fc, index, def) has_data(fc, index) ? get_int32(index)[pid] : def;\n#define get_data_f(fc, index, def) has_data(fc, index) ? get_float(index)[pid] : def;\n#define get_data_f2(fc, index, def) has_data(fc, index) ? get_float2(index)[pid] : def;\n#define get_data_f3(fc, index, def) has_data(fc, index) ? get_float3(index)[pid] : def;\n#define get_data_f4(fc, index, def) has_data(fc, index) ? get_float4(index)[pid] : def;\n\n#define set_data_u(fc, index, val) if (has_data(fc, index)) { get_uint32(index)[pid] = val; }\n#define set_data_i(fc, index, val) if (has_data(fc, index)) { get_int32(index)[pid] = val; }\n#define set_data_f(fc, index, val) if (has_data(fc, index)) { get_float(index)[pid] = val; }\n#define set_data_f2(fc, index, val) if (has_data(fc, index)) { get_float2(index)[pid] = val; }\n#define set_data_f3(fc, index, val) if (has_data(fc, index)) { get_float3(index)[pid] = val; }\n#define set_data_f4(fc, index, val) if (has_data(fc, index)) { get_float4(index)[pid] = val; }\n\nstruct particle_data {\nprivate:\n    constant particle_data_header& particle_header;\n    device const uint8_t* data;\n    \npublic:\n    device particle_counters* counters() const {\n        \n        particle_data_description desc = particle_header.descriptions[ particle_data_index_counters ];\n        return (device particle_counters *)(data + desc.offset);\n    }\n\n    particle_data(constant particle_data_header& particle_header,\n                  device const uint8_t* data)\n    : particle_header(particle_header), data(data)\n    {\n    }\n    \n    \n\n    uint32_t get_active_count() const { return counters()->get_active_count(); }\n    void set_active_count(uint32_t v) { counters()->set_active_count(v); }\n\n    uint32_t get_live_count() { return counters()->get_live_count(); }\n    void set_live_count(uint32_t v) { counters()->set_live_count(v); }\n\n    uint32_t get_added_count() { return counters()->get_added_count(); }\n    void set_added_count(uint32_t v) { counters()->set_added_count(v); }\n\n    uint32_t get_dead_count() { return counters()->get_dead_count(); }\n    void set_dead_count(uint32_t v) { counters()->set_dead_count(v); }\n\n    uint32_t get_generated_count() { return counters()->get_generated_count(); }\n    void add_generated_count(uint32_t v) { counters()->add_generated_count(v); }\n    \n    uint32_t get_allocated_count() { return counters()->get_allocated_count(); }\n    void set_allocated_count(uint32_t v) { counters()->set_allocated_count(v); }\n    \n    uint32_t get_current_seed() { return counters()->get_current_seed(); }\n    void set_current_seed(uint32_t v) { counters()->set_current_seed(v); }\n    \n    uint32_t get_visible_count() const { return counters()->get_visible_count(); }\n    void set_visible_count(uint32_t v) { counters()->set_visible_count(v); }\n\n    uint32_t increment_live_count() { return counters()->increment_live_count(); }\n    uint32_t increment_dead_count() { return counters()->increment_dead_count(); }\n\n    bool is_outside(uint index) const { return counters()->is_outside(index); }\n    bool is_outside(thread uint* index, int spawnid) { return counters()->is_outside(index, spawnid); }\n    uint index_from_added(uint index) { return counters()->index_from_added(index); }\n    bool newly_created_is_outside(thread uint* index) { return counters()->newly_created_is_outside(index); }\n    bool newly_created_is_outside(thread uint* index, int spawnid) { return counters()->newly_created_is_outside(index, spawnid); }\n    int32_t get_spawn_id(uint index){ return counters()->get_spawn_id(index); }\n    int32_t get_spawn_id_if_present(uint index, int32_t dispatch_spawn_id){ return counters()->get_spawn_id_if_present(index, dispatch_spawn_id); }\n\n    float4x4 world_from_emitter() { return counters()->world_from_emitter; }\n    float3 emitter_scale() { return vfx_get_scale(world_from_emitter()); }\n    float4 emitter_orientation() { return vfx_quat_(world_from_emitter()); }\n\n    \n\n    uint32_t init_kernel_seed(uint32_t kernel_offset, uint32_t particle_offset) {\n        return counters()->get_current_seed() + kernel_offset + particle_offset;\n    }\n    uint32_t get_seed(int pid) {\n        return init_kernel_seed(0, pid);\n    }\n    \n    \n\n    device uint32_t* get_uint32(int data_index) const {\n        particle_data_description desc = particle_header.descriptions[ data_index ];\n        return (device uint32_t *)(data + desc.offset);\n    }\n    \n    device atomic_uint* get_atomic_uint(int data_index) const {\n        particle_data_description desc = particle_header.descriptions[ data_index ];\n        return (device atomic_uint *)(data + desc.offset);\n    }\n    \n    device int32_t* get_int32(int data_index) const {\n        particle_data_description desc = particle_header.descriptions[ data_index ];\n        return (device int32_t *)(data + desc.offset);\n    }\n\n    device float* get_float(int data_index) const {\n        particle_data_description desc = particle_header.descriptions[ data_index ];\n        return (device float *)(data + desc.offset);\n    }\n\n    device float2* get_float2(int data_index) const {\n        particle_data_description desc = particle_header.descriptions[ data_index ];\n        return (device float2 *)(data + desc.offset);\n    }\n\n    device float3* get_float3(int data_index) const {\n        particle_data_description desc = particle_header.descriptions[ data_index ];\n        return (device float3 *)(data + desc.offset);\n    }\n\n    device float4* get_float4(int data_index) const {\n        particle_data_description desc = particle_header.descriptions[ data_index ];\n        return (device float4 *)(data + desc.offset);\n    }\n\n    \n    \n    bool has(int data_index) const {\n        return particle_header.descriptions[ data_index ].offset > 0;\n    }\n    \n    bool has(int data_index, int16_t type) const {\n        particle_data_description desc = particle_header.descriptions[ data_index ];\n        return desc.offset > 0 && desc.type == type;\n    }\n\n    \n\n    float3 get_position(int pid) const {\n        return get_float3(particle_data_index_positions)[pid];\n    }\n\n    void set_position(int pid, float3 v) {\n        get_float3(particle_data_index_positions)[pid] = v;\n    }\n\n    float3 get_velocity(int pid) const {\n        return get_data_f3(has_velocity, particle_data_index_velocities, DEFAULT_VELOCITY);\n    }\n\n    void set_velocity(int pid, float3 v) {\n        set_data_f3(has_velocity, particle_data_index_velocities, v);\n    }\n\n    float4 get_color(int pid) const {\n        return get_data_f4(has_color, particle_data_index_colors, DEFAULT_COLOR);\n    }\n\n    half4 get_color_as_half(int pid) const {\n        half4 color = half4(get_color(pid));\n        color.a = saturate(color.a);\n        return color;\n    }\n\n    void set_color(int pid, float4 v) {\n        set_data_f4(has_color, particle_data_index_colors, v);\n    }\n\n    float2 get_ribbon_length(int pid) const {\n        return get_data_f2(has_ribbon_length, particle_data_index_ribbon_lengths, 0.f);\n    }\n\n    void set_ribbon_length(int pid, float2 v) {\n        set_data_f2(has_ribbon_length, particle_data_index_ribbon_lengths, v);\n    }\n\n    float3 get_size(uint pid) const {\n        \n        if (is_defined_and_true(has_size3D)) {\n            return get_float3(particle_data_index_sizes)[ pid ];\n        } else if (is_defined_and_true(has_size2D)) {\n            return float3(get_float2(particle_data_index_sizes)[ pid ], 0.001f); \n        } else if (is_defined_and_true(has_size1D)) {\n            return float3(get_float(particle_data_index_sizes)[ pid ]);\n        }\n        \n        particle_data_description desc = particle_header.descriptions[ particle_data_index_sizes ];\n        if (desc.offset > 0) {\n            switch (desc.type) {\n                case particle_data_type_float3: \n                    return get_float3(particle_data_index_sizes)[ pid ];\n                case particle_data_type_float2: \n                    return float3(get_float2(particle_data_index_sizes)[ pid ], 0.001f);\n                case particle_data_type_float: \n                    return float3(get_float(particle_data_index_sizes)[ pid ]);\n            }\n        }\n        return DEFAULT_SIZE;\n    }\n\n    void set_size(int pid, float3 v) {\n        \n        if (is_defined_and_true(has_size3D)) {\n            get_float3(particle_data_index_sizes)[ pid ] = v;\n        } else if (is_defined_and_true(has_size2D)) {\n            get_float2(particle_data_index_sizes)[ pid ] = v.xy;\n        } else if (is_defined_and_true(has_size1D)) {\n            get_float(particle_data_index_sizes)[ pid ] = v.x;\n        } else {\n            \n            particle_data_description desc = particle_header.descriptions[ particle_data_index_sizes ];\n            if (desc.offset > 0) {\n                switch (desc.type) {\n                    case particle_data_type_float3:\n                        get_float3(particle_data_index_sizes)[ pid ] = v;\n                        break;\n                    case particle_data_type_float2:\n                        get_float2(particle_data_index_sizes)[ pid ] = v.xy;\n                        break;\n                    case particle_data_type_float:\n                        get_float(particle_data_index_sizes)[ pid ] = v.x;\n                        break;\n                }\n            }\n        }\n    }\n\n    float2 get_size2D(uint pid) const {\n        return get_size(pid).xy;\n    }\n\n    void set_size2D(uint pid, float2 size) {\n        set_size(pid, float3(size, 1.f));\n    }\n\n    float get_size1D(uint pid) const {\n        return get_size(pid).x;\n    }\n\n    void set_size1D(uint pid, float size) {\n        set_size(pid, float3(size));\n    }\n\n    float4 get_orientation(int pid) const {\n        return get_data_f4(has_orientation, particle_data_index_orientations, DEFAULT_ORIENTATION);\n    }\n\n    void set_orientation(int pid, float4 v) {\n        set_data_f4(has_orientation, particle_data_index_orientations, v);\n    }\n\n    float4 get_angular_velocity(int pid) const {\n        return get_data_f4(has_angular_velocity, particle_data_index_angular_velocities, DEFAULT_ANGULAR_VELOCITY);\n    }\n\n    void set_angular_velocity(int pid, float4 v) {\n        set_data_f4(has_angular_velocity, particle_data_index_angular_velocities, v);\n    }\n\n    float get_angle(int pid) const {\n        return get_data_f(has_angle, particle_data_index_angles, DEFAULT_ANGLE);\n    }\n\n    void set_angle(int pid, float v) {\n        set_data_f(has_angle, particle_data_index_angles, v);\n    }\n\n    float get_angle_velocity(int pid) const {\n        return get_data_f(has_angle_velocity, particle_data_index_angle_velocities, DEFAULT_ANGLE_VELOCITY);\n    }\n\n    void set_angle_velocity(int pid, float v) {\n        set_data_f(has_angle_velocity, particle_data_index_angle_velocities, v);\n    }\n\n    \n\n    float get_age(int pid) const {\n        return get_data_f(has_age, particle_data_index_ages, DEFAULT_AGE);\n    }\n\n    void set_age(int pid, float v) {\n        set_data_f(has_age, particle_data_index_ages, v);\n    }\n\n    float get_lifetime(int pid) const {\n        return get_data_f(has_lifetime, particle_data_index_lifetimes, DEFAULT_LIFETIME);\n    }\n\n    void set_lifetime(int pid, float v) {\n        set_data_f(has_lifetime, particle_data_index_lifetimes, v);\n    }\n\n    float get_texture_frame(int pid) const {\n        return get_data_f(has_texture_frame, particle_data_index_frames, DEFAULT_TEXTURE_FRAME);\n    }\n\n    void set_texture_frame(int pid, float v) {\n        set_data_f(has_texture_frame, particle_data_index_frames, v);\n    }\n\n    float3 get_linear_factor(int pid) const {\n        return get_data_f3(has_linear_factor, particle_data_index_linear_factors, DEFAULT_LINEAR_FACTOR);\n    }\n\n    void set_linear_factor(int pid, float3 v) {\n        set_data_f3(has_linear_factor, particle_data_index_linear_factors, v);\n    }\n\n    float3 get_angular_factor(int pid) const {\n        return get_data_f3(has_angular_factor, particle_data_index_angular_factors, DEFAULT_ANGULAR_FACTOR);\n    }\n\n    void set_angular_factor(int pid, float3 v) {\n        set_data_f3(has_angular_factor, particle_data_index_angular_factors, v);\n    }\n\n    \n    float3 get_pivot(int pid) const {\n        return has_data(has_pivot, particle_data_index_pivots)\n        ? unpack_unorm4x8_to_float(get_uint32(particle_data_index_pivots)[pid]).xyz\n        : DEFAULT_PIVOT_F; \n    }\n\n    \n    void set_pivot(int pid, float3 v) {\n        uint32_t u = pack_float_to_unorm4x8(float4(v, 0.f));\n        set_data_u(has_pivot, particle_data_index_pivots, u);\n    }\n    \n    \n    float3 get_signed_pivot(int pid) const {\n        return get_pivot(pid) * 2 - 1;\n    }\n\n    float3 get_target(int pid) const {\n        return get_data_f3(has_target, particle_data_index_targets, DEFAULT_TARGET);\n    }\n\n    void set_target(int pid, float3 v) {\n        set_data_f3(has_target, particle_data_index_targets, v);\n    }\n\n    \n\n    float get_mass(int pid) const {\n        return get_data_f(has_mass, particle_data_index_masses, DEFAULT_MASS);\n    }\n\n    void set_mass(int pid, float v) {\n        set_data_f(has_mass, particle_data_index_masses, v)\n    }\n\n    uint32_t get_id(int pid) const {\n        return get_data_u(has_particle_id, particle_data_index_ids, 0);\n    }\n\n    void set_id(int pid, uint32_t v) {\n        set_data_u(has_particle_id, particle_data_index_ids, v);\n    }\n\n    uint32_t get_parent_id(int pid) const {\n        return get_data_u(has_parent_id, particle_data_index_parent_ids, 0);\n    }\n\n    void set_parent_id(int pid, uint32_t v) {\n        set_data_u(has_parent_id, particle_data_index_parent_ids, v);\n    }\n\n    float get_roughness(int pid) const {\n        return has(particle_data_index_roughness) ? get_float(particle_data_index_roughness)[pid] : DEFAULT_ROUGHNESS;\n    }\n\n    void set_roughness(int pid, float v) {\n        if (has(particle_data_index_roughness)) { get_float(particle_data_index_roughness)[pid] = v; }\n    }\n\n    float get_metalness(int pid) const {\n        return has(particle_data_index_metalness) ? get_float(particle_data_index_metalness)[pid] : DEFAULT_METALNESS;\n    }\n\n    void set_metalness(int pid, float v) {\n        if (has(particle_data_index_metalness)) { get_float(particle_data_index_metalness)[pid] = v; }\n    }\n\n    float get_emission(int pid) const {\n        return has(particle_data_index_emission) ? get_float(particle_data_index_emission)[pid] : DEFAULT_EMISSION;\n    }\n\n    void set_emission(int pid, float v) {\n        if (has(particle_data_index_emission)) { get_float(particle_data_index_emission)[pid] = v; }\n    }\n\n    float4 get_user_data1(int pid) const {\n        return get_data_f4(has_user_data1, particle_data_index_user_data1s, DEFAULT_USER_DATA);\n    }\n\n    void set_user_data1(int pid, float4 v) {\n        set_data_f4(has_user_data1, particle_data_index_user_data1s, v);\n    }\n\n    float4 get_user_data2(int pid) const {\n        return get_data_f4(has_user_data2, particle_data_index_user_data2s, DEFAULT_USER_DATA);\n    }\n\n    void set_user_data2(int pid, float4 v) {\n        set_data_f4(has_user_data2, particle_data_index_user_data2s, v);\n    }\n\n    float4 get_user_data3(int pid) const {\n        return get_data_f4(has_user_data3, particle_data_index_user_data3s, DEFAULT_USER_DATA);\n    }\n\n    void set_user_data3(int pid, float4 v) {\n        set_data_f4(has_user_data3, particle_data_index_user_data3s, v);\n    }\n\n    float4 get_user_data4(int pid) const {\n        return get_data_f4(has_user_data4, particle_data_index_user_data4s, DEFAULT_USER_DATA);\n    }\n\n    void set_user_data4(int pid, float4 v) {\n        set_data_f4(has_user_data4, particle_data_index_user_data4s, v);\n    }\n\n    uint32_t get_index_from_id(int pid) const {\n        return get_data_u(has_particle_id, particle_data_index_index_from_id, VFX_PARTICLE_INVALID);\n    }\n    \n    \n    uint32_t safe_get_index_from_id(int32_t pid) const {\n        if (pid < 0 || pid >= int(counters()->get_allocated_count())){\n            return VFX_PARTICLE_INVALID;\n        }\n        return get_data_u(has_particle_id, particle_data_index_index_from_id, VFX_PARTICLE_INVALID);\n    }\n    \n    void set_index_from_id(int pid, uint32_t index) const {\n        set_data_u(has_particle_id, particle_data_index_index_from_id, index);\n    }\n    \n    uint32_t get_free_id(int pid) const {\n        return get_data_u(has_particle_id, particle_data_index_free_ids, VFX_PARTICLE_INVALID);\n    }\n    \n    void set_free_id(int pid, uint32_t v) const {\n        set_data_u(has_particle_id, particle_data_index_free_ids, v);\n    }\n    \n    \n    \n    uint32_t get_neighbor_grid_list_head(int cell) const {\n        return (counters()->has_neighbor_grid && cell < int(counters()->get_grid_cell_count())) ? get_uint32(particle_data_index_neighbor_grid_heads)[cell] : VFX_PARTICLE_INVALID;\n    }\n    \n    void set_neighbor_grid_list_head(int cell, uint32_t v) const { \n        if (counters()->has_neighbor_grid) {\n            get_uint32(particle_data_index_neighbor_grid_heads)[cell] = v;\n        }\n    }\n    \n    uint32_t atomic_exchange_neighbor_grid_list_head(int cell, uint32_t v) const {\n        return atomic_exchange_explicit(&get_atomic_uint(particle_data_index_neighbor_grid_heads)[cell], v, memory_order_relaxed);\n    }\n    \n    uint32_t get_neighbor_grid_list_next(int pid) const {\n        return counters()->has_neighbor_grid ? get_uint32(particle_data_index_neighbor_grid_nexts)[pid] : VFX_PARTICLE_INVALID;\n    }\n    \n    void set_neighbor_grid_list_next(int pid, uint32_t v) const {\n        if (counters()->has_neighbor_grid) {\n            get_uint32(particle_data_index_neighbor_grid_nexts)[pid] = v;\n        }\n    }\n    \n    uint3 pos_to_cell_3d(simd_float3 pos) const {\n        int3 grid_dim = int3(counters()->grid_dimensions);\n        return uint3((int3(floor((pos - counters()->grid_origin) / counters()->grid_cell_size)) % grid_dim + grid_dim) % grid_dim);\n    }\n    \n    uint32_t cell_3d_to_cell_index(uint3 cell_3d) const {\n        uint3 cell = cell_3d * counters()->grid_cell_stride;\n        return cell.x + cell.y + cell.z;\n    }\n    \n    uint32_t pos_to_cell_index(simd_float3 pos) const {\n        return cell_3d_to_cell_index(pos_to_cell_3d(pos));\n    }\n    \n    bool particle_index_is_valid(uint32_t index) const {\n        return index < get_active_count();\n    }\n    \n    void get_27_neighboring_cells_lists(simd_float3 pos, thread uint32_t* cell_lists) const{\n        uint3 cell_3d = pos_to_cell_3d(pos);\n        int3 grid_dim = int3(counters()->grid_dimensions);\n        \n        \n        constexpr int3 cell_offsets[13] = {\n            { 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 },\n            {-1, 1, 0 }, {-1, 0, 1 }, { 1, 1, 0 }, { 1, 0, 1 }, { 0,-1, 1 }, { 0, 1, 1 },\n            {-1,-1, 1 }, { 1,-1, 1 }, {-1, 1, 1 }, { 1, 1, 1 }\n        };\n        \n        \n        \n        cell_lists[0] = get_neighbor_grid_list_head(cell_3d_to_cell_index(cell_3d));\n        int index = 1;\n        \n        for(int i = 0; i < 13; i++){\n            uint3 current_cell = uint3(((int3(cell_3d) + cell_offsets[i]) % grid_dim + grid_dim) % grid_dim);\n            cell_lists[index] = get_neighbor_grid_list_head(cell_3d_to_cell_index(current_cell));\n            index++;\n            current_cell = uint3(((int3(cell_3d) - cell_offsets[i]) % grid_dim + grid_dim) % grid_dim);\n            cell_lists[index] = get_neighbor_grid_list_head(cell_3d_to_cell_index(current_cell));\n            index++;\n        }\n    }\n    \n    uint32_t get_neighbors_in_radius(simd_float3 pos, float radius, uint32_t max_neighbor_count, thread uint32_t* neighbors) const {\n        \n        \n        for(uint i = 0; i < max_neighbor_count; i++){\n            neighbors[i] = VFX_PARTICLE_INVALID;\n        }\n        \n        if(!counters()->has_neighbor_grid) return 0; \n        \n        uint32_t cell_lists[27];\n        \n        get_27_neighboring_cells_lists(pos, cell_lists);\n        \n        \n        uint neighbor_count = 0;\n        float squared_radius = vfx_pow2(min(radius, counters()->grid_cell_size));\n        \n        for(int cell = 0; cell < 27; cell++){\n            uint32_t particle_index = cell_lists[cell];\n            for(uint i = 0; i < counters()->max_neighbors_per_cell; i++){\n                \n                if(particle_index != VFX_PARTICLE_INVALID){\n                    \n                    float3 their_pos = get_position(particle_index);\n                    float3 diff = their_pos - pos;\n                    float squared_dist = dot(diff, diff);\n                    \n                    if(squared_dist < squared_radius){\n                        neighbors[neighbor_count] = particle_index;\n                        neighbor_count++;\n                        if(neighbor_count >= max_neighbor_count){\n                            break;\n                        }\n                    }\n                } else {\n                    break;\n                }\n                particle_index = get_neighbor_grid_list_next(particle_index);\n            }\n        }\n        \n        \n        return neighbor_count;\n    }\n    \n    uint32_t get_nearest_neighbor_in_radius(simd_float3 pos, float radius) const {\n        \n        if(!counters()->has_neighbor_grid) return VFX_PARTICLE_INVALID; \n            \n        uint32_t cell_lists[27];\n        \n        get_27_neighboring_cells_lists(pos, cell_lists);\n            \n        uint32_t closest = VFX_PARTICLE_INVALID;\n        float min_squared_dist = MAXFLOAT;\n            \n        float squared_radius = vfx_pow2(min(radius, counters()->grid_cell_size));\n        \n        for(int cell = 0; cell < 27; cell++){\n            uint32_t particle_index = cell_lists[cell];\n            for(uint i = 0; i < counters()->max_neighbors_per_cell; i++){\n                if(particle_index != VFX_PARTICLE_INVALID){\n                    \n                    float3 their_pos = get_position(particle_index);\n                    float3 diff = their_pos - pos;\n                    float squared_dist = dot(diff, diff);\n                    \n                    if(squared_dist < min_squared_dist && squared_dist < squared_radius){\n                        closest = particle_index;\n                        min_squared_dist = squared_dist;\n                    }\n                } else {\n                    break;\n                }\n                particle_index = get_neighbor_grid_list_next(particle_index);\n            }\n        }\n\n        return closest;\n    }\n    \n    \n    \n    \n    float4x4 get_transform(int pid) const {\n        float3 pos = get_position(pid);\n        float4 ori = get_orientation(pid);\n        float3 scl = get_size(pid);\n        float4x4 emitter_from_particle = vfx_make_transform(ori, float4(pos, 1), scl);\n        if (has_pivot) {\n            float3 pvt = get_signed_pivot(pid);\n            emitter_from_particle = emitter_from_particle * vfx_make_translation(float4(-pvt, 1));\n        }\n        return emitter_from_particle;\n    }\n    \n    float4x4 get_world_transform(int pid) {\n        return counters()->world_from_emitter * get_transform(pid);\n    }\n    \n    half3 get_rme(int pid) const {\n        return half3(get_roughness(pid), get_metalness(pid), get_emission(pid));\n    }\n\n};\n\ntemplate <int B = 4>\nstruct particle_data_attachment {\n    constant particle_data_header& particle_header    [[ buffer(B) ]];\n    device const uint8_t* data                        [[ buffer(B+1) ]];\n    \n    particle_data unwrap() {\n            return particle_data(particle_header, data);\n    }\n};\n\n#endif\n\ntypedef struct\n{\n    int resolution;\n    float edgeAtt;\n    simd_float4 worldPosSize;\n    simd_float4 scaleBiasNrm; \n    simd_float4 scaleBiasTex; \n\n    float worldCellSize;\n    float invWorldCellSize;\n\n    simd_float2 opacityScaleBias;\n    simd_float2 colorScaleBias;\n\n    int frameCount;\n} VoxelDataUniforms;\n\nNS_ASSUME_NONNULL_END\n"
+ "#pragma mark - Includes begin"
+ "#pragma mark - Includes end"
+ "#pragma mark - Namespace Begin"
+ "#pragma mark - Namespace End"
+ "#pragma once\n\n#import \"vfx_render.h\"\n\n#ifdef __METAL_VERSION__\n\nnamespace vfx {\n\nstruct PreintegratedBrdf;\nstruct MultiscatterBrdf;\n\nconstant bool kEnableAreaLight = false; \n\nstruct EnvironmentProbeTextures {\n    metal::texturecube_array<half> cubeArray;\n    metal::texturecube_array<half> diffuseArray;\n    metal::texturecube<half> cube;\n    metal::texturecube<half> diffuse;\n    metal::texture2d_array<half> textureArray;\n};\n\nstruct LightingTextures {\n    texturecube<half> texturePrefilteredDiffuse;\n    texturecube<half> texturePrefilteredSpecular;\n    texturecube<half> texturePrefilteredBlendDiffuse;\n    texturecube<half> texturePrefilteredBlendSpecular;\n\n    EnvironmentProbeTextures envProbeTextures;\n    constant VirtualEnvironmentProbeLighting::TextureArgumentBuffer* virtualProbeTextures = nullptr;\n\n    texture1d<half> ispTonemapLUT;\n    texture2d<half> brdfLUT;\n    texture2d<half> specMaxEssMap;\n\n    depth2d<float> shadowMap;\n\n    texture2d<half> textureFilter;\n    texture2d_array<half> textureAreaLightMaps [[function_constant(kEnableAreaLight)]];\n};\n\nstruct LightingBuffers {\n    constant LightConstantBuffer& lightConstants;\n    constant IBLConstants& iblConstants;\n    constant ProbeConstantBuffer& envProbeTable;\n    constant VirtualEnvironmentProbeLighting::ProbeConstantBuffer& virtualProbeConstants;\n    constant half* specMaxEssAvgTable;\n};\n\nstruct EnvironmentLightingFeatures {\n    bool enableIBL = false;\n    bool enableAREnvProbes = false;\n    bool enableVirtualEnvProbes = false;\n    bool enableIBLBlending = false;\n    bool enableAnalyticLights = false;\n};\n\nstruct GeometryLightingParameters {\n    float3 crwsPosition;\n    float3 tangent;\n    float3 bitangent;\n    float3 normal;\n};\n\nstruct MaterialLightingParameters {\n    half3 baseColor;\n    half metallic;\n    half specular;\n    half roughness;\n    half ambientOcclusion;\n};\n\nnamespace api_re {\n\nfloat computeClippingOpacity(float3 crWorldPosition,\n                             ClippingIndexSlice clippingIndexSlice,\n                             constant const ClippingConstants& clippingConstants);\n\nhalf computeBreakthroughOpacity(texture2d_array<half> breakthrough,\n                                constant BreakthroughGPUData *breakthroughData,\n                                float3 crwsPosition,\n                                ushort entityFocusLevel);\n\nhalf computeBreakthroughOpacityLegacy(texture2d_array<half> breakthrough,\n                                      uint8_t textureReadIndex,\n                                      bool uiBreakthroughEnabled,\n                                      half uiBreakthroughInfluence,\n                                      float2 uv,\n                                      uint viewportIndex);\n\nhalf computeNearFieldVignettingFactor(float3 crworldSpacePosition,\n                                      float3 centerOfHeadCrworldSpacePosition,\n                                      half vignettingFadeoutDistanceNormalization,\n                                      half vignettingTotalFadeoutDistance);\n\nuint applyDithering(float opacity,\n                    float4 screenPosition,\n                    texture2d<half> blueNoiseTexture,\n                    uint sampleMask);\n\nhalf3 calculateLighting(thread const LightingTextures& textures,\n                        thread const LightingBuffers& buffers,\n                        thread const GeometryLightingParameters& geom,\n                        thread const MaterialLightingParameters& mat,\n                        float environmentLightingWeight,\n                        float3 worldPosition,\n                        float3 crwsCameraPosition,\n                        EnvironmentLightingFeatures features);\n\n}} \n\n#endif \n"
+ "#undef %@\n"
+ "$options['kHitTestCategoryBitMask'] = %4;\nconst %r0 = vfx_script_js_hit_test(%script_context, %0, $options);"
+ "$options['kHitTestCategoryBitMask'] = %6;\nconst %r0 = vfx_script_js_ray_test(%script_context, %1, %2, $options);"
+ "$options['kHitTestRootNode'] = %3;"
+ "$options['kHitTestRootNode'] = %5;"
+ "$subgraph_outputs"
+ "%0"
+ "%0 != VFX_PARTICLE_INVALID"
+ "%0 + %node_id_hash + %2"
+ "%0 + %node_id_hash + %2 + "
+ "%0 + %node_id_hash + %2 + %param0"
+ "%0.get_active_count()"
+ "%0.get_nearest_neighbor_in_radius(%1, %2)"
+ "%0.map((x,i) => "
+ "%0.safe_get_index_from_id(%1)"
+ "%1 !== 0 ? int(%0 / %1) : 0"
+ "%1 >= 0 && %1 < "
+ "%3 >= 0 && %3 < $childCount"
+ "%@ [%d]"
+ "%@%@%@%@"
+ "%@|SF:%@|DF:%@PASS:%@ read:%x write:%x"
+ "%f %f %f"
+ "%range.x + float("
+ "%script_context.simulationIndex"
+ "%{public}s"
+ "' because of its vector arguments.\nAdd the selector to vfx_objc_get_invocation_shim."
+ "' is never published"
+ "' needs to be added to vfx_script_objc.h."
+ "(%0 * VFX_PI) / "
+ "(%0 / VFX_PI) * "
+ "(%0 >= %1) && (%0 <= %2)"
+ "(%0, %1), %1 != "
+ "(%script_context, $keypath, %"
+ "(%script_context, &$keypath, %"
+ "((a,b)=>Math.sqrt(a.map((x,i)=>(x-b[i])**2).reduce((sum,x)=>sum+x)))"
+ "((a,b)=>a.length==b.length&&a.every((e,i)=>(e===b[i])))("
+ "((a,b)=>a.map((x,i)=>(x-b[i])**2).reduce((sum,x)=>sum+x))"
+ "((a,b)=>b!==0?(a%b+b)%b:0)"
+ "((a,b)=>b!==0?a%b:0)"
+ "((e,x)=>x<e?0:1)"
+ "(CFX::RG::ExternalResourceDesc){\n"
+ "(CFXComparisonFunc)func < kCFXComparisonFuncCount"
+ "(CFXStencilOp)op < kCFXStencilOpCount"
+ "(CFXTextureDescriptor){\n"
+ "(elementCount > 1) == (osdRuntimeData->patchRangesTable != nullptr)"
+ "(q=>vfx_is_almost_equal4(q, float4(0,0,0,1)))"
+ "(size % CFXVMAlignmentSize()) == 0"
+ "(v=>Math.sqrt(vfx_dot4(v,v)))"
+ "(v=>v.reduce((sum,x)=>sum*x))"
+ "(v=>v.reduce((sum,x)=>sum+x))"
+ "(x=>Math.pow(2,x))"
+ "(x=>x.map(v=>v*v).reduce((s,x)=>s+x))"
+ "));\n"
+ "),\n"
+ ");\n"
+ ");\nauto %r1 = vfx_script_get_hand_data_tracked(%script_context, "
+ ")]>"
+ "++copy_pass_count;\n"
+ "+0"
+ ",\n"
+ ", "
+ ", $neighbors);\nvfx_script_buffer %r0 = vfx_script_buffer { $neighbors, $count };"
+ ", %0 / %1, %1 != "
+ ", &$value);\n#r0=%1"
+ ", &$value);\n#r0=%2"
+ ", CFX::RG::Temporal{"
+ ", device packed_float3 const *vfx_bezier_curve_controlPoints\n"
+ ", device void const *vfx_bezier_curve_data\n"
+ ", value_type_if_dynamic: "
+ "- (void)testGeneratedRenderGraph {\n"
+ "-(vfx_cos(VFX_PI * %0) - "
+ "->commonRenderParameters().cullMode = "
+ "->commonRenderParameters().depthClipMode = "
+ "->commonRenderParameters().depthPlaneCount = "
+ "->commonRenderParameters().depthPlaneStart = "
+ "->commonRenderParameters().fillMode = "
+ "->commonRenderParameters().inverseWinding = "
+ "->commonRenderParameters().levelCount = "
+ "->commonRenderParameters().levelStart = "
+ "->commonRenderParameters().renderTargetArrayLength = "
+ "->commonRenderParameters().sliceCount = "
+ "->commonRenderParameters().sliceStart = "
+ "->commonRenderParameters().winding = "
+ "->dependsOn("
+ "->readFrom("
+ "->renderTo("
+ "->writeTo("
+ "-[VFXRenderer _discardPendingGPUFramePresentedHandlers]"
+ "-[VFXRenderer _render]"
+ "-[VFXWorld _nodeWithIndexPath:]"
+ "-[VFXWorld _setRootNode:immediate:]"
+ "-[VFXWorld assetPathResolver]"
+ "-[VFXWorld assetRegistry]"
+ "-[VFXWorld dataRepresentationWithOptions:]"
+ "-[VFXWorld defaultPointOfView]"
+ "-[VFXWorld defaultRenderGraph]"
+ "-[VFXWorld prepareForRenderer:progressHandler:]"
+ "-[VFXWorld prepareWithRenderer:]"
+ "-[VFXWorld restart]"
+ "-[VFXWorld rootNode]"
+ "-[VFXWorld setAssetPathResolver:]"
+ "-[VFXWorld setBehaviorGraph:]"
+ "-[VFXWorld setDefaultPointOfView:]"
+ "-[VFXWorld setDefaultRenderGraph:]"
+ "-[VFXWorld setRootNode:forLayer:]"
+ "-[VFXWorld setShaderCacheConfigurations:]"
+ "-[VFXWorld setValue:forUndefinedKey:]"
+ "-[VFXWorld shaderCacheConfigurations]"
+ "-[VFXWorld stateManager]"
+ "-[VFXWorld triggerManager]"
+ "-[VFXWorld valueForUndefinedKey:]"
+ "-[VFXWorld writeToURL:options:progressHandler:]"
+ ".collection cannot be used as a return type constraint."
+ ".contents"
+ ".dst = "
+ ".dstSliceOffset = "
+ ".get()"
+ ".quaternions should have been replaced before codegen"
+ ".sliceCount = "
+ ".src = "
+ ".srcSliceOffset = "
+ "/'1"
+ "// script_marker:"
+ "// script_marker:user_code_begin"
+ "///)@"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/AppleEngine/CFXCullingContext.c"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/AppleEngine/CFXEngineContext.m"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/CFXVFX/CFXCoreEntityManager.m"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/Core/CFXWorld.m"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/NewRenderer/VFXMTLLibraryManager.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/NewRenderer/VFXMTLRenderContext.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/NewRenderer/VFXMTLResourceManager+Compilation.m"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/RenderGraphV2/CRenderGraphEngineContext.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/RenderGraphV2/Passes/AuthoringPass.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/RenderGraphV2/Passes/BloomPass.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/RenderGraphV2/Passes/CompositePass.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/RenderGraphV2/Passes/CopyStereoSideBySidePass.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/RenderGraphV2/Passes/Culling.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/RenderGraphV2/Passes/CullingPass.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/RenderGraphV2/Passes/ManipulatorPass.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/RenderGraphV2/Passes/MotionBlurPass.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/RenderGraphV2/Passes/OverlayPass.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/RenderGraphV2/Passes/RemoteReplayPass.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/RenderGraphV2/Passes/RenderElementsPass.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/RenderGraphV2/Passes/RenderGraphLibrary.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/RenderGraphV2/Passes/SceneRenderer.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/RenderGraphV2/Passes/ShadowMapAtlasPass.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/CFX/Transactions/CFXTransaction.c"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/ObjC/Texture sources/Custom sources/VFXCoreAnimationSource.m"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/ObjC/VFXRenderer.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/ObjC/VFXWorld.m"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/VFXRenderGraph/GPUResourceManager.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/VFXRenderGraph/RenderGraph.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/VFXRenderGraph/RenderGraphProcessing.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/VFXRenderGraph/RenderGraphProvider.mm"
+ "/Library/Caches/com.apple.xbs/Sources/VFX/sources/VFX/Views/VFXView.m"
+ "/node-"
+ "/private/var/mobile/XcodeBuiltProducts/com.apple.VFXTemp/"
+ "/script_marker:(.*)/"
+ "0 0"
+ "0 1"
+ "1&0!0 0 0/$6"
+ "20@0:8i16"
+ "3&0!0 0"
+ "3&0!0 0 0/$6"
+ "6&0!0 0 0/$6"
+ ": makeScriptParameter: unresolved object: "
+ "::clamp_to_border"
+ ";\n"
+ ";\nvfx_msgSend<void>(%1, _sel(setStateNamed_), $name);"
+ "<%@: %p <%f,%f,%f> | meshElementIndex=%d node=%@ bone=%@>"
+ "<%p> %@ constants:%@"
+ "<%p> vert:%@ frag:%@ desc:%@"
+ "<%s %p \"%@\">"
+ "<%s %p |"
+ "<%s %p | "
+ "<%s %p | \"%@\"\n"
+ "<%s %p | \"%@\" custom, [%.3f %.3f %.3f %.3f ; %.3f %.3f %.3f %.3f ; %.3f %.3f %.3f %.3f ; %.3f %.3f %.3f %.3f]>"
+ "<%s %p | \"%@\" ortho, near:%.3f far:%.3f scale: %.3f>"
+ "<%s %p | \"%@\" persp, near:%.3f far:%.3f fov:%.3f>"
+ "<%s %p | \"%@\", "
+ "<%s %p | \"%@\">"
+ "<%s %p | %@ %d>"
+ "<%s %p | %@ %f,%f,%f>"
+ "<%s %p | %@ %f>"
+ "<%s %p | %@ %p>"
+ "<%s %p | %@ [%f %f %f %f]>"
+ "<%s %p | %@ [%f %f %f %f][%f %f %f %f][%f %f %f %f][%f %f %f %f]>"
+ "<%s %p | %@ [%f %f %f]>"
+ "<%s %p | %@ [%f %f]>"
+ "<%s %p | %@ data:(%p) mut:%d count:%ld type:%@ divisor:%d mtl:%d offset:%zu stride:%zu"
+ "<%s %p | %@ ptr:%p>"
+ "<%s %p | %d objects>"
+ "<%s %p | '%@' in '%@'>"
+ "<%s %p | '%@'>"
+ "<%s %p | Type:%@ CastsShadow(Samples:%d Cascade:%d)>"
+ "<%s %p | Type:%@>"
+ "<%s %p | ZRead:%d ZWrite:%d ZFunc:%d cull:%d fill:%d>"
+ "<%s %p | animations: %@>"
+ "<%s %p | curve segments: %d linear, %d quadratic, %d cubic>"
+ "<%s %p | entryPoint:\"%d\" flags:%x\n"
+ "<%s %p | geometry: %p\n"
+ "<%s %p | geometry:%p state:%d\n"
+ "<%s %p | name:%@ joint:%d weight:%d vertexCount:%d\n"
+ "<%s %p | skeleton:%p jointCount:%d\n"
+ "<%s %p | src:%@ [%fx%f]>"
+ "<%s %p | src:%p [%fx%f]>"
+ "<%s %p | targetCount:%d needsBlendColor:%d\n"
+ "<%s %p | type:%@ primCount:%d channels:%d indexBytes:%d offset:%d acmr:%f inst:%d dataSize:%d shared:%p>"
+ "<%s %p | type:%d>"
+ "<%s %p | vertex:`%@` fragment:`%@` macros:%@>"
+ "<%s %p>"
+ "<%s(%@) %p | \"%@\"\n"
+ "<PlayerPeer connection:"
+ "<VFXAssetNode %p: %@ - asset: %@>"
+ "<null>"
+ "@\"<CFXRemoteResourceProvider>\""
+ "@\"<MTL4Archive>\"32@0:8@\"NSURL\"16^@24"
+ "@\"<MTL4ArgumentTable>\"32@0:8@\"MTL4ArgumentTableDescriptor\"16^@24"
+ "@\"<MTL4CommandAllocator>\"16@0:8"
+ "@\"<MTL4CommandAllocator>\"32@0:8@\"MTL4CommandAllocatorDescriptor\"16^@24"
+ "@\"<MTL4CommandBuffer>\"16@0:8"
+ "@\"<MTL4CommandQueue>\"16@0:8"
+ "@\"<MTL4CommandQueue>\"32@0:8@\"MTL4CommandQueueDescriptor\"16^@24"
+ "@\"<MTL4Compiler>\"32@0:8@\"MTL4CompilerDescriptor\"16^@24"
+ "@\"<MTL4CounterHeap>\"32@0:8@\"MTL4CounterHeapDescriptor\"16^@24"
+ "@\"<MTL4PipelineDataSetSerializer>\"24@0:8@\"MTL4PipelineDataSetSerializerDescriptor\"16"
+ "@\"<MTLBuffer>\"24@0:8Q16"
+ "@\"<MTLBuffer>\"40@0:8Q16Q24q32"
+ "@\"<MTLDepthStencilState>\"25@0:8{?={?=b4b4b4b4b8b8}{?=b4b4b4b4b8b8}b7b1}16"
+ "@\"<MTLFunctionHandle>\"24@0:8@\"<MTL4BinaryFunction>\"16"
+ "@\"<MTLFunctionHandle>\"24@0:8@\"NSString\"16"
+ "@\"<MTLFunctionHandle>\"32@0:8@\"<MTL4BinaryFunction>\"16Q24"
+ "@\"<MTLFunctionHandle>\"32@0:8@\"NSString\"16Q24"
+ "@\"<MTLLibrary>\"24@0:8@\"<MTLDevice>\"16"
+ "@\"<MTLLibrary>\"8@?0"
+ "@\"<MTLRenderPipelineState>\"24@0:8Q16"
+ "@\"<MTLRenderPipelineState>\"32@0:8@\"MTL4RenderPipelineBinaryFunctionsDescriptor\"16^@24"
+ "@\"<MTLResource>\"12@?0C8"
+ "@\"<MTLSamplerState>\"24@0:8{?=b8b8b8b8b8b8b8b7b1}16"
+ "@\"<MTLTensor>\"32@0:8@\"MTLTensorDescriptor\"16^@24"
+ "@\"<MTLTensor>\"40@0:8@\"MTLTensorDescriptor\"16Q24^@32"
+ "@\"<MTLTexture>\"12@?0C8"
+ "@\"<MTLTexture>\"20@0:8C16"
+ "@\"<MTLTexture>\"24@0:8@\"MTLTextureViewDescriptor\"16"
+ "@\"<MTLTextureViewPool>\"32@0:8@\"MTLResourceViewPoolDescriptor\"16^@24"
+ "@\"<VFXAsset>\"16@0:8"
+ "@\"<VFXDrawCallContext>\""
+ "@\"<VFXGeometry>\""
+ "@\"<VFXMTLMeshlessDeformer>\""
+ "@\"<VFXMetalLibraryProvider>\""
+ "@\"<VFXParameterInfo>\"24@0:8@\"NSString\"16"
+ "@\"<VFXParameterList>\"16@0:8"
+ "@\"<VFXRenderTargetInfo>\"16@0:8"
+ "@\"<VFXState>\"16@0:8"
+ "@\"<_TtP3VFX10VFXBinding_>\"24@0:8@\"NSString\"16"
+ "@\"CAMetalDisplayLink\""
+ "@\"CAMetalDisplayLinkUpdate\""
+ "@\"CFXRemoteArgumentBufferDescriptor\"32@0:8Q16Q24"
+ "@\"CFXRemoteFunctionDescription\""
+ "@\"CFXRemoteRenderPipelineDescriptor\"24@0:8Q16"
+ "@\"JSValue\"16@?0@\"JSValue\"8"
+ "@\"JSValue\"24@?0@\"JSValue\"8@\"JSValue\"16"
+ "@\"JSValue\"32@?0@\"JSValue\"8@\"JSValue\"16@\"JSValue\"24"
+ "@\"JSValue\"40@?0@\"JSValue\"8@\"JSValue\"16@\"JSValue\"24@\"JSValue\"32"
+ "@\"JSValue\"48@?0@\"JSValue\"8@\"JSValue\"16@\"JSValue\"24@\"JSValue\"32@\"JSValue\"40"
+ "@\"MTL4PipelineDescriptor\"16@0:8"
+ "@\"MTLComputePipelineReflection\"16@0:8"
+ "@\"MTLFunctionReflection\"24@0:8@\"NSString\"16"
+ "@\"MTLRenderPipelineReflection\"16@0:8"
+ "@\"NSArray\"12@?0I8"
+ "@\"NSArray\"28@0:8@?<B@?@\"VFXAssetNode\"^B>16B24"
+ "@\"NSDate\""
+ "@\"RGCachedComputeCommandEncoder\""
+ "@\"RGCachedComputeCommandEncoder\"16@0:8"
+ "@\"RGCachedComputeCommandEncoder\"8@?0"
+ "@\"VFXAssetNode\"16@0:8"
+ "@\"VFXAssetNode\"24@0:8@\"NSString\"16"
+ "@\"VFXAssetRegistry\"16@0:8"
+ "@\"VFXConstraint\""
+ "@\"VFXDrawCall\""
+ "@\"VFXMTLMesh\"16@0:8"
+ "@\"VFXMTLREContext\""
+ "@\"VFXRendererRayMap\""
+ "@\"VFXViewConfiguration\""
+ "@\"_TtC3VFX15VFXEntityObject\""
+ "@\"_TtC3VFX16VFXMotionTracker\""
+ "@112@0:8@16{?=[8Q]QQC}24"
+ "@136@0:8{?=^{__CFXProgramHashCode}^{__CFXProgram}^{__CFString}^{__CFString}^{__CFXRenderingOverride}^{__CFXBlendStates}CCCC@QCC@{?=C@?}Q}16^{?=[8Q]QQC}128"
+ "@20@0:8C16"
+ "@24@0:8^{CGPath=}16"
+ "@24@0:8^{__CFXBezierCurveGeometry=}16"
+ "@24@0:8^{__CFXCamera={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}{?=b1b1b1b3ffff{?=[4]}{?=[4]}}fff^{__CFXCameraEffectDepthOfField}^{__CFXCameraEffectMotionBlur}^{__CFXCameraEffectGrain}^{__CFXCameraEffectExposure}^{__CFXCameraEffectToneMapping}^{__CFXCameraEffectBloom}^{__CFXCameraEffectVignetting}^{__CFXCameraEffectLensBlur}^{__CFXCameraEffectColorFringe}^{__CFXCameraEffectColorGrading}^{__CFXCameraEffectChromaticTransform}^{__CFXCameraEffectDoughnutBokeh}^{__CFXCameraEffectSSAO}b1b1b1b1{?=[4]}Q}16"
+ "@24@0:8^{__CFXConstraint={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFString}fBB{?=^?^?^?^?^?^?}^v}16"
+ "@24@0:8^{__CFXFloor={__CFXModel={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXGeometry}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}ffffifffQ}16"
+ "@24@0:8^{__CFXMaterialProperty={__CFRuntimeBase=QAQ}(?=^{__CFXImage}^{__CFXImageProxy}^{__CFXTexture}^v^v^v{CFXColor4=(?=[4f]{?=ffff})})^vq^vb8b1b4c{?=b8b8b8b8b8b8b8b7b1}^{?}fi^v}16"
+ "@24@0:8^{__CFXMeshElement={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}II^{__CFXMeshElement}CCC{?=C^{__CFData}I^I^{?}SCB}^vfff^v^{__CFXMeshSource}[2]^{?}I}16"
+ "@24@0:8^{__CFXModel={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXGeometry}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16"
+ "@24@0:8^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}16"
+ "@24@0:8^{__CFXParametricGeometry={__CFXModel={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXGeometry}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=fffffffffiiiiiiiiiiI}{?=^?^?^?^?^?^?}^{__CFData}}16"
+ "@24@0:8^{__CFXProgramHashCode={__CFRuntimeBase=QAQ}{?=[22I]SI[8I]CCCC[16{?=Cc}]{?=SCb3b2b2}b1b1b1b1b1b1b1b1b1b1b1b1b1b3b3b1b1[8c]}^{__CFString}I[2^{__CFArray}][8^{__CFString}]}16"
+ "@24@0:8^{__CFXRemoteFrameBuilder=}16"
+ "@24@0:8^{__CFXShaderModifier={__CFRuntimeBase=QAQ}^{__CFString}^{__CFString}^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}cCIII[32C]}16"
+ "@24@0:8^{__CFXShapeGeometry={__CFXModel={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXGeometry}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=Cfffif^{CGPath}^v^{CGPath}^v}^{__CFXMesh}[32C]}16"
+ "@24@0:8^{__CFXTextGeometry={__CFXShapeGeometry={__CFXModel={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXGeometry}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=Cfffif^{CGPath}^v^{CGPath}^v}^{__CFXMesh}[32C]}{?=^{__CTFrame}^v^viiBBB{CGRect={CGPoint=dd}{CGSize=dd}}}}16"
+ "@24@0:8{?=b8b8b8b8b8b8b8b7b1}16"
+ "@25@0:8{?={?=b4b4b4b4b8b8}{?=b4b4b4b4b8b8}b7b1}16"
+ "@28@?0@8B16@?<v@?@>20"
+ "@32@0:816@24"
+ "@32@0:8^{__CFXImage=}16B24C28"
+ "@32@0:8^{__CFXModel={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXGeometry}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16@24"
+ "@32@0:8^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}16^{__CFXModel={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXGeometry}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}24"
+ "@32@0:8^{__CFXRemoteFrameBuilder=}16@24"
+ "@368@0:8{?={?=^{__CFXProgramHashCode}^{__CFXProgram}^{__CFString}^{__CFString}^{__CFXRenderingOverride}^{__CFXBlendStates}CCCC@QCC@{?=C@?}Q}@{?=[8Q]QQC}^{__CFXBlendStates}[8Q]C@@@@@@@?CBBB}16"
+ "@36@0:8i16@20@28"
+ "@36@0:8r^{?=^{__CFXProgram}^{__CFXProgramHashCode}^{__CFXMaterial}^{__CFXModel}^{__CFXNode}^{__CFXGeometry}^{__CFXMeshElement}{?=[8C]}^{__CFXRenderingOverride}^IBBBBBb3}16B24*28"
+ "@36@0:8{CGSize=dd}16I32"
+ "@40@0:8@16I24^{__CFXEngineContext=}28B36"
+ "@40@0:8Q16Q24q32"
+ "@40@0:8^{__CFXEngineContext=}16@24@32"
+ "@40@0:8^{__CFXGeometry=}16^{__CFXMesh=}24@32"
+ "@40@0:8i16@20@28i36"
+ "@48@0:8@16@24@?32^@40"
+ "@48@0:8@16@24B32Q36B44"
+ "@48@0:8@16Q24@32^@40"
+ "@48@0:8^{__CFXEngineContext=}16{?=b8b8b8b8b8b8b8b7b1}24^d32^{?=BB}40"
+ "@48@0:8^{__CFXGPUDevice=}16Q24Q32@40"
+ "@48@0:8^{__CFXImageProxy={__CFRuntimeBase=QAQ}{?=^?^?^?^?}^vC}16{?=b8b8b8b8b8b8b8b7b1}24^{__CFXEngineContext=}32^B40"
+ "@48@0:8^{__CFXMaterialProperty={__CFRuntimeBase=QAQ}(?=^{__CFXImage}^{__CFXImageProxy}^{__CFXTexture}^v^v^v{CFXColor4=(?=[4f]{?=ffff})})^vq^vb8b1b4c{?=b8b8b8b8b8b8b8b7b1}^{?}fi^v}16^{__CFXEngineContext=}24^B32^B40"
+ "@48@0:8q16^B24^B32@40"
+ "@52@0:8@16@24B32@?36^@44"
+ "@52@0:8^{__CFXImage=}16{?=b8b8b8b8b8b8b8b7b1}24C32^{__CFXEngineContext=}36^B44"
+ "@56@0:8@16@24@32B40@44B52"
+ "@56@0:8^{__CFXGeometry=}16Q24C32C36@\"VFXMTLResourceManager\"40@\"<VFXMTLDeformerInitComputeContext>\"48"
+ "@56@0:8^{__CFXGeometry=}16Q24C32C36@40@48"
+ "@60@0:8@16@24B32@36@?44^@52"
+ "@60@0:8{?=^vII}16{?={?=CCCC}b16b16b16b16b16b8b8b8b4b3b2b1b1b1}32B56"
+ "@84@0:8@16@24@32@40^v48@56@64@72f80"
+ "@88@0:8^{CGPath=}16{?=[4]}24"
+ "@?24@0:8@16"
+ "ALBEDO METALNESS"
+ "AffectedByGlobalForces (Legacy)"
+ "Always"
+ "Anchored (Legacy)"
+ "Angular Velocity"
+ "ApplyCameraEffect"
+ "Area lights are not supported by particles"
+ "AreaMax"
+ "AreaMin"
+ "Array"
+ "AssertNotUndefined"
+ "Assertion '%s' failed. "
+ "Assertion '%s' failed. ApplyEffect input color must not be null"
+ "Assertion '%s' failed. Bad RE type"
+ "Assertion '%s' failed. C3DDeformerTransforms is not supported when instancing is active"
+ "Assertion '%s' failed. CFXRendererElementStoreDeallocateSpanForNodeModelLOD unexpected lod count"
+ "Assertion '%s' failed. Deformer stack failed to find buffer for shader argument \"%@\""
+ "Assertion '%s' failed. Deindexing failed - Polygon edge counts inconsistency"
+ "Assertion '%s' failed. Format is not supported"
+ "Assertion '%s' failed. Incremental kernels don't support the `positionScale` property"
+ "Assertion '%s' failed. Internal consistency error - argument buffer began but never ended"
+ "Assertion '%s' failed. Internal consistency error - unexpected sparse morph target"
+ "Assertion '%s' failed. Internal consistency error – no free index"
+ "Assertion '%s' failed. MTLRenderCommandEncoder shouldn't use both owned encoder and external encoder"
+ "Assertion '%s' failed. Meshless deformers do not support deforming normals"
+ "Assertion '%s' failed. Meshless deformers do not support deforming tangents"
+ "Assertion '%s' failed. Mismatch between DrawCall count and RendererElement count"
+ "Assertion '%s' failed. Morph target has a vertex count different from the base mesh"
+ "Assertion '%s' failed. Need a currentArgumentDescriptor"
+ "Assertion '%s' failed. Need to set the renderPipeline BEFORE setting buffers"
+ "Assertion '%s' failed. Node should been tracked by this model"
+ "Assertion '%s' failed. Node should not already been tracked by this model"
+ "Assertion '%s' failed. Only compute offsets for polygon"
+ "Assertion '%s' failed. Only implemented for VFXCore RE"
+ "Assertion '%s' failed. Presentation instance query on <%@ %p> (ref: %p) targets the wrong world %p (ref: %p) – has token for %p (%p)"
+ "Assertion '%s' failed. Raytraceable mesh must have at least one element"
+ "Assertion '%s' failed. Raytracing not supported on this device"
+ "Assertion '%s' failed. Unexpected storage mode"
+ "Assertion '%s' failed. Unsupported geometry type"
+ "Assertion '%s' failed. We expect one DrawCall per RendererElement"
+ "Assertion '%s' failed. __AllocateSpansForNodModelLOD unexpected lod count"
+ "Assertion '%s' failed. __setAxisAngleValue offset out of bounds"
+ "Assertion '%s' failed. __setEulerAngleValue offset out of bounds"
+ "Assertion '%s' failed. __setPositionValue offset out of bounds"
+ "Assertion '%s' failed. __setQuaternionValue offset out of bounds"
+ "Assertion '%s' failed. __setScaleValue offset out of bounds"
+ "Assertion '%s' failed. __setTransformValue offset out of bounds"
+ "Assertion '%s' failed. _setupRemoteResourcesRegistry called twice"
+ "Assertion '%s' failed. allocate size is 0"
+ "Assertion '%s' failed. allocation size must be multiple of page size"
+ "Assertion '%s' failed. bad size: %d != %d"
+ "Assertion '%s' failed. bufferMetadata not ready"
+ "Assertion '%s' failed. merge: src world not empty"
+ "Assertion '%s' failed. program is of wrong type"
+ "Assertion '%s' failed. read value out of bounds"
+ "Assertion '%s' failed. setBlendingDesc: index out of range"
+ "Assertion '%s' failed. should be nil"
+ "Assertion '%s' failed. unexpects array"
+ "B24@0:8^{__CFXGeometry=}16"
+ "B24@0:8^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}16"
+ "B24@?0^{__CFXShapeBoundary=^{__CFXShapeVertex}IIffffC}8^{__CFXShapeBoundary=^{__CFXShapeVertex}IIffffC}16"
+ "B36@0:8r^{?=^{__CFXProgram}^{__CFXProgramHashCode}^{__CFXMaterial}^{__CFXModel}^{__CFXNode}^{__CFXGeometry}^{__CFXMeshElement}{?=[8C]}^{__CFXRenderingOverride}^IBBBBBb3}16@24B32"
+ "B40@0:8^v16Q24@32"
+ "B48@0:8@16@24@32@40"
+ "B48@0:8^{__CFXImage=}16@24@32C40B44"
+ "B48@0:8{CGSize=dd}16d32@40"
+ "B52@0:8@16i24@28@36^@44"
+ "B56@0:8r^{?=^{__CFXProgram}^{__CFXProgramHashCode}^{__CFXMaterial}^{__CFXModel}^{__CFXNode}^{__CFXGeometry}^{__CFXMeshElement}{?=[8C]}^{__CFXRenderingOverride}^IBBBBBb3}16C24^{__CFXDeformerStack=}28^@36^{__CFXSkinner=}44i52"
+ "BackgroundIsTexture"
+ "BeginTransaction"
+ "BentNormal"
+ "BlueNoise32"
+ "BreakeeLayerTexture"
+ "BreakthroughTAAInput"
+ "Browser alreadyConnectedToEndpoint"
+ "Browser cancel connection"
+ "Browser cancelled"
+ "Browser default newState "
+ "Browser disconnecting from studio"
+ "Browser failed with "
+ "Browser newState "
+ "Browser results "
+ "BtMask"
+ "Buffer Count (private)"
+ "Buffer Count (shared)"
+ "Buffer Memory (private)"
+ "Buffer Memory (shared)"
+ "Buffers"
+ "Bug: Behavior Graph compilation failed without any diagnostics ("
+ "C24@0:8@\"<MTLTexture>\"16"
+ "C24@0:8@16"
+ "C32@0:8{?=^vII}16"
+ "CAMetalDisplayLinkDelegate"
+ "CFGetTypeID(program) == CFXProgramGetTypeID()"
+ "CFX-OpenSubdiv-Raytracing.h"
+ "CFX-OpenSubdiv-Raytracing.metal"
+ "CFXBezierCurve"
+ "CFXBezierCurveGeometry"
+ "CFXBindingWrapper"
+ "CFXBufferAllocatorPerFrame"
+ "CFXGPUDevice"
+ "CFXGeometryGetMeshElementCountForDeformerBasedDynamicMesh(geometry) == 1"
+ "CFXIndicesContentGetVertexIndicesForLinePrimitiveAtIndex"
+ "CFXIndicesContentGetVertexIndicesForTrianglePrimitiveAtIndex"
+ "CFXModel"
+ "CFXProgram"
+ "CFXProgramHashCodeEncoder"
+ "CFXRemoteArgumentBufferDescriptor"
+ "CFXRemoteArgumentEncoder"
+ "CFXRemoteFrameBuilder"
+ "CFXRemoteFunctionDescription"
+ "CFXRemoteRenderCommandEncoder"
+ "CFXRemoteRenderPipelineDescriptor"
+ "CFXRemoteRendererContext"
+ "CFXRemoteResourceProvider"
+ "CFXRenderingOverride"
+ "CFXShaderModifierArrayEncoder"
+ "CFXShaderModifierEncoder"
+ "CFXTextureAllocatorPerFrame"
+ "CFXVFXUpdateEmitterRendererElements"
+ "COLOR1"
+ "CPU "
+ "CPU Render time"
+ "CPU Update time"
+ "Can't bind default for: "
+ "Can't publish a render target"
+ "Can't use MSAA with a depth texture that only has 1 sample"
+ "Cannot add an entity object that is already in a scene"
+ "Canny"
+ "Capturing in Xcode..."
+ "ChamferBox"
+ "ClearCoatTmpOutput"
+ "ClearcoatNeedUpscale"
+ "ColorMatchingComputePipelines"
+ "ColorOverPosition (Legacy)"
+ "ColorOverTexture (Legacy)"
+ "ColorOverVelocity (Legacy)"
+ "ColorTarget(CFX::RG::AccessInfo::"
+ "CommandBuffer created and no encoding was done"
+ "CommitTransaction"
+ "Compilation in Progress : "
+ "Component TextureLoadingOptions not present"
+ "Compute kCFXModelTessellatorTypeConstrainedEdgeLength tessellation factors"
+ "ComputeNeighborGrid.CPU"
+ "ComputeNeighborGrid.GPU"
+ "ComputePipelines"
+ "ComputePipelinesWithStageDescriptor"
+ "ComputeShaderAsset"
+ "ConfiguredconnectionReady "
+ "Connection new state: "
+ "ContentsScaleFactor"
+ "Conversion"
+ "Convert texture"
+ "ConvertTransform"
+ "Converted texture"
+ "Coordinates"
+ "Copy linearize depth"
+ "Copy to publish"
+ "CopyData (Legacy)"
+ "CopyStereoSideBySidePass"
+ "Core"
+ "Could not decode acknoledgement"
+ "Could not decode configuration"
+ "Could not decode effect: "
+ "Could not encode configuration"
+ "Could not encode health"
+ "Could not encode updateEffectAcknowledgement"
+ "Could not resolve "
+ "Could not resolve None"
+ "Could not unarchive world "
+ "Could not write world to url: "
+ "Couldn't create the ColorCube buffer"
+ "Couldn't load the ColorCube data from "
+ "CubicEaseInOutNode"
+ "CubicEaseOutNode"
+ "DEPTH COPY"
+ "DOF Gather"
+ "DOF_GATHER"
+ "DOF_MAX_COC"
+ "DOMAIN_MAX %f %f %f"
+ "DOMAIN_MIN %f %f %f"
+ "DeallocNotifier"
+ "DebugDrawSystemState.IndexBuffer"
+ "DecrementClamp"
+ "DecrementWrap"
+ "DefaultTexture"
+ "DeformerStacks"
+ "Depth Of Field Mode"
+ "Depth Of Field Quality"
+ "DepthDisableReadWrite"
+ "DepthPostPassCulling"
+ "DepthStencil Count"
+ "DepthTarget(CFX::RG::AccessInfo::"
+ "Did not receive configuration"
+ "Dilate"
+ "DilateVariance"
+ "DirectLightingDenoisedDiffuse"
+ "DirectLightingDenoisedSpecular"
+ "DirectLightingReservoirBuffer"
+ "DirectLightingResolveDiffuse"
+ "DirectLightingResolveSpecular"
+ "DistanceConstraint (Legacy)"
+ "Doesn't implement code generation"
+ "DownsampleRate"
+ "DrawCall"
+ "DrawCallInternal"
+ "ESVFXctl"
+ "Easing"
+ "Emulate rate map"
+ "Equal"
+ "Erode"
+ "ErodeVariance"
+ "Error with task_info() in memoryUsageInMBytes: "
+ "Error: %@ can't provide a library for %@"
+ "Error: %@ can't provide a library hash"
+ "Error: %@ failed to create a library with error %@"
+ "Error: %s - index (%u) out of bounds (%lu)"
+ "Error: %s should only be called on a private renderer, using -[VFXRenderer _discardPendingGPUFrameCompletedHandlers] instead"
+ "Error: Argument \"%@\" : failed to write value to Metal buffer (%@)"
+ "Error: Argument \"%@\" : mismatch between the NSData and the buffer size %ld != %ld"
+ "Error: Argument \"%@\" : only NSData and NSValue are supported for shadable value storage (found \"%@\"). Please make sure that your custom shader modifier uniform types match the custom properties of the shadable object"
+ "Error: Array for material property contents must have 6 elements"
+ "Error: Builtin rayTracer rendergraph provider resolve failed: %s"
+ "Error: Builtin remote rendergraph provider resolve failed: %s"
+ "Error: CFXAnimationManagerGetTimeForNode - can't ensure animation continuity since animation manager is dead"
+ "Error: CFXAnimationToCAAnimation: unsupported animation type \"%@\""
+ "Error: CFXCoreEntityHandleCopyBindingCache - lost binding information, won't be saved"
+ "Error: CFXSkinRef internal data types have changed"
+ "Error: CFXSourceAccessorSetSource - source has insufficient data (length %zu for offset %zu) ; count capped to 0 (was %d)"
+ "Error: CFXSourceAccessorSetSource - source has insufficient data (length %zu for offset %zu, count %d and stride %zu) ; count capped to %d (was %d)"
+ "Error: CFXTransformSetValue unexpected axis component index %d"
+ "Error: CFXTransformSetValue unexpected euler component index %d"
+ "Error: CFXTransformSetValue unexpected position component index %d"
+ "Error: CFXTransformSetValue unexpected quat component index %d"
+ "Error: CFXTransformSetValue unexpected scale component index %d"
+ "Error: Can't draw primitives without a valid pass descriptor"
+ "Error: Can't render mesh without a valid pass descriptor"
+ "Error: Can't resolve external data pointer: missing metadata"
+ "Error: Can't set the bounding box of a VFXBezierCurveGeometry (readonly)"
+ "Error: Can't set the bounding box of a VFXMesh (readonly)"
+ "Error: Color matching for %@ → %@ could be done more efficiently by switching to a _sRGB variant of the MTLPixelFormat"
+ "Error: Compiler error while building render pipeline state: %@ \n"
+ "Error: Could not create texture with descriptor : %dx%d format:%lu"
+ "Error: Could not create texture with descriptor : %dx%d iosurface:%lu"
+ "Error: Data missing in external buffer"
+ "Error: Deallocating render context with %d outstanding command buffer completion handlers"
+ "Error: Deallocating render context with %d outstanding command buffer scheduling handlers"
+ "Error: Deallocating render context with %d outstanding drawable presentation handlers"
+ "Error: Deallocating render context with 1 outstanding command buffer completion handler"
+ "Error: Deallocating render context with 1 outstanding command buffer scheduling handler"
+ "Error: Deallocating render context with 1 outstanding drawable presentation handler"
+ "Error: Deindexer issue - source %p (%@) has no original data at index %u"
+ "Error: Deindexer issue - will discard face #%u of element at index %d (%p)"
+ "Error: Deindexing failed - mesh %p has no position source"
+ "Error: DrawCall already opened. Call EndDrawCall first"
+ "Error: DrawCall not opened. Call BeginDrawCall first"
+ "Error: Error importing VFX world at %@: %@"
+ "Error: Failed to archive model's custom attributes. %@ %@"
+ "Error: Failed to compile shader:\n%@"
+ "Error: Failed to compute color conversion parameters for %@ → %@"
+ "Error: Failed to convert animation"
+ "Error: Failed to create image from image source %@ (status: %d) (%@)"
+ "Error: Failed to load common profile cache library : %@"
+ "Error: Invalidating OpenSubdiv runtime data of model %@"
+ "Error: LUT data exceeds expected size\n"
+ "Error: Memory allocation failed"
+ "Error: Memory allocation failed for LUT"
+ "Error: Mesh source has invalid semantic"
+ "Error: MetalCapture: %@"
+ "Error: Missing RenderPipelineDesc for resourceID %llu"
+ "Error: Missing shadable value for parameter \"%@\" [vertex: %d fragment: %d]"
+ "Error: Missing shadable value for parameter \"%@.%@\" [vertex: %d fragment: %d]"
+ "Error: No RenderPipelineState set 1"
+ "Error: No RenderPipelineState set 2"
+ "Error: No RenderPipelineState set 3"
+ "Error: No RenderPipelineState set 4"
+ "Error: No conversion info for %@ → %@, texture will be copied"
+ "Error: Over-detach of instance %@ from world %p"
+ "Error: Remote render encoder - not implemented: device"
+ "Error: Remote render encoder - not implemented: dispatchThreadsPerTile"
+ "Error: Remote render encoder - not implemented: drawIndexedPatches 1"
+ "Error: Remote render encoder - not implemented: drawIndexedPatches 2"
+ "Error: Remote render encoder - not implemented: drawMeshThreadgroups"
+ "Error: Remote render encoder - not implemented: drawMeshThreadgroupsWithIndirectBuffer"
+ "Error: Remote render encoder - not implemented: drawMeshThreads"
+ "Error: Remote render encoder - not implemented: drawPatches"
+ "Error: Remote render encoder - not implemented: drawPatches 2"
+ "Error: Remote render encoder - not implemented: drawPrimitives 2"
+ "Error: Remote render encoder - not implemented: executeCommandsInBuffer"
+ "Error: Remote render encoder - not implemented: fragmentBufferBoundAt"
+ "Error: Remote render encoder - not implemented: insertDebugSignpost"
+ "Error: Remote render encoder - not implemented: isCullModeLocked"
+ "Error: Remote render encoder - not implemented: isFillModeLocked"
+ "Error: Remote render encoder - not implemented: label"
+ "Error: Remote render encoder - not implemented: memoryBarrierWithResources"
+ "Error: Remote render encoder - not implemented: memoryBarrierWithScope"
+ "Error: Remote render encoder - not implemented: popDebugGroup"
+ "Error: Remote render encoder - not implemented: pushDebugGroup"
+ "Error: Remote render encoder - not implemented: sampleCountersInBuffer"
+ "Error: Remote render encoder - not implemented: setBlendColorRed"
+ "Error: Remote render encoder - not implemented: setColorStoreAction"
+ "Error: Remote render encoder - not implemented: setColorStoreActionOptions"
+ "Error: Remote render encoder - not implemented: setDeferredBindingEnabled"
+ "Error: Remote render encoder - not implemented: setDepthBias"
+ "Error: Remote render encoder - not implemented: setDepthStoreAction"
+ "Error: Remote render encoder - not implemented: setDepthStoreActionOptions"
+ "Error: Remote render encoder - not implemented: setEncoder"
+ "Error: Remote render encoder - not implemented: setFragmentAccelerationStructure"
+ "Error: Remote render encoder - not implemented: setFragmentBufferOffset"
+ "Error: Remote render encoder - not implemented: setFragmentIntersectionFunctionTable"
+ "Error: Remote render encoder - not implemented: setFragmentIntersectionFunctionTables"
+ "Error: Remote render encoder - not implemented: setFragmentSamplerState"
+ "Error: Remote render encoder - not implemented: setFragmentSamplerStates"
+ "Error: Remote render encoder - not implemented: setFragmentTexture 2"
+ "Error: Remote render encoder - not implemented: setFragmentVisibleFunctionTable"
+ "Error: Remote render encoder - not implemented: setFragmentVisibleFunctionTables 2"
+ "Error: Remote render encoder - not implemented: setLabel"
+ "Error: Remote render encoder - not implemented: setLockCullMode"
+ "Error: Remote render encoder - not implemented: setLockFillMode"
+ "Error: Remote render encoder - not implemented: setMeshBuffer"
+ "Error: Remote render encoder - not implemented: setMeshBufferOffset"
+ "Error: Remote render encoder - not implemented: setMeshBuffers"
+ "Error: Remote render encoder - not implemented: setMeshBytes"
+ "Error: Remote render encoder - not implemented: setMeshSamplerState"
+ "Error: Remote render encoder - not implemented: setMeshSamplerState 2"
+ "Error: Remote render encoder - not implemented: setMeshSamplerStates 1"
+ "Error: Remote render encoder - not implemented: setMeshSamplerStates 2"
+ "Error: Remote render encoder - not implemented: setMeshTexture"
+ "Error: Remote render encoder - not implemented: setMeshTextures"
+ "Error: Remote render encoder - not implemented: setMeshTsetObjectBufferextures"
+ "Error: Remote render encoder - not implemented: setObjectBufferOffset"
+ "Error: Remote render encoder - not implemented: setObjectBuffers"
+ "Error: Remote render encoder - not implemented: setObjectBytes"
+ "Error: Remote render encoder - not implemented: setObjectSamplerState"
+ "Error: Remote render encoder - not implemented: setObjectSamplerState 2"
+ "Error: Remote render encoder - not implemented: setObjectSamplerStates"
+ "Error: Remote render encoder - not implemented: setObjectTexture"
+ "Error: Remote render encoder - not implemented: setObjectTextures"
+ "Error: Remote render encoder - not implemented: setObjectThreadgroupMemoryLength"
+ "Error: Remote render encoder - not implemented: setScissorRect"
+ "Error: Remote render encoder - not implemented: setScissorRects"
+ "Error: Remote render encoder - not implemented: setStencilReferenceValue"
+ "Error: Remote render encoder - not implemented: setStencilStoreAction"
+ "Error: Remote render encoder - not implemented: setStencilStoreActionOptions"
+ "Error: Remote render encoder - not implemented: setTessellationFactorBuffer"
+ "Error: Remote render encoder - not implemented: setTessellationFactorScale"
+ "Error: Remote render encoder - not implemented: setThreadgroupMemoryLength"
+ "Error: Remote render encoder - not implemented: setTileAccelerationStructure"
+ "Error: Remote render encoder - not implemented: setTileBuffer"
+ "Error: Remote render encoder - not implemented: setTileBufferOffset"
+ "Error: Remote render encoder - not implemented: setTileBuffers"
+ "Error: Remote render encoder - not implemented: setTileBytes"
+ "Error: Remote render encoder - not implemented: setTileIntersectionFunctionTable"
+ "Error: Remote render encoder - not implemented: setTileIntersectionFunctionTables"
+ "Error: Remote render encoder - not implemented: setTileSamplerState"
+ "Error: Remote render encoder - not implemented: setTileSamplerState 2"
+ "Error: Remote render encoder - not implemented: setTileSamplerStates"
+ "Error: Remote render encoder - not implemented: setTileSamplerStates 2"
+ "Error: Remote render encoder - not implemented: setTileTexture"
+ "Error: Remote render encoder - not implemented: setTileTextures"
+ "Error: Remote render encoder - not implemented: setTileVisibleFunctionTable"
+ "Error: Remote render encoder - not implemented: setTileVisibleFunctionTables"
+ "Error: Remote render encoder - not implemented: setVertexAccelerationStructure"
+ "Error: Remote render encoder - not implemented: setVertexAmplificationCount"
+ "Error: Remote render encoder - not implemented: setVertexBuffer"
+ "Error: Remote render encoder - not implemented: setVertexBufferOffset"
+ "Error: Remote render encoder - not implemented: setVertexBuffers 2"
+ "Error: Remote render encoder - not implemented: setVertexBytes"
+ "Error: Remote render encoder - not implemented: setVertexIntersectionFunctionTable"
+ "Error: Remote render encoder - not implemented: setVertexIntersectionFunctionTables 2"
+ "Error: Remote render encoder - not implemented: setVertexSamplerState"
+ "Error: Remote render encoder - not implemented: setVertexSamplerStates 2"
+ "Error: Remote render encoder - not implemented: setVertexSamplerStates 3"
+ "Error: Remote render encoder - not implemented: setVertexVisibleFunctionTable"
+ "Error: Remote render encoder - not implemented: setVertexVisibleFunctionTables"
+ "Error: Remote render encoder - not implemented: setViewport"
+ "Error: Remote render encoder - not implemented: setViewports"
+ "Error: Remote render encoder - not implemented: setVisibilityResultMode"
+ "Error: Remote render encoder - not implemented: textureBarrier"
+ "Error: Remote render encoder - not implemented: tileHeight"
+ "Error: Remote render encoder - not implemented: tileWidth"
+ "Error: Remote render encoder - not implemented: updateFence"
+ "Error: Remote render encoder - not implemented: useHeap 1"
+ "Error: Remote render encoder - not implemented: useHeap 2"
+ "Error: Remote render encoder - not implemented: useHeaps"
+ "Error: Remote render encoder - not implemented: useHeaps 2"
+ "Error: Remote render encoder - not implemented: useResource"
+ "Error: Remote render encoder - not implemented: useResources 1"
+ "Error: Remote render encoder - not implemented: vertexBufferBoundAt"
+ "Error: Remote render encoder - not implemented: waitForFence"
+ "Error: RemoteRenderPipelineDesc %@ already registered with resourceID %llu"
+ "Error: Support for LUT 1D disabled"
+ "Error: Unable to perform metal capture if environment variable MTL_CAPTURE_ENABLED != 1"
+ "Error: Unknown geometry class \"%@\""
+ "Error: Unsupported coder class %@ for material property contents %@"
+ "Error: Unsupported coder for material property contents %@"
+ "Error: Unsupported command. Aborting draw"
+ "Error: Unsupported moprher geometry \"%@\""
+ "Error: VFX could not attribute memory (mach_memory_entry_ownership failed)"
+ "Error: VFXDecodeImage: invalid archive"
+ "Error: VFXMTLRenderContext - no renderPipelineForResourceID. no descriptor registered"
+ "Error: VFXMTLRenderContext initWithDevice : commandQueue.device should the same as device"
+ "Error: VFXMTLRenderContext initWithEngineContext : gpuDevice should not be nil"
+ "Error: We did not succeed in locating all the joints, so do not update the model as it might be worse if we use the wrong bones."
+ "Error: [SceneKit import] Material \"%@\" uses unsupported transparency mode (`SCNTransparencyModeRGBZero`) for %@"
+ "Error: [SceneKit import] Unnamed source material property"
+ "Error: [SceneKit import] Unsupported class (%@) for `transparency` property"
+ "Error: [SceneKit import] Unsupported shadable class (%@) uses `#pragma transparent`"
+ "Error: [SceneKit import] VFXMeshPrimitiveTypeFromSCNPrimitiveType - unknown type"
+ "Error: [SceneKit import] VFXMeshSourceSemanticFromSCNSemantic - unknown semantic"
+ "Error: _CFXMeshElementEditorIncreaseBytesPerIndexIfNeeded unknown bytes per index"
+ "Error: _CFXSkinnerUpdateBoundingBox - skinned node has no mesh"
+ "Error: _CFXSkinnerUpdateBoundingBox - skinned node has no position source"
+ "Error: __MeshComputeBoundingBoxForMeshElementAtIndex - element has insufficient data (length %zu for count %d and stride %zu) ; count capped to %d (was %d)"
+ "Error: __MeshComputeBoundingBoxForMeshElementAtIndex - index (%u) out of bounds (%u)"
+ "Error: __validateIndexInContent - index (%u) out of bounds (%lu)"
+ "Error: assets referencing scene graph node: %@"
+ "Error: calling %s on presentation instance"
+ "Error: can't create a skinner with no base geometry"
+ "Error: cannot handle more than one fragment modifier"
+ "Error: cannot handle more than one geometry modifier"
+ "Error: cannot handle more than one surface modifier"
+ "Error: deformer: missing dependency0"
+ "Error: deformer: missing dependency1"
+ "Error: exception decoding unsecure object for key: %@"
+ "Error: eyeSight node already has an authoring node - skip"
+ "Error: failed decoding bindings %@: %@"
+ "Error: failed decoding state items %@: %@"
+ "Error: failed to assign animation with keypath %@"
+ "Error: failed to remap authoring graph"
+ "Error: hashCodeForSource - unexpected type in macros"
+ "Error: incorrect buffer size for attachments vertex [%d] fragments [%d]. Expected:%d Provided:%d"
+ "Error: invalid model detected - skip CFXCreateTangentsWithMeshOptimized"
+ "Error: invalid wrapS value: %d"
+ "Error: invalid wrapT value: %d"
+ "Error: missing LUT texture"
+ "Error: modifying beginTime of implicit transaction. Missing transaction begin?"
+ "Error: patching invalid duplicated core entity handle for %@"
+ "Error: remapped object has no identifier"
+ "Error: renderPipelineDesc has not been registered"
+ "Error: renderPipelineState has not been registered"
+ "Error: setBlendInDuration is deprecated"
+ "Error: setBlendOutDuration is deprecated"
+ "Error: trying to merge a null world"
+ "Error: unexpected blending desc buffer length"
+ "Error: unknown base type - can't allocate value"
+ "Expected RemotePreviewPlayerPeerConnection: "
+ "Expected RemotePreviewStudioPeerConnection"
+ "Expected endpoint"
+ "Expects filter height greater than 0"
+ "Expects filter width greater than 0"
+ "ExponentialEaseNode"
+ "Fail compiling pipeline state: "
+ "Failed compiling computePipeline hash"
+ "Failed compiling renderPipeline hash"
+ "Failed to create blit command encoder"
+ "Failed to create render command encoder"
+ "Failed to decode MTLVertexDescriptor: "
+ "Failed to encode MTLVertexDescriptor: "
+ "Failed to move to XcodeBuiltProducts "
+ "Failed to send configuration to VFX Studio"
+ "Failed to send health to VFX Studio "
+ "Failed to send updateEffectAcknowledgement to VFX Studio "
+ "Failed to wait for cache entry "
+ "Filter height must be odd"
+ "Filter width must be odd"
+ "Flattened"
+ "Flow"
+ "Fog End Distance"
+ "Fog Start Distance"
+ "FragmentShaderAsset"
+ "FrustumCullPerParticle"
+ "GPU "
+ "GPU requires constant emitter"
+ "GPUDevice"
+ "Gaussian"
+ "GetNearestNeighborInRadius"
+ "GetNeighborsInRadius"
+ "GetParticleCollision"
+ "GetParticleCount"
+ "GetParticleIndex"
+ "GetPresentationObject"
+ "GetResolvedVariable"
+ "GetTransformNormal"
+ "GetTransformPosition"
+ "Global"
+ "Graph Editor: unable to find template matching "
+ "Greater"
+ "GreaterEqual"
+ "Growing Emitter (Legacy)"
+ "HasBackground"
+ "HasDOF"
+ "HasDirectLightings"
+ "HasFog"
+ "HasIBL"
+ "HasIndirectClearcoat"
+ "HasIndirectDiffuse"
+ "HasIndirectSpecular"
+ "HasSubsurface"
+ "HasTransmission"
+ "Hit error writing "
+ "HybridRenderer input transmission"
+ "IES lights are not supported by particles"
+ "IESTextures"
+ "IOPlatformExpertDevice"
+ "IOPlatformSerialNumber"
+ "IS_BEZIER_CURVE"
+ "ImageProxy"
+ "Images"
+ "ImplicitEntityAssetNode"
+ "ImplicitWorldReferenceNode"
+ "Inconsistent types for '"
+ "Incorrect actor executor assumption; Expected same executor as "
+ "IncrementClamp"
+ "IncrementWrap"
+ "Index Of Refraction"
+ "IndexOfRefraction"
+ "IndirectClearCoatTDPingPongTex0"
+ "IndirectClearCoatTraceBuffer"
+ "IndirectDiffuseDenoiseOutput"
+ "IndirectDiffuseNeedUpscale"
+ "IndirectDiffuseReservoirBuffer"
+ "IndirectDiffuseSDPingPongTex0"
+ "IndirectDiffuseSpatialTmpOutput"
+ "IndirectSpecularNeedUpscale"
+ "IndirectSpecularSpatialTmpOutput"
+ "IndirectSpecularTraceBuffer"
+ "IndirectSpecularUpscale"
+ "Info: FixIncorrectPremultiply %@ time %u x %u : %fms"
+ "Info: removeResourceIDForResource %llu"
+ "Init neighbor grid"
+ "InitNewParticlesSpawnID"
+ "Input depth texture size must match the output color texture size."
+ "InstantiatePrefab"
+ "Invalid conversion ("
+ "Invalid dependencies"
+ "Invalid random mode"
+ "Invalid render target"
+ "Invalid texture input"
+ "Invalid viewport, origin and size must be expressed in percentage of output texture size"
+ "InvalidateRenderTarget"
+ "Invert"
+ "IrradianceCachePass"
+ "IrradianceTextures"
+ "Irradiance_Cache_Debug_Target"
+ "Irradiance_Cache_Reactive_Mask_Target"
+ "Irradiance_Cache_Reactive_TMP_Mask_Target"
+ "IsValidationFrame"
+ "JSContext.currentSourceKey"
+ "JSGlobalContextRef"
+ "JSValueRef"
+ "JavaScript error: "
+ "JavaScript requires shim for '"
+ "Keep"
+ "LODDebug"
+ "LUT_3D_SIZE %d"
+ "Laplacian"
+ "LastDepthTarget"
+ "LastNormalTarget"
+ "Less"
+ "LessEqual"
+ "LoadRenderTarget"
+ "LocalBoxCollider Collider (Legacy)"
+ "LocalTranslateBy"
+ "Logic"
+ "LookupNodeByName"
+ "MDL material conversion: property not implemented yet: "
+ "MPSConvolutionPass color input resolve"
+ "MPSMorphologicalPass color input resolve"
+ "MTLCAPTURE_DESTINATION_DEVELOPER_TOOLS_ENABLE"
+ "MTL_CAPTURE_ENABLED"
+ "Main.Last.Color0"
+ "Main.Last.Depth"
+ "Manipulator_frag"
+ "Manipulator_vert"
+ "MaterialRuntimeTable"
+ "Math"
+ "MaxRadius"
+ "May cause performance issues in a ParticleInit or ParticleUpdate flow"
+ "Memory Footprint: "
+ "MeshElements"
+ "MeshSources"
+ "Meshes"
+ "Metal pipeline script written in \""
+ "MetalFunctionScript"
+ "MigrationPlaceholder"
+ "Missing expected published resource "
+ "Missing library compiling "
+ "Missing script runtime"
+ "Mode"
+ "Model"
+ "MorphDeformerReadOnlyBuffers"
+ "Multiple materials"
+ "Must be part of Run Mode flow (e.g. IfRunMode"
+ "MutatingRandomSeed"
+ "N"
+ "N/A"
+ "NORMAL PREPASS"
+ "NORMAL ROUGHNESS"
+ "NSFastEnumeration"
+ "Never"
+ "No renderer given at prepare"
+ "NoopRunModeAction"
+ "Not a GPU emitter"
+ "Not allowed in subgraph"
+ "Not available in C"
+ "Not available in GPU ParticleInit/ParticleUpdate"
+ "Not available in JavaScript"
+ "Not available on CPU"
+ "NotEqual"
+ "Numeric value is incompatible with "
+ "OVERLAY"
+ "Object"
+ "Objective-C selector '"
+ "OnHandTrackingUpdate"
+ "OpacityOverVelocity (Legacy)"
+ "OpenSubdivComputeEvaluators"
+ "OrientationConstraint (Legacy)"
+ "Orthographic Scale"
+ "Other"
+ "Parenting"
+ "Particle Material"
+ "ParticleIndexIsValid"
+ "ParticleLifeAndDeath"
+ "ParticlePrepareGPUSystem"
+ "ParticleSPHSimulation.GPU"
+ "Pass "
+ "PathTracerPingPongTex0"
+ "Peer Connection "
+ "Per-Particle graph"
+ "PhysicalEaseNode"
+ "Physically Based"
+ "PipelineStates [%d]"
+ "PlayerPeer endpoint:"
+ "PointCacheFromModel"
+ "PositionOverTexture (Legacy)"
+ "Post process input albedo metalness"
+ "Post process input color1"
+ "Post process input normal roughness"
+ "Post process input radiance AO"
+ "PostDepthPass"
+ "PostProcess albedoMetalnessTarget input resolve"
+ "PostProcess normal input resolve"
+ "PostProcess radianceAOTarget input resolve"
+ "PostProcessSPI"
+ "PostProcessSPI Copy color"
+ "PostProcessSPI Copy color1"
+ "PostProcessSPI output"
+ "PrecomputedLightingEnvironment"
+ "PreferJavaScript"
+ "PrepareObject"
+ "Presentation"
+ "Presented attachment is already presented elsewhere"
+ "Projection Matrix"
+ "Projection Transform"
+ "Projector (Legacy)"
+ "ProvidePlayerHealth"
+ "ProvidePlayerPeerConfiguration"
+ "ProvidePlayerUpdateEffectAcknowledgement"
+ "Published attachment is already published elsewhere"
+ "PushFrame #%d last:%d [%p:%s] value:%g\n"
+ "Q24@0:8@\"<MTLBuffer>\"16"
+ "Q24@0:8@\"<MTLRenderPipelineState>\"16"
+ "Q24@0:8@\"<MTLTexture>\"16"
+ "Q32@0:8@\"<VFXMTLDeformerUpdateComputeContext>\"16r^{?=@@@@@@@@@@@@}24"
+ "Q32@0:8@\"CFXRemoteRenderPipelineDescriptor\"16@\"<MTLRenderPipelineState>\"24"
+ "Q32@0:8@16@24"
+ "Q32@0:8@16r^{?=@@@@@@@@@@@@}24"
+ "Q32@0:8{?=^vII}16"
+ "Q40@0:8^{?=Q^@^Q[5Q]}16^@24Q32"
+ "Q8@?0"
+ "Q96@0:816{?=[4]}32"
+ "QuadraticEaseInNode"
+ "QuadraticEaseInOutNode"
+ "QuadraticEaseOutNode"
+ "QualityMode"
+ "QuarticEaseInNode"
+ "QuarticEaseInOutNode"
+ "QuarticEaseOutNode"
+ "QuaternionMultiply"
+ "QuinticEaseInNode"
+ "QuinticEaseInOutNode"
+ "QuinticEaseOutNode"
+ "RADIANCE AO"
+ "RAYTRACER OUTPUT"
+ "REMOTE COLOR OUTPUT"
+ "REMOTE DEPTH OUTPUT"
+ "RG::RenderGraphContext ctx(gpuDevice);\n"
+ "RGFramePrivateBufferPool"
+ "RGFrameSharedBufferPool"
+ "RGPassKindBlit"
+ "RGPassKindCompute"
+ "RGPassKindCustom"
+ "RGPassKindRender"
+ "RTDirectLightingSpatialDenoisePass"
+ "RTDirectLightingTemporalDenoisePass"
+ "RTIndirectClearCoatSpatialDenoisePass"
+ "RTIndirectClearCoatTemporalDenoisePass"
+ "RTIndirectClearCoatTracePass"
+ "RTIndirectClearCoatUpscalePass"
+ "RTIndirectSpecularSpatialDenoisePass"
+ "RTIndirectSpecularTemporalDenoisePass"
+ "RTIndirectSpecularTracePass"
+ "RTIndirectSpecularUpscalePass"
+ "RTTransmissionSpatialDenoisePass"
+ "RTTransmissionTemporalDenoisePass"
+ "RTTransmissionTracePass"
+ "RTTransmissionUpscalePass"
+ "RT_CLEARCOAT_SPATIAL_DENOISE"
+ "RT_DIRECT_LIGHTING_SPATIAL_DENOISE"
+ "RT_DIRECT_LIGHTING_TEMPORAL_DENOISE"
+ "RT_INDIRECT_CLEARCOAT_TEMPORAL_DENOISE"
+ "RT_INDIRECT_CLEARCOAT_TRACE"
+ "RT_INDIRECT_CLEARCOAT_UPSCALE"
+ "RT_INDIRECT_SPECULAR_TEMPORAL_DENOISE"
+ "RT_INDIRECT_SPECULAR_TRACE"
+ "RT_INDIRECT_SPECULAR_UPSCALE"
+ "RT_SPECULAR_SPATIAL_DENOISE"
+ "RT_TRANSMISSION_SPATIAL_DENOISE"
+ "RT_TRANSMISSION_TRACE"
+ "RT_TRANSMISSION_UPSCALE"
+ "RadianceTextures"
+ "RadiusScale"
+ "Random"
+ "RandomInFloatRange"
+ "RandomInIntRange"
+ "RasterizerStates"
+ "RayTracer"
+ "RayTracerPass"
+ "RaytracingSystem Build"
+ "RaytracingSystemPass"
+ "Receive error from device."
+ "Receive unexpected: "
+ "Referenced texture is not loaded"
+ "References are not supported on GPU"
+ "ReflectionProbe"
+ "Remote"
+ "Remote Clear Pass"
+ "RemoteRendering"
+ "RemoteReplay"
+ "RemoveAllAnimations"
+ "RemoveFromParent"
+ "Render Graph"
+ "Render prepass"
+ "RenderPipeline can not be waiting again!!!"
+ "RenderTargetAsset"
+ "Replace"
+ "ReprojectionMapPass"
+ "ReprojectionMapPassOutput"
+ "Ribbon Trails (Legacy)"
+ "RotateAroundTarget"
+ "SCNAnimationEventsKey"
+ "SDF OUTPUT"
+ "SDF TMP_A"
+ "SDF TMP_B"
+ "SDFGenerationPass"
+ "SDFGenerationPass color input resolve"
+ "SIMPLIFIED_SHADER_IDENTIFIER"
+ "SM_Model,"
+ "SPH Fluid Simulation"
+ "SPH Simulation requires a NeighborGrid component on the emitter."
+ "SSAO-TRACE"
+ "SSAO_SPATIAL_OUTPUT_TMP2"
+ "SSAO_SPATIAL_TMP_FULLRES"
+ "SSR Composite Output"
+ "SSR Thickness Mode"
+ "SSRCompositePass"
+ "SSRDownsamplePass"
+ "SSRHasAO"
+ "SSRHasIBL"
+ "SSRIsHDR"
+ "SSRQuality"
+ "SSRRaytracePass"
+ "SSRSpatialDenoiseOutput"
+ "SSRSpatialDenoisePass"
+ "SSRSpatialDenoiseTmpTex"
+ "SSRTemporalDenoisePass"
+ "SSRTemporalDenoisePingPongTex0"
+ "SSRThicknessMode"
+ "SSRUpscale"
+ "SSRUpscalePass"
+ "SSR_SPATIAL_DENOISE"
+ "SSR_TEMPORAL_DENOISE"
+ "SSR_UPSCALE"
+ "STENCIL"
+ "SUOcclusionAlphaMask"
+ "Sampled render target '"
+ "Sampled render target is never published"
+ "Sampler Count"
+ "Samplers"
+ "Save Metal capture in "
+ "ScriptCompileAttempt<HeaderScript>"
+ "ScriptParameter "
+ "ScriptRuntime is missing function names"
+ "ScriptRuntime<HeaderScript>"
+ "ScriptStateRestoration<HeaderScript>"
+ "SetResolvedVariable"
+ "Shadables"
+ "Shows the grid boundaries and occupation. On GPU the grid repeats infinitely to handle particles going outside of the bounding box. This shows the grid only once."
+ "SinEaseInOutNode"
+ "Sine Move Action (Legacy)"
+ "SizeOverTexture (Legacy)"
+ "SizeOverVelocity (Legacy)"
+ "SkinDeformerReadOnlyBuffers"
+ "Sobel"
+ "SpatialPassId"
+ "StageDescriptors [%d]"
+ "StencilTarget(CFX::RG::AccessInfo::"
+ "Stereo rendering require final color with 2 slices"
+ "Struct"
+ "Subgraph"
+ "SubsurfaceReservoirBuffer"
+ "T,N,V_boundingBoxMax"
+ "T,N,V_boundingBoxMin"
+ "T,N,V_scale"
+ "T@\"<CFXRemoteResourceProvider>\",&,N"
+ "T@\"<MTLCommandBuffer>\",&,N"
+ "T@\"<MTLRasterizationRateMap>\",&,N"
+ "T@\"<MTLTexture>\",&,N,V_directionTexture"
+ "T@\"<MTLTexture>\",&,N,V_originTexture"
+ "T@\"<VFXDrawCallContext>\",&,N"
+ "T@\"<VFXGeometry>\",&,N"
+ "T@\"<VFXGeometry>\",R,N"
+ "T@\"<VFXParameterList>\",R,N"
+ "T@\"<VFXRenderTargetInfo>\",R,N"
+ "T@\"<VFXState>\",&,N"
+ "T@\"<VFXStatisticsProvider>\",N,W,VrendererStatisticsProvider"
+ "T@\"<VFXStencilInfo>\",?,R,N"
+ "T@\"CAMediaTimingFunction\",R,C"
+ "T@\"CAMetalDisplayLinkUpdate\",&,N,V_metalDisplayLinkUpdate"
+ "T@\"CFXRemoteFunctionDescription\",&,N,V_fragmentFunction"
+ "T@\"CFXRemoteFunctionDescription\",&,N,V_vertexFunction"
+ "T@\"MTLComputePipelineReflection\",R"
+ "T@\"MTLRenderPipelineReflection\",R"
+ "T@\"MTLVertexDescriptor\",&,N,V_vertexDescriptor"
+ "T@\"NSArray\",C,N,V_subpixelData"
+ "T@\"NSData\",&,N"
+ "T@\"NSData\",C,N"
+ "T@\"NSDictionary\",C,N,V_functionConstantValues"
+ "T@\"NSString\",&,N,V_tag"
+ "T@\"NSString\",&,N,VcolorSpaceName"
+ "T@\"NSString\",C,N,V_functionName"
+ "T@\"NSString\",R,C,N"
+ "T@\"NSString\",R,N,V_identifier"
+ "T@\"NSString\",R,N,V_shadableIdentifier"
+ "T@\"RGCachedComputeCommandEncoder\",R,N"
+ "T@\"VFXAssetRegistry\",R,N"
+ "T@\"VFXMTLMesh\",R,N"
+ "T@\"VFXMTLREContext\",R,N,V_reContext"
+ "T@\"VFXNode\",&,N,V_destination"
+ "T@\"VFXNode\",&,N,V_node"
+ "T@\"VFXNode\",&,N,V_source"
+ "T@\"VFXRenderer\",R,N"
+ "T@\"VFXRendererRayMap\",&,N"
+ "T@\"VFXRendererRayMap\",&,N,V_rayMap"
+ "T@\"VFXState\",&,N,V_from"
+ "T@\"VFXState\",&,N,V_to"
+ "T@\"VFXStateManager\",R,N"
+ "T@\"VFXTimingFunction\",&,N,V_timingFunction"
+ "T@\"VFXWorld\",N,V_world"
+ "T@\"_TtC3VFX15VFXEntityObject\",R,N"
+ "T@\"_TtC3VFX20EntityPropertyHelper\",N,R"
+ "T@\"_TtC3VFX23VFXReferencePlaceholder\",N,R"
+ "T@,&,N,V_programHashCode"
+ "T@,N,W,Vhandle"
+ "T@?,C,N,V_encodeHandler"
+ "T@?,C,N,V_onDealloc"
+ "T@?,C,N,V_updater"
+ "TB,N,GisLowLatency"
+ "TB,N,V_additiveWritesToAlpha"
+ "TB,N,V_isSideBySideStereo"
+ "TB,N,V_rasterizationEnabled"
+ "TB,N,V_transitionsEnabled"
+ "TB,N,V_usesMultisampling"
+ "TB,N,VadditiveWritesToAlpha"
+ "TB,N,VisPublic"
+ "TB,N,VisRenderingInRE"
+ "TB,N,VwantsExtendedDynamicRange"
+ "TITLE \"%255[^\"]\""
+ "TQ,N,V_pixelFormat"
+ "TQ,N,V_primitiveTopologyClass"
+ "TQ,N,V_primitiveType"
+ "TQ,N,V_stencilPixelFormat"
+ "TQ,N,V_type"
+ "T^{CGPath=},R"
+ "T^{VFXTriggerEnabledTypes=b1b1b1b1b1b1b1b1b1b1b1b1b1b1},R,N"
+ "T^{__CFXBufferAllocatorPerFrame=},R,N"
+ "T^{__CFXGPUDevice=},R,N"
+ "T^{__CFXNode=},N,&"
+ "T^{__CFXTextureAllocatorPerFrame=},R,N"
+ "T^{__CFXWorld=},R,N"
+ "Td,N,V_beginTime"
+ "Td,N,V_duration"
+ "TemporalDenoisePass"
+ "TemporalDenoisePingPongTex"
+ "Tessellators"
+ "Test"
+ "TextToImageGenerator: Failed to create bitmap context"
+ "Texture"
+ "Texture Count (private)"
+ "Texture Count (shared)"
+ "Texture From Text"
+ "Texture Memory (private)"
+ "Texture Memory (shared)"
+ "TextureCache corrupt state: "
+ "TextureFromTextGenerator"
+ "TextureRequireAnimationRepresentation"
+ "TextureRequireSizeLimit"
+ "Tf,?,R,N"
+ "Tf,N,V_zOrigin"
+ "The fluid's rest density. When the density is different from the rest density, it creates pressure forces that push particles to return to the rest density."
+ "The fluid's viscosity. Higher values gives a thicker fluid."
+ "The radius used for the simulation. This should be the same as the radius used for the Neighbor Grid (or smaller)."
+ "The stiffness detemines how responsive the fluid will be to density variations. Instabilities are more likely to occur with high values."
+ "This determines the maximum allocated size for the grid. The actual size might be smaller if the bounding box of the emitter is smaller."
+ "This determines the size of a cell. Neighbor queries radius will be clamped to this value. For best results use the smallest value necessary."
+ "This value has no influence on the allocated size, it can affect the performance of neighbor queries."
+ "Ti,?,R,N"
+ "Ti,N,V_cellPatternMode"
+ "Ti,N,V_materialType"
+ "Ti,N,V_renderingOrder"
+ "Ti,N,V_screenHeight"
+ "Ti,N,V_screenWidth"
+ "Ti,N,V_subpixels"
+ "Tq,N,V_gpuFamily"
+ "Tq,N,V_maxVertexAmplificationCount"
+ "Tq,N,V_operation"
+ "Tq,N,VbindingType"
+ "Tq,N,VmodelModificationCount"
+ "Tq,R,N,V_emitterObjectID"
+ "Transmission"
+ "Transmission Color"
+ "TransmissionApprox"
+ "TransmissionColor"
+ "TransmissionPingPongTex"
+ "TransmissionReservoirBuffer"
+ "TransmissionTemporalDenoise"
+ "TransmissionUpscale"
+ "Transparency Mode"
+ "T{?=[4]},N,V_transform"
+ "T{?=^vII},R,N"
+ "USE_ALBEDO_METALNESS_OUTPUT"
+ "USE_BARYCENTRIC_WIREFRAME"
+ "USE_BENTNORMALS"
+ "USE_INVERSEMODELTRANSFORM"
+ "USE_INVERSEMODELVIEWTRANSFORM"
+ "USE_LATE_LATCHING"
+ "USE_METALNESS_ROUGHNESS_OUTPUT"
+ "USE_NORMALTRANSFORM"
+ "USE_NORMAL_ROUGHNESS_OUTPUT"
+ "USE_RADIANCE_AO_OUTPUT"
+ "USE_RE_RADIANCE_IRRADIANCE_MAP_SAMPLING"
+ "USE_RE_SYSTEM_TREATMENTS"
+ "USE_SCREEN_UV"
+ "USE_SUBSURFACE"
+ "USE_TRANSMISSION"
+ "USE_TRANSMISSIONCOLORTEXCOORD"
+ "USE_TRANSMISSIONTEXCOORD"
+ "Unable to build original graph: "
+ "Unable to create descriptor"
+ "Unable to create full screen quad pass"
+ "Unable to create kernelscript pass"
+ "Unable to create original graph: "
+ "Unable to find texture for binding %@ (\"%@\") and material property %@ derived from value %@ (model=%@, material=%@)"
+ "Unable to find texture for binding %@ and material property %@"
+ "Unable to generate test, optimised render graph build failed: "
+ "Unable to generate test, render graph build failed: "
+ "Unable to generate test: "
+ "Unable to load the ColorCube data from "
+ "Unable to remap asset entity, bailing out"
+ "Unamed"
+ "Unreachable code: CFXEngineContextGetTextureWithHandle - no render context"
+ "Unreachable code: CFXEngineContextGetTextureWithHash - no render context"
+ "Unreachable code: CFXModelValueStorageUpdateModelValueFromPresentationValue - unexpected class"
+ "Unreachable code: Could not find deformer class associated to meshless geometry"
+ "Unreachable code: Internal consistency error – can't transfer ownership"
+ "Unreachable code: Invalid index size (%zu bytes per index)"
+ "Unreachable code: Mesh source has invalid bounds"
+ "Unreachable code: Meshless geometries don't support normals"
+ "Unreachable code: Meshless geometries don't support tangents"
+ "Unreachable code: Raytracing support for uniform subdivision has not been implemented yet."
+ "Unreachable code: Unexpected vertex format %@ for acceleration structure"
+ "Unreachable code: Unknown component type"
+ "Unreachable code: Unknown geometry class \"%@\""
+ "Unreachable code: Unsupported edge crease vertex format (%d)"
+ "Unreachable code: vImageEncodeVectorHalf only supports half2/3/4"
+ "Unsupported Trigger Type "
+ "Update effect has not associated data"
+ "UpdateResourceUsageAndStorageMode(ctx, optimisedGraph, pass, resource);\n"
+ "UseNormalDepthTex"
+ "UseScreenSpaceRadius"
+ "Using Metal binary archive \""
+ "Utilities"
+ "VFX"
+ "VFX current command buffer"
+ "VFX isn't supported on Virtual Machines because argument buffers are not fully implemented there rdar://100784848"
+ "VFX resource command buffer"
+ "VFX update command buffer #"
+ "VFX.DoNode"
+ "VFX.EasingNode"
+ "VFX.EntityPropertyHelper"
+ "VFX.GetGPUEmitterNode"
+ "VFX.MigrationPlaceholderNode"
+ "VFX.RemotePreviewPlayerPeer"
+ "VFX.ShaderArchive"
+ "VFX.StringJoinNode"
+ "VFX.SwitchNode"
+ "VFX.VFXMotionTracker"
+ "VFX.VFXReferencePlaceholder"
+ "VFX.WorldAssetNode"
+ "VFX.WorldObjectNode"
+ "VFX._AnyECSValueNode"
+ "VFX._AnyWorldValueNode"
+ "VFX._ArrayNode"
+ "VFX._CodeNode"
+ "VFX._RandomSeedNode"
+ "VFX._RandomTNode"
+ "VFX._ResolvedVariableNode"
+ "VFX._StaticECSValueNode"
+ "VFX._StaticWorldValueNode"
+ "VFX/AuthoringGraph+Serialization.swift"
+ "VFX/CodeEmitter+CodeGen.swift"
+ "VFX/CommandBufferHelper.swift"
+ "VFX/Engine.swift"
+ "VFX/GraphV1Components.swift"
+ "VFX/Lights.swift"
+ "VFX/Nodes+Array.swift"
+ "VFX/Nodes+Code.swift"
+ "VFX/Nodes+Triggers.swift"
+ "VFX/Nodes+VFXActions.swift"
+ "VFX/ParticleGenerateGrid.swift"
+ "VFX/ParticleSPHSimulation.swift"
+ "VFX/QueryCursor.swift"
+ "VFX/RemotePreviewPeerConnection.swift"
+ "VFX/RemotePreviewPlayerPeer.swift"
+ "VFX/RemotePreviewStudioPeerListener.swift"
+ "VFX/ScriptCompilerSystem.swift"
+ "VFX/ScriptTrampolineCodeGen.swift"
+ "VFX/Scripting+Execute+JavaScript.swift"
+ "VFX/ScriptingSupport+Components.swift"
+ "VFX/URLWatcher.swift"
+ "VFX/VFXCoreView.swift"
+ "VFX/VFXGazeTracker.swift"
+ "VFX/VFXMotionTracker.swift"
+ "VFX/VFXViewLegacy.swift"
+ "VFX/VideoAudio.swift"
+ "VFX/colorLUT.swift"
+ "VFX12"
+ "VFX13"
+ "VFXARKitGazeTracker"
+ "VFXARKitHandTracker"
+ "VFXAssetNodeJSExport"
+ "VFXAssetRegistryJSExport"
+ "VFXAudioAsset"
+ "VFXBezierCurveGeometry"
+ "VFXCORE_PREPARE_PASS"
+ "VFXCORE_RECYCLE_DRAWCALLS_PASS"
+ "VFXCopyContext"
+ "VFXCopyingRemappable"
+ "VFXCoreAssetJSExport"
+ "VFXCorePreparePass"
+ "VFXCoreRecycleDrawCallsPass"
+ "VFXCoreSimulate"
+ "VFXDrawCall"
+ "VFXEntityProvider"
+ "VFXFileAssetJSExport"
+ "VFXGeometry"
+ "VFXGraphBinding"
+ "VFXInternal"
+ "VFXMTLBezierCurveDeformer"
+ "VFXMTLMeshlessDeformer"
+ "VFXMTLREContext"
+ "VFXMTLRenderContextSceneRendererMainPassCustomPostProcessHelper"
+ "VFXMetalLibraryProvider"
+ "VFXMotionData $motionData;\nvfx_script_get_motion_data(%script_context, &$motionData);\nauto %r0 = $motionData.attitude;\nauto %r1 = $motionData.rotationRate;\nauto %r2 = $motionData.gravity;\nauto %r3 = $motionData.userAcceleration;\nauto %r4 = $motionData.magneticField;\nauto %r5 = $motionData.magneticFieldAccuracy;\nauto %r6 = $motionData.heading;"
+ "VFXParameterInfo"
+ "VFXParameterList"
+ "VFXParameterList_Private"
+ "VFXParameterizable"
+ "VFXParticleCollisionDataComponent"
+ "VFXParticleCollisionInfo $event;\nvfx_script_get_particle_collision(%script_context, %param1, %param0, &$event);\nauto %r0 = $event.hasCollided;\nauto %r1 = $event.position;\nauto %r2 = $event.normal;\nauto %r3 = $event.direction;"
+ "VFXPhysicsContactDelegate"
+ "VFXPlayer"
+ "VFXPlayerImmersive"
+ "VFXPlayerMac"
+ "VFXPlayerTV"
+ "VFXPresentationSupport"
+ "VFXPreviewSessionMessageType"
+ "VFXProgramDidCompileNotification"
+ "VFXREWorldSimulation"
+ "VFXReferenceEnumerable"
+ "VFXRemoteFrame"
+ "VFXRemotePreview"
+ "VFXRemotePreviewPlayerPeer"
+ "VFXRemotePreviewPlayerPeerDelegate"
+ "VFXRemoteRendererProxy"
+ "VFXRemoteRendererProxyRegistry"
+ "VFXRemoteRendererXPCProtocol"
+ "VFXRemoteResourceConsumer"
+ "VFXRenderCommandExtendedEncoder"
+ "VFXRendererInitForRemoteDecoding"
+ "VFXRendererInitForRemoteEncoding"
+ "VFXRendererRayMap"
+ "VFXRenderingInRE"
+ "VFXScriptingSupport"
+ "VFXShadableInterfaceDidChangeNotificationName"
+ "VFXShaderCacheConfiguration"
+ "VFXStateSupport"
+ "VFXStudio"
+ "VFXTextureClientPlaceholder"
+ "VFXTriggerTypeCollisionBegan"
+ "VFXTriggerTypeCollisionEnded"
+ "VFXTriggerTypeCollisionUpdate"
+ "VFXTriggerTypeGazeTracking"
+ "VFXTriggerTypeHandTracking"
+ "VFXTriggerTypeMotionTracking"
+ "VFXTriggerTypeParticleCollision"
+ "VFXTriggerTypeTapBegan"
+ "VFXTriggerTypeTapCancelled"
+ "VFXTriggerTypeTapDragged"
+ "VFXTriggerTypeTapEnded"
+ "VFXTriggerTypeTick"
+ "VFXViewConfiguration"
+ "VFXWorldExportCompressMeshElements"
+ "VFXWorldExportOptimize"
+ "VFXWorldLoaderAllowLoadingEffectFromTheFuture"
+ "VFXWorldLoaderCompileGraphsCallback"
+ "VFXWorldLoaderConformToSubdivisionScheme"
+ "VFXWorldLoaderLoadForRERendering"
+ "VFXWorldProvider"
+ "VFXWorldReference"
+ "VFXWrapModeClampToZero"
+ "VFX_PARTICLE_INVALID"
+ "VFX_USES_RE_SHADERS"
+ "Variable hasn't been created"
+ "VisualDepthTexture"
+ "Vortex.GPU"
+ "Warning: CFXNodeGetWorldMatrixPtr - no transform tree"
+ "Warning: CFXVFXPrepareDrawCalls -> no world yet"
+ "Warning: CFXVFXSimulate -> no world yet"
+ "Warning: Deindexing - Vertex at index %u of %u is not used by any mesh element"
+ "Warning: Found elements with different channel counts in the same mesh"
+ "Warning: Missing material property for binding \"%@\" (material: %p, model: %p)"
+ "Warning: Missing shadable value for binding \"%@\" (material: %p, model: %p)"
+ "Warning: RemoteRenderPipelineDesc %@ already registered"
+ "Warning: Rendering for Eyesight without an Eyesight Frame, fallback to default camera location"
+ "Warning: UseResource failed with unknown resourceID: %llu"
+ "Warning: VFXProgram overrides shader modifiers"
+ "Warning: _CFXSkinnerUpdateBoundingBox - skinned node has no model"
+ "Warning: binding type %ld can't not be exposed"
+ "Warning: buffer rID:%llu was not found"
+ "Warning: copyCFXImageFromImage: invalid sub-image %@\n"
+ "Warning: failed to re-create tangents"
+ "Warning: loading VFX1 file format"
+ "Welcome to VFX 203.0.15.502.1 (May 29 2025 00:23:46)"
+ "WireframeMaterials"
+ "World"
+ "WorldReferenceNode"
+ "WrapAroundCamera (Legacy)"
+ "XCTAssert(DeduceStoreAction(optimisedGraph, pass, resource, ctx.stackAllocator(), ctx.optimisationParameters()) == "
+ "XCTAssert(copy_pass_count == "
+ "XCTAssert(ctx.resolvedTextureDescriptor(resource).storageMode == "
+ "XCTAssert(ctx.resolvedTextureDescriptor(resource).usage == "
+ "XCTAssert(optimisedGraph);\n"
+ "XCTAssert(renderGraph);\n"
+ "XCTAssert(sortedStages.size() == "
+ "XCTAssert(sortedStages["
+ "XPC_SERVICE_NAME"
+ "Zero"
+ "[%ld:%ld]"
+ "[(id <MTLDeviceSPI>)device supportsMemorylessRenderTargets]"
+ "[16{VFXWorldBuffer=\"viewTransform\"{float4x4=\"columns\"[4]}\"inverseViewTransform\"{float4x4=\"columns\"[4]}\"projectionTransform\"{float4x4=\"columns\"[4]}\"viewProjectionTransform\"{float4x4=\"columns\"[4]}\"viewToCubeTransform\"{float4x4=\"columns\"[4]}\"lastFrameViewProjectionTransform\"{float4x4=\"columns\"[4]}\"ambientLightingColor\"\"fogColor\"\"fogParameters\"\"inverseResolution\"\"time\"f\"timeFract\"f\"deltaTime\"f\"motionBlurIntensity\"f\"environmentIntensity\"f\"environmentTransform\"{float4x4=\"columns\"[4]}\"inverseProjectionTransform\"{float4x4=\"columns\"[4]}\"inverseViewProjectionTransform\"{float4x4=\"columns\"[4]}\"nearFar\"\"viewportSize\"\"inverseTransposeViewTransform\"{float4x4=\"columns\"[4]}\"clusterScale\"\"frame\"I}]"
+ "[3^{__CFXProgram}]"
+ "[8{?=\"blendingEnabled\"B\"_writeMask\"C\"colorSrcBlend\"C\"colorDstBlend\"C\"colorBlendOp\"C\"alphaSrcBlend\"C\"alphaDstBlend\"C\"alphaBlendOp\"C}]"
+ "[Auth] Arrow"
+ "[Auth] Axis"
+ "[Auth] Circle"
+ "[Auth] RotationArc"
+ "[Auth] Translation"
+ "[Producer] Destroyed Buffer rID:%@ -> %p"
+ "[Producer] Destroyed Texture rID:%@ -> %p"
+ "[Producer] New Buffer rID:%@ -> %@"
+ "[Raytracing] EmitterBuffer"
+ "[Raytracing] InstanceBuffer"
+ "[Raytracing] LightBuffer"
+ "[Raytracing] MeshBuffer"
+ "[Raytracing] MeshElementBuffer"
+ "[privateRendererOwner isKindOfClass:[VFXView class]]"
+ "[vfxComputeEncoder isEncoding]"
+ "]->classIdentifier() == "
+ "]->writes()["
+ "].size() == "
+ "];\n"
+ "];\nconst %r0 = $strings.join(\"\");"
+ "];\nuint32_t $count = %0.get_neighbors_in_radius(%1, %2, "
+ "]["
+ "^v16@?0^v8"
+ "^{?=QII}"
+ "^{?=QI}"
+ "^{?={?=[4]}(?=)}"
+ "^{?={?=b8b8b8b8b8b8b8b7b1}I}"
+ "^{CGPath=}"
+ "^{VFXMTLRenderCommandEncoder=IC@@@^{BufferAllocatorPerFrame}B}"
+ "^{VFXTriggerEnabledTypes=b1b1b1b1b1b1b1b1b1b1b1b1b1b1}16@0:8"
+ "^{VFXWorldBuffer={float4x4=[4]}{float4x4=[4]}{float4x4=[4]}{float4x4=[4]}{float4x4=[4]}{float4x4=[4]}fffff{float4x4=[4]}{float4x4=[4]}{float4x4=[4]}{float4x4=[4]}I}16@0:8"
+ "^{VFXWorldBuffer={float4x4=[4]}{float4x4=[4]}{float4x4=[4]}{float4x4=[4]}{float4x4=[4]}{float4x4=[4]}fffff{float4x4=[4]}{float4x4=[4]}{float4x4=[4]}{float4x4=[4]}I}24@0:8^{__CFXWorld=}16"
+ "^{__CFString=}"
+ "^{__CFString=}16@0:8"
+ "^{__CFXBezierCurveGeometry=}"
+ "^{__CFXBufferAllocatorPerFrame=}16@0:8"
+ "^{__CFXCamera={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}{?=b1b1b1b3ffff{?=[4]}{?=[4]}}fff^{__CFXCameraEffectDepthOfField}^{__CFXCameraEffectMotionBlur}^{__CFXCameraEffectGrain}^{__CFXCameraEffectExposure}^{__CFXCameraEffectToneMapping}^{__CFXCameraEffectBloom}^{__CFXCameraEffectVignetting}^{__CFXCameraEffectLensBlur}^{__CFXCameraEffectColorFringe}^{__CFXCameraEffectColorGrading}^{__CFXCameraEffectChromaticTransform}^{__CFXCameraEffectDoughnutBokeh}^{__CFXCameraEffectSSAO}b1b1b1b1{?=[4]}Q}"
+ "^{__CFXCamera={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}{?=b1b1b1b3ffff{?=[4]}{?=[4]}}fff^{__CFXCameraEffectDepthOfField}^{__CFXCameraEffectMotionBlur}^{__CFXCameraEffectGrain}^{__CFXCameraEffectExposure}^{__CFXCameraEffectToneMapping}^{__CFXCameraEffectBloom}^{__CFXCameraEffectVignetting}^{__CFXCameraEffectLensBlur}^{__CFXCameraEffectColorFringe}^{__CFXCameraEffectColorGrading}^{__CFXCameraEffectChromaticTransform}^{__CFXCameraEffectDoughnutBokeh}^{__CFXCameraEffectSSAO}b1b1b1b1{?=[4]}Q}16@0:8"
+ "^{__CFXCommonProfile={__CFRuntimeBase=QAQ}^{__CFXMaterial}C^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}ffffCiBb1b1b1b1b1b1b13}"
+ "^{__CFXCommonProfile={__CFRuntimeBase=QAQ}^{__CFXMaterial}C^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}ffffCiBb1b1b1b1b1b1b13}16@0:8"
+ "^{__CFXCoreEntityHandle={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFString}^{__CFDictionary}^{__CFArray}iB^v}"
+ "^{__CFXCoreEntityHandle={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFString}^{__CFDictionary}^{__CFArray}iB^v}16@0:8"
+ "^{__CFXFloor={__CFXModel={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXGeometry}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}ffffifffQ}16@0:8"
+ "^{__CFXGPUDevice=}"
+ "^{__CFXGPUDevice=}16@0:8"
+ "^{__CFXGeometry=}"
+ "^{__CFXImage=}28@0:8@16C24"
+ "^{__CFXImage=}36@0:8@16C24^B28"
+ "^{__CFXImage=}8@?0"
+ "^{__CFXImageProxy=}8@?0"
+ "^{__CFXMaterialProperty={__CFRuntimeBase=QAQ}(?=^{__CFXImage}^{__CFXImageProxy}^{__CFXTexture}^v^v^v{CFXColor4=(?=[4f]{?=ffff})})^vq^vb8b1b4c{?=b8b8b8b8b8b8b8b7b1}^{?}fi^v}"
+ "^{__CFXMaterialProperty={__CFRuntimeBase=QAQ}(?=^{__CFXImage}^{__CFXImageProxy}^{__CFXTexture}^v^v^v{CFXColor4=(?=[4f]{?=ffff})})^vq^vb8b1b4c{?=b8b8b8b8b8b8b8b7b1}^{?}fi^v}16@0:8"
+ "^{__CFXMaterialProperty={__CFRuntimeBase=QAQ}(?=^{__CFXImage}^{__CFXImageProxy}^{__CFXTexture}^v^v^v{CFXColor4=(?=[4f]{?=ffff})})^vq^vb8b1b4c{?=b8b8b8b8b8b8b8b7b1}^{?}fi^v}20@0:8B16"
+ "^{__CFXMeshElement={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}II^{__CFXMeshElement}CCC{?=C^{__CFData}I^I^{?}SCB}^vfff^v^{__CFXMeshSource}[2]^{?}I}"
+ "^{__CFXMeshElement={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}II^{__CFXMeshElement}CCC{?=C^{__CFData}I^I^{?}SCB}^vfff^v^{__CFXMeshSource}[2]^{?}I}16@0:8"
+ "^{__CFXMeshElement={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}II^{__CFXMeshElement}CCC{?=C^{__CFData}I^I^{?}SCB}^vfff^v^{__CFXMeshSource}[2]^{?}I}36@0:8C16q20q28"
+ "^{__CFXMeshSource={__CFXGenericSource={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}12@?0C8"
+ "^{__CFXModel={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXGeometry}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}"
+ "^{__CFXModel={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXGeometry}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16@0:8"
+ "^{__CFXModelTarget={__CFRuntimeBase=QAQ}^v^vscCCB}"
+ "^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}"
+ "^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}16@0:8"
+ "^{__CFXProgram={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}b1b1^{__CFXProgramDelegate}[2^{__CFString}]^{__CFString}^{__CFString}^{__CFDictionary}^{__CFSet}^v^{__CFDictionary}i@?@?QI}"
+ "^{__CFXProgram=}"
+ "^{__CFXProgram=}20@0:8B16"
+ "^{__CFXProgram=}40@0:8^{__CFXProgramHashCode=}16^{__CFXEngineContext=}24^v32"
+ "^{__CFXProgram=}48@0:8^{__CFXProgramHashCode=}16^{__CFXEngineContext=}24@32^v40"
+ "^{__CFXProgramHashCode={__CFRuntimeBase=QAQ}{?=[22I]SI[8I]CCCC[16{?=Cc}]{?=SCb3b2b2}b1b1b1b1b1b1b1b1b1b1b1b1b1b3b3b1b1[8c]}^{__CFString}I[2^{__CFArray}][8^{__CFString}]}"
+ "^{__CFXProgramHashCode={__CFRuntimeBase=QAQ}{?=[22I]SI[8I]CCCC[16{?=Cc}]{?=SCb3b2b2}b1b1b1b1b1b1b1b1b1b1b1b1b1b3b3b1b1[8c]}^{__CFString}I[2^{__CFArray}][8^{__CFString}]}16@0:8"
+ "^{__CFXRemoteFrameBuilder=}"
+ "^{__CFXRenderingOverride=}"
+ "^{__CFXShaderModifier={__CFRuntimeBase=QAQ}^{__CFString}^{__CFString}^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}cCIII[32C]}"
+ "^{__CFXShaderModifier={__CFRuntimeBase=QAQ}^{__CFString}^{__CFString}^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}cCIII[32C]}16@0:8"
+ "^{__CFXTextureAllocatorPerFrame=}16@0:8"
+ "_TtC3VFX10ARGazeNode"
+ "_TtC3VFX10ARHandNode"
+ "_TtC3VFX10DilateNode"
+ "_TtC3VFX10RepeatNode"
+ "_TtC3VFX10SwitchNode"
+ "_TtC3VFX10ThrowIfNaN"
+ "_TtC3VFX10_ArrayNode"
+ "_TtC3VFX11AreaMaxNode"
+ "_TtC3VFX11AreaMinNode"
+ "_TtC3VFX11ForEachNode"
+ "_TtC3VFX11HitTestNode"
+ "_TtC3VFX11NewNodeNode"
+ "_TtC3VFX11ProjectNode"
+ "_TtC3VFX11RayTestNode"
+ "_TtC3VFX11TextureNode"
+ "_TtC3VFX11TexturePool"
+ "_TtC3VFX12AddChildNode"
+ "_TtC3VFX12NoopTestNode"
+ "_TtC3VFX12_RandomTNode"
+ "_TtC3VFX13DeepCloneNode"
+ "_TtC3VFX13IsKeyDownNode"
+ "_TtC3VFX13LaplacianNode"
+ "_TtC3VFX13QMultiplyNode"
+ "_TtC3VFX13ShaderArchive"
+ "_TtC3VFX13StopTimerNode"
+ "_TtC3VFX13UnprojectNode"
+ "_TtC3VFX13VFXActionNode"
+ "_TtC3VFX13_VariableNode"
+ "_TtC3VFX14ApplyForceNode"
+ "_TtC3VFX14AudioAssetNode"
+ "_TtC3VFX14CurveAssetNode"
+ "_TtC3VFX14DebugLODSystem"
+ "_TtC3VFX14ExpressionNode"
+ "_TtC3VFX14GuardIsRunMode"
+ "_TtC3VFX14MetalKitHelper"
+ "_TtC3VFX14MotionDataNode"
+ "_TtC3VFX14ScreenSizeNode"
+ "_TtC3VFX14StartTimerNode"
+ "_TtC3VFX14StringJoinNode"
+ "_TtC3VFX14TypedArrayNode"
+ "_TtC3VFX14VFXGazeTracker"
+ "_TtC3VFX14VFXHandTracker"
+ "_TtC3VFX14VFXUtilityNode"
+ "_TtC3VFX14WorldAssetNode"
+ "_TtC3VFX15ApplyTorqueNode"
+ "_TtC3VFX15CopyTextureNode"
+ "_TtC3VFX15OnCollisionNode"
+ "_TtC3VFX15OnMouseDownNode"
+ "_TtC3VFX15WorldObjectNode"
+ "_TtC3VFX15_RandomSeedNode"
+ "_TtC3VFX16AddAnimationNode"
+ "_TtC3VFX16CameraEffectNode"
+ "_TtC3VFX16GenericArrayNode"
+ "_TtC3VFX16GetSDFNormalNode"
+ "_TtC3VFX16HeaderFileSystem"
+ "_TtC3VFX16OnMouseMovedNode"
+ "_TtC3VFX16PointToPixelNode"
+ "_TtC3VFX16PresentationNode"
+ "_TtC3VFX16ThrowIfNaNOrNull"
+ "_TtC3VFX16VFXAnimationNode"
+ "_TtC3VFX16VFXHierarchyNode"
+ "_TtC3VFX16VFXMotionTracker"
+ "_TtC3VFX16_AnyECSValueNode"
+ "_TtC3VFX17ConvertVectorNode"
+ "_TtC3VFX17DummyRemapContext"
+ "_TtC3VFX17GetGPUEmitterNode"
+ "_TtC3VFX17ImplicitStartNode"
+ "_TtC3VFX17LocalRotateByNode"
+ "_TtC3VFX17NoopActionAnyNode"
+ "_TtC3VFX17SDFGenerationNode"
+ "_TtC3VFX17SetWorldStateNode"
+ "_TtC3VFX17ViewConstantsNode"
+ "_TtC3VFX18CTrampolineCodeGen"
+ "_TtC3VFX18ColorRampAssetNode"
+ "_TtC3VFX18FrameConstantsNode"
+ "_TtC3VFX18GetAnyECSValueNode"
+ "_TtC3VFX18LinearizeDepthNode"
+ "_TtC3VFX18MatrixMultiplyNode"
+ "_TtC3VFX18OnMotionUpdateNode"
+ "_TtC3VFX18SetAnyECSValueNode"
+ "_TtC3VFX18SetObjectStateNode"
+ "_TtC3VFX18_AnyWorldValueNode"
+ "_TtC3VFX19ColorConversionNode"
+ "_TtC3VFX19CommandBufferHelper"
+ "_TtC3VFX19ConstRandomSeedNode"
+ "_TtC3VFX19ConvertPositionNode"
+ "_TtC3VFX19ConvertToStringNode"
+ "_TtC3VFX19DeclareVariableNode"
+ "_TtC3VFX19GraphRunModeChecker"
+ "_TtC3VFX19RemoveAnimationNode"
+ "_TtC3VFX19_StaticECSValueNode"
+ "_TtC3VFX20BeginTransactionNode"
+ "_TtC3VFX20CommandBufferTracker"
+ "_TtC3VFX20ConvertTransformNode"
+ "_TtC3VFX20EntityPropertyHelper"
+ "_TtC3VFX20GetAnyWorldValueNode"
+ "_TtC3VFX20GetVariableValueNode"
+ "_TtC3VFX20LocalTranslateByNode"
+ "_TtC3VFX20LookupNodeByNameNode"
+ "_TtC3VFX20PreferJavaScriptNode"
+ "_TtC3VFX20RemoveFromParentNode"
+ "_TtC3VFX20SetAnyWorldValueNode"
+ "_TtC3VFX20SetVariableValueNode"
+ "_TtC3VFX20VerifierRemapContext"
+ "_TtC3VFX21CommitTransactionNode"
+ "_TtC3VFX21GetCollectionSizeNode"
+ "_TtC3VFX21InstantiatePrefabNode"
+ "_TtC3VFX21NoopRunModeActionNode"
+ "_TtC3VFX21ScriptKeyPathResolver"
+ "_TtC3VFX21_ResolvedVariableNode"
+ "_TtC3VFX21_StaticWorldValueNode"
+ "_TtC3VFX22ImplicitWorldAssetNode"
+ "_TtC3VFX22MetalTrampolineCodeGen"
+ "_TtC3VFX22MutatingRandomSeedNode"
+ "_TtC3VFX22OnUserInputTriggerNode"
+ "_TtC3VFX22RotateAroundTargetNode"
+ "_TtC3VFX22SwiftTrampolineCodeGen"
+ "_TtC3VFX22VFXSpaceConversionNode"
+ "_TtC3VFX23ContentsScaleFactorNode"
+ "_TtC3VFX23ImplicitWorldObjectNode"
+ "_TtC3VFX23OnParticleCollisionNode"
+ "_TtC3VFX23PrepareLightsSystemVFX1"
+ "_TtC3VFX23RemoveAllAnimationsNode"
+ "_TtC3VFX23ScriptTrampolineCodeGen"
+ "_TtC3VFX23VFXReferencePlaceholder"
+ "_TtC3VFX24EmitterParticleCountNode"
+ "_TtC3VFX24GetCollectionElementNode"
+ "_TtC3VFX24GetParticleCollisionNode"
+ "_TtC3VFX24MigrationPlaceholderNode"
+ "_TtC3VFX24ParticleIndexIsValidNode"
+ "_TtC3VFX24VariantDescriptorTracker"
+ "_TtC3VFX25_CurrentParticleValueNode"
+ "_TtC3VFX25_ParticleValueAtIndexNode"
+ "_TtC3VFX26InvalidateRenderTargetNode"
+ "_TtC3VFX26OnARGazeTrackingUpdateNode"
+ "_TtC3VFX26OnARHandTrackingUpdateNode"
+ "_TtC3VFX26TextToImageGeneratorSystem"
+ "_TtC3VFX27GetParticleValueAtIndexNode"
+ "_TtC3VFX27JavaScriptTrampolineCodeGen"
+ "_TtC3VFX27RemotePreviewPeerConnection"
+ "_TtC3VFX27SetParticleValueAtIndexNode"
+ "_TtC3VFX28GetResolvedVariableValueNode"
+ "_TtC3VFX28RemotePreviewSessionProtocol"
+ "_TtC3VFX28SetResolvedVariableValueNode"
+ "_TtC3VFX29InspectorSetParticleValueNode"
+ "_TtC3VFX30EmitterLookupParticleIndexNode"
+ "_TtC3VFX31EmitterGetNeighborsInRadiusNode"
+ "_TtC3VFX31ParticleEmitterGPUSystemStorage"
+ "_TtC3VFX31RemotePreviewStudioPeerListener"
+ "_TtC3VFX33RemotePreviewPlayerPeerConnection"
+ "_TtC3VFX33RemotePreviewStudioPeerConnection"
+ "_TtC3VFX37EmitterGetNearestNeighborInRadiusNode"
+ "_TtC3VFX7BoxNode"
+ "_TtC3VFX7HitNode"
+ "_TtC3VFX8CodeNode"
+ "_TtC3VFX8LoopNode"
+ "_TtC3VFX8TentNode"
+ "_TtC3VFX9CannyNode"
+ "_TtC3VFX9CloneNode"
+ "_TtC3VFX9ErodeNode"
+ "_TtC3VFX9NoiseNode"
+ "_TtC3VFX9SobelNode"
+ "_TtC3VFX9StartNode"
+ "_TtC3VFX9_CodeNode"
+ "_TtC3VFXP33_8100BC794FBB48A1AB2F92B7945A22E218ScriptKeyPathCache"
+ "_TtC3VFXP33_8D3A29A2784429379A15EB5803AD5FA218EntityManagerActor"
+ "_TtC3VFXP33_A1A4C3D28342ECFED6A0B380DFA5196417GraphScopeChecker"
+ "_TtC3VFXP33_C4E2DBBBFC07D2822B3288C0270C06A820JavaScriptCodeLoader"
+ "_TtCC3VFX12GraphCodeGenP33_22BEB975C8D88BF1BD499327E6FD4D1D10CFGInvalid"
+ "_TtCC3VFX12GraphCodeGenP33_22BEB975C8D88BF1BD499327E6FD4D1D13CFGCustomFlow"
+ "_TtCC3VFX31RemotePreviewStudioPeerListener4Peer"
+ "_TtCFC3VFX11ShaderCache12makeFunctionFzT10descriptorVS_18FunctionDescriptor7contextVS_24ShaderCompilationContext_PSo11MTLFunction_L_15FunctionWrapper"
+ "_TtCV3VFX20ParticleGenerateGrid9GPUSystem"
+ "_TtCV3VFX21ParticleSPHSimulation9CPUSystem"
+ "_TtCV3VFX21ParticleSPHSimulation9GPUSystem"
+ "_TtCV3VFX6Vortex9GPUSystem"
+ "_VFXCoderMaterialPropertyTextureProviderHelper"
+ "_VFXWorldRendererMainPassCustomPostProcessHelper"
+ "_VFXWorldRendererMainPassCustomPostProcessSupportDrawSceneBackgroundUsingEncoder:commandBuffer:renderPassDesc:"
+ "__bindings"
+ "__createPipelineStateWithDescriptor:desc:pipeline:"
+ "__drawableSize"
+ "__hasMissingAssignment"
+ "__updateCAnchor"
+ "__updateCSimulationSpeed"
+ "__useBakedTemplate"
+ "__vfx_script_table[] = {"
+ "__vfx_script_tbx"
+ "__wantsSeparateMeshElements"
+ "_activeRenderVariantDescriptors"
+ "_allocator"
+ "_automaticallyAdjustsVideoMirroring"
+ "_baseEntityName"
+ "_beginRenderPass:renderEncoder:"
+ "_bezierCurveInfoBuffer"
+ "_binaryArchives"
+ "_bindRenderPipelineArgumentsOfCommand:materialHashChanged:modelWithShaderModifier:modelWithShaderModifierHasChanged:nodeHasChanged:programHasChanged:projHasChanged:viewHasChanged:"
+ "_bindingNames:"
+ "_blendingDesc"
+ "_boundingBoxMax"
+ "_boundingBoxMin"
+ "_buffer::"
+ "_buffer::fallback:"
+ "_bufferCount"
+ "_buildBezierCurveInfoPipelineCubic"
+ "_buildBezierCurveInfoPipelineLinear"
+ "_buildBezierCurveInfoPipelineQuadratic"
+ "_buildQuadGeometryPipeline"
+ "_builder"
+ "_caMetalDisplayLink"
+ "_cachedComputeCommandEncoder"
+ "_cameraFocusPlaneModel"
+ "_cameraFrustumModel"
+ "_cameraModel"
+ "_cameraNearPlaneModel"
+ "_cameraOrthographicFrustumModel"
+ "_captureMetalFrameStarted"
+ "_cellPatternMode"
+ "_cfxDeformerStack"
+ "_cgPath"
+ "_clearContentsForDeallocation:"
+ "_cloneWithOption:copyContext:"
+ "_commandBuffer == nil"
+ "_commandEncoder"
+ "_commitResourceCommandBufferIfNeeded"
+ "_commonProfile"
+ "_commonProfileCacheLibraryHasherBlock"
+ "_commonProfileCacheLibraryProviderBlock"
+ "_computeEntityData"
+ "_computeGlobalData"
+ "_computeVFXObjectConstants"
+ "_computeViewData"
+ "_configuration"
+ "_connection"
+ "_connectionState"
+ "_copyAndCompile:"
+ "_copyBindingsFrom:"
+ "_copyInto:compile:"
+ "_copyRecursively:copyContext:"
+ "_copyWithOptions:to:copyContext:"
+ "_coreShaderCache"
+ "_crWorldFromWorldMatrix"
+ "_createCFXImageFromImage:"
+ "_createCheckedThrowingContinuation(_:)"
+ "_createSkinnerWithBones:boneWeights:boneIndices:baseMesh:"
+ "_currentClearColor"
+ "_currentEntityBuffer"
+ "_currentExternalDrawCallContext"
+ "_currentExternalViewConstants"
+ "_currentGlobalBuffer"
+ "_currentObjectBuffer"
+ "_currentPass"
+ "_currentProjectionMatrix"
+ "_currentRenderPassDesc"
+ "_currentRenderSize"
+ "_currentViewBuffer"
+ "_currentViewMatrix"
+ "_currentWorldBuffer"
+ "_curveControlPointCount"
+ "_curveInfo"
+ "_curveToGeometryTransform"
+ "_customMainPassPostProcessUsesExtraRenderTargetForRenderer:pixelFormat:"
+ "_deallocRemoteResources"
+ "_decoder"
+ "_deepCloneWithContext:"
+ "_defaultPointOfView"
+ "_deferredLoadingData"
+ "_didPresentAtTime:"
+ "_directionTexture"
+ "_disableCoreRendering"
+ "_discardPendingGPUFrameCompletedHandlers"
+ "_discardPendingGPUFramePresentedHandlers"
+ "_discardPendingGPUFrameScheduledHandlers"
+ "_drawCallContext"
+ "_drawInstancedCubeProgram"
+ "_drawInstancedQuadProgram"
+ "_drawWithUpdate:"
+ "_drawablePropertiesDidChange"
+ "_effectModel"
+ "_emitterObjectID"
+ "_emulateRRM"
+ "_encodeCustomMainPassPostProcessForRenderer:atTime:helper:"
+ "_encodeHandler"
+ "_entityBufferMetadata"
+ "_entityConstants"
+ "_entityRemapTable"
+ "_errors"
+ "_executeDeformerStackOfCommand:dataKind:deformerStack:metalDeformedMesh:skinner:skinnerCalculationMode:"
+ "_external"
+ "_eyeSightDictionary"
+ "_fieldModel"
+ "_fillFrameUniformsWithWorld:"
+ "_fillNodeA:nodeB:contactPoint:contactNormal:distance:hitFraction:"
+ "_fillProcessingContextWithCullingContext:"
+ "_fillProcessingContextWithEngineIterationContext:"
+ "_fillVFXCoreRenderData"
+ "_finalizeCloning:"
+ "_forceSynchronousLoading"
+ "_frameBufferAllocator"
+ "_from"
+ "_functionConstantValues"
+ "_functionName"
+ "_gazeTrackerActive"
+ "_geometry.texcoords[x]"
+ "_globalBufferMetadata"
+ "_globalConstants"
+ "_gpuDevice"
+ "_gpuFamily"
+ "_gpuHandlersLock"
+ "_handTrackerActive"
+ "_hashCode"
+ "_identifiersToPeers"
+ "_inFlightFramesSemaphore"
+ "_inFocusDistance"
+ "_influenceIndexSize"
+ "_influenceOffsetsBuffer"
+ "_initBezierCurveInfoPipeline"
+ "_initWithDevice:commandQueue:options:isPrivateRenderer:privateRendererOwner:clearsOnDraw:"
+ "_initializeDisplayLinkWithCompletionHandler:"
+ "_installBindingsOfNode:probeCacheIndex:"
+ "_installState"
+ "_integrateModelKitComputedMaps:withModel:node:texturePathProvider:vertexAttributeNamed:materialPropertyNamed:filePath:"
+ "_isEyeSightFrame"
+ "_isHandTrackingRoot"
+ "_isSetupForRE"
+ "_isShared"
+ "_isSideBySideStereo"
+ "_language"
+ "_lastDeformedCurveControlPointsBuffer"
+ "_lastFrame"
+ "_lastModificationDate"
+ "_lastOptionsHash"
+ "_legacyShaderCache"
+ "_libraryHash"
+ "_libraryProvider"
+ "_lightModel"
+ "_lightingContribution.%@ = %@;\n"
+ "_loadURL:options:statusHandler:error:"
+ "_maxVertexAmplificationCount"
+ "_maximumBlurRadius"
+ "_mergeWorld:parentNode:parentAssetNode:remapEntities:"
+ "_meshByRebuildingNormals"
+ "_meshForParametricModelHasChanged"
+ "_meshSourceWithData:semantic:vectorCount:componentType:componentCount:dataOffset:dataStride:"
+ "_meshlessDeformer"
+ "_metalDisplayLinkUpdate"
+ "_morphKind == VFXMTLMorphDeformerKindSparse"
+ "_motionTracker"
+ "_muteWorldChange"
+ "_newLayeredRenderTargetWithSize:arrayLength:"
+ "_newRenderTargetWithSize:"
+ "_nextWorldBuffer"
+ "_onDealloc"
+ "_operation"
+ "_optionalSelectorsInitialized"
+ "_originTexture"
+ "_originalRenderPassDesc"
+ "_outOfFocusDistance"
+ "_ownedEncoder"
+ "_ownedEncoder == nil"
+ "_parentRef"
+ "_parseBindings:function:renderPipeline:isClientProgram:customBindingsOut:"
+ "_patchCoreEntityHandle:"
+ "_peers"
+ "_pendingConnections"
+ "_physicsBodyCountInHierarchy"
+ "_playerHealth"
+ "_preferredConfiguration"
+ "_primitiveTopologyClass"
+ "_processedJoints"
+ "_programDidCompile:"
+ "_programHashCode"
+ "_propagatePhysicsBodyCountChange:"
+ "_proxies"
+ "_quadMesh"
+ "_quadPositionsBuffer"
+ "_quadTexcoordsBuffer"
+ "_quality"
+ "_rasterizationEnabled"
+ "_rayMap"
+ "_reContext"
+ "_rebuildMeshElementsFromPresentation"
+ "_rebuildMeshSourcesFromPresentation"
+ "_recreateMeshFromPresentation"
+ "_remapEntities:srcWorldIdentifier:"
+ "_remapEntityReferencesToVFXObjects:"
+ "_remapNodeReferences:nullifyIfAbsent:"
+ "_remapObjects:remapTable:"
+ "_remapTable"
+ "_remote"
+ "_remote.resourceIDToBuffer == NULL"
+ "_renderGraphParticleMaterialOverride"
+ "_renderWorldOrRemoteData"
+ "_renderer:didPresentWorld:atTime:"
+ "_rendererForPrepare"
+ "_resetMaterialsFromPresentation"
+ "_resourceIDForBuffer:"
+ "_resourceProvider"
+ "_respondToDepthMitigation"
+ "_runtimeMorphTargetCount"
+ "_runtimeMorphTargets"
+ "_samplers"
+ "_samplersCount"
+ "_scaleNodeX"
+ "_scaleNodeY"
+ "_scaleNodeZ"
+ "_scene"
+ "_sceneForCollisionPlanes"
+ "_sceneTexturesArgumentBuffer"
+ "_screenHeight"
+ "_screenSpaceAmbientOcclusionEnableBentNormal"
+ "_screenSpaceAmbientOcclusionIntensity"
+ "_screenSpaceAmbientOcclusionQuality"
+ "_screenSpaceAmbientOcclusionRadius"
+ "_screenSpaceReflectionObjectThickness"
+ "_screenSpaceReflectionQuality"
+ "_screenSpaceReflectionThicknessMode"
+ "_screenWidth"
+ "_secondaryPovs"
+ "_sendSignalWithIdentifier:delay:"
+ "_setBaseGeometry:"
+ "_setEncoder:alreadyUsed:"
+ "_setModelRef:"
+ "_setPixelBuffer:"
+ "_setSampleBuffer:"
+ "_setShapeObject:"
+ "_setSourceObject:forBinding:"
+ "_setupRemoteResourcesRegistry"
+ "_setupRenderPipelineOfCommand:tessellator:useTessellation:"
+ "_setupTessellatorOfCommand:deformersDidMutateMeshForCurrentFrame:tessellationPipelineStateHash:"
+ "_shadableIdentifier"
+ "_shaderArchive"
+ "_shaderCacheConfigurations"
+ "_shaderModifier"
+ "_shouldCaptureNextMetalFrame"
+ "_showCircleOfConfusion"
+ "_simulationAnchor"
+ "_sourceCodeShaderCache"
+ "_startCaptureIfNeeded"
+ "_stateUpdateDate"
+ "_stencilPixelFormat"
+ "_stopCapture"
+ "_subpixelData"
+ "_subpixels"
+ "_supportsDidPresentDelegate"
+ "_tessellatorValueForModel:"
+ "_texture::"
+ "_texture::fallback:"
+ "_texture::fallback:fallbackScope:"
+ "_textureCount"
+ "_textures"
+ "_timeOrigin"
+ "_timeSource"
+ "_to"
+ "_touchIdentifier"
+ "_transientDrawCall"
+ "_transientPass"
+ "_transitionsEnabled"
+ "_transmission"
+ "_transmissionColor"
+ "_unprojectPoints:count:viewport:"
+ "_updateAssociatedVFXNodeWithModelSetter:texturePathProvider:vertexAttributeNamed:materialPropertyNamed:"
+ "_updateAvailableSelectors"
+ "_updateEntityModelFromPresentation"
+ "_updateEntityPresentationFromModel"
+ "_updateModelFromPresentation"
+ "_updateModelFromPresentation:"
+ "_updatePresentationFromModel"
+ "_updateSampler"
+ "_updateVFXCoreOpacityFromNodes"
+ "_updateVFXCoreTimeStep:"
+ "_updateVFXCoreUseFixedTimeStep:"
+ "_updateViewDependentConstants:world:"
+ "_updater"
+ "_useFixedTimeStep"
+ "_usesMultisampling"
+ "_vfxDeprecatedAddAnimation:forKey:"
+ "_vfxObjectConstants"
+ "_vfxViewUniforms"
+ "_videoMirrored"
+ "_viewBufferMetadata"
+ "_viewConstants"
+ "_wantsCustomMainPassPostProcessForRenderer:"
+ "_wantsScreenSpaceAmbientOcclusion"
+ "_wantsSeparateMeshElements"
+ "_winding"
+ "_worldDidUpdateEnabledTriggers:"
+ "_worldIdentifier"
+ "_zOrigin"
+ "access name index "
+ "addAnimationAsset:forKey:"
+ "addComputePipelineWithDescriptor:"
+ "addEyeSightFrameNode:"
+ "addLibraryWithLabel:path:"
+ "addMeshRenderPipelineWithDescriptor:"
+ "addRenderPipelineWithDescriptor:"
+ "addSecondaryPointOfView:"
+ "addStateTransition:"
+ "additiveAlpha"
+ "allTextureFilesWithoutDoNotDownload"
+ "allTextureFilesWithoutOptions"
+ "alloc"
+ "allocateWithStagingBuffer:desc:forceCPUBlit:"
+ "allocatedBufferCount"
+ "allocatedTextureCount"
+ "allowEncodingUnknownType"
+ "allowHotReload"
+ "alphaBlendOperation"
+ "alphaComponent"
+ "anchor"
+ "anchorUpdateTimer"
+ "anyDrawNeedsLinearDepth"
+ "appendWithTrigger:contact:inWorld:"
+ "applyConfiguration:"
+ "applyFrom:reverse:transition:"
+ "arGazeTracker"
+ "archive"
+ "areParticlesSimulatedInWorldSpace"
+ "arg access "
+ "argumentsDefaultValues"
+ "arrayByAddingObject:"
+ "asyncLoadGPUTexture"
+ "atomByNode"
+ "attachment"
+ "attitude"
+ "authoringName"
+ "authoring_drawDeformersForNode:authoringEnvironment:"
+ "authoring_drawIndexedPrimitives:indexCount:indexType:indexBuffer:instanceCount:vertexBuffers:offsets:range:vertexDescriptor:withProgram:uniforms:uniformsLength:rasterizerStates:blendStates:"
+ "authoring_drawPrimitives:vertexCount:instanceCount:vertexBuffers:offsets:range:vertexDescriptor:withProgram:uniforms:uniformsLength:rasterizerStates:blendStates:"
+ "authoring_renderMesh:meshElement:withProgram:uniforms:uniformsLength:rasterizerStates:blendStates:texture:sampler:depthBias:"
+ "auto "
+ "auto $value = %1;\nvfx_script_graph_log(%script_context, "
+ "auto $value = %2;\nvfx_script_graph_log(%script_context, "
+ "auto %r0 = vfx_script_color_ramp_create_setting_color(%script_context, %0, %1, %2);\n#defer\nvfx_script_color_ramp_destroy(%script_context, %r0);"
+ "auto %r0 = vfx_script_get_gaze_data(%script_context, 0);\nauto %r1 = vfx_script_get_gaze_data(%script_context, 1);\nauto %r2 = vfx_script_get_gaze_data(%script_context, 2);"
+ "auto %r0 = vfx_script_get_hand_data(%script_context, "
+ "auto %r1 = vfx_script_get_gaze_data(%script_context, 0);\nauto %r2 = vfx_script_get_gaze_data(%script_context, 1);\nauto %r3 = vfx_script_get_gaze_data(%script_context, 2);"
+ "auto builder = ctx.createPersistentRenderGraphBuilder();\n"
+ "auto gpuDevice = CFXGPUDeviceCreate(nil);\n"
+ "auto* "
+ "auto* optimisedGraph = OptimiseRenderGraph(renderGraph, builder.get(), ctx);\n"
+ "auto* pass = sortedStages["
+ "auto* renderGraph = builder->build(ctx, error);\n"
+ "auto* resource = sortedStages["
+ "b15"
+ "b5"
+ "backboard"
+ "back{%@},"
+ "barrierAfterQueueStages:beforeStages:"
+ "baseGeometryBindTransform-%d"
+ "baseGeometryMeshlessPositionSource"
+ "beginEncodingWithCommandBuffer:label:"
+ "beginEncodingWithCommandBuffer:renderPassDescriptor:label:"
+ "beginExternalFrameWithEncoder:frameIndex:"
+ "beginFrameWithEncoder:frameIndex:"
+ "beginImgUIFrameWithViewportSize:backingScaleFactor:renderer:"
+ "beginShaderCacheRecording:"
+ "beginTransaction"
+ "beginTransition:"
+ "behaviorGraphWithEntityHandle:"
+ "bezierCurveGeometryWithGeometryRef:"
+ "binaryArchives"
+ "binaryFunctions"
+ "binary_functions"
+ "bindindValueForKey:"
+ "bindingDataForKey:"
+ "bindingForKey:"
+ "bindingNames"
+ "bindingTimestamp"
+ "bindingType"
+ "black"
+ "blackArray"
+ "blackUint"
+ "blend_inc_add_8x_generic"
+ "blend_inc_init_8x_generic"
+ "blendingDesc"
+ "blendingDescAt:"
+ "blitEncoder"
+ "block_mergesort_float"
+ "block_mergesort_int32_t_float"
+ "bool2"
+ "bool3"
+ "bool4"
+ "border_color::"
+ "bounce"
+ "bounceEase"
+ "boxIntersectionFunction"
+ "bp"
+ "breakthroughData"
+ "browser"
+ "btUIBreakthroughEnabled"
+ "btUIBreakthroughInfluence"
+ "buffer != nil"
+ "bufferAllocator"
+ "bufferForBuiltin:"
+ "bufferForCommonProfileArgumentNamed:"
+ "bufferForResourceID:"
+ "bufferMetadata[i].resolved"
+ "bufferPoolIsActive"
+ "bufferSlice.length() >= ((shOrder * shOrder) * 3 * sizeof(float))"
+ "buffers->dependency0Normals"
+ "buffers->dependency0Positions"
+ "buffers->dependency0Tangents"
+ "buffers->dependency1Normals"
+ "buffers->dependency1Positions"
+ "buffers->dependency1Tangents"
+ "buildAccelerationStructureDescriptors"
+ "builderHeaderScript"
+ "builtinForBufferSlice:"
+ "builtinForTexture:"
+ "c4"
+ "caMediaTimingFunction"
+ "cachedComputeFunctionName"
+ "cachedFunctionConstants"
+ "cachedPipelineState"
+ "call emitConstructor() instead"
+ "callWithArguments:"
+ "cameraEffect"
+ "cameraFocusPlaneModel"
+ "cameraFrustumModel"
+ "cameraModel"
+ "cameraNearPlaneModel"
+ "cameraOrthographicFrustumModel"
+ "capture"
+ "caseNames"
+ "cellPatternMode"
+ "centerTransform"
+ "centerWorldTransform"
+ "changeDecoderSpeed:"
+ "channelCount == rhs.lookupInfo->channelCount"
+ "char2"
+ "char2N"
+ "char3"
+ "char3N"
+ "char4N"
+ "checkAllEntityReferences"
+ "checkNoReferenceToOldECS:oldWorldRef:"
+ "classForCoder"
+ "cleanupPrefabsReferences"
+ "clearArgumentBufferDescriptors"
+ "clearBackBufferWithUpdate:"
+ "clearIfMissing"
+ "clientIdentifier"
+ "clientTextureIdentifier"
+ "clipping"
+ "clippingSdfTextureArray"
+ "codeEntitiesWithTable"
+ "codingID"
+ "collectCoreEntityHandles"
+ "colorSpaceName"
+ "colorU"
+ "colorV"
+ "com.apple.Photos"
+ "com.apple.VFXPlayer"
+ "com.apple.VFXView-displaylink"
+ "com.apple.mobileslideshow"
+ "commitTransition:"
+ "commonProfileGeneratorAllowingHotReload:"
+ "componentCount"
+ "componentCountAtKeyPath:target:"
+ "componentIndex * sizeof(float) + length <= sizeof(CFXColor4)"
+ "componentSize"
+ "configurationIsIncompatibleWithStudio"
+ "connectToStudio"
+ "connection"
+ "connectionCancelled"
+ "connectionFailed"
+ "connectionReady "
+ "connectionToStudioFailed"
+ "connectionToStudioStarted"
+ "connectionToStudioWasCancelled"
+ "const $keypath = "
+ "const $options = {};\n$options['kHitTestBoundingBoxOnly'] = %1;\n$options['kHitTestSkipHiddenNode'] = %2;"
+ "const $options = {};\n$options['kHitTestBoundingBoxOnly'] = %3;\n$options['kHitTestSkipHiddenNode'] = %4;"
+ "const $strings = ["
+ "const $subgraph_outputs = new Array("
+ "const %@ %@ = %@.%@;\n"
+ "constant int32_t& spawnID                         [[ buffer(vfx_buffer_binding_index_compute_spawn_id) ]]"
+ "constants"
+ "contentsOffset"
+ "contentsRotation"
+ "convertToAdditiveWithBaseGeometry:"
+ "convertToSparseWithBaseGeometry:"
+ "copyAndCompileScripts"
+ "copyFromTensor:sourceOrigin:sourceDimensions:toTensor:destinationOrigin:destinationDimensions:"
+ "copyParticleData"
+ "copyPropertiesFrom:copyContext:"
+ "copyTo:withContext:"
+ "copy_array_to_side_by_side"
+ "copy_final_order_with_visible"
+ "coreEntity"
+ "coreEntityManager"
+ "coreHandleWasResolved"
+ "could not compile scripts: "
+ "could not migrate asset node referencing "
+ "couldn't find function for js script "
+ "couldn't map script parameter at: "
+ "couldn't write Metal pripeline script: "
+ "counterClockwise"
+ "createCollisionPlane:transform:"
+ "createEntityPropertyHelperWithObjectID:"
+ "createEntityPropertyHelperWithTag:"
+ "createManagedResource(\""
+ "createNullEntityPropertyHelper"
+ "createProviderWithOptions:"
+ "createResource(\""
+ "ctx.stackAllocator().frame([&] {\n"
+ "cubeFromViewTransform"
+ "cubeFromViewTransform:"
+ "cubicEaseIn"
+ "cubicEaseInOut"
+ "cubicEaseOut"
+ "cullParticleGPU needs a pointOfCulling"
+ "cullParticleGPU needs a renderer"
+ "cullingContext"
+ "cullingContext->engineContext"
+ "cumulativeCache"
+ "currentArgumentDescriptor != nil"
+ "currentArgumentDescriptor == nil"
+ "currentBufferAllocatorPerFrame"
+ "currentCommandBufferHelper"
+ "currentExternalDrawCallContext"
+ "customPropertyNames"
+ "d48@0:8@16@24^{__CFXEngineContext=}32{?=b8b8b8b8b8b8b8b7b1}40"
+ "deallocateElementAtOffset:inPage:"
+ "debugQuickLookObjectWithWorld:"
+ "debug_colorbox_vert"
+ "declaration"
+ "decode:"
+ "decodeAndEnumerateRemoteFrame:usingBlock:"
+ "decodeFn"
+ "decodeRemoteFrame:skipDrawCalls:"
+ "deepCloneWithContext:"
+ "default.metallib"
+ "defaultEulerAngles"
+ "defaultPointOfView"
+ "defaultPosition"
+ "defaultShapeForModel:"
+ "defines"
+ "deformedRaytraceableMeshForNode:fallbackModel:"
+ "deformerClassForMeshlesshGeometry:"
+ "deformerStack"
+ "deformer_bezier_build_info_cubic"
+ "deformer_bezier_build_info_linear"
+ "deformer_bezier_build_info_quadratic"
+ "deformer_bezier_build_quad_geometry"
+ "deformer_bezier_init_info"
+ "deformsControlPointsForMeshlessGeometry:"
+ "density_relaxation"
+ "depth: %@,"
+ "depthAttachmentPixelFormat"
+ "depthMitigationTransitionFactor"
+ "depthStencilStateForDepthStencilDesc:"
+ "descForDepthStencilState:"
+ "descForSamplerState:"
+ "destinationAlphaBlendFactor"
+ "destinationRGBBlendFactor"
+ "destinationTexture"
+ "destroyBufferWithRemoteID:"
+ "destroyCollisionPlane:"
+ "destroyTextureWithRemoteID:"
+ "deviceMotion"
+ "deviceMotionUpdateInterval"
+ "deviceWithUniqueID:"
+ "devices"
+ "didInitConstraintRef"
+ "didReceiveNewWorldArchivedAt:"
+ "didRenameTag:to:"
+ "didSetPointOfView:"
+ "directionTexture"
+ "dirty"
+ "dirtyQuery"
+ "disableCoreRendering"
+ "disableEntities:"
+ "discardPendingCommandBufferCompletedHandlers"
+ "discardPendingCommandBufferScheduledHandlers"
+ "discardPendingDrawablePresentedHandlers"
+ "discoverySessionWithDeviceTypes:mediaType:position:"
+ "dispatchOnGrid1D:"
+ "dispatchOnGrid2D:"
+ "dispatchOnGrid3D:"
+ "displayLink:didUpdate:"
+ "distance_squared"
+ "distantFuture"
+ "doNotExport"
+ "documentation"
+ "dof_gather"
+ "downsampling#intrinsic"
+ "drawAuthoringEnvironment:node:context:"
+ "drawCallCountWithEmitterID:"
+ "drawRenderElement:withOverrides:"
+ "drawSceneBackgroundUsingEncoder:commandBuffer:renderPassDescriptor:"
+ "drawable"
+ "edgeMode#intrinsic"
+ "effectModel"
+ "effectiveTarget"
+ "elementIndex == (int)elementCount"
+ "emitter#intrinsic"
+ "emitterObjectID"
+ "enableDepthMitigation"
+ "enableSSAO"
+ "enableScriptDiagnosticsTracing"
+ "enable_vertex_amplification"
+ "enabledTypes"
+ "encode:"
+ "encodeAuthoringWithEncoder:renderer:colorFormat:depthStencilFormat:sampleCount:"
+ "encodeCommandsInNewCommandBufferUsingBlock:"
+ "encodeHandler"
+ "encodeNewlyRegisteredResources:"
+ "encodeRemoteFrameWithBuffers:textures:"
+ "encodersCreated"
+ "endExternalFrame"
+ "endImgUIFrameWithCommandBuffer:encoder:renderPassDescriptor:renderer:"
+ "endpoint"
+ "entityHelper"
+ "entityObject's EM got deallocated"
+ "enumerateAnimationReferencesUsingBlock:"
+ "enumerateDrawCallsForNode:usingBlock:"
+ "enumerateDrawCallsUsingBlock:context:"
+ "enumerateInternalDeformersUsingBlock:"
+ "enumerateReferencesForOperation:usingBlock:"
+ "enumerateSecondaryPointOfViewsUsingBlock:"
+ "envProbeTable"
+ "et la on invalidate"
+ "evaluateScript:"
+ "exception"
+ "exponentialEase"
+ "externalDrawCallQuery"
+ "eyeAnchorUpdateInterval"
+ "eyeSightFrame"
+ "fetchArgumentBufferDescriptorWithRemoteID:offset:"
+ "fieldModel"
+ "fileFormatVersion"
+ "fillRemapTable:copy:"
+ "filterMap"
+ "filterRepeats"
+ "filterRepeats#intrinsic"
+ "finalMesh"
+ "finalize"
+ "finishLoadingWithSerializationContext:"
+ "flagAsPresentationObject"
+ "flatness2"
+ "float2 bezierCurveUV;\n"
+ "float2 texcoord0;\n"
+ "float2 texcoord1;\n"
+ "float2 texcoord2;\n"
+ "float2 texcoord3;\n"
+ "float2 texcoord4;\n"
+ "float2 texcoord5;\n"
+ "float2 texcoord6;\n"
+ "float2 texcoord7;\n"
+ "float2x2"
+ "float2x4"
+ "float3x2"
+ "float3x4"
+ "float4(%0[0]*%0[3], %0[1]*%0[3], %0[2]*%0[3], %0[3])"
+ "float4(%translation[0], %translation[1], %translation[2], 1.0)"
+ "float4x2"
+ "float4x3"
+ "flow control nodes must implement flowSignature"
+ "fmax3"
+ "fmin3"
+ "for (auto& stage : optimisedGraph->stages()) {\n"
+ "for (auto* p : optimisedGraph->passes())\n"
+ "forceDepthPostPass"
+ "forearmArm"
+ "forearmWrist"
+ "fragment_linked_functions"
+ "front{%@},"
+ "frustumCullPerParticle"
+ "functionConstantValues"
+ "functionHandleWithBinaryFunction:"
+ "functionHandleWithBinaryFunction:stage:"
+ "functionHandleWithName:"
+ "functionHandleWithName:stage:"
+ "gen2D_checkerboard"
+ "genCube_skybox_daynight"
+ "genCube_skybox_gradient"
+ "genCube_skybox_gradient2"
+ "genCube_skybox_milkyway"
+ "generateBindingsForPipeline:withReflection:program:materialIdentifier:overrides:"
+ "generate_keys_spawn_id"
+ "geometry == NULL || CFXGeometryGetType(geometry) == kCFXGeometryTypeMesh"
+ "geometry."
+ "getReturnValue:"
+ "gpuFamily"
+ "gyroUpdateInterval"
+ "h"
+ "half2x2"
+ "half2x3"
+ "half2x4"
+ "half3x2"
+ "half3x3"
+ "half3x4"
+ "half4x2"
+ "half4x3"
+ "half4x4"
+ "handChirality"
+ "handChivarly#intrinsic"
+ "handJoint"
+ "handJoint#intrinsic"
+ "handShakeWithObject:reply:"
+ "hasBadReference"
+ "hasParticleColliderComponent"
+ "hasParticleEmitterComponent"
+ "has_raymap"
+ "has_ribbon_cap_begin_texture"
+ "has_ribbon_cap_end_texture"
+ "hash should be in the table!"
+ "hashCode"
+ "hdr"
+ "headerInludeString"
+ "heading"
+ "height#intrinsic"
+ "highThreshold#intrinsic"
+ "hitDistanceTex"
+ "horizontal"
+ "i1010102N"
+ "identifier#intrinsic"
+ "identifiersToPeers "
+ "if ($value !== null) { %r0 = $value; }"
+ "if (VFX::RG::isCopyPass(p))\n"
+ "if (contains_nan(%0)) { throw '%0 is NaN'; }"
+ "if (contains_null_or_nan(%0)) { throw '%0 is null or NaN'; }"
+ "if (first->classIdentifier() == second->classIdentifier()) {\n"
+ "if (particles.newly_created_is_outside(&pid, spawnID)) return;"
+ "ignoreHiddenNodes"
+ "immersiveEnvironmentMask"
+ "in.screen_uv"
+ "inFocusDistance"
+ "inProgress compilation"
+ "index < CFX_MAX_COLOR_ATTACHMENTS"
+ "index path "
+ "indexBufferWriteOffset == headerLength"
+ "indexFingerIntermediateBase"
+ "indexFingerIntermediateTip"
+ "indexFingerKnuckle"
+ "indexFingerMetacarpal"
+ "indexFingerTip"
+ "influenceCount"
+ "influenceOffsets[%d]"
+ "info.wantsFinalNormalsBuffer == false"
+ "info.wantsFinalTangentsBuffer == false"
+ "infoByScriptLocation"
+ "iniWithBlock:"
+ "iniWithLibrary:"
+ "iniWithLibraryURL:"
+ "initPresentation:"
+ "initPresentationConstraintWithConstraintRef:"
+ "initPresentationModelWithModelRef:"
+ "initPresentationWorldWithWorldRef:"
+ "initWithBinding:coreEntityHandle:"
+ "initWithCGPath:"
+ "initWithCGPath:transform:"
+ "initWithDescriptor:"
+ "initWithDevice:kernelWidth:kernelHeight:"
+ "initWithDevice:kernelWidth:kernelHeight:values:"
+ "initWithDevice:kernelWidth:kernelHeight:weights:"
+ "initWithDevice:remoteEncoding:"
+ "initWithEngineContext:resourceManager:commandQueue:"
+ "initWithEntityHandle:"
+ "initWithHashCode:"
+ "initWithInteger:"
+ "initWithLayer:runLoop:block:"
+ "initWithMeshlessGeometry:outputs:deformDataKind:finalDataKind:resourceManager:computeContext:"
+ "initWithMetalLayer:"
+ "initWithModel:resourceManager:"
+ "initWithModelRef:"
+ "initWithPerceptualDuration:bounce:"
+ "initWithRed:green:blue:alpha:"
+ "initWithRemoteFrameBuilder:"
+ "initWithRemoteFrameBuilder:encoder:"
+ "initWithShaderModifier:"
+ "initWithURL:options:"
+ "init_neighbor_grid"
+ "initiatedConnection"
+ "innerLayerNode"
+ "inputPrimitiveTopology"
+ "inputValues"
+ "insertSplit"
+ "instantiate:"
+ "interfaceWithProtocol:"
+ "interpolant<float2, interpolation::perspective> bezierCurveUV;\n"
+ "intersection_functions"
+ "intrinsicNodes"
+ "invalid colorRamp binding type"
+ "invalid language: "
+ "invalidateGraphV1"
+ "invalidateHelper"
+ "invalidateShape"
+ "inverseProjectionTransform"
+ "inverseProjectionTransform:"
+ "inverseTransposeViewTransform"
+ "inverseTransposeViewTransform:"
+ "inverseViewProjectionTransform"
+ "inverseViewProjectionTransform:"
+ "inverseViewTransform"
+ "inverseViewTransform:"
+ "invocationWithMethodSignature:"
+ "invoke"
+ "isAlphaToCoverageEnabled"
+ "isAlphaToOneEnabled"
+ "isArray"
+ "isBlendingEnabled"
+ "isEmulatingRRM"
+ "isEyeSightFrame"
+ "isEyesightFrame"
+ "isHandTrackingRoot"
+ "isHeader"
+ "isInEditingMode"
+ "isLowLatency"
+ "isNull"
+ "isRasterizationEnabled"
+ "isRenderingInRE"
+ "isRepeat"
+ "isSideBySideStereo"
+ "isSpring"
+ "isTemporal"
+ "isTessellationFactorScaleEnabled"
+ "isVFX2Presentation"
+ "isVisible"
+ "isolateResourceManager"
+ "ispTonemapLUT"
+ "jointIndices[%d]"
+ "jointWeights[%d]"
+ "jsCode"
+ "jsContext"
+ "kCFXBaseTypeInt32"
+ "kCFXBaseTypeInt64"
+ "kCFXNotificationModelWillDie"
+ "kCFXNotificationParametricModelTypeDidChange"
+ "kCFXWorldDidUpdateEnabledTriggersNotification"
+ "kCoreEntityKey"
+ "kSceneSourceCleanupMeshes"
+ "kSceneSourceFormat"
+ "kVFXRendererInitOptionForRERendering"
+ "kVFXSceneSourceConvertToUnit"
+ "kWorldInitOptionForRERendering"
+ "keyCodeFilter#intrinsic"
+ "keyPathByRef"
+ "lastFrame"
+ "lastFrameViewProjectionTransform"
+ "lastFrameViewProjectionTransform:"
+ "lastUpdateTime"
+ "lazyMTKTextureLoader"
+ "leftEyeTransform"
+ "leftEyeWorldTransform"
+ "libraryForDevice:"
+ "libraryForProgramDesc:resourceManager:completionHandler:"
+ "libraryProvider"
+ "line nodeID "
+ "littleFingerIntermediateBase"
+ "littleFingerIntermediateTip"
+ "littleFingerKnuckle"
+ "littleFingerMetacarpal"
+ "littleFingerTip"
+ "llu);\n"
+ "loadNonNativeFormatAt:options:statusHandler:error:"
+ "loadWithUrl:loadingFor:options:infoOut:error:"
+ "loadWorldDescriptionAt:options:compressed:statusHandler:error:"
+ "loadWorldDescriptionFromData:options:compressed:sourceURL:statusHandler:error:"
+ "loadWorldFromData:options:statusHandler:error:"
+ "loadWorldFromURL:options:statusHandler:error:"
+ "local"
+ "localizedName"
+ "lodStateQuery"
+ "logSharedResources"
+ "long"
+ "longValue"
+ "lowThreshold#intrinsic"
+ "magneticFieldAccuracy"
+ "magnetometerUpdateInterval"
+ "mainPassColorTextureAtIndex:"
+ "makeCompatibleRenderer"
+ "makeRenderPipelineForResourceID:"
+ "makeTextureLoadingSynchronous"
+ "mangleString"
+ "mappingChannelMaskForTexcoordsUse"
+ "materialOverride#intrinsic"
+ "materialPropertyMaskForTexcoordsUse"
+ "matrix3x3_column(vfx_quat_to_matrix3x3(%0), 2)"
+ "max3"
+ "maxCount#intrinsic"
+ "maxGridResolution"
+ "maxNeighborsPerCell"
+ "maxResolution"
+ "maxRetryCount"
+ "maxSearchRadius"
+ "maxVertexAmp"
+ "maxVertexAmplificationCount"
+ "maximumBlurRadius"
+ "median3"
+ "mergeScene error - inconsistent clone entity count"
+ "mergeScene:"
+ "mergeWorld:parentNode:parentAssetNode:"
+ "merge_subarrays_float"
+ "merge_subarrays_int32_t_float"
+ "meshElement == NULL"
+ "meshElement->_topology.type == kCFXMeshElementTypePolygonsArray"
+ "meshElementCount > 0"
+ "meshElementIndex"
+ "meshElementWithMeshElementRef:"
+ "meshRenderPipelines"
+ "meshSourceWithColorComponents:count:hasAlpha:colorSpace:"
+ "meshSourceWithMDLVertexAttribute:mesh:"
+ "meshSourceWithMeshSourceRef:"
+ "metalDisplayLink:needsUpdate:"
+ "metalDisplayLinkUpdate"
+ "metalMesh.volatileBuffer != nil"
+ "methodReturnLength"
+ "methodReturnType"
+ "methodSignatureForSelector:"
+ "middleFingerIntermediateBase"
+ "middleFingerIntermediateTip"
+ "middleFingerKnuckle"
+ "middleFingerMetacarpal"
+ "middleFingerTip"
+ "migrationPlaceholders"
+ "min3"
+ "mirrored"
+ "missing call parameter '"
+ "missing case for js: "
+ "model->_subdivInfo.subdivisionLevel > 0"
+ "model->_trackedNodes"
+ "model->_trackedNodes && CFSetContainsValue(model->_trackedNodes, node)"
+ "model."
+ "model.materials[%d]"
+ "modelCount"
+ "modelForLightType:"
+ "modelModificationCount"
+ "modelRef"
+ "modelWithGeometry:"
+ "modelWithModelRef:"
+ "modifiers"
+ "morpher._isUsingSparseTargets == vfxMorpher._isUsingSparseTargets"
+ "motionManager"
+ "motionUpdateTimer"
+ "mtlMesh"
+ "muteWorldChange"
+ "names"
+ "names.count < CFX_MAX_CUSTOM_TEXCOOORD"
+ "namespace vfx_%@ {"
+ "nearFar:"
+ "needsUpdate"
+ "newArchiveWithURL:error:"
+ "newArgumentTableWithDescriptor:error:"
+ "newBuffer:remoteID:"
+ "newBufferWithLength:options:placementSparsePageSize:"
+ "newCommandAllocator"
+ "newCommandAllocatorWithDescriptor:error:"
+ "newCommandBuffer"
+ "newCompilerWithDescriptor:error:"
+ "newComputePipelineStateWithBinaryFunctions:error:"
+ "newCounterHeapWithDescriptor:error:"
+ "newFrame:index:"
+ "newMTL4CommandQueue"
+ "newMTL4CommandQueueWithDescriptor:error:"
+ "newPipelineDataSetSerializerWithDescriptor:"
+ "newProxyWithIdentifier:"
+ "newRadianceTextureForEnvironmentTexture:size:engineContext:cpuAccessible:"
+ "newRenderPipelineDescriptorForSpecialization"
+ "newRenderPipelineStateWithBinaryFunctions:error:"
+ "newTensorWithDescriptor:error:"
+ "newTensorWithDescriptor:offset:error:"
+ "newTextureViewPoolWithDescriptor:error:"
+ "newTextureViewWithDescriptor:"
+ "nextLocationIndex"
+ "nextPathComponent"
+ "no script runtime"
+ "no such function: "
+ "node attachment name "
+ "nodeWithMDLObject:masterObjects:worldNodes:skinnedMeshes:skelNodesMap:asset:options:context:mpuScale:"
+ "not a collection"
+ "not an aggregate"
+ "not enough context to decide!"
+ "notifications._eventType == kCFXNotificationEventType_Model"
+ "null"
+ "null pass, invalid translation"
+ "object scriptKeyPath "
+ "offset < 16"
+ "offset < 3"
+ "offset=%d&size=%d&name=%@"
+ "oldGeneration"
+ "onDealloc"
+ "openPackageWithUrl:"
+ "operationCount"
+ "orientationMode"
+ "originTexture"
+ "originalSource"
+ "osd"
+ "osdRuntimeData->patchComputeContext.perPatchTypeComputePipelines[patchType] == nil"
+ "osd_rt_eval_extra_point_fvar"
+ "osd_rt_eval_extra_point_vertex"
+ "osd_rt_eval_regular_point_fvar"
+ "osd_rt_eval_regular_point_vertex"
+ "outOfFocusDistance"
+ "outerLayerNode"
+ "output1 = input1 + input2;"
+ "outputPath"
+ "outputsAlbedoMetalness"
+ "outputsByNode"
+ "outputsNormalRoughness"
+ "outputsRadianceAO"
+ "outputs_normal_roughness"
+ "overallVertexIndex == (CFIndex)effectiveIndexCount"
+ "p_"
+ "palm"
+ "parallelRenderEncoder"
+ "parameterInfoForKey:"
+ "particleColliderWithEntityHandle:"
+ "particleEmitterWithEntityHandle:"
+ "particleMaterial"
+ "particleMaterialOverride#intrinsic"
+ "particle_debug_print"
+ "particle_fill_grid"
+ "particles.get_spawn_id_if_present(pid, spawnID)"
+ "pass resource "
+ "passes_array_t sortedPasses(ctx.stackAllocator(), stage.size());\n"
+ "patchArgumentBufferWithEncoder:encoderContext:"
+ "patchParamsBuffer.storageMode == MTLStorageModePrivate || patchParamsBuffer.storageMode == MTLStorageModeShared"
+ "payload"
+ "pendingConnections "
+ "perThreadRenderEncoder"
+ "perceptualDuration"
+ "performBlockThrowingExceptionsAsErrors:error:"
+ "physicalEase"
+ "pingPongDiffuseTex0"
+ "pingPongSpecularTex0"
+ "pingPongVarianceTex0"
+ "pipelineDesc"
+ "pixelFormat not supported on CPU: "
+ "pixelFormat#intrinsic"
+ "placeholderQuery"
+ "playerConfiguration"
+ "pointOfViewDependencies"
+ "portalPlane"
+ "postCommandAvoidingImmediateModeWithWorldRef:applyBlock:"
+ "postCommandWithObject:applyBlock:"
+ "postCommandWithObject:key:applyBlock:"
+ "postCommandWithObject:key:subscriptIndex:derivedKeyPath:applyBlock:"
+ "postCommandWithObject:key:subscriptKey:derivedKeyPath:applyBlock:"
+ "postCommandWithObject:keyPath:applyBlock:"
+ "postCommandWithWorldRef:applyBlock:"
+ "postReleaseCommandWithCFXObject:"
+ "powerEase"
+ "precomputedLightingEnvironmentDataForContents:radianceTextureSize:device:error:"
+ "prefabWithNode:"
+ "preferredConfiguration"
+ "preferredDeviceID"
+ "preferredmacOSSDK"
+ "preferredmacOSToolchain"
+ "prepareDrawCalls"
+ "prepareDrawCallsWithFrameIndex:renderer:"
+ "prepareWithRenderer:"
+ "presentationBindingForKey:"
+ "presentationBoneNode"
+ "presentationConstraint"
+ "presentationConstraintWithConstraintRef:"
+ "presentationHandleWithEntityObject:"
+ "presentationModelWithModelRef:"
+ "presentationProperties"
+ "presentationWorld"
+ "previousLocationInView:"
+ "primitiveTopologyClass"
+ "primvarDataTypeHash"
+ "privateBindingNames"
+ "privateFunctions"
+ "privateNames"
+ "private_functions"
+ "processDefaultLibrary"
+ "processedGraphs"
+ "programHashCode->_desc.materialPropertysHash[i] <= ((1 << (kCFXMaterialPropertyTypeHashIndexMax + 1)) - 1)"
+ "programHashCodeEncoderWithHashCode:"
+ "projectFolder"
+ "projectPoints:count:viewport:"
+ "projectionTransform:"
+ "projectionTransformValue"
+ "proxyWithIdentifier:"
+ "publishedAttachmentPasses"
+ "publishedAttachments"
+ "q16@?0^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}8"
+ "q32@0:8@16@24"
+ "quadIntersectionFunction"
+ "quadraticEaseIn"
+ "quadraticEaseInOut"
+ "quadraticEaseOut"
+ "quality"
+ "quarticEaseIn"
+ "quarticEaseInOut"
+ "quarticEaseOut"
+ "queryTimestampFrequency"
+ "quinticEaseIn"
+ "quinticEaseInOut"
+ "quinticEaseOut"
+ "r <= CFXSkinGetTotalInfluenceCount(skin)"
+ "r^v16@0:8"
+ "r_"
+ "radianceTextureForEnvironmentTexture:engineContext:"
+ "rasterSampleCount"
+ "rasterizationEnabled"
+ "rayMap"
+ "raymap_origin_z"
+ "raymap_scale"
+ "raytracingContext.perPatchTypeExtraComputePipelines[patchType] == nil"
+ "raytracingContext.perPatchTypeFVarExtraComputePipelines[patchType] == nil"
+ "raytracingContext.perPatchTypeFVarRegularComputePipelines[patchType] == nil"
+ "raytracingContext.perPatchTypeRegularComputePipelines[patchType] == nil"
+ "reContext"
+ "recordedShaderSourceCode"
+ "recycleBuffersGetCompletionWithRenderer:"
+ "recycleDrawCalls"
+ "reflectionForFunctionWithName:"
+ "registerBuiltinBuffer:builtin:"
+ "registerBuiltinTexture:builtin:"
+ "registerCustomProgramBindingBlockTrampoline:"
+ "registerPlayerIfNeeded:"
+ "registerRESystems"
+ "registerREinVFX2Systems"
+ "registerRenderPipeline:forResourceID:"
+ "registerRenderPipelineDescriptor:state:"
+ "registering entityObject with no tag"
+ "remapEntityReferences:duplicating:"
+ "remoteDecoder"
+ "remoteEncoder"
+ "remotePreviewProtocolVersion"
+ "remoteRegisterArgumentBufferDescriptor:remoteID:offset:"
+ "remoteRegisterBuffer:remoteID:"
+ "remoteRegisterRenderPipelineDescriptor:remoteID:"
+ "remoteRegisterTexture:remoteID:"
+ "remoteResourceProvider"
+ "remoteUnregisterBuffer:"
+ "remoteUnregisterTexture:"
+ "removeAllBuiltinBuffers"
+ "removeAllBuiltinTextures"
+ "removeCollisionPlane:"
+ "removeEyesightFrameNode:"
+ "removeFromPendingConnections "
+ "removeResourceForKey:fromRegistry:"
+ "removeResourceIDForResource:"
+ "removeSecondaryPointOfView:"
+ "removeStateTransition:"
+ "removing entityObject with no tag"
+ "render pass"
+ "renderBackground#intrinsic"
+ "renderGraphMaterialOverride"
+ "renderPipelineDescForResourceID:"
+ "renderPipelineForResourceID:"
+ "renderPipelineID != 0"
+ "renderResourceForProgramDesc:renderPassDesc:"
+ "renderResourcesFor:renderPassFormat:"
+ "renderWorldPassesAndDependencies"
+ "renderer-renderer-renderer-renderer"
+ "rendererElement->_renderableAttributeKind == kCFXRenderableAttributeKindVFXCore"
+ "rendererPlaceholder"
+ "rendererStatisticsProvider"
+ "rendererWithCommandQueue:options:"
+ "renderer_constants_enable_ssao"
+ "renderer_constants_outputs_albedo_metalness"
+ "renderer_constants_outputs_radiance_ao"
+ "renderer_constants_use_api_v2"
+ "replacementObjectForCoder:"
+ "requiredThreadsPerMeshThreadgroup"
+ "requiredThreadsPerObjectThreadgroup"
+ "requiredThreadsPerThreadgroup"
+ "requiredThreadsPerTileThreadgroup"
+ "resetPhysicsBodyTransformInHierarchy"
+ "resolveCache"
+ "resolved color"
+ "resolvedURLForContents:"
+ "resourceAllocation failed: "
+ "resourceConsumer"
+ "resourceIDForBuffer:"
+ "resourceIDForBufferSlice:"
+ "resourceIDForRenderPipelineState:"
+ "resourceIDForTexture:"
+ "resourceManager[%p] {"
+ "restoreAABBQuery"
+ "retryCount"
+ "rgbBlendOperation"
+ "rightEyeTransform"
+ "rightEyeWorldTransform"
+ "ringFingerIntermediateBase"
+ "ringFingerIntermediateTip"
+ "ringFingerKnuckle"
+ "ringFingerMetacarpal"
+ "ringFingerTip"
+ "rotationMatrix"
+ "rotationRate"
+ "sampledAttachments"
+ "samplerStateForSamplerDesc:"
+ "scheduling"
+ "screenHeight"
+ "screenSpaceAmbientOcclusionEnableBentNormal"
+ "screenSpaceAmbientOcclusionQuality"
+ "screenSpaceReflectionObjectThickness"
+ "screenSpaceReflectionQuality"
+ "screenSpaceReflectionThicknessMode"
+ "screenWidth"
+ "script_hitTest:options:"
+ "script_instantiate:"
+ "script_rootNode"
+ "selectedCase.defaultValue"
+ "self-self-self-self"
+ "selfPlaceholder"
+ "sendSignalWithIdentifier:delay:"
+ "setAbsolutePath:"
+ "setAnchor:"
+ "setAnimationDurationAsFloat:"
+ "setArgument:atIndex:"
+ "setBaseGeometryBindTransform:"
+ "setBindingData:forKey:"
+ "setBindingType:"
+ "setBindingValue:size:forKey:"
+ "setBlendingDesc:at:"
+ "setBounce:"
+ "setBoundingBoxMax:"
+ "setBoundingBoxMin:"
+ "setBuffer:offset:at:"
+ "setBufferSlice:atIndex:"
+ "setCellPatternMode:"
+ "setClientIdentifier:"
+ "setClientTextureIdentifier:"
+ "setClipRect:"
+ "setColorAttachmentMap:"
+ "setColorSpaceName:"
+ "setCompareFunction:"
+ "setContentsOffset:"
+ "setContentsRotation:"
+ "setContentsScale:"
+ "setCurrentExternalDrawCallContext:"
+ "setCurrentPass:"
+ "setDefaultPointOfView:"
+ "setDepthTestMinBound:maxBound:"
+ "setDirectionTexture:"
+ "setDisableCoreRendering:"
+ "setEdgeMode:"
+ "setEmulateRRM:"
+ "setEncodeHandler:"
+ "setErrorOptions:"
+ "setException:"
+ "setFileName:"
+ "setFragmentLinkedFunctions:"
+ "setFrom:"
+ "setFunctionConstantValues:"
+ "setFunctionName:"
+ "setGeometry:"
+ "setGpuFamily:"
+ "setHandle:"
+ "setImmediateModeWithAtomicTime:"
+ "setInFocusDistance:"
+ "setIsEyeSightFrame:"
+ "setIsHandTrackingRoot:"
+ "setIsLocal:"
+ "setIsPublic:"
+ "setIsRenderingInRE:"
+ "setIsSideBySideStereo:"
+ "setIsVisible:"
+ "setLastUpdateTime:"
+ "setLibraryProvider:"
+ "setLocal:"
+ "setMaterialType:"
+ "setMaximumBlurRadius:"
+ "setMetalDisplayLinkUpdate:"
+ "setModelModificationCount:"
+ "setModelRef:"
+ "setMuteWorldChange:"
+ "setNextFrameTime:"
+ "setOnDealloc:"
+ "setOriginTexture:"
+ "setOutOfFocusDistance:"
+ "setOwner:"
+ "setPerceptualDuration:"
+ "setPreferredFrameLatency:"
+ "setPrimitiveTopologyClass:"
+ "setProgramHashCode:"
+ "setProjectionTransformValue:"
+ "setQuality:"
+ "setRawValueNoReplication:"
+ "setRayMap:"
+ "setRemoteResourceProvider:"
+ "setRendererStatisticsProvider:"
+ "setSampler:at:"
+ "setScreenHeight:"
+ "setScreenSpaceAmbientOcclusionEnableBentNormal:"
+ "setScreenSpaceAmbientOcclusionQuality:"
+ "setScreenSpaceReflectionObjectThickness:"
+ "setScreenSpaceReflectionQuality:"
+ "setScreenSpaceReflectionThicknessMode:"
+ "setScreenWidth:"
+ "setSelector:"
+ "setShaderCacheConfigurations:"
+ "setShowCircleOfConfusion:"
+ "setSideBySideStereo:"
+ "setSimulationAnchor:"
+ "setSimulationRate:"
+ "setSimulationSpeed:"
+ "setSpringCoefiscients:"
+ "setStateNamed:"
+ "setStencilPixelFormat:"
+ "setSubpixelData:"
+ "setSubpixels:"
+ "setSwiftString:"
+ "setTexture:at:"
+ "setTimeOrigin:"
+ "setTimeSource:"
+ "setTo:"
+ "setToolsDispatchBufferSPI:atIndex:stages:"
+ "setTransitionOverride:forItem:"
+ "setTransitionsEnabled:"
+ "setUpdater:"
+ "setUseFixedTimeStep:"
+ "setUsesMultisampling:"
+ "setVertexFormat:"
+ "setVertexLinkedFunctions:"
+ "setWantsScreenSpaceAmbientOcclusion:"
+ "setZOrigin:"
+ "set_wantsSeparateMeshElements:"
+ "setupFinalMeshFromBaseMeshWithInfo:"
+ "setupFinalMeshFromMeshlessBaseGeometryWithInfo:"
+ "setupInitialBuffersWithBasePositionSourceProvider:baseNormalSourceProvider:baseTangentSourceProvider:info:"
+ "setupTextureClient"
+ "sfFactor"
+ "shadableIdentifier"
+ "shaderArchive"
+ "shaderCacheConfigurations"
+ "shaderCacheRecordingEnabled"
+ "shaderCompilationContext"
+ "shaderModifier"
+ "shaderModifierArrayEncoderWithArray:"
+ "shaderModifierEncoderWithShaderModifier:"
+ "shaderModifiers[material]"
+ "shaderModifiers[model]"
+ "shared_%lx"
+ "short2N"
+ "short3N"
+ "short4N"
+ "showCircleOfConfusion"
+ "simulationAnchor"
+ "simulationSpace"
+ "simulationSpeed"
+ "sinEaseIn"
+ "sinEaseInOut"
+ "sinEaseOut"
+ "size != 0"
+ "sizeOfCounterHeapEntry:"
+ "sizeof(dest) == metadata->size"
+ "skinnerWithBaseGeometry:bones:boneInverseBindTransforms:boneWeights:boneIndices:"
+ "sortedStages.push_back(std::move(sortedPasses));\n"
+ "sortingValue"
+ "sourceAlphaBlendFactor"
+ "sourceRGBBlendFactor"
+ "sparseBufferTier"
+ "sparseTextureTier"
+ "specMaxEssMap"
+ "specializedFunctions"
+ "splitInputOutputStructsIfNeededForSourceCode:generatedFromReplacementStrings:perPixelLighting:clipDistanceCount:hasBezierCurveDeformer:"
+ "springCoefiscients"
+ "springDuration"
+ "src_type_size"
+ "ssr_temporal_denoise"
+ "stableHashForDictionary:"
+ "stage < kCFXProgramStageCount"
+ "stages_array_t sortedStages(ctx.stackAllocator(), optimisedGraph->stages().size());\n"
+ "standardUniforms"
+ "start:"
+ "startDeviceMotionUpdatesUsingReferenceFrame:"
+ "stateTransitions"
+ "static struct { const char *name; void *ptr; }"
+ "static vfx_script_keypath_ref_t $keypath = "
+ "std::copy(stage.begin(), stage.end(), std::back_inserter(sortedPasses));\n"
+ "std::stable_sort(sortedPasses.begin(), sortedPasses.end(), [&](const auto* first, const auto* second) {\n"
+ "std::string error;\n"
+ "stencilAttachmentPixelFormat"
+ "stencilReferenceValue"
+ "still reference to old ECS post merge (component = "
+ "still reference to old World post merge (component = "
+ "stopDeviceMotionUpdates"
+ "stopMagnetometerUpdates"
+ "subGraphs"
+ "subGraphsDecls"
+ "subWorld.rootNode.childNodes.count == 0"
+ "subpixelData"
+ "subpixels"
+ "successorPaths"
+ "swapToNewEntity:newScene:"
+ "swiftString"
+ "tapCount"
+ "targetPositionSource"
+ "tensorSizeAndAlignWithDescriptor:"
+ "tessellationControlPointIndexType"
+ "tessellationFactorFormat"
+ "tessellationFactorStepFunction"
+ "tessellationOutputWindingOrder"
+ "tessellation_factor_format"
+ "textureBreakthroughDepth"
+ "textureForBuiltin:"
+ "textureForEntity:isFallback:isDynamic:renderer:"
+ "textureForResourceID:"
+ "this node should have been migrated to an actual node"
+ "threadGroupSizeIsMultipleOfThreadExecutionWidth"
+ "threshold#intrinsic"
+ "throwTestException"
+ "thumbIntermediateBase"
+ "thumbIntermediateTip"
+ "thumbKnuckle"
+ "thumbTip"
+ "timeFract"
+ "timeOrigin"
+ "timeSource"
+ "tintFactor"
+ "toDictionary"
+ "toDouble"
+ "toInt32"
+ "toNumber"
+ "toObject"
+ "toString"
+ "token->worldRef == worldRef"
+ "tr_a"
+ "tr_p"
+ "tr_s"
+ "traceAllScriptDiagnostics"
+ "trailing tokens after: "
+ "transferRenderGraphResourcesFrom:"
+ "transitionFrom:to:"
+ "transitionOverrideForItem:"
+ "transitionsEnabled"
+ "transmission"
+ "transmissionColor"
+ "transmissionColorTexcoord"
+ "transmissionTexcoord"
+ "transparency"
+ "transparentStencilOverdraw"
+ "triggerRenderWithRendererIdentifier:with:"
+ "truncatingMiddle"
+ "type name "
+ "type2DMultisample"
+ "type2dMultisampleArray"
+ "typeByCodingID"
+ "typeByVariableName"
+ "typeID"
+ "typeTextureBuffer"
+ "typedef struct {\n"
+ "u);\n"
+ "u, "
+ "u1010102N"
+ "u_shaderModifierParameters"
+ "u_shaderModifierParametersFragment"
+ "u_shaderModifierParametersGeometry"
+ "u_shaderModifierParametersLighting"
+ "u_shaderModifierParametersSurface"
+ "uchar2"
+ "uchar2N"
+ "uchar3"
+ "uchar3N"
+ "uchar4N"
+ "uint"
+ "uint16_t amp_id [[ amplification_id, function_constant(enable_vertex_amplification) ]]"
+ "uint2"
+ "uint3"
+ "uint32_t $neighbors["
+ "uint32_t copy_pass_count = 0;\n"
+ "uint4"
+ "unexpected call to collision trigger"
+ "uniqueID"
+ "unknown color ramp binding object"
+ "unprojectPoints:count:viewport:"
+ "unsafeParameterHandleForKey:"
+ "unsupported MTLWinding case "
+ "unsupported case "
+ "updateAssociatedEntityWithTag:"
+ "updateAtTime"
+ "updateAtTime:deltaTime:frameIndex:renderer:"
+ "updateCollisionPlane:collideOutsideExtents:"
+ "updateCollisionPlane:extents:transform:"
+ "updateCollisionPlane:scale:orientation:position:"
+ "updateContext"
+ "updateCount"
+ "updateDataForAuthoringEnvironment:node:transforms:context:"
+ "updateDependencyBuffersInBufferArray:forDeformer:"
+ "updateFlags == CFXRendererElementSync_VFXCore"
+ "updateFrameConstants"
+ "updateItemsScale:axis:"
+ "updateRenderPassDescriptor:"
+ "updateVFX2RenderOutputWithPointOfView:commandBuffer:renderer:particleMaterialOverride:"
+ "updateVFXObjectReferences:"
+ "updateViewConstantsWithWorld:"
+ "updateWithComputeContext:buffers:"
+ "update_visible_count"
+ "updater"
+ "useFixedTimeStep"
+ "use_orientation_for_lighting"
+ "userAcceleration"
+ "userData:isParticleComponent"
+ "usesMultisampling"
+ "ushort2N"
+ "ushort3N"
+ "ushort4N"
+ "using passes_array_t = CFX::Array<CFX::RG::Pass *, 0, CFX::StackAllocator>;\n"
+ "using stages_array_t = CFX::Array<passes_array_t, 0, CFX::StackAllocator>;\n"
+ "uv0"
+ "v104@0:8Q1624{?=[4]}40"
+ "v104@0:8{?=^{__CFXProgram}^{__CFXProgramHashCode}^{__CFXMaterial}^{__CFXModel}^{__CFXNode}^{__CFXGeometry}^{__CFXMeshElement}{?=[8C]}^{__CFXRenderingOverride}^IBBBBBb3}16"
+ "v120@0:8Q16Q24Q32r^@40r^Q48{_NSRange=QQ}56@72^{__CFXProgram={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}b1b1^{__CFXProgramDelegate}[2^{__CFString}]^{__CFString}^{__CFString}^{__CFDictionary}^{__CFSet}^v^{__CFDictionary}i@?@?QI}80r^v88Q96^{__CFXRasterizerStates=}104^{__CFXBlendStates=}112"
+ "v132@?0{__CFXShapeVertex={CGPoint=dd}{CGPoint=dd}{CGPoint=dd}{CGPoint=dd}fBC}8{CGPoint=dd}80f96{CGPoint=dd}100{CGPoint=dd}116"
+ "v136@0:8Q16Q24Q32@40Q48r^@56r^Q64{_NSRange=QQ}72@88^{__CFXProgram={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}b1b1^{__CFXProgramDelegate}[2^{__CFString}]^{__CFString}^{__CFString}^{__CFDictionary}^{__CFSet}^v^{__CFDictionary}i@?@?QI}96r^v104Q112^{__CFXRasterizerStates=}120^{__CFXBlendStates=}128"
+ "v144@0:8{?=^{__CFXProgramHashCode}^{__CFXProgram}^{__CFString}^{__CFString}^{__CFXRenderingOverride}^{__CFXBlendStates}CCCC@QCC@{?=C@?}Q}16@128@?136"
+ "v16@?0@\"<VFXMTLDeformer>\"8"
+ "v16@?0@8"
+ "v16@?0I8f12"
+ "v16@?0r^{CGPathElement=i^{CGPoint}}8"
+ "v20@0:8{?=BBBB}16"
+ "v20@?0I8I12f16"
+ "v22@0:8{?=CCCCCB}16"
+ "v232@0:8^v16^{__CFXNode=}24{?={?=[4]}{?=[4]}{?=[4]}}32@\"VFXMTLRenderContext\"224"
+ "v232@0:8^v16^{__CFXNode=}24{?={?=[4]}{?=[4]}{?=[4]}}32@224"
+ "v24@0:8@\"<MTLRenderCommandEncoder>\"16"
+ "v24@0:8@\"<VFXState>\"16"
+ "v24@0:8@\"MTLLogicalToPhysicalColorAttachmentMapSPI\"16"
+ "v24@0:8@\"RGCachedComputeCommandEncoder\"16"
+ "v24@0:8@?<v@?@\"VFXAssetNode\"^B>16"
+ "v24@0:8^{?=[8Q]QQC}16"
+ "v24@0:8^{?=^{__CFXEnginePipeline}^{__CFXEngineContext}^{__CFXPassInstance}^vQQBBBBBBB}16"
+ "v24@0:8^{__CFXCullingContext=[16{?=[6{?=}]}][16{?=[6{?=}]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16]CCCC^{__CFXRenderingOverride}^v^{__CFXNode}^{__CFXNode}^{__CFXNode}^{__CFXNode}BBBBBBBBBCQQ^v^{__CFXWorld}^{__CFXEngineContext}dd{?=}{?=[4]}{?=[4]}[16{?=^{?}II}]B^?}16"
+ "v24@0:8^{__CFXMeshElement={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}II^{__CFXMeshElement}CCC{?=C^{__CFData}I^I^{?}SCB}^vfff^v^{__CFXMeshSource}[2]^{?}I}16"
+ "v24@0:8^{__CFXModel={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXGeometry}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16"
+ "v24@0:8^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}16"
+ "v24@0:8^{__CFXParametricGeometry={__CFXModel={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXGeometry}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=fffffffffiiiiiiiiiiI}{?=^?^?^?^?^?^?}^{__CFData}}16"
+ "v24@0:8^{__CFXRemoteFrameBuilder=}16"
+ "v24@0:8^{__CFXShapeGeometry={__CFXModel={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXGeometry}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=Cfffif^{CGPath}^v^{CGPath}^v}^{__CFXMesh}[32C]}16"
+ "v24@0:8^{__CFXTextGeometry={__CFXShapeGeometry={__CFXModel={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXGeometry}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=Cfffif^{CGPath}^v^{CGPath}^v}^{__CFXMesh}[32C]}{?=^{__CTFrame}^v^viiBBB{CGRect={CGPoint=dd}{CGSize=dd}}}}16"
+ "v24@0:8f16S20"
+ "v24@?0@\"<MTLRenderCommandEncoder>\"8@\"<VFXDrawCallContext>\"16"
+ "v24@?0@\"VFXDisplayLink\"8@\"CAMetalDisplayLinkUpdate\"16"
+ "v24@?0Q8^v16"
+ "v24@?0^S8^16"
+ "v24@?0^v8Q16"
+ "v24@?0^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}8*16"
+ "v24@?0^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}8q16"
+ "v24@?0^{__CFXNode=}8q16"
+ "v24@?0^{__CFXShapeBoundary=^{__CFXShapeVertex}IIffffC}8^{__CFXShapeBoundary=^{__CFXShapeVertex}IIffffC}16"
+ "v24@?0^{__CFXShapeBoundary=^{__CFXShapeVertex}IIffffC}8i16i20"
+ "v28@0:8@\"<MTLTexture>\"16C24"
+ "v28@0:8@16C24"
+ "v28@?0@8B16@?<v@?@>20"
+ "v28@?0C8I12*16I24"
+ "v28@?0I8{?=qq}12"
+ "v28@?0^{__CFXDeformerStack=}8^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}16C24"
+ "v32@0:8@\"<VFXRemoteRendererXPCReplyProtocol>\"16@?<v@?I>24"
+ "v32@0:8@\"CAMetalDisplayLink\"16@\"CAMetalDisplayLinkUpdate\"24"
+ "v32@0:8@\"CFXRemoteRenderPipelineDescriptor\"16Q24"
+ "v32@0:8@\"NSData\"16q24"
+ "v32@0:8@\"NSObject<OS_xpc_object>\"16@\"NSNumber\"24"
+ "v32@0:8@\"VFXPhysicsWorld\"16@\"VFXPhysicsContact\"24"
+ "v32@0:8@16@\"VFXCopyContext\"24"
+ "v32@0:8@16^{?=@{os_unfair_lock_s=I}}24"
+ "v32@0:8@16^{__CFDictionary=}24"
+ "v32@0:8@16^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}24"
+ "v32@0:8@?16^{?=@?@^{__CFXRenderingOverride}@^{__CFXWorld}^{__CFXNode}}24"
+ "v32@0:8Q16@?24"
+ "v32@0:8Q16q24"
+ "v32@0:8^v16Q24"
+ "v32@0:8^{?=@@@@@@@@@@@@}16@24"
+ "v32@0:8^{?=[8Q]QQC}16^v24"
+ "v32@0:8^{__CFXCullingContext=[16{?=[6{?=}]}][16{?=[6{?=}]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16]CCCC^{__CFXRenderingOverride}^v^{__CFXNode}^{__CFXNode}^{__CFXNode}^{__CFXNode}BBBBBBBBBCQQ^v^{__CFXWorld}^{__CFXEngineContext}dd{?=}{?=[4]}{?=[4]}[16{?=^{?}II}]B^?}16^{__CFXWorld=}24"
+ "v32@0:8^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}16^I24"
+ "v32@0:8^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}16^v24"
+ "v32@0:8^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}16^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}24"
+ "v32@0:8^{__CFXProgram={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}b1b1^{__CFXProgramDelegate}[2^{__CFString}]^{__CFString}^{__CFString}^{__CFDictionary}^{__CFSet}^v^{__CFDictionary}i@?@?QI}16^{__CFXWorld=}24"
+ "v32@0:8^{__CFXRendererElement=I^{__CFXNode}(?={__CFXRendererElementAttributes=^{__CFXModel}^{__CFXGeometry}^{__CFXMaterial}^{__CFXProgram}^{__CFXMeshElement}^{__CFNumber}}{__CFXRendererElementHandler={?=}@?}){?=[8C]}iIb3b1b1b1b1b3b1b3b1b1}16^{__CFXRenderingOverride={__CFRuntimeBase=QAQ}^{__CFXRasterizerStates}}24"
+ "v32@0:8q16@?24"
+ "v32@0:8q16@?<v@?@B@?<v@?@>>24"
+ "v32@0:8{?=BCCCCCCC}16q24"
+ "v32@0:8{?=b8b8b8b8b8b8b8b7b1}16q24"
+ "v32@?0@\"NSString\"8@\"CFXBinding\"16^B24"
+ "v32@?0@\"NSString\"8@\"VFXBindingWrapper\"16^B24"
+ "v32@?0@\"VFXModelDeformer\"8Q16^B24"
+ "v32@?0@\"VFXNode\"8Q16^B24"
+ "v32@?0Q8^^{__CFXNode}16^^{__CFXLight}24"
+ "v32@?0^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}8q16^B24"
+ "v32@?0^{__CFXNode=}8q16^B24"
+ "v32@?0q8^^{__CFXNode}16^^{__CFXLight}24"
+ "v36@0:8@16B24@28"
+ "v36@0:8^{?=SS}16I24^{?=^{__CFXEnginePipeline}^{__CFXEngineContext}^{__CFXPassInstance}^vQQBBBBBBB}28"
+ "v36@0:8{?=^vII}16C32"
+ "v36@?0^{__CFXConstraint={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFString}fBB{?=^?^?^?^?^?^?}^v}8^v16^{__CFXModelTarget={__CFRuntimeBase=QAQ}^v^vscCCB}24f32"
+ "v384@0:8@16{?={?=^{__CFXProgramHashCode}^{__CFXProgram}^{__CFString}^{__CFString}^{__CFXRenderingOverride}^{__CFXBlendStates}CCCC@QCC@{?=C@?}Q}@{?=[8Q]QQC}^{__CFXBlendStates}[8Q]C@@@@@@@?CBBB}24@376"
+ "v38@0:8@16^v24{?=CCCCCB}32"
+ "v40@0:8@\"<MTLCommandBuffer>\"16@\"MTLRenderPassDescriptor\"24@\"NSString\"32"
+ "v40@0:8@\"<MTLRenderCommandEncoder>\"16@\"<MTLCommandBuffer>\"24@\"MTLRenderPassDescriptor\"32"
+ "v40@0:8@\"CFXRemoteArgumentBufferDescriptor\"16Q24Q32"
+ "v40@0:8@16@24^{?=[8Q]QQC}32"
+ "v40@0:8@16^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}24^{__CFXLight=}32"
+ "v40@0:8Q16@24@32"
+ "v40@0:8Q16Q24q32"
+ "v40@0:8^v16^{__CFXNode=}24@\"VFXMTLRenderContext\"32"
+ "v40@0:8^v16^{__CFXNode=}24@32"
+ "v40@0:8^{__CFXEngineContext=}16{?=b8b8b8b8b8b8b8b7b1}24^d32"
+ "v40@0:8^{__CFXImageProxy=}16^{__CFXEngineContext=}24^{__CFXMaterialProperty={__CFRuntimeBase=QAQ}(?=^{__CFXImage}^{__CFXImageProxy}^{__CFXTexture}^v^v^v{CFXColor4=(?=[4f]{?=ffff})})^vq^vb8b1b4c{?=b8b8b8b8b8b8b8b7b1}^{?}fi^v}32"
+ "v40@0:8^{__CFXMaterialProperty={__CFRuntimeBase=QAQ}(?=^{__CFXImage}^{__CFXImageProxy}^{__CFXTexture}^v^v^v{CFXColor4=(?=[4f]{?=ffff})})^vq^vb8b1b4c{?=b8b8b8b8b8b8b8b7b1}^{?}fi^v}16^{__CFXEngineContext=}24^{__CFXPassInstance=^{__CFXRenderingOverride}CBCC[16^{__CFXArray}]{__CFXCullingContext=[16{?=[6{?=}]}][16{?=[6{?=}]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16]CCCC^{__CFXRenderingOverride}^v^{__CFXNode}^{__CFXNode}^{__CFXNode}^{__CFXNode}BBBBBBBBBCQQ^v^{__CFXWorld}^{__CFXEngineContext}dd{?=}{?=[4]}{?=[4]}[16{?=^{?}II}]B^?}SI}32"
+ "v40@0:8^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}16^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}24^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}32"
+ "v40@0:8{?=^vII}16Q32"
+ "v40@?0@\"JSValue\"8@\"JSValue\"16@\"JSValue\"24@\"JSValue\"32"
+ "v44@0:8@16@24@32B40"
+ "v44@0:8@16^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1b1b1{?={?=SS}I}^{?}^{__CFXModel}^{__CFXDeformerStack}f{?=}}24^{__CFXLight=}32f40"
+ "v46@0:8@?16@?24@?32{?=BBBBBB}40"
+ "v48@0:8@16@24@32Q40"
+ "v48@0:8^{__CFXEngineContext=}16{?=b8b8b8b8b8b8b8b7b1}24^d32^{?=BB}40"
+ "v48@0:8d16d24q32@40"
+ "v48@?0@\"NSObject\"8:16^^v24Q32^v40"
+ "v48@?0{?=}8i40I44"
+ "v52@0:8@16@24@32B40^@44"
+ "v56@0:8@16@24@32@40@?48"
+ "v56@0:8@16@24Q32@40@?48"
+ "v56@0:8@16@24Q32Q40q48"
+ "v56@0:8@16@24^{__CFXProgram={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}b1b1^{__CFXProgramDelegate}[2^{__CFString}]^{__CFString}^{__CFString}^{__CFDictionary}^{__CFSet}^v^{__CFDictionary}i@?@?QI}32^{__CFString=}40^{__CFXRenderingOverride={__CFRuntimeBase=QAQ}^{__CFXRasterizerStates}}48"
+ "v56@0:8@16{?=@^{__CFData}@@}24"
+ "v56@0:8^{?=SS}16{?=qq}24^{__CFXRendererElementStore=}40^{__CFXPassInstance=^{__CFXRenderingOverride}CBCC[16^{__CFXArray}]{__CFXCullingContext=[16{?=[6{?=}]}][16{?=[6{?=}]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16]CCCC^{__CFXRenderingOverride}^v^{__CFXNode}^{__CFXNode}^{__CFXNode}^{__CFXNode}BBBBBBBBBCQQ^v^{__CFXWorld}^{__CFXEngineContext}dd{?=}{?=[4]}{?=[4]}[16{?=^{?}II}]B^?}SI}48"
+ "v56@0:8r^{?=^{__CFXProgram}^{__CFXProgramHashCode}^{__CFXMaterial}^{__CFXModel}^{__CFXNode}^{__CFXGeometry}^{__CFXMeshElement}{?=[8C]}^{__CFXRenderingOverride}^IBBBBBb3}16B24^{__CFXModel={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXGeometry}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}28B36B40B44B48B52"
+ "v64@0:8@\"<MTLTensor>\"16@\"MTLTensorExtents\"24@\"MTLTensorExtents\"32@\"<MTLTensor>\"40@\"MTLTensorExtents\"48@\"MTLTensorExtents\"56"
+ "v64@0:8@16@24@32@40@48@56"
+ "v64@0:8^{__CFXProgram=}16@24@32@40@?48@?56"
+ "v72@0:8^{?=fIIQQ}16^{?=I^{__CFXGeometry}^{__CFXMeshSource}^{__CFXMeshSource}Q}24*32Q40Q48^I56@64"
+ "v72@0:8q16244056"
+ "v80@0:8^16Q24{?=dddddd}32"
+ "v88@0:8^{?=fIIQQ}16^{?=I^{__CFXGeometry}^{__CFXMeshSource}^{__CFXMeshSource}Q}24*32Q40*48Q56Q64^I72@80"
+ "v92@0:8^{__CFXMesh=}16^{__CFXMeshElement={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}II^{__CFXMeshElement}CCC{?=C^{__CFData}I^I^{?}SCB}^vfff^v^{__CFXMeshSource}[2]^{?}I}24^{__CFXProgram={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}b1b1^{__CFXProgramDelegate}[2^{__CFString}]^{__CFString}^{__CFString}^{__CFDictionary}^{__CFSet}^v^{__CFDictionary}i@?@?QI}32r^v40Q48^{__CFXRasterizerStates=}56^{__CFXBlendStates=}64^{__CFXImage=}72{?=b8b8b8b8b8b8b8b7b1}80B88"
+ "valueWithJSValueRef:inContext:"
+ "valueWithNewBigIntFromUInt64:inContext:"
+ "valueWithNullInContext:"
+ "valueWithObject:inContext:"
+ "value_type_if_dynamic"
+ "variantDescriptorTracker"
+ "varyings"
+ "vdSentinel"
+ "vertexLinkedFunctions"
+ "vertex_linked_functions"
+ "vertical"
+ "vfx-capture.gputrace"
+ "vfx-default.mtlp-json"
+ "vfx-log-fails-binary-cache"
+ "vfx.vfxCoreTime"
+ "vfx::api_v2::apply_system_treatments"
+ "vfx::api_v2::crws_position"
+ "vfx::api_v2::make_system_treatment_parameters"
+ "vfxCoreViewConstants"
+ "vfx_"
+ "vfx_%@::"
+ "vfx_angle(%0, %1, %2)"
+ "vfx_bezier_curve_controlPoints"
+ "vfx_bezier_curve_data"
+ "vfx_constants.dt"
+ "vfx_constants.is_run_mode"
+ "vfx_constants.time"
+ "vfx_curveToGeometryTransform"
+ "vfx_decodeObjectOfClass:forKey:"
+ "vfx_decodeObjectOfClasses:forKey:"
+ "vfx_distance_squared"
+ "vfx_distance_to_bezier_curve"
+ "vfx_get_rotation"
+ "vfx_get_rotationq(%0)"
+ "vfx_get_scale4x4"
+ "vfx_get_translation"
+ "vfx_irradiance_cache_clear"
+ "vfx_irradiance_cache_debug"
+ "vfx_irradiance_cache_indirect_argument"
+ "vfx_irradiance_cache_indirect_reset"
+ "vfx_irradiance_cache_indirect_update"
+ "vfx_irradiance_cache_reactive_mask"
+ "vfx_irradiance_cache_reactive_mask_blur"
+ "vfx_irradiance_cache_update"
+ "vfx_is_almost_equal"
+ "vfx_is_almost_zero"
+ "vfx_is_inside_bezier_curve"
+ "vfx_length_squared"
+ "vfx_linear_to_srgb"
+ "vfx_make_float4(%translation, 1.0f)"
+ "vfx_make_transform(%rotation, "
+ "vfx_modifiers_params_fragment_t"
+ "vfx_modifiers_params_geometry_t"
+ "vfx_modifiers_params_lighting_t"
+ "vfx_modifiers_params_surface_t"
+ "vfx_msgSend<void>($options, _sel(setValue_forKey_), %3, VFXHitTestRootNodeKey);"
+ "vfx_msgSend<void>($options, _sel(setValue_forKey_), %5, VFXHitTestRootNodeKey);"
+ "vfx_node_in"
+ "vfx_nodes_in"
+ "vfx_orthonormal_basis(%0, &$a, &$b);"
+ "vfx_osd_synchronize_coarse_positions_authoring"
+ "vfx_project_position"
+ "vfx_quat_conjugate"
+ "vfx_quat_exp(%0)"
+ "vfx_quat_from_axisangle"
+ "vfx_quat_from_axisangle_"
+ "vfx_quat_from_euler"
+ "vfx_quat_from_euler_"
+ "vfx_quat_from_normal"
+ "vfx_quat_from_normal_"
+ "vfx_quat_is_identity"
+ "vfx_quat_length_"
+ "vfx_quat_look_at"
+ "vfx_quat_look_at_"
+ "vfx_quat_mul(%0, %1)"
+ "vfx_quat_normalize"
+ "vfx_quat_rotation_between_fast"
+ "vfx_quat_rotation_between_fast_"
+ "vfx_quat_to_axisangle"
+ "vfx_quat_to_axisangle_"
+ "vfx_ray_tracer"
+ "vfx_re_shaders.h"
+ "vfx_re_shaders_internal.h"
+ "vfx_re_support.h"
+ "vfx_render.h"
+ "vfx_render_options.h"
+ "vfx_reprojection_map"
+ "vfx_reprojection_map_copy"
+ "vfx_robust_normalize"
+ "vfx_robust_normalize4"
+ "vfx_rt_clearcoat_indirect_argument"
+ "vfx_rt_clearcoat_indirect_reset"
+ "vfx_rt_clearcoat_indirect_update"
+ "vfx_rt_clearcoat_spatial_denoise"
+ "vfx_rt_direct_lighting_dilate_variance"
+ "vfx_rt_direct_lighting_erode_variance"
+ "vfx_rt_direct_lighting_spatial_denoise"
+ "vfx_rt_direct_lighting_temporal_denoise"
+ "vfx_rt_indirect_specular_indirect_argument"
+ "vfx_rt_indirect_specular_indirect_reset"
+ "vfx_rt_indirect_specular_indirect_update"
+ "vfx_rt_indirect_specular_spatial_denoise"
+ "vfx_rt_indirect_specular_temporal_denoise"
+ "vfx_rt_indirect_specular_trace"
+ "vfx_rt_indirect_specular_upscale"
+ "vfx_rt_transmission_spatial_denoise"
+ "vfx_rt_transmission_temporal_denoise"
+ "vfx_rt_transmission_trace"
+ "vfx_rt_transmission_upscale"
+ "vfx_sample_2d_gradient_x(&%0, %uv * %scale + %offset)"
+ "vfx_script_buffer"
+ "vfx_script_buffer_create()"
+ "vfx_script_buffer_free("
+ "vfx_script_clock_simulation_index(%script_context)"
+ "vfx_script_color_ramp_create(\n    %script_context,\n    (simd_float4[]) {"
+ "vfx_script_color_ramp_destroy(%script_context, "
+ "vfx_script_curve_create(\n    %script_context,\n    (float[]) {"
+ "vfx_script_curve_destroy(%script_context, "
+ "vfx_script_get_ecs_value"
+ "vfx_script_get_world_renderer"
+ "vfx_script_get_world_renderer(%script_context)"
+ "vfx_script_get_world_value"
+ "vfx_script_initialize_objc_helpers();"
+ "vfx_script_invalidate_render_target(%script_context, %param0)"
+ "vfx_script_is_key_down(%script_context, %0)"
+ "vfx_script_is_run_mode(%script_context)"
+ "vfx_script_js_get_ecs_value"
+ "vfx_script_js_get_world_value"
+ "vfx_script_js_hit_test"
+ "vfx_script_js_invoke"
+ "vfx_script_js_ray_test"
+ "vfx_script_js_set_ecs_value"
+ "vfx_script_js_set_world_value"
+ "vfx_script_particle_count(%0)"
+ "vfx_script_particle_get_age"
+ "vfx_script_particle_get_angle"
+ "vfx_script_particle_get_angle_velocity"
+ "vfx_script_particle_get_angular_factor"
+ "vfx_script_particle_get_angular_velocity"
+ "vfx_script_particle_get_color"
+ "vfx_script_particle_get_emission"
+ "vfx_script_particle_get_id"
+ "vfx_script_particle_get_linear_factor"
+ "vfx_script_particle_get_mass"
+ "vfx_script_particle_get_metalness"
+ "vfx_script_particle_get_orientation"
+ "vfx_script_particle_get_parent_id"
+ "vfx_script_particle_get_pivot"
+ "vfx_script_particle_get_position"
+ "vfx_script_particle_get_roughness"
+ "vfx_script_particle_get_size"
+ "vfx_script_particle_get_size1d"
+ "vfx_script_particle_get_size2d"
+ "vfx_script_particle_get_size3d"
+ "vfx_script_particle_get_target"
+ "vfx_script_particle_get_texture_frame"
+ "vfx_script_particle_get_user_data1"
+ "vfx_script_particle_get_user_data2"
+ "vfx_script_particle_get_user_data3"
+ "vfx_script_particle_get_user_data4"
+ "vfx_script_particle_get_velocity"
+ "vfx_script_particle_index_t"
+ "vfx_script_particle_lookup_by_id(%0, %1)"
+ "vfx_script_particle_set_age"
+ "vfx_script_particle_set_angle"
+ "vfx_script_particle_set_angle_velocity"
+ "vfx_script_particle_set_angular_factor"
+ "vfx_script_particle_set_angular_velocity"
+ "vfx_script_particle_set_color"
+ "vfx_script_particle_set_emission"
+ "vfx_script_particle_set_id"
+ "vfx_script_particle_set_linear_factor"
+ "vfx_script_particle_set_mass"
+ "vfx_script_particle_set_metalness"
+ "vfx_script_particle_set_orientation"
+ "vfx_script_particle_set_parent_id"
+ "vfx_script_particle_set_pivot"
+ "vfx_script_particle_set_position"
+ "vfx_script_particle_set_roughness"
+ "vfx_script_particle_set_size"
+ "vfx_script_particle_set_size1d"
+ "vfx_script_particle_set_size2d"
+ "vfx_script_particle_set_size3d"
+ "vfx_script_particle_set_target"
+ "vfx_script_particle_set_texture_frame"
+ "vfx_script_particle_set_user_data1"
+ "vfx_script_particle_set_user_data2"
+ "vfx_script_particle_set_user_data3"
+ "vfx_script_particle_set_user_data4"
+ "vfx_script_particle_set_velocity"
+ "vfx_script_set_ecs_value"
+ "vfx_script_set_world_value"
+ "vfx_script_start_timer(%script_context, "
+ "vfx_script_stop_timer(%script_context, "
+ "vfx_script_string_create(%script_context, \""
+ "vfx_script_string_destroy(%script_context, "
+ "vfx_script_string_destroy(%script_context, %r0);"
+ "vfx_script_string_join"
+ "vfx_script_string_to_objc(%script_context, %2)"
+ "vfx_script_texture_sample2d_gradient_x(%0, %uv * %scale + %offset)"
+ "vfx_script_tick(%script_context, "
+ "vfx_shader_api.h"
+ "vfx_shader_api_v2.h"
+ "vfx_shadowmap_util.h"
+ "vfx_shared.h"
+ "vfx_sin((%0 * VFX_PI) / "
+ "vfx_snapshot.gputrace"
+ "vfx_srgb_to_linear"
+ "vfx_ssao_blur_atrous"
+ "vfx_ssao_fxaa"
+ "vfx_ssao_trace"
+ "vfx_ssr_raytrace"
+ "vfx_ssr_spatial_atrous_denoise"
+ "vfx_ssr_upscale"
+ "vfx_temporal_denoise"
+ "vfx_transform_direction"
+ "vfx_transform_direction3x3"
+ "vfx_transform_direction4x4"
+ "vfx_transform_normal"
+ "vfx_transform_position"
+ "vfx_transform_position3x3"
+ "vfx_transform_position4x4"
+ "vfx_translate3x3"
+ "vfx_translate4x4"
+ "vfxibl"
+ "viewProjectionTransform"
+ "viewProjectionTransform:"
+ "viewTransform:"
+ "viewWillDie"
+ "viewportSize:"
+ "visible_functions"
+ "visualDepthStaticOcclusionDepthBias"
+ "visualDepthStaticOcclusionTransitionFactor"
+ "void *$groupNumber = vfx_msgSend<void*>(_class(NSNumber), _sel(numberWithUnsignedInteger_), %4);\nvfx_msgSend<void>($options, _sel(setValue_forKey_), $groupNumber, VFXHitTestOptionCategoryBitMask);\n\nvoid *$renderer = vfx_script_get_world_renderer(%script_context);\nvoid *$resArray = vfx_msgSend<void*>($renderer, _sel(script_hitTest_options_), %0, $options);\n\nvfx_script_buffer $buffer = { 0 };\n\n$buffer.pointer = vfx_script_create_buffer_from_array(%script_context, $resArray, &$buffer.count);\n\nvfx_script_buffer %r0 = $buffer;\n\n#defer\nfree($buffer.pointer);"
+ "void *$groupNumber = vfx_msgSend<void*>(_class(NSNumber), _sel(numberWithUnsignedInteger_), %6);\nvfx_msgSend<void>($options, _sel(setValue_forKey_), $groupNumber, VFXHitTestOptionCategoryBitMask);\n\nvoid *$resArray = vfx_msgSend<void*>(%0, _sel(hitTestWithSegmentFromPoint_toPoint_options_), %1, %2, $options);\n\nvfx_script_buffer $buffer = { 0 };\n\n$buffer.pointer = vfx_script_create_buffer_from_array(%script_context, $resArray, &$buffer.count);\n\nvfx_script_buffer %r0 = $buffer;\n\n#defer\nfree($buffer.pointer);"
+ "void *$options = vfx_msgSend<void*>(_class(NSMutableDictionary), _sel(dictionary));\nvoid *$yes = vfx_msgSend<void*>(_class(NSNumber), _sel(numberWithBool_), true);\nvoid *$no = vfx_msgSend<void*>(_class(NSNumber), _sel(numberWithBool_), false);\nif (%3) {\n    vfx_msgSend<void>($options, _sel(setValue_forKey_), $yes, VFXHitTestBoundingBoxOnlyKey);\n}\nvfx_msgSend<void>($options, _sel(setValue_forKey_), %4 ? $yes : $no, VFXHitTestIgnoreHiddenNodesKey);"
+ "void *$options = vfx_msgSend<void*>(_class(NSMutableDictionary), _sel(dictionary));\nvoid *$yes = vfx_msgSend<void*>(_class(NSNumber), _sel(numberWithBool_), true);\nvoid *$no = vfx_msgSend<void*>(_class(NSNumber), _sel(numberWithBool_), false);\nvfx_msgSend<void>($options, _sel(setValue_forKey_), %1 ? $yes : $no, VFXHitTestBoundingBoxOnlyKey);\nvfx_msgSend<void>($options, _sel(setValue_forKey_), %2 ? $yes : $no, VFXHitTestIgnoreHiddenNodesKey);"
+ "void *$world = vfx_script_get_world(%script_context);\nvfx_msgSend<void>($world, _sel(setState_), %1);"
+ "void *const * arguments_buffer = vfx_script_get_arguments_buffer(script_context);"
+ "void *script_context"
+ "w == maxInfluenceCount * vertexCount"
+ "wantsCollisionPlanes"
+ "wantsSSAO"
+ "wantsScreenSpaceAmbientOcclusion"
+ "weightCount == _runtimeMorphTargetCount"
+ "whiteArray"
+ "willRemoveAudioAsset:fromWorld:"
+ "world-world-world-world"
+ "worldPass dependencies "
+ "worldPlaceholder"
+ "worlds"
+ "wrist"
+ "write: %s"
+ "zIndex"
+ "zOrigin"
+ "zeros2048bytes"
+ "{\n"
+ "{?=\"frameLightingSetDatas\"{unordered_map<unsigned long long, VFXMTLLightSetData, std::hash<unsigned long long>, std::equal_to<unsigned long long>, std::allocator<std::pair<const unsigned long long, VFXMTLLightSetData>>>=\"__table_\"{__hash_table<std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, std::__unordered_map_hasher<unsigned long long, std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, std::hash<unsigned long long>, std::equal_to<unsigned long long>>, std::__unordered_map_equal<unsigned long long, std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, std::equal_to<unsigned long long>, std::hash<unsigned long long>>, std::allocator<std::__hash_value_type<unsigned long long, VFXMTLLightSetData>>>=\"__bucket_list_\"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, void *> *> *>>>=\"__ptr_\"^^v\"__deleter_\"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, void *> *> *>>=\"__size_\"Q}}\"__first_node_\"{__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, void *> *>=\"__next_\"^v}\"__size_\"Q\"__max_load_factor_\"f}}\"currentLightingHashKey\"Q\"currentLightingDesc\"{?=\"count\"q\"lights\"[8^{__CFXLight}]\"lightsData\"[8^{__CFXLightRuntimeData}]}\"currentLightingSpace\"{?=\"columns\"[4]}\"currentLightingSpaceShadow\"{?=\"columns\"[4]}\"needLightingSpaceTransformation\"B\"clusterSystem\"{VFXMTLClusterSystem=\"clustersCount\"\"tileSize\"\"selectedDebugClusterIndex\"\"_debugClusterTilesPipeline\"@\"VFXMTLRenderPipeline\"\"_debugLightIndicesBufferPipeline\"@\"VFXMTLRenderPipeline\"\"_debugClusterSlicesPipeline\"@\"VFXMTLRenderPipeline\"\"_debugProgram\"[7^{__CFXProgram}]\"_debugShapes\"[7^{__CFXMesh}]}\"clusterInfo\"{Info=\"clusterBuffer\"{BufferSlice=\"impl\"{?=\"_buffer\"^v\"_offset\"I\"_length\"I}}\"clusterTexture\"@\"<MTLTexture>\"\"lightIndicesTexture\"@\"<MTLTexture>\"\"cellSize\"\"clusterScale\"\"cellPixelSize\"\"omniLightsRange\"\"spotLightsRange\"\"probeLightsRange\"\"lightsBuffer\"{BufferSlice=\"impl\"{?=\"_buffer\"^v\"_offset\"I\"_length\"I}}\"lightsBufferLightCount\"I\"shadowTexture\"@\"<MTLTexture>\"\"iesOrGoboTextures\"[8@\"<MTLTexture>\"]\"samplerStates\"[8@\"<MTLSamplerState>\"]\"areaBuffer\"@\"<MTLBuffer>\"\"areaBufferOffset\"Q\"areaBufferOffsets\"[8Q]}\"reflectionProbesTextureArray\"@\"<MTLTexture>\"}"
+ "{?=\"initialized\"B\"showFullStatistics\"B\"showRenderOptionsPanel\"B\"fps\"f\"waitDisplayLinkTime\"f\"pressedButtonIndex\"q\"fpsString\"^{__CFString}\"shortString\"^{__CFString}\"internalString\"^{__CFString}\"lightingStatistics\"[9I]\"stats\"{__CFXEngineStats=\"verticesProcessed\"I\"primitivesProcessed\"I\"drawCount\"I\"drawStep\"I\"frameCount\"I\"fboSwitches\"I\"vboSwitches\"I\"attSwitches\"I\"attEnabling\"I\"iboSwitches\"I\"vaoSwitches\"I\"prgSwitches\"I\"texSwitches\"I\"rssSwitches\"I\"getCount\"I\"uniformFloatSent\"I\"uniformIntSent\"I\"uniformVector2Sent\"I\"uniformVector3Sent\"I\"uniformVector4Sent\"I\"uniformMatrix4Sent\"I\"vboUploaded\"I\"iboUploaded\"I\"texUploaded\"I\"cpuTime\"d\"cstrTime\"d\"phyTime\"d\"vfxCoreTime\"d\"animTime\"d\"skinTime\"d\"mrphTime\"d\"rendTime\"d\"twoDTime\"d\"delegateTime\"d\"glFlushTime\"d\"waitDisplayLinkTime\"d\"drawableWaitTime\"d\"gpuTime\"d\"lastDisplayLinkTime\"d\"prgCount\"I\"texCount\"I\"fboCount\"I\"vboCount\"I\"rboCount\"I\"iboCount\"I\"cboCount\"I\"vaoCount\"I\"fboMemory\"I\"rboMemory\"I\"vboMemory\"I\"iboMemory\"I\"cboMemory\"I\"texMemory\"I\"backBufferMemory\"I\"depthBuffersMemory\"I\"onlineShaderCount\"I\"onlineShaderCompilationTime\"d\"renderPipelineCount\"I\"renderPipelineCompilationTime\"d\"computePipelineCount\"I\"computePipelineCompilationTime\"d\"frmAvgTime\"d\"frmMinTime\"d\"frmMaxTime\"d\"frameTimeHistory\"[60d]\"frameTimeCurrentIndex\"I\"startTime\"d\"lastFrameTime\"d}}"
+ "{?=\"kind\"q\"active\"B\"local\"B\"strength\"f\"dampening\"f\"noiseAmount\"f\"noiseSeed\"Q\"categoryBitMask\"Q\"shape\"q\"scope\"q\"cullMode\"q\"falloffExponent\"f\"halfExtents\"\"offset\"\"smoothness\"f\"speed\"f}"
+ "{?=\"lock\"{os_unfair_lock_s=\"_os_unfair_lock_opaque\"I}\"keyCodeConfiguration\"@\"NSDictionary\"\"keyDown\"{set<unsigned short, std::less<unsigned short>, std::allocator<unsigned short>>=\"__tree_\"{__tree<unsigned short, std::less<unsigned short>, std::allocator<unsigned short>>=\"__begin_node_\"^v\"__end_node_\"{__tree_end_node<std::__tree_node_base<void *> *>=\"__left_\"^v}\"__size_\"Q}}\"forward\"{vector<unsigned short, std::allocator<unsigned short>>=\"__begin_\"^S\"__end_\"^S\"__cap_\"^S}\"backward\"{vector<unsigned short, std::allocator<unsigned short>>=\"__begin_\"^S\"__end_\"^S\"__cap_\"^S}\"left\"{vector<unsigned short, std::allocator<unsigned short>>=\"__begin_\"^S\"__end_\"^S\"__cap_\"^S}\"right\"{vector<unsigned short, std::allocator<unsigned short>>=\"__begin_\"^S\"__end_\"^S\"__cap_\"^S}}"
+ "{?=\"minFilter\"b8\"magFilter\"b8\"mipFilter\"b8\"sAddressMode\"b8\"tAddressMode\"b8\"rAddressMode\"b8\"compareFunction\"b8\"maxAnisotropy\"b7\"supportArgumentBuffers\"b1}"
+ "{?=\"monotonicSubsegmentCountCubic\"I\"segmentCountLinear\"S\"segmentCountQuadratic\"S\"segmentCountCubic\"S\"segmentInfoOffsetLinear\"S\"segmentInfoOffsetQuadratic\"S\"segmentInfoOffsetCubic\"S\"controlPointIndicesOffset\"S}"
+ "{?=\"passInstance\"^{__CFXPassInstance}\"lightingSystem\"^{__CFXLightingSystem}\"dynamicBatchingSystem\"^{__CFXDynamicBatchingSystem}\"renderingOverrides\"^{__CFXRenderingOverride}\"cullingContext\"^{__CFXCullingContext}\"renderGraphPass\"^v\"passRequiresLighting\"B\"isMainPass\"B\"transformTree\"^{__CFXTransformTree}\"programHashCodeStoreKey\"Q}"
+ "{?=\"red\"d\"green\"d\"blue\"d\"alpha\"d}"
+ "{?=\"renderSliceIndex\"C\"eyeCount\"C\"eyeIndex\"C\"viewMapping\"C\"multiVertexOutputStreamGenerator\"C\"isMainPass\"B}"
+ "{?=\"resourceProvider\"@\"resourceIDToBuffer\"@\"NSMapTable\"\"resourceIDToTexture\"@\"NSMapTable\"\"bufferToBuiltin\"@\"NSMapTable\"\"textureToBuiltin\"@\"NSMapTable\"\"resourceIDToRenderPipeline\"@\"NSMapTable\"\"resourceIDToRenderPipelineDesc\"@\"NSMapTable\"\"renderPipelineDescToResourceID\"@\"NSMapTable\"\"renderPipelineStateToDescriptor\"@\"NSMapTable\"\"argumentBufferEntries\"^{?}\"argumentBufferEntriesCount\"q\"newlyRegisteredRenderPipelineResourceIDs\"@\"NSMutableArray\"}"
+ "{?=\"stage\"i\"bindings\"@\"NSArray\"\"programBindingBlocks\"@\"NSDictionary\"\"overrides\"^{__CFXRenderingOverride}}"
+ "{?=\"supportsUpdate\"b1\"supportsDidApplyAnimations\"b1\"supportsDidSimulatePhysics\"b1\"supportsDidApplyConstraints\"b1\"supportsWillRender\"b1\"supportsDidRender\"b1\"supportsInputTime\"b1\"supportsReadSubdivCache\"b1\"supportsWriteSubdivCache\"b1\"supportsMainPassCustomPostProcess\"b1\"supportsDidPresent\"b1}"
+ "{?=\"textureInfo\"{?=\"texture\"^{__CFXImage}\"sampler\"{?=\"minFilter\"b8\"magFilter\"b8\"mipFilter\"b8\"sAddressMode\"b8\"tAddressMode\"b8\"rAddressMode\"b8\"compareFunction\"b8\"maxAnisotropy\"b7\"supportArgumentBuffers\"b1}\"textureSize\"{CGSize=\"width\"d\"height\"d}\"isRetina\"B}\"lineHeight\"f\"characterWidth_texture\"s\"characterWidth_typography\"^f\"characterHeight_texture\"s\"symbolRects\"^{?}}"
+ "{?=\"vfcGlobalConstants\"{BufferSlice=\"impl\"{?=\"_buffer\"^v\"_offset\"I\"_length\"I}}\"vfcGlobalConstantsEncoder\"@\"<MTLArgumentEncoder>\"\"vfcViewConstants\"{BufferSlice=\"impl\"{?=\"_buffer\"^v\"_offset\"I\"_length\"I}}\"viewConstants\"{BufferSlice=\"impl\"{?=\"_buffer\"^v\"_offset\"I\"_length\"I}}}"
+ "{?=\"videoOutput\"@\"pixelBuffer\"^{__CVBuffer}\"mtlTextureForRenderer\"@\"<MTLTexture>\"\"mtlTextureColorMatched\"@\"<MTLTexture>\"\"mtlTextureColorForColorMatchingComputeKernel\"@\"<MTLTexture>\"\"pixelBufferColorSpace\"^{CGColorSpace}}"
+ "{?=\"weakProgram\"^{__CFXProgram}\"baseIndex\"I\"baseVertex\"I\"vertexSize\"I\"allocatedVerticesSize\"I\"allocatedIndicesSize\"I\"textureImage\"^{__CFXImage}\"sampler\"{?=\"minFilter\"b8\"magFilter\"b8\"mipFilter\"b8\"sAddressMode\"b8\"tAddressMode\"b8\"rAddressMode\"b8\"compareFunction\"b8\"maxAnisotropy\"b7\"supportArgumentBuffers\"b1}\"texture\"^{__CFXTexture}\"drawMode\"C\"orthographic\"B\"clearDepthBuffer\"B\"enableDepthTest\"B\"enableCulling\"B\"isDynamic\"B\"mesh\"^{__CFXMesh}\"meshElement\"^{__CFXMeshElement}\"_cache\"{?=\"verticesStride\"Q\"colorsStride\"Q\"uvsStride\"Q\"verticesData\"*\"colorsData\"*\"uvsData\"*}\"_usedMeshes\"@\"NSMutableSet\"\"_freeMeshes\"@\"NSMutableSet\"\"_usedMeshElements\"@\"NSMutableSet\"\"_freeMeshElements\"@\"NSMutableSet\"}"
+ "{?=BCCCCCCC}24@0:8q16"
+ "{?=Cffif^v^v}16@0:8"
+ "{?=QQ}24@0:8@\"MTLTensorDescriptor\"16"
+ "{?=[4]}20@0:8i16"
+ "{?=^vII}16@0:8"
+ "{?=^vII}20@0:8C16"
+ "{?=b8b8b8b8b8b8b8b7b1}16@0:8"
+ "{?=b8b8b8b8b8b8b8b7b1}24@0:8@\"<MTLSamplerState>\"16"
+ "{?=b8b8b8b8b8b8b8b7b1}24@0:8@16"
+ "{?={?=Cffif^v^v}^v^viiBB{CGRect={CGPoint=dd}{CGSize=dd}}f}16@0:8"
+ "{?={?=b4b4b4b4b8b8}{?=b4b4b4b4b8b8}b7b1}24@0:8@\"<MTLDepthStencilState>\"16"
+ "{?={?=b4b4b4b4b8b8}{?=b4b4b4b4b8b8}b7b1}24@0:8@16"
+ "{BufferAllocatorPerFrame=\"impl\"^{__CFXBufferAllocatorPerFrame}}"
+ "{BufferSlice=\"impl\"{?=\"_buffer\"^v\"_offset\"I\"_length\"I}}"
+ "{BufferSlice={?=^vII}}28@0:8i16@20"
+ "{BufferSlice={?=^vII}}36@0:8i16@20@28"
+ "{Cache=\"rasterizerStates\"^{__CFXRasterizerStates}\"geometry\"^{__CFXGeometry}\"metalMesh\"@\"VFXMTLMesh\"\"meshElement\"^{__CFXMeshElement}\"metalMeshElement\"@\"VFXMTLMeshElement\"\"program\"^{__CFXProgram}\"material\"^{__CFXMaterial}\"model\"^{__CFXModel}\"metalShadable\"@\"VFXMTLShadable\"\"commonProfile\"^{__CFXCommonProfile}\"blendStates\"^{__CFXBlendStates}\"colorBufferWriteMask\"C\"primitiveTopologyClass\"C\"node\"^{__CFXNode}\"pointOfView\"^{__CFXNode}\"deformerStack\"^{__CFXDeformerStack}\"viewTransform\"{?=\"columns\"[4]}\"proj\"{?=\"columns\"[4]}\"vertexDescriptorHash\"Q\"tessellationPipelineStateHash\"C\"renderPipeline\"@\"VFXMTLRenderPipeline\"}"
+ "{TextureAllocatorPerFrame=\"impl\"^{__CFXTextureAllocatorPerFrame}}"
+ "{VFXTriggerEnabledTypes=\"tapBegan\"b1\"tapEnded\"b1\"tapDragged\"b1\"mouseMoved\"b1\"tapCancelled\"b1\"keyDown\"b1\"keyUp\"b1\"collisionBegan\"b1\"collisionUpdate\"b1\"collisionEnded\"b1\"handTracking\"b1\"gazeTracking\"b1\"motionTracking\"b1\"particleCollision\"b1}"
+ "{VFX_RE_C_EntityConstants_s=\"lodDrawInfo\"I\"fadeOpacity\"f\"tintFactor\"f\"debugMode\"I\"clippingIndexSlice\"{?=\"offset\"S\"count\"S}\"samplerIndexCount\"I\"sfFactor\"f\"instanceCount\"I\"fakeFresnelOpacityBasedBoostFactor\"f\"btTextureReadIndex\"C\"stencilReferenceValue\"C\"receivesIBLShadow\"B\"environmentLightingWeight\"f\"portalPlane\"\"dfColor\"\"dfColorStraight\"\"entityIdentifier\"Q\"meshPartIdentifier\"Q\"btUIBreakthroughEnabled\"B\"btUIBreakthroughInfluence\"S\"meshShadowIntensity\"f\"lightGroupIdentifier\"S\"depthMitigationTransitionFactor\"f\"sceneUnderstandingTransitionFactor\"f\"visualDepthStaticOcclusionTransitionFactor\"f\"invPortalLightBlendDistance\"S\"automaticallyInstanced\"B\"visualDepthStaticOcclusionDepthBias\"S}"
+ "{VFX_RE_C_EntityConstants_s=IffI{?=SS}IfIfCCBfQQBSfSfffSBS}16@0:8"
+ "{VFX_RE_C_GlobalConstants_s=\"crwsReferencePosition\"\"time\"f\"frameCount\"I\"dfColor\"\"dfColorStraight\"}"
+ "{VFX_RE_C_GlobalConstants_s=fI}16@0:8"
+ "{VFX_RE_C_ViewConstants_s=\"crWorldToViewArray\"[2{?=\"columns\"[4]}]\"crWorldToPhysicalCameraArray\"[2{?=\"columns\"[4]}]\"crWorldToProjArray\"[2{?=\"columns\"[4]}]\"crWorldToHomographyArray\"[2{?=\"columns\"[4]}]\"viewToProjArray\"[2{?=\"columns\"[4]}]\"projToViewArray\"[2{?=\"columns\"[4]}]\"crwsCameraPositionArray\"[2]\"vrrMapPhysicalSizeArray\"[2]\"viewportPercentsArray\"[2]\"viewportPercents\"\"renderTargetSize\"\"vrrMapScreenSize\"\"renderTargetColorFormats\"\"renderTargetDepthStencilFormatSampleCount\"\"tonemapInPlace\"I\"viewportCount\"I\"useVertexAmplification\"I\"povcClipDistance\"f\"cameraEye\"I\"additiveTintColor\"\"vignettingFadeoutDistanceNormalization\"S\"vignettingTotalFadeoutDistance\"S\"vignettingPivotPosition\"\"portalClipPlane\"}"
+ "{VFX_RE_C_ViewConstants_s=[2{?=[4]}][2{?=[4]}][2{?=[4]}][2{?=[4]}][2{?=[4]}][2{?=[4]}][2][2][2]IIIfISS}16@0:8"
+ "{array<(anonymous namespace)::BufferMetadata, 13UL>=\"__elems_\"[13{BufferMetadata=\"name\"@\"NSString\"\"scope\"i\"isArray\"B\"resolved\"B\"offset\"q\"size\"q}]}"
+ "{re_vfx_object_constants=\"render_options\"S\"perceptual_blending_mode\"S}"
+ "{re_vfx_object_constants=SS}16@0:8"
+ "{unique_ptr<CFX::BufferAllocatorPerFrame, std::default_delete<CFX::BufferAllocatorPerFrame>>=\"__ptr_\"^{BufferAllocatorPerFrame}}"
+ "{unique_ptr<VFXMTLRenderCommandEncoder, std::default_delete<VFXMTLRenderCommandEncoder>>=\"__ptr_\"^{VFXMTLRenderCommandEncoder}}"
+ "{view_constants=\"view_from_crworld\"[2{?=\"columns\"[4]}]\"proj_from_crworld\"[2{?=\"columns\"[4]}]\"proj_from_view\"[2{?=\"columns\"[4]}]\"view_from_proj\"[2{?=\"columns\"[4]}]\"crws_camera_pos\"[2]\"inverseViewProjectionMatrix\"{?=\"columns\"[4]}\"crInverseViewProjectionMatrix\"{?=\"columns\"[4]}\"crws_from_viewport\"[2{?=\"columns\"[4]}]\"worldReferencePosition\"\"renderTargetSize\"\"cameraCount\"I\"useVertexAmplification\"I\"ndcFromScreen\"\"nearFar\"\"linearizationFactors\"\"padding\"I\"fadeOpacity\"f\"renderTargetDepthStencilFormatSampleCount\"\"vrrMapPhysicalSizeArray\"[2]\"viewport_percents\"[2]\"vrrMapScreenSize\"\"portal_clip_plane_deprecated\"\"lastframe_proj_from_crworld\"[2{?=\"columns\"[4]}]\"fogParameters\"\"fogColor\"}"
+ "}"
+ "}\n\n"
+ "} %@;\n\n"
+ "} //namespace"
+ "} commonprofile_io_vert;"
+ "} else {\n"
+ "});\n"
+ "},\n    (float[]) {"
+ "}, "
+ "\xf0\xf0\xb2"
+ "\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf2"
- "\n\n\n\n\n\n#if __METAL_VERSION__ >= 220 \n    #include <TargetConditionals.h>\n    #if TARGET_OS_OSX || TARGET_OS_MACCATALYST\n        \n        \n        #define SHOULD_CHECK_IF_OUTSIDE_TEXTURE  0\n        #define RETURN_IF_OUTSIDE_TEXTURE(dst)\n        #define RETURN_IF_OUTSIDE_TEXTURE3D(dst)\n    #else\n        #define SHOULD_CHECK_IF_OUTSIDE_TEXTURE  1\n        #define RETURN_IF_OUTSIDE_TEXTURE(dst)   if ((index.x >= dst.get_width()) || (index.y >= dst.get_height())) return;\n        #define RETURN_IF_OUTSIDE_TEXTURE3D(dst) if ((index.x >= dst.get_width()) || (index.y >= dst.get_height()) || (index.z >= dst.get_depth())) return;\n    #endif\n    #define SUPPORTS_LAYERED_RENDERING           1\n    #define SUPPORTS_MULTIPLE_VIEWPORT_RENDERING 1\n#else\n    #if defined(__METAL_MACOS__)\n        \n        \n        #define SHOULD_CHECK_IF_OUTSIDE_TEXTURE      0\n        #define RETURN_IF_OUTSIDE_TEXTURE(dst)\n        #define RETURN_IF_OUTSIDE_TEXTURE3D(dst)\n        #define SUPPORTS_LAYERED_RENDERING           (__METAL_VERSION__ >= 200)\n        #define SUPPORTS_MULTIPLE_VIEWPORT_RENDERING (__METAL_VERSION__ >= 200)\n    #elif defined(__METAL_IOS__)\n        #define SHOULD_CHECK_IF_OUTSIDE_TEXTURE      1\n        #define RETURN_IF_OUTSIDE_TEXTURE(dst)       if ((index.x >= dst.get_width()) || (index.y >= dst.get_height())) return;\n        #define RETURN_IF_OUTSIDE_TEXTURE3D(dst)     if ((index.x >= dst.get_width()) || (index.y >= dst.get_height()) || (index.z >= dst.get_depth())) return;\n        #define SUPPORTS_LAYERED_RENDERING           (__METAL_VERSION__ >= 210)\n        #define SUPPORTS_MULTIPLE_VIEWPORT_RENDERING (__METAL_VERSION__ >= 210)\n    #endif\n#endif\n\n\n\nnamespace vfx {\n    \n    \n    static inline float4 reduce_op(float4 d0, float4 d1)\n    {\n        d0.x = min(d0.x, d1.x);\n        d0.y = max(d0.y, d1.y);\n        d0.z += d1.z;\n        d0.w += d1.w;\n        return d0;\n    }\n    \n    inline float vector_reduce_min(float4 v)\n    {\n        float2 min_lh = min(v.xy, v.zw);\n        return min(min_lh.x, min_lh.y);\n    }\n    \n    inline float vector_reduce_max(float4 v)\n    {\n        float2 max_lh = max(v.xy, v.zw);\n        return max(max_lh.x, max_lh.y);\n    }\n    \n    inline int vector_reduce_add(int4 v)\n    {\n        int2 add_lh = v.xy + v.zw;\n        return add_lh.x + add_lh.y;\n    }\n    \n    inline float3x3 mat3(float4x4 mat4)\n    {\n        return float3x3(mat4[0].xyz, mat4[1].xyz, mat4[2].xyz);\n    }\n    \n    inline float3 mat4_mult_float3_normalized(float4x4 matrix, float3 src)\n    {\n        float3 dst  =  src.xxx * matrix[0].xyz;\n        dst         += src.yyy * matrix[1].xyz;\n        dst         += src.zzz * matrix[2].xyz;\n        return normalize(dst);\n    }\n    \n    inline float3 mat4_mult_float3(float4x4 matrix, float3 src)\n    {\n        float3 dst  =  src.xxx * matrix[0].xyz;\n        dst         += src.yyy * matrix[1].xyz;\n        dst         += src.zzz * matrix[2].xyz;\n        return dst;\n    }\n\n    inline float3 matrix_rotate(float4x4 mat, float3 dir)\n    {\n        return  dir.xxx * mat[0].xyz +\n                dir.yyy * mat[1].xyz +\n                dir.zzz * mat[2].xyz;\n    }\n\n    inline float4 matrix_transform(float4x4 mat, float3 pos)\n    {\n        return  pos.xxxx * mat[0] +\n                pos.yyyy * mat[1] +\n                pos.zzzz * mat[2] +\n                           mat[3];\n    }\n\n    inline float3 quaternion_rotate_vector(float4 q, float3 v)\n    {\n        float3 t = 2.f * cross(q.xyz, v);\n        return v + q.w * t + cross(q.xyz, t);\n    }\n\n    \n    template <class T>\n    inline vec<T, 3> robust_normalize(vec<T, 3> v)\n    {\n        vec<T, 3> zero = 0.;\n        return all(v == zero) ? zero : normalize(v);\n    }\n\n    template <class T>\n    inline void generate_basis(vec<T, 3> inR, thread vec<T, 3> *outS, thread vec<T, 3> *outT)\n    {\n        \n        T x  = -inR.x;\n        T y  = inR.y;\n        T z  = inR.z;\n        T sz = copysign(T(1.), z);\n        T a  = y / (abs(z) + T(1.));\n        T b  = y * a;\n        T c  = x * a;\n        *outS = (vec<T, 3>){ z + sz * b,  sz * c,       x       };\n        *outT = (vec<T, 3>){ c,           T(1.) - b,    -sz * y };\n    }\n    \n    \n    \n    inline float3 blend_add(float3 base, float3 blend)\n    {\n        return min(base + blend, 1.0);\n    }\n    \n    inline float3 blend_lighten(float3 base, float3 blend)\n    {\n        return max(blend, base);\n    }\n    \n    inline float3 blend_screen(float3 base, float3 blend)\n    {\n        return (1.0 - ((1.0 - base) * (1.0 - blend)));\n    }\n\n    \n    \n    inline half sq(half f) {\n        return f * f;\n    }\n\n    inline float sq(float f) {\n        return f * f;\n    }\n    \n    inline float2 sincos(float angle) {\n        float cs;\n        float sn = ::sincos(angle, cs);\n        return float2(sn, cs);\n    }\n    \n    \n    inline float acos_fast(float f) {\n        float x = abs(f);\n        float res = -0.156583f * x + M_PI_2_F;\n        res *= sqrt(1.0f - x);\n        return (f >= 0.f) ? res : M_PI_F - res;\n    }\n\n    inline float asin_fast(float f)\n    {\n        return M_PI_2_F - acos_fast(f);\n    }\n\n    \n    inline float atan_fast(float inX)\n    {\n        float  x = inX;\n        return x*(-0.1784f * abs(x) - 0.0663f * x * x + 1.0301f);\n    }\n    \n    inline float atan2_fast(float y, float x)\n    {\n        float sx = x > 0.f ? -1.f : 1.f;\n        float abs_y = abs(y) + 1e-10f; \n        float r = (x + abs_y*sx) / (abs_y - x*sx);\n        float angle = sx * M_PI_4_F + M_PI_2_F;\n        angle      += (0.1963f * r * r - 0.9817f) * r;\n        return y > 0.f ? angle : -angle;\n    }\n    \n    \n    template <class T>\n    inline vec<T, 3> cartesian_from_spherical(vec<T, 2> uv)\n    {\n        \n        \n        T cos_phi;\n        T phi = uv.x * 2.0f * M_PI_F;\n        T sin_phi = ::sincos(phi, cos_phi);\n        \n        T cos_theta;\n        T theta     = uv.y * M_PI_F;\n        T sin_theta = ::sincos(theta, cos_theta);\n\n        return vec<T, 3>(cos_phi * sin_theta,\n                         cos_theta,\n                         -sin_phi * sin_theta);\n    }\n\n    inline float2 spherical_from_cartesian(float3 dir)\n    {\n        return float2( atan2(-dir.z, dir.x) * (0.5f * M_1_PI_F), acos(dir.y) * M_1_PI_F);\n    }\n\n    inline half2 spherical_from_cartesian(half3 dir)\n    {\n        return half2(atan2(-dir.z, dir.x) * 0.5h, acos(dir.y)) * M_1_PI_H;\n    }\n\n    inline float2 spherical_from_cartesian_fast(float3 dir)\n    {\n        return float2( atan2_fast(-dir.z, dir.x) * (0.5f * M_1_PI_F), acos_fast(dir.y) * M_1_PI_F);\n    }\n\n    inline half2 spherical_from_cartesian_fast(half3 dir)\n    {\n        return half2( atan2_fast(-dir.z, dir.x) * 0.5h, acos_fast(dir.y)) * M_1_PI_H;\n    }\n\n    #define dual_contract_factor  1.0\n\n    template <class T>\n    inline vec<T, 2> dual_paraboloid_from_cartesian(vec<T, 3> dir)\n    {\n        dir.xy /= abs(dir.z) + 1.0;\n\n        dir.y = 0.5 - dir.y * 0.5;\n        T s   = sign(dir.z) * 0.25;\n        dir.x = s * (dir.x - 1.0) + 0.5;\n        return dir.xy;\n    }\n    \n    \n    template <class T>\n    inline vec<T, 3> cartesian_from_dual_paraboloid(vec<T, 2>  uv)\n    {\n        \n        T zside = 0.5 * sign(0.5 - uv.x);\n        uv.x = 1.0 - abs(4.0 * uv.x - 2.0); \n        uv.y   = 1.0 - uv.y * 2.0;\n        T z = length_squared(uv); \n        z = (1.0 - z) * zside;\n        \n        return vec<T, 3>(uv.x, uv.y, z);\n    }\n\n    \n    template <class T>\n    inline vec<T, 2> signNotZero(vec<T, 2> v) {\n        return vec<T, 2>((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n    }\n\n    template <class T>\n    inline vec<T, 2> octEncode(vec<T, 3> v) {\n        float2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n        return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n    }\n\n    template <class T>\n    inline vec<T, 3> octDecode(vec<T, 2> p) {\n        float3 v = float3(p.xy, 1.0 - abs(p.x) - abs(p.y));\n        if (v.z < 0) v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);\n        return normalize(v);\n    }\n\n    inline float reduce_min(float3 v) {\n        return min(v.x, min(v.y, v.z));\n    }\n    \n    inline float reduce_min(float4 v) {\n        return min(min(v.x, v.y), min(v.z, v.w));\n    }\n\n    inline float reduce_max(float3 v) {\n        return max(v.x, max(v.y, v.z));\n    }\n\n    inline float reduce_max(float4 v) {\n        return max(max(v.x, v.y), max(v.z, v.w));\n    }\n\n    \n    inline float3 randomSphereDir(float2 rnd)\n    {\n        float s = rnd.x * M_PI_F * 2.f;\n        float t = rnd.y * 2.f - 1.f;\n        return float3( float2(sin(s), cos(s)) * sqrt(1.f-t*t), t );\n    }\n    \n    \n    template <class T>\n    inline T interleaved_gradient_noise(vec<T, 2> pos)\n    {\n        vec<T, 3> magic( 0.06711056f, 0.00583715f, 52.9829189f );\n        return fract( magic.z * fract( dot( pos, magic.xy ) ) );\n    }\n    \n    inline float3 hemisphere_reflect(float3 v, float3 nrm)\n    {\n        \n        \n        \n        float k = dot(v,nrm);\n        return (k>0.0) ? v : v-2.0*nrm*k;\n    }\n\n    \n    inline float3 randomHemisphereDir(float3 dir, float2 rnd)\n    {\n        return hemisphere_reflect(randomSphereDir( rnd ), dir);\n    }\n    \n    inline void orthogonal_basis(float3 n, thread float3& xp, thread float3& yp)\n    {\n        \n        float sz = n.z >= 0.f ? 1.f : -1.f;\n        float a  =  n.y / (1.f + abs(n.z));\n        float b  =  n.y * a;\n        float c  = -n.x * a;\n        \n        xp = float3(n.z + sz * b,   sz * c,     -n.x);\n        yp = float3(c,              1.f - b,    -sz * n.y);\n    }\n\n    template <class U>\n    inline float2 normalized_coordinate(ushort2 index, U texture)\n    {\n        uint width  = texture.get_width();\n        uint height = texture.get_height();\n        \n        float u = width  == 1 ? 0.5f : float(index.x) / float(width - 1);\n        float v = height == 1 ? 0.5f : float(index.y) / float(height - 1);\n        \n        return float2(u, v);\n    }\n\n    template <class U>\n    inline float2 normalized_coordinate(uint2 index, U texture)\n    {\n        uint width  = texture.get_width();\n        uint height = texture.get_height();\n        \n        float u = width  == 1 ? 0.5f : float(index.x) / float(width - 1);\n        float v = height == 1 ? 0.5f : float(index.y) / float(height - 1);\n        \n        return float2(u, v);\n    }\n\n    template <class U>\n    inline half2 normalized_coordinate_half(uint2 index, U texture)\n    {\n        uint width  = texture.get_width();\n        uint height = texture.get_height();\n        \n        half u = width  == 1 ? 0.5h : half(index.x) / half(width - 1);\n        half v = height == 1 ? 0.5h : half(index.y) / half(height - 1);\n        \n        return half2(u, v);\n    }\n\n    \n\n    template <class T>\n    inline vec<T, 3> cubemap_dir_from_sampleCoord(uint face, vec<T, 2> sampleCoord) \n    {\n        switch(face) {\n            case 0: \n                return vec<T, 3>( 1.0, -sampleCoord.y, -sampleCoord.x);\n\n            case 1: \n                return vec<T, 3>(-1.0, -sampleCoord.y,  sampleCoord.x);\n\n            case 2: \n                return vec<T, 3>(sampleCoord.x,  1.0,  sampleCoord.y);\n\n            case 3: \n                return vec<T, 3>(sampleCoord.x, -1.0, -sampleCoord.y);\n\n            case 4: \n                return vec<T, 3>( sampleCoord.x, -sampleCoord.y,  1.0);\n\n            default: \n                return vec<T, 3>(-sampleCoord.x, -sampleCoord.y, -1.0);\n        }\n    }\n\n    \n    template <class T>\n    inline T signed_unit(T uv) {\n        return uv * 2.0 - 1.0;\n    }\n\n    \n    template <class T>\n    inline T unsigned_unit(T uv) {\n        return uv * 0.5 + 0.5;\n    }\n\n    template <class T>\n    inline vec<T, 3> cubemap_dir_from_uv(uint face, vec<T, 2> uv) \n    {\n        return cubemap_dir_from_sampleCoord(face, signed_unit(uv));\n    }\n\n    template <class T>\n    inline vec<T, 3> cubemap_dir_from_uv_unit(uint face, vec<T, 2> uv) \n    {\n        return normalize(cubemap_dir_from_uv(face, uv));\n    }\n\n    \n    \n    inline float2 barycentric_mix(float2 __x, float2 __y, float2 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }\n    inline float3 barycentric_mix(float3 __x, float3 __y, float3 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }\n    inline float4 barycentric_mix(float4 __x, float4 __y, float4 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }\n    \n    static inline float rect(float2 lt, float2 rb, float2 uv)\n    {\n        float2 borders = step(lt, uv) * step(uv, rb);\n        return borders.x * borders.y;\n    }\n    \n    inline half4 debugColorForCascade(int cascade)\n    {\n        switch (cascade) {\n            case 0:\n            return half4(1.h, 0.h, 0.h, 1.h);\n            case 1:\n            return half4(0.9, 0.5, 0., 1.);\n            case 2:\n            return half4(1., 1., 0., 1.);\n            case 3:\n            return half4(0., 1., 0., 1.);\n            default:\n            return half4(0., 0., 0., 1.);\n        }\n    }\n\n    inline half3 debugColorForFace(int count)\n    {\n        switch (count) {\n            case 0:  return half3(1.0h, 0.1h, 0.1h);\n            case 1:  return half3(0.1h, 1.0h, 1.0h);\n            case 2:  return half3(0.1h, 1.0h, 0.1h);\n            case 3:  return half3(1.0h, 0.1h, 1.0h);\n            case 4:  return half3(0.1h, 0.1h, 1.0h);\n            default: return half3(1.0h, 1.0h, 0.1h);\n        }\n    }\n\n    inline half4 debugColorForCount(int count)\n    {\n        switch (count) {\n            case 0: return half4(0.0h, 0.0h, 0.0h, 1.h);\n            case 1: return half4(0.0h, 0.0h, 0.4h, 1.h);\n            case 2: return half4(0.0h, 0.0h, 0.9h, 1.h);\n            case 3: return half4(0.0h, 0.4h, 0.7h, 1.h);\n            case 4: return half4(0.0h, 0.9h, 0.4h, 1.h);\n            case 5: return half4(0.0h, 0.9h, 0.0h, 1.h);\n            case 6: return half4(0.4h, 0.7h, 0.0h, 1.h);\n            case 7: return half4(0.9h, 0.7h, 0.0h, 1.h);\n            default: return half4(1., 0., 0., 1.);\n        }\n    }\n\n    inline float grid(float2 lt, float2 rb, float2 gridSize, float thickness, float2 uv)\n    {\n        float insideRect = rect(lt, rb + thickness, uv);\n        float2 gt = thickness * gridSize;\n        float2 lines = step(abs(lt - fract(uv * gridSize)), gt);\n        return insideRect * (lines.x + lines.y);\n    }\n\n    inline float checkerboard(float2 gridSize, float2 uv)\n    {\n        float2 check = floor(uv * gridSize);\n        return step(fmod(check.x + check.y, 2.f), 0.f);\n    }\n\n    \n\n    inline float luminance(float3 color)\n    {\n        \n        \n        return dot(color, float3(0.212671, 0.715160, 0.072169));\n    }\n    inline half luminance(half3 color)\n    {\n        \n        \n        return dot(color, half3(0.212671h, 0.715160h, 0.072169h));\n    }\n    \n    inline float vfx_srgb_to_linear(float c)\n    {\n        return (c <= 0.04045f) ? c / 12.92f : powr((c + 0.055f) / 1.055f, 2.4f);\n    }\n    \n    inline half srgb_to_linear_fast(half c)\n    {\n        return powr(c, 2.2h);\n    }\n    \n    inline half3 srgb_to_linear_fast(half3 c)\n    {\n        return powr(c, 2.2h);\n    }\n    \n    inline half vfx_srgb_to_linear(half c)\n    {\n        \n        return (c <= 0.04045h) ? (c * 0.0773993808h) :  powr(0.9478672986h * c + 0.05213270142h, 2.4h);\n    }\n    \n    inline float3 vfx_srgb_to_linear(float3 c)\n    {\n        return float3(vfx_srgb_to_linear(c.x), vfx_srgb_to_linear(c.y), vfx_srgb_to_linear(c.z));\n    }\n    \n    inline float linear_to_srgb(float c)\n    {\n        return (c < 0.0031308f) ? (12.92f * c) : (1.055f * powr(c, 1.f/2.4f) - 0.055f);\n    }\n    \n    inline float3 linear_to_srgb(float3 v) { \n        return float3(linear_to_srgb(v.x), linear_to_srgb(v.y), linear_to_srgb(v.z));\n    }\n    \n}\n\n\n\ninline float4 texture2DProj(texture2d<float> tex, sampler smp, float4 uv)\n{\n    return tex.sample(smp, uv.xy / uv.w);\n}\n\ninline half4 texture2DProj(texture2d<half> tex, sampler smp, float4 uv)\n{\n    return tex.sample(smp, uv.xy / uv.w);\n}\n\nstatic constexpr sampler vfx_shadow_sampler_rev_z = sampler(coord::normalized, filter::linear, mip_filter::none, address::clamp_to_zero, compare_func::less_equal);\n\nstatic constexpr sampler vfx_shadow_sampler = vfx_shadow_sampler_rev_z;\n\ninline float shadow2D(sampler shadow_sampler, depth2d<float> tex, float3 uv, float4 tile)\n{\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    float2 mapSize = float2(tex.get_width(), tex.get_height());\n    float2 duv = 0.5f / mapSize;\n    float2 uv0 = tile.xy;\n    float2 uvs = tile.zw;\n\n    float2 b = uv0 + duv;\n    float2 s = uvs - 2 * duv;\n\n    uv.xy = uv.xy * s + b;\n#endif\n\n    return tex.sample_compare(shadow_sampler, uv.xy, uv.z);\n}\n\ninline float shadow2DProj(sampler shadow_sampler, depth2d<float> tex, float4 uv, float4 tile)\n{\n    float3 uvp = uv.xyz / uv.w;\n    uvp.xy = tile.xy + uvp.xy * tile.zw;\n    return tex.sample_compare(shadow_sampler, uvp.xy, uvp.z);\n}\n\ninline float shadow2DArray(sampler shadow_sampler, depth2d_array<float> tex, float3 uv, uint slice)\n{\n    return tex.sample_compare(shadow_sampler, uv.xy, slice, uv.z);\n}\n\ninline float shadow2DArrayProj(sampler shadow_sampler, depth2d_array<float> tex, float4 uv, uint slice)\n{\n    float3 uvp = uv.xyz / uv.w;\n    return tex.sample_compare(shadow_sampler, uvp.xy, slice, uvp.z);\n}\n\n\n\ninline float4 transformViewPosInShadowSpace(float3 pos, float4x4 shadowMatrix)\n{\n    \n    float4 lightScreen =  shadowMatrix * float4(pos, 1.f);\n\n    return lightScreen;\n}\n\ninline float ComputeShadow(sampler shadow_sampler, float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap, float4 tile)\n{\n    float4 lightScreen =  transformViewPosInShadowSpace(worldPos, shadowMatrix);\n    lightScreen.xyz /= lightScreen.w;\n\n    if (any(lightScreen.xy < 0.0 || lightScreen.xy > 1.0)) {\n        return 0.0;\n    }\n\n    float shadow = shadow2D(shadow_sampler, shadowMap, lightScreen.xyz, tile);\n\n    \n    shadow *= step(0., lightScreen.w);\n    \n    return shadow;\n}\n\ninline float ComputeSoftShadowGrid(sampler shadow_sampler, float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap, int sampleCount, float4 tile)\n{\n    float4 lightScreen =  transformViewPosInShadowSpace(worldPos, shadowMatrix);\n    lightScreen.xyz /= lightScreen.w;\n\n    if (any(lightScreen.xy < 0.0 || lightScreen.xy > 1.0)) {\n        return 0.0;\n    }\n\n    \n    float shadow;\n    if (sampleCount <= 1) {\n        shadow = shadow2D(shadow_sampler, shadowMap, lightScreen.xyz, tile);\n    } else {\n\n        lightScreen.z += 0.005f; \n\n        float2 texelSize = 2.f / float2(shadowMap.get_width(), shadowMap.get_height());\n        float2 origin    = lightScreen.xy - (sampleCount * 0.5f) * texelSize;\n\n        \n        if (sampleCount <= 4) { \n            half totalAccum = 0.h;\n            for (int y = 0; y < sampleCount; ++y) {\n                for (int x = 0; x < sampleCount; ++x) {\n                    totalAccum  += half(shadowMap.sample_compare(shadow_sampler, origin, lightScreen.z, 2 * int2(x,y)));\n                }\n            }\n            shadow = totalAccum / half(sampleCount * sampleCount);\n        } else {\n            float totalAccum = 0.f;\n            for (int y = 0; y < sampleCount; ++y) {\n                for (int x = 0; x < sampleCount; ++x) {\n                    float2 samplePos = origin + texelSize * float2(x, y);\n                    totalAccum  += shadowMap.sample_compare(shadow_sampler, samplePos, lightScreen.z);\n                }\n            }\n            shadow = totalAccum / float(sampleCount * sampleCount);\n        }\n    }\n\n    \n    shadow *= step(0., lightScreen.w);\n\n    return shadow;\n}\n\ninline float ComputeSoftShadow(sampler shadow_sampler, float3 lightScreen, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount, float shadowRadius, float4 tile)\n{\n    if (any(lightScreen.xyz < 0.0 || lightScreen.xyz > 1.0)) {\n        return 0.0;\n    }\n\n    \n    float shadow;\n    if (sampleCount <= 1) {\n        shadow = shadow2D(shadow_sampler, shadowMap, lightScreen.xyz, tile);\n    } else {\n        \n\n        \n        float3 duvdist_dx = dfdx(lightScreen.xyz);\n        float3 duvdist_dy = dfdy(lightScreen.xyz);\n\n        \n        \n        \n        \n        \n        \n\n        float inv_det_J = 1.0 / ((duvdist_dx.x * duvdist_dy.y) - (duvdist_dx.y * duvdist_dy.x));\n        float2 ddist_duv = inv_det_J * float2(duvdist_dy.y * duvdist_dx.z - duvdist_dx.y * duvdist_dy.z,\n                                              duvdist_dx.x * duvdist_dy.z - duvdist_dy.x * duvdist_dx.z);\n\n        float totalAccum = 0.0;\n\n        for (int i = 0; i < sampleCount; i++) {\n            float3 uvOffset = shadowKernel[i].xyz * shadowRadius;\n\n            float2 uvWithOffset = lightScreen.xy + uvOffset.xy;\n            if (any(uvWithOffset < 0.0 || uvWithOffset > 1.0)) {\n                continue;\n            }\n            float dist = lightScreen.z * (1.0 + uvOffset.z) + (ddist_duv.x * uvOffset.x + ddist_duv.y * uvOffset.y);\n            if (dist < 0.0) {\n                continue;\n            }\n\n            totalAccum += shadow2D(shadow_sampler, shadowMap, float3(uvWithOffset, dist), tile);\n        }\n\n        shadow = totalAccum / float(sampleCount);\n    }\n\n    return shadow;\n}\n\ninline float ComputeCascadeBlendAmount(float3 shadowPos, bool cascadeBlending)\n{\n    const float cascadeBlendingFactor = 0.1f; \n\n    float3 cascadePos = abs(shadowPos.xyz * 2.f - 1.f);\n    \n    if (cascadeBlending) {\n#if 0\n        const float edge = 1.f - cascadeBlendingFactor;\n        \n        cascadePos = 1.f - saturate((cascadePos - edge) / cascadeBlendingFactor);\n        return cascadePos.x * cascadePos.y * cascadePos.z; \n#else\n        \n        float distToEdge = 1.0f - max(max(cascadePos.x, cascadePos.y), cascadePos.z);\n        return smoothstep(0.0f, cascadeBlendingFactor, distToEdge);\n#endif\n    } else {\n        return step(cascadePos.x, 1.f) * step(cascadePos.y, 1.f) * step(cascadePos.z, 1.f);\n    }\n}\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\ninline float4 SampleShadowCascade(sampler shadow_sampler, depth2d<float> shadowMaps, float3 shadowPosition, uint cascadeIndex, constant float4* shadowKernel, int sampleCount, float shadowRadius, float4 tile)\n#else\ninline float4 SampleShadowCascade(sampler shadow_sampler, depth2d_array<float> shadowMaps, float3 shadowPosition, uint cascadeIndex, constant float4* shadowKernel, int sampleCount, float shadowRadius)\n#endif\n{\n    \n    float2 gridSize = float2(shadowMaps.get_width(), shadowMaps.get_height()) / 32;\n    float gd = vfx::checkerboard(shadowPosition.xy, gridSize);\n    float3 gridCol = mix(float3(vfx::debugColorForCascade(cascadeIndex).rgb), float3(0.f), float3(gd > 0.f));\n\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    float shadow = ComputeSoftShadow(shadow_sampler, shadowPosition, shadowMaps, shadowKernel, sampleCount, shadowRadius, tile);\n#else\n    float shadow = 0.0;\n    if (sampleCount > 1) {\n\n        \n        for (int i = 0; i < sampleCount; ++i) {\n            shadow += shadow2DArray(shadow_sampler, shadowMaps, shadowKernel[i].xyz * shadowRadius + shadowPosition, cascadeIndex);\n        }\n        shadow /= float(sampleCount);\n    } else {\n        \n        shadow = shadow2DArray(shadow_sampler, shadowMaps, shadowPosition, cascadeIndex);\n    }\n#endif\n    return float4(gridCol, shadow);\n}\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\ninline float4 ComputeCascadedShadow(sampler shadow_sampler, float3 viewPos, float4x4 shadowMatrix, constant float4 *cascadeScale, constant float4 *cascadeBias, int cascadeCount, depth2d<float> shadowMaps, bool enableCascadeBlending, constant float4* shadowKernel, int sampleCount, float shadowRadius, constant float4* tiles)\n#else\ninline float4 ComputeCascadedShadow(sampler shadow_sampler, float3 viewPos, float4x4 shadowMatrix, constant float4 *cascadeScale, constant float4 *cascadeBias, int cascadeCount, depth2d_array<float> shadowMaps, bool enableCascadeBlending, constant float4* shadowKernel, int sampleCount, float shadowRadius)\n#endif\n{\n    float4 shadow = 0.f;\n    float shadowSum = 0.f;\n    \n    \n    float3 pos_ls =  (shadowMatrix * float4(viewPos, 1.f)).xyz;\n    for (int c = 0; c < cascadeCount; ++c) {\n        \n        float3 pos_cs =  pos_ls * cascadeScale[c].xyz + cascadeBias[c].xyz;\n\n        \n        float cascadeRadius = shadowRadius * cascadeScale[c].x;\n\n        float opacity = ComputeCascadeBlendAmount(pos_cs, enableCascadeBlending);\n\n\n        if (shadowSum >= 1.f && opacity <= 0.0) \n            break;                              \n                                                \n\n        if (opacity > 0.f) { \n            \n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n            shadow += SampleShadowCascade(shadow_sampler, shadowMaps, pos_cs, c, shadowKernel, sampleCount, cascadeRadius, tiles[c]) * opacity;\n#else\n            shadow += SampleShadowCascade(shadow_sampler, shadowMaps, pos_cs, c, shadowKernel, sampleCount, cascadeRadius) * opacity;\n#endif\n            shadowSum += opacity;\n        }\n    }\n\n    if (shadowSum > 0) {\n        shadow /= shadowSum;\n    }\n    return shadow;\n}\n\ntemplate <class T>\ninline void applyFog(thread vec<T, 4>& color, float eye_distance, float3 fogParameters, vec<T, 4> fogColor) {\n    float fogFactor = pow(clamp(eye_distance * fogParameters.x + fogParameters.y, 0.f, float(fogColor.a)), fogParameters.z);\n    color.rgb = mix(color.rgb, fogColor.rgb * color.a, fogFactor);\n}\n\n\n\n#pragma mark Pack/Unpack\n\ninline ushort packHalf2ToUShort(half2 v) {\n    v = saturate(v);\n    v = round(v*255);\n    ushort2 uv = ushort2(v);\n    ushort res = (uv.x & 0x00ff) | ((uv.y & 0x00ff) << 8);\n    return res;\n}\n\ninline half2 unpackHalf2FromUShort(ushort v) {\n    half2 res;\n    \n    res.x = half(v & 0x00ff);\n    res.y = half( (v & 0xff00) >> 8);\n    \n    return res/255.;\n}\n"
- "\n\nfloat2 _grid(float2 uv, float2 lineWidth)\n{\n    float4 uvDDXY = float4(dfdx(uv), dfdy(uv));\n    float2 uvDeriv = float2(length(uvDDXY.xz), length(uvDDXY.yw));\n    bool invertLineX = lineWidth.x > 0.5;\n    bool invertLineY = lineWidth.y > 0.5;\n    float2 targetWidth = float2(invertLineX ? 1.0 - lineWidth.x : lineWidth.x, invertLineY ? 1.0 - lineWidth.y : lineWidth.y);\n    float2 drawWidth = clamp(targetWidth, uvDeriv, 0.5);\n    float2 lineAA = uvDeriv * 1.5;\n    float2 gridUV = abs(fract(uv) * 2.0 - 1.0);\n    gridUV = float2( invertLineX ? gridUV.x : 1.0 - gridUV.x, invertLineY ? gridUV.y : 1.0 - gridUV.y );\n    float2 grid2 = smoothstep(drawWidth + lineAA, drawWidth - lineAA, gridUV);\n    grid2 *= saturate(targetWidth / drawWidth);\n    grid2 = mix(grid2, targetWidth, saturate(uvDeriv * 2.0 - 1.0));\n    grid2 = float2( invertLineX ? 1.0 - grid2.x : grid2.x, invertLineY ? 1.0 - grid2.y : grid2.y);\n    return grid2;\n}\n\n\nfloat2 _gridFast(float2 uv, float2 lineWidth)\n{\n    float4 uvDDXY = float4(dfdx(uv), dfdy(uv));\n    float2 uvDeriv = float2(length(uvDDXY.xz), length(uvDDXY.yw));\n    float2 drawWidth = clamp(lineWidth, uvDeriv, 0.5);\n    float2 lineAA = uvDeriv * 1.5;\n    float2 gridUV = 1. - abs(fract(uv) * 2.0 - 1.0);\n    float2 grid2 = smoothstep(drawWidth + lineAA, drawWidth - lineAA, gridUV);\n    grid2 *= saturate(lineWidth / drawWidth);\n    grid2 = mix(grid2, lineWidth, saturate(uvDeriv * 2.0 - 1.0));\n    return grid2;\n}\n\nfloat grid(float2 uv, float2 lineWidth)\n{\n    float2 grid2 = _gridFast(uv, lineWidth);\n    return mix(grid2.x, 1.0, grid2.y);\n}\n\n#pragma body\n\nfloat2 uv0 = (_surface.diffuseTexcoord.xy - float2(0.5)) * 2.;\nfloat2 uv = uv0 * 500;\nfloat2 uv2 = uv * 10;\nfloat s1 = 0.002;\nfloat s2 = 0.0012;\nfloat g = grid(uv, float2(s1));\nfloat g2 = grid(uv2, float2(s2));\n\nfloat4 color = float4(0.5, 0.5, 0.5, 0.8);\nfloat4 red = float4(1,0,0,1);\nfloat4 blue = float4(0.1568627451,0.3137254902,1,1);\n\nfloat2 g0 = _gridFast(uv0, float2(s1)*0.003);\ng0 = smoothstep(0., 0.01, g0);\n\ncolor = mix(color, blue, g0.x);\ncolor = mix(color, red, g0.y);\n\n\nfloat border = max(0., 1 - length(uv0));\n\n\nfloat p = min(1.0, -(_surface.position.z + 0.1));\n\n_output.color = color * max(g, g2) * pow(border, 0.5) * p;\n"
- "\n#import <metal_stdlib>\n\nusing namespace metal;\n\n#import \"vfx_metal\"\n#import \"vfx_util.h\"\n#import \"CFX-PBR.metal\"\n#import \"vfx_tessellation.h\"\n\n\n\n#ifdef USE_LAYERED_RENDERING\n#define texture2d_layer texture2d_array\n#define sampleLayer(a,b) sample(a,b,in.sliceIndex)\n#else\n#define texture2d_layer texture2d\n#define sampleLayer(a,b) sample(a,b)\n#endif\n\n#ifdef CFX_USE_TEXTURE_FOR_LIGHT_INDICES\n#define LightIndex(lid) u_lightIndicesTexture.read((ushort)lid).x\n#else\n#define LightIndex(lid) u_lightIndicesBuffer[lid]\n#endif\n\n\n\n#ifdef USE_GBUFFER_OUTPUT\n    #undef USE_PER_VERTEX_LIGHTING\n    #undef USE_PER_PIXEL_LIGHTING\n    #undef USE_LIGHTING\n#endif\n\n\n\ntypedef struct {\n\n#ifdef USE_MODELTRANSFORM\n    float4x4 modelTransform;\n#endif\n#ifdef USE_INVERSEMODELTRANSFORM\n    float4x4 inverseModelTransform;\n#endif\n#ifdef USE_MODELVIEWTRANSFORM\n    float4x4 modelViewTransform;\n#endif\n#ifdef USE_INVERSEMODELVIEWTRANSFORM\n    float4x4 inverseModelViewTransform;\n#endif\n#ifdef USE_NORMALTRANSFORM\n    float4x4 normalTransform;\n#endif\n#ifdef USE_MODELVIEWPROJECTIONTRANSFORM\n    float4x4 modelViewProjectionTransform;\n#endif\n#ifdef USE_INVERSEMODELVIEWPROJECTIONTRANSFORM\n    float4x4 inverseModelViewProjectionTransform;\n#endif\n#ifdef USE_LASTFRAMETRANSFORM\n    float4x4 lastFrameModelTransform;\n#endif\n#ifdef USE_MOTIONBLUR\n    float motionBlurIntensity;\n#endif\n#ifdef USE_BOUNDINGBOX\n    float2x3 boundingBox;\n#endif\n#ifdef USE_WORLDBOUNDINGBOX\n    float2x3 worldBoundingBox;\n#endif\n#ifdef USE_NODE_OPACITY\n    float nodeOpacity;\n#endif\n#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)\n    sh2_coefficients shCoefficients;\n#elif defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 3)\n    sh3_coefficients shCoefficients;\n#endif\n#ifdef USE_CLUSTERED_LIGHTING\n    uint8_t categoryBitmask;\n#endif\n} commonprofile_node;\n\ntypedef struct {\n    float3 position         [[attribute(VFXVertexSemanticPosition)]];\n#ifdef HAS_NORMAL\n    float3 normal           [[attribute(VFXVertexSemanticNormal)]];\n#endif\n#ifdef USE_TANGENT\n    float4 tangent          [[attribute(VFXVertexSemanticTangent)]];\n#endif\n#ifdef USE_VERTEX_COLOR\n    float4 color            [[attribute(VFXVertexSemanticColor)]];\n#endif\n#if defined(NEED_IN_TEXCOORD0) || defined(DEBUG_PIXEL)\n    float2 texcoord0        [[attribute(VFXVertexSemanticTexcoord0)]];\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    float2 texcoord1        [[attribute(VFXVertexSemanticTexcoord1)]];\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    float2 texcoord2        [[attribute(VFXVertexSemanticTexcoord2)]];\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    float2 texcoord3        [[attribute(VFXVertexSemanticTexcoord3)]];\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    float2 texcoord4        [[attribute(VFXVertexSemanticTexcoord4)]];\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    float2 texcoord5        [[attribute(VFXVertexSemanticTexcoord5)]];\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    float2 texcoord6        [[attribute(VFXVertexSemanticTexcoord6)]];\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    float2 texcoord7        [[attribute(VFXVertexSemanticTexcoord7)]];\n#endif\n} vfx_vertex_t; \n\ntypedef struct {\n    float4 fragmentPosition [[position]]; \n#ifdef USE_POINT_RENDERING\n    float fragmentSize [[point_size]];\n#endif\n#ifdef USE_VERTEX_COLOR\n    float4 vertexColor;\n#endif\n#ifdef USE_PER_VERTEX_LIGHTING\n    float3 diffuse;\n#ifdef USE_SPECULAR\n    float3 specular;\n#endif\n#ifdef USE_CLEARCOAT\n    float clearCoat;\n#endif\n#ifdef USE_CLEARCOATROUGHNESS\n    float clearCoatRoughness;\n#endif\n#ifdef USE_CLEARCOATNORMAL\n    float clearCoatNormal;\n#endif\n#endif\n#if defined(USE_POSITION) && (USE_POSITION == 2)\n    float3 position;\n#endif\n#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)\n    float3 normal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    float3 tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    float3 bitangent;\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n    float2 displacementTexcoord;   \n#endif\n#ifdef USE_CLEARCOAT_MAP\n    float2 clearCoatTexcoord;   \n#endif\n#ifdef USE_CLEARCOATROUGHNESS_MAP\n    float2 clearCoatRoughnessTexcoord;   \n#endif\n#ifdef USE_CLEARCOATNORMAL_MAP\n    float2 clearCoatNormalTexcoord;   \n#endif\n#ifdef USE_NODE_OPACITY\n    float nodeOpacity;\n#endif\n#ifdef USE_TEXCOORD\n    __TexcoordDecl__\n#endif\n    \n#ifdef USE_EXTRA_VARYINGS\n    __ExtraVaryingsDecl__\n#endif\n#ifdef USE_LASTFRAMETRANSFORM\n    float3 mv_lastFragment;\n    float3 mv_fragment;\n#endif\n#ifdef USE_OUTLINE\n    float outlineHash [[ flat ]];\n#endif\n#ifdef USE_INSTANCING\n    uint   instanceID [[ flat ]];\n#endif\n#ifndef USE_VERTEX_AMPLIFICATION \n#ifdef USE_LAYERED_RENDERING\n    uint   sliceIndex [[render_target_array_index]];\n#endif\n#ifdef USE_MULTIPLE_VIEWPORTS_RENDERING\n    uint   sliceIndex [[viewport_array_index]];\n#endif\n#endif\n#if DEBUG_PIXEL\n    float2 uv0;\n#endif\n} commonprofile_io;\n\n\n#ifdef USE_SHADER_MODIFIERS\n__ShaderModifiersDecl__\n#endif\n\n\n#import \"CFX-Lighting.metal\"\n\nenum CFXColorMask {\n    kCFXColorMaskRed    = 0x1 << 3,\n    kCFXColorMaskGreen  = 0x1 << 2,\n    kCFXColorMaskBlue   = 0x1 << 1,\n    kCFXColorMaskAlpha  = 0x1 << 0\n};\n\ninline float4 colorFromMask(float4 col, int mask)\n{\n    switch (mask) {\n\n        case kCFXColorMaskRed:                      return col.r;\n        case kCFXColorMaskRed|kCFXColorMaskGreen:   return float4(col.rg, 0.f, 1.f);\n        case kCFXColorMaskRed|kCFXColorMaskBlue:    return float4(col.rb, 0.f, 1.f);\n        case kCFXColorMaskRed|kCFXColorMaskAlpha:   return float4(col.ra, 0.f, 1.f);\n\n        case kCFXColorMaskGreen:                    return col.g;\n        case kCFXColorMaskGreen|kCFXColorMaskBlue:  return float4(col.bg, 0.f, 1.f);\n        case kCFXColorMaskGreen|kCFXColorMaskAlpha: return float4(col.ag, 0.f, 1.f);\n\n        case kCFXColorMaskBlue:     return col.b;\n        case kCFXColorMaskBlue|kCFXColorMaskAlpha:  return float4(col.ab, 0.f, 1.f);\n\n        case kCFXColorMaskAlpha:    return col.a;\n    }\n    return col;\n}\n\n#ifndef USE_PBR\n\ninline float3 illuminate(VFXShaderSurface surface, VFXShaderLightingContribution lighting)\n{\n    float3 albedo = surface.diffuse.rgb * surface.ambientOcclusion;\n    float3 color = lighting.diffuse * albedo;\n#if defined(USE_AMBIENT_LIGHTING)\n    color +=  lighting.ambient * albedo;\n#endif\n#ifdef USE_SELFILLUMINATION\n    color += surface.diffuse.rgb * surface.selfIllumination.rgb;\n#endif\n    \n    \n    \n#ifdef USE_SPECULAR\n    float3 S = lighting.specular;\n#elif defined(USE_REFLECTIVE)\n    float3 S = float3(0.);\n#endif\n#ifdef USE_REFLECTIVE\n    S += surface.reflective.rgb * surface.ambientOcclusion;\n#endif\n#ifdef USE_SPECULAR\n    S *= surface.specular.rgb;\n#endif\n#if (defined(USE_SPECULAR) || defined(USE_REFLECTIVE)) && !defined(DISABLE_SPECULAR)\n    color += S;\n#endif\n#ifdef USE_EMISSION\n    color += surface.emission.rgb;\n#endif\n#ifdef USE_MULTIPLY\n    color *= surface.multiply.rgb;\n#endif\n#ifdef USE_MODULATE\n    color *= lighting.modulate;\n#endif\n    return color;\n}\n#endif\n\nstruct VFXShaderGeometry\n{\n    float4 position;\n    float3 normal;\n    float4 tangent;\n    float4 color;\n    float pointSize;\n    float2 texcoords[8]; \n#ifdef USE_CLIP_DISTANCE0\n    float clipDistance0;\n#endif\n#ifdef USE_CLIP_DISTANCE1\n    float clipDistance1;\n#endif\n#ifdef USE_CLIP_DISTANCE2\n    float clipDistance2;\n#endif\n#ifdef USE_CLIP_DISTANCE3\n    float clipDistance3;\n#endif\n};\n\nstruct commonprofile_uniforms {\n    \n    float4 diffuseColor;\n    float4 specularColor;\n    float4 ambientOcclusionColor;\n    float4 emissionColor;\n    float4 selfIlluminationColor;\n    float4 reflectiveColor;\n    float4 multiplyColor;\n    float4 transparentColor;\n    float clearCoat;\n    float clearCoatRoughness;\n    float3 clearCoatNormal;\n    float subsurface;\n    float3 subsurfaceRadius;\n    float metalness;\n    \n    float roughness;\n    float diffuseIntensity;\n    float specularIntensity;\n    float normalIntensity;\n    float ambientOcclusionIntensity;\n    float emissionIntensity;\n    float selfIlluminationIntensity;\n    float reflectiveIntensity;\n    float multiplyIntensity;\n    float transparentIntensity;\n    \n    float metalnessIntensity;\n    float roughnessIntensity;\n    float clearCoatIntensity;\n    float clearCoatRoughnessIntensity;\n    float clearCoatNormalIntensity;\n    float subsurfaceIntensity;\n    float subsurfaceRadiusIntensity;\n    float displacementIntensity;\n    float materialShininess;\n    float selfIlluminationOcclusion;\n    float alphaCutoff;\n    float3 fresnel; \n    \n#if USE_ARGUMENT_BUFFERS\n    texture2d<float>    emissionTexture;\n    sampler             emissionSampler;\n    texture2d<float>    ambientOcclusionTexture;\n    sampler             ambientOcclusionSampler;\n    texture2d<float>    diffuseTexture;\n    sampler             diffuseSampler;\n    texture2d<float>    specularTexture;\n    sampler             specularSampler;\n#if defined(USE_REFLECTIVE_CUBEMAP)\n    texturecube<float>  reflectiveTexture;\n#else\n    texture2d<float>    reflectiveTexture;\n#endif\n    sampler             reflectiveSampler;\n    texture2d<float>    transparentTexture;\n    sampler             transparentSampler;\n    texture2d<float>    multiplyTexture;\n    sampler             multiplySampler;\n    texture2d<float>    normalTexture;\n    sampler             normalSampler;\n    texture2d<float>    selfIlluminationTexture;\n    sampler             selfIlluminationSampler;\n    texture2d<float>    metalnessTexture;\n    sampler             metalnessSampler;\n    texture2d<float>    roughnessTexture;\n    sampler             roughnessSampler;\n    texture2d<float>    displacementTexture;\n    sampler             displacementSampler;\n    \n#endif \n#ifdef TEXTURE_TRANSFORM_COUNT\n    float4x4 textureTransforms[TEXTURE_TRANSFORM_COUNT];\n#endif\n};\n\n#ifdef USE_OPENSUBDIV\n\n__OpenSubdivDeclPerGeometry__\n__OpenSubdivDeclPerPatchType__\n__OpenSubdivDeclShared__\n\nstruct osd_packed_vertex {\n    packed_float3 position;\n#if defined(OSD_USER_VARYING_DECLARE_PACKED)\n    OSD_USER_VARYING_DECLARE_PACKED\n#endif\n};\n\n#endif\n\n\n#ifdef USE_DISPLACEMENT_MAP\nstatic void applyDisplacement(texture2d<float>                 displacementTexture,\n                              sampler                          displacementTextureSampler,\n                              float2                           displacementTexcoord,\n                              thread VFXShaderGeometry&        geometry,\n                              constant commonprofile_uniforms& vfx_commonprofile)\n{\n#ifdef USE_DISPLACEMENT_TEXTURE_COMPONENT\n\tfloat altitude = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n#ifdef USE_DISPLACEMENT_INTENSITY\n\taltitude *= vfx_commonprofile.displacementIntensity;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n\tfloat3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));\n\tgeometry.position.xyz += geometry.normal * altitude;\n\t\n\tfloat3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);\n\tfloat3 h;\n\th.x = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\th.y = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\th.z = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord-offset.zy), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\t\n#ifdef USE_DISPLACEMENT_INTENSITY\n\th *= vfx_commonprofile.displacementIntensity;\n#endif\n\t\n\tfloat3 n = normalize( float3( (h.x - h.y)/offset.x, 1., (h.x - h.z)/offset.y) );\n\tgeometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;\n\tgeometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));\n#endif \n#else \n\tfloat3 displacement = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;\n#ifdef USE_DISPLACEMENT_INTENSITY\n\tdisplacement *= vfx_commonprofile.displacementIntensity;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n\tfloat3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));\n\tgeometry.position.xyz += geometry.tangent.xyz * displacement.x + geometry.normal.xyz * displacement.y + bitangent.xyz * displacement.z;\n\t\n\tfloat3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);\n\tfloat3 a = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;\n\tfloat3 b = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz).rgb;\n\tfloat3 c = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.zy).rgb;\n\t\n#ifdef USE_DISPLACEMENT_INTENSITY\n\ta *= vfx_commonprofile.displacementIntensity;\n\tb *= vfx_commonprofile.displacementIntensity;\n\tc *= vfx_commonprofile.displacementIntensity;\n#endif\n\t\n\tb += offset.xzz;\n\tc -= offset.zzy;\n\tfloat3 n = (normalize( cross( b-a, c-a ) ));\n\tgeometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;\n\tgeometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));\n#endif \n#endif \n}\n#endif \n\n#ifdef USE_OUTLINE\nstatic inline float hash(float2 p)\n{\n    const float2 kMod2 = float2(443.8975f, 397.2973f);\n    p  = fract(p * kMod2);\n    p += dot(p.xy, p.yx+19.19f);\n    return fract(p.x * p.y);\n}\n#endif\n    \n\n\n\n\n#if defined(USE_TESSELLATION)\nstruct vfx_patch_t {\n    patch_control_point<vfx_vertex_t> controlPoints;\n};\n#endif\n\n#if defined(USE_OPENSUBDIV)\n#if OSD_IS_ADAPTIVE\n[[ patch(quad, VERTEX_CONTROL_POINTS_PER_PATCH) ]]\n#endif\n#elif defined(USE_TESSELLATION)\n[[ patch(triangle, 3) ]]\n#endif\n    \n    \nvertex commonprofile_io commonprofile_vert(\n#if !defined(USE_TESSELLATION)\n                                           vfx_vertex_t                       in                               [[ stage_in ]]\n                                           , uint                             vfx_vertexID                     [[ vertex_id ]]\n#else \n                                           \n#ifdef USE_OPENSUBDIV\n#if OSD_IS_ADAPTIVE\n#if USE_STAGE_IN\n                                           PatchInput                         patchInput                       [[ stage_in ]]\n#else\n                                           OsdVertexBufferSet                 patchInput\n#endif\n                                           , float2                           patchCoord                       [[ position_in_patch ]]\n                                           , uint                             patchID                          [[ patch_id ]]\n                                           , constant float&                  osdTessellationLevel             [[ buffer(TESSELLATION_LEVEL_BUFFER_INDEX) ]]\n#else \n                                           constant unsigned*                 osdIndicesBuffer                 [[ buffer(INDICES_BUFFER_INDEX) ]]\n                                           , constant osd_packed_vertex*      osdVertexBuffer                  [[ buffer(VERTEX_BUFFER_INDEX) ]]\n                                           , uint                             vertexID                         [[ vertex_id ]]\n#endif \n#if defined(OSD_FVAR_WIDTH)\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n                                           , constant uint32_t&               osdFaceVaryingChannelCount       [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_COUNT_INDEX) ]]\n                                           , constant OsdFVarChannelDesc*     osdFaceVaryingChannelDescriptors [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_DESCRIPTORS_INDEX) ]]\n                                           , constant uint32_t&               osdFaceVaryingPatchArrayIndex    [[ buffer(OSD_FVAR_CHANNELS_PATCH_ARRAY_INDEX_BUFFER_INDEX) ]]\n                                           , constant void*                   osdFaceVaryingChannelsPackedData [[ buffer(OSD_FVAR_CHANNELS_PACKED_DATA_BUFFER_INDEX) ]]\n#else\n                                           , constant float*                  osdFaceVaryingData               [[ buffer(OSD_FVAR_DATA_BUFFER_INDEX) ]]\n                                           , constant int*                    osdFaceVaryingIndices            [[ buffer(OSD_FVAR_INDICES_BUFFER_INDEX) ]]\n#if OSD_IS_ADAPTIVE\n                                           , constant packed_int3*            osdFaceVaryingPatchParams        [[ buffer(OSD_FVAR_PATCHPARAM_BUFFER_INDEX) ]]\n                                           , constant packed_int4&            osdFaceVaryingPatchArray         [[ buffer(OSD_FVAR_PATCH_ARRAY_BUFFER_INDEX) ]]\n#endif\n#endif \n#endif \n#else \n                                           vfx_patch_t                        in                               [[ stage_in ]]\n                                           , float3                           patchCoord                       [[ position_in_patch ]]\n#endif \n#endif \n                                           \n#ifdef USE_MULTIPLE_RENDERING\n                                           , constant VFXWorldBuffer*         vfx_frame_multi                  [[ buffer(0) ]]\n#else\n                                           , constant VFXWorldBuffer&         vfx_frame                        [[ buffer(0) ]]\n#endif\n#if defined(USE_INSTANCING) || defined(USE_MULTIPLE_RENDERING)\n                                           , constant commonprofile_node*     vfx_nodes                        [[ buffer(1) ]]\n#else\n                                           , constant commonprofile_node&     vfx_node                         [[ buffer(1) ]]\n#endif\n#ifdef USE_PER_VERTEX_LIGHTING\n                                           , constant vfx_light*              vfx_lights                       [[ buffer(2) ]]\n                                           , constant float4*                 u_shadowKernel\n                                           , texture2d_array<float>           u_areaLightBakedDataTexture\n#endif\n                                           \n                                           , constant commonprofile_uniforms& vfx_commonprofile\n#ifdef USE_INSTANCING\n                                           , uint                             vfx_instanceID                   [[ instance_id ]]\n#endif\n#ifdef USE_VERTEX_AMPLIFICATION\n                                           , ushort                           amplificationID                  [[ amplification_id ]]\n#endif\n\n#ifdef USE_POINT_RENDERING\n                                           \n                                           , constant float3&                 vfx_pointSize\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n#if USE_ARGUMENT_BUFFERS\n#define u_displacementTexture           vfx_commonprofile.displacementTexture\n#define u_displacementTextureSampler    vfx_commonprofile.displacementSampler\n#else\n                                           , texture2d<float>                 u_displacementTexture\n                                           , sampler                          u_displacementTextureSampler\n#endif \n#endif \n#ifdef USE_VERTEX_EXTRA_ARGUMENTS\n                                           __VertexExtraArguments__\n#endif\n                                           )\n{\n    commonprofile_io out;\n    \n#ifdef USE_MULTIPLE_RENDERING\n\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant VFXWorldBuffer& vfx_frame = vfx_frame_multi[amplificationID];\n#else\n    out.instanceID = vfx_instanceID / USE_MULTIPLE_RENDERING;\n    out.sliceIndex = vfx_instanceID % USE_MULTIPLE_RENDERING;\n    constant VFXWorldBuffer& vfx_frame = vfx_frame_multi[out.sliceIndex];\n#endif\n    \n#ifdef USE_INSTANCING\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& vfx_node = vfx_nodes[USE_MULTIPLE_RENDERING * vfx_instanceID + amplificationID];\n#else\n    \n    \n    constant commonprofile_node& vfx_node = vfx_nodes[vfx_instanceID];\n#endif\n#else\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& vfx_node = vfx_nodes[amplificationID];\n#else\n    constant commonprofile_node& vfx_node = vfx_nodes[out.sliceIndex];\n#endif\n#endif\n    \n#else \n    \n#ifdef USE_INSTANCING\n    out.instanceID = vfx_instanceID;\n    constant commonprofile_node& vfx_node = vfx_nodes[vfx_instanceID];\n#endif\n    \n#endif \n    \n    \n#ifdef USE_TESSELLATION\n    uint vfx_vertexID; \n    vfx_vertexID = 0;\n#endif\n    \n    \n    \n    \n    \n    VFXShaderGeometry _geometry;\n    \n#if !defined(USE_TESSELLATION)\n    \n    \n    _geometry.position = float4(in.position, 1.f);\n#if defined(USE_NORMAL) && defined(HAS_NORMAL)\n    _geometry.normal = in.normal;\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = in.tangent;\n#endif\n#if defined(NEED_IN_TEXCOORD0) || defined(DEBUG_PIXEL)\n    _geometry.texcoords[0] = in.texcoord0;\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    _geometry.texcoords[1] = in.texcoord1;\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    _geometry.texcoords[2] = in.texcoord2;\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    _geometry.texcoords[3] = in.texcoord3;\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    _geometry.texcoords[4] = in.texcoord4;\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    _geometry.texcoords[5] = in.texcoord5;\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    _geometry.texcoords[6] = in.texcoord6;\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    _geometry.texcoords[7] = in.texcoord7;\n#endif\n#ifdef HAS_VERTEX_COLOR\n    _geometry.color = in.color;\n#elif USE_VERTEX_COLOR\n    _geometry.color = float4(1.);\n#endif\n    \n#else \n    \n#ifdef USE_OPENSUBDIV\n#if OSD_IS_ADAPTIVE\n#if USE_STAGE_IN\n    int3 patchParam = patchInput.patchParam;\n#else\n    int3 patchParam = patchInput.patchParamBuffer[patchID];\n#endif\n    \n    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);\n    float tessellationLevel = min(osdTessellationLevel, (float)OSD_MAX_TESS_LEVEL) / exp2((float)refinementLevel - 1);\n    \n    OsdPatchVertex patchVertex = OsdComputePatch(tessellationLevel, patchCoord, patchID, patchInput);\n    \n#if defined(OSD_FVAR_WIDTH)\n    int patchIndex = OsdGetPatchIndex(patchID);\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);\n#else\n    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingIndices, osdFaceVaryingData, osdFaceVaryingPatchParams, osdFaceVaryingPatchArray);\n#endif\n#endif\n    \n    _geometry.position = float4(patchVertex.position, 1.f);\n    \n#if defined(USE_NORMAL)\n    _geometry.normal = patchVertex.normal;\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = float4(patchVertex.tangent, -1.f);\n    \n#endif\n#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[0] = patchVertex.texcoord0;\n#endif\n#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[1] = patchVertex.texcoord1;\n#endif\n#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[2] = patchVertex.texcoord2;\n#endif\n#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[3] = patchVertex.texcoord3;\n#endif\n#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[4] = patchVertex.texcoord4;\n#endif\n#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[5] = patchVertex.texcoord5;\n#endif\n#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[6] = patchVertex.texcoord6;\n#endif\n#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[7] = patchVertex.texcoord7;\n#endif\n#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.color = patchVertex.color;\n#endif\n    \n#else \n    \n#if OSD_PATCH_QUADS\n    const uint primitiveIndex = vertexID / 6;\n#ifdef USE_NORMAL\n    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 0]].position;\n    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 1]].position;\n    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 2]].position;\n    float3 normal = normalize(cross(p2 - p1, p0 - p1));\n#endif\n    const uint triangleIndices[6] = { 0, 1, 2, 0, 2, 3 };\n    const uint quadVertexIndex = triangleIndices[vertexID % 6];\n    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + quadVertexIndex]];\n#elif OSD_PATCH_TRIANGLES\n    const uint primitiveIndex = vertexID / 3;\n#ifdef USE_NORMAL\n    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 0]].position;\n    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 1]].position;\n    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 2]].position;\n    float3 normal = normalize(cross(p2 - p1, p0 - p1));\n#endif\n    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[vertexID]];\n#endif\n    \n    float3 position = osdVertex.position;\n    \n#if defined(OSD_FVAR_WIDTH)\n    int patchIndex = OsdGetPatchIndex(primitiveIndex);\n#if OSD_PATCH_QUADS\n    float2 quadUVs[4] = { float2(0,0), float2(1,0), float2(1,1), float2(0,1) };\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);\n#else\n    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingIndices, osdFaceVaryingData);\n#endif\n#elif OSD_PATCH_TRIANGLES\n    \n#endif\n#endif \n    \n#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[0] = osdVertex.texcoord0;\n#endif\n#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[1] = osdVertex.texcoord1;\n#endif\n#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[2] = osdVertex.texcoord2;\n#endif\n#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[3] = osdVertex.texcoord3;\n#endif\n#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[4] = osdVertex.texcoord4;\n#endif\n#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[5] = osdVertex.texcoord5;\n#endif\n#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[6] = osdVertex.texcoord6;\n#endif\n#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[7] = osdVertex.texcoord7;\n#endif\n#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.color = osdVertex.color;\n#endif\n    \n    _geometry.position = float4(position, 1.f);\n#ifdef USE_NORMAL\n    _geometry.normal = normal;\n#endif\n    \n#endif \n    \n#else \n    \n    \n    \n    \n    \n#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE) || defined(TESSELLATION_SMOOTHING_MODE_PHONG)\n    float3 P0 = in.controlPoints[0].position;\n    float3 P1 = in.controlPoints[1].position;\n    float3 P2 = in.controlPoints[2].position;\n    float3 N0 = in.controlPoints[0].normal;\n    float3 N1 = in.controlPoints[1].normal;\n    float3 N2 = in.controlPoints[2].normal;\n#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE)\n    float3 position, normal;\n    vfx_smooth_geometry_pn_triangle(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);\n#elif defined(TESSELLATION_SMOOTHING_MODE_PHONG)\n    float3 position, normal;\n    vfx_smooth_geometry_phong(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);\n#endif\n    _geometry.position = float4(position, 1.f);\n#ifdef USE_NORMAL\n    _geometry.normal = normal;\n#endif\n#else \n    \n    _geometry.position = float4(vfx::barycentric_mix(in.controlPoints[0].position, in.controlPoints[1].position, in.controlPoints[2].position, patchCoord), 1.f);\n#if defined(USE_NORMAL) && defined(HAS_NORMAL)\n    _geometry.normal = normalize(vfx::barycentric_mix(in.controlPoints[0].normal, in.controlPoints[1].normal, in.controlPoints[2].normal, patchCoord));\n#endif\n#endif \n    \n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = normalize(vfx::barycentric_mix(in.controlPoints[0].tangent, in.controlPoints[1].tangent, in.controlPoints[2].tangent, patchCoord));\n#endif\n#ifdef NEED_IN_TEXCOORD0\n    _geometry.texcoords[0] = vfx::barycentric_mix(in.controlPoints[0].texcoord0, in.controlPoints[1].texcoord0, in.controlPoints[2].texcoord0, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    _geometry.texcoords[1] = vfx::barycentric_mix(in.controlPoints[0].texcoord1, in.controlPoints[1].texcoord1, in.controlPoints[2].texcoord1, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    _geometry.texcoords[2] = vfx::barycentric_mix(in.controlPoints[0].texcoord2, in.controlPoints[1].texcoord2, in.controlPoints[2].texcoord2, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    _geometry.texcoords[3] = vfx::barycentric_mix(in.controlPoints[0].texcoord3, in.controlPoints[1].texcoord3, in.controlPoints[2].texcoord3, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    _geometry.texcoords[4] = vfx::barycentric_mix(in.controlPoints[0].texcoord4, in.controlPoints[1].texcoord4, in.controlPoints[2].texcoord4, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    _geometry.texcoords[5] = vfx::barycentric_mix(in.controlPoints[0].texcoord5, in.controlPoints[1].texcoord5, in.controlPoints[2].texcoord5, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    _geometry.texcoords[6] = vfx::barycentric_mix(in.controlPoints[0].texcoord6, in.controlPoints[1].texcoord6, in.controlPoints[2].texcoord6, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    _geometry.texcoords[7] = vfx::barycentric_mix(in.controlPoints[0].texcoord7, in.controlPoints[1].texcoord7, in.controlPoints[2].texcoord7, patchCoord);\n#endif\n#ifdef HAS_VERTEX_COLOR\n    _geometry.color = vfx::barycentric_mix(in.controlPoints[0].color, in.controlPoints[1].color, in.controlPoints[2].color, patchCoord);\n#elif USE_VERTEX_COLOR\n    _geometry.color = float4(1.);\n#endif\n    \n#endif \n    \n#endif \n    \n#ifdef USE_POINT_RENDERING\n    _geometry.pointSize = vfx_pointSize.x;\n#endif\n    \n#ifdef USE_TEXCOORD\n    __VertexDoVertexOnlyTexcoord__\n#endif\n    \n#ifdef USE_DISPLACEMENT_MAP\n    applyDisplacement(u_displacementTexture, u_displacementTextureSampler, _displacementTexcoord, _geometry, vfx_commonprofile);\n    out.displacementTexcoord = _displacementTexcoord;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_GEOMETRY_MODIFIER\n    \n    __DoGeometryModifier__\n    \n#endif\n    \n#ifdef USE_CLIP_DISTANCE0\n    out.clipDistance[0] = _geometry.clipDistance0;\n#endif\n#ifdef USE_CLIP_DISTANCE1\n    out.clipDistance[1] = _geometry.clipDistance1;\n#endif\n#ifdef USE_CLIP_DISTANCE2\n    out.clipDistance[2] = _geometry.clipDistance2;\n#endif\n#ifdef USE_CLIP_DISTANCE3\n    out.clipDistance[3] = _geometry.clipDistance3;\n#endif\n    \n    \n    \n    \n    \n    \n#if defined(USE_POSITION) || (defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)) || defined(USE_TANGENT) || defined(USE_BITANGENT) || defined(USE_INSTANCING)\n    VFXShaderSurface _surface;\n#endif\n#if defined(USE_POSITION) || defined(USE_INSTANCING)\n    _surface.position = (vfx_node.modelViewTransform * _geometry.position).xyz;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n#ifdef HINT_UNIFORM_SCALE\n    float3x3 nrmTransform = vfx::mat3(vfx_node.modelViewTransform);\n    _surface.normal = nrmTransform * _geometry.normal;\n#else\n    float3x3 modelViewTransform = vfx::mat3(vfx_node.modelViewTransform);\n    float3 invScaleSquared = 1.f / float3(length_squared(modelViewTransform[0]),\n                                          length_squared(modelViewTransform[1]),\n                                          length_squared(modelViewTransform[2]));\n    _surface.normal = normalize(modelViewTransform * (_geometry.normal * invScaleSquared));\n#endif\n#ifdef USE_GBUFFER_OUTPUT\n    _surface.normal = vfx::mat3(vfx_node.modelTransform) * _geometry.normal;\n#endif\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _surface.tangent = normalize(vfx::mat3(vfx_node.modelViewTransform) * _geometry.tangent.xyz);\n    _surface.bitangent = _geometry.tangent.w * cross(_surface.tangent, _surface.normal); \n    \n#endif\n    \n    \n#ifdef USE_VIEW\n    _surface.view = normalize(-_surface.position);\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_PER_VERTEX_LIGHTING\n    \n    VFXShaderLightingContribution _lightingContribution(_surface, out);\n    _lightingContribution.diffuse = 0.;\n  #ifdef USE_SPECULAR\n    _lightingContribution.specular = 0.;\n    _surface.shininess = vfx_commonprofile.materialShininess;\n  #endif\n    \n    __VertexDoLighting__\n    \n    out.diffuse = _lightingContribution.diffuse;\n  #ifdef USE_SPECULAR\n    out.specular = _lightingContribution.specular;\n  #endif\n#endif\n#if defined(USE_POSITION) && (USE_POSITION == 2)\n    out.position = _surface.position;\n#endif\n#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)\n    out.normal = _surface.normal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    out.tangent = _surface.tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    out.bitangent = _surface.bitangent;\n#endif\n#ifdef USE_VERTEX_COLOR\n    out.vertexColor = _geometry.color;\n#endif\n    \n#if DEBUG_PIXEL\n    out.uv0 = _geometry.texcoords[0];\n#endif\n\n#ifdef USE_TEXCOORD\n    __VertexDoTexcoord__\n#endif\n    \n    \n    \n    \n    \n#if defined(USE_POSITION) || defined(USE_INSTANCING)\n    out.fragmentPosition = vfx_frame.projectionTransform * float4(_surface.position, 1.);\n#elif defined(USE_MODELVIEWPROJECTIONTRANSFORM) \n    out.fragmentPosition = vfx_node.modelViewProjectionTransform * _geometry.position;\n#endif\n    \n#ifdef USE_NODE_OPACITY\n    out.nodeOpacity = vfx_node.nodeOpacity;\n#endif\n    \n#ifdef USE_POINT_RENDERING\n    float screenSize = _geometry.pointSize / out.fragmentPosition.w;\n    out.fragmentSize = clamp(screenSize, vfx_pointSize.y, vfx_pointSize.z);\n#endif\n    \n#ifdef USE_LASTFRAMETRANSFORM\n    float4 lastFrameFragmentPosition = vfx_frame.lastFrameViewProjectionTransform * vfx_node.lastFrameModelTransform * _geometry.position;\n    out.mv_fragment = out.fragmentPosition.xyw;\n    out.mv_lastFragment = lastFrameFragmentPosition.xyw;\n#endif\n    \n#ifdef USE_OUTLINE\n\tout.outlineHash = hash(vfx_node.modelTransform[3].xy)+1.f/255.f;\n#endif\n    \n    return out;\n}\n\n\n\n\n\nstruct VFXOutput\n{\n    float4 color [[ color(0) ]];\n#ifdef USE_COLOR1_OUTPUT\n    half4 color1 [[ color(1) ]];\n#endif\n#ifdef USE_NORMALS_OUTPUT\n    half4 normals [[ color(2) ]];\n#endif\n#if defined(USE_MOTIONBLUR) && !defined(USE_GBUFFER_OUTPUT)\n    half4 motionblur [[ color(3) ]];\n#endif\n#ifdef USE_REFLECTANCE_ROUGHNESS_OUTPUT\n    half4 reflectanceRoughnessOutput [[ color(4) ]];\n#endif\n#ifdef USE_RADIANCE_OUTPUT\n    half4 radiance [[ color(5) ]];\n#endif\n#ifdef USE_GBUFFER_OUTPUT\n    float4 albedo [[ color(VFXGBufferAttachmentAlbedo) ]];\n    float4 normals [[ color(VFXGBufferAttachmentNormal) ]];\n    float4 roughmetal [[ color(VFXGBufferAttachmentRoughnessMetalness) ]];\n    \n#ifdef USE_MOTIONBLUR\n    float4 velocity [[ color(VFXGBufferAttachmentVelocity) ]];\n#else\n    float2 velocity [[ color(VFXGBufferAttachmentVelocity) ]];\n#endif\n    float4 clearCoat [[ color(VFXGBufferAttachmentClearCoat) ]];\n    float4 subsurface [[ color(VFXGBufferAttachmentSubsurface) ]];\n#endif\n};\n    \n#ifdef USE_MODIFIER_FRAMEBUFFER\nstruct VFXFramebuffer\n{\n    float4 color;\n};\n#endif\n\nfragment VFXOutput commonprofile_frag(commonprofile_io                   in                          [[ stage_in  ]]\n                                      , constant commonprofile_uniforms& vfx_commonprofile           [[ buffer(0) ]]\n#ifdef USE_MULTIPLE_RENDERING\n                                      , constant VFXWorldBuffer*         vfx_frame_multi             [[ buffer(1) ]]\n#else\n                                      , constant VFXWorldBuffer&         vfx_frame                   [[ buffer(1) ]]\n#endif\n#if defined(USE_INSTANCING) || defined(USE_MULTIPLE_RENDERING)\n                                      , constant commonprofile_node*     vfx_nodes                   [[ buffer(2) ]]\n#else\n                                      , constant commonprofile_node&     vfx_node                    [[ buffer(2) ]]\n#endif\n#ifdef USE_PER_PIXEL_LIGHTING\n                                      , constant vfx_light*              vfx_lights                  [[ buffer(3) ]]\n                                      , constant float4*                 u_shadowKernel\n                                      , texture2d_array<float>           u_areaLightBakedDataTexture\n#ifdef CFX_SUPPORT_CUBE_ARRAY\n                                      , texturecube_array<half>          u_reflectionProbeTexture\n#else\n                                      , texture2d_array<half>            u_reflectionProbeTexture\n#endif\n                                      , texture3d<ushort>                u_clusterTexture\n#ifdef CFX_USE_TEXTURE_FOR_LIGHT_INDICES\n                                      , texture1d<ushort>                u_lightIndicesTexture\n#else\n                                      , constant CFXLightIndexType*      u_lightIndicesBuffer\n#endif\n#endif\n#if defined(CFX_SUPPORTS_PROGRAMMABLE_BLENDING) && defined(USE_MODIFIER_FRAMEBUFFER_COLOR0)\n                                      , float4                           framebufferColor0           [[ color(0) ]]\n#endif\n#if USE_ARGUMENT_BUFFERS\n\n#define u_emissionTexture               vfx_commonprofile.emissionTexture\n#define u_emissionTextureSampler        vfx_commonprofile.emissionSampler\n#define u_ambientOcclusionTexture       vfx_commonprofile.ambientOcclusionTexture\n#define u_ambientOcclusionTextureSampler vfx_commonprofile.ambientOcclusionSampler\n#define u_diffuseTexture                vfx_commonprofile.diffuseTexture\n#define u_diffuseTextureSampler         vfx_commonprofile.diffuseSampler\n#define u_specularTexture               vfx_commonprofile.specularTexture\n#define u_specularTextureSampler        vfx_commonprofile.specularSampler\n#define u_reflectiveTexture             vfx_commonprofile.reflectiveTexture\n#define u_reflectiveTextureSampler      vfx_commonprofile.reflectiveSampler\n#define u_transparentTexture            vfx_commonprofile.transparentTexture\n#define u_transparentTextureSampler     vfx_commonprofile.transparentSampler\n#define u_multiplyTexture               vfx_commonprofile.multiplyTexture\n#define u_multiplyTextureSampler        vfx_commonprofile.multiplySampler\n#define u_normalTexture                 vfx_commonprofile.normalTexture\n#define u_normalTextureSampler          vfx_commonprofile.normalSampler\n#define u_selfIlluminationTexture       vfx_commonprofile.selfIlluminationTexture\n#define u_selfIlluminationTextureSampler vfx_commonprofile.selfIlluminationSampler\n#define u_metalnessTexture              vfx_commonprofile.metalnessTexture\n#define u_metalnessTextureSampler       vfx_commonprofile.metalnessSampler\n#define u_roughnessTexture              vfx_commonprofile.roughnessTexture\n#define u_roughnessTextureSampler       vfx_commonprofile.roughnessSampler\n\n#else\n#ifdef USE_EMISSION_MAP\n                                      , texture2d<float>              u_emissionTexture\n                                      , sampler                       u_emissionTextureSampler\n#endif\n#ifdef USE_AMBIENTOCCLUSION_MAP\n                                      , texture2d<float>              u_ambientOcclusionTexture\n                                      , sampler                       u_ambientOcclusionTextureSampler\n#endif\n#ifdef USE_DIFFUSE_MAP\n                                      , texture2d<float>              u_diffuseTexture\n                                      , sampler                       u_diffuseTextureSampler\n#endif\n#ifdef USE_SPECULAR_MAP\n                                      , texture2d<float>              u_specularTexture\n                                      , sampler                       u_specularTextureSampler\n#endif\n#ifdef USE_REFLECTIVE_MAP\n                                      , texture2d<float>              u_reflectiveTexture\n                                      , sampler                       u_reflectiveTextureSampler\n#elif defined(USE_REFLECTIVE_CUBEMAP)\n                                      , texturecube<float>            u_reflectiveTexture\n                                      , sampler                       u_reflectiveTextureSampler\n#endif\n#ifdef USE_TRANSPARENT_MAP\n                                      , texture2d<float>              u_transparentTexture\n                                      , sampler                       u_transparentTextureSampler\n#endif\n#ifdef USE_MULTIPLY_MAP\n                                      , texture2d<float>              u_multiplyTexture\n                                      , sampler                       u_multiplyTextureSampler\n#endif\n#ifdef USE_NORMAL_MAP\n                                      , texture2d<float>              u_normalTexture\n                                      , sampler                       u_normalTextureSampler\n#endif\n#ifdef USE_SELFILLUMINATION_MAP\n                                      , texture2d<float>              u_selfIlluminationTexture\n                                      , sampler                       u_selfIlluminationTextureSampler\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n                                      , texture2d<float>              u_displacementTexture\n                                      , sampler                       u_displacementTextureSampler\n#endif\n#ifdef USE_PBR\n#ifdef USE_METALNESS_MAP\n                                      , texture2d<float>              u_metalnessTexture\n                                      , sampler                       u_metalnessTextureSampler\n#endif\n#ifdef USE_ROUGHNESS_MAP\n                                      , texture2d<float>              u_roughnessTexture\n                                      , sampler                       u_roughnessTextureSampler\n#endif\n#ifdef USE_CLEARCOAT_MAP\n                                      , texture2d<float>              u_clearCoatTexture\n                                      , sampler                       u_clearCoatTextureSampler\n#endif\n#ifdef USE_CLEARCOATROUGHNESS_MAP\n                                      , texture2d<float>              u_clearCoatRoughnessTexture\n                                      , sampler                       u_clearCoatRoughnessTextureSampler\n#endif\n#ifdef USE_CLEARCOATNORMAL_MAP\n                                      , texture2d<float>              u_clearCoatNormalTexture\n                                      , sampler                       u_clearCoatNormalTextureSampler\n#endif\n#ifdef USE_SUBSURFACE_MAP\n                                      , texture2d<float>              u_subsurfaceTexture\n                                      , sampler                       u_subsurfaceTextureSampler\n#endif\n#ifdef USE_SUBSURFACERADIUS_MAP\n                                      , texture2d<float>              u_subsurfaceRadiusTexture\n                                      , sampler                       u_subsurfaceRadiusTextureSampler\n#endif\n#endif \n#endif \n#ifdef USE_PBR\n                                      , texturecube<float>            u_radianceTexture\n                                      , texture2d<float>              u_specularDFGDiffuseHammonTexture\n#if !defined(USE_SELFILLUMINATION_MAP)\n                                      , texturecube<float>            u_irradianceTexture\n#endif\n#endif \n#ifdef USE_SSAO\n                                      , texture2d<float>              u_ssaoTexture\n#endif\n#ifdef USE_FRAGMENT_EXTRA_ARGUMENTS\n                                      __FragmentExtraArguments__\n#endif\n#if defined(USE_DOUBLE_SIDED)\n                                      , bool                          isFrontFacing                    [[front_facing]]\n#endif\n#ifdef USE_POINT_RENDERING\n                                      , float2                        pointCoord                       [[point_coord]]\n#endif\n#ifdef USE_VERTEX_AMPLIFICATION\n                                      , ushort                        amplificationID                  [[amplification_id]]\n#endif\n#ifdef USE_BARYCENTRIC_COORD\n                                      , float3                        u_barycentricCoord                 [[barycentric_coord]]\n#endif\n                                      )\n{\n#ifdef USE_MULTIPLE_RENDERING\n    \n#ifdef USE_VERTEX_AMPLIFICATION\n    constant VFXWorldBuffer& vfx_frame = vfx_frame_multi[amplificationID];\n#else\n    constant VFXWorldBuffer& vfx_frame = vfx_frame_multi[in.sliceIndex];\n#endif\n    \n#ifdef USE_INSTANCING\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& vfx_node = vfx_nodes[USE_MULTIPLE_RENDERING * in.instanceID + amplificationID];\n#else\n    constant commonprofile_node& vfx_node = vfx_nodes[USE_MULTIPLE_RENDERING * in.instanceID + in.sliceIndex];\n#endif\n#else\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& vfx_node = vfx_nodes[amplificationID];\n#else\n    constant commonprofile_node& vfx_node = vfx_nodes[in.sliceIndex];\n#endif\n#endif\n    \n#else \n    \n#ifdef USE_INSTANCING\n    constant commonprofile_node& vfx_node = vfx_nodes[in.instanceID];\n#endif\n    \n#endif \n    \n    VFXOutput _output;\n\n    \n    \n    \n    \n    VFXShaderSurface _surface;\n#ifdef USE_TEXCOORD\n    __FragmentDoTexcoord__\n#endif\n    _surface.ambientOcclusion = 1.f; \n\n#ifdef USE_AMBIENTOCCLUSION_MAP\n#if defined(USE_AMBIENTOCCLUSION_TEXTURE_COMPONENT)\n    _surface.ambientOcclusion = colorFromMask(u_ambientOcclusionTexture.sample(u_ambientOcclusionTextureSampler, _surface.ambientOcclusionTexcoord), USE_AMBIENTOCCLUSION_TEXTURE_COMPONENT).r;\n#else\n    _surface.ambientOcclusion = u_ambientOcclusionTexture.sample(u_ambientOcclusionTextureSampler, _surface.ambientOcclusionTexcoord).r;\n#endif \n#ifdef USE_AMBIENTOCCLUSION_INTENSITY\n    _surface.ambientOcclusion = saturate(mix(1.f, _surface.ambientOcclusion, vfx_commonprofile.ambientOcclusionIntensity));\n#endif\n#endif\n\n\n#if defined(USE_SSAO)\n    _surface.ambientOcclusion *= u_ssaoTexture.sample( sampler(filter::linear), in.fragmentPosition.xy * vfx_frame.inverseResolution.xy ).x;\n#endif\n    \n#ifdef USE_DIFFUSE_MAP\n    _surface.diffuse = u_diffuseTexture.sample(u_diffuseTextureSampler, _surface.diffuseTexcoord);\n#if defined(USE_DIFFUSE_TEXTURE_COMPONENT)\n    _surface.diffuse = colorFromMask(_surface.diffuse, USE_DIFFUSE_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_DIFFUSE_INTENSITY\n    _surface.diffuse.rgb *= vfx_commonprofile.diffuseIntensity;\n#endif\n#elif defined(USE_DIFFUSE_COLOR)\n    _surface.diffuse = vfx_commonprofile.diffuseColor;\n#else\n    _surface.diffuse = float4(0.f,0.f,0.f,1.f);\n#endif\n#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)\n    _surface.diffuse.rgb    *= in.vertexColor.rgb;\n    _surface.diffuse        *= in.vertexColor.a; \n#endif\n#ifdef USE_SPECULAR_MAP\n    _surface.specular = u_specularTexture.sample(u_specularTextureSampler, _surface.specularTexcoord);\n#if defined(USE_SPECULAR_TEXTURE_COMPONENT)\n    _surface.specular = colorFromMask(_surface.specular, USE_SPECULAR_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_SPECULAR_INTENSITY\n    _surface.specular *= vfx_commonprofile.specularIntensity;\n#endif\n#elif defined(USE_SPECULAR_COLOR)\n    _surface.specular = vfx_commonprofile.specularColor;\n#elif defined(USE_SPECULAR)\n    _surface.specular = float4(0.f);\n#endif\n    \n#ifdef USE_CLEARCOAT_MAP\n    _surface.clearCoat = u_clearCoatTexture.sample(u_clearCoatTextureSampler, _surface.clearCoatTexcoord).r;\n#if defined(USE_CLEARCOAT_TEXTURE_COMPONENT)\n    _surface.clearCoat = colorFromMask(_surface.clearCoat, USE_CLEARCOAT_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_CLEARCOAT_INTENSITY\n    _surface.clearCoat *= vfx_commonprofile.clearCoatIntensity;\n#endif\n#elif defined(USE_CLEARCOAT_COLOR)\n    _surface.clearCoat = vfx_commonprofile.clearCoat;\n#else\n    _surface.clearCoat = 0.f;\n#endif\n    \n#ifdef USE_CLEARCOATROUGHNESS_MAP\n#if defined(USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT)\n    _surface.clearCoatRoughness = colorFromMask(u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord), USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.clearCoatRoughness = u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord).r;\n#endif\n#ifdef USE_CLEARCOATROUGHNESS_INTENSITY\n    _surface.clearCoatRoughness *= vfx_commonprofile.clearCoatRoughnessIntensity;\n#endif\n#elif defined(USE_CLEARCOATROUGHNESS_COLOR)\n    _surface.clearCoatRoughness = vfx_commonprofile.clearCoatRoughness;\n#else\n    _surface.clearCoatRoughness = 0.03f;\n#endif\n    \n    \n#ifdef USE_SUBSURFACE_MAP\n    _surface.subsurface = u_subsurfaceTexture.sample(u_subsurfaceTextureSampler, _surface.subsurfaceTexcoord).r;\n#if defined(USE_SUBSURFACE_TEXTURE_COMPONENT)\n    _surface.subsurface = colorFromMask(_surface.subsurface, USE_SUBSURFACE_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_SUBSURFACE_INTENSITY\n    _surface.subsurface *= vfx_commonprofile.subsurfaceIntensity;\n#endif\n#elif defined(USE_SUBSURFACE_COLOR)\n    _surface.subsurface = vfx_commonprofile.subsurface;\n#else\n    _surface.subsurface = 0.f;\n#endif\n    \n#ifdef USE_SUBSURFACERADIUS_MAP\n    _surface.subsurfaceRadius = u_subsurfaceRadiusTexture.sample(u_subsurfaceRadiusTextureSampler, _surface.subsurfaceRadiusTexcoord).r;\n#if defined(USE_SUBSURFACERADIUS_TEXTURE_COMPONENT)\n    _surface.subsurfaceRadius = colorFromMask(_surface.subsurfaceRadius, USE_SUBSURFACERADIUS_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_SUBSURFACERADIUS_INTENSITY\n    _surface.subsurfaceRadius *= vfx_commonprofile.subsurfaceRadiusIntensity;\n#endif\n#elif defined(USE_SUBSURFACERADIUS_COLOR)\n    _surface.subsurfaceRadius = vfx_commonprofile.subsurfaceRadius;\n#else\n    _surface.subsurfaceRadius = float3(0.f);\n#endif\n    \n#ifdef USE_EMISSION_MAP\n    _surface.emission = u_emissionTexture.sample(u_emissionTextureSampler, _surface.emissionTexcoord);\n#if defined(USE_EMISSION_TEXTURE_COMPONENT)\n    _surface.emission = colorFromMask(_surface.emission, USE_EMISSION_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_EMISSION_INTENSITY\n    _surface.emission *= vfx_commonprofile.emissionIntensity;\n#endif\n#elif defined(USE_EMISSION_COLOR)\n    _surface.emission = vfx_commonprofile.emissionColor;\n#elif defined(USE_EMISSION)\n    _surface.emission = float4(0.);\n#endif\n#ifdef USE_SELFILLUMINATION_MAP\n    _surface.selfIllumination = u_selfIlluminationTexture.sample(u_selfIlluminationTextureSampler, _surface.selfIlluminationTexcoord);\n#if defined(USE_SELFILLUMINATION_TEXTURE_COMPONENT)\n    _surface.selfIllumination = colorFromMask(_surface.selfIllumination, USE_SELFILLUMINATION_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_SELFILLUMINATION_INTENSITY\n    _surface.selfIllumination *= vfx_commonprofile.selfIlluminationIntensity;\n#endif\n#elif defined(USE_SELFILLUMINATION_COLOR)\n    _surface.selfIllumination = vfx_commonprofile.selfIlluminationColor;\n#elif defined(USE_SELFILLUMINATION)\n    _surface.selfIllumination = float4(0.);\n#endif\n#ifdef USE_MULTIPLY_MAP\n    _surface.multiply = u_multiplyTexture.sample(u_multiplyTextureSampler, _surface.multiplyTexcoord);\n#if defined(USE_MULTIPLY_TEXTURE_COMPONENT)\n    _surface.multiply = colorFromMask(_surface.multiply, USE_MULTIPLY_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_MULTIPLY_INTENSITY\n    _surface.multiply = mix(float4(1.), _surface.multiply, vfx_commonprofile.multiplyIntensity);\n#endif\n#elif defined(USE_MULTIPLY_COLOR)\n    _surface.multiply = vfx_commonprofile.multiplyColor;\n#elif defined(USE_MULTIPLY)\n    _surface.multiply = float4(1.);\n#endif\n#ifdef USE_TRANSPARENT_MAP\n    _surface.transparent = u_transparentTexture.sample(u_transparentTextureSampler, _surface.transparentTexcoord);\n#if defined(USE_TRANSPARENT_TEXTURE_COMPONENT)\n    _surface.transparent = colorFromMask(_surface.transparent, USE_TRANSPARENT_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_TRANSPARENT_INTENSITY\n    _surface.transparent *= vfx_commonprofile.transparentIntensity;\n#endif\n#elif defined(USE_TRANSPARENT_COLOR)\n    _surface.transparent = vfx_commonprofile.transparentColor;\n#elif defined(USE_TRANSPARENT)\n    _surface.transparent = float4(1.f);\n#endif\n    \n#ifdef USE_METALNESS_MAP\n#if defined(USE_METALNESS_TEXTURE_COMPONENT)\n    _surface.metalness = colorFromMask(u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord), USE_METALNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.metalness = u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord).r;\n#endif\n#ifdef USE_METALNESS_INTENSITY\n    _surface.metalness *= vfx_commonprofile.metalnessIntensity;\n#endif\n#elif defined(USE_METALNESS_COLOR)\n    _surface.metalness = vfx_commonprofile.metalness;\n#else\n    _surface.metalness = 0.f;\n#endif\n    \n#ifdef USE_ROUGHNESS_MAP\n#if defined(USE_ROUGHNESS_TEXTURE_COMPONENT)\n    _surface.roughness = colorFromMask(u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord), USE_ROUGHNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.roughness = u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord).r;\n#endif\n#ifdef USE_ROUGHNESS_INTENSITY\n    _surface.roughness *= vfx_commonprofile.roughnessIntensity;\n#endif\n#elif defined(USE_ROUGHNESS_COLOR)\n    _surface.roughness = vfx_commonprofile.roughness;\n#else\n    _surface.roughness = 0.f;\n#endif\n#if (defined USE_POSITION) && (USE_POSITION == 2)\n    _surface.position = in.position;\n#endif\n#if (defined USE_NORMAL) && (USE_NORMAL == 2)\n#if defined(HAS_NORMAL) || defined(USE_OPENSUBDIV)\n#ifdef USE_DOUBLE_SIDED\n    _surface.geometryNormal = normalize(in.normal.xyz) * (isFrontFacing ? 1.f : -1.f );\n#else\n    _surface.geometryNormal = normalize(in.normal.xyz);\n#endif\n#else \n    _surface.geometryNormal = normalize( cross(dfdy( _surface.position ), dfdx( _surface.position ) ));\n#endif\n    _surface.normal = _surface.geometryNormal;\n    _surface.clearCoatNormal = _surface.geometryNormal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    _surface.tangent = in.tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    _surface.bitangent = in.bitangent;\n#endif\n#if (defined USE_VIEW) && (USE_VIEW == 2)\n    _surface.view = normalize(-in.position);\n    {\n        \n        \n        float NoV = dot(_surface.geometryNormal, _surface.view);\n        _surface.view = _surface.view + max(0.f, -2.f * NoV) * _surface.geometryNormal;         \n        \n    }\n#endif\n#if defined(USE_NORMAL_MAP)\n    {\n        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.normal);\n#ifdef USE_NORMAL_MAP\n#if defined(USE_NORMAL_TEXTURE_COMPONENT)\n        _surface._normalTS.xy = colorFromMask(u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord), USE_NORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;\n        _surface._normalTS.z = sqrt(1.f - saturate(length_squared(_surface._normalTS.xy)));\n#else\n        _surface._normalTS = u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord).rgb;\n        _surface._normalTS = _surface._normalTS * 2.f - 1.f;\n#endif\n#ifdef USE_NORMAL_INTENSITY\n        _surface._normalTS = normalize(mix(float3(0.f, 0.f, 1.f), _surface._normalTS, vfx_commonprofile.normalIntensity));\n#endif\n#else\n        _surface._normalTS = float3(0.f, 0.f, 1.f);\n#endif\n        _surface.normal.rgb = normalize(ts2vs * _surface._normalTS.xyz );\n    }\n#else\n    _surface._normalTS = float3(0.f, 0.f, 1.f);\n#endif\n#if defined(USE_PBR) && !defined(USE_GBUFFER_OUTPUT)\n    {\n        float roughness = clamp(_surface.roughness, PBR_MIN_ROUGHNESS, 1.0);\n        float alpha = vfx_filteredAlphaFromRoughness(_surface.normal, roughness);\n        _surface.roughness = sqrt(alpha);\n    }\n#endif\n#if defined(USE_CLEARCOATNORMAL_MAP)\n    {\n        \n        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.geometryNormal);\n#ifdef USE_CLEARCOATNORMAL_MAP\n#if defined(USE_CLEARCOATNORMAL_TEXTURE_COMPONENT)\n        _surface._clearCoatNormalTS.xy = colorFromMask(u_clearCoatNormalTexture.sample(u_clearCoatnormalTextureSampler, _surface.clearCoatNormalTexcoord), USE_CLEARCOATNORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;\n        _surface._clearCoatNormalTS.z = sqrt(1.f - saturate(length_squared(_surface._clearCoatNormalTS.xy)));\n#else\n        _surface._clearCoatNormalTS = u_clearCoatNormalTexture.sample(u_clearCoatNormalTextureSampler, _surface.clearCoatNormalTexcoord).rgb;\n        _surface._clearCoatNormalTS = _surface._clearCoatNormalTS * 2.f - 1.f;\n#endif\n#ifdef USE_CLEARCOATNORMAL_INTENSITY\n        _surface._clearCoatNormalTS = mix(float3(0.f, 0.f, 1.f), _surface._clearCoatNormalTS, vfx_commonprofile.clearCoatNormalIntensity);\n#endif\n#else\n        _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);\n#endif\n        _surface.clearCoatNormal.rgb = normalize(ts2vs * _surface._clearCoatNormalTS.xyz );\n    }\n#else\n    _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);\n#endif\n    \n#ifdef USE_REFLECTIVE_MAP\n    float3 refl = reflect( -_surface.view, _surface.normal );\n    float m = 2.f * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.f)*(refl.z+1.f));\n    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, float2(float2(refl.x,-refl.y) / m) + 0.5f);\n#if defined(USE_REFLECTIVE_TEXTURE_COMPONENT)\n    _surface.reflective = colorFromMask(_surface.reflective, USE_REFLECTIVE_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_REFLECTIVE_INTENSITY\n    _surface.reflective *= vfx_commonprofile.reflectiveIntensity;\n#endif\n#elif defined(USE_REFLECTIVE_CUBEMAP)\n    float3 refl = reflect( _surface.position, _surface.normal );\n    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, vfx::mat4_mult_float3(vfx_frame.viewToCubeTransform, refl)); \n#ifdef USE_REFLECTIVE_INTENSITY\n    _surface.reflective *= vfx_commonprofile.reflectiveIntensity;\n#endif\n#elif defined(USE_REFLECTIVE_COLOR)\n    _surface.reflective = vfx_commonprofile.reflectiveColor;\n#elif defined(USE_REFLECTIVE)\n    _surface.reflective = float4(0.);\n#endif\n#ifdef USE_FRESNEL\n    _surface.fresnel = vfx_commonprofile.fresnel.x + vfx_commonprofile.fresnel.y * pow(1.f - saturate(dot(_surface.view, _surface.normal)), vfx_commonprofile.fresnel.z);\n    _surface.reflective *= _surface.fresnel;\n#endif\n#ifdef USE_SHININESS\n    _surface.shininess = vfx_commonprofile.materialShininess;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_SURFACE_MODIFIER\n    \n    __DoSurfaceModifier__\n    \n#endif\n    \n    \n    \n    \n    \n    VFXShaderLightingContribution _lightingContribution(_surface, in);\n#ifdef USE_LIGHT_MODIFIER\n    __LightModifierCopyDecl__\n#endif\n#ifdef USE_AMBIENT_LIGHTING\n    _lightingContribution.ambient = vfx_frame.ambientLightingColor.rgb;\n#endif\n#ifdef USE_LIGHTING\n#ifdef USE_PER_PIXEL_LIGHTING\n#ifdef USE_CLUSTERED_LIGHTING\n    uint3 clusterIndex;\n    clusterIndex.xy = uint2(in.fragmentPosition.xy * vfx_frame.clusterScale.xy); \n    clusterIndex.z = in.position.z * vfx_frame.clusterScale.z + vfx_frame.clusterScale.w; \n    \n    \n    ushort4 cluster_offset_count = u_clusterTexture.read(clusterIndex);\n    int lid = cluster_offset_count.x;\n#endif\n\n#ifdef USE_PBR\n    _lightingContribution.prepareForPBR(u_specularDFGDiffuseHammonTexture, vfx_commonprofile.selfIlluminationOcclusion);\n    \n    \n#ifdef USE_SELFILLUMINATION\n    _lightingContribution.add_irradiance_from_selfIllum();\n#else\n#ifdef USE_PROBES_LIGHTING \n\n#ifdef USE_IBL_TRANSFORM\n    _lightingContribution.add_global_irradiance_from_sh(vfx_frame.environmentTransform * vfx_frame.viewToCubeTransform, vfx_node.shCoefficients);\n#else\n    _lightingContribution.add_global_irradiance_from_sh(vfx_frame.viewToCubeTransform, vfx_node.shCoefficients);\n#endif \n\n#else\n\n#ifdef USE_IBL_TRANSFORM\n    _lightingContribution.add_global_irradiance_probe(u_irradianceTexture, vfx_frame.environmentTransform * vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#else\n    _lightingContribution.add_global_irradiance_probe(u_irradianceTexture, vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#endif \n\n#endif \n#endif\n\n    \n#ifndef DISABLE_SPECULAR\n#ifdef CFX_USE_REFLECTION_PROBES\n    int probe_count = (cluster_offset_count.z & 0xff);\n    for (int i = 0 ; i < probe_count; ++i, ++lid) {\n        _lightingContribution.add_local_probe(vfx_lights[LightIndex(lid)], u_reflectionProbeTexture);\n    }\n#if PROBES_NORMALIZATION\n#if PROBES_OUTER_BLENDING\n    _lightingContribution.specular += _lightingContribution.probesWeightedSum.rgb / max(1.f, _lightingContribution.probesWeightedSum.a);\n#else\n    _lightingContribution.specular += _lightingContribution.probesWeightedSum.rgb / _lightingContribution.probesWeightedSum.a;\n#endif\n    float globalFactor = saturate(1.f - _lightingContribution.probesWeightedSum.a);\n#else\n    float globalFactor = _lightingContribution.probeRadianceRemainingFactor;\n#endif\n    \n#ifdef USE_IBL_TRANSFORM\n    _lightingContribution.add_global_probe(vfx_frame.environmentTransform * vfx_frame.viewToCubeTransform, globalFactor * vfx_frame.environmentIntensity,\n                                           u_reflectionProbeTexture);\n#else\n    _lightingContribution.add_global_probe(vfx_frame.viewToCubeTransform, globalFactor * vfx_frame.environmentIntensity,\n                                           u_reflectionProbeTexture);\n#endif \n    \n#else \n    \n#ifdef USE_IBL_TRANSFORM\n    _lightingContribution.add_global_probe(u_radianceTexture, vfx_frame.environmentTransform * vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#else\n   _lightingContribution.add_global_probe(u_radianceTexture, vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#endif \n    \n#ifdef USE_CLEARCOAT\n    \n#ifdef USE_IBL_TRANSFORM\n    _lightingContribution.add_global_probeClearCoat(u_radianceTexture, vfx_frame.environmentTransform * vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#else\n    _lightingContribution.add_global_probeClearCoat(u_radianceTexture, vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#endif \n    \n#endif\n\n    \n#endif \n#endif \n\n#endif \n    #if DEBUG_PIXEL\n        switch (DEBUG_PIXEL) {\n            case 1: _output.color = float4(_surface.normal * 0.5f + 0.5f, 1.f); break;\n            case 2: _output.color = float4(_surface.geometryNormal * 0.5f + 0.5f, 1.f); break;\n            case 3: _output.color = float4(_surface.tangent * 0.5f + 0.5f, 1.f); break;\n            case 4: _output.color = float4(in.uv0, 0.f, 1.f); break;\n            case 5: _output.color = float4(_surface.diffuse.rgb, 1.f); break;\n            case 6: _output.color = float4(float3(_surface.roughness), 1.f); break;\n            case 7: _output.color = float4(float3(_surface.metalness), 1.f); break;\n            case 8: _output.color = float4(float3(_surface.ambientOcclusion), 1.f); break;\n            default: break;\n        }\n        return _output;\n    #endif\n    \n    __FragmentDoLighting__\n    \n    #ifdef USE_CLUSTERED_LIGHTING\n        \n        int omni_count = cluster_offset_count.y & 0xff;\n        for (int i = 0 ; i < omni_count; ++i, ++lid) {\n            if ((vfx_node.categoryBitmask & vfx_lights[LightIndex(lid)].categoryBitmask) == 0) continue;\n            _lightingContribution.add_local_omni(vfx_lights[LightIndex(lid)]);\n        }\n\n        \n        int spot_count = (cluster_offset_count.y >> 8);\n        for (int i = 0 ; i < spot_count; ++i, ++lid) {\n            if ((vfx_node.categoryBitmask & vfx_lights[LightIndex(lid)].categoryBitmask) == 0) continue;\n            _lightingContribution.add_local_spot(vfx_lights[LightIndex(lid)]);\n        }\n\n    #endif\n#else \n        _lightingContribution.diffuse = in.diffuse;\n    #ifdef USE_SPECULAR\n        _lightingContribution.specular = in.specular;\n    #endif\n#endif \n    #ifdef AVOID_OVERLIGHTING\n        _lightingContribution.diffuse = saturate(_lightingContribution.diffuse);\n    #ifdef USE_SPECULAR\n        _lightingContribution.specular = saturate(_lightingContribution.specular);\n    #endif \n    #endif \n#else \n    _lightingContribution.diffuse = float3(0.);\n#endif \n\n    \n    \n    \n    \n#ifndef USE_GBUFFER_OUTPUT\n#ifdef USE_PBR\n    { \n        float3 diffuseAlbedo = mix(_lightingContribution.pbr.albedo, float3(0.0), _surface.metalness);\n        \n        \n#ifdef USE_PBR_TRANSPARENCY\n        float3 color = (_lightingContribution.ambient * _surface.ambientOcclusion) * _lightingContribution.pbr.albedo;\n#else\n        float3 color = (_lightingContribution.ambient * _surface.ambientOcclusion) * _surface.diffuse.rgb;\n#endif\n        \n        color += _lightingContribution.pbr.envDiffuse;\n        color += _lightingContribution.diffuse * diffuseAlbedo;\n#ifndef DISABLE_SPECULAR\n        color += _lightingContribution.pbr.envSpecular;\n        color += _lightingContribution.specular;\n#endif\n#ifdef USE_EMISSION\n        color += _surface.emission.rgb;\n#endif\n#ifdef USE_MULTIPLY\n        color *= _surface.multiply.rgb;\n#endif\n#ifdef USE_MODULATE\n        color *= _lightingContribution.modulate;\n#endif\n#ifndef USE_GBUFFER_OUTPUT\n        _output.color.rgb = color;\n#endif\n    }\n#else \n\n#ifdef USE_SHADOWONLY\n    _output.color.rgb = float3(0.0);\n    _output.color.a = 1. - _lightingContribution.shadowFactor;\n#else\n#ifdef USE_CONSTANT\n    _output.color.rgb = _surface.diffuse.rgb;\n    \n#ifdef USE_EMISSION\n    _output.color.rgb += _surface.emission.rgb;\n#endif\n#ifdef USE_MULTIPLY\n    _output.color.rgb *= _surface.multiply.rgb;\n#endif\n    \n#else\n    _output.color.rgb = illuminate(_surface, _lightingContribution);\n#endif\n#endif \n#endif \n\n#ifndef USE_SHADOWONLY\n  #ifdef USE_PBR_TRANSPARENCY\n    _output.color.a = _lightingContribution.pbr.transparency;\n  #else\n    _output.color.a = _surface.diffuse.a;\n  #endif\n#endif\n\n#ifdef USE_FOG\n    applyFog(_output.color, length(_surface.position.xyz), vfx_frame.fogParameters, vfx_frame.fogColor);\n#endif\n\n#if !defined(DIFFUSE_PREMULTIPLIED) && !defined(USE_PBR_TRANSPARENCY)\n    _output.color.rgb *= _surface.diffuse.a;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_SHADOWONLY\n    float transparencyFactor = 1.0;\n  #ifdef USE_NODE_OPACITY\n    transparencyFactor *= in.nodeOpacity;\n  #endif\n    _output.color.a *= transparencyFactor; \n\n#else \n\n#ifdef USE_TRANSPARENT \n    \n#ifndef USE_PBR_TRANSPARENCY\n  _output.color *= _surface.transparent.a;\n#endif\n\n#endif \n    \n#ifdef USE_NODE_OPACITY\n    _output.color *= in.nodeOpacity;\n#endif\n    \n#endif \n#endif \n\n    \n    \n    \n    \n#ifdef USE_MODIFIER_FRAMEBUFFER\n    const VFXFramebuffer _framebuffer = {\n#if defined(CFX_SUPPORTS_PROGRAMMABLE_BLENDING) && defined(USE_MODIFIER_FRAMEBUFFER_COLOR0)\n        .color = framebufferColor0\n#else\n        .color = 0.f\n#endif\n    };\n#endif\n    \n#ifdef USE_FRAGMENT_MODIFIER\n    \n    __DoFragmentModifier__\n    \n#endif\n#if defined(USE_CLUSTERED_LIGHTING) && defined(DEBUG_CLUSTER_TILE)\n    _output.color.rgb = mix(_output.color.rgb, float3(vfx::debugColorForCount(clusterIndex.z).xyz), 0.1f);\n    _output.color.rgb = mix(_output.color.rgb, float3(clusterIndex.x & 0x1 ^ clusterIndex.y & 0x1).xyz, 0.01f);\n#endif\n    \n#ifdef USE_ALPHA_CUTOFF\n    if (_output.color.a <= vfx_commonprofile.alphaCutoff)\n        discard_fragment();\n#endif\n\n#ifdef USE_POINT_RENDERING\n    if ((dfdx(pointCoord.x) < 0.5f) && (length_squared(pointCoord * 2.f - 1.f) > 1.f)) {\n        discard_fragment();\n    }\n#endif\n    \n    \n#ifdef USE_OUTLINE\n    _output.color.rgb = in.outlineHash;\n#endif\n    \n\n#if defined(USE_MOTIONBLUR) && !defined(USE_GBUFFER_OUTPUT)\n#ifdef USE_MULTIPLE_RENDERING\n    _output.motionblur.xy = half2((in.mv_fragment.xy - vfx_frame.viewportSize.zw) / in.mv_fragment.z - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * vfx_frame.motionBlurIntensity;\n#else\n    _output.motionblur.xy = half2((in.mv_fragment.xy / in.mv_fragment.z) - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * vfx_frame.motionBlurIntensity;\n#endif\n    _output.motionblur.z = length(_output.motionblur.xy);\n    _output.motionblur.w = half(-_surface.position.z);\n#endif\n\n#ifdef USE_NORMALS_OUTPUT\n    _output.normals = half4( half3(_surface.normal.xyz), half(_surface.roughness) );\n#endif\n    \n#ifdef USE_RADIANCE_OUTPUT\n    _output.radiance.rgb = half3(_lightingContribution.specular.rgb);\n#endif\n                                 \n#ifdef USE_REFLECTANCE_ROUGHNESS_OUTPUT\n#ifdef USE_PBR\n    _output.reflectanceRoughnessOutput = half4( half3(_lightingContribution.pbr.probeReflectance), half(_surface.roughness) );\n#else \n    _output.reflectanceRoughnessOutput = half4( 0.h );\n#endif\n#endif\n    \n#ifdef USE_BARYCENTRIC_WIREFRAME\n#ifdef USE_BARYCENTRIC_COORD\n    const float3 d = 1.0f * fwidth(baryCoord);\n    const float3 s = smoothstep(d * 0.25f, d * 0.75, u_barycentricCoord);\n    _output.color = mix(float4(1.0), _output.color, min3(s.x, s.y, s.z));\n#endif\n#endif\n    \n#ifdef USE_GBUFFER_OUTPUT\n    float opacity = _surface.diffuse.a;\n#ifdef USE_NODE_OPACITY\n    opacity *= in.nodeOpacity;\n#endif\n    \n    float dither = vfx::interleaved_gradient_noise(in.fragmentPosition.xy);\n    dither = fract(dither + in.fragmentPosition.z * 1.61803398875);\n    dither = fract(dither + vfx_frame.frame * 1.61803398875);\n    if (opacity < dither) discard_fragment();\n    \n    float3 emission = float3(0.);\n#ifdef USE_EMISSION\n    emission = _surface.emission.rgb;\n#endif\n    _output.albedo = float4(_surface.diffuse.rgb, opacity);\n    _output.normals = float4(_surface.normal.xyz, in.fragmentPosition.z);\n    _output.roughmetal = float4(_surface.roughness, _surface.metalness, _surface.ambientOcclusion, 1.);\n    _output.color = float4(emission, 1.);\n    \n    float2 vfx_prevUv = (in.mv_lastFragment.xy / in.mv_lastFragment.z);\n    float2 vfx_uv = (in.mv_fragment.xy / in.mv_fragment.z);\n    _output.velocity.xy = (vfx_prevUv - vfx_uv) * float2(.5,-.5);\n    \n#ifdef USE_MOTIONBLUR\n    _output.velocity.z = length(_output.velocity.xy);\n    _output.velocity.w = -_surface.position.z;\n#endif\n    ushort clearcoatIR = packHalf2ToUShort(half2(_surface.clearCoat, _surface.clearCoatRoughness));\n    _output.clearCoat = float4(_surface.clearCoatNormal, as_type<half>(clearcoatIR));\n    \n    _output.subsurface = float4(_surface.subsurfaceRadius, _surface.subsurface);\n#endif\n    \n    \n    return _output;\n}\n"
- "  maxInf:%d morpher:%p\n"
- " buffers (total: "
- " buffers will be destroy."
- " conversion to ScriptScheduling is not yet supported"
- " evict from cache "
- " is already published elsewhere"
- " was not in the allocator"
- "!CFSetContainsValue(geometry->_trackedNodes, node)"
- "!geometry->_trackedNodes || !CFSetGetCount(geometry->_trackedNodes)"
- "#define USE_QUAT_FOR_IES 1\n#define USE_PBR_DOMINANT_DIRECTION 1\n\n#define PBR_INTENSITY_FACTOR M_PI_2_F\n#define BoostFactor (20.0f * PBR_INTENSITY_FACTOR)\n\n\nstruct vfx_light\n{\n    float4 color; \n    float3 pos; \n    float3 dir; \n    float shadowRadius; \n    uint8_t lightType; \n    uint8_t shadowSampleCount; \n                                \n    union {\n        struct {\n            float4      cascadeScale[4]; \n            float4      cascadeBias[4];\n        } directional; \n        struct {\n            float4      attenuationFactors; \n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n            float4x4    projection;\n            float       depthBias;\n#else\n            float3      shadowScaleBias; \n#endif\n        } omni;\n        struct {\n            float4      _attenuationFactors; \n            float2      scaleBias; \n        } spot;\n        struct {\n            float4      _attenuationFactors; \n            float2      scaleBias; \n#if USE_QUAT_FOR_IES\n            float4      light_from_view_quat; \n#else\n            float4x4    light_from_view; \n#endif\n        } ies;\n        union {\n            struct {\n                float2 halfExtents;\n                float doubleSided;\n            } rectangle;\n            struct {\n                uint32_t vertexCount;\n                float doubleSided;\n            } polygon;\n            struct {\n                float halfLength;\n            } line;\n            struct {\n                float2 halfExtents;\n                float doubleSided;\n            } ellipse;\n            struct {\n                float3 halfExtents;\n            } ellipsoid;\n        } area;\n        struct {\n            float3  offset;\n            float4  halfExtents; \n            float3  parallaxCenter;\n            float3  parallaxExtents;\n            int32_t index; \n            int32_t parallaxCorrection; \n        } probe;\n    } parameters; \n\n    float4x4    shadowMatrix; \n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    float4 tiles[6]; \n#endif\n\tuint8_t categoryBitmask;\n};\n\n#if defined(__METAL_VERSION__) \n\nusing namespace metal;\n\nnamespace vfx {\n    static constexpr sampler linearSampler = sampler(filter::linear, mip_filter::linear);\n}\n\nstruct VFXShaderSurface {\n    float3 view;                \n    float3 position;            \n    float3 normal;              \n    float3 geometryNormal;      \n    float2 normalTexcoord;      \n    float3 tangent;             \n    float3 bitangent;           \n    float4 diffuse;             \n    float2 diffuseTexcoord;     \n    float4 specular;            \n    float2 specularTexcoord;    \n    float4 emission;            \n    float2 emissionTexcoord;    \n    float4 selfIllumination;            \n    float2 selfIlluminationTexcoord;    \n    float4 multiply;            \n    float2 multiplyTexcoord;    \n    float4 transparent;         \n    float2 transparentTexcoord; \n    float4 reflective;          \n    float  metalness;           \n    float2 metalnessTexcoord;   \n    float  roughness;           \n    float2 roughnessTexcoord;   \n    float clearCoat;            \n    float2 clearCoatTexcoord;   \n    float clearCoatRoughness;   \n    float2 clearCoatRoughnessTexcoord;\n    float3 clearCoatNormal;     \n    float2 clearCoatNormalTexcoord;\n    float subsurface;\n    float2 subsurfaceTexCoord;\n    float3 subsurfaceRadius;\n    float2 subsurfaceRadiusTexCoord;\n    float shininess;            \n    float fresnel;              \n    float ambientOcclusion;     \n    float2 ambientOcclusionTexcoord;   \n    float3 _normalTS;           \n    float3 _clearCoatNormalTS;  \n#ifdef USE_SURFACE_EXTRA_DECL\n    __SurfaceExtraDecl__\n#endif\n};\n\n\n\nstruct VFXShaderLight {\n    float4 intensity;\n    float3 direction;\n\n    float  _att;\n    float3 _spotDirection;\n    float  _distance;\n};\n\nenum VFXShadingModel\n{\n    VFXShadingModelConstant,\n    VFXShadingModelPhong,\n    VFXShadingModelNone,\n    VFXShadingModelPhysicallyBased,\n    VFXShadingModelShadowOnly,\n\n    VFXShadingModelCustom \n};\n\n#define PROBES_NORMALIZATION 0\n#define PROBES_OUTER_BLENDING 1\n\nstruct VFXShaderLightingContribution\n{\n    float3 ambient;\n    float3 diffuse;\n    float3 specular;\n    float3 modulate;\n\n#ifdef USE_SHADOWONLY\n    float shadowFactor;\n#endif\n\n#if PROBES_NORMALIZATION\n    float4 probesWeightedSum; \n#else\n    float  probeRadianceRemainingFactor;\n#endif\n\n    thread VFXShaderSurface& surface;\n\n#ifdef USE_PER_VERTEX_LIGHTING\n    commonprofile_io out;\n#else\n    commonprofile_io in;\n#endif\n\n#ifdef USE_PBR\n    struct {\n        float3 albedo;\n        float3 envDiffuse;\n        float3 envSpecular;\n        float3 reflectance;\n        float3 probeReflectance;\n#ifndef USE_PBR_LAMBERTIAN_REFLECTION\n        float2 diffuseHammonFactors;\n#endif\n#ifdef USE_PBR_TRANSPARENCY\n        float  transparency;\n#endif\n        float  NoV;\n        float  selfIlluminationOcclusion;\n#ifdef USE_CLEARCOAT\n        float  NoVClearCoat;\n        float3 probeReflectanceClearCoat;\n#endif\n    } pbr;\n#endif\n    \n    VFXShaderLightingContribution(thread VFXShaderSurface& iSurface, commonprofile_io io):surface(iSurface)\n#ifdef USE_PER_VERTEX_LIGHTING\n    ,out(io)\n#else\n    ,in(io)\n#endif\n    {\n        ambient = 0.f;\n        diffuse = 0.f;\n        specular = 0.f;\n#ifdef USE_SHADOWONLY\n        shadowFactor = 1.f;\n#endif\n\n#if PROBES_NORMALIZATION\n#if PROBES_OUTER_BLENDING\n        probesWeightedSum = float4(0.f);\n#else\n        probesWeightedSum = float4(0.f, 0.f, 0.f, 0.000001f); \n#endif\n#else\n        probeRadianceRemainingFactor = 1.f;\n#endif\n\n#ifdef USE_MODULATE\n        modulate = 1.f;\n#else\n        modulate = 0.f;\n#endif\n    }\n\n#ifdef USE_PBR\n    void prepareForPBR(texture2d<float, access::sample> specularDFGDiffuseHammonTexture, float occ)\n    {\n        pbr.envDiffuse = 0.f;\n        pbr.envSpecular = 0.f;\n        pbr.selfIlluminationOcclusion = occ;\n      \n        pbr.albedo = surface.diffuse.rgb;\n#ifdef USE_PBR_TRANSPARENCY\n  #ifdef DIFFUSE_PREMULTIPLIED\n        \n        pbr.transparency = 1.f;\n  #else\n        pbr.transparency = surface.diffuse.a;\n  #endif\n  #ifdef USE_TRANSPARENCY\n    #ifdef USE_PER_VERTEX_LIGHTING\n        pbr.transparency *= out.transparency;\n    #else\n        pbr.transparency *= in.transparency;\n    #endif\n  #endif\n  #ifdef USE_TRANSPARENT\n        pbr.transparency *= surface.transparent.a;\n  #endif\n        pbr.albedo *= pbr.transparency;\n  #ifdef DIFFUSE_PREMULTIPLIED\n        \n        \n        pbr.transparency *= surface.diffuse.a;\n  #endif\n#endif\n        \n        float3 n = surface.normal;\n        float3 v = surface.view;\n        pbr.NoV = abs(dot(n, v));\n        \n        float roughness = surface.roughness;\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        float2 specularDFG = specularDFGDiffuseHammonTexture.sample(vfx::linearSampler, float2(pbr.NoV, roughness)).rg;\n#else\n        float4 env = specularDFGDiffuseHammonTexture.sample(vfx::linearSampler, float2(pbr.NoV, roughness));\n        float2 specularDFG = env.xy;\n        pbr.diffuseHammonFactors = env.zw;\n#endif\n        \n        pbr.reflectance = mix(PBR_F0_NON_METALLIC, pbr.albedo, surface.metalness);\n        pbr.probeReflectance = pbr.reflectance * specularDFG.r + specularDFG.g;\n                                \n#ifdef USE_CLEARCOAT\n        pbr.NoVClearCoat = abs(dot(surface.clearCoatNormal, v));\n        float2 DFGClearCoat = specularDFGDiffuseHammonTexture.sample(vfx::linearSampler, float2(pbr.NoVClearCoat, surface.clearCoatRoughness)).rg;\n        pbr.probeReflectanceClearCoat = 0.04 * DFGClearCoat.r + DFGClearCoat.g;\n#endif\n    }\n#endif\n\n\n#ifdef USE_LIGHT_MODIFIER\n    __LightModifierExtraDecl__\n#endif\n\n    float4 debug_pixel(float2 fragmentPosition)\n    {\n        const int width = 64;\n        switch (int(fragmentPosition.x + fragmentPosition.y ) / width) {\n            case 0: return float4(surface.view, 1.f);\n            case 1: return float4(surface.position, 1.f);\n            case 2: return float4(surface.normal, 1.f);\n            case 3: return float4(surface.geometryNormal, 1.f);\n            case 4: return float4(float3(surface.ambientOcclusion), 1.f);\n            case 5: return surface.diffuse;\n            case 6: return float4(float3(surface.metalness), 1.f);\n            case 7: return float4(float3(surface.roughness), 1.f);\n            case 8: return float4(ambient, 1.f);\n            case 9: return float4(diffuse, 1.f);\n            default: return float4(specular, 1.f);\n        }\n    }\n\n    \n\n    static inline float3 lambert_diffuse(float3 l, float3 n, float3 color, float intensity) {\n        return color * (intensity * saturate(dot(n, l)));\n    }\n\n    void phong(float3 l, float3 color, float intensity)\n    {\n        float3 D = lambert_diffuse(l, surface.normal, color, intensity);\n        diffuse += D;\n\n        float3 r = reflect(-l, surface.normal);\n        specular += powr(saturate(dot(r, surface.view)), surface.shininess) * D;\n    }\n\n#ifdef USE_PBR\n    void physicallyBased(float3 l, float3 color, float intensity)\n    {\n        float3 n         = surface.normal;\n        float3 v         = surface.view;\n        float  roughness = surface.roughness;\n        float  alpha     = roughness * roughness;\n\n        float3 h = normalize(l + v);\n\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n        \n        float D   = vfx_brdf_D(alpha, NoH);\n        float3 F  = vfx_brdf_F_opt(pbr.reflectance, LoH);\n        float Vis = vfx_brdf_V(alpha, NoL, pbr.NoV);\n\n        \n        diffuse  += color * (NoL * M_1_PI_F * intensity);\n        specular += color * F * (NoL * D * Vis * intensity);\n        \n        #ifdef USE_CLEARCOAT\n            n = surface.clearCoatNormal;\n\n            roughness = max(surface.clearCoatRoughness, 0.089f);\n            alpha = roughness * roughness; \n        \n            \n            \n            float NoH_coat = saturate(dot(n, h));\n            float NoL_coat = saturate(dot(n, l));\n            D   = vfx_brdf_D(alpha, NoH_coat);\n            F   = vfx_brdf_F_opt(0.04, LoH) * surface.clearCoat;\n            Vis = vfx_brdf_V(alpha, NoL_coat, saturate(dot(n,v)));\n        \n            float attenuation = 1.0 - F.r;\n            specular *=  (attenuation * attenuation);\n            specular += color * F * ( NoL_coat * D * Vis * intensity);\n        #endif\n    }\n#endif\n\n    void custom(float3 _l, float3 _color, float _intensity)\n    {\n#ifdef USE_LIGHT_MODIFIER\n        thread VFXShaderLightingContribution &_lightingContribution = *this;\n        thread VFXShaderSurface& _surface = surface;\n        VFXShaderLight _light = {.direction = _l, .intensity = float4(_color, 1.f), ._att = _intensity };\n        \n        __DoLightModifier__\n        \n#endif\n    }\n\n    void shade(float3 l, float3 color, float intensity)\n    {\n#ifdef LIGHTING_MODEL\n        switch (LIGHTING_MODEL) {\n#ifdef USE_SHADOWONLY\n            case VFXShadingModelShadowOnly:        shadowFactor *= intensity; break;\n#endif\n            case VFXShadingModelPhong:             phong(l, color, intensity);   break;\n#ifdef USE_PBR\n            case VFXShadingModelPhysicallyBased:   physicallyBased(l, color, intensity);     break;\n#endif\n            case VFXShadingModelCustom:            custom(l, color, intensity);  break;\n            default:  break; \n        }\n#endif\n    }\n\n    \n    \n    \n    float pbr_dist_attenuation_alternate(float3 l, float cutoff) {\n        \n        float radius = 0.1f; \n        float factor = 1.f / (1.f + length(l)/radius);\n        float attenuation = saturate(factor * factor); \n        return saturate((attenuation - cutoff) / (1.f - cutoff));\n    }\n\n    float pbr_dist_attenuation(float3 l, float inv_square_radius) {\n        float sqr_dist = length_squared(l);\n        float atten = 1.f / max(sqr_dist, 0.0001f);\n\n        \n        float factor = saturate(1.f - vfx::sq(sqr_dist * inv_square_radius));\n        return atten * factor * factor;\n    }\n\n    float non_pbr_dist_attenuation(float3 l, float4 att)\n    {\n        return powr(saturate(length(l) * att.x + att.y), att.z);\n    }\n\n    float dist_attenuation(float3 unnormalized_l, vfx_light light)\n    {\n#ifdef USE_PBR\n        return pbr_dist_attenuation(unnormalized_l, light.parameters.omni.attenuationFactors.w);\n        \n        \n#else\n#ifdef USE_SHADOWONLY\n        return 1.f;\n#endif\n        return non_pbr_dist_attenuation(unnormalized_l, light.parameters.omni.attenuationFactors);\n#endif\n    }\n\n    float spot_attenuation(float3 l, vfx_light light)\n    {\n#ifdef USE_SHADOWONLY\n        return 1.f;\n#endif\n        \n        return saturate(dot(l, light.dir) * light.parameters.spot.scaleBias.x + light.parameters.spot.scaleBias.y);\n    }\n\n    void shade_modulate(float3 l, float4 color, float intensity)\n    {\n        constexpr half3 white = half3(1.h);\n        \n        modulate *= float3(mix(white, half3(color.rgb), half(color.a * intensity)));\n    }\n\n    float3 gobo(float3 pos, vfx_light light, texture2d<half> goboTexture, sampler goboSampler)\n    {\n        half3 g = texture2DProj(goboTexture, goboSampler, (light.shadowMatrix * float4(pos, 1.f))).rgb;\n        return light.color.rgb * float3(mix(1.h, g, half(light.color.a)));\n    }\n\n    float shadow(float3 pos, vfx_light light, depth2d<float> shadowMap)\n    {\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n        float4 tile = light.tiles[0];\n#else\n        float4 tile = {0.0, 0.0, 1.0, 1.0};\n#endif\n        float shadow = ComputeShadow(vfx_shadow_sampler, pos, light.shadowMatrix, shadowMap, tile);\n        return 1.f - shadow * light.color.a; \n    }\n\n    \n    float shadow(float3 pos, vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel)\n    {\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n        float4 tile = light.tiles[0];\n#else\n        float4 tile = {0.0, 0.0, 1.0, 1.0};\n#endif\n        float4 lightScreen = transformViewPosInShadowSpace(pos, light.shadowMatrix);\n        lightScreen.xyz /= lightScreen.w;\n        float shadow = ComputeSoftShadow(vfx_shadow_sampler, lightScreen.xyz, shadowMap, shadowKernel, light.shadowSampleCount, light.shadowRadius, tile);\n        return 1.f - shadow * light.color.a; \n    }\n\n    float shadow(float3 pos, vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int shadowSampleCount)\n    {\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n        float4 tile = light.tiles[0];\n#else\n        float4 tile = {0.0, 0.0, 1.0, 1.0};\n#endif\n        float4 lightScreen = transformViewPosInShadowSpace(pos, light.shadowMatrix);\n        lightScreen.xyz /= lightScreen.w;\n        float shadow = ComputeSoftShadow(vfx_shadow_sampler, lightScreen.xyz, shadowMap, shadowKernel, shadowSampleCount, light.shadowRadius, tile);\n        return 1.f - shadow * light.color.a; \n    }\n\n    float shadow(float3 pos, vfx_light light, depth2d<float> shadowMap, int shadowSampleCount)\n    {\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n        float4 tile = light.tiles[0];\n#else\n        float4 tile = {0.0, 0.0, 1.0, 1.0};\n#endif\n        float shadow = ComputeSoftShadowGrid(vfx_shadow_sampler, pos, light.shadowMatrix, shadowMap, shadowSampleCount, tile);\n        return 1.f - shadow * light.color.a; \n    }\n\n\nushort getCubeFace(float3 dir)\n{\n    \n    float3 absDir = abs(dir);\n    float maxAxis = max(absDir.x, max(absDir.y, absDir.z));\n    if (absDir.z == maxAxis) {\n        \n        return dir.z > 0.0f ? 4 : 5;\n    } else if (absDir.y == maxAxis) {\n        \n        return dir.y > 0.0f ? 2 : 3;\n    } else {\n        \n        \n        return dir.x > 0.0f ? 0 : 1;\n    }\n}\n\nfloat4x4 getFaceRotation(ushort face) {\n\n    float4 xAxis(1.0, 0.0, 0.0, 0.0);\n    float4 yAxis(0.0, 1.0, 0.0, 0.0);\n    float4 zAxis(0.0, 0.0, 1.0, 0.0);\n    float4 zero (0.0, 0.0, 0.0, 1.0);\n\n    switch (face) {\n        case 0: return float4x4(-zAxis, yAxis,  xAxis, zero);\n        case 1: return float4x4( zAxis, yAxis, -xAxis, zero);\n        case 2: return float4x4( xAxis,-zAxis,  yAxis, zero);\n        case 3: return float4x4( xAxis, zAxis, -yAxis, zero);\n        case 4: return float4x4(-xAxis, yAxis, -zAxis, zero);\n        case 5: return float4x4( xAxis, yAxis,  zAxis, zero);\n        default: return float4x4();\n    }\n}\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    float shadow_omni(float3 pos_vs, float3 nrm_vs, vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n#else\n    float shadow_omni(float3 pos_vs, float3 nrm_vs, vfx_light light, depthcube<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n#endif\n    {\n        \n#define USE_TANGENT_SAMPLING 0\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n        float  depthBias = light.parameters.omni.depthBias;\n#else\n        float2 scaleBias = light.parameters.omni.shadowScaleBias.xy;\n        float  depthBias = light.parameters.omni.shadowScaleBias.z;\n#endif\n\n        \n        pos_vs += nrm_vs * depthBias;\n\n        \n        float4 pos_ls = (light.shadowMatrix * float4(pos_vs, 1.f));\n\n#if !CFX_USE_ATLAS_FOR_SHADOW_MAP\n        \n        float z_lin = vfx::reduce_max(abs(pos_ls));\n\n        \n        \n        \n        \n        float z_ndc = (z_lin * scaleBias.x + scaleBias.y) / z_lin - depthBias;\n#endif\n\n        \n        float shadow;\n        if (sampleCount <= 1) {\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n            ushort face = getCubeFace(normalize(pos_ls.xyz));\n            float4 tile = light.tiles[face];\n            shadow = ComputeShadow(vfx_shadow_sampler, (getFaceRotation(face) * pos_ls).xyz, light.parameters.omni.projection, shadowMap, tile);\n#else\n            shadow = shadowMap.sample_compare(vfx_shadow_sampler, pos_ls.xyz, z_ndc);\n#endif\n        } else {\n\n            \n            float filteringSizeFactor = light.shadowRadius;\n\n#if USE_TANGENT_SAMPLING\n            float3 tgt_x, tgt_y;\n            vfx::orthogonal_basis(pos_ls, tgt_x, tgt_y);\n#else\n            float3 nrm_ls = (light.shadowMatrix * float4(nrm_vs, 0.f)).xyz;\n#endif\n\n            \n            float totalAccum = 0.0;\n            for(int i=0; i < sampleCount; i++){\n\n#if USE_TANGENT_SAMPLING\n                float2 scale = shadowKernel[i].xy * filteringSizeFactor * 2.f;\n                float3 smp_ls = pos_ls.xyz + tgt_x * scale.x + tgt_y * scale.y;\n#else\n                float3 smp_ls = pos_ls.xyz + vfx::randomHemisphereDir(nrm_ls, shadowKernel[i].xy * 0.5 + 0.5) * filteringSizeFactor;\n#endif\n\n                \n                \n                \n\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n                ushort face = getCubeFace(normalize(smp_ls.xyz));\n                float4 tile = light.tiles[face];\n                totalAccum += ComputeShadow(vfx_shadow_sampler, (getFaceRotation(face) * float4(smp_ls, 1.0)).xyz, light.parameters.omni.projection, shadowMap, tile);\n#else\n                totalAccum += shadowMap.sample_compare(vfx_shadow_sampler, smp_ls, z_ndc);\n#endif\n\n            }\n            shadow = totalAccum / float(sampleCount);\n        }\n\n        return 1.f - shadow * light.color.a; \n    }\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    float shadow(float3 pos, constant vfx_light& light, depth2d<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount)\n    {\n        float shadow = ComputeCascadedShadow(vfx_shadow_sampler, pos, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius, light.tiles).a;\n        return 1.f - shadow * light.color.a; \n    }\n#else\n    float shadow(float3 pos, constant vfx_light& light, depth2d_array<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount)\n    {\n        float shadow = ComputeCascadedShadow(vfx_shadow_sampler, pos, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius).a;\n        return 1.f - shadow * light.color.a; \n    }\n#endif\n\n    \n\n    void add_directional(vfx_light light)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n    void add_directional(vfx_light light, texture2d<half> goboTexture, sampler goboSampler)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);\n        \n          \n\n            shade(light.dir, light.color.rgb, intensity);\n\n    }\n\n    \n    void add_directional(vfx_light light, depth2d<float> shadowMap)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        intensity *= shadow(surface.position, light, shadowMap);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n    void add_directional(vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        intensity *= shadow(surface.position, light, shadowMap, shadowKernel);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    void add_directional(vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        intensity *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n    void add_directional(vfx_light light, depth2d<float> shadowMap, int sampleCount)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        intensity *= shadow(surface.position, light, shadowMap, sampleCount);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    void add_directional(constant vfx_light& light, depth2d<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount, bool debugCascades)\n#else\n    void add_directional(constant vfx_light& light, depth2d_array<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount, bool debugCascades)\n#endif\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        if (debugCascades) {\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n            float4 shadowDebug = ComputeCascadedShadow(vfx_shadow_sampler, surface.position, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius, light.tiles);\n#else\n            float4 shadowDebug = ComputeCascadedShadow(vfx_shadow_sampler, surface.position, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius);\n#endif\n            intensity *= (1.f - shadowDebug.a);\n            shade(light.dir, light.color.rgb, intensity);\n            diffuse.rgb = mix(diffuse.rgb, shadowDebug.rgb, light.color.a);\n        } else {\n            intensity *= shadow(surface.position, light, shadowMaps, cascadeCount, blendCascade, shadowKernel, sampleCount);\n            shade(light.dir, light.color.rgb, intensity);\n        }\n    }\n\n    \n\n    void add_omni(vfx_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        shade(l, light.color.rgb, dist_attenuation(unnormalized_l, light) * BoostFactor);\n    }\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    void add_omni(vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n#else\n    void add_omni(vfx_light light, depthcube<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n#endif\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light) * BoostFactor;\n        intensity *= shadow_omni(surface.position, surface.normal, light, shadowMap, shadowKernel, sampleCount);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    void add_local_omni(vfx_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        shade(l, light.color.rgb, dist_attenuation(unnormalized_l, light) * BoostFactor);\n    }\n\n    \n\n    void add_spot(vfx_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light) * BoostFactor;\n        intensity      *= spot_attenuation(l, light);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    void add_spot(vfx_light light, texture2d<half> goboTexture, sampler goboSampler)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light) * BoostFactor;\n        intensity      *= spot_attenuation(l, light);\n        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);\n\n        \n        \n        \n              shade(l, light.color.rgb, intensity);\n        \n    }\n\n    void add_local_spot(vfx_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light) * BoostFactor;\n        intensity      *= spot_attenuation(l, light);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    \n    void add_spot(vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light) * BoostFactor;;\n        intensity      *= spot_attenuation(l, light);\n        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    \n\n#ifdef USE_PBR\n\n    \n\n#ifdef CFX_SUPPORT_CUBE_ARRAY\n    void add_local_probe(vfx_light light, texturecube_array<half> probeTextureArray)\n#else\n    void add_local_probe(vfx_light light, texture2d_array<half> probeTextureArray)\n#endif\n    {\n#if !PROBES_NORMALIZATION\n        if (probeRadianceRemainingFactor <= 0.f)\n            return;\n#endif\n\n        bool parallaxCorrection = light.parameters.probe.parallaxCorrection;\n        int    probeIndex       = light.parameters.probe.index;\n        float3 probeExtents     = light.parameters.probe.halfExtents.xyz;\n        float  blendDist        = light.parameters.probe.halfExtents.w;\n        float3 probeOffset      = light.parameters.probe.offset;\n        float3 parallaxExtents  = light.parameters.probe.parallaxExtents;\n        float3 parallaxCenter   = light.parameters.probe.parallaxCenter;\n\n        float3 n = surface.normal;\n        float3 v = surface.view;\n        float3 r = reflect(-v, n); \n\n        float3 specDir = vfx::mat4_mult_float3(light.shadowMatrix, r);\n\n        \n        float3 pos_ls = (light.shadowMatrix * float4(surface.position, 1.f)).xyz;\n\n        \n        float3 d = abs(pos_ls) - probeExtents;\n#if PROBES_OUTER_BLENDING\n        if (any(d > blendDist))\n#else\n        if (any(d > 0.f))\n#endif\n        {\n            return;\n        }\n\n#if PROBES_NORMALIZATION\n        \n        \n#if PROBES_OUTER_BLENDING\n        float3 nd = saturate(-(d / blendDist) * 0.5f + 0.5f);\n#else\n        float3 nd = saturate(-(d / blendDist));\n#endif\n        float probeFactor = (nd.x * nd.y * nd.z) * light.color.r;\n#else\n        \n        float sd = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n#if PROBES_OUTER_BLENDING\n        float probeFactor = saturate(1.f - sd / blendDist);\n#else\n        float probeFactor = saturate(-sd / blendDist);\n#endif\n        \n        \n        \n        probeFactor *= probeRadianceRemainingFactor * light.color.r; \n#endif\n\n        if (parallaxCorrection ) {\n            \n            float3 pos_off = pos_ls + parallaxCenter;\n            float3 t1 = ( parallaxExtents - pos_off) / specDir;\n            float3 t2 = (-parallaxExtents - pos_off) / specDir;\n            float3 tmax = max(max(0, t1), t2); \n            float t = min(tmax.x, min(tmax.y, tmax.z));\n\n            \n            float3 hit_ls = pos_ls + specDir * t;\n            specDir = hit_ls - probeOffset;\n        }\n\n        \n        specDir.z *= -1.0;\n\n        float mipd = float(probeTextureArray.get_num_mip_levels()) - 1.f;\n        const float intensity = surface.ambientOcclusion * probeFactor;\n\n        float mips = surface.roughness * mipd;\n#ifdef CFX_SUPPORT_CUBE_ARRAY\n        float3 LD = float3(probeTextureArray.sample(vfx::linearSampler, specDir, probeIndex, level(mips)).rgb);\n#else\n        float2 specUV = vfx::dual_paraboloid_from_cartesian(normalize(specDir));\n        float3 LD = float3(probeTextureArray.sample(vfx::linearSampler, specUV, probeIndex, level(mips)).rgb);\n#endif\n\n        \n\n        \n#if PROBES_NORMALIZATION\n        probesWeightedSum += float4(LD * intensity * pbr.probeReflectance, probeFactor);\n#else\n        probeRadianceRemainingFactor = saturate(probeRadianceRemainingFactor - probeFactor);\n        specular += LD * intensity * pbr.probeReflectance;\n#endif\n        \n#ifdef USE_CLEARCOAT\n        n = surface.clearCoatNormal;\n        r = reflect(-v, n);\n        specDir = vfx::mat4_mult_float3(light.shadowMatrix, r);\n        if (parallaxCorrection ) {\n            float3 pos_off = pos_ls + parallaxCenter;\n            \n            float3 t1 = ( parallaxExtents - pos_off) / specDir;\n            float3 t2 = (-parallaxExtents - pos_off) / specDir;\n            float3 tmax = max(max(0, t1), t2); \n            float t = min(tmax.x, min(tmax.y, tmax.z));\n            \n            \n            float3 hit_ls = pos_ls + specDir * t;\n            specDir = hit_ls - probeOffset;\n        }\n        mips = surface.clearCoatRoughness * mipd;\n#ifdef CFX_SUPPORT_CUBE_ARRAY\n        LD = float3(probeTextureArray.sample(vfx::linearSampler, specDir, probeIndex, level(mips)).rgb);\n#else\n        specUV = vfx::dual_paraboloid_from_cartesian(normalize(specDir));\n        LD = float3(probeTextureArray.sample(vfx::linearSampler, specUV, probeIndex, level(mips)).rgb);\n#endif\n#if PROBES_NORMALIZATION\n        probesWeightedSum += float4(LD * intensity * pbr.probeReflectanceClearCoat, probeFactor) * surface.clearCoat;\n#else\n        specular += LD * intensity * pbr.probeReflectanceClearCoat  * surface.clearCoat;\n#endif\n#endif\n    }\n\n    void add_global_probe(float4x4 localDirToWorldCubemapDir,\n                          float environmentIntensity,\n#ifdef CFX_SUPPORT_CUBE_ARRAY\n                          texturecube_array<half> probeTextureArray\n#else\n                          texture2d_array<half> probeTextureArray\n#endif\n                          )\n    {\n        float3 n = surface.normal;\n        float3 v = surface.view;\n        float3 r = reflect(-v, n); \n        \n        float3 specDir = vfx::mat4_mult_float3(localDirToWorldCubemapDir, r);\n        float mips = surface.roughness * float(probeTextureArray.get_num_mip_levels() - 1);\n        \n#ifdef CFX_SUPPORT_CUBE_ARRAY\n        float3 LD = float3(probeTextureArray.sample(vfx::linearSampler, specDir, 0, level(mips)).rgb);\n#else\n        float2 specUV = vfx::dual_paraboloid_from_cartesian(normalize(specDir));\n        float3 LD = float3(probeTextureArray.sample(vfx::linearSampler, specUV, 0, level(mips)).rgb);\n#endif\n        \n        \n        specular += pbr.probeReflectance * LD * surface.ambientOcclusion * environmentIntensity;\n    }\n\n    void add_global_probe(texturecube<float, access::sample> specularLD,\n                          float4x4                           localDirToWorldCubemapDir,\n                          float                              environmentIntensity)\n    {\n        float3 n        = surface.normal;\n        float3 v        = surface.view;\n        float3 r        = reflect(-v, n); \n        float roughness = surface.roughness;\n\n#if USE_PBR_DOMINANT_DIRECTION\n        float alpha = roughness * roughness;\n        float smoothness = 1.0f - alpha;\n        float specularLerpFactor = (1. - smoothness * (sqrt(smoothness) + alpha));\n        float3 specularDominantNDirection = mix(r, n, specularLerpFactor); \n#else\n        float3 specularDominantNDirection = r;\n#endif\n        \n        \n        float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);\n        float3 dir = vfx::mat4_mult_float3(localDirToWorldCubemapDir, specularDominantNDirection);\n        float3 LD = specularLD.sample(vfx::linearSampler, dir, level(mipLevel)).rgb;\n        pbr.envSpecular += pbr.probeReflectance * LD * surface.ambientOcclusion * environmentIntensity;\n    }\n\n#ifdef USE_CLEARCOAT\n    void add_global_probeClearCoat(texturecube<float, access::sample> specularLD,\n                          float4x4                           localDirToWorldCubemapDir,\n                          float                              environmentIntensity)\n    {\n        float3 n = surface.clearCoatNormal;\n        \n        float3 v        = surface.view;\n        float3 r        = reflect(-v, n); \n        float roughness = surface.clearCoatRoughness;\n\n        \n        float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);\n        float3 LD = specularLD.sample(vfx::linearSampler, vfx::mat4_mult_float3(localDirToWorldCubemapDir, r), level(mipLevel)).rgb;\n\n        LD *= surface.ambientOcclusion;\n        \n        \n        float Fc = vfx_brdf_F_opt(0.04f, pbr.NoVClearCoat).r * surface.clearCoat;\n        float attenuation = 1.0f - Fc;\n        specular *= (attenuation * attenuation);\n        \n        specular += LD * environmentIntensity * pbr.probeReflectanceClearCoat * surface.clearCoat;\n    }\n#endif\n    \n    \n\n    void add_irradiance_from_selfIllum()\n    {\n        float selfIlluminationAO = saturate(mix(1.f, surface.ambientOcclusion, pbr.selfIlluminationOcclusion));\n        float3 irradiance = surface.selfIllumination.rgb;\n        \n        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        pbr.envDiffuse += selfIlluminationAO * irradiance * diffuseAlbedo;\n#else\n        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);\n        pbr.envDiffuse += selfIlluminationAO * irradiance * diffuseReflectance;\n#endif\n    }\n\n    void add_global_irradiance_from_sh(float4x4         localDirToWorldCubemapDir,\n#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)\n                                       sh2_coefficients shCoefficients)\n#else\n    sh3_coefficients shCoefficients)\n#endif\n    {\n        float3 n_sh_space = vfx::mat4_mult_float3(localDirToWorldCubemapDir, surface.normal);\n        float3 irradiance = shEvalDirection(float4(n_sh_space.xy, -n_sh_space.z, 1.), shCoefficients);\n        \n        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        pbr.envDiffuse += surface.ambientOcclusion * irradiance * diffuseAlbedo;\n#else\n        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);\n        pbr.envDiffuse += surface.ambientOcclusion * irradiance * diffuseReflectance;\n#endif\n    }\n\n    void add_global_irradiance_probe(texturecube<float, access::sample> irradianceTexture,\n                                     float4x4                           localDirToWorldCubemapDir,\n                                     float                              environmentIntensity)\n    {\n#if USE_PBR_DOMINANT_DIRECTION\n        float3 n = surface.normal;\n        float3 v = surface.view;\n        \n        \n        const half a = 1.02341h * surface.roughness - 1.51174h; \n        const half b = -0.511705h * surface.roughness + 0.755868h;\n        const half diffuseBendFactor = saturate((pbr.NoV * a + b) * surface.roughness);\n        float3 diffuseDominantNDirection = mix(n, v, diffuseBendFactor);\n#else\n        float3 diffuseDominantNDirection = n;\n#endif\n        \n        float3 n_cube_space = vfx::mat4_mult_float3(localDirToWorldCubemapDir, diffuseDominantNDirection);\n        float3 irradiance = irradianceTexture.sample(vfx::linearSampler, n_cube_space).rgb;\n        \n        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        pbr.envDiffuse += (surface.ambientOcclusion * environmentIntensity) * irradiance * diffuseAlbedo;\n#else\n        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);\n        pbr.envDiffuse += (surface.ambientOcclusion * environmentIntensity) * irradiance * diffuseReflectance;\n#endif\n    }\n\n#endif \n\n    \n\n    static constexpr sampler iesSampler = sampler(filter::linear, mip_filter::none, address::clamp_to_edge);\n    \n    float ies_attenuation(float3 l, vfx_light light, texture2d<half> iesTexture)\n    {\n#if USE_QUAT_FOR_IES\n        float3 v    = vfx::quaternion_rotate_vector(light.parameters.ies.light_from_view_quat, -l);\n#else\n        float3 v    = vfx::matrix_rotate(light.parameters.ies.light_from_view, -l);\n#endif\n        float phi   = (v.z * light.parameters.ies.scaleBias.x + light.parameters.ies.scaleBias.y);\n        float theta = atan2(v.y, v.x) * 0.5f * M_1_PI_F;\n        return iesTexture.sample(iesSampler, float2(phi, abs(theta))).r;\n    }\n\n    void add_ies(vfx_light light, texture2d<half> iesTexture)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= ies_attenuation(l, light, iesTexture);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    void add_ies(vfx_light light, texture2d<half> iesTexture, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= ies_attenuation(l, light, iesTexture);\n        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    \n\n    void add_area_rectangle(vfx_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n        float3 v = surface.view;\n        float3 n = surface.normal;\n        float3 p = surface.position;\n\n        \n        float3 tangent = normalize(v - n * dot(v, n));\n        float3 bitangent = cross(n, tangent);\n        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));\n\n        float3 lightCenter = light.shadowMatrix[3].xyz;\n        \n        \n        float sidedness = dot(light.dir, lightCenter - p);\n        if (light.parameters.area.rectangle.doubleSided == false && sidedness <= 0.f)\n            return;\n        \n        float3 lightRight = light.shadowMatrix[0].xyz * light.parameters.area.rectangle.halfExtents.x * sign(sidedness);\n        float3 lightTop   = light.shadowMatrix[1].xyz * light.parameters.area.rectangle.halfExtents.y;\n        \n        float4x3 cornerDirections = float4x3((lightCenter + lightRight + lightTop) - p,\n                                             (lightCenter + lightRight - lightTop) - p,\n                                             (lightCenter - lightRight - lightTop) - p,\n                                             (lightCenter - lightRight + lightTop) - p);\n\n        cornerDirections[0] = shadingSpaceTransform * cornerDirections[0];\n        cornerDirections[1] = shadingSpaceTransform * cornerDirections[1];\n        cornerDirections[2] = shadingSpaceTransform * cornerDirections[2];\n        cornerDirections[3] = shadingSpaceTransform * cornerDirections[3];\n\n        float diffuseAmount = pbr_area_light_eval_rectangle(cornerDirections);\n\n        float brdfNorm = 1.f;\n        float3x3 inverseLTCMatrix = vfx_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);\n\n        cornerDirections[0] = inverseLTCMatrix * cornerDirections[0];\n        cornerDirections[1] = inverseLTCMatrix * cornerDirections[1];\n        cornerDirections[2] = inverseLTCMatrix * cornerDirections[2];\n        cornerDirections[3] = inverseLTCMatrix * cornerDirections[3];\n\n        float specularAmount = brdfNorm * pbr_area_light_eval_rectangle(cornerDirections);\n\n        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); \n        \n        float3 lightColor = light.color.rgb;\n        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;\n        specular += specularAmount * lightColor * pbr.reflectance;\n#endif\n    }\n\n    void add_area_polygon(vfx_light light, texture2d_array<float> bakedDataTexture, device packed_float2 *vertexPositions)\n    {\n#ifdef USE_PBR\n        float3 v = surface.view;\n        float3 n = surface.normal;\n        float3 p = surface.position;\n\n        \n        float3 tangent = normalize(v - n * dot(v, n));\n        float3 bitangent = cross(n, tangent);\n        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));\n\n        float3 lightCenter = light.shadowMatrix[3].xyz;\n        \n        \n        float sidedness = dot(light.dir, lightCenter - p);\n        if (light.parameters.area.polygon.doubleSided == false && sidedness <= 0.f)\n            return;\n        \n        float3 lightRight = light.shadowMatrix[0].xyz * sign(sidedness);\n        float3 lightTop   = light.shadowMatrix[1].xyz;\n\n        p           = shadingSpaceTransform * p;\n        lightCenter = shadingSpaceTransform * lightCenter;\n        lightRight  = shadingSpaceTransform * lightRight;\n        lightTop    = shadingSpaceTransform * lightTop;\n\n        float diffuseAmount = pbr_area_light_eval_polygon(p, lightCenter, lightRight, lightTop, light.parameters.area.polygon.vertexCount, vertexPositions);\n\n        float brdfNorm = 1.f;\n        float3x3 inverseLTCMatrix = vfx_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);\n\n        p           = inverseLTCMatrix * p;\n        lightCenter = inverseLTCMatrix * lightCenter;\n        lightRight  = inverseLTCMatrix * lightRight;\n        lightTop    = inverseLTCMatrix * lightTop;\n\n        float specularAmount = brdfNorm * pbr_area_light_eval_polygon(p, lightCenter, lightRight, lightTop, light.parameters.area.polygon.vertexCount, vertexPositions);\n        \n        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); \n\n        float3 lightColor = light.color.rgb;\n        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;\n        specular += specularAmount * lightColor * pbr.reflectance;\n#endif\n    }\n\n    void add_area_line(vfx_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n        float3 v = surface.view;\n        float3 n = surface.normal;\n        float3 p = surface.position;\n\n        \n        float3 tangent = normalize(v - n * dot(v, n));\n        float3 bitangent = cross(n, tangent);\n        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));\n\n        float3 lightCenter = light.shadowMatrix[3].xyz;\n        float3 lightRight  = light.shadowMatrix[0].xyz * light.parameters.area.line.halfLength;\n\n        float2x3 cornerDirections = float2x3((lightCenter + lightRight) - p,\n                                             (lightCenter - lightRight) - p);\n\n        cornerDirections[0] = shadingSpaceTransform * cornerDirections[0];\n        cornerDirections[1] = shadingSpaceTransform * cornerDirections[1];\n\n        float diffuseAmount = pbr_area_light_eval_line(cornerDirections);\n\n        float brdfNorm = 1.f;\n        float3x3 inverseLTCMatrix = vfx_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);\n\n        cornerDirections[0] = inverseLTCMatrix * cornerDirections[0];\n        cornerDirections[1] = inverseLTCMatrix * cornerDirections[1];\n\n        float specularAmount = brdfNorm * pbr_area_light_eval_line(cornerDirections);\n\n        float3 ortho = normalize(cross(cornerDirections[0], cornerDirections[1]));\n        float ltcWidthFactor = 1.0 / length(vfx_ltc_matrix_invert_transpose(inverseLTCMatrix) * ortho);\n        specularAmount *= ltcWidthFactor;\n        \n        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); \n\n        float3 lightColor = light.color.rgb;\n        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;\n        specular += specularAmount * lightColor * pbr.reflectance;\n#endif\n    }\n\n    void add_area_ellipse(vfx_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n#endif\n    }\n\n    void add_area_ellipsoid(vfx_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n#endif\n    }\n};\n\n#endif \n"
- "#ifndef __VFXMetalDefines__\n#define __VFXMetalDefines__\n\nenum {\n    VFXVertexSemanticPosition,\n    VFXVertexSemanticNormal,\n    VFXVertexSemanticTangent,\n    VFXVertexSemanticColor,\n    VFXVertexSemanticBoneIndices,\n    VFXVertexSemanticBoneWeights,\n    VFXVertexSemanticTexcoord0,\n    VFXVertexSemanticTexcoord1,\n    VFXVertexSemanticTexcoord2,\n    VFXVertexSemanticTexcoord3,\n    VFXVertexSemanticTexcoord4,\n    VFXVertexSemanticTexcoord5,\n    VFXVertexSemanticTexcoord6,\n    VFXVertexSemanticTexcoord7\n};\n\nenum {\n    VFXGBufferAttachmentEmission,\n    VFXGBufferAttachmentNormal,\n    VFXGBufferAttachmentRoughnessMetalness,\n    VFXGBufferAttachmentAlbedo,\n    VFXGBufferAttachmentVelocity,\n    VFXGBufferAttachmentClearCoat,\n    VFXGBufferAttachmentSubsurface\n};\n\n\n\nstruct VFXWorldBuffer {\n    float4x4    viewTransform;\n    float4x4    inverseViewTransform; \n    float4x4    projectionTransform;\n    float4x4    viewProjectionTransform;\n    float4x4    viewToCubeTransform; \n    float4x4    lastFrameViewProjectionTransform;\n    float4      ambientLightingColor;\n    float4\t\tfogColor;\n    float3\t\tfogParameters; \n    float2      inverseResolution;\n    float       time;\n    float       sinTime;\n    float       cosTime;\n    float       random01;\n    float       motionBlurIntensity;\n\n    float       environmentIntensity;\n    float4x4    environmentTransform;\n    float4x4    inverseProjectionTransform;\n    float4x4    inverseViewProjectionTransform;\n\n    float2      nearFar; \n    float4      viewportSize; \n\n    float4x4    inverseTransposeViewTransform;\n\n    \n    float4      clusterScale; \n    \n    uint32_t    frame;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#endif \n"
- "#import <metal_stdlib>\nusing namespace metal;\n\n// VFX_USER_CODE_STARTS_HERE\n"
- "%0.array[vfx_clamp(%1, 0, "
- "%@-split%d"
- "%@-splitContainer"
- "%f %f %f %f"
- "%fx%f"
- "%range.lower_bound + float(vfx_random01(&%0) * float(%range.upper_bound - %range.lower_bound))"
- "%script_context.dt"
- "%script_context.isFirstFrame"
- "%script_context.time"
- "(%0 * VFX_PI) / 180.0f"
- "(%0 / VFX_PI) * 180.0f"
- "(%0.lower_bound, %0.upper_bound)"
- "(%1) ? %0 / %1 : "
- "(%2 >= %0) && (%2 <= %1)"
- "(&%0) * %radius)"
- "(&%0) - vfx_float3_half_one())"
- "(&%0) - vfx_float3_half_one()) * vfx_sqrt("
- "((id <MTLBufferBinding>)argument).bufferDataType == MTLDataTypeStruct"
- "(1.0 - exp(%exponent * %t)) / (1.0 - exp(%exponent))"
- "(1.0f - exp(%exponent * %t)) / (1.0f - exp(%exponent))"
- "(CFIndex)fxPass->_outputCount <= count"
- "(NSUInteger)bufferBinding.bufferSize == ((id<MTLBufferBinding>)argument).bufferDataSize"
- "(VFXArgumentBindingBlock)bufferBinding.bindBlock == nil"
- "(simd_float4[]) {}"
- "(void *script_context) {\n"
- ")]"
- ", &%temp0);\nauto %r0 = %0;"
- "-(vfx_cos(M_PI * %0) - 1.0f) / 2.0f"
- "-(vfx_cos(M_PI_F * %0) - 1) / 2"
- "--GBufferMaterial--"
- ".arrayOfAnySize cannot be used as a return type constraint."
- ".color"
- "// Compute Kernel Function\n\n"
- "// VFX_USER_CODE_STARTS_HERE"
- "// VFX_USER_CODE_STARTS_HERE\n"
- "///'@"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/AppleEngine/CFXCullingContext.c"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/AppleEngine/CFXEngineContext.m"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/CFXVFX/CFXVFXRenderContext.m"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/Core/CFXWorld.m"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/NewRenderer/VFXMTLLibraryManager.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/NewRenderer/VFXMTLRenderContext.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/NewRenderer/VFXMTLResourceManager+Compilation.m"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/CRenderGraphEngineContext.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/AuthoringPass.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/BloomPass.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/CompositePass.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/Culling.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/CullingPass.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/DebugCopyStereoPass.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/ManipulatorPass.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/MotionBlurPass.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/OverlayPass.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/RenderElementsPass.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/RenderGraphLibrary.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/SceneRenderer.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/ShadowMapAtlasPass.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/Transactions/CFXTransaction.c"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/ObjC/Texture sources/Custom sources/VFXCoreAnimationSource.m"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/ObjC/VFXRenderer.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/ObjC/VFXWorld.m"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/VFXRenderGraph/Sources/GPUResourceManager.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/VFXRenderGraph/Sources/RenderGraph.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/VFXRenderGraph/Sources/RenderGraphProcessing.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/VFXRenderGraph/Sources/RenderGraphProvider.mm"
- "/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/Views/VFXView.m"
- "/tmp/vfx-capture.gputrace"
- "0x"
- "1 - vfx_cos((%0 * M_PI_F) / 2)"
- "1$0\"0 0 0/$4"
- "1.0f - vfx_cos((%0 * M_PI) / 2.0f)"
- "3$0\"0 0"
- "3$0\"0 0 0/$4"
- "6$0\"0 0 0/$4"
- "<%@: %p <%f,%f,%f> | geometryIndex=%d node=%@ bone=%@>"
- "<%@: %p | world=%@ pointOfView=%@>"
- "<%@:%p \"%@\"\n"
- "<%@<%@>:%p \"%@\"\n"
- "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-\n<plist version=\"1.0\">\n<dict>\n\t<key>sequence</key>\n\t<array>\n\t\t<string>VFX_renderMirroredScene</string>\n\t\t<string>VFX_renderFloor</string>\n\t</array>\n\t<key>passes</key>\n\t<dict>\n\t\t<key>VFX_renderMirroredScene</key>\n\t\t<dict>\n\t\t\t<key>outputs</key>\n\t\t\t<dict>\n\t\t\t\t<key>depth</key>\n\t\t\t\t<string>VFX-Floor-depth</string>\n\t\t\t\t<key>color</key>\n\t\t\t\t<string>VFX-Floor-color</string>\n\t\t\t</dict>\n\t\t\t<key>draw</key>\n\t\t\t<string>DRAW_SCENE</string>\n\t\t\t<key>depthStates</key>\n\t\t\t<dict>\n\t\t\t\t<key>clear</key>\n\t\t\t\t<true/>\n\t\t\t</dict>\n\t\t\t<key>colorStates</key>\n\t\t\t<dict>\n\t\t\t\t<key>clear</key>\n\t\t\t\t<true/>\n\t\t\t</dict>\n\t\t</dict>\n\t\t<key>VFX_renderFloor</key>\n\t\t<dict>\n\t\t\t<key>depthStates</key>\n\t\t\t<dict>\n\t\t\t\t<key>clear</key>\n\t\t\t\t<false/>\n\t\t\t</dict>\n\t\t\t<key>colorStates</key>\n\t\t\t<dict>\n\t\t\t\t<key>clear</key>\n\t\t\t\t<false/>\n\t\t\t</dict>\n\t\t\t<key>inputs</key>\n\t\t\t<dict>\n\t\t\t\t<key>u_floorReflectionDepth</key>\n\t\t\t\t<string>VFX-Floor-depth</string>\n\t\t\t\t<key>u_floorReflectionColor</key>\n\t\t\t\t<string>VFX-Floor-color</string>\n\t\t\t\t<key>u_floorNormal</key>\n\t\t\t\t<string>u_floorNormal</string>\n\t\t\t\t<key>u_floorTangent</key>\n\t\t\t\t<string>u_floorTangent</string>\n\t\t\t\t<key>u_floorCenter</key>\n\t\t\t\t<string>u_floorCenter</string>\n\t\t\t\t<key>u_floorExtent</key>\n\t\t\t\t<string>u_floorExtent</string>\n\t\t\t\t<key>u_floorReflectivity</key>\n\t\t\t\t<string>u_floorReflectivity</string>\n\t\t\t\t<key>u_floor_viewport</key>\n\t\t\t\t<string>u_floor_viewport</string>\n\t\t\t\t<key>u_floorMVP_i</key>\n\t\t\t\t<string>u_floorMVP_i</string>\n\t\t\t\t<key>u_floorPlane</key>\n\t\t\t\t<string>u_floorPlane</string>\n\t\t\t\t<key>u_floorFalloff</key>\n\t\t\t\t<string>u_floorFalloff</string>\n\t\t\t\t<key>u_floorFalloffStart</key>\n\t\t\t\t<string>u_floorFalloffStart</string>\n\t\t\t</dict>\n\t\t\t<key>draw</key>\n\t\t\t<string>DRAW_GEOMETRY</string>\n\t\t\t<key>installViewport</key>\n\t\t\t<false/>\n\t\t</dict>\n\t</dict>\n\t<key>symbols</key>\n\t<dict>\n\t\t<key>u_floorNormal</key>\n\t\t<dict>\n\t\t\t<key>type</key>\n\t\t\t<string>float3</string>\n\t\t</dict>\n\t\t<key>u_floorTangent</key>\n\t\t<dict>\n\t\t\t<key>type</key>\n\t\t\t<string>float4</string>\n\t\t</dict>\n\t\t<key>u_floorCenter</key>\n\t\t<dict>\n\t\t\t<key>type</key>\n\t\t\t<string>float3</string>\n\t\t</dict>\n\t\t<key>u_floorExtent</key>\n\t\t<dict>\n\t\t\t<key>type</key>\n\t\t\t<string>float2</string>\n\t\t</dict>\n\t\t<key>u_floor_viewport</key>\n\t\t<dict>\n\t\t\t<key>type</key>\n\t\t\t<string>float4</string>\n\t\t</dict>\n\t\t<key>u_floorReflectivity</key>\n\t\t<dict>\n\t\t\t<key>type</key>\n\t\t\t<string>float</string>\n\t\t</dict>\n\t\t<key>u_floorMVP_i</key>\n\t\t<dict>\n\t\t\t<key>type</key>\n\t\t\t<string>float4x4</string>\n\t\t</dict>\n\t\t<key>u_floorPlane</key>\n\t\t<dict>\n\t\t\t<key>type</key>\n\t\t\t<string>float4</string>\n\t\t</dict>\n\t\t<key>u_floorFalloff</key>\n\t\t<dict>\n\t\t\t<key>type</key>\n\t\t\t<string>float</string>\n\t\t</dict>\n\t\t<key>u_floorFalloffStart</key>\n\t\t<dict>\n\t\t\t<key>type</key>\n\t\t\t<string>float</string>\n\t\t</dict>\n\t</dict>\n\t<key>targets</key>\n\t<dict>\n\t\t<key>VFX-Floor-depth</key>\n\t\t<dict>\n\t\t\t<key>type</key>\n\t\t\t<string>depth</string>\n\t\t</dict>\n\t\t<key>VFX-Floor-color</key>\n\t\t<dict>\n\t\t\t<key>type</key>\n\t\t\t<string>color</string>\n\t\t\t<key>format</key>\n\t\t\t<string>rgba</string>\n\t\t</dict>\n\t</dict>\n</dict>\n</plist>\n"
- "<CFXAllocator>"
- "<CFXAnimationCluster %p>"
- "<CFXAnimationClusterKeyframes %p>"
- "<CFXAnimationClusterNode %p>"
- "<CFXAnimationEvents>"
- "<CFXAnimationGroup %p animations:%@>"
- "<CFXAnimationManager %p>"
- "<CFXAnimationNode %p>"
- "<CFXAnimationPlayer %p>"
- "<CFXArray %p:, %d objects>"
- "<CFXAvoidOccluderConstraintDelegate %p>"
- "<CFXBlendStates %p targetCount:%d needsBlendColor:%d\n"
- "<CFXCamera:%p \"%@\" custom, [%.3f %.3f %.3f %.3f ; %.3f %.3f %.3f %.3f ; %.3f %.3f %.3f %.3f ; %.3f %.3f %.3f %.3f]>"
- "<CFXCamera:%p \"%@\" ortho, near:%.3f far:%.3f scale: %.3f>"
- "<CFXCamera:%p \"%@\" persp, near:%.3f far:%.3f fov:%.3f>"
- "<CFXCameraEffect Bloom:%p"
- "<CFXCameraEffect ChromaticTransform:%p"
- "<CFXCameraEffect ColorGrading:%p"
- "<CFXCameraEffect DoughnutBokeh:%p"
- "<CFXCameraEffect Exposure:%p"
- "<CFXCameraEffect Grain:%p"
- "<CFXCameraEffect LensBlur:%p"
- "<CFXCameraEffect MotionBlur:%p"
- "<CFXCameraEffect SSAO:%p"
- "<CFXCameraEffect ToneMapping:%p"
- "<CFXCameraEffect Vignetting:%p"
- "<CFXCameraEffect depthOfField:%p"
- "<CFXCommonProfile %p :"
- "<CFXConstraint %@ %p>"
- "<CFXConstraintAvoidOccluder %p>"
- "<CFXConstraintController>"
- "<CFXConstraintLookAt %p>"
- "<CFXConstraintManagerRef>"
- "<CFXConvexPolyhedron %p>"
- "<CFXCoreEntityHandle>"
- "<CFXCoreEntityManager>"
- "<CFXCullingSystem %p>"
- "<CFXDeformerStack %p (geometry: %p)\n"
- "<CFXDeformerStack %p>"
- "<CFXDynamicBatchingSystem %p>"
- "<CFXEdgeArray>"
- "<CFXEngineContext>"
- "<CFXEngineNotificationQueue %p>"
- "<CFXEnginePipeline %p>"
- "<CFXEntity:%p>"
- "<CFXFXPass %@>"
- "<CFXFXPassInput %@>"
- "<CFXFXProgram %p [vertex:`%@` fragment:`%@` macros:%@]>"
- "<CFXFXRenderGraph>"
- "<CFXFXSampler>"
- "<CFXFloor>"
- "<CFXForceField %p> Type:%d"
- "<CFXGenericSource %lx>"
- "<CFXGlyph '%@' in '%@'>"
- "<CFXHitTestResult %@ %f,%f,%f>"
- "<CFXImage %p src:%@ [%fx%f]>"
- "<CFXImage %p src:%p [%fx%f]>"
- "<CFXImageProxy>"
- "<CFXIndexStore>"
- "<CFXKeyValueStore>"
- "<CFXKeyframeController %p>"
- "<CFXKeyframedAnimation %p>"
- "<CFXLOD>"
- "<CFXLight %p> Type:%@"
- "<CFXLight %p> Type:%@ CastsShadow(Samples:%d Cascade:%d)"
- "<CFXLightProbesSystem %p>"
- "<CFXLightingSystem %p>"
- "<CFXMaterial %p : \"%@\", "
- "<CFXMaterialProperty>"
- "<CFXMesh %p \"%@\"\n"
- "<CFXMeshElement %p type:%@ primCount:%d channels:%d indexBytes:%d offset:%d acmr:%f inst:%d dataSize:%d shared:%p>"
- "<CFXMeshElementEditor>"
- "<CFXMeshSource %p(%@) data:(%p) mut:%d count:%ld type:%@ divisor:%d mtl:%d offset:%d stride:%d"
- "<CFXModelTarget>"
- "<CFXModelValueStorage>"
- "<CFXModelValueStorageItem %p>"
- "<CFXMorph %p \"%@\"\n"
- "<CFXMorpher %p baseGeom:%p state:%d\n"
- "<CFXNode:%p \"%@\"\n"
- "<CFXProgramHashCode %p : "
- "<CFXProgramHashCodeStore %p>"
- "<CFXRasterizerStates %p> ZRead:%d ZWrite:%d ZFunc:%d cull:%d fill:%d"
- "<CFXRaytracingSystem %p>"
- "<CFXRendererElementStore %p>"
- "<CFXResourceCache 0x%lx>"
- "<CFXShaderModifier %p language:%s, entryPoint:\"%d\" flags:%x\n"
- "<CFXShape '%@'>"
- "<CFXSimpleAnimation>"
- "<CFXSkin %p name:%@ joint:%d weight:%d vertexCount:%d\n"
- "<CFXSkinner %p skeleton:%p jointCount:%d cpuReady:%d\n"
- "<CFXSortSystem %p>"
- "<CFXSourceAccessor %lx>"
- "<CFXSpanAllocator %p>"
- "<CFXSubdivisionOsdGPURuntimeDataRef %p>"
- "<CFXTextFrame>"
- "<CFXTextLine>"
- "<CFXTextureProxy>"
- "<CFXTextureSampler>"
- "<CFXTimingFunction>"
- "<CFXTransaction>"
- "<CFXTransformTree %p>"
- "<CFXTriangulationInfo>"
- "<CFXVFXLightUpdateCommand>"
- "<CFXVFXRenderContext>"
- "<CFXValue %p - %@ ptr:%p >"
- "<CFXWorld>"
- "@\"<CAMetalDrawable>\""
- "@\"<MTLAccelerationStructure>\"32@0:8@\"MTLAccelerationStructureDescriptor\"16Q24"
- "@\"<MTLAccelerationStructure>\"32@0:8Q16Q24"
- "@\"<MTLBuffer>\"40@0:8Q16Q24Q32"
- "@\"<MTLComputeCommandEncoder>\"8@?0"
- "@\"<MTLResource>\"8@?0"
- "@\"<MTLTexture>\"32@0:8@\"MTLTextureDescriptor\"16Q24"
- "@\"<MTLTexture>\"8@?0"
- "@\"<UIFocusEnvironment>\"16@0:8"
- "@\"<UIFocusItemContainer>\"16@0:8"
- "@\"<VFXRERenderTargetInfo>\"16@0:8"
- "@\"<VFXShadable>\""
- "@\"<VFXWorldRemotePreviewDelegate>\""
- "@\"AVPlayerItemVideoOutput\""
- "@\"CADisplayLink\""
- "@\"CIImage\""
- "@\"MTKView\""
- "@\"MTLStencilDescriptor\"16@0:8"
- "@\"NSString\"24@0:8@\"NSString\"16"
- "@\"NSString\"24@0:8@\"UIFocusUpdateContext\"16"
- "@\"UIFocusEffect\"16@0:8"
- "@\"UIView\"16@0:8"
- "@\"VFXCameraEffectSSAO\""
- "@\"VFXEntityObject\""
- "@\"VFXMesh\""
- "@\"_TtC3VFX24VFXRemotePreviewEndpoint\""
- "@128@0:8{?=^{__CFXFXProgram}^{__CFXMaterial}^{__CFXGeometry}^{__CFXFXPass}^{__CFXFXPass}@^{__CFXBlendStates}^{__CFXNode}CCCCCC@{?=C@?}Q}16@120"
- "@24@0:8^{__CFDictionary=}16"
- "@24@0:8^{__CFXCamera={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}{?=b1b1b1b3ffff{?=[4]}{?=[4]}}fff^{__CFXCameraEffectDepthOfField}^{__CFXCameraEffectMotionBlur}^{__CFXCameraEffectGrain}^{__CFXCameraEffectExposure}^{__CFXCameraEffectToneMapping}^{__CFXCameraEffectBloom}^{__CFXCameraEffectVignetting}^{__CFXCameraEffectLensBlur}^{__CFXCameraEffectColorFringe}^{__CFXCameraEffectColorGrading}^{__CFXCameraEffectChromaticTransform}^{__CFXCameraEffectDoughnutBokeh}^{__CFXCameraEffectSSAO}b1b1b1b1{?=[4]}Q^{__CFXFXRenderGraph}}16"
- "@24@0:8^{__CFXCoreEntityHandle={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFString}^{__CFDictionary}^{__CFArray}B^v}16"
- "@24@0:8^{__CFXFloor={__CFXGeometry={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXMesh}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}ffffifffQ}16"
- "@24@0:8^{__CFXGeometry={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXMesh}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16"
- "@24@0:8^{__CFXImage=}16"
- "@24@0:8^{__CFXMaterialProperty={__CFRuntimeBase=QAQ}(?=^{__CFXImage}^{__CFXImageProxy}^{__CFXTexture}^v^v{CFXColor4=(?=[4f]{?=ffff})}^v)^vq^vb8b1b4c^{__CFXTextureSampler}^{?}fi^v}16"
- "@24@0:8^{__CFXMeshElement={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}II^{__CFXMeshElement}CCC{?=c^{__CFData}I^I^{?}SCB}^vfff^v^{__CFXMeshSource}[2]^{?}I}16"
- "@24@0:8^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1{?={?=SS}I}^{?}^{__CFXGeometry}^{__CFXDeformerStack}f{?=}}16"
- "@24@0:8^{__CFXParametricGeometry={__CFXGeometry={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXMesh}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=fffffffffiiiiiiiiiiI}{?=^?^?^?^?^?^?}^{__CFData}}16"
- "@24@0:8^{__CFXShapeGeometry={__CFXGeometry={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXMesh}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__CFXMesh}[32C]}16"
- "@24@0:8^{__CFXTextGeometry={__CFXShapeGeometry={__CFXGeometry={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXMesh}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__CFXMesh}[32C]}{?=^{__CTFrame}^v^viiBBB{CGRect={CGPoint=dd}{CGSize=dd}}}}16"
- "@24@0:8i16B20"
- "@32@0:8@16^{__CFDictionary=}24"
- "@32@0:8Q16^{__CFDictionary=}24"
- "@32@0:8^{__CFXGeometry={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXMesh}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16@24"
- "@32@0:8^{__CFXImage=}16B24i28"
- "@344@0:8{?={?=^{__CFXFXProgram}^{__CFXMaterial}^{__CFXGeometry}^{__CFXFXPass}^{__CFXFXPass}@^{__CFXBlendStates}^{__CFXNode}CCCCCC@{?=C@?}Q}@{?=[8Q]QQC}^{__CFXBlendStates}[8Q]C@@@@@?CBBB}16"
- "@40@0:8@16^{__CFXEngineContext=}24@32"
- "@40@0:8Q16Q24Q32"
- "@40@0:8^{?=CCCb1b1b1b1b1b1[4C]}1624Q32"
- "@40@0:8^{__CFXGeometry={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXMesh}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16^{__CFXMesh=}24@32"
- "@40@0:8q16^B24^B32"
- "@44@0:8@16@24B32Q36"
- "@44@0:8@16^{__CFXEngineContext=}24B32@36"
- "@44@0:8q16f2428"
- "@48@0:8@16@24Q32@?40"
- "@48@0:8^{__CFXEngineContext=}16^{__CFXTextureSampler={__CFRuntimeBase=QAQ}iiiiiifCiQ}24^d32^{?=BB}40"
- "@48@0:8^{__CFXImageProxy={__CFRuntimeBase=QAQ}{?=^?^?^?^?}^vC}16^{__CFXTextureSampler={__CFRuntimeBase=QAQ}iiiiiifCiQ}24^{__CFXEngineContext=}32^B40"
- "@48@0:8^{__CFXMaterialProperty={__CFRuntimeBase=QAQ}(?=^{__CFXImage}^{__CFXImageProxy}^{__CFXTexture}^v^v{CFXColor4=(?=[4f]{?=ffff})}^v)^vq^vb8b1b4c^{__CFXTextureSampler}^{?}fi^v}16^{__CFXEngineContext=}24^B32^B40"
- "@52@0:8^{__CFXImage=}16^{__CFXTextureSampler={__CFRuntimeBase=QAQ}iiiiiifCiQ}24i32^{__CFXEngineContext=}36^B44"
- "@80@0:8@16@24@32@40^v48@56@64@72"
- "@inline(__always) "
- "ARVFXView"
- "Add TextureCPURuntime on #"
- "AffectedByGlobalForces"
- "Ai"
- "Assertion '%s' failed. Argument with the same name cannot have different class type"
- "Assertion '%s' failed. Assumed count is 1"
- "Assertion '%s' failed. CFXAnimatableParamControllerGetParamDescription - address out of bounds"
- "Assertion '%s' failed. CFXDeformerTransforms is not supported when instancing is active"
- "Assertion '%s' failed. CFXFXRenderGraphGetPassAtIndex index %ld is out of bounds (%ld)"
- "Assertion '%s' failed. CFXModelValueStorageUpdateModelValueFromPresentationValue - unexpected class"
- "Assertion '%s' failed. CFXRendererElementStoreDeallocateSpanForNodeGeometryLOD unexpected lod count"
- "Assertion '%s' failed. CFXTransformSetValue offset out of bounds"
- "Assertion '%s' failed. Cannot declare twice the same symbol (%@)"
- "Assertion '%s' failed. Coordinate space inconsistency"
- "Assertion '%s' failed. Fov is larger that 180 degrees. this can't be"
- "Assertion '%s' failed. Internal consistency error - unexpected sparse moprh target"
- "Assertion '%s' failed. Internal consistency error: number of indices should be a multiple of number of channels"
- "Assertion '%s' failed. Layered rendering is not supported"
- "Assertion '%s' failed. Morph target has a vertex count different from the base geometry"
- "Assertion '%s' failed. Must declare upfront"
- "Assertion '%s' failed. Node should been tracked by this geometry"
- "Assertion '%s' failed. Node should not already been tracked by this geometry"
- "Assertion '%s' failed. Only supports pass buffer arguments as struct"
- "Assertion '%s' failed. Presentation instance query targets the wrong world"
- "Assertion '%s' failed. Unsupported layout"
- "Assertion '%s' failed. Variable rasterization rate is not supported on this device"
- "Assertion '%s' failed. __AllocateSpansForNodeGeometryLOD unexpected lod count"
- "Assertion '%s' failed. _createSubSource - inconsistent data length"
- "Assertion '%s' failed. _finalizeSplit - inconsistent data length"
- "Assertion '%s' failed. buffers of the same name in different stages need to have the same type"
- "Assertion '%s' failed. compiling a renderGraph twice"
- "Assertion '%s' failed. inconsistency in _finalizeSplit"
- "Assertion '%s' failed. pass:_setupInput unexpected type"
- "Assertion '%s' failed. the cfxImage should have been cleared when setting a layer"
- "Assertion '%s' failed. unexpected error in CFXFXPassSetInputs"
- "Assertion '%s' failed. unexpected error in CFXFXPassSetOutput"
- "AsyncBlit"
- "B24@0:8@\"UIFocusUpdateContext\"16"
- "B24@0:8^{__CFXNode=}16"
- "B24@?0^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1{?={?=SS}I}^{?}^{__CFXGeometry}^{__CFXDeformerStack}f{?=}}8^B16"
- "B24@?0^{__CFXShapeBoundary=^{__CFXShapeVertex}IIffffi}8^{__CFXShapeBoundary=^{__CFXShapeVertex}IIffffi}16"
- "B40@0:8@16@24@32"
- "B40@0:8^{?=CCCb1b1b1b1b1b1[4C]}1624Q32"
- "B40@0:8{CGSize=dd}16d32"
- "B48@0:8^{__CFXImage=}16@24@32i40B44"
- "B52@0:8@16B24@28@36^@44"
- "B56@0:8@16@24@32@?40^@48"
- "B60@0:8@16@24@32B40@?44^@52"
- "B68@0:8@16@24@32B40@44@?52^@60"
- "Buffer too large "
- "Buffer too small "
- "Bug: Behavior Graph compilation failed without any diagnostics"
- "CFDictionaryGetValue(renderGraph->_parameterStorage->parameters, symbolName) == 0"
- "CFGetTypeID(target->_owner) == CFXNodeGetTypeID()"
- "CFXCameraEffectSSAO"
- "CFXEngineContextGetRenderContext(engineContext)"
- "CFXFXCIFilterPass.json"
- "CFXFXCIFilterPassMetal.json"
- "CFXFXCIFilterPassMetalRenderGraph.json"
- "CFXFXFloorPass.plist"
- "CFXFXPass"
- "CFXFXPassInput"
- "CFXFXProgram"
- "CFXFXRenderGraph"
- "CFXFXSampler"
- "CFXGeometry"
- "CFXTextureSampler"
- "CFXVFXLightUpdateCommand"
- "CFXVFXRenderContext"
- "CFXVFXUpdateRendererElement"
- "Cannot add an Entity that is already in a world"
- "Cannot create a blitEncoder"
- "Cannot create a computeEncoder"
- "Cannot create encoder current command buffer!"
- "Cannot cull transparent particles without colors"
- "Cannot generate sorting keys with .unsorted"
- "Clear drawable"
- "ClearCoatUpscale"
- "ClearCoatUpscaleDistance"
- "ColorOverPosition"
- "ColorOverTexture"
- "ColorOverVelocity"
- "Compute kCFXGeometryTessellatorTypeConstrainedEdgeLength tessellation factors"
- "ComputeNN.CPU"
- "Copy downsample color input"
- "Copy downsample depth input"
- "Copy radiance input"
- "Copy raytrace normal input"
- "Copy reflectance roughness input"
- "Copy to final"
- "Could not allocate texture "
- "Could not allocate texture NA with "
- "DDGI Debug output"
- "DDGIDebugPass"
- "DDGIPass"
- "DDGI_DEBUG_PASS"
- "DDGI_depth_0"
- "DDGI_depth_1"
- "DDGI_irradiance_0"
- "DDGI_irradiance_1"
- "DEPTH_PREPASS"
- "DOF blur CoC X"
- "DOF blur CoC Y"
- "DOF downsample CoC"
- "DOF final"
- "DOF_COC_BLUR_OUTPUT_"
- "DOF_COC_DOWNSAMPLE"
- "DOF_DOWNSAMPLE_SORT_COC_PASS"
- "DOF_FINAL"
- "DOWNSAMPLE DEPTH INPUT"
- "DebugCopyStereoPass"
- "Depth prepass"
- "DirectLightingResolve"
- "DisplayLink"
- "DisplayLink (coalesced)"
- "DistanceConstraint"
- "DoNotSave should have been filtered out already!"
- "Draw bucket size"
- "E"
- "EmitterBuffer"
- "Error: 'type' is required for symbol %@"
- "Error: Argument '%@' : failed to write value to Metal buffer (%@)"
- "Error: Argument '%@' : mismatch between the NSData and the buffer size %ld != %ld"
- "Error: Argument '%@' : only NSData and NSValue are supported for shadable value storage (found '%@'). Please make sure that your custom shader modifier uniform types match the custom properties of the shadable object"
- "Error: CFXAnimationNodeChangeSpeed - can't ensure animation continuity since animation manager is dead"
- "Error: CFXAnimationToCAAnimation: unsupported animation"
- "Error: CFXEngineContextRenderRenderGraph - unknown draw instruction"
- "Error: CFXFXRenderGraphAppendPass out of capacity"
- "Error: CFXFXRenderGraphCompile - invalid description (sequence missing or empty) %@"
- "Error: CFXFXRenderGraphGetValueForSymbol - unknown param named %@"
- "Error: CFXFXRenderGraphSetValueForSymbol - expect an image for paramName %@"
- "Error: CFXFXRenderGraphSetValueForSymbol - unknown param named %@"
- "Error: CFXMeshSourceCreateCopyWithComponentsBaseType: unsupported type"
- "Error: CFXMorphConvertToCalculationMode: no base source"
- "Error: CFXTransformSetValue unexptected component index %d"
- "Error: Cannot use a program because shader modifiers are set"
- "Error: Compiler error while building render pipeline state for node %@:\n%@"
- "Error: Conversion from other types than float is not supported"
- "Error: Conversion of an interleaved source is not supported, please convert your sources before interleaving"
- "Error: Could not create texture with descriptor : %@"
- "Error: Deindexer failed - Source %p (%@) has no original data at index %u"
- "Error: Failed to archive geometry's custom attributes. %@ %@"
- "Error: Failed to create snapshot with error %@"
- "Error: Failed to load common profile chache library : %@"
- "Error: Invalidating OpenSubdiv runtime data of geometry %@"
- "Error: Over-detach of instance %@ from world %@"
- "Error: Unsupported shadable class (%@) uses `#pragma transparent`"
- "Error: VFXDecodemage: invalid archive"
- "Error: VFXMTLRenderContext initWithDevice : device should not be nil"
- "Error: VFXMeshPrimitiveTypeFromSCNPrimitiveType - unknown type"
- "Error: VFXMeshSourceSemanticFromSCNSemantic - unknown semantic"
- "Error: We did not succeed in locating all the joints, so do not update the geometry as it might be worse if we use the wrong bones."
- "Error: World %@ is modified within a rendering callback of another world (%@). This is not allowed and may lead to crash"
- "Error: _CFXModelPathResolveDynamicParameter unknown path %@"
- "Error: _applyNewEntityForNode - node already has an entity"
- "Error: _bufferTypeFromName - unknown output type: %@"
- "Error: _convertOutputsDescriptionToOutputs - unknown output type: %@"
- "Error: _modelSourceWithSource - Conversion failed"
- "Error: array for material property contents must have 6 elements"
- "Error: can't create a skinner with no base mesh"
- "Error: can't set a bounding box to a Mesh (readonly)"
- "Error: cannot renderMesh without a vaid passDescriptor"
- "Error: custom color grading not implemented"
- "Error: description for input named %@ is missing"
- "Error: display link thread seems stuck"
- "Error: error importing VFX world: %@"
- "Error: failed compiling shader:\n%@"
- "Error: failed to find cloned skeleton in cloned tree"
- "Error: failed to load dictionary named %@"
- "Error: framebuffer height (%d) exceeds device's limit (%d), clamping"
- "Error: framebuffer height must be > 0"
- "Error: framebuffer width (%d) exceeds device's limit (%d), clamping"
- "Error: framebuffer width must be > 0"
- "Error: incorrect buffer size  for attachments vertex [%d] fragments [%d]. Expected:%d Provided:%d"
- "Error: invalid geometry detected - skip CFXCreateTangentsWithGeometryOptimized"
- "Error: invalue description for input named %@ - expect a dictionary"
- "Error: leaking materials array"
- "Error: missing value for attachment \"%@\" [vertex: %d fragment: %d]"
- "Error: node::setTransform - invalid matrix"
- "Error: node::setTransform - invalid matrix (nan in scale)"
- "Error: pass has no storage for input %@"
- "Error: renderGraph should not be null"
- "Error: target mesh has a different number of vertices (%d != %d)"
- "Error: too many blend states: max render target is %d"
- "Error: unknown blend factor named %@"
- "Error: unknown blend op named %@"
- "Error: unknown cull mode named %@"
- "Error: unknown depth comparison function named %@"
- "Error: unnamed source material property"
- "Execute"
- "Explicit render"
- "Failed allocating MTLBuffer of "
- "Failed creating pcache-jointindices buffer with size: "
- "Failed loading VFXBRDF in Bundle"
- "Failed loading VFXDefaultIrradiance in Bundle"
- "Failed loading VFXDefaultRadiance in Bundle"
- "FluidAbsorbRender"
- "FluidBlur"
- "FluidCompositeRender"
- "FluidSpheresRender"
- "Format: %@ ; Size: %gx%g[%d] ; Texture: <%p> ; [rc:%ld/ts:%ld]\n"
- "GPUToolBox"
- "GdXjx1ixZYvN9Gg8iSf68A"
- "Geometry source has invalid bounds"
- "GrowEmitterRuntime"
- "IOR"
- "ImplicitEntityAsset"
- "ImplicitWorldReference"
- "Info: Shaders without a vertex function are not allowed"
- "Info: [VFXView] Using separate work group"
- "Info: pass named %@ appears to be useless - skipping"
- "InstanceBuffer"
- "Jittering is not supported on VFXMetalLayer"
- "LOBE_FOOTPRINT"
- "LightBuffer"
- "LoadImage (PVRTC)"
- "LocalBoxCollider Collider"
- "MDL material convertion: property not implemented yet: "
- "MPSGaussianBlur color input resolve"
- "MTKViewDelegate"
- "MTLHeap"
- "MaterialBuffer"
- "MeshBuffer"
- "MeshElementBuffer"
- "Metal"
- "Metal pipelines script written in \""
- "Missing fragment function"
- "Missing material runtime"
- "Missing renderer"
- "NORMAL"
- "NORMAL_PREPASS"
- "Name: %@ ; %@"
- "No pass storage for binding %@"
- "No registered texture for binding %@ and symbol \"%@\" in pass or render graph.\nPass: (%p)\n"
- "No sampler found for binding %@ and input %@"
- "No texture or image provided for binding %@ by sampler %@.\nTexture: %@\nImage: %@"
- "NodeTransformController"
- "NodeVisibilityController"
- "Only supports 2D textures"
- "OpacityOverVelocity"
- "OrientationConstraint"
- "ParticleClassSpawnID"
- "ParticleLifetime"
- "PointCacheFromVertex"
- "PositionOverTexture"
- "Post process input normal"
- "Post process input radiance"
- "Post process input reflectance roughness"
- "PrepareCB"
- "Published attachment "
- "Q48@0:8@\"<VFXMTLDeformerUpdateComputeContext>\"16@\"<MTLBuffer>\"24@\"<MTLBuffer>\"32@\"<MTLBuffer>\"40"
- "Q48@0:8@16@24@32@40"
- "QuadraticEaseInOut"
- "QuadraticEaseOut"
- "QuarticEaseInOut"
- "QuinticEaseInOut"
- "RADIANCE"
- "RADIANCE COPY"
- "RAYTRACE NORMAL INPUT"
- "REFLECTANCE ROUGHNESS"
- "REFLECTANCE ROUGHNESS COPY"
- "RTClearCoatSpatialReSTIRPass"
- "RTClearCoatTemporalDenoisePass"
- "RTClearCoatTracePass"
- "RTClearCoatUpscalePass"
- "RTDirectLightingDenoisePass"
- "RTDirectLightingSpatialReSTIRPass"
- "RTIndirectDiffuseSpatialReSTIRPass"
- "RTSpecularSpatialReSTIRPass"
- "RTSpecularTemporalDenoisePass"
- "RTSpecularTracePass"
- "RTSpecularUpscalePass"
- "RT_CLEARCOAT_SPATIAL_RESTIR"
- "RT_CLEARCOAT_TEMPORAL_DENOISE"
- "RT_CLEARCOAT_TRACE"
- "RT_CLEARCOAT_UPSCALE"
- "RT_DIRECT_LIGHTING_DENOISE"
- "RT_INDIRECT_DIFFUSE_SPATIAL_RESTIR"
- "RT_SPECULAR_SPATIAL_RESTIR"
- "RT_SPECULAR_TEMPORAL_DENOISE"
- "RT_SPECULAR_UPSCALE"
- "Received command buffer error status clear texture "
- "RenderFrame (Layer)"
- "RenderOutput"
- "RenderPipelineState label is malformed"
- "Renderer.uploadLock"
- "ResolveResolution"
- "SM_Geo,"
- "SSAO-COMPUTE"
- "SSAOUpscalePass"
- "SSAO_UPSCALE"
- "SSAO_UPSCALE_OUTPUT"
- "SSR"
- "SSR BLUR OUTPUT "
- "SSR COLOR COPY"
- "SSR Composite output"
- "SSR blur X"
- "SSR blur Y"
- "SSR composite"
- "SSR downsample"
- "SSR raytrace"
- "SSR_BLUR_PASS"
- "ScreenSpaceRadius"
- "ShowNearestNeighbours"
- "Sine Move Action"
- "SizeOverVelocity"
- "SpecularUpscale"
- "SpecularUpscaleDistance"
- "T"
- "T@\"<MTLBuffer>\",R,N,V_buffer"
- "T@\"<MTLCommandBuffer>\",&,N,V_commandBuffer"
- "T@\"<UIFocusEnvironment>\",R,W,N"
- "T@\"<UIFocusItemContainer>\",R,N"
- "T@\"<VFXRERenderTargetInfo>\",N,R"
- "T@\"<VFXShadable>\",R,N,V_shadable"
- "T@\"<VFXStencilInfo>\",N,R"
- "T@\"MTLStencilDescriptor\",N,R"
- "T@\"NSArray\",C,N,V_viewpoints"
- "T@\"NSObject<OS_dispatch_group>\",R,N"
- "T@\"NSString\",&,N,V_type"
- "T@\"NSString\",&,N,Vtag"
- "T@\"NSString\",?,R,C,N"
- "T@\"NSString\",R,N,Videntifier"
- "T@\"UIFocusEffect\",?,R,C,N"
- "T@\"UIView\",?,R,W,N"
- "T@\"VFXEntityObject\",R,N"
- "T@\"VFXMTLResourceManager\",N,R"
- "T@\"VFXMesh\",R,N"
- "T@\"VFXNode\",&,N,Vdestination"
- "T@\"VFXNode\",&,N,Vsource"
- "T@\"VFXState\",R,N,V_sourceState"
- "T@\"VFXState\",R,N,V_targetState"
- "T@\"VFXStateManager\",W,N,V_manager"
- "T@\"VFXWorld\",N,W,Vworld"
- "T@,&,N,V_texture"
- "TB,N,GisAppliedOnCompletion"
- "TB,N,V_shouldPresentAfterMinimumDuration"
- "TB,N,V_simulateCommandBufferFailure"
- "TB,N,V_syncTimeWithCoreAnimation"
- "TC,N,R"
- "TC,R,N"
- "TQ"
- "TQ,N,R"
- "T^v,R,N,V_frameTexturePool"
- "T^{VFXMTLComputeCommandEncoder=@@^{VFXMTLBufferPool}I},R,N"
- "Td,N,V_time"
- "TexturePlaceholder"
- "Ti,R,N"
- "Tq,N,V_referenceCount"
- "Tq,N,V_timeStamp"
- "Tq,N,VgeometryModificationCount"
- "Tq,N,VinputsCount"
- "Tq,N,Voperation"
- "TransformPosition"
- "Trying to add a reference an an invalid Entity "
- "Ts,N,Vtype"
- "T{?=[4]},N,Vtransform"
- "UIFocusEnvironment"
- "UIFocusItem"
- "USE_FALLOFF"
- "USE_FALLOFF_START"
- "USE_NORMALS_OUTPUT"
- "USE_RADIANCE_OUTPUT"
- "USE_REFLECTANCE_ROUGHNESS_OUTPUT"
- "USE_REVERSE_Z"
- "USE_SKINNING"
- "USE_TRANSPARENCY"
- "Unable to find texture for binding %@ (\"%@\") and effect materialProperty %@ derived from value %@ (geometry=%@, material=%@)"
- "Unable to find texture for binding %@ and effect materialProperty %@"
- "Unreachable code: Asking to created a texture with an invalid format!"
- "Unreachable code: CFXEngineContextGetTextureFromHandle - no render context"
- "Unreachable code: CFXEngineContextGetTextureWithName"
- "Unreachable code: Invalid CommonProfile generator"
- "Unsupported Trigger Type"
- "VFX - Blit for VFXCompositorRendererLayoutLayered"
- "VFX Studio"
- "VFX could not attribute memory (mach_memory_entry_ownership failed)"
- "VFX update command buffer"
- "VFX-SSAO"
- "VFX-floor-color-%p"
- "VFX-floor-depth-%p"
- "VFX.AmbientLight"
- "VFX.ArrayNode"
- "VFX.DirectionalLight"
- "VFX.EntityAssetNode"
- "VFX.GPUHelper"
- "VFX.RandomSeedNode"
- "VFX.RandomTypedNode"
- "VFX.RectAreaLight"
- "VFX.VFXRemotePreviewEndpoint"
- "VFX.VFXSceneLightParameters"
- "VFX.WorldReferenceNode"
- "VFX._ECSValueNode"
- "VFX._WorldValueNode"
- "VFX/BufferPool.swift"
- "VFX/EntityManager+Export.swift"
- "VFX/NoHeapTextureAllocator.swift"
- "VFX/Nodes+Easing.swift"
- "VFX/ParticleNoise.swift"
- "VFX/RenderFunctions.swift"
- "VFX/ScriptBuilderSystem.swift"
- "VFX/ScriptCodeGen.swift"
- "VFX/ShaderCache+PipelinesScript.swift"
- "VFXAnimationCommitOnCompletion"
- "VFXAnimationEventsKey"
- "VFXAnimationFadeInDurationKey"
- "VFXAnimationFadeOutDurationKey"
- "VFXCameraControlEventHandler"
- "VFXCameraEffectSSAO"
- "VFXCompositorRenderer"
- "VFXCompositorRendererLayoutKey"
- "VFXCore sync"
- "VFXMTLDeviceSupportsLayeredRendering(device)"
- "VFXMTLPassResourceBinding"
- "VFXMaterialPropertyPrivate_PrecomputedLightingEnvironment"
- "VFXMetalLayer"
- "VFXMetalLayerJSExport"
- "VFXNode access on GPU is not implemented"
- "VFXNode references is not supported on GPU"
- "VFXREDrawCallContext"
- "VFXRERenderTargetInfo"
- "VFXRenderGraph/RenderGraph.swift"
- "VFXRenderTarget"
- "VFXStateMachine"
- "VFXStencilInfo"
- "VFXTriggerTypeMouseDown"
- "VFXTriggerTypeMouseDragged"
- "VFXTriggerTypeMouseUp"
- "VFXTriggerTypeTicked"
- "VFXTriggerTypeTouchBegan"
- "VFXTriggerTypeTouchCanceled"
- "VFXTriggerTypeTouchEnded"
- "VFXTriggerTypeTouchMoved"
- "VFXWorldExportCompressGeometryElements"
- "VFXWorldLoaderAssumeLinearDisplayP3SourceColorSpaceKey"
- "VFXWorldLoaderIgnoreVertexColorsKey"
- "VFXWrapModeClampToBorder"
- "VFX_displayLinkCallback:"
- "VFX_renderFloor"
- "VFX_renderMirroredScene"
- "VFX_setupDisplayLinkWithQueue:screen:policy:"
- "Vector Render"
- "Wait inFlightSemaphore"
- "WaitDrawable"
- "Warning: CFXNodeGetWorldMatrix - no transform tree"
- "Warning: CFXVFXSimulateAndPrepareDrawCalls -> no world yet"
- "Warning: Deindexing - Vertex at index %u of %u is not used by any geometry element"
- "Warning: Failed getting a valid drawable. Skipping this frame."
- "Warning: Found elements with different channel counts in the same geometry"
- "Warning: Invalid VFXScene"
- "Warning: Invalid image"
- "Warning: Missing texture value for %@"
- "Warning: Should not update VFXLight without CFXLight"
- "Warning: VFXCore IBL Sync from image only supports URL"
- "Warning: _CFXSkinnerUpdateBoundingBox - skinned node has no geometry"
- "Warning: _beginTranslateAtLocation: invalid zRange"
- "Warning: _convertOutputsDescriptionToOutputs - can't find output named %@"
- "Warning: binding type %d can't not be exposed"
- "Warning: can't create a fbo description for pass %@ - can't find pass description with name %@"
- "Warning: copyCFXImageFromImage: invalid sub-image\n"
- "Warning: struct member does not match pass description : %@"
- "Warning: symbol named %@ should be in \"targets\" not \"symbols\""
- "Warning: unknown depth texture format : %@"
- "Warning: unknown texture format : %@"
- "We are trying to move an entity object from one entityManager to another. this is not supported. we are leaking tombstoned entities"
- "WireframeLayer"
- "WrapAroundCamera"
- "[16{VFXWorldBuffer=\"viewTransform\"{float4x4=\"columns\"[4]}\"inverseViewTransform\"{float4x4=\"columns\"[4]}\"projectionTransform\"{float4x4=\"columns\"[4]}\"viewProjectionTransform\"{float4x4=\"columns\"[4]}\"viewToCubeTransform\"{float4x4=\"columns\"[4]}\"lastFrameViewProjectionTransform\"{float4x4=\"columns\"[4]}\"ambientLightingColor\"\"fogColor\"\"fogParameters\"\"inverseResolution\"\"time\"f\"sinTime\"f\"cosTime\"f\"random01\"f\"motionBlurIntensity\"f\"environmentIntensity\"f\"environmentTransform\"{float4x4=\"columns\"[4]}\"inverseProjectionTransform\"{float4x4=\"columns\"[4]}\"inverseViewProjectionTransform\"{float4x4=\"columns\"[4]}\"nearFar\"\"viewportSize\"\"inverseTransposeViewTransform\"{float4x4=\"columns\"[4]}\"clusterScale\"\"frame\"I}]"
- "[2{?=\"originX\"d\"originY\"d\"width\"d\"height\"d\"znear\"d\"zfar\"d}]"
- "[3@\"<MTLBuffer>\"]"
- "[3@\"<MTLTexture>\"]"
- "[3^{__CFXFXProgram}]"
- "[bufferBinding isKindOfClass:[VFXMTLPassResourceBinding class]]"
- "[device supportsRasterizationRateMapWithLayerCount:layerCount]"
- "[privateRendererOwner isKindOfClass:[VFXView class]] || [privateRendererOwner isKindOfClass:[VFXCompositorRenderer class]]"
- "^^{VFXMTLBufferPool}"
- "^{?=[4]}"
- "^{?=^{__CFXFXPassInput}II}"
- "^{CGImage=}24@0:8^@16"
- "^{VFXMTLComputeCommandEncoder=@@^{VFXMTLBufferPool}I}"
- "^{VFXMTLComputeCommandEncoder=@@^{VFXMTLBufferPool}I}16@0:8"
- "^{VFXMTLRenderCommandEncoder=IC@@^{VFXMTLBufferPool}B}"
- "^{__CFXCamera={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}{?=b1b1b1b3ffff{?=[4]}{?=[4]}}fff^{__CFXCameraEffectDepthOfField}^{__CFXCameraEffectMotionBlur}^{__CFXCameraEffectGrain}^{__CFXCameraEffectExposure}^{__CFXCameraEffectToneMapping}^{__CFXCameraEffectBloom}^{__CFXCameraEffectVignetting}^{__CFXCameraEffectLensBlur}^{__CFXCameraEffectColorFringe}^{__CFXCameraEffectColorGrading}^{__CFXCameraEffectChromaticTransform}^{__CFXCameraEffectDoughnutBokeh}^{__CFXCameraEffectSSAO}b1b1b1b1{?=[4]}Q^{__CFXFXRenderGraph}}"
- "^{__CFXCamera={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}{?=b1b1b1b3ffff{?=[4]}{?=[4]}}fff^{__CFXCameraEffectDepthOfField}^{__CFXCameraEffectMotionBlur}^{__CFXCameraEffectGrain}^{__CFXCameraEffectExposure}^{__CFXCameraEffectToneMapping}^{__CFXCameraEffectBloom}^{__CFXCameraEffectVignetting}^{__CFXCameraEffectLensBlur}^{__CFXCameraEffectColorFringe}^{__CFXCameraEffectColorGrading}^{__CFXCameraEffectChromaticTransform}^{__CFXCameraEffectDoughnutBokeh}^{__CFXCameraEffectSSAO}b1b1b1b1{?=[4]}Q^{__CFXFXRenderGraph}}16@0:8"
- "^{__CFXCameraEffectSSAO=}16@0:8"
- "^{__CFXCommonProfile={__CFRuntimeBase=QAQ}^{__CFXMaterial}i^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}^{__CFXMaterialProperty}ffffCqBb1b1b1b1b1b1b1b13}16@0:8"
- "^{__CFXCoreEntityHandle={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFString}^{__CFDictionary}^{__CFArray}B^v}"
- "^{__CFXCoreEntityHandle={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFString}^{__CFDictionary}^{__CFArray}B^v}16@0:8"
- "^{__CFXFXPassInput=}"
- "^{__CFXFXProgram={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}b1b1^{__CFXFXProgramDelegate}[2^{__CFString}]^{__CFString}^{__CFString}^{__CFDictionary}^{__CFSet}^v^{__CFDictionary}^vQI}"
- "^{__CFXFXProgram=}"
- "^{__CFXFXProgram=}20@0:8B16"
- "^{__CFXFXProgram=}40@0:8^{__CFXProgramHashCode=}16^{__CFXEngineContext=}24^v32"
- "^{__CFXFXProgram=}48@0:8^{__CFXProgramHashCode=}16^{__CFXEngineContext=}24@32^v40"
- "^{__CFXFXRenderGraph=}16@0:8"
- "^{__CFXFloor={__CFXGeometry={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXMesh}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}ffffifffQ}16@0:8"
- "^{__CFXForceField=}16@0:8"
- "^{__CFXFramebuffer=}"
- "^{__CFXGeometry={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXMesh}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}"
- "^{__CFXGeometry={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXMesh}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16@0:8"
- "^{__CFXImage=}"
- "^{__CFXImage=}28@0:8@16i24"
- "^{__CFXImage=}32@0:8@16Q24"
- "^{__CFXImage=}36@0:8@16i24^B28"
- "^{__CFXMaterialProperty={__CFRuntimeBase=QAQ}(?=^{__CFXImage}^{__CFXImageProxy}^{__CFXTexture}^v^v{CFXColor4=(?=[4f]{?=ffff})}^v)^vq^vb8b1b4c^{__CFXTextureSampler}^{?}fi^v}"
- "^{__CFXMaterialProperty={__CFRuntimeBase=QAQ}(?=^{__CFXImage}^{__CFXImageProxy}^{__CFXTexture}^v^v{CFXColor4=(?=[4f]{?=ffff})}^v)^vq^vb8b1b4c^{__CFXTextureSampler}^{?}fi^v}16@0:8"
- "^{__CFXMaterialProperty={__CFRuntimeBase=QAQ}(?=^{__CFXImage}^{__CFXImageProxy}^{__CFXTexture}^v^v{CFXColor4=(?=[4f]{?=ffff})}^v)^vq^vb8b1b4c^{__CFXTextureSampler}^{?}fi^v}20@0:8B16"
- "^{__CFXMeshElement={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}II^{__CFXMeshElement}CCC{?=c^{__CFData}I^I^{?}SCB}^vfff^v^{__CFXMeshSource}[2]^{?}I}"
- "^{__CFXMeshElement={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}II^{__CFXMeshElement}CCC{?=c^{__CFData}I^I^{?}SCB}^vfff^v^{__CFXMeshSource}[2]^{?}I}16@0:8"
- "^{__CFXMeshElement={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}II^{__CFXMeshElement}CCC{?=c^{__CFData}I^I^{?}SCB}^vfff^v^{__CFXMeshSource}[2]^{?}I}36@0:8c16q20q28"
- "^{__CFXModelTarget={__CFRuntimeBase=QAQ}^v^vscCCB^?^?}"
- "^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1{?={?=SS}I}^{?}^{__CFXGeometry}^{__CFXDeformerStack}f{?=}}"
- "^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1{?={?=SS}I}^{?}^{__CFXGeometry}^{__CFXDeformerStack}f{?=}}16@0:8"
- "^{__CFXSkinner=}56@0:8q16@24@32@40@48"
- "^{__CFXTextureSampler={__CFRuntimeBase=QAQ}iiiiiifCiQ}"
- "^{__CFXTextureSampler={__CFRuntimeBase=QAQ}iiiiiifCiQ}16@0:8"
- "^{__CVBuffer=}"
- "_3DConnexionIsPressed"
- "_TtC3VFX10BufferPool"
- "_TtC3VFX11PrivateHeap"
- "_TtC3VFX12SetStateNode"
- "_TtC3VFX13PowerEaseNode"
- "_TtC3VFX13ScriptCodeGen"
- "_TtC3VFX13SinEaseInNode"
- "_TtC3VFX14BounceEaseNode"
- "_TtC3VFX14CScriptCodeGen"
- "_TtC3VFX14ImplicitDoNode"
- "_TtC3VFX14QTransformNode"
- "_TtC3VFX14RandomSeedNode"
- "_TtC3VFX14SinEaseOutNode"
- "_TtC3VFX15CubicEaseInNode"
- "_TtC3VFX15EasingFloatNode"
- "_TtC3VFX15EntityAssetNode"
- "_TtC3VFX15RandomTypedNode"
- "_TtC3VFX16CubicEaseOutNode"
- "_TtC3VFX16GetArraySizeNode"
- "_TtC3VFX16PhysicalEaseNode"
- "_TtC3VFX16SinEaseInOutNode"
- "_TtC3VFX17DepthStencilCache"
- "_TtC3VFX17QuarticEaseInNode"
- "_TtC3VFX17QuinticEaseInNode"
- "_TtC3VFX18CubicEaseInOutNode"
- "_TtC3VFX18EntityManagerActor"
- "_TtC3VFX18MetalScriptCodeGen"
- "_TtC3VFX18QuarticEaseOutNode"
- "_TtC3VFX18QuinticEaseOutNode"
- "_TtC3VFX18SwiftScriptCodeGen"
- "_TtC3VFX18VectorRenderSystem"
- "_TtC3VFX18WorldReferenceNode"
- "_TtC3VFX19ExponentialEaseNode"
- "_TtC3VFX19GetArrayElementNode"
- "_TtC3VFX19PrepareLightsSystem"
- "_TtC3VFX19QuadraticEaseInNode"
- "_TtC3VFX20HeapTextureAllocator"
- "_TtC3VFX20QuadraticEaseOutNode"
- "_TtC3VFX20QuarticEaseInOutNode"
- "_TtC3VFX20QuinticEaseInOutNode"
- "_TtC3VFX20WireframeLayerSystem"
- "_TtC3VFX21FluidBlurRenderSystem"
- "_TtC3VFX22NoHeapTextureAllocator"
- "_TtC3VFX22QuadraticEaseInOutNode"
- "_TtC3VFX23FluidAbsorbRenderSystem"
- "_TtC3VFX23ImplicitEntityAssetNode"
- "_TtC3VFX23VFXSceneLightParameters"
- "_TtC3VFX24FluidSpheresRenderSystem"
- "_TtC3VFX24VFXRemotePreviewEndpoint"
- "_TtC3VFX26FluidCompositeRenderSystem"
- "_TtC3VFX26ImplicitWorldReferenceNode"
- "_TtC3VFX38VectorRenderSystemRenderPipelineStates"
- "_TtC3VFX9ArrayNode"
- "_TtC3VFX9GPUHelper"
- "_TtC3VFXP33_A1A4C3D28342ECFED6A0B380DFA5196412ScopeChecker"
- "_TtCC3VFX12GraphCodeGenP33_22BEB975C8D88BF1BD499327E6FD4D1D9CFGBranch"
- "_TtCFC3VFX11ShaderCache12makeFunctionFzT4nameSS7libraryGSqPSo10MTLLibrary__14constantValuesGSaVS_16FunctionConstant_13useAsLinkableSb_PSo11MTLFunction_L_15FunctionWrapper"
- "_VFXWorldRendererMainPassCustomPostProcessSupportDrawSceneBackgroundUsingEncoder:commandBuffer:renderPassDescriptor:"
- "__aspectRatio"
- "__attribute__((visibility(\"default\"))) "
- "__removeObjectFromChildNodesAtIndex:"
- "__wantsSeparateGeometryElements"
- "_adaptativeFrameDuration"
- "_allSymbolsWithVFXSemantic"
- "_allowRemoteEdition"
- "_allowsTranslation"
- "_apertureBladeCount"
- "_arrayLength"
- "_aspectRatio"
- "_autoCameraTarget"
- "_automaticCameraTargetUpToDate"
- "_beginTranslateAtLocation:"
- "_browseScale"
- "_browseScaleFactor"
- "_caDisplayLink"
- "_caDisplayLinkCallback"
- "_callbackWithTime:"
- "_cameraFocusPlaneGeometry"
- "_cameraFrustumGeometry"
- "_cameraGeometry"
- "_cameraLoaded"
- "_cameraNearPlaneGeometry"
- "_cameraOrthographicFrustumGeometry"
- "_captureStarted"
- "_cfxImage"
- "_ciImage"
- "_clearContents"
- "_clickOrigin"
- "_cloneSharable:remap:"
- "_cloneWithOption:remapTable:"
- "_coalescingSource"
- "_colorAttachmentDescriptor"
- "_colorTexture"
- "_colorTextures"
- "_constantBufferPools"
- "_contentType != VFXContentTypeLayer"
- "_copyAttributes:"
- "_copyCFXImageFromImageData:typeID:"
- "_copyImageFromCFXImage:"
- "_copyRecursively:remapOut:"
- "_copyWithOptions:to:remap:"
- "_createOffscreenFramebufferIfNeeded"
- "_createSkinnerWithVertexCount:bones:boneWeights:boneIndices:baseMesh:"
- "_currentInitDeformer"
- "_currentRenderPassDescriptor"
- "_currentUpdateBuffers.dependency0Normals"
- "_currentUpdateBuffers.dependency0Positions"
- "_currentUpdateBuffers.dependency0Tangents"
- "_currentUpdateBuffers.dependency1Normals"
- "_currentUpdateBuffers.dependency1Positions"
- "_currentUpdateBuffers.dependency1Tangents"
- "_currentVFXViewFocusEnvironment"
- "_customDecodingOfVFXProgram:"
- "_customEncodingOfVFXProgram:"
- "_customMainPassProcessUsesExtraRenderTargetForRenderer:pixelFormat:"
- "_deepCloneWithRemapTableOut:"
- "_defaultDepthStencilState"
- "_deformers"
- "_depthTexture"
- "_depthTextures"
- "_description"
- "_didUpdateBackingSize"
- "_drawAtTime:"
- "_drawForJittering"
- "_drawInRenderingQueueWithDrawable:renderPassDescriptor:"
- "_drawable"
- "_effectGeometry"
- "_encodeCustomMainPassProcessForRenderer:atTime:helper:"
- "_entityHandle"
- "_expand"
- "_fadeInDuration"
- "_fadeOutDuration"
- "_falloff"
- "_fetchMesh"
- "_fieldGeometry"
- "_fillNodeA:nodeB:contactPoint:collisionImpulse:distance:hitFraction:"
- "_flushDisplayLink"
- "_focalBlurSampleCount"
- "_fragmentShader"
- "_framebufferInfo"
- "_geometryByRemovingSkinnerSources"
- "_geometryByUnifyingNormalsWithCreaseThreshold:"
- "_geometryByWeldingVerticesWithThreshold:normalThreshold:"
- "_gimbalLockMode"
- "_hasAutomaticCameraTarget"
- "_inFlightSemaphore"
- "_inertiaRunning"
- "_inertiaVelocity"
- "_initChildNodesArray"
- "_initRendererWithOptions:"
- "_initialMatrix"
- "_initialMatrixForRoll"
- "_initialPoint"
- "_initializeDisplayLinkWithScreen:policy:completionHandler:"
- "_inputs"
- "_integrateModelKitComputedMaps:withGeometry:node:texturePathProvider:vertexAttributeNamed:materialPropertyNamed:filePath:"
- "_invalidateFramebuffer"
- "_isEligibleForFocusInteraction"
- "_isFront"
- "_isInertiaRunning"
- "_isInvalidated"
- "_isMetalSupported"
- "_isRunningInExtension"
- "_isViewedObjectSphereComputed"
- "_lastRenderedTime"
- "_lastSimulationTime"
- "_lastWorldTime"
- "_layout"
- "_lightGeometry"
- "_lightLoaded"
- "_lightingContribution.%@=%@;\n"
- "_loadAction"
- "_loadURL:into:options:statusHandler:error:"
- "_logicalHeight"
- "_logicalWidth"
- "_maxInFlightFrameCount"
- "_meshByUnifyingNormalsWithCreaseThreshold:"
- "_meshChanged"
- "_modelLoaded"
- "_modelSourceWithData:semantic:vectorCount:componentType:componentCount:dataOffset:dataStride:"
- "_morphTargetCount"
- "_morphTargets"
- "_morpherLoaded"
- "_mtkView"
- "_mtlTexture"
- "_offScreenFramebuffer"
- "_onInertiaTimer"
- "_optionsForSymbol:"
- "_originalFov"
- "_originalRenderPassDescriptor"
- "_parseBindings:function:renderPipeline:"
- "_passBindings"
- "_pendingGPUFrameCount"
- "_pixelBuffer"
- "_preferredFocusMovementStyle"
- "_preferredFrameRate"
- "_preloadRenderer"
- "_prepareRenderTarget"
- "_presentFramebuffer"
- "_processingContext.passInstance"
- "_profile"
- "_queuedFrameCount"
- "_rasterizationRateMapBlitPipeline"
- "_rasterizationRateMapDataBuffer"
- "_reSyncModelTree"
- "_rebuildRasterizationRateMap"
- "_rebuildTextures"
- "_referenceCount"
- "_remoteEditionEndpoint"
- "_remotePreviewDelegate"
- "_removeFromParentNodeWithoutRemovingWorldReference"
- "_renderSize"
- "_renderWorldWithEngineContext:"
- "_renderingSnapshot"
- "_rendersIntoMaterial"
- "_resetBrowseScaleFactor"
- "_resourceGroup"
- "_roll"
- "_rotateWithDrag:mode:stickyAxis:"
- "_runFPSTestWithDuration:"
- "_runningInExtension"
- "_runningLock"
- "_samplerInput"
- "_screenSpaceReflectionMaxRayDistance"
- "_screenSpaceReflectionSampleCount"
- "_screenSpaceReflectionStride"
- "_semanticInfos"
- "_setAntialiasingMode:forcingReset:"
- "_setBaseMesh:"
- "_setCFXImageRef:"
- "_setCFXProgramDelegate"
- "_setGeometryRef:"
- "_setupContentsFromCFXImage"
- "_setupMeshElements"
- "_setupMeshSources"
- "_setupOffscreenRendererWithSize:"
- "_shadable"
- "_shouldCaptureNextFrame"
- "_shouldDeleteFramebuffer"
- "_shouldPresentAfterMinimumDuration"
- "_simulateCommandBufferFailure"
- "_skinnerLoaded"
- "_skipFramesIfNoDrawableAvailable"
- "_sliceTextures"
- "_snapshotRenderer"
- "_sourceFile"
- "_sourceState"
- "_ssao"
- "_stateLock"
- "_syncEntityObjCModel"
- "_syncObjCModel"
- "_syncObjCModel:"
- "_syncTimeWithCoreAnimation"
- "_targetState"
- "_tessellatorValueForGeometry:"
- "_texturePixelFormat"
- "_timeStamp"
- "_totalDragWithInertia"
- "_translateTo:"
- "_upDir"
- "_upDirIsSet"
- "_updateAssociatedVFXNodeWithGeometrySetter:texturePathProvider:vertexAttributeNamed:materialPropertyNamed:"
- "_updateMaterialFilters"
- "_updateMaterialPropertyTransform:"
- "_updateVFXCoreFromNodes"
- "_usesAbsoluteTime"
- "_usesLayeredRendering"
- "_usesMultipleViewportRendering"
- "_vertexShader"
- "_vertexWeightIndexSize"
- "_vertexWeightIndicesBuffer"
- "_vfxCoreViewports"
- "_vfx_forceAsImpulse"
- "_vfx_simd_quatf(vfx_quat_from_x_rotation(%angle))"
- "_vfx_simd_quatf(vfx_quat_from_y_rotation(%angle))"
- "_vfx_simd_quatf(vfx_quat_from_z_rotation(%angle))"
- "_vfx_torqueAsImpulse"
- "_videoOutput"
- "_videoSourceFormat"
- "_viewMatrix0"
- "_viewMatrix1"
- "_viewedObjectSphere"
- "_viewportDidChange"
- "_volatileBufferPools"
- "_wantsCustomMainPassProcessForRenderer:"
- "_wantsSeparateGeometryElements"
- "_zoomFactor"
- "activeRenderVariantDescriptors"
- "adaptativeFrameRate"
- "add"
- "addLightWithType:"
- "addNormalsWithAttributeNamed:creaseThreshold:"
- "addPassResourceBindingsForArgument:"
- "addRenderTargetRuntime"
- "addTransition:"
- "address < (void*) ((unsigned char*)controller+sizeof(struct __CFXAnimatableParamController))"
- "allocateConstantBuffer "
- "allocateConstantBuffer failed copying MTLDrawIndexedPrimitivesIndirectArguments"
- "allocateConstantBuffer failed copying MTLDrawPrimitivesIndirectArguments"
- "allocateConstantBuffer failed copying REVFXIBLConstants_s"
- "allocateConstantBuffer failed copying REVFXLightConstantBuffer_s"
- "allocateConstantBuffer failed copying SIMD3<UInt32>"
- "allocateConstantBuffer failed copying external_entity_constants"
- "allocateConstantBuffer failed copying external_scene_buffers"
- "allocateConstantBuffer failed copying external_scene_constants"
- "allocateConstantBuffer failed copying frame_constants"
- "allocateConstantBuffer failed copying global_constants"
- "allocateConstantBuffer failed copying object_constants"
- "allocateConstantBuffer failed copying particle_ao_material_constants"
- "allocateConstantBuffer failed copying particle_gaussian_material_constants"
- "allocateConstantBuffer failed copying particle_init_with_parent_uniforms"
- "allocateConstantBuffer failed copying particle_mesh_material_constants"
- "allocateConstantBuffer failed copying particle_surface_material_constants"
- "allocateConstantBuffer failed copying particle_update_counters_uniforms"
- "allocateConstantBuffer failed copying update_life_uniforms"
- "allocateConstantBuffer failed copying view_constants"
- "allocatedBuffer"
- "alphaDst"
- "alphaOp"
- "alphaSaturate"
- "alphaSrc"
- "always"
- "apertureBladeCount"
- "appendWithTrigger:event:view:inWorld:"
- "assetWithURL:"
- "atomCache"
- "auto %r0 = vfx_get_translation(%0);\nauto %r1 = vfx_quat_(vfx_get_rotation(%0));\nauto %r2 = vfx_get_scale(%0);"
- "auto %r0 = vfx_script_color_ramp_create(\n    %script_context,\n    "
- "auto %r0 = vfx_script_color_ramp_create_setting_color(%script_context, %colorRamp, %color, %index);\n#cleanup\nvfx_script_color_ramp_destroy(%script_context, %r0);"
- "auto %r0 = vfx_script_curve_create(\n    %script_context,\n    "
- "auto %temp0 = %0;\nvfx_script_graph_log(\""
- "auto %temp0 = %1;\nvfx_script_graph_log(\""
- "b14"
- "back"
- "backFaceBehavior"
- "beginImgUIFrameWithViewportSize:backingScaleFactor:"
- "beginTransaction:"
- "behavior"
- "bgra8"
- "bgra8Unorm"
- "bgra8unorm"
- "bladeCount"
- "blendStates"
- "blend_inc_add_8x_p_kernel"
- "blend_inc_add_8x_pn_kernel"
- "blend_inc_init_8x_p_kernel"
- "blend_inc_init_8x_pn_kernel"
- "blur"
- "bufferView.length == CFX::ConstantBufferAlignSize((shOrder * shOrder) * 3 * sizeof(float))"
- "buildAccelerationStructureDescriptorsWithEntity:"
- "call doesn't make sense on "
- "cameraFocusPlaneGeometry"
- "cameraFrustumGeometry"
- "cameraGeometry"
- "cameraNearPlaneGeometry"
- "cameraOrthographicFrustumGeometry"
- "canDrawConcurrently"
- "cfgScopes"
- "channelCount == CFXMeshElementGetIndicesChannelCount(rhs.element)"
- "ciImage"
- "clampToBorder"
- "clientProgram"
- "color0"
- "colorDst"
- "colorOp"
- "colorSrc"
- "colorStates"
- "com.apple.VFXview-renderer"
- "com.apple.vfx.forceSeparateWorkGroup"
- "commitsOnCompletion"
- "compile"
- "compute"
- "computeAutomaticTargetPoint"
- "computeBoundingSphereOmittingFloorsForNode:sphere:"
- "const char *name"
- "constantAlpha"
- "constantBufferAlignment"
- "constantBuffers"
- "constantColor"
- "contentLayer"
- "convertTime:fromLayer:"
- "convertToAdditiveWithBaseMesh:"
- "convertToSparseWithBaseMesh:"
- "copyImageFromCFXImage:"
- "copyParameterDataToBuffer:offset:"
- "copyPropertiesFrom:"
- "correspondingExternalIndex"
- "couldn't find metal function for script "
- "couldn't load metal function: "
- "couldn't write Metal pipelines script: "
- "count == 1"
- "createSkinnerWithBaseMesh:bones:boneWeights:boneIndices:"
- "createSkyboxWithParameters:"
- "createSnapshot:"
- "cullBack"
- "cullFront"
- "cullNone"
- "currentAllocatingFrame"
- "currentDrawable"
- "currentEncoder"
- "currentEncoderWrapper"
- "currentFrameBuffers"
- "currentHeapSizeUsed"
- "d > 0"
- "d48@0:8@16@24^{__CFXEngineContext=}32^{__CFXTextureSampler={__CFRuntimeBase=QAQ}iiiiiifCiQ}40"
- "deallocateElementAtOffset:"
- "debugQuickLookObjectWithAssetPathResolver:"
- "debug_copy_stereo"
- "decrement"
- "decrementWrap"
- "default:switchCaseOptions"
- "defaultShapeForGeometry:"
- "deformer"
- "depth16"
- "depth16Unorm"
- "depth16unorm"
- "depth24"
- "depth24Unorm"
- "depth24Unorm_stencil8"
- "depth24unorm"
- "depth24unorm_stencil8"
- "depth32Float"
- "depth32f"
- "depth32float"
- "depth32float_stencil8"
- "depthCompareFunction"
- "depthFail"
- "depthOfField.apertureBladeCount"
- "depthOfField.focalBlurSampleCount"
- "depthStates"
- "depthStencilPixelFormat"
- "depthStencilStates"
- "destroyDrawCalls"
- "dictionaryWithContentsOfURL:"
- "didHintFocusMovement:"
- "didUpdateFocusInContext:withAnimationCoordinator:"
- "dirtySharedFileQuery"
- "dirtyTextureClient"
- "disc2DDesc"
- "discShape"
- "discardVideoData"
- "display"
- "displayLinkCallbackShouldReturnImmediately"
- "displayLinkPolicy"
- "dof_blur2"
- "dof_blur_vertical"
- "dof_coc_blur"
- "dof_coc_downsample_sort"
- "dof_compute_kernel_parallel"
- "dof_downsample_rate"
- "draw"
- "drawFullScreenQuadForPass:"
- "drawInMTKView:"
- "drawRect:"
- "drawRenderElement:withPass:"
- "draw_geometry"
- "draw_main_world"
- "draw_node"
- "draw_nodes"
- "draw_none"
- "draw_quad"
- "draw_world"
- "dvt_supportedTypesForPropertyContents"
- "effectGeometry"
- "emitsDoubleSided"
- "emitterIdentifier"
- "enable"
- "enableLogging"
- "enableRead"
- "enableWrite"
- "encodeAuthoringWithEncoder:colorFormat:depthStencilFormat:sampleCount:"
- "encoders"
- "endDraggingWithVelocity:"
- "endImgUIFrameWithCommandBuffer:encoder:renderPassDescriptor:"
- "enumerateDependencies:"
- "equal"
- "excludeCategoryMask"
- "extents"
- "fadeInDuration"
- "fadeOutDuration"
- "fail"
- "failed to create light instance"
- "failed to make a compute pipeline state for function "
- "fieldGeometry"
- "filters."
- "float2 texcoord%d;\n"
- "focalBlurSampleCount"
- "focusEffect"
- "focusGroupIdentifier"
- "focusGroupPriority"
- "focusItemContainer"
- "focusItemDeferralMode"
- "focusSystemForEnvironment:"
- "for cache entry in non loading state. Current state is "
- "fragment"
- "frameAllocatedSize"
- "frameBufferFeatures"
- "frameMaxHeapSizeNeeded"
- "framebufferColor"
- "front"
- "frontVector"
- "frontVectorWithPointOfView:"
- "func"
- "fxPass->_inputCount == count"
- "generateBindingsForPipeline:withReflection:program:material:geometry:pass:"
- "generatorWithProfile:allowingHotReload:"
- "geometry->_subdivInfo.subdivisionLevel > 0"
- "geometry->_trackedNodes"
- "geometry->_trackedNodes && CFSetContainsValue(geometry->_trackedNodes, node)"
- "geometry.materials[%d]"
- "geometryCount"
- "geometryElementWithMeshElementRef:"
- "geometryForLightType:"
- "geometryModificationCount"
- "geometryShader"
- "geometrySourceWithColorComponents:count:hasAlpha:colorSpace:"
- "geometrySourceWithMDLVertexAttribute:mesh:"
- "geometrySourceWithMeshSourceRef:"
- "getEncoderAndResetCache"
- "global"
- "greater"
- "greaterEqual"
- "hasConstantAlpha"
- "hasFreeElementsLeft"
- "has_DOF"
- "has_IBL"
- "has_background"
- "has_clearcoat"
- "has_directLightings"
- "has_indirectDiffuse"
- "has_specular"
- "has_subsurface"
- "has_uniform_size_LEGACY"
- "horizontalSampleStorage"
- "ibl"
- "ici"
- "if (particles.newly_created_is_outside(&pid)) return;"
- "ignoreFloors"
- "includeCategoryMask"
- "increment"
- "incrementWrap"
- "index < renderGraph->_count"
- "indexCount % channelCount == 0"
- "indexOffset"
- "indexSet "
- "influencingMorpher"
- "initPresentationModelWithGeometryRef:"
- "initWithDescription:size:arrayLength:"
- "initWithDevice:contentsOf:error:"
- "initWithDevice:engineContext:"
- "initWithDevice:model:"
- "initWithDevice:model:options:"
- "initWithFormat:arguments:"
- "initWithGeometry:resourceManager:"
- "initWithMTKView:options:"
- "initWithMTLTexture:options:"
- "initWithName:"
- "initWithQueue:screen:policy:block:"
- "initWithShapeGeometryRef:"
- "initWithSource:andTarget:"
- "initWithStateManager:"
- "initWithType:"
- "initWithType:intensity:color:"
- "inputName"
- "inputsCount"
- "installViewport"
- "invalid wrapS value: %d"
- "invalid wrapT value: %d"
- "invert"
- "isDepthWriteEnabled"
- "isFull"
- "isParticleComponent"
- "isTransparentFocusItem"
- "isViewDependant"
- "is_depth_pass"
- "jointsForVertexWeights[%d]"
- "kBehaviorGraph"
- "kCFXBaseTypeInteger"
- "kCFXNotificationGeometryWillDie"
- "kFilterKey"
- "kModelTransform"
- "kModelViewProjectionTransform"
- "kModelViewTransform"
- "kNormalTransform"
- "kParticleCollider"
- "kParticleEmitter"
- "kProjectionTransform"
- "kSceneSourceConvertToUnit"
- "kViewTransform"
- "kWorldInitOptionForAuthoring"
- "kWorldSourceAdjustInvalidClippingPlanes"
- "kWorldSourceAssetDirectoryURLs"
- "kWorldSourceCheckConsistency"
- "kWorldSourceCleanupMeshes"
- "kWorldSourceConvertToUnit"
- "kWorldSourceConvertToYUpIfNeeded"
- "kWorldSourceCreateCameraIfAbsent"
- "kWorldSourceCreateLightIfAbsent"
- "kWorldSourceCreateNormalsIfAbsent"
- "kWorldSourceFlattenWorld"
- "kWorldSourceFormat"
- "kWorldSourceInterleaveSources"
- "kWorldSourceMakeSourcesCheaper"
- "kWorldSourceRemoveAllLights"
- "kWorldSourceRemoveColorArrays"
- "kWorldSourceSplitMeshesForGLES"
- "keep"
- "layerCount"
- "layerMask"
- "less"
- "lessEqual"
- "libraryForProgramDesc:completionHandler:"
- "light_count"
- "load:options:error:"
- "loadData:into:options:statusHandler:error:"
- "loadNonNativeFormatAt:into:options:statusHandler:error:"
- "loadURL:into:options:statusHandler:error:"
- "loadWithCommandBuffer:label:"
- "loadWithCommandBuffer:renderPassDescriptor:"
- "loadWithUrl:loadingForAuthoring:infoOut:presentationScene:error:"
- "loadWorldDescriptionAt:into:options:compressed:statusHandler:error:"
- "loadWorldDescriptionFromData:into:options:compressed:sourceURL:statusHandler:error:"
- "locationOfTouch:inView:"
- "lock DepthStencilCache"
- "m"
- "main pass"
- "matchesDescription:size:arrayLength:"
- "matrixWithNoRoll:"
- "maxAvailableSizeWithAlignment:"
- "maxHeapSizeNeeded"
- "maxTextureHeight2D"
- "maxTextureWidth2D"
- "metal not supported"
- "metalFragmentShader"
- "metalLibraryFile"
- "metalLibraryName"
- "metalVertexShader"
- "metal_custom"
- "mipmapped"
- "mirrorNode"
- "modelInverseTransform"
- "modelViewInverseTransform"
- "modelViewProjectionInverseTransform"
- "modelWithGeometryRef:"
- "mtkView:drawableSizeWillChange:"
- "mutableMaterials"
- "nameByScriptParameter"
- "nameToInput"
- "never"
- "newAccelerationStructureWithDescriptor:offset:"
- "newAccelerationStructureWithSize:offset:"
- "newBufferWithLength:options:offset:"
- "newRadianceTextureForEnvironmentTexture:engineContext:cpuAccessible:commandBuffer:"
- "newTextureWithDescriptor:offset:"
- "nextScope"
- "nil buffer slice"
- "node->_cumulativeCache"
- "nodeFromflattenedMesh"
- "nodeWithMDLObject:masterObjects:worldNodes:skinnedMeshes:skelNodesMap:asset:options:context:"
- "normalInverseTransform"
- "not available in metal"
- "not supported on this class"
- "notEqual"
- "notifications._eventType == kCFXNotificationEventType_Geometry"
- "numberOfFramesBeforePurge"
- "offset=%d&size=%d"
- "oldIndexToNewIndex[sourceIndex]"
- "oneMinusConstantAlpha"
- "oneMinusConstantColor"
- "oneMinusDstAlpha"
- "oneMinusDstColor"
- "oneMinusSrcAlpha"
- "oneMinusSrcColor"
- "onlyMovableNodes"
- "onlyShadowCasters"
- "outputs"
- "outputsNormal"
- "overallVertexIndex == (CFIndex)indexCount"
- "overridesCustomProgram"
- "owners"
- "paramName"
- "parameter"
- "parameterBufferSizeAndAlign"
- "parentFocusEnvironment"
- "pass"
- "pass %d"
- "pass->_overridedRendererElementsProgramHashcodes"
- "passFormat"
- "passes"
- "peakAllocationsRingBuffer"
- "pendingGPUFrameCount"
- "persistent"
- "physicalSizeForLayer:"
- "pingPongTex0"
- "pingPongTex1"
- "pixelFormatView"
- "pointOfCulling.world"
- "portalCrossingPlane"
- "postCommandWithContext:object:applyBlock:"
- "postCommandWithContext:object:key:applyBlock:"
- "postCommandWithContext:object:key:subscriptIndex:derivedKeyPath:applyBlock:"
- "postCommandWithContext:object:key:subscriptKey:derivedKeyPath:applyBlock:"
- "postCommandWithContext:object:keyPath:applyBlock:"
- "postFX"
- "preDraw"
- "preFX"
- "preToneMap"
- "precomputedLightingEnvironmentDataForContents:device:error:"
- "prefabWithRootNode:"
- "preferredFocusEnvironments"
- "preferredFocusedView"
- "presentationBehaviorGraphWithCoreEntityHandleRef:"
- "presentationBindings"
- "presentationModelWithGeometryRef:"
- "presentationParticleColliderWithCoreEntityHandleRef:"
- "presentationParticleEmitterWithCoreEntityHandleRef:"
- "probe_debug_scale"
- "probe_grid"
- "probe_res"
- "programHashCode->_desc.materialPropertysHash[i] <= ((1 << (kCFXMaterialPropertyHashIndexMax + 1)) - 1)"
- "projectPoints:count:"
- "projectionInverseTransform"
- "propertyListWithData:options:format:error:"
- "pvr"
- "pvrtc"
- "pvrtcData"
- "q16@?0^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1{?={?=SS}I}^{?}^{__CFXGeometry}^{__CFXDeformerStack}f{?=}}8"
- "quality_mode"
- "queuedFrameCount"
- "r <= CFXSkinGetWeightsCount(skin)"
- "r16"
- "r16Float"
- "r16Sint"
- "r16Snorm"
- "r16Uint"
- "r16Unorm"
- "r16f"
- "r16float"
- "r16i"
- "r16s"
- "r16sint"
- "r16snorm"
- "r16ui"
- "r16uint"
- "r16unorm"
- "r32"
- "r32Float"
- "r32Sint"
- "r32Uint"
- "r32f"
- "r32float"
- "r32i"
- "r32sint"
- "r32ui"
- "r32uint"
- "r8"
- "r8Sint"
- "r8Snorm"
- "r8Uint"
- "r8Unorm"
- "r8i"
- "r8s"
- "r8sint"
- "r8snorm"
- "r8ui"
- "r8uint"
- "r8unorm"
- "radianceTextureForEnvironmentTexture:engineContext:commandBuffer:"
- "raise:format:"
- "rays_per_probe"
- "readSIMD2D:"
- "readSIMD3D:"
- "readSIMD3x3D:"
- "readSIMD4D:"
- "readSIMD4x4D:"
- "recordMetalPipelinesScript"
- "rect2DDesc"
- "rectShape"
- "recycleBufferPools used:"
- "referenceCount"
- "referenceValue"
- "registerPlayer:"
- "registerUserBlockTrampoline:"
- "reloadFromURL:error:"
- "reloadWorld:withUpdatedWorldAtURL:"
- "remapEntityReferences:"
- "remoteEditionEndpoint"
- "remotePreviewDelegate"
- "removeFileWrapper:"
- "removeLightWithId:"
- "removeSkyboxes"
- "removeSmallestUnusedBuffer "
- "removeTransitionFrom:to:"
- "renderBufferFormat"
- "renderGraph->_isCompiled==false"
- "renderGraph->_parameterStorage == NULL || renderGraph->_parameterStorage->storage == NULL"
- "renderMesh:meshElement:withProgram:engineContext:transform:color:rasterizerStates:blendState:texture:depthBias:"
- "renderPassDescriptorPool"
- "renderResourceForProgramDesc:renderPassDescriptor:"
- "renderTarget"
- "renderTargetHeap"
- "renderTime"
- "rendererClass"
- "rendersIntoMaterial"
- "replace"
- "requestFocusUpdateToEnvironment:"
- "resetUsingDescriptor:"
- "resourceGroup"
- "reverseSubstract"
- "rg"
- "rg16"
- "rg16Float"
- "rg16Sint"
- "rg16Snorm"
- "rg16Uint"
- "rg16Unorm"
- "rg16f"
- "rg16float"
- "rg16i"
- "rg16s"
- "rg16sint"
- "rg16snorm"
- "rg16ui"
- "rg16uint"
- "rg16unorm"
- "rg32"
- "rg32Float"
- "rg32Sint"
- "rg32Uint"
- "rg32f"
- "rg32float"
- "rg32i"
- "rg32sint"
- "rg32ui"
- "rg32uint"
- "rg8"
- "rg8Sint"
- "rg8Snorm"
- "rg8Uint"
- "rg8Unorm"
- "rg8i"
- "rg8s"
- "rg8sint"
- "rg8snorm"
- "rg8ui"
- "rg8uint"
- "rg8unorm"
- "rgba"
- "rgba16"
- "rgba16Float"
- "rgba16Sint"
- "rgba16Snorm"
- "rgba16Uint"
- "rgba16Unorm"
- "rgba16f"
- "rgba16float"
- "rgba16i"
- "rgba16s"
- "rgba16sint"
- "rgba16snorm"
- "rgba16ui"
- "rgba16uint"
- "rgba16unorm"
- "rgba32"
- "rgba32Float"
- "rgba32Sint"
- "rgba32Uint"
- "rgba32f"
- "rgba32float"
- "rgba32i"
- "rgba32sint"
- "rgba32ui"
- "rgba32uint"
- "rgba8"
- "rgba8Sint"
- "rgba8Snorm"
- "rgba8Uint"
- "rgba8Unorm"
- "rgba8i"
- "rgba8s"
- "rgba8sint"
- "rgba8snorm"
- "rgba8ui"
- "rgba8uint"
- "rgba8unorm"
- "rotateWithVector:mode:"
- "roundedNoStroke"
- "roundedRect2DDesc"
- "roundedRectStrokeDesc"
- "roundedRectStrokeShadowDesc"
- "roundedWithStrokeColorWidth"
- "roundedWithStrokeColorWidthShadow"
- "runtimeEntityManager"
- "samples"
- "scopes"
- "screenSpaceReflectionDepthThreshold"
- "screenSpaceReflectionMaximumDistance"
- "screenSpaceReflectionSampleCount"
- "screenSpaceReflectionStride"
- "self.focusItemContainer.coordinateSpace == focusEnvironmentView.coordinateSpace"
- "semanticForSymbol:"
- "semanticInfos"
- "sequence"
- "setAdaptativeFrameRate:"
- "setApertureBladeCount:"
- "setAreaLightParametersWithExtents:doubleSided:"
- "setAttenuationRadius:"
- "setCommitsOnCompletion:"
- "setContentsGravity:"
- "setDepthResolveFilter:"
- "setDirectionalLightUniformOverridesOn:world:proj:"
- "setDirectionalParametersWithScale:zNear:zFar:"
- "setEmitterIdentifier:"
- "setEncoder:alreadyUsed:"
- "setEntityHandle:"
- "setFadeInDuration:"
- "setFadeOutDuration:"
- "setFalloff:"
- "setFilters:"
- "setFocalBlurSampleCount:"
- "setGeometryModificationCount:"
- "setGeometryRef:"
- "setGeometryShader:"
- "setIBLParametersWithEntity:"
- "setIBLParametersWithTag:"
- "setIBLParametersWithUrl:texture:"
- "setInputsCount:"
- "setLayer:atIndex:"
- "setLightParametersOn:parameters:"
- "setManager:"
- "setNeedsDisplayOnBoundsChange:"
- "setNeedsFocusUpdate"
- "setPointLightParametersWithZNear:zFar:"
- "setReferenceCount:"
- "setRegistry:"
- "setRemoteEditionEndpoint:"
- "setRemotePreviewDelegate:"
- "setRendersIntoMaterial:"
- "setScreenSpaceReflectionDepthThreshold:"
- "setScreenSpaceReflectionMaximumDistance:"
- "setScreenSpaceReflectionSampleCount:"
- "setScreenSpaceReflectionStride:"
- "setSemantic:forSymbol:"
- "setSemantic:forSymbol:options:"
- "setSemanticInfos:"
- "setShadowParametersOn:castsShadows:tiles:count:depthBias:"
- "setShouldPresentAfterMinimumDuration:"
- "setSimdTransform:"
- "setSimdWorldTransform:"
- "setSimulateCommandBufferFailure:"
- "setSkipFramesIfNoDrawableAvailable:"
- "setSourceFile:"
- "setSpecializedName:"
- "setSpotLightParametersWithOuterAngle:innerAngle:zNear:zFar:"
- "setSsao:"
- "setStencilResolveFilter:"
- "setSyncTimeWithCoreAnimation:"
- "setTessellationControlShader:"
- "setTessellationEvaluationShader:"
- "setTimeStamp:"
- "setTranslation:inView:"
- "setVideoSourceFormat:"
- "setViewMatrix0:"
- "setViewMatrix1:"
- "setViewpointCoordinateSpace:"
- "setVisibilityResultBuffer:"
- "set_aspectRatio:"
- "set_wantsSeparateGeometryElements:"
- "setupFinalMeshWithMesh:entityName:info:usingDrawIndirect:"
- "setupInitialBuffersWithBaseMesh:entityName:info:"
- "shadableGeometry"
- "shadableMaterial"
- "shaderRead"
- "shaderWrite"
- "shadowRoundedDesc"
- "shouldPresentAfterMinimumDuration"
- "shouldUpdateFocusInContext:"
- "showDebugMenu"
- "show_probes"
- "simd_cross(%0, %1)"
- "simd_dot(%0, %0)"
- "simd_dot(%0, %1)"
- "simd_float3 %temp0 = vfx_float3_zero();\nsimd_float3 %temp1 = vfx_float3_zero();\nvfx_orthonormal_basis(%0, &%temp0, &%temp1);\nsimd_float3 %r0 = %temp0;\nsimd_float3 %r1 = %temp1;"
- "simulateCommandBufferError"
- "simulateCommandBufferFailure"
- "skipFramesIfNoDrawableAvailable"
- "snapshotRendererWithSize:"
- "soundIdentifierForFocusUpdateInContext:"
- "sourceFile"
- "sourceState"
- "spatial_pass_id"
- "splitContainer"
- "splitInputOutputStructsIfNeededForSourceCode:generatedFromReplacementStrings:perPixelLighting:clipDistanceCount:"
- "srcType"
- "ssao"
- "stage < kCFXFXProgramStageCount"
- "static vfx_entry_t __vfx_script_table[] = {"
- "static vfx_entry_t __vfx_script_table_ref = { \""
- "stencil"
- "stencil8"
- "stencilStates"
- "sub.buffer != nil"
- "subfn_%node_name("
- "substract"
- "supportsMTLFeatureSet:"
- "swift"
- "switchToState:"
- "symbolName"
- "symbols"
- "syncTimeWithCoreAnimation"
- "targetName"
- "targetState"
- "td"
- "temporal_factor"
- "tessellationControlShader"
- "tessellationEvaluationShader"
- "textureAbsolutePath"
- "textureCubeDescriptorWithPixelFormat:size:mipmapped:"
- "textureDescriptorForAttachment:"
- "textureForEntity:isFallback:isDynamic:"
- "textureForSliceIndex:"
- "textureTag"
- "texture_rectangle"
- "timeStamp"
- "timestamp"
- "token->worldRef == world"
- "toolchainPath"
- "transitionsFrom:"
- "translationInView:"
- "triggerRenderWith:renderer:"
- "triggerType:event:fromView:"
- "typeTest == input->_baseType"
- "u_floorCenter"
- "u_floorExtent"
- "u_floorFalloff"
- "u_floorFalloffStart"
- "u_floorMVP_i"
- "u_floorNormal"
- "u_floorPlane"
- "u_floorReflectionColor"
- "u_floorReflectionDepth"
- "u_floorReflectivity"
- "u_floorTangent"
- "u_floor_viewport"
- "uint16_t amp_id [[ amplification_id ]]"
- "uniformName"
- "unregisterManagerForDevice:"
- "unsupported format for scale: "
- "unsupported stage or stage combination: "
- "unusedBuffers"
- "unusedTextures"
- "updateAtTime:deltaTime:frameIndex:"
- "updateBridgedReferencesWithBridgeable:objectByIdentifier:"
- "updateBrowseScaleFactor"
- "updateFocusIfNeeded"
- "updateItemsScale:"
- "updateVFX2RenderOutputWithPointOfView:commandBuffer:"
- "updateWithComputeContext:positions:normals:tangents:"
- "uploadLock"
- "usePortalCrossing, "
- "use_depth_test"
- "usedSize"
- "usedTextures"
- "userInfoData"
- "usesSeparateWorkGroup"
- "v120@0:8{?=[3]}16^v112"
- "v128@0:8{?=^{__CFXFXProgram}^{__CFXMaterial}^{__CFXGeometry}^{__CFXFXPass}^{__CFXFXPass}@^{__CFXBlendStates}^{__CFXNode}CCCCCC@{?=C@?}Q}16@?120"
- "v140@?0{__CFXShapeVertex={CGPoint=dd}{CGPoint=dd}{CGPoint=dd}{CGPoint=dd}fBi}8{CGPoint=dd}88f104{CGPoint=dd}108{CGPoint=dd}124"
- "v148@0:8^{__CFXMesh=}16^{__CFXMeshElement={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}II^{__CFXMeshElement}CCC{?=c^{__CFData}I^I^{?}SCB}^vfff^v^{__CFXMeshSource}[2]^{?}I}24^{__CFXFXProgram={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}b1b1^{__CFXFXProgramDelegate}[2^{__CFString}]^{__CFString}^{__CFString}^{__CFDictionary}^{__CFSet}^v^{__CFDictionary}^vQI}32^{__CFXEngineContext=}40{?=[4]}48r^{CFXColor4=(?=[4f]{?=ffff})}112^{__CFXRasterizerStates=}120^{__CFXBlendStates=}128^{__CFXImage=}136B144"
- "v152@0:8{?=[4]}16^v144"
- "v16@?0@\"<VFXWorldReference>\"8"
- "v16@?0^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1{?={?=SS}I}^{?}^{__CFXGeometry}^{__CFXDeformerStack}f{?=}}8"
- "v20@0:8s16"
- "v21@0:8{?=CCCCB}16"
- "v24@0:8@\"MTKView\"16"
- "v24@0:8@\"UIFocusMovementHint\"16"
- "v24@0:8^{?=^{__CFXEnginePipeline}^{__CFXEngineContext}^{__CFXFXPassInstance}^vQ^{__CFXNode}BBBB}16"
- "v24@0:8^{CGColor=}16"
- "v24@0:8^{VFXMTLComputeCommandEncoder=@@^{VFXMTLBufferPool}I}16"
- "v24@0:8^{__CFXFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__CFXFXRenderGraph}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__CFXFXProgram}^{__CFXMaterial}^{__CFXBlendStates}^{__CFXRasterizerStates}{CFXColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__CFXRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[8{?=CCCb1b1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}[9f]^{?}I^{__CFXNode}^{__CFXNode}^{__CFArray}^{__CFXNode}C^{__CFString}^{__CFString}^{__CFString}^^{__CFXFXPassInput}qq^{__CFDictionary}@?@?^{__CFDictionary}^v}16"
- "v24@0:8^{__CFXGeometry={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXMesh}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16"
- "v24@0:8^{__CFXImage=}16"
- "v24@0:8^{__CFXMeshElement={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}II^{__CFXMeshElement}CCC{?=c^{__CFData}I^I^{?}SCB}^vfff^v^{__CFXMeshSource}[2]^{?}I}16"
- "v24@0:8^{__CFXParametricGeometry={__CFXGeometry={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXMesh}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=fffffffffiiiiiiiiiiI}{?=^?^?^?^?^?^?}^{__CFData}}16"
- "v24@0:8^{__CFXShapeGeometry={__CFXGeometry={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXMesh}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__CFXMesh}[32C]}16"
- "v24@0:8^{__CFXTextGeometry={__CFXShapeGeometry={__CFXGeometry={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXMesh}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__CFXMesh}[32C]}{?=^{__CTFrame}^v^viiBBB{CGRect={CGPoint=dd}{CGSize=dd}}}}16"
- "v24@?0@\"<MTLRenderCommandEncoder>\"8@\"<VFXREDrawCallContext>\"16"
- "v24@?0^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1{?={?=SS}I}^{?}^{__CFXGeometry}^{__CFXDeformerStack}f{?=}}8*16"
- "v24@?0^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1{?={?=SS}I}^{?}^{__CFXGeometry}^{__CFXDeformerStack}f{?=}}8^B16"
- "v24@?0^{__CFXNode=}8^B16"
- "v24@?0^{__CFXShapeBoundary=^{__CFXShapeVertex}IIffffi}8^{__CFXShapeBoundary=^{__CFXShapeVertex}IIffffi}16"
- "v24@?0^{__CFXShapeBoundary=^{__CFXShapeVertex}IIffffi}8i16i20"
- "v28@0:816B24"
- "v28@0:8@\"NSString\"16f24"
- "v28@?0I8^^{__CFXNode}12^^{__CFXLight}20"
- "v28@?0^{__CFXDeformerStack=}8^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1{?={?=SS}I}^{?}^{__CFXGeometry}^{__CFXDeformerStack}f{?=}}16C24"
- "v28@?0c8I12*16I24"
- "v32@0:8@\"<VFXAnimation>\"16@\"NSString\"24"
- "v32@0:8@\"UIFocusUpdateContext\"16@\"UIFocusAnimationCoordinator\"24"
- "v32@0:8@16^{__CFXNode=}24"
- "v32@0:8@?16Q24"
- "v32@0:8^16Q24"
- "v32@0:8^^v16^q24"
- "v32@0:8^{__CFXFXProgram={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}b1b1^{__CFXFXProgramDelegate}[2^{__CFString}]^{__CFString}^{__CFString}^{__CFDictionary}^{__CFSet}^v^{__CFDictionary}^vQI}16^{__CFXWorld=}24"
- "v32@0:8^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1{?={?=SS}I}^{?}^{__CFXGeometry}^{__CFXDeformerStack}f{?=}}16^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1{?={?=SS}I}^{?}^{__CFXGeometry}^{__CFXDeformerStack}f{?=}}24"
- "v32@0:8^{__CFXRendererElement=I^{__CFXNode}(?={__CFXRendererElementAttributes=^{__CFXGeometry}^{__CFXMesh}^{__CFXMaterial}^{__CFXFXRenderGraph}^v}{__CFXRendererElementHandler={?=}@?}){?=[8C]}iIb3b1b1b1b1b3b1b3b1b1}16^{__CFXFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__CFXFXRenderGraph}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__CFXFXProgram}^{__CFXMaterial}^{__CFXBlendStates}^{__CFXRasterizerStates}{CFXColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__CFXRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[8{?=CCCb1b1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}[9f]^{?}I^{__CFXNode}^{__CFXNode}^{__CFArray}^{__CFXNode}C^{__CFString}^{__CFString}^{__CFString}^^{__CFXFXPassInput}qq^{__CFDictionary}@?@?^{__CFDictionary}^v}24"
- "v360@0:8@16{?={?=^{__CFXFXProgram}^{__CFXMaterial}^{__CFXGeometry}^{__CFXFXPass}^{__CFXFXPass}@^{__CFXBlendStates}^{__CFXNode}CCCCCC@{?=C@?}Q}@{?=[8Q]QQC}^{__CFXBlendStates}[8Q]C@@@@@?CBBB}24@352"
- "v36@0:8^{?=SS}16I24^{?=^{__CFXEnginePipeline}^{__CFXEngineContext}^{__CFXFXPassInstance}^vQ^{__CFXNode}BBBB}28"
- "v36@?0^{__CFXConstraint={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFString}fBB{?=^?^?^?^?^?^?}^v}8^v16^{__CFXModelTarget={__CFRuntimeBase=QAQ}^v^vscCCB^?^?}24f32"
- "v37@0:8@16^v24{?=CCCCB}32"
- "v38@0:8^{__CFXMesh=}16^{__CFString=}24{?=BBBBBB}32"
- "v40@0:816q32"
- "v40@0:8@\"MTKView\"16{CGSize=dd}24"
- "v40@0:8@\"NSString\"16@\"NSString\"24@\"NSDictionary\"32"
- "v40@0:8@16^{__CFXNode=}24^{__CFXLight=}32"
- "v40@0:8@16{CGSize=dd}24"
- "v40@0:8Q16@24^{__CFDictionary=}32"
- "v40@0:8^{__CFXEngineContext=}16^{__CFXTextureSampler={__CFRuntimeBase=QAQ}iiiiiifCiQ}24^d32"
- "v40@0:8^{__CFXImageProxy={__CFRuntimeBase=QAQ}{?=^?^?^?^?}^vC}16^{__CFXEngineContext=}24^{__CFXMaterialProperty={__CFRuntimeBase=QAQ}(?=^{__CFXImage}^{__CFXImageProxy}^{__CFXTexture}^v^v{CFXColor4=(?=[4f]{?=ffff})}^v)^vq^vb8b1b4c^{__CFXTextureSampler}^{?}fi^v}32"
- "v40@0:8^{__CFXMaterialProperty={__CFRuntimeBase=QAQ}(?=^{__CFXImage}^{__CFXImageProxy}^{__CFXTexture}^v^v{CFXColor4=(?=[4f]{?=ffff})}^v)^vq^vb8b1b4c^{__CFXTextureSampler}^{?}fi^v}16^{__CFXEngineContext=}24^{__CFXFXPassInstance=^{__CFXFXPass}q^{__CFXFXPassInstance}CCBCC[16^{__CFXArray}]{__CFXCullingContext=^{__CFXEnginePipeline}[16{?=[6{?=}]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[6{?=}]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16][16{?=[4]}]CCCCB^{__CFXFXPass}^v^{__CFXNode}^{__CFXNode}^{__CFXNode}BBBBBBBCQQ^v^{__CFXWorld}^{__CFXEngineContext}dd{?=}{?=[4]}{?=[4]}[16{?=^{?}II}]B^?}^{__CFXNode}SI}32"
- "v40@0:8^{__CFXMesh=}16^{__CFString=}24{?=BBBB}32B36"
- "v40@0:8^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1{?={?=SS}I}^{?}^{__CFXGeometry}^{__CFXDeformerStack}f{?=}}16^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1{?={?=SS}I}^{?}^{__CFXGeometry}^{__CFXDeformerStack}f{?=}}24^{__CFXNode={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXNode}^{__CFXNode}^{__CFXNode}i{?={?=[4]}(?=)}^{?}BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1b1b1{?={?=SS}I}^{?}^{__CFXGeometry}^{__CFXDeformerStack}f{?=}}32"
- "v40@0:8^{__CFXWorld=}16@24@?32"
- "v40@0:8d16d24q32"
- "v40@0:8q16^v24^v32"
- "v44@0:8@16^{__CFXNode=}24^{__CFXLight=}32f40"
- "v48@0:8@16Q24Q32q40"
- "v48@0:8^{__CFXEngineContext=}16^{__CFXTextureSampler={__CFRuntimeBase=QAQ}iiiiiifCiQ}24^d32^{?=BB}40"
- "v48@0:8^{__CFXWorld=}16@24@32@?40"
- "v48@0:8q16B24^v28q36f44"
- "v48@0:8{CGPoint=dd}16q32Q40"
- "v56@0:816^v48"
- "v56@0:8^{?=SS}16{?=qq}24^{__CFXRendererElementStore=}40^{__CFXFXPassInstance=^{__CFXFXPass}q^{__CFXFXPassInstance}CCBCC[16^{__CFXArray}]{__CFXCullingContext=^{__CFXEnginePipeline}[16{?=[6{?=}]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[6{?=}]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16{?=[4]}][16][16{?=[4]}]CCCCB^{__CFXFXPass}^v^{__CFXNode}^{__CFXNode}^{__CFXNode}BBBBBBBCQQ^v^{__CFXWorld}^{__CFXEngineContext}dd{?=}{?=[4]}{?=[4]}[16{?=^{?}II}]B^?}^{__CFXNode}SI}48"
- "v64@0:8@16@24^{__CFXFXProgram={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}b1b1^{__CFXFXProgramDelegate}[2^{__CFString}]^{__CFString}^{__CFString}^{__CFDictionary}^{__CFSet}^v^{__CFDictionary}^vQI}32^{__CFXMaterial=}40^{__CFXGeometry={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFXMesh}^{__CFXMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__CFXMeshElement}^{__CFXMeshSource}^{__CFXMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}48^{__CFXFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__CFXFXRenderGraph}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__CFXFXProgram}^{__CFXMaterial}^{__CFXBlendStates}^{__CFXRasterizerStates}{CFXColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__CFXRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[8{?=CCCb1b1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}[9f]^{?}I^{__CFXNode}^{__CFXNode}^{__CFArray}^{__CFXNode}C^{__CFString}^{__CFString}^{__CFString}^^{__CFXFXPassInput}qq^{__CFDictionary}@?@?^{__CFDictionary}^v}56"
- "v64@0:8^{__CFXFXProgram=}16@24@32@40@?48@?56"
- "v64@0:8^{__CFXWorld=}16@24@32@40@48@?56"
- "v64@0:8^{__CFXWorld=}16@24@32Q40@48@?56"
- "v72@0:8^{?=fIIQQ}16^{?=I^{__CFXMesh}^{__CFXMeshSource}^{__CFXMeshSource}Q}24*32Q40Q48^I56@64"
- "v88@0:8^{?=fIIQQ}16^{?=I^{__CFXMesh}^{__CFXMeshSource}^{__CFXMeshSource}Q}24*32Q40*48Q56Q64^I72@80"
- "v96@0:8{?=^{__CFXFXProgram}^{__CFXMaterial}^{__CFXGeometry}^{__CFXNode}^{__CFXMesh}^{__CFXMeshElement}{?=[8C]}^{__CFXFXPass}^IBBBBBb3}16"
- "vector_shadow_frag"
- "vector_shadow_vert"
- "vertexWeightIndices[%d]"
- "vertexWeights[%d]"
- "verticalSampleStorage"
- "vfx.prttime"
- "vfxComputeEncoder->isEncoding()"
- "vfxRenderContext"
- "vfx_atan2(%0, %1)"
- "vfx_clamp(%0, %1, %2)"
- "vfx_compute_%SCRIPT_ID%::vfx_compute"
- "vfx_custom_shader_%SCRIPT_ID%::vfx_fragment"
- "vfx_custom_shader_%SCRIPT_ID%::vfx_vertex"
- "vfx_ddgi_border"
- "vfx_ddgi_raytrace"
- "vfx_ddgi_update"
- "vfx_debug_ddgi"
- "vfx_distance(%0, %1)"
- "vfx_distance_squared(%0, %1)"
- "vfx_get_rotation(%0)"
- "vfx_get_scale(%0)"
- "vfx_is_almost_equal(%0, %1)"
- "vfx_is_almost_zero(%0)"
- "vfx_make_float4(vfx_linear_to_srgb(vfx_get_xyz(%0)), %0.w)"
- "vfx_make_float4(vfx_srgb_to_linear(vfx_get_xyz(%0)), %0.w)"
- "vfx_make_float_range"
- "vfx_make_int_range"
- "vfx_make_transform(%rotation, vfx_make_float4(%translation, 1.0), %scale)"
- "vfx_make_transform(%rotation, vfx_make_float4(%translation, 1.0f), %scale)"
- "vfx_mix(%0, %1, %2)"
- "vfx_mix(vfx_remap_01(%4, %0, %1), %2, %3)"
- "vfx_muladd(%0, %1, %2)"
- "vfx_nodes"
- "vfx_project_position(%0, %1)"
- "vfx_quat_conjugate(%0)"
- "vfx_quat_from_axisangle(%axis, %angle)"
- "vfx_quat_from_axisangle(%axisAngle)"
- "vfx_quat_from_axisangle_(%axis, %angle)"
- "vfx_quat_from_axisangle_(%axisAngle)"
- "vfx_quat_from_euler(%eulerAngles)"
- "vfx_quat_from_euler_(%eulerAngles)"
- "vfx_quat_from_matrix3x3(%rotation)"
- "vfx_quat_from_matrix4x4(%rotation)"
- "vfx_quat_from_normal(%normal)"
- "vfx_quat_from_normal_(%normal)"
- "vfx_quat_is_identity(%0)"
- "vfx_quat_length_(%0)"
- "vfx_quat_look_at_(%0, %1)"
- "vfx_quat_normalize(%0)"
- "vfx_quat_rotation_between_fast_(%0, %1)"
- "vfx_quat_to_axisangle_(%0)"
- "vfx_reduce_add(%0)"
- "vfx_reduce_mul(%0)"
- "vfx_remap_01(%2, %0, %1)"
- "vfx_robust_normalize(%0)"
- "vfx_rt_clearcoat_spatial_restir"
- "vfx_rt_direct_lighting_denoise"
- "vfx_rt_direct_lighting_spatial_restir"
- "vfx_rt_indirect_diffuse_spatial_restir"
- "vfx_rt_specular_spatial_restir"
- "vfx_rt_specular_temporal_denoise"
- "vfx_rt_specular_trace"
- "vfx_rt_specular_upscale"
- "vfx_saturate(%0)"
- "vfx_scale(%0, %1)"
- "vfx_script_set_current_state(%script_context, %1, %2);"
- "vfx_script_tick(%script_context, %1, %2);"
- "vfx_sin((%0 * M_PI) / 2.0f)"
- "vfx_sin((%0 * M_PI_F) / 2)"
- "vfx_smoothstep(%1, %2, %0)"
- "vfx_ssao_blur_x"
- "vfx_ssao_blur_y"
- "vfx_ssao_compute"
- "vfx_ssr_blur_x"
- "vfx_ssr_blur_y"
- "vfx_ssr_raytrace_frag"
- "vfx_ssr_raytrace_vert"
- "vfx_step(%1, %0)"
- "vfx_transform(%0, %1)"
- "vfx_transform_direction(%0, %1)"
- "vfx_transform_normal(%0, %1)"
- "vfx_transform_position(%0, %1)"
- "vfx_translate(%0, %1)"
- "vfx_transpose(%0)"
- "vfx_worker_group"
- "viewInverseTransform"
- "viewMatrix0"
- "viewMatrix1"
- "viewTransform"
- "viewedObjectSphere"
- "viewpointCoordinateSpace"
- "viewportDependant"
- "void *const * arguments_buffer = vfx_script_get_arguments_buffer(script_context);\n"
- "vrr_blit_physical_to_screen"
- "vrr_blit_physical_to_screen_layered"
- "w == count * indexCountPerPrimitive"
- "w == dataLength"
- "w == numberOfInfluence * vertexCount"
- "waitDrawable"
- "wasAddedToWorld:"
- "weightCount == _morphTargetCount"
- "weightsCount"
- "willBeRemovedFromWorld:"
- "withDefaultIBLConstantBuffer::"
- "withDefaultLightConstantBuffer::"
- "worldBackground"
- "worldWithURL:options:transferringConfigurationFrom:error:"
- "wrapP"
- "writeSIMD2D:to:"
- "writeSIMD3D:to:"
- "writeSIMD3x3D:to:"
- "writeSIMD4D:to:"
- "writeSIMD4x4D:to:"
- "{\n  \"passes\" : {\n    \"VFX_ApplyCIFilter\" : {\n      \"outputs\" : {\n        \"color\" : \"VFX-CI-effect-color\"\n      },\n      \"inputs\" : {\n        \"myInput1\" : \"VFX-CI-nodetree-color\"\n      },\n      \"draw\" : \"CUSTOM\"\n    },\n    \"VFX_renderCINodeTree\" : {\n      \"outputs\" : {\n        \"depth\" : \"VFX-CI-nodetree-depth\",\n        \"color\" : \"VFX-CI-nodetree-color\"\n      },\n      \"ignoreFloors\" : true,\n      \"draw\" : \"DRAW_NODE\",\n      \"node\" : \"self\"\n    },\n    \"VFX_renderCIQuad\" : {\n      \"inputs\" : {\n        \"u_m\" : \"CFX-CIFilter_modelMatrix\",\n        \"u_color\" : {\n          \"target\" : \"VFX-CI-effect-color\",\n          \"sampler\" : {\n            \"magnificationFilter\" : \"nearest\",\n            \"minificationFilter\" : \"nearest\"\n          }\n        },\n        \"u_middleZ\" : \"CFX-CIFilter_middleZ\",\n        \"u_depth\" : {\n          \"target\" : \"VFX-CI-nodetree-depth\",\n          \"sampler\" : {\n            \"magnificationFilter\" : \"nearest\",\n            \"minificationFilter\" : \"nearest\"\n          }\n        }\n      },\n      \"hasConstantAlpha\" : false,\n      \"colorStates\" : {\n        \"clear\" : false\n      },\n      \"depthStates\" : {\n        \"clear\" : false\n      },\n      \"program\" : \"CFX-CIFilterComposite\",\n      \"draw\" : \"none\",\n      \"clientProgram\" : false,\n      \"blendStates\" : {\n        \"enable\" : true,\n        \"colorDst\" : \"oneMinusSrcAlpha\",\n        \"colorSrc\" : \"one\"\n      }\n    }\n  },\n  \"sequence\" : [\n    \"VFX_renderCINodeTree\",\n    \"VFX_ApplyCIFilter\",\n    \"VFX_renderCIQuad\"\n  ],\n  \"symbols\" : {\n    \"CFX-CIFilter_middleZ\" : {\n      \"type\" : \"float\"\n    },\n    \"CFX-CIFilter_modelMatrix\" : {\n      \"type\" : \"mat4\"\n    }\n  },\n  \"targets\" : {\n    \"VFX-CI-effect-color\" : {\n      \"type\" : \"color\"\n    },\n    \"VFX-CI-nodetree-color\" : {\n      \"target\" : \"texture_rectangle\",\n      \"type\" : \"color\"\n    },\n    \"VFX-CI-nodetree-depth\" : {\n      \"type\" : \"depth\"\n    }\n  }\n}"
- "{\n  \"sequence\" : [\n                \"VFX_renderCINodeTree\",\n                \"VFX_ApplyCIFilter\",\n                \"VFX_renderCIQuad\"\n                ],\n  \"targets\" : {\n    \"VFX-CI-nodetree-depth\" : {\n      \"type\" : \"depth\"\n    },\n    \"VFX-CI-nodetree-color\" : {\n      \"type\" : \"color\",\n      \"format\" : \"rgba\",\n    },\n    \"VFX-CI-effect-color\" : {\n      \"type\" : \"color\",\n      \"format\" : \"rgba\",\n      \"usage\" : [\"shaderWrite\", \"shaderRead\"]\n    }\n  },\n  \"symbols\" : {\n    \"CFX-CIFilter_middleZ\" : {\n      \"type\" : \"float\"\n    },\n    \"CFX-CIFilter_extent\" : {\n      \"type\" : \"float4\"\n    }\n  },\n  \"passes\" : {\n    \"VFX_renderCIQuad\" : {\n      \"inputs\" : {\n        \"u_color\" : {\n          \"target\" : \"VFX-CI-effect-color\",\n          \"sampler\" : {\n            \"magnificationFilter\" : \"nearest\",\n            \"minificationFilter\" : \"nearest\"\n          }\n        },\n        \"u_middleZ\" : \"CFX-CIFilter_middleZ\",\n        \"u_extent\" : \"CFX-CIFilter_extent\",\n        \"u_depth\" : {\n          \"target\" : \"VFX-CI-nodetree-depth\",\n          \"sampler\" : {\n            \"magnificationFilter\" : \"nearest\",\n            \"minificationFilter\" : \"nearest\"\n          }\n        }\n      },\n      \"hasConstantAlpha\" : false,\n      \"colorStates\" : {\n        \"clear\" : false\n      },\n      \"depthStates\" : {\n        \"clear\" : false\n      },\n      \"cullMode\" : \"none\",\n      \"metalVertexShader\" : \"vfx_filterCompositeVert\",\n      \"metalFragmentShader\" : \"vfx_filterCompositeFrag\",\n      \"draw\" : \"none\",\n      \"clientProgram\" : false,\n      \"blendStates\" : {\n        \"enable\" : true,\n        \"colorDst\" : \"oneMinusSrcAlpha\",\n        \"colorSrc\" : \"one\"\n      }\n    },\n    \"VFX_ApplyCIFilter\" : {\n      \"outputs\" : {\n        \"color\" : \"VFX-CI-effect-color\"\n      },\n      \"inputs\" : {\n        \"myInput1\" : \"VFX-CI-nodetree-color\"\n      },\n      \"draw\" : \"CUSTOM\"\n    },\n    \"VFX_renderCINodeTree\" : {\n      \"draw\" : \"DRAW_NODE\",\n      \"node\" : \"self\",\n      \"ignoreFloors\" : true,\n      \"outputs\" : {\n        \"depth\" : \"VFX-CI-nodetree-depth\",\n        \"color\" : \"VFX-CI-nodetree-color\"\n      },\n      \"colorStates\" : {\n        \"clear\" : true\n      },\n      \"depthStates\" : {\n        \"clear\" : true\n      },\n      \n    }\n  }\n}\n"
- "{\n  \"sequence\" : [\n                \"VFX_renderCIQuad\"\n                ],\n  \"targets\" : {\n    \"VFX-CI-effect-depth\" : {\n      \"type\" : \"depth\"\n    },\n    \"VFX-CI-effect-color\" : {\n      \"type\" : \"color\",\n      \"format\" : \"rgba\",\n      \"usage\" : [\"shaderWrite\", \"shaderRead\"]\n    }\n  },\n  \"symbols\" : {\n    \"CFX-CIFilter_middleZ\" : {\n      \"type\" : \"float\"\n    },\n    \"CFX-CIFilter_extent\" : {\n      \"type\" : \"float4\"\n    }\n  },\n  \"passes\" : {\n    \"VFX_renderCIQuad\" : {\n      \"inputs\" : {\n        \"u_color\" : {\n          \"target\" : \"VFX-CI-effect-color\",\n          \"sampler\" : {\n            \"magnificationFilter\" : \"nearest\",\n            \"minificationFilter\" : \"nearest\"\n          }\n        },\n        \"u_middleZ\" : \"CFX-CIFilter_middleZ\",\n        \"u_extent\" : \"CFX-CIFilter_extent\",\n        \"u_depth\" : {\n          \"target\" : \"VFX-CI-effect-depth\",\n          \"sampler\" : {\n            \"magnificationFilter\" : \"nearest\",\n            \"minificationFilter\" : \"nearest\"\n          }\n        }\n      },\n      \"hasConstantAlpha\" : false,\n      \"colorStates\" : {\n        \"clear\" : false\n      },\n      \"depthStates\" : {\n        \"clear\" : false\n      },\n      \"cullMode\" : \"none\",\n      \"metalVertexShader\" : \"vfx_filterCompositeVert\",\n      \"metalFragmentShader\" : \"vfx_filterCompositeFrag\",\n      \"draw\" : \"none\",\n      \"clientProgram\" : false,\n      \"blendStates\" : {\n        \"enable\" : true,\n        \"colorDst\" : \"oneMinusSrcAlpha\",\n        \"colorSrc\" : \"one\"\n      }\n    },\n  }\n}\n"
- "{?=\"buffer\"@\"<MTLBuffer>\"\"offset\"Q}"
- "{?=\"format\"C\"sampleCount\"C\"textureUsage\"C\"renderToTexture\"b1\"forceTextureRect\"b1\"viewportDependant\"b1\"renderToIOSurface\"b1\"mipmapped\"b1\"textureCube\"b1\"padding\"[4C]}"
- "{?=\"frameBuffer\"^{__CFXFramebuffer}\"multisamplingFrameBuffer\"^{__CFXFramebuffer}\"drawableSize\"{CGSize=\"width\"d\"height\"d}}"
- "{?=\"frameLightingSetDatas\"{unordered_map<unsigned long long, VFXMTLLightSetData, std::hash<unsigned long long>, std::equal_to<unsigned long long>, std::allocator<std::pair<const unsigned long long, VFXMTLLightSetData>>>=\"__table_\"{__hash_table<std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, std::__unordered_map_hasher<unsigned long long, std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, std::hash<unsigned long long>, std::equal_to<unsigned long long>>, std::__unordered_map_equal<unsigned long long, std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, std::equal_to<unsigned long long>, std::hash<unsigned long long>>, std::allocator<std::__hash_value_type<unsigned long long, VFXMTLLightSetData>>>=\"__bucket_list_\"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, void *> *> *>>>=\"__ptr_\"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, void *> *> *>>>=\"__value_\"^^v\"__value_\"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, void *> *> *>>=\"__data_\"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, void *> *> *>>=\"__value_\"Q}}}}\"__p1_\"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, void *>>>=\"__value_\"{__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, void *> *>=\"__next_\"^v}}\"__p2_\"{__compressed_pair<unsigned long, std::__unordered_map_hasher<unsigned long long, std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, std::hash<unsigned long long>, std::equal_to<unsigned long long>>>=\"__value_\"Q}\"__p3_\"{__compressed_pair<float, std::__unordered_map_equal<unsigned long long, std::__hash_value_type<unsigned long long, VFXMTLLightSetData>, std::equal_to<unsigned long long>, std::hash<unsigned long long>>>=\"__value_\"f}}}\"currentLightingHashKey\"Q\"currentLightingDesc\"{?=\"count\"q\"lights\"[8^{__CFXLight}]\"lightsData\"[8^{__CFXLightRuntimeData}]}\"currentLightingSpace\"{?=\"columns\"[4]}\"currentLightingSpaceShadow\"{?=\"columns\"[4]}\"needLightingSpaceTransformation\"B\"clusterSystem\"{VFXMTLClusterSystem=\"clustersCount\"\"tileSize\"\"selectedDebugClusterIndex\"\"_debugClusterTilesPipeline\"@\"VFXMTLRenderPipeline\"\"_debugLightIndicesBufferPipeline\"@\"VFXMTLRenderPipeline\"\"_debugClusterSlicesPipeline\"@\"VFXMTLRenderPipeline\"\"_debugProgram\"[7^{__CFXFXProgram}]\"_debugShapes\"[7^{__CFXMesh}]}\"clusterInfo\"{Info=\"clusterBuffer\"{?=\"memory\"*\"buffer\"@\"<MTLBuffer>\"\"offset\"Q}\"clusterTexture\"@\"<MTLTexture>\"\"lightIndicesTexture\"@\"<MTLTexture>\"\"cellSize\"\"clusterScale\"\"cellPixelSize\"\"omniLightsRange\"\"spotLightsRange\"\"probeLightsRange\"\"lightsBuffer\"{?=\"memory\"*\"buffer\"@\"<MTLBuffer>\"\"offset\"Q}\"lightsBufferLightCount\"I\"shadowTexture\"@\"<MTLTexture>\"\"iesOrGoboTextures\"[8@\"<MTLTexture>\"]\"samplerStates\"[8@\"<MTLSamplerState>\"]\"areaBuffer\"@\"<MTLBuffer>\"\"areaBufferOffset\"Q\"areaBufferOffsets\"[8Q]}\"reflectionProbesTextureArray\"@\"<MTLTexture>\"}"
- "{?=\"initialized\"B\"showFullStatistics\"B\"showRenderOptionsPanel\"B\"fps\"f\"waitDisplayLinkTime\"f\"pressedButtonIndex\"q\"fpsString\"^{__CFString}\"shortString\"^{__CFString}\"internalString\"^{__CFString}\"lightingStatistics\"[9I]\"stats\"{__CFXEngineStats=\"verticesProcessed\"I\"primitivesProcessed\"I\"drawCount\"I\"drawStep\"I\"frameCount\"I\"fboSwitches\"I\"vboSwitches\"I\"attSwitches\"I\"attEnabling\"I\"iboSwitches\"I\"vaoSwitches\"I\"prgSwitches\"I\"texSwitches\"I\"rssSwitches\"I\"getCount\"I\"uniformFloatSent\"I\"uniformIntSent\"I\"uniformVector2Sent\"I\"uniformVector3Sent\"I\"uniformVector4Sent\"I\"uniformMatrix4Sent\"I\"vboUploaded\"I\"iboUploaded\"I\"texUploaded\"I\"cpuTime\"d\"cstrTime\"d\"phyTime\"d\"prtTime\"d\"animTime\"d\"skinTime\"d\"mrphTime\"d\"rendTime\"d\"twoDTime\"d\"delegateTime\"d\"glFlushTime\"d\"waitDisplayLinkTime\"d\"drawableWaitTime\"d\"gpuTime\"d\"lastDisplayLinkTime\"d\"prgCount\"I\"texCount\"I\"fboCount\"I\"vboCount\"I\"rboCount\"I\"iboCount\"I\"cboCount\"I\"vaoCount\"I\"fboMemory\"I\"rboMemory\"I\"vboMemory\"I\"iboMemory\"I\"cboMemory\"I\"texMemory\"I\"backBufferMemory\"I\"depthBuffersMemory\"I\"onlineShaderCount\"I\"onlineShaderCompilationTime\"d\"renderPipelineCount\"I\"renderPipelineCompilationTime\"d\"computePipelineCount\"I\"computePipelineCompilationTime\"d\"frmAvgTime\"d\"frmMinTime\"d\"frmMaxTime\"d\"frameTimeHistory\"[60d]\"frameTimeCurrentIndex\"I\"startTime\"d\"lastFrameTime\"d}}"
- "{?=\"kind\"q\"active\"B\"strength\"f\"dampening\"f\"noiseAmount\"f\"noiseSeed\"Q\"categoryBitMask\"Q\"shape\"q\"scope\"q\"cullMode\"q\"falloffExponent\"f\"halfExtents\"\"offset\"\"smoothness\"f\"speed\"f}"
- "{?=\"lock\"{os_unfair_lock_s=\"_os_unfair_lock_opaque\"I}\"keyCodeConfiguration\"@\"NSDictionary\"\"keyDown\"{set<unsigned short, std::less<unsigned short>, std::allocator<unsigned short>>=\"__tree_\"{__tree<unsigned short, std::less<unsigned short>, std::allocator<unsigned short>>=\"__begin_node_\"^v\"__pair1_\"{__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<unsigned short, void *>>>=\"__value_\"{__tree_end_node<std::__tree_node_base<void *> *>=\"__left_\"^v}}\"__pair3_\"{__compressed_pair<unsigned long, std::less<unsigned short>>=\"__value_\"Q}}}\"forward\"{vector<unsigned short, std::allocator<unsigned short>>=\"__begin_\"^S\"__end_\"^S\"__end_cap_\"{__compressed_pair<unsigned short *, std::allocator<unsigned short>>=\"__value_\"^S}}\"backward\"{vector<unsigned short, std::allocator<unsigned short>>=\"__begin_\"^S\"__end_\"^S\"__end_cap_\"{__compressed_pair<unsigned short *, std::allocator<unsigned short>>=\"__value_\"^S}}\"left\"{vector<unsigned short, std::allocator<unsigned short>>=\"__begin_\"^S\"__end_\"^S\"__end_cap_\"{__compressed_pair<unsigned short *, std::allocator<unsigned short>>=\"__value_\"^S}}\"right\"{vector<unsigned short, std::allocator<unsigned short>>=\"__begin_\"^S\"__end_\"^S\"__end_cap_\"{__compressed_pair<unsigned short *, std::allocator<unsigned short>>=\"__value_\"^S}}}"
- "{?=\"mouseDown\"b1\"mouseUp\"b1\"mouseMoved\"b1\"mouseDragged\"b1\"keyDown\"b1\"keyUp\"b1\"touchBegan\"b1\"touchMoved\"b1\"touchEnded\"b1\"touchCanceled\"b1}"
- "{?=\"passInstance\"^{__CFXFXPassInstance}\"lightingSystem\"^{__CFXLightingSystem}\"dynamicBatchingSystem\"^{__CFXDynamicBatchingSystem}\"pass\"^{__CFXFXPass}\"renderGraphPass\"^v\"passRequiresLighting\"B\"isMainPass\"B\"transformTree\"^{__CFXTransformTree}\"programHashCodeStoreKey\"Q}"
- "{?=\"renderSliceIndex\"C\"eyeCount\"C\"viewMapping\"C\"multiVertexOutputStreamGenerator\"C\"isMainPass\"B}"
- "{?=\"stage\"i\"bindings\"@\"NSArray\"\"customBlocks\"@\"NSDictionary\"\"pass\"^{__CFXFXPass}}"
- "{?=\"supportsUpdate\"b1\"supportsDidApplyAnimations\"b1\"supportsDidSimulatePhysics\"b1\"supportsDidApplyConstraints\"b1\"supportsWillRender\"b1\"supportsDidRender\"b1\"supportsInputTime\"b1\"supportsReadSubdivCache\"b1\"supportsWriteSubdivCache\"b1\"supportsMainPassCustomPostProcess\"b1}"
- "{?=\"textureInfo\"{?=\"texture\"^{__CFXImage}\"textureSize\"{CGSize=\"width\"d\"height\"d}\"isRetina\"B}\"lineHeight\"f\"characterWidth_texture\"s\"characterWidth_typography\"^f\"characterHeight_texture\"s\"symbolRects\"^{?}}"
- "{?=\"view_from_crworld\"[2{?=\"columns\"[4]}]\"proj_from_crworld\"[2{?=\"columns\"[4]}]\"proj_from_view\"[2{?=\"columns\"[4]}]\"view_from_proj\"[2{?=\"columns\"[4]}]\"crws_camera_pos\"[2]\"worldReferencePosition\"\"renderTargetSize\"\"viewportCount\"I\"useVertexAmplification\"I\"viewport_percents\"[2]}"
- "{?=\"weakProgram\"^{__CFXFXProgram}\"baseIndex\"I\"baseVertex\"I\"vertexSize\"I\"allocatedVerticesSize\"I\"allocatedIndicesSize\"I\"textureImage\"^{__CFXImage}\"texture\"^{__CFXTexture}\"drawMode\"C\"orthographic\"B\"clearDepthBuffer\"B\"enableDepthTest\"B\"enableCulling\"B\"isDynamic\"B\"mesh\"^{__CFXMesh}\"meshElement\"^{__CFXMeshElement}\"_cache\"{?=\"verticesStride\"Q\"colorsStride\"Q\"uvsStride\"Q\"verticesData\"*\"colorsData\"*\"uvsData\"*}\"_usedMeshes\"@\"NSMutableSet\"\"_freeMeshes\"@\"NSMutableSet\"\"_usedMeshElements\"@\"NSMutableSet\"\"_freeMeshElements\"@\"NSMutableSet\"}"
- "{?=[4]}80@0:8{?=[4]}16"
- "{?=cffif^v^v}16@0:8"
- "{?={?=cffif^v^v}^v^viiBB{CGRect={CGPoint=dd}{CGSize=dd}}f}16@0:8"
- "{CFXSphere=\"vector\"}"
- "{CFXSphere=}16@0:8"
- "{Cache=\"rasterizerStates\"^{__CFXRasterizerStates}\"mesh\"^{__CFXMesh}\"metalMesh\"@\"VFXMTLMesh\"\"meshElement\"^{__CFXMeshElement}\"metalMeshElement\"@\"VFXMTLMeshElement\"\"program\"^{__CFXFXProgram}\"material\"^{__CFXMaterial}\"geometry\"^{__CFXGeometry}\"metalShadable\"@\"VFXMTLShadable\"\"commonProfile\"^{__CFXCommonProfile}\"blendStates\"^{__CFXBlendStates}\"colorBufferWriteMask\"C\"primitiveTopologyClass\"C\"node\"^{__CFXNode}\"pointOfView\"^{__CFXNode}\"deformers\"^{__CFXDeformerStack}\"viewTransform\"{?=\"columns\"[4]}\"proj\"{?=\"columns\"[4]}\"vertexDescriptorHash\"Q\"tessellationPipelineStateHash\"C\"renderPipeline\"@\"VFXMTLRenderPipeline\"}"
- "{VFXMTLComputeCommandEncoder=\"_encoder\"@\"RGCachedComputeCommandEncoder\"\"_commandBuffer\"@\"<MTLCommandBuffer>\"\"_bufferPool\"^{VFXMTLBufferPool}\"_features\"I}"
- "{atomic<int>=\"__a_\"{__cxx_atomic_impl<int, std::__cxx_atomic_base_impl<int>>=\"__a_value\"Ai}}"
- "\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\""
- "\xf0\xf0\xf2"

```
