## CoreLocation

> `/System/Library/Frameworks/CoreLocation.framework/CoreLocation`

```diff

-2964.0.4.0.0
-  __TEXT.__text: 0x1c3f74
-  __TEXT.__auth_stubs: 0x1a40
-  __TEXT.__objc_methlist: 0xa26c
-  __TEXT.__const: 0x4a85
-  __TEXT.__gcc_except_tab: 0xd448
-  __TEXT.__oslogstring: 0x34996
-  __TEXT.__cstring: 0x215fa
-  __TEXT.__ustring: 0x750
-  __TEXT.__unwind_info: 0x5410
-  __TEXT.__objc_classname: 0x13ec
-  __TEXT.__objc_methname: 0x1b5a3
-  __TEXT.__objc_methtype: 0x62a6
-  __TEXT.__objc_stubs: 0xdf40
-  __DATA_CONST.__got: 0x720
-  __DATA_CONST.__const: 0x1ec8
-  __DATA_CONST.__objc_classlist: 0x550
+3051.0.3.0.0
+  __TEXT.__text: 0x1fa678
+  __TEXT.__auth_stubs: 0x1af0
+  __TEXT.__objc_methlist: 0xa4b4
+  __TEXT.__const: 0x4948
+  __TEXT.__gcc_except_tab: 0xed4c
+  __TEXT.__oslogstring: 0x3a37a
+  __TEXT.__cstring: 0x24e7e
+  __TEXT.__ustring: 0x70a
+  __TEXT.__unwind_info: 0x5898
+  __TEXT.__objc_classname: 0x1395
+  __TEXT.__objc_methname: 0x1cc1b
+  __TEXT.__objc_methtype: 0x5d9b
+  __TEXT.__objc_stubs: 0xea00
+  __DATA_CONST.__got: 0x748
+  __DATA_CONST.__const: 0x2198
+  __DATA_CONST.__objc_classlist: 0x538
   __DATA_CONST.__objc_catlist: 0x18
   __DATA_CONST.__objc_protolist: 0xb8
   __DATA_CONST.__objc_imageinfo: 0x8
-  __DATA_CONST.__objc_selrefs: 0x51e8
+  __DATA_CONST.__objc_selrefs: 0x54e8
   __DATA_CONST.__objc_protorefs: 0x78
-  __DATA_CONST.__objc_superrefs: 0x4e8
+  __DATA_CONST.__objc_superrefs: 0x4d0
   __DATA_CONST.__objc_arraydata: 0x90
-  __AUTH_CONST.__auth_got: 0xd38
-  __AUTH_CONST.__const: 0x3ae0
-  __AUTH_CONST.__cfstring: 0xaf60
-  __AUTH_CONST.__objc_const: 0x119a8
+  __AUTH_CONST.__auth_got: 0xd90
+  __AUTH_CONST.__const: 0x3bb8
+  __AUTH_CONST.__cfstring: 0xb9e0
+  __AUTH_CONST.__objc_const: 0x11778
   __AUTH_CONST.__objc_arrayobj: 0x78
   __AUTH_CONST.__objc_doubleobj: 0x10
-  __AUTH_CONST.__objc_intobj: 0x90
   __AUTH_CONST.__objc_dictobj: 0x50
-  __AUTH.__objc_data: 0x2d00
-  __DATA.__objc_ivar: 0xb24
-  __DATA.__data: 0x9e0
-  __DATA.__bss: 0x358
-  __DATA.__common: 0x1b0
-  __DATA_DIRTY.__objc_ivar: 0x80
-  __DATA_DIRTY.__objc_data: 0x820
+  __AUTH_CONST.__objc_intobj: 0x78
+  __AUTH.__objc_data: 0x2ee0
+  __DATA.__objc_ivar: 0xb28
+  __DATA.__data: 0xf20
+  __DATA.__bss: 0xae0
+  __DATA.__common: 0x68
+  __DATA_DIRTY.__objc_ivar: 0xa8
+  __DATA_DIRTY.__objc_data: 0x550
   __DATA_DIRTY.__data: 0x88
-  __DATA_DIRTY.__bss: 0x1200
-  __DATA_DIRTY.__common: 0x68
+  __DATA_DIRTY.__bss: 0xd50
+  __DATA_DIRTY.__common: 0x20
   - /System/Library/Frameworks/CoreBluetooth.framework/CoreBluetooth
   - /System/Library/Frameworks/CoreData.framework/CoreData
   - /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation
   - /System/Library/Frameworks/Foundation.framework/Foundation
   - /System/Library/Frameworks/IOKit.framework/Versions/A/IOKit
   - /System/Library/Frameworks/Security.framework/Security
+  - /System/Library/Frameworks/_LocationEssentials.framework/_LocationEssentials
   - /System/Library/PrivateFrameworks/CoreAnalytics.framework/CoreAnalytics
   - /System/Library/PrivateFrameworks/GeoServices.framework/GeoServices
   - /System/Library/PrivateFrameworks/LocationSupport.framework/LocationSupport
   - /System/Library/PrivateFrameworks/ManagedConfiguration.framework/ManagedConfiguration
+  - /System/Library/PrivateFrameworks/PairedDeviceRegistry.framework/PairedDeviceRegistry
   - /System/Library/PrivateFrameworks/RunningBoardServices.framework/RunningBoardServices
   - /usr/lib/libMobileGestalt.dylib
   - /usr/lib/libSystem.B.dylib

   - /usr/lib/libsqlite3.dylib
   - /usr/lib/libxml2.2.dylib
   - /usr/lib/libz.1.dylib
-  UUID: 242BBE5D-DF14-31AC-A35C-7FCBFD98A207
-  Functions: 5086
-  Symbols:   1123
-  CStrings:  11344
+  UUID: 50F95936-27E4-3FF0-9708-58D9938CEF10
+  Functions: 5308
+  Symbols:   1115
+  CStrings:  11921
 
Symbols:
+ _CLClientSnapLocationToResolution
+ _OBJC_CLASS_$_CLBIO_Calibration
+ _OBJC_CLASS_$_CLEEDFeedbackRequest
+ _OBJC_CLASS_$_CLIdentifiableClientConnectionManager
+ _OBJC_CLASS_$_CLLocationExtendedTimestamps
+ _OBJC_CLASS_$_CLRecentLocationsFetchOptions
+ _OBJC_CLASS_$_CLVisitCondition
+ _OBJC_CLASS_$_PDRRegistry
+ _OBJC_EHTYPE_$_NSException
+ _OBJC_METACLASS_$_CLBIO_Calibration
+ _OBJC_METACLASS_$_CLEEDFeedbackRequest
+ _OBJC_METACLASS_$_CLIdentifiableClientConnectionManager
+ _OBJC_METACLASS_$_CLLocationExtendedTimestamps
+ _OBJC_METACLASS_$_CLRecentLocationsFetchOptions
+ _OBJC_METACLASS_$_CLVisitCondition
+ __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE21__grow_by_and_replaceEmmmmmmPKc
+ __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEmc
+ __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6insertEmPKcm
+ __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm
+ __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC2ERKS5_mmRKS4_
+ __ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEj
+ __ZNSt3__113random_deviceC1ERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE
+ __ZNSt3__113random_deviceD1Ev
+ __ZNSt3__113random_deviceclEv
+ __ZNSt3__16localeC1Ev
+ __ZTVNSt3__115basic_streambufIcNS_11char_traitsIcEEEE
+ ___memset_chk
+ _acosf
+ _asinf
+ _dispatch_queue_attr_make_with_autorelease_frequency
+ _kFeedbackCallReasonKey
+ _kFeedbackCallRelatedToEmergencyKey
+ _kFeedbackCallTriggerKey
+ _kFeedbackCallerResponsiveKey
+ _kFeedbackRespondersDispatchedForCallKey
+ _kFeedbackVersionKey
+ _kRequestTypeFeedbackCollection
+ _mach_get_times
+ _objc_begin_catch
+ _objc_end_catch
+ _objc_retain_x3
+ _objc_retain_x6
+ _xpc_transaction_exit_clean
- _CLClientCreateIso6709Notation
- _CLClientGetDistanceHighPrecision
- _CLLocationCoordinate2DGetDistanceFrom
- _CLLocationDistanceMax
- _CLTimeIntervalMax
- _NSCalendarIdentifierGregorian
- _NSUnderlyingErrorKey
- _OBJC_CLASS_$_CLFloor
- _OBJC_CLASS_$_CLLocationGnssOdometerInfo
- _OBJC_CLASS_$_CLLocationMatchInfo
- _OBJC_CLASS_$_CLLocationSourceInformation
- _OBJC_CLASS_$_CLLocationTrackRunInfo
- _OBJC_CLASS_$_NSCalendar
- _OBJC_CLASS_$__CLLocationFusionInfo
- _OBJC_METACLASS_$_CLFloor
- _OBJC_METACLASS_$_CLLocation
- _OBJC_METACLASS_$_CLLocationGnssOdometerInfo
- _OBJC_METACLASS_$_CLLocationMatchInfo
- _OBJC_METACLASS_$_CLLocationSourceInformation
- _OBJC_METACLASS_$_CLLocationTrackRunInfo
- _OBJC_METACLASS_$__CLLocationFusionInfo
- _OBJC_METACLASS_$__CLLocationGroundAltitude
- __ZNKSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4findEcm
- __ZNKSt3__115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEE3strEv
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEPKc
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEPKc
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6insertEmPKc
- __ZNSt3__115basic_streambufIcNS_11char_traitsIcEEEC2Ev
- __ZNSt3__115basic_streambufIcNS_11char_traitsIcEEED2Ev
- __Znwm
- _kCLLocationAccuracyAggressivePrecisionReduction
- _kCLLocationAccuracyBestForNavigation
- _kCLLocationAccuracyBystander
- _kCLLocationAccuracyBystanderPreLoiOverride
- _kCLLocationAccuracyE911CallInviteHigh
- _kCLLocationAccuracyE911CallInviteLow
- _kCLLocationAccuracyHundredMeters
- _kCLLocationAccuracyKilometer
- _kCLLocationAccuracyLeech
- _kCLLocationAccuracyNearestTenMeters
- _kCLLocationAccuracyPrecisionLimitation
- _kCLLocationAccuracyReduced
- _kCLLocationAccuracyRhythmicNonWaking
- _kCLLocationAccuracyRhythmicWaking
- _kCLLocationAccuracyThreeKilometers
- _kCLLocationCoordinate2DInvalid
- _kCLLocationIntegrityHigh
- _kCLLocationIntegrityLow
- _kCLLocationIntegrityMedium
- _kCLLocationIntegrityNone
- _objc_release_x28
CStrings:
+ "\n supportsFC1ND %s\n supportsNBAMMS %s\n supportsUnii5 %s\n capabilities %u\n"
+ "#ADL #location #routine getRemoteObjectProxy failed with error %@"
+ "#ADL #routine, fetchLocationAtDate, NULL handler"
+ "#ADL #routine, fetchLocationAtMachContinuousTime, NULL handler"
+ "#ADL #routine, fetchLocationsInLastSeconds, NULL handler"
+ "#ADL #routine, fetchRecentLocationsWithOptions, NULL handler"
+ "#EED2FWK,%{public}s, callRelatedToEmergency: %{public}d"
+ "#EED2FWK,%{public}s, constructed CLEEDFeedbackRequest:%{private}@, state:%{public}ld, error:%{public}ld"
+ "#EED2FWK,%{public}s, constructed CLEEDRequestTypeFeedbackCollection:%{private}@, error:%{public}ld"
+ "#EED2FWK,%{public}s,nil cached Feedback Dict or CLEEDHelperError, early return"
+ "#EED2FWK,%{public}s,nil feedbackRequestDict, early return"
+ "#EED2FWK,%{public}s,requestTypeString:%{public}@, requestType:%{public}ld, feedbackVersion:%{public}d,callRelatedToEmergency:%{public}d,callerResponsive:%{public}@,callTrigger:%{public}lu,callReason:%{public}lu,respondersDispatched:%{public}@"
+ "#EED2FWK,%{public}s,requestTypeString:%{public}@, requestType:%{public}ld, feedbackVersion:%{public}d,callRelatedToEmergency:%{public}d,callerResponsive:%{public}@,callTrigger:%{public}lu,callReason:%{public}lu,respondersDispatched:%{public}@]"
+ "#EED2FWK,%{public}s[ID:%{public}@,psapID:%{public}@,partnerID:%{public}@,geofenceID:%{public}@,requestDate:%{public}@,state:%{public}lu,feedbackVersion:%{public}d,callRelatedToEmergency:%{public}d,callerResponsive:%{public}@,callTrigger:%{public}lu,callReason:%{public}lu,respondersDispatched:{public}%@"
+ "#Spi, Error with asynchronous proxy, error: %@"
+ "#Spi, Error with synchronous proxy, error: %@"
+ "#Spi,locctl_tool,fetchRecentLocationAtCfAbsoluteTime,failed with error %@"
+ "#Spi,locctl_tool,fetchRecentLocationAtMachContinuousTime,failed with error %@"
+ "#Spi,locctl_tool,fetchRecentLocationsInLastSeconds,failed with error %@"
+ "#Spi,locctl_tool,getRecentLocationsBufferStatusWithReplyBlock failed with error %@"
+ "#Spi,locctl_tool,got fetchRecentLocationsWithOptions from synchronousRemoteObject,count,%lu"
+ "#Spi,locctl_tool,triggerRecentLocationsRevisedFromMachContinuousTime,could not ping for revised locations notification %@"
+ "#durian #userstats"
+ "#ficConnectionManager cannnot be created without a response-handler"
+ "%.7lf"
+ "%.7lf,%.7lf"
+ "%.7lf,%.7lf,%.2lf"
+ "%@\n <CLEEDFeedbackRequest: feedbackVersion, %d, callRelatedToEmergency, %d, callerResponsive, %@, callTrigger, %lu, callReason, %lu, respondersDispatched, %@>"
+ "%@,%.7lf,%.7lf"
+ "%@,%@,%@,%d,%d"
+ "%@,cfAbsTimestamp, %.3f, machContinuousTimestamp_s, %.3f, sampleInterval_s, %.3f, deltaPosition_m.X, %.3f, deltaPosition_m.Y, %.3f, deltaPosition_m.Z, %.3f, deltaVelocity_mps.X, %.3f, deltaVelocity_mps.Y, %.3f, deltaVelocity_mps.Z, %.3f, quaternion.X, %.3f, quaternion.Y, %.3f, quaternion.Z, %.3f, quaternion.W, %.3f, referenceFrameContinuity, %zu, sessionReferenceFrame, %zu, staticFlag, %zu, mountState, %zu, zupt, %zu, dotBiasChange, %zu"
+ "%@,roadID,%llu,clRoadID,%llu,roadClass,%d,formOfWay,%d,connectingCLRoadID,%llu,connectingStartCoord,%.7lf,%.7lf,connectingEndCoord,%.7lf,%.7lf,familiarityIndex,%.5lf,sequenceNumber,%.5lf,coordinates%@"
+ "%d"
+ "%f (%@)"
+ "-[CLEEDFeedbackRequest getRequestDict]"
+ "-[CLEEDFeedbackRequest initWithDictionary:decryptedRequestData:baseURL:error:]"
+ "-[CLEEDFeedbackRequest initWithDictionary:error:]"
+ "-[CLEEDFeedbackRequest initWithID:psapID:partnerID:geofenceID:requestDate:state:feedbackVersion:callRelatedToEmergency:callerResponsive:callTrigger:callReason:respondersDispatched:]"
+ "-[CLIdentifiableClientConnectionManager initWithSilo:locationManager:startMessageName:startMessagePayload:responseHandler:]"
+ "-[CLLocationInternalClient asynchronousRemoteObject]_block_invoke"
+ "-[CLLocationInternalClient copyRecentLocationsBufferStatus]_block_invoke"
+ "-[CLLocationInternalClient fetchRecentLocationAtCfAbsoluteTime:]_block_invoke"
+ "-[CLLocationInternalClient fetchRecentLocationAtMachContinuousTime:]_block_invoke"
+ "-[CLLocationInternalClient fetchRecentLocationsInLastSeconds:]_block_invoke"
+ "-[CLLocationInternalClient triggerRecentLocationsRevisedFromMachContinuousTime:toMachContinuousTime:]_block_invoke"
+ "-[CLLocationManagerRoutine fetchLocationAtDate:withHandler:]"
+ "-[CLLocationManagerRoutine fetchLocationAtMachContinuousTime:withHandler:]"
+ "-[CLLocationManagerRoutine fetchLocationsInLastSeconds:withHandler:]"
+ "-[CLLocationManagerRoutine fetchRecentLocationsWithOptions:withHandler:]"
+ "-[CLLocationSmoother configureWithWorkoutActivityType:shouldReconstructEntireRoute:timeIntervalsThatNeedPopulating:]"
+ "-[CLMapsXPCServiceManager cancelRoadDataRequest]"
+ "-[CLMapsXPCServiceManager cancelRoadDataRequest]_block_invoke"
+ "-[CLMapsXPCServiceManager constructRouteFromLocation:roadID:clRoadID:projection:toLocation:toRoadID:toCLRoadID:toProjection:maxRouteLength:allowNetwork:isPedestrianOrCycling:clearTiles:iOSTime:familiarityData:withReply:]_block_invoke"
+ "-[CLTripSegmentProcessorManager cancelMapHelperRoadDataRequest]"
+ "-[CLTripSegmentProcessorManager constructRouteWithID:withOptions:usingRoadData:startRoad:endRoad:modeOfTransport:outputHandler:]"
+ "-[CLTripSegmentProcessorManager constructRouteWithID:withOptions:usingRoadData:startRoad:endRoad:modeOfTransport:outputHandler:completionHandler:]_block_invoke"
+ "-[CLTripSegmentProcessorManager generateWaypointsOnTheRoute:forRouteID:withOptions:modeOfTransport:outputHandler:]"
+ "-[CLTripSegmentProcessorManager generateWaypointsOnTheRoute:forRouteID:withOptions:modeOfTransport:outputHandler:completionHandler:]_block_invoke"
+ "-[CLTripSegmentProcessorManager getMatchedLocationCandidates:dataID:modeOfTransport:options:outputHandler:]"
+ "-[CLTripSegmentProcessorManager getMatchedLocationCandidates:dataID:modeOfTransport:options:outputHandler:completionHandler:]_block_invoke"
+ "-[CLTripSegmentProcessorManager getWaypointsSubsetFromSnapPointOnRoute:modeOfTransport:snapLocation:snapRoad:waypoints:routeID:withOptions:outputHandler:]"
+ "-[CLTripSegmentProcessorManager matchLocations:toRoute:waypoints:withOptions:andRouteID:modeOfTransport:outputHandler:]"
+ "-[CLTripSegmentProcessorManager matchLocations:toRoute:waypoints:withOptions:andRouteID:modeOfTransport:outputHandler:completionHandler:]_block_invoke"
+ "-[CLTripSegmentProcessorManager matchLocations:toRoute:withOptions:andRouteID:modeOfTransport:outputHandler:]"
+ "-[CLTripSegmentProcessorManager outputRouteLearningDebuggingDataInCLTSPFile:]"
+ "-[CLTripSegmentProcessorManager propagateLocation:route:distance:withOptions:modeOfTransport:outputHandler:]"
+ "-[CLTripSegmentProcessorManager propagateLocation:route:distance:withOptions:modeOfTransport:outputHandler:completionHandler:]_block_invoke"
+ "-[CLTripSegmentProcessorManager simulateLocationOnRouteID:withOptions:usingRoadData:modeOfTransport:constantSpeed:outputHandler:]"
+ "-[CLTripSegmentProcessorManager simulateLocationOnRouteID:withOptions:usingRoadData:modeOfTransport:constantSpeed:outputHandler:completionHandler:]_block_invoke"
+ "-[_CLLocationManagerRoutineProxy getRemoteObjectProxyWithErrorHandler:]_block_invoke"
+ "/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Daemon/Positioning/GPS/Core/CLStateMachine.h"
+ "/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Framework/CoreLocation/CLIdentifiableClientConnectionManager.mm"
+ "/dev/urandom"
+ "00"
+ "01:20:02"
+ "<Invalid>"
+ "@\"<GEOMapFeatureAccessRequest>\""
+ "@\"CLBIO_Calibration\""
+ "@\"CLIdentifiableClientConnectionManager\""
+ "@\"CLLocationCoordinate\""
+ "@\"GEOMapFeatureAccess\""
+ "@104@0:8{?=ddddddddddii}16"
+ "@108@0:8@16@24@32@40@48q56q64B72@76q84q92@100"
+ "@120@0:8@16d24d32@40@48@56Q64Q72Q80Q88Q96Q104@112"
+ "@132@0:8{CLLocationCoordinate2D=dd}16Q32Q40d48{CLLocationCoordinate2D=dd}56Q72Q80d88d96B104B108B112d116@124"
+ "@24@0:8@?16"
+ "@24@0:8^v16"
+ "@24@0:8f16f20"
+ "@28@0:8@16B24"
+ "@296@0:8Q16Q24Q32Q40Q48Q56Q64Q72Q80Q88Q96Q104Q112Q120Q128Q136Q144Q152Q160Q168Q176Q184Q192Q200Q208Q216Q224q232Q240Q248Q256Q264Q272Q280Q288"
+ "@32@0:8@16B24B28"
+ "@32@0:8B16B20B24I28"
+ "@36@0:8Q16B24@28"
+ "@40@0:8@16@24d32"
+ "@48@0:8@16@24@32B40B44"
+ "@48@0:8@16{basic_string<char, std::char_traits<char>, std::allocator<char>>=(__rep={__short=[23c]b7b1}{__long=*Qb63b1})}24"
+ "@48@0:8q16d24d32d40"
+ "@56@0:8@16@24@32@40@?48"
+ "@56@0:8@16@24@32q40@?48"
+ "@56@0:8@16@24q32@40@?48"
+ "@64@0:8@16@24@32@40q48@?56"
+ "@64@0:8@16@24@32q40d48@?56"
+ "@64@0:8@16@24d32@40q48@?56"
+ "@72@0:8@16@24@32@40@48q56@?64"
+ "@76@0:8@16@24B32q36@44@52@60@68"
+ "@80@0:8@16q24@32@40@48@56@64@?72"
+ "Assertion failed: i < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMVector.h, line 273,invalid index %zu >= %zu."
+ "Assertion failed: i < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMVector.h, line 279,invalid index %zu >= %zu."
+ "Assertion failed: ldx < M*N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMMatrix.h, line 84,invalid element %zu >= %zu."
+ "B32@0:8^d16@24"
+ "B32@0:8^i16@24"
+ "B40@0:8^d16^{__CFString=}24^{__CFString=}32"
+ "B40@0:8^i16^{__CFString=}24^{__CFString=}32"
+ "B56@0:8{shared_ptr<CLMapRoad>=^{CLMapRoad}^{__shared_weak_count}}16B32B36B40B44^v48"
+ "B60@0:8d16d24d32B40B44B48@52"
+ "CL: CLInternalGetLearnedRoutesAccess"
+ "CL: CLInternalGetVisitHistoryAccess"
+ "CL: CLInternalGetVisitHistoryAccessAllowedTime"
+ "CL: CLInternalSetLearnedRoutesAccess"
+ "CL: CLInternalSetVisitHistoryAccess"
+ "CLBIO_Calibration"
+ "CLDurianConnectionInterval"
+ "CLDurianDebugShouldRemoveDeviceFromTADeviceRecord"
+ "CLEEDFeedbackRequest"
+ "CLGeoAccessCommon::LocationNE::LocationNE(CLDistanceCalc *, double, double, double, double)"
+ "CLGeoMapSnapDataPtr CLTripSegmentProcessor::getSnapForThisLocationInTheSpecifiedRoadArray(CFAbsoluteTime, double, double, double, double, double, std::vector<CLMapRoadPtr> &, double)"
+ "CLIdentifiableClientConnectionManager"
+ "CLLocationExtendedTimestamps"
+ "CLLocationExtendedTimestamps.mm"
+ "CLLocationExtendedTimestampsLocation"
+ "CLLocationExtendedTimestampsMachContinuousTime"
+ "CLLocationExtendedTimestampsSystemTime"
+ "CLMM,CLTSP,MapHelperService,XPCService returned constructRouteFromLocation call,roadCount,%{public}d,error,%{public}d,responseTime,%{public}.1lf"
+ "CLMM,CLTSP,MapHelperService,cancelRoadDataRequest,sharedInstance is nil"
+ "CLMM,CLTSP,Roads,queryForRoadsWithinDistance returned error"
+ "CLMM,CLTSP,processing time tracker started,maxAllowed,%{public}.1lf"
+ "CLMM,CLTSP,processing time,%{public}.1lf,exceeded maxAllowed,%{public}.1lf"
+ "CLMapHelperService"
+ "CLMapIntegrationSparse"
+ "CLRS,configureWithWorkoutActivityType,HKWorkoutActivityType,%{public}lu,shouldReconstructEntireRoute,%{public}d,timeIntervalsThatNeedPopulating,%{public}lu"
+ "CLRS,timeIntervalsThatNeedPopulating,index,%{public}zu,start,%{public}.lf,stop,%{public}.1lf,diff,%{public}.1lf"
+ "CLRecentLocationsFetchOptions"
+ "CLTSP,%{private}llu,KPIComputer,findClosestPointOnRoad returned false,isRouteWithSkippedPart,%{public}d"
+ "CLTSP,%{public}.1lf,interpolateOnRoad returned false"
+ "CLTSP,%{public}.2lf,addExtraFreewayCandidateInWiderRadius,added new FWY candidate,rawLL,%{sensitive}.7lf,%{sensitive}.7lf,rawCourse,%{public}.2lf,snapLL,%{sensitive}.7lf,%{sensitive}.7lf,snapCourse,%{public}.2lf"
+ "CLTSP,%{public}.2lf,addExtraFreewayCandidateInWiderRadius,crntSnapVector or lastSnapVector is empty"
+ "CLTSP,%{public}.2lf,addExtraFreewayCandidateInWiderRadius,crntSnapVectorShouldHaveSnapOnFWY,NO"
+ "CLTSP,%{public}.2lf,addExtraFreewayCandidateInWiderRadius,geometry is nil"
+ "CLTSP,%{public}.2lf,addExtraFreewayCandidateInWiderRadius,unable to compute freeway candidates for WiFi position"
+ "CLTSP,%{public}.3lf,aStarConstruct,processing time exceededed local max,%{public}.2lf,exceeded max,%{public}.2lf"
+ "CLTSP,Analytics,tripID,%{public}s,modeOfTransport,%{public}d,bcCount,%{public}d,tripDuration,%{public}d,tripDistance,%{public}d,reconstructedCount,%{public}d,origPct,%{public}.2lf,liPct,%{public}.2lf,iiPct,%{public}.2lf,miPct,%{public}.2lf,miSegments,%{public}d,astarAttemptCount,%{public}d,miRouteRejectedPct,%{public}.2lf,astarFailPct,%{public}.2lf,astarIterationExceededMaxPct,%{public}.2lf,astarRoadCountExceededMaxPct,%{public}.2lf,astarMaxIterations,%{public}.2lf,astarAvgIterations,%{public}.2lf,astarProcessingTime,%{public}.2lf,mapQueryCount,%{public}d,mapFailPct,%{public}.2lf,maxTimeBetweenEpochs,%{public}.2lf,avgTimeBetweenEpochs,%{public}.2lf,invalidSpeedPct,%{public}.2lf,invalidCoursePct,%{public}.2lf,tripChunksCount,%{public}d,percentageOfRailwaySnap,%{public}.2lf,processingTime,%{public}.2lf"
+ "CLTSP,CLAStarRouteConstructor,processingTime exceeded max allowed,construct"
+ "CLTSP,CLAStarRouteConstructor,processingTime exceeded max allowed,constructPedestrian"
+ "CLTSP,CLAStarRouteConstructor,processingTime exceeded max allowed,constructRouteCandidates"
+ "CLTSP,CLGEOMapHelperService,fetchGEOBuildingDataAroundCoordinate,tileStyle,%1d,repliedWithCount,%d,elapsedTime,%.2lf"
+ "CLTSP,CLMM,GEOMapFeatureAccessRequest,tileStyle,%1d,reported errorcode,%lld,domain,%@,description,\"%@\""
+ "CLTSP,CLMM,MapHelperService CleanExit"
+ "CLTSP,CLMM,MapHelperService,GEOMapFeatureAccessRequest reported errorcode,%lld,domain,%@,description,\"%@\""
+ "CLTSP,CLMM,MaphelperService,Releasing OS Transaction"
+ "CLTSP,CLMM,MaphelperService,Taking OS Transaction"
+ "CLTSP,CLMM,MaphelperService,application missing building data entitlement"
+ "CLTSP,CLMM,MaphelperService,application missing road data entitlement"
+ "CLTSP,CLMM,MaphelperService,cancelRoadDataRequest"
+ "CLTSP,CLMM,MaphelperService,cancelRoadDataRequest processed"
+ "CLTSP,CLMM,MaphelperService,cancelRoadDataRequest,query not in progress"
+ "CLTSP,CLMM,MaphelperService,function call does not support constructing route for pedestrian/cycling use case"
+ "CLTSP,CLMM,MaphelperService,getCLMapRoadDataFromTripSegmentRoad,failed to find clMapRoad"
+ "CLTSP,CLMM,MaphelperService,getGEOMapFeatureRoadDataAroundCoordinate failed"
+ "CLTSP,CLMM,MaphelperService,invalid coordinates for building data query"
+ "CLTSP,CLMM,MaphelperService,invalid coordinates for road data query"
+ "CLTSP,CLMM,MaphelperService,invalid null-island coordinates for road data query"
+ "CLTSP,CLMM,MaphelperService,invalid radius or over the max allowed radius for building data query"
+ "CLTSP,CLMM,MaphelperService,invalid radius or over the max allowed radius for road data query"
+ "CLTSP,CLTripSegmentMapIntegratorSparse,processingTime exceeded max allowed,after generateSnapCandidates"
+ "CLTSP,CLTripSegmentMapIntegratorSparse,processingTime exceeded max allowed,after makeSegmentsForRouteConstruction"
+ "CLTSP,CLTripSegmentMapIntegratorSparse,processingTime exceeded max allowed,constructSegment loop,iteration,%{public}d"
+ "CLTSP,CLTripSegmentProcessor,processingTime exceeded max allowed,after LI"
+ "CLTSP,CLTripSegmentProcessor,processingTime exceeded max allowed,after PTS"
+ "CLTSP,CLTripSegmentProcessor,processingTime exceeded max allowed,after runInertialIntegrator"
+ "CLTSP,CLTripSegmentProcessor,processingTime exceeded max allowed,after runLinearInterpolator"
+ "CLTSP,CLTripSegmentProcessor,processingTime exceeded max allowed,after runMapIntegrator"
+ "CLTSP,CLTripSegmentUtilities::convertInertialOdometryDataToInertialData failed"
+ "CLTSP,KPIComputer,fMisMatchedLength,%{public}.3lf,misMatchLength,%{public}.2lf,isRouteWithSkippedPart,%{public}d"
+ "CLTSP,MI,%{public}.3lf,constructing astar route between,startPoint,%{sensitive}.7lf,%{sensitive}.7lf,endPoint,%{sensitive}.7lf,%{sensitive}.7lf,distance,%{public}.3lf,endTime,%{public}.3lf,maxDistance,%{public}.3lf,speed,%{public}.3lf,maxSpeedBasedDistance,%{public}.1lf,maxLOSBasedDistance,%{public}.1lf"
+ "CLTSP,MI,%{public}.3lf,try alternate astar route between,startPoint,%{sensitive}.7lf,%{sensitive}.7lf,endPoint,%{sensitive}.7lf,%{sensitive}.7lf,distance,%{public}.3lf,endTime,%{public}.3lf,maxDistance,%{public}.3lf,maxSpeedBasedDistance,%{public}.1lf,maxLOSBasedDistance,%{public}.1lf,tryCount,%{public}d"
+ "CLTSP,Received Simulated Sparse trip output Data,ID,%{public}s,distance,%{public}.2lf,distanceUnc,%{public}.2lf,startTime,%{public}.2lf,endTime, %{public}.2lf,modeOfTransport,%{public}d,locationCount,%{public}d,routeRoads,%{public}d,routeLengthMatch,%{public}d,routeDeviationCount,%{public}d,routeDeviationPerKm,%{public}.2lf,routeDeviationPerHr,%{public}.2lf"
+ "CLTSP,Recorder,recording data for date,%{public}s,time,%{public}s to filename,%{public}@"
+ "CLTSP,Recorder,unable to write data as device doesn't have enough disk space,%lu"
+ "CLTSP,Recorder,writeToFile,success,type,%{public}d,length,%{public}d,freeDiskSpace,%{public}lu"
+ "CLTSP,RouteBuilder,generateAndCombineRoute for loop,processingTime exceeded max allowed"
+ "CLTSP,RouteBuilder,generateSnapCandidates,processingTime exceeded max allowed"
+ "CLTSP,UseInertialOdometryInTSP,%{public}d"
+ "CLTSP,aStarConstructPedestrian,findRoadsConnectedToEndOfThisRoad failed"
+ "CLTSP,aStarConstructPedestrian,findRoadsConnectedToStartOfThisRoad failed"
+ "CLTSP,constructRouteUsingFamiliarRoads,AStar Route Reconstruction failed,tripID,%{public}s"
+ "CLTSP,constructRouteUsingFamiliarRoads,Empty AStar route"
+ "CLTSP,constructRouteUsingFamiliarRoads,end location is invalid"
+ "CLTSP,constructRouteUsingFamiliarRoads,end snap determination failed,tripID,%{public}s"
+ "CLTSP,constructRouteUsingFamiliarRoads,familiar road data is empty,tripID,%{public}s"
+ "CLTSP,constructRouteUsingFamiliarRoads,generated route do not have sufficient familiar roads"
+ "CLTSP,constructRouteUsingFamiliarRoads,output,routeID,%{public}s,modeOfTransport,%{public}d,routeRoadsCount,%{public}d,processingTimeMSec,%{public}.1lf"
+ "CLTSP,constructRouteUsingFamiliarRoads,start location is invalid"
+ "CLTSP,constructRouteUsingFamiliarRoads,start snap determination failed,tripID,%{public}s"
+ "CLTSP,constructRouteUsingFamiliarRoads,unable to generate waypoints"
+ "CLTSP,constructRouteUsingFamiliarRoads,unexpected - clmaproad not found after maps API search,tripID,%{public}s"
+ "CLTSP,constructRouteUsingFamiliarRoads,unexpected - clmaproad not found, searching from maps API,tripID,%{public}s"
+ "CLTSP,constructRouteUsingFamiliarRoads,waypoints or constructed route is empty,routeCount,%{public}d,wpCount,%{public}d"
+ "CLTSP,constructRouteUsingRoadData"
+ "CLTSP,constructRouteUsingRoadData called with roads,%{public}d,tripID,%{public}s"
+ "CLTSP,constructRouteUsingRoadData failed,tripID,%{public}s"
+ "CLTSP,constructRouteUsingRoadData for tripID,%{public}s,returned error,%{public}lld,domain,%{public}@,description,\"%{private}@\""
+ "CLTSP,convert1HzDataToSparseAndComputeRouteMatchKPI,1,duration,%{public}d,numberOfGPSLocations,%{public}d,gpsPercentage,%{public}.2lf"
+ "CLTSP,convert1HzDataToSparseAndComputeRouteMatchKPI,zero crumbs simulated"
+ "CLTSP,convertInertialOdometryDataToInertialData,empty inertialOdometryDataArray"
+ "CLTSP,convertInertialOdometryDataToInertialData,empty tripLocations"
+ "CLTSP,convertInertialOdometryDataToInertialData,null inertialDataArray"
+ "CLTSP,convertInertialOdometryDataToInertialData,null inertialOdometryDataArray"
+ "CLTSP,convertInertialOdometryDataToInertialData,null tripLocations"
+ "CLTSP,crumbStatistics,tripID,%{public}s,totalCrumbs,%{public}d,avgCrumbDistance,%{public}.2lf,avgCrumbTimeDiff,%{public}.2lf,maxCrumbDistance,%{public}.2lf,maxCrumbTimeDiff,%{public}.2lf,gpsCount,%{public}d,gpsPercentage,%{public}.2lf,avgGPSCrumbDistance,%{public}.2lf,avgGPSCrumbTimeDiff,%{public}.2lf,maxGPSCrumbDistance,%{public}.2lf,maxGPSCrumbTimeDiff,%{public}.2lf,numGPSSessions,%{public}d,maxFixCountInAGPSSession,%{public}.1lf,avgFixCountInAGPSSession,%{public}.1lf,minFixCountInAGPSSession,%{public}.1lf,avgDistanceBetweenGPSSessions,%{public}.2lf,avgTimeDiffBetweenGPSSessions,%{public}.2lf,maxDistanceBetweenGPSSessions,%{public}.2lf,maxTimeDiffBetweenGPSSessions,%{public}.2lf,wifiCount,%{public}d,wifiPercentage,%{public}.2lf,avgWiFiCrumbDistance,%{public}.2lf,avgWiFiCrumbTimeDiff,%{public}.2lf,maxWiFiCrumbDistance,%{public}.2lf,maxWiFiCrumbTimeDiff,%{public}.2lf"
+ "CLTSP,duplicate location at time,%{public}.1lf,snap already exists!"
+ "CLTSP,duplicate location coordinate at time,%{public}.1lf, and at time,%{public}.1lf"
+ "CLTSP,fillCLRoadIDOfConnectingRoad,null geometry"
+ "CLTSP,fillCLRoadIDOfConnectingRoad,road pointer is null"
+ "CLTSP,filterWiFiFixes,boundingBoxCheck removed,time,%{public}.2lf,LL,%{sensitive}.7lf,%{sensitive}.7lf,hunc,%{public}.3lf,speed,%{public}.3lf,course,%{public}.3lf,distThreshold,%{public}.1lf"
+ "CLTSP,findClosestPointOnRoad returned false"
+ "CLTSP,generateWayPointsOnTheRoute,empty road vector,trip,%{public}s"
+ "CLTSP,generateWayPointsOnTheRoute,findRoadsConnectedToEndOfThisRoad call failed for road,%{private}lld,trip,%{public}s"
+ "CLTSP,generateWayPointsOnTheRoute,interpolateProjections failed,trip,%{public}s,projection,%{public}.2lf"
+ "CLTSP,generateWayPointsOnTheRoute,null geometry,trip,%{public}s"
+ "CLTSP,generateWayPointsOnTheRoute,null pathlet,trip,%{public}s"
+ "CLTSP,generateWayPointsOnTheRoute,null road,trip,%{public}s"
+ "CLTSP,generateWayPointsOnTheRoute,waypoint skipped due to too close distance,%{public}.2lf,trip,%{public}s,LL,%{sensitive}.7lf,%{sensitive}.7lf,courseDiff,%{sensitive}.2lf"
+ "CLTSP,generateWaypointsOnTheRoute called with roads,%{public}d,tripID,%{public}s"
+ "CLTSP,generateWaypointsOnTheRoute failed to snap"
+ "CLTSP,generateWaypointsOnTheRoute failed,routeID,%{public}s"
+ "CLTSP,generateWaypointsOnTheRoute,output,identifier,%{public}s,modeOfTransport,%{public}d,predictedLocations,%{public}d,processingTimeMSec,%{public}.1lf"
+ "CLTSP,generateWaypointsOnTheRoute,returned error,%{public}lld,domain,%{public}@,description,\"%{private}@\""
+ "CLTSP,generateWaypointsOnTheRoute,route road data is nil or empty,tripID,%{public}s"
+ "CLTSP,generateWaypointsOnTheRoute,unable to generate waypoints"
+ "CLTSP,generateWaypointsOnTheRoute,unsupported mode of transport,tripID,%{public}s"
+ "CLTSP,getCLTripSegmentRoadDataArrayAsCLMapRoadVector,findRoadsNear call failed,roadID,%{public}lld"
+ "CLTSP,getCLTripSegmentRoadDataArrayAsCLMapRoadVector,null geometry"
+ "CLTSP,getCLTripSegmentRoadDataArrayAsCLMapRoadVector,road data query failed,roadID,%{public}lld"
+ "CLTSP,getCLTripSegmentRoadDataArrayAsConsolidatedCLMapRoad,road data conversion failed"
+ "CLTSP,getMatchedLocationCandidates called with locations,%{public}d,dataID,%{public}s"
+ "CLTSP,getMatchedLocationCandidates failed to snap"
+ "CLTSP,getMatchedLocationCandidates failed,dataID,%{public}s"
+ "CLTSP,getMatchedLocationCandidates,input modeOfTransport not supported,tripID,%{public}s"
+ "CLTSP,getMatchedLocationCandidates,location count received is 0"
+ "CLTSP,getMatchedLocationCandidates,locations are nil"
+ "CLTSP,getMatchedLocationCandidates,returned error,%{public}lld,domain,%{public}@,description,\"%{private}@\""
+ "CLTSP,getMatchedLocationCandidates,snap failed"
+ "CLTSP,getPercentageOfFamiliarRoadsInRoute,Empty AStar route"
+ "CLTSP,getPercentageOfFamiliarRoadsInRoute,familiarRoadData is null"
+ "CLTSP,getWaypointsSubsetFromSnapPoint,output,routeID,%{public}s,modeOfTransport,%{public}d,routeRoadsCount,%{public}d,wpCounts,%{public}d,processingTimeMSec,%{public}.1lf"
+ "CLTSP,getWaypointsSubsetFromSnapPoint,routeRoads is invalid"
+ "CLTSP,getWaypointsSubsetFromSnapPoint,snap information is nil"
+ "CLTSP,getWaypointsSubsetFromSnapPointOnRoute failed to snap"
+ "CLTSP,input modeOfTransport not supported"
+ "CLTSP,invalid speed input,trip,%{public}s,speed,%{public}.2lf"
+ "CLTSP,location count received is 0"
+ "CLTSP,location data is nil or empty"
+ "CLTSP,location data is nil or empty,tripID,%{public}s"
+ "CLTSP,locations are nil"
+ "CLTSP,matchLocations for routeID,%{public}s,returned error,%{public}lld,domain,%{public}@,description,\"%{private}@\""
+ "CLTSP,matchLocationsCandidates,output,dataID,%{public}s,modeOfTransport,%{public}d,tripLocations,%{public}d,routeRoadsCount,%{public}d,processingTimeMSec,%{public}.1lf"
+ "CLTSP,matchLocationsToRoute called with roads,%{public}d,tripID,%{public}s"
+ "CLTSP,matchLocationsToRoute failed to snap"
+ "CLTSP,matchLocationsToRoute failed,routeID,%{public}s"
+ "CLTSP,matchLocationsToRoute,matched on a road not in route"
+ "CLTSP,matchLocationsToRoute,no roads found within search radius"
+ "CLTSP,matchLocationsToRoute,output,routeID,%{public}s,modeOfTransport,%{public}d,routeRoadsCount,%{public}d,processingTimeMSec,%{public}.1lf"
+ "CLTSP,matchLocationsToRoute,routeRoads is invalid"
+ "CLTSP,matchLocationsToRoute,snap with course failed"
+ "CLTSP,matchLocationsToRoute,tripLocations is invalid"
+ "CLTSP,max distance between crumbs check failed,distance,%{public}.2lf,maxCrumbSeparation,%{public}d"
+ "CLTSP,nil tripLocations"
+ "CLTSP,not validating crumbs for simulated data"
+ "CLTSP,processData,output,tripSegmentID,%{public}s,modeOfTransport,%{public}d,isFinalPart,%{public}d,sparseLocationsCount,%{public}d,reconstructedLocCount,%{public}d,routeRoadsCount,%{public}d,totalDistance,%{public}.2lf,processingTimeMSec,%{public}.1lf,simulated,%{public}d,date,%{public}s,time,%{public}s"
+ "CLTSP,propagateLocation called with locations,%{public}d,tripID,%{public}s"
+ "CLTSP,propagateLocation failed to snap"
+ "CLTSP,propagateLocation failed,routeID,%{public}s"
+ "CLTSP,propagateLocation,both locations and route are empty, one must be provided"
+ "CLTSP,propagateLocation,both locations and route are empty, one must be provided,%{public}.2lf"
+ "CLTSP,propagateLocation,both locations and route are nil, one must be provided"
+ "CLTSP,propagateLocation,both locations and route are nil, one must be provided,%{public}.2lf"
+ "CLTSP,propagateLocation,distance invalid"
+ "CLTSP,propagateLocation,distance invalid,%{public}.2lf"
+ "CLTSP,propagateLocation,distance,%{public}.2lf,returned error,%{public}lld,domain,%{public}@,description,\"%{private}@\""
+ "CLTSP,propagateLocation,input modeOfTransport not supported,tripID,%{public}s"
+ "CLTSP,propagateLocationForward,output,tripID,%{public}s,iOSTime,%{public}.1lf,modeOfTransport,%{public}d,predictedLocations,%{sensitive}.7lf,%{sensitive}.7lf,distance,%{public}.3lf,percentageTravelled,%{public}.7lf,processingTimeMSec,%{public}.1lf"
+ "CLTSP,propagateLocationForward,tripID,%{public}s,added snapLL,%{sensitive}.7lf,%{sensitive}.7lf,course,%{public}.2lf,roadID,%{sensitive}llu,for rawLL,%{sensitive}.7lf,%{sensitive}.7lf,rawCourse,%{public}.2lf"
+ "CLTSP,propagateLocationForward,tripID,%{public}s,invalid distance,%{public}.2lf"
+ "CLTSP,propagateLocationForward,tripID,%{public}s,invalid inputs, prediction failed"
+ "CLTSP,propagateLocationForward,tripID,%{public}s,less distance travelled than min required prediction ,predictedLocation,%{sensitive}.7lf,%{sensitive}.7lf,distanceTravelled,%{public}.2lf"
+ "CLTSP,propagateLocationForward,tripID,%{public}s,mapmatcher returned error, prediction failed"
+ "CLTSP,propagateLocationForward,tripID,%{public}s,unable to convert TSR to current road, prediction failed"
+ "CLTSP,propagateLocationForward,tripID,%{public}s,unable to find current road, prediction failed"
+ "CLTSP,propagateLocationForward,tripID,%{public}s,unable to find intersections for the road, break out early"
+ "CLTSP,propagateLocationForward,tripID,%{public}s,unable to find next road, break out early"
+ "CLTSP,propagateLocationForward,tripID,%{public}s,unable to find next road, null island, prediction failed"
+ "CLTSP,route appended at end using stopSnaps,numRoads,%{public}d"
+ "CLTSP,route appended at start using startSnaps,numRoads,%{public}d"
+ "CLTSP,route road data is nil or empty"
+ "CLTSP,route road data is nil or empty,tripID,%{public}s"
+ "CLTSP,simulateLocationOnRoute for tripID,%{public}s,returned error,%{public}lld,domain,%{public}@,description,\"%{private}@\""
+ "CLTSP,simulateLocationOnRoute,getCLTripSegmentRoadDataArrayAsConsolidatedCLMapRoad failed,tripID,%{public}s"
+ "CLTSP,simulateLocationOnRoute,input,routeID,%{public}s,modeOfTransport,%{public}d,,routeRoadsCount,%{public}d,speed,%{public}.1lf"
+ "CLTSP,simulateLocationOnRoute,interpolateProjections failed,trip,%{public}s,projection,%{public}.2lf"
+ "CLTSP,simulateLocationOnRoute,modified simulation speed,trip,%{public}s,prevSpeed,%{public}.2lf,newSpeed,%{public}.2lf"
+ "CLTSP,simulateLocationOnRoute,output,routeID,%{public}s,modeOfTransport,%{public}d,routeRoadsCount,%{public}d,reconstructedLocCount,%{public}d,totalDistance,%{public}.2lf,processingTimeMSec,%{public}.1lf"
+ "CLTSP,simulateLocationOnRoute,road coordinates are not available,%{public}s"
+ "CLTSP,simulateLocationOnRouteID"
+ "CLTSP,simulateLocationOnRouteID called with roads,%{public}d,tripID,%{public}s"
+ "CLTSP,simulateLocationOnRouteID failed,tripID,%{public}s"
+ "CLTSP,snap data is nil"
+ "CLTSP,trip segment processing failed,%{public}d"
+ "CLTSP,tripData add failed, static data pointer is null,tripID,%{public}s,count,%{public}lu"
+ "CLTSP,tripData element added,tripID,%{public}s,count,%{public}lu"
+ "CLTSP,tripData element erased due to timeout,tripID,%{public}s,count,%{public}lu"
+ "CLTSP,tripData element updated pointer,tripID,%{public}s,count,%{public}lu"
+ "CLTSP,tripData stats submitted and element erased,tripID,%{public}s,count,%{public}lu"
+ "CLTSP,tripID not present in CLTripSegmentSharedData array while accessing getAnalyticsInstance,%{public}s,arraySize,%{public}d"
+ "CLTSP,tripID not present in CLTripSegmentSharedData array while accessing getRoadSequenceNumber,%{public}s,arraySize,%{public}d"
+ "CLTSP,tripID not present in CLTripSegmentSharedData array while accessing getRouteMatchKPIComputer,%{public}s,arraySize,%{public}d"
+ "CLTSP,tripLocations count zero"
+ "CLTSP,triplocations validation failed"
+ "CLTSP,tspManager,cancelRoadDataRequest"
+ "CLTSP,tspManager,outputTripMatchingDebuggingDataInCLTSPFile - invalid data"
+ "CLTSP,unsupported mode of transport,tripID,%{public}s"
+ "CLTSP,wifi location availability check failed,wiFiCount,%{public}d,gpsPercentage,%{public}.1lf"
+ "CLTripSegmentAnalytics &CLTripSegmentSharedData::getAnalyticsInstance(const std::string &)"
+ "CLTripSegmentRouteMatchKPI &CLTripSegmentSharedData::getRouteMatchKPIComputer(const std::string &)"
+ "CLVisitCondition"
+ "CLVisitCondition(poiCategory:%d, lat:(private), lon:(private), radius:%f)"
+ "Can't load data from file"
+ "ConstructRouteUsingFamiliarRoads"
+ "Critical"
+ "Date: %@, allowDelayedResponse, %d"
+ "EEDRequestMetricSubmitted"
+ "FProgramNumber"
+ "High"
+ "Invalid fileURL"
+ "LocalBluePOI"
+ "LocationNE, DistanceCalc is NULL"
+ "Low"
+ "MachContinuousTimeSec: %.3f, allowDelayedResponse, %d"
+ "MaxCrumbSeparationInMetersForTripReconstruction"
+ "May 30 2025"
+ "Medium"
+ "NumberOfSeconds: %u, allowDelayedResponse, %d, returnSparseLocations, %d"
+ "PropagateLocations"
+ "SimulateLocationOnRoute"
+ "StoreDemoMode"
+ "SystemAccepted"
+ "T &CMVector<double, 2>::operator[](const size_t) [T = double, N = 2]"
+ "T CMMatrix<double, 2>::operator[](size_t) const [T = double, M = 2, N = 2]"
+ "T CMVector<double, 2>::operator[](const size_t) const [T = double, N = 2]"
+ "T@\"CLBIO_Calibration\",R,N,V_calibration"
+ "T@\"CLIdentifiableClientConnectionManager\",&,N,V_connectionManager"
+ "T@\"CLLocation\",C,N,V_location"
+ "T@\"CLLocationCoordinate\",R,N,V_connectingRoadEndCoordinate"
+ "T@\"CLLocationCoordinate\",R,N,V_connectingRoadStartCoordinate"
+ "T@\"NSDate\",C,N,V_systemTimeNotUserTime"
+ "T@\"NSDate\",R,C,N,V_date"
+ "T@\"NSNumber\",N,V_callerResponsive"
+ "T@\"NSNumber\",N,V_respondersDispatched"
+ "T@\"NSNumber\",R,C,N,V_machContinuousTimeSeconds"
+ "T@\"NSNumber\",R,C,N,V_numberOfSeconds"
+ "T@\"NSString\",R,V_onBehalfOfBundleIdentifer"
+ "T@\"NSUUID\",R,V_commuteID"
+ "TB,N,V_callRelatedToEmergency"
+ "TB,N,V_metricSubmitted"
+ "TB,R,N,V_allowDelayedResponse"
+ "TB,R,N,V_enableUseWifiInPTS"
+ "TB,R,N,V_isWatch"
+ "TB,R,N,V_returnSparseLocations"
+ "TB,R,N,V_runLocationOutlierRejector"
+ "TB,R,N,V_useNonGNSSFixesForRouteReconstruction"
+ "TB,R,V_supportsUnii5"
+ "TB,V_isValid"
+ "TB,V_started"
+ "TLV"
+ "TQ,N,V_locationDataMask"
+ "TQ,R,N,V_dotBiasChange"
+ "TQ,R,N,V_mountState"
+ "TQ,R,N,V_stepSizeForLocationOutlierRejector"
+ "TQ,R,N,V_windowSizeForLocationOutlierRejector"
+ "TQ,R,N,V_zupt"
+ "TQ,R,V_abandonedFwUpdateCount"
+ "TQ,R,V_abandonedFwUpdateTime"
+ "TQ,R,V_bomSoundCount"
+ "TQ,R,V_crashCount"
+ "TQ,R,V_dualConnectionTime"
+ "TQ,R,V_dualLeashTime"
+ "TQ,R,V_fc1ndRangingCount"
+ "TQ,R,V_fc1ndRangingTime"
+ "TQ,R,V_lastClear"
+ "TQ,R,V_lastPIn"
+ "TQ,R,V_multiConnectionTime"
+ "TQ,R,V_multiLeashTime"
+ "TQ,R,V_multiTime"
+ "TQ,R,V_nbmmsRangingTime"
+ "TQ,R,V_nearOwnerTime"
+ "TQ,R,V_nearOwnerTimeV2"
+ "TQ,R,V_overflowFlag"
+ "TQ,R,V_ownerLongSoundCount"
+ "TQ,R,V_ownerShortSoundCount"
+ "TQ,R,V_pairingAttemptsCount"
+ "TQ,R,V_proxPairingTime"
+ "TQ,R,V_rangingCount"
+ "TQ,R,V_rangingTime"
+ "TQ,R,V_roseInitCount"
+ "TQ,R,V_roseOnTime"
+ "TQ,R,V_singleConnectionTime"
+ "TQ,R,V_singleLeashTime"
+ "TQ,R,V_soundCount"
+ "TQ,R,V_soundTime"
+ "TQ,R,V_utAccelCount"
+ "TQ,R,V_utLongSoundCount"
+ "TQ,R,V_utShortSoundCount"
+ "TQ,R,V_wildTime"
+ "Td,N,V_machContinuousTimeSec"
+ "Td,R,N,V_maxProcessingTimeInMilliSec"
+ "Td,R,N,V_radius"
+ "Td,R,N,V_sequenceNumber"
+ "Td,R,N,V_useXPCServiceForVehicularAStarSearch"
+ "Tf,R,N,V_rotationToTrueNorth_rad"
+ "Tf,R,N,V_scaleFactor"
+ "Tq,N,V_callReason"
+ "Tq,N,V_callTrigger"
+ "Tq,N,V_feedbackVersion"
+ "Tq,R,N,V_poiCategory"
+ "Tq,R,V_batteryState"
+ "Unii-5"
+ "Unset"
+ "Unspecified"
+ "UseInertialOdometryInTSP"
+ "UseXPCServiceForVehicularAStarSearch"
+ "[CLLocationOutlierRejector]:[computDistanceBetweenTwoIOSamples] computation failed.startIdx,%zu,endIdx,%zu,ioCount,%zu"
+ "[CLLocationOutlierRejector]:[constructIOTrajecotry] high invalid IO sample ratio, %{public}.2f."
+ "[CLLocationOutlierRejector]:[constructIOTrajecotry] not enough displacement in IO horizon, %{public}.2f."
+ "[CLLocationOutlierRejector]:[constructIOTrajectory] IO time is not monotonically increasing,prevIOTime,%{public}.1f,currentIOTime,%{public}.1f"
+ "[CLLocationOutlierRejector]:[constructLocationTrajectory] Failed to convert from lat/lon to NWU failed. location sample,latitude,%{sensitive}.7f, longitude,%{sensitive}.7f,selected origin,latitude,%{sensitive}.7f,longitude,%{sensitive}.7f."
+ "[CLLocationOutlierRejector]:[constructLocationTrajectory] not enough displacement along the location horizon, %{public}.2f."
+ "[CLLocationOutlierRejector]:[isTrajectoryStraightBeforeAndAfterFlag] start idx equal or greater than end idx.startIdx,%zu,endIdx,%zu,ioCount,%zu"
+ "[CLLocationOutlierRejector]:[runRejector] No overlap time period between location and IO samples."
+ "[CLLocationOutlierRejector]:[runRejector] count of set of inliers is too few, %{public}zu."
+ "[CLLocationOutlierRejector]:[runRejector] first location index,%{public}zu, higher than location size,%{public}zu."
+ "[CLLocationOutlierRejector]:[runRejector] selected inliers are too sparse in space."
+ "[CLLocationOutlierRejector]:[selectInliers] contruct IO trajectory failed."
+ "[CLLocationOutlierRejector]:[selectInliers] contruct location trajectory failed."
+ "[CLLocationOutlierRejector]:[selectInliers] inliers are selected for batch count, %{public}zu, with residual threshold, %{public}.1f and inlier ratio, %{public}.2f"
+ "[CLLocationOutlierRejector]:[selectInliers] no inlier is selected for batch count, %{public}zu"
+ "[CLLocationOutlierRejector]:[selectInliers] robust umeyama failed, residual threshold, %{public}.1f ."
+ "[CLLocationOutlierRejector]:[selectInliers] vector sizes are not equal: io,%{public}zu,location,%{public}zu,timestamp,%{public}zu"
+ "[CLLocationOutlierRejector]:[setHeadAndTailIndicesForLocationArray] head index can not be larger than or equal to tail index."
+ "[CLLocationOutlierRejector]:[setHeadAndTailIndicesForLocationArray] no overlap, last IO is earlier than first location."
+ "[CLLocationOutlierRejector]:[setHeadAndTailIndicesForLocationArray] no overlap, last location is earlier than first IO."
+ "[CLLocationOutlierRejector]:[setHeadAndTailIndicesForLocationArray] there is no location sample earlier than last IO sample."
+ "[CLLocationOutlierRejector]:[setHeadAndTailIndicesForLocationArray] there is no location sample later than first IO sample."
+ "[CLPedestrianRTSSmoother]:[openLoopPropagationTail] course offset is not initialized."
+ "[CLPedestrianRTSSmoother]:[runRTS] Returned false. Last consumed measurement is not initialized in forward propagation loop."
+ "[CLPedestrianRTSSmoother]:[runRTS] Returned false. Last consumed measurement is still not initialized even after propagation loop."
+ "[CLPedestrianRTSSmoother]:[runRTS] There is no inertialOdometry sample between consecutive location samples. timestamp of coming location sample %{public}.3f, timestamp of consumed location sample %{public}.3f.areThereEnoughValidIOSamples,%d,isIODistanceLongEnough,%d."
+ "[CLTrajectorySmootherUtilities] Conversion from lat/lon to NWU failed. location sample,latitude,%{sensitive}.7f,longitude,%{sensitive}.7f,selected origin,latitude,%{sensitive}.7f,longitude,%{sensitive}.7f."
+ "[CLTrajectorySmootherUtilities], distance between two consecutive samples is, %{public}.1f."
+ "[CLTrajectorySmoother]:[runPedestrianTrajectorySmoothing] ratioOfDenseUrbanLocation, %{private}.2f, durationOfSession_inSec, %{public}.2f, shouldRunRANSAC, %{public}d, wasLocationOutlierRejectorEnabled, %{public}d, enableUseWifiInPTS, %{public}d."
+ "[RobustUmeyama]: initialization failed."
+ "[RobustUmeyama]: iteration failed."
+ "[RobustUmeyama]:number of iterations, %{public}zu, maximum allowed, %{public}zu."
+ "[Umeyama]: number of observations is 0."
+ "[Umeyama]: number of observations, %{public}zu < dimension %{public}zu."
+ "[Umeyama]: reference size, %{public}zu !=  toBeAligned size %{public}zu."
+ "[Umeyama]:determinant of U is not correct, %{public}.2f"
+ "[Umeyama]:determinant of U is not orthogonal"
+ "[Umeyama]:determinant of V is not correct, %{public}.2f"
+ "[Umeyama]:determinant of V is not orthogonal"
+ "[Umeyama]:determinant of rotation matrix is not correct, %{public}.2f"
+ "[Umeyama]:negative singular value, %{public}.2f"
+ "[Umeyama]:non-positive weight, %{public}.2f"
+ "[Umeyama]:problem is infeasible"
+ "[Umeyama]:repeated singular value"
+ "[Umeyama]:rotation matrix is not orthogonal"
+ "[Umeyama]:sum of singular values is, %{public}.2f"
+ "[Umeyama]:sum of weights are not positive, %{public}.2f"
+ "[coder allowsKeyedCoding]"
+ "_CLMapHelperService, %p"
+ "_abandonedFwUpdateCount"
+ "_abandonedFwUpdateTime"
+ "_allowDelayedResponse"
+ "_batteryState"
+ "_calibration"
+ "_callReason"
+ "_callRelatedToEmergency"
+ "_callTrigger"
+ "_callerResponsive"
+ "_checkAndExerciseForPushClientWithBundleID:completionHandler:"
+ "_checkAndExerciseLearnedRoutesAuthorizationForBundleID:orBundlePath:completionHandler:"
+ "_commuteID"
+ "_connectingRoadEndCoordinate"
+ "_connectingRoadStartCoordinate"
+ "_connectionManager"
+ "_dotBiasChange"
+ "_dualConnectionTime"
+ "_dualLeashTime"
+ "_enableUseWifiInPTS"
+ "_fc1ndRangingCount"
+ "_fc1ndRangingTime"
+ "_feedbackVersion"
+ "_initWithPoiCategory:latitude:longitude:radius:"
+ "_isValid"
+ "_isWatch"
+ "_lastHistoricalLocationTimestamp"
+ "_lastPIn"
+ "_locationDataMask"
+ "_machContinuousTimeSec"
+ "_machContinuousTimeSeconds"
+ "_maxProcessingTimeInMilliSec"
+ "_metricSubmitted"
+ "_mountState"
+ "_multiConnectionTime"
+ "_multiLeashTime"
+ "_nbmmsRangingTime"
+ "_numberOfSeconds"
+ "_onBehalfOfBundleIdentifer"
+ "_pairingAttemptsCount"
+ "_pauseLocationUpdater"
+ "_proxPairingTime"
+ "_respondersDispatched"
+ "_responseHandler"
+ "_responseHandler != nullptr"
+ "_resumeLocationUpdater"
+ "_returnSparseLocations"
+ "_roseInitCount"
+ "_roseOnTime"
+ "_rotationToTrueNorth_rad"
+ "_runLocationOutlierRejector"
+ "_scaleFactor"
+ "_sequenceNumber"
+ "_singleConnectionTime"
+ "_singleLeashTime"
+ "_start"
+ "_startMessageName"
+ "_startMessagePayload"
+ "_started"
+ "_stepSizeForLocationOutlierRejector"
+ "_supportsUnii5"
+ "_systemTimeNotUserTime"
+ "_useNonGNSSFixesForRouteReconstruction"
+ "_useXPCServiceForVehicularAStarSearch"
+ "_windowSizeForLocationOutlierRejector"
+ "_zupt"
+ "abandonedFwUpdateCount"
+ "abandonedFwUpdateTime"
+ "addIndexesInRange:"
+ "allowDelayedResponse"
+ "astarIterationExceededMax"
+ "asynchronousRemoteObject"
+ "attemptCount"
+ "avgCrumbDistance"
+ "avgCrumbTimeDiff"
+ "avgDistanceBetweenGPSSessions"
+ "avgFixCountInAGPSSession"
+ "avgGPSCrumbDistance"
+ "avgGPSCrumbTimeDiff"
+ "avgTimeDiffBetweenGPSSessions"
+ "avgWiFiCrumbDistance"
+ "avgWiFiCrumbTimeDiff"
+ "batteryState"
+ "batteryStateToString:"
+ "bool (anonymous namespace)::isTrajectoryStraightBeforeAndAfterFlag(NSArray<CLBackgroundInertialOdometrySample *> * _Nullable, size_t, size_t)"
+ "bool CLAStarRouteConstructor::construct(CLDistanceCalc &, const CFAbsoluteTime, CLGeoMapFeatureAccessGeometryCommon::ProcessingTimeTracker &, const CLGeoMapSnapDataPtr, const CLGeoMapSnapDataPtr, std::shared_ptr<CLGeoMapFeatureRoadGeometryBuffer>, const double, const bool, std::shared_ptr<CLFamiliarRoadData>, const double)"
+ "bool CLAStarRouteConstructor::construct(CLDistanceCalc &, const CFAbsoluteTime, CLGeoMapFeatureAccessGeometryCommon::ProcessingTimeTracker &, const CLGeoMapSnapDataPtr, const CLGeoMapSnapDataPtr, std::shared_ptr<CLGeoMapFeatureRoadGeometryBuffer>, const double, const bool, std::shared_ptr<CLFamiliarRoadData>, const double)_block_invoke"
+ "bool CLAStarRouteConstructor::constructPedestrian(CLDistanceCalc &, const CFAbsoluteTime, CLGeoMapFeatureAccessGeometryCommon::ProcessingTimeTracker &, const CLMapRoadPtr &, const CLMapRoadPtr &, std::shared_ptr<CLGeoMapFeatureRoadGeometryBuffer>, const GEOLocationCoordinate2D &, const double, double, const std::optional<double>)"
+ "bool CLGeoAccessCommon::findClosestPointOnRoad(CLDistanceCalc &, const int, const std::vector<Coordinate> &, const Coordinate &, double &, double &) [Coordinate = CLLocationCoordinate2D]"
+ "bool CLGeoMapFeatureAccessGeometryCommon::ProcessingTimeTracker::processingTimeExceededMaxAllowed() const"
+ "bool CLLocationOutlierRejector::constructIOTrajectory(NSArray<CLBackgroundInertialOdometrySample *> * _Nonnull, const std::vector<double> &, std::vector<CMVector<double, kNumberOfDimensions>> &, std::vector<bool> &)"
+ "bool CLLocationOutlierRejector::constructLocationTrajectory(NSArray<CLTripSegmentLocation *> * _Nonnull, std::vector<CMVector<double, kNumberOfDimensions>> &, std::vector<double> &, std::vector<double> &)"
+ "bool CLLocationOutlierRejector::runRejector(NSArray<CLTripSegmentLocation *> * _Nonnull, NSArray<CLBackgroundInertialOdometrySample *> * _Nullable, NSMutableIndexSet * _Nullable, std::unordered_map<size_t, double> &, const bool)"
+ "bool CLLocationOutlierRejector::selectInliers(NSArray<CLTripSegmentLocation *> * _Nonnull, NSArray<CLBackgroundInertialOdometrySample *> * _Nonnull, NSMutableIndexSet * _Nonnull, double &)"
+ "bool CLLocationOutlierRejector::setHeadAndTailIndicesForLocationArray(NSArray<CLTripSegmentLocation *> * _Nonnull, NSArray<CLBackgroundInertialOdometrySample *> * _Nullable)"
+ "bool CLPTSUtility::areTriplocationSamplesTooSparseInSpace(NSArray<CLTripSegmentLocation *> * _Nonnull)"
+ "bool CLTrajectorySmoother::runPedestrianTrajectorySmoothing(NSArray<CLTripSegmentLocation *> * _Nonnull, NSArray<CLBackgroundInertialOdometrySample *> * _Nullable, NSMutableArray<CLTripSegmentLocation *> * _Nonnull, double &, const bool, const bool, std::unordered_map<size_t, double> &)"
+ "bool CLTripSegmentMapIntegratorSparse::constructSegment(NSUUID * _Nonnull, const std::vector<CLGeoMapSnapDataPtr> &, const std::vector<CLGeoMapSnapDataPtr> &, bool, bool, const CLTripSegmentModeOfTransport)"
+ "bool CLTripSegmentProcessor::constructRouteUsingFamiliarRoads(NSUUID * _Nonnull, NSArray<CLTripSegmentRoadData *> * _Nonnull, CLTripSegmentRoadData * _Nonnull, CLTripSegmentRoadData * _Nonnull, const CLTripSegmentModeOfTransport, CLTripSegmentProcessorOptions * _Nonnull, TripSegmentOutputDataHandler _Nonnull)"
+ "bool CLTripSegmentProcessor::convert1HzDataToSparseAndComputeRouteMatchKPI(CLTripSegmentProcessorOptions * _Nonnull, CLTripSegmentInputData * _Nonnull, CLTripSegmentOutputData * _Nonnull)"
+ "bool CLTripSegmentProcessor::convert1HzDataToSparseAndComputeRouteMatchKPI(CLTripSegmentProcessorOptions * _Nonnull, CLTripSegmentInputData * _Nonnull, CLTripSegmentOutputData * _Nonnull)_block_invoke"
+ "bool CLTripSegmentProcessor::generateWaypointsOnTheRoute(NSUUID * _Nonnull, NSArray<CLTripSegmentRoadData *> * _Nullable, const CLTripSegmentModeOfTransport, CLTripSegmentProcessorOptions * _Nonnull, TripSegmentOutputDataHandler _Nonnull)"
+ "bool CLTripSegmentProcessor::getMatchedLocationCandidates(NSUUID * _Nonnull, const CLTripSegmentModeOfTransport, NSArray<CLTripSegmentLocation *> * _Nullable, CLTripSegmentProcessorOptions * _Nonnull, TripSegmentOutputDataHandler _Nonnull)"
+ "bool CLTripSegmentProcessor::getWaypointsSubsetFromSnapPoint(NSUUID * _Nonnull, const CLTripSegmentModeOfTransport, CLTripSegmentLocation * _Nonnull, CLTripSegmentRoadData * _Nonnull, NSArray<CLTripSegmentRoadData *> * _Nonnull, NSArray<CLTripSegmentLocation *> * _Nullable, CLTripSegmentProcessorOptions * _Nonnull, TripSegmentOutputDataHandler _Nonnull)"
+ "bool CLTripSegmentProcessor::matchLocationsToRoute(NSUUID * _Nonnull, NSArray<CLTripSegmentRoadData *> * _Nonnull, NSArray<CLTripSegmentLocation *> * _Nullable, const CLTripSegmentModeOfTransport, NSArray<CLTripSegmentLocation *> * _Nonnull, CLTripSegmentProcessorOptions * _Nonnull, TripSegmentOutputDataHandler _Nonnull)"
+ "bool CLTripSegmentProcessor::matchLocationsToRoute(NSUUID * _Nonnull, NSArray<CLTripSegmentRoadData *> * _Nonnull, const CLTripSegmentModeOfTransport, NSArray<CLTripSegmentLocation *> * _Nonnull, CLTripSegmentProcessorOptions * _Nonnull, TripSegmentOutputDataHandler _Nonnull)"
+ "bool CLTripSegmentProcessor::processPedestrianData(CLTripSegmentProcessorOptions * _Nonnull, NSUUID * _Nonnull, const bool, const CLTripSegmentModeOfTransport, NSArray<CLTripSegmentLocation *> * _Nonnull, NSArray<CLBackgroundInertialOdometrySample *> * _Nonnull, NSMutableArray<CLTripSegmentLocation *> * _Nonnull, NSMutableArray<CLTripSegmentRoadData *> * _Nonnull)"
+ "bool CLTripSegmentProcessor::processVehicularData(CLTripSegmentProcessorOptions * _Nonnull, NSUUID * _Nonnull, const bool, const CLTripSegmentModeOfTransport, NSArray<CLTripSegmentLocation *> * _Nonnull, NSArray<CLTripSegmentInertialData *> * _Nonnull, NSMutableArray<CLTripSegmentLocation *> * _Nonnull, NSMutableArray<CLTripSegmentRoadData *> * _Nonnull)"
+ "bool CLTripSegmentProcessor::propagateLocationForward(NSUUID * _Nonnull, const CLTripSegmentModeOfTransport, NSArray<CLTripSegmentLocation *> * _Nullable, NSArray<CLTripSegmentRoadData *> * _Nullable, const double, CLTripSegmentProcessorOptions * _Nonnull, TripSegmentOutputDataHandler _Nonnull)"
+ "bool CLTripSegmentProcessor::runMapIntegrator(CLTripSegmentProcessorOptions * _Nonnull, NSUUID * _Nonnull, const CLTripSegmentModeOfTransport, const bool, NSArray<CLTripSegmentLocation *> * _Nonnull, NSArray<CLTripSegmentLocation *> * _Nonnull, NSMutableArray<CLTripSegmentLocation *> * _Nonnull, NSMutableArray<CLTripSegmentRoadData *> * _Nonnull)"
+ "bool CLTripSegmentProcessor::simulateLocationOnRoute(NSUUID * _Nonnull, NSArray<CLTripSegmentRoadData *> * _Nonnull, const CLTripSegmentModeOfTransport, double, CLTripSegmentProcessorOptions * _Nonnull, TripSegmentOutputDataHandler _Nonnull)"
+ "bool CLTripSegmentProcessor::validateIncomingTripLocationData(CLTripSegmentProcessorOptions * _Nonnull, NSUUID * _Nonnull, NSArray<CLTripSegmentLocation *> * _Nonnull, const CLTripSegmentModeOfTransport)"
+ "bool CLTripSegmentRouteBuilder::addExtraFreewayCandidateInWiderRadius(const CFAbsoluteTime, std::shared_ptr<CLGeoMapFeatureRoadGeometryBuffer>, const std::vector<CLGeoMapSnapDataPtr> &, std::vector<CLGeoMapSnapDataPtr> &)"
+ "bool CLTripSegmentRouteBuilder::generateRouteCandidatesForOneSegment(const CFAbsoluteTime, std::shared_ptr<CLGeoMapFeatureRoadGeometryBuffer>, const std::vector<CLGeoMapSnapDataPtr> &, std::vector<CLGeoMapSnapDataPtr> &, const std::vector<CLRouteCandidateVector> &, std::vector<CLRouteCandidatePtr> &, std::vector<CLRouteCandidateVector> &)"
+ "bool CLTripSegmentUtilities::CLGPSFixTracker::canUseThisFix(NSArray<CLTripSegmentLocation *> * _Nonnull, int, const double, const bool, const double, const double)"
+ "bool CMRobustUmeyama<double, 2>::runMEstimator(const std::vector<CMVector<T, N>> &, const std::vector<CMVector<T, N>> &, const std::vector<T> &) [T = double, N = 2]"
+ "bool CMUmeyama<double, 2>::checkAndNormalizeWeights(const std::vector<T> &) [T = double, N = 2]"
+ "bool CMUmeyama<double, 2>::computeScaling(const CMVector<T, N> &) [T = double, N = 2]"
+ "bool CMUmeyama<double, 2>::isRotationMatrixValid() [T = double, N = 2]"
+ "bool CMUmeyama<double, 2>::performSingularValueDecomposition(const CMMatrix<T, N> &, CMMatrix<T, N> &, CMVector<T, N> &, CMMatrix<T, N> &) const [T = double, N = 2]"
+ "bool CMUmeyama<double, 2>::runAlgorithm(const std::vector<CMVector<T, N>> &, const std::vector<CMVector<T, N>> &, const std::vector<T> &) [T = double, N = 2]"
+ "calibration"
+ "calibrationRotationToTrueNorth"
+ "calibrationScaleFactor"
+ "callReason"
+ "callRelatedToEmergency"
+ "callTrigger"
+ "call_reason"
+ "call_related_to_emergency"
+ "call_trigger"
+ "callerResponsive"
+ "caller_responsive"
+ "cancelMapHelperRoadDataRequest"
+ "cancelRoadDataRequest"
+ "checkAndExerciseLearnedRoutesAuthorizationForBundleID:orBundlePath:replyBlock:"
+ "checkAndExercisePushClientAuthorizationForBundleID:replyBlock:"
+ "clMapRoadDerivedFromMapsAPI"
+ "clMapRoadNotFoundForRouteRoadEntry"
+ "com.apple.demo-settings"
+ "commuteID"
+ "configWithMonitorName:onBehalfOfBundleIdentifier:queue:eventHandler:"
+ "configureWithWorkoutActivity:shouldReconstructEntireRoute:timeIntervalsThatNeedPopulating:"
+ "configureWithWorkoutActivityType:shouldReconstructEntireRoute:timeIntervalsThatNeedPopulating:"
+ "connectingClMapRoadNotFoundForRouteRoadEntry"
+ "connectingRoadEndCoordinate"
+ "connectingRoadFoundUsingAnotherEntryInArray"
+ "connectingRoadFoundUsingClRoaIDMatch"
+ "connectingRoadMatchedUsingMapsAPI"
+ "connectingRoadMatchedUsingStartAndEndCoordinate"
+ "connectingRoadStartAndEndCoordinateNotAvailable"
+ "connectingRoadStartCoordinate"
+ "connectionManager"
+ "constructRouteFromLocation:roadID:clRoadID:projection:toLocation:toRoadID:toCLRoadID:toProjection:maxRouteLength:allowNetwork:isPedestrianOrCycling:clearTiles:iOSTime:familiarityData:withReply:"
+ "constructRouteWithID:withOptions:usingRoadData:startRoad:endRoad:modeOfTransport:outputHandler:"
+ "constructRouteWithID:withOptions:usingRoadData:startRoad:endRoad:modeOfTransport:outputHandler:completionHandler:"
+ "containsIndex:"
+ "convertCLMapRoadVectorToRoadDictionaryArray:"
+ "coord%d"
+ "copyRecentLocationsBufferStatus"
+ "dotBiasChange"
+ "double &CLTripSegmentSharedData::getRoadSequenceNumber(const std::string &)"
+ "double (anonymous namespace)::computDistanceBetweenTwoIOSamples(NSArray<CLBackgroundInertialOdometrySample *> * _Nullable, size_t, size_t)"
+ "double CLAStarRouteConstructor::getPercentageOfFamiliarRoadsInRoute(std::shared_ptr<CLFamiliarRoadData>)"
+ "dualConnectionTime"
+ "dualLeashTime"
+ "empty payload, no stats"
+ "enableUseWifiInPTS"
+ "fGEOMapFeatureAccess"
+ "fGeoMapFeatureRoadRequest"
+ "fHasEntitlementForBuildingData"
+ "fHasEntitlementForRoadData"
+ "fRoadDataRequestInProgress"
+ "fShouldReconstructEntireRoute"
+ "fTimeIntervalsThatNeedPopulating"
+ "fTransaction"
+ "fWorkoutActivityType"
+ "fc1ndRangingCount"
+ "fc1ndRangingTime"
+ "feedbackVersion"
+ "feedback_version"
+ "fetchGEORoadDataAtIntersectionOf:allowNetwork:isPedestrianOrCycling:clearTiles:ignoreUTurns:returnRoads:"
+ "fetchLocationAtDate:withHandler:"
+ "fetchLocationAtMachContinuousTime:withHandler:"
+ "fetchLocationsInLastSeconds:withHandler:"
+ "fetchRecentLocationAtCfAbsoluteTime:"
+ "fetchRecentLocationAtMachContinuousTime:"
+ "fetchRecentLocationsInLastSeconds:"
+ "fetchRecentLocationsWithOptions:replyBlock:"
+ "fetchRecentLocationsWithOptions:withHandler:"
+ "findMyAccessoryManager:didPrepareRangingOnDevice:withConnInterval:error:"
+ "generateWaypointsOnTheRoute"
+ "generateWaypointsOnTheRoute:forRouteID:withOptions:modeOfTransport:outputHandler:"
+ "generateWaypointsOnTheRoute:forRouteID:withOptions:modeOfTransport:outputHandler:completionHandler:"
+ "getCLMapRoadForLocation:roadID:clRoadID:allowNetwork:isPedestrianOrCycling:clearTiles:"
+ "getGEOMapFeatureRoadDataAroundLatitude:longitude:inRadius:allowNetwork:isPedestrianOrCycling:clearTiles:returnRoads:"
+ "getLearnedRoutesAccess:forBundleID:orBundlePath:"
+ "getLearnedRoutesAccess:forBundleIdentifier:"
+ "getLearnedRoutesAccessForBundleID:orBundlePath:replyBlock:"
+ "getMatchedLocationCandidates"
+ "getMatchedLocationCandidates:dataID:modeOfTransport:options:outputHandler:"
+ "getMatchedLocationCandidates:dataID:modeOfTransport:options:outputHandler:completionHandler:"
+ "getRecentLocationsBufferStatusWithReplyBlock:"
+ "getRemoteObjectProxyWithErrorHandler:"
+ "getVisitHistoryAccess:forBundleID:orBundlePath:"
+ "getVisitHistoryAccess:forBundleIdentifier:"
+ "getVisitHistoryAccessAllowedTime:forBundleID:orBundlePath:"
+ "getVisitHistoryAccessAllowedTime:forBundleIdentifier:"
+ "getVisitHistoryAccessAllowedTimeForBundleID:orBundlePath:replyBlock:"
+ "getVisitHistoryAccessForBundleID:orBundlePath:replyBlock:"
+ "getWaypointsSubsetFromSnapPointOnRoute:modeOfTransport:snapLocation:snapRoad:waypoints:routeID:withOptions:outputHandler:"
+ "gpsCrumbsCount"
+ "gpsPercentage"
+ "handleMessageWithName:payload:"
+ "handleResponseMessage:"
+ "headingMode"
+ "initWithCLLocation:systemTime:machContinuousTimeSec:"
+ "initWithCommuteID:tripSegmentID:isFinalPart:modeOfTransport:tripLocations:startTripLocation:stopTripLocation:inertialOdometryData:"
+ "initWithDate:"
+ "initWithDate:allowDelayedResponse:"
+ "initWithDate:machContinuousTimeSeconds:numberOfSeconds:allowDelayedResponse:returnSparseLocations:"
+ "initWithDouble:"
+ "initWithID:psapID:partnerID:geofenceID:requestDate:state:feedbackVersion:callRelatedToEmergency:callerResponsive:callTrigger:callReason:respondersDispatched:"
+ "initWithMachContinuousTimeSeconds:"
+ "initWithMachContinuousTimeSeconds:allowDelayedResponse:"
+ "initWithNumberOfSeconds:"
+ "initWithNumberOfSeconds:allowDelayedResponse:"
+ "initWithNumberOfSeconds:allowDelayedResponse:returnSparseLocations:"
+ "initWithNumberOfSeconds:returnSparseLocations:"
+ "initWithOverflowFlag:crashCount:multiTime:nearOwnerTime:wildTime:soundCount:soundTime:rangingCount:rangingTime:multiLeashTime:multiConnectionTime:nearOwnerTimeV2:singleLeashTime:singleConnectionTime:dualConnectionTime:dualLeashTime:utAccelCount:lastClear:roseOnTime:ownerLongSoundCount:ownerShortSoundCount:utLongSoundCount:utShortSoundCount:bomSoundCount:fc1ndRangingCount:fc1ndRangingTime:lastPIn:batteryState:nbmmsRangingTime:abandonedFwUpdateCount:abandonedFwUpdateTime:roseInitCount:pairingAttemptsCount:proxPairingTime:version:"
+ "initWithPOICategory:"
+ "initWithPayloadV3:"
+ "initWithQueue:memoryCacheCountLimit:memoryCacheCostLimit:"
+ "initWithRotationToTrueNorth:scaleFactor:"
+ "initWithSilo:locationManager:startMessageName:startMessagePayload:responseHandler:"
+ "initWithStartMessageName:startMessagePayload:locationManager:responseHandler:"
+ "initWithStartMessageName:startMessagePayload:responseHandler:"
+ "initWithSupportsFC1ND:supportsNBAMMS:supportsUnii5:capabilities:"
+ "initWithTimestamp:machContinuousTimestamp:sampleInterval:deltaPosition:deltaVelocity:quaternion:referenceFrameContinuity:referenceFrame:staticFlag:mountState:zupt:dotBiasChange:calibration:"
+ "initWithWorkoutActivityType:shouldReconstructEntireRoute:timeIntervalsThatNeedPopulating:"
+ "integerForKey:"
+ "internalConstructVehicularRouteFromLocation:roadID:clRoadID:projection:toLocation:toRoadID:toCLRoadID:toProjection:maxRouteLength:allowNetwork:isPedestrianOrCycling:clearTiles:iOSTime:familiarityData:"
+ "invalid length"
+ "isEligibleForAlwaysAuthorizationRequestForBundleID:orBundlePath:completionHandler:"
+ "isEligibleForAlwaysAuthorizationRequestForBundleID:orBundlePath:replyBlock:"
+ "isEqualToFetchOptions:"
+ "isTripSegmentLocationFollowedByUTurnMaskSet"
+ "isTripSegmentLocationMotionStationaryMaskSet"
+ "isWatch"
+ "kCLConnectionMessageDiagnostics"
+ "kCLConnectionMessageHistoricalLocationStartDateKey"
+ "kCLConnectionMessagehistoricalLocationEndDateKey"
+ "kCLHeadingCodingKeyHeadingMode"
+ "kCLVisitConditionLatitude"
+ "kCLVisitConditionLongitude"
+ "kCLVisitConditionPoi"
+ "kCLVisitConditionRadius"
+ "lastPIn"
+ "lastPin"
+ "locationDataMask"
+ "machContinuousTimeSec"
+ "machContinuousTimeSeconds"
+ "magneticHeading %.2f trueHeading %.2f accuracy %.2f headingMode %d x %+.3f y %+.3f z %+.3f @ %@"
+ "malformed TLV, offset + 2 >= length"
+ "malformed TLV, offset + length > payload"
+ "mapDataUnavailable"
+ "maphelperservice"
+ "matchLocations:toRoute:waypoints:withOptions:andRouteID:modeOfTransport:outputHandler:"
+ "matchLocations:toRoute:waypoints:withOptions:andRouteID:modeOfTransport:outputHandler:completionHandler:"
+ "matchLocations:toRoute:withOptions:andRouteID:modeOfTransport:outputHandler:"
+ "maxCrumbDistance"
+ "maxCrumbTimeDiff"
+ "maxDistanceBetweenGPSSessions"
+ "maxFamiliarityIndex"
+ "maxFixCountInAGPSSession"
+ "maxGPSCrumbDistance"
+ "maxGPSCrumbTimeDiff"
+ "maxPairedDeviceCount"
+ "maxProcessingTimeInMilliSec"
+ "maxProcessingTimeMilliSec"
+ "maxTimeDiffBetweenGPSSessions"
+ "maxWiFiCrumbDistance"
+ "maxWiFiCrumbTimeDiff"
+ "metricSubmitted"
+ "minFixCountInAGPSSession"
+ "mountState"
+ "multiConnectionTime"
+ "multiLeashTime"
+ "nbmmsRangingTime"
+ "numGPSSessions"
+ "numberOfSeconds"
+ "onBehalfOfBundleIdentifer"
+ "outputRouteLearningDebuggingDataInCLTSPFile:"
+ "pairingAttemptsCount"
+ "percentageOfFamiliarRoadsInRoute"
+ "percentageOfRailwaySnap"
+ "poiCategory"
+ "processingEndTime"
+ "processingStartTime"
+ "propagateLocation:route:distance:withOptions:modeOfTransport:outputHandler:"
+ "propagateLocation:route:distance:withOptions:modeOfTransport:outputHandler:completionHandler:"
+ "proxPairingAttemptsCount"
+ "proxPairingTime"
+ "psap_feedback"
+ "removeAllIndexes"
+ "removeIndexes:"
+ "respondersDispatched"
+ "responders_dispatched"
+ "returnSparseLocations"
+ "roadFamiliarityAddedForRouteRoadEntry"
+ "roadFamiliarityNotAddedForRouteRoadEntry"
+ "roseInitCount"
+ "roseOnTime"
+ "rotationToTrueNorth_rad"
+ "routeDeviationComparedTo1HzGPS"
+ "routeDeviationPerHrComparedTo1HzGPS"
+ "routeDeviationPerKmComparedTo1HzGPS"
+ "routeLengthMatchPercentageComparedTo1HzGPS"
+ "runLocationOutlierRejector"
+ "scaleFactor"
+ "sequenceNumber"
+ "setCallReason:"
+ "setCallRelatedToEmergency:"
+ "setCallTrigger:"
+ "setCallerResponsive:"
+ "setConnectingRoadStartCoordinate:endCoordinate:"
+ "setConnectionManager:"
+ "setEnableUseWifiInPTS:"
+ "setEntitlementsForBuilding:"
+ "setEntitlementsForRoad:"
+ "setFeedbackVersion:"
+ "setIsValid:"
+ "setIsWatch:"
+ "setLearnedRoutesAccess:forBundleID:orBundlePath:"
+ "setLearnedRoutesAccess:forBundleID:orBundlePath:replyBlock:"
+ "setLearnedRoutesAccess:forBundleIdentifier:"
+ "setLocationDataMask:"
+ "setMachContinuousTimeSec:"
+ "setMaxProcessingTimeInMilliSec:"
+ "setMetricSubmitted:"
+ "setObject:atIndexedSubscript:"
+ "setRespondersDispatched:"
+ "setRunLocationOutlierRejector:"
+ "setSequenceNumber:"
+ "setStarted:"
+ "setStepSizeForLocationOutlierRejector:"
+ "setSystemTimeNotUserTime:"
+ "setTripSegmentLocationDataMask:"
+ "setUseNonGNSSFixesForRouteReconstruction:"
+ "setUseXPCServiceForVehicularAStarSearch:"
+ "setVisitHistoryAccess:forBundleID:orBundlePath:"
+ "setVisitHistoryAccess:forBundleID:orBundlePath:replyBlock:"
+ "setVisitHistoryAccess:forBundleIdentifier:"
+ "setWindowSizeForLocationOutlierRejector:"
+ "simulateLocationOnRouteID:withOptions:usingRoadData:modeOfTransport:constantSpeed:outputHandler:"
+ "simulateLocationOnRouteID:withOptions:usingRoadData:modeOfTransport:constantSpeed:outputHandler:completionHandler:"
+ "singleConnectionTime"
+ "singleLeashTime"
+ "smoothLocations:batchType:handler:"
+ "stageTADetection:deviceType:detailsBitmask:shouldRemoveDevice:"
+ "started"
+ "static CLMapRoadPtr CLTripSegmentUtilities::getCLMapRoadPtrOfConnectingRoad(CLTripSegmentRoadData * _Nonnull, std::shared_ptr<CLGeoMapFeatureRoadGeometryBuffer> &, const std::vector<CLMapRoadPtr> &)"
+ "static bool CLRoadTypeConversionUtilities::getCLTripSegmentRoadDataArrayAsCLMapRoadVector(NSArray<CLTripSegmentRoadData *> * _Nonnull, std::vector<CLMapRoadPtr> &, std::shared_ptr<CLGeoMapFeatureRoadGeometryBuffer>)"
+ "static bool CLTripSegmentUtilities::convertInertialOdometryDataToInertialData(NSArray<CLTripSegmentLocation *> * _Nonnull, NSArray<CLBackgroundInertialOdometrySample *> * _Nonnull, NSMutableArray<CLTripSegmentInertialData *> * _Nonnull)"
+ "static bool CLTripSegmentUtilities::generateWayPointsOnTheRoute(CLDistanceCalc &, NSUUID * _Nonnull, std::shared_ptr<CLGeoMapFeatureRoadGeometryBuffer> &, const std::vector<CLMapRoadPtr> &, NSMutableArray<CLTripSegmentLocation *> * _Nonnull)"
+ "static bool CLTripSegmentUtilities::getCLTripSegmentRoadDataArrayAsConsolidatedCLMapRoad(NSArray<CLTripSegmentRoadData *> * _Nonnull, std::shared_ptr<CLGeoMapFeatureRoadGeometryBuffer> &, CLMapRoadPtr &)"
+ "static int CLTripSegmentUtilities::getUserDefaultsIntForKey(NSString * _Nonnull, const int)"
+ "stepSizeForLocationOutlierRejector"
+ "stringValue"
+ "supportsUnii5"
+ "systemTimeNotUserTime"
+ "takeOSTransaction"
+ "triggerRecentLocationsRevisedFromMachContinuousTime:toMachContinuousTime:"
+ "triggerRecentLocationsRevisedFromMachContinuousTime:toMachContinuousTime:replyBlock:"
+ "tripID"
+ "unknown type"
+ "updateLastHistoricalLocationTimestamp:"
+ "useNonGNSSFixesForRouteReconstruction"
+ "useXPCServiceForVehicularAStarSearch"
+ "v140@0:8{CLLocationCoordinate2D=dd}16Q32Q40d48{CLLocationCoordinate2D=dd}56Q72Q80d88d96B104B108B112d116@\"NSArray\"124@?<v@?@\"NSArray\">132"
+ "v140@0:8{CLLocationCoordinate2D=dd}16Q32Q40d48{CLLocationCoordinate2D=dd}56Q72Q80d88d96B104B108B112d116@124@?132"
+ "v28@0:8I16@?<v@?@\"NSArray\"@\"NSError\">20"
+ "v32@0:8@\"CLRecentLocationsFetchOptions\"16@?<v@?@\"NSArray\"@\"NSError\">24"
+ "v32@0:8@\"CLRecentLocationsFetchOptions\"16@?<v@?@\"NSError\"@\"NSArray\"@\"NSArray\"@\"NSArray\">24"
+ "v32@0:8@\"NSDate\"16@?<v@?@\"CLLocationExtendedTimestamps\"@\"NSError\">24"
+ "v32@0:8@\"NSString\"16@?<v@?@\"NSError\"BB>24"
+ "v32@0:8d16@?24"
+ "v32@0:8d16@?<v@?@\"CLLocationExtendedTimestamps\"@\"NSError\">24"
+ "v32@0:8i16B20@\"NSArray\"24"
+ "v32@0:8i16B20@24"
+ "v40@0:8@\"NSArray\"16Q24@?<v@?@\"NSArray\"@\"NSError\">32"
+ "v40@0:8@\"NSString\"16@\"NSString\"24@?<v@?@\"NSError\"d>32"
+ "v40@?0@\"NSError\"8@\"NSArray\"16@\"NSArray\"24@\"NSArray\"32"
+ "v64@0:8@16@24@32q40@?48@?56"
+ "v64@0:8@16@24q32@40@?48@?56"
+ "v72@0:8@16@24@32q40d48@?56@?64"
+ "v72@0:8@16@24d32@40q48@?56@?64"
+ "v80@0:8@16@24@32@40@48q56@?64@?72"
+ "void CLAStarRouteConstructor::constructRouteCandidates(std::shared_ptr<CLGeoMapFeatureRoadGeometryBuffer>, CLGeoMapFeatureAccessGeometryCommon::ProcessingTimeTracker &, const std::vector<CLGeoMapSnapDataPtr> &, const std::vector<CLGeoMapSnapDataPtr> &, std::vector<CLRouteCandidatePtr> &)"
+ "void CLGeoMapFeatureAccessGeometryCommon::ProcessingTimeTracker::start(const double)"
+ "void CLTripSegmentAnalytics::fillAnalyticsFromTripSegmentInputData(CLTripSegmentInputData * _Nonnull)"
+ "void CLTripSegmentAnalyticsSimulatedTripSegment::compareAndSubmitCoreAnalytics(NSUUID * _Nonnull, NSUUID * _Nonnull, const int, NSArray<CLTripSegmentLocation *> * _Nonnull, CLTripSegmentOutputData * _Nonnull, const double)"
+ "void CLTripSegmentRouteMatchKPI::computeKPI(NSArray<CLTripSegmentRoadData *> * _Nonnull, NSArray<CLTripSegmentRoadData *> * _Nonnull, bool)"
+ "void CLTripSegmentSharedData::addTrip(const std::string &, std::shared_ptr<CLTripSegmentStaticData> &)"
+ "void CLTripSegmentSharedData::removeTrip(const std::string &)"
+ "void getGeoMapGeometrySettingsForRouteReconstruction(const std::string &, CLTripSegmentProcessorOptions * _Nonnull, CLGeoMapFeatureGeometrySettings &, const CLTripSegmentModeOfTransport)"
+ "watch-companion"
+ "wiFiCrumbsCount"
+ "wiFiPercentage"
+ "windowSizeForLocationOutlierRejector"
+ "zupt"
+ "{\"msg%{public}.0s\":\"#ADL #location #routine getRemoteObjectProxy\", \"proxy\":%{public, location:escape_only}@, \"connection\":%{public, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#ADL #routine fetchLocationAtDate\", \"proxy\":%{public, location:escape_only}@, \"date\":%{public, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#ADL #routine fetchLocationAtMachContinuousTime\", \"proxy\":%{public, location:escape_only}@, \"mct\":\"%{public}0.3f\"}"
+ "{\"msg%{public}.0s\":\"#ADL #routine fetchLocationsInLastSeconds\", \"proxy\":%{public, location:escape_only}@, \"numberOfSeconds\":%{public}d}"
+ "{\"msg%{public}.0s\":\"#ADL #routine fetchRecentLocationsWithOptions\", \"proxy\":%{public, location:escape_only}@, \"fetchOptions\":%{public, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#durian #userstats initWithPayloadV3\", \"payload\":%{public, location:escape_only}@, \"size\":%{public}d}"
+ "{\"msg%{public}.0s\":\"#durian #userstats\", \"error\":%{public, location:escape_only}s, \"payload\":%{public, location:escape_only}@, \"offset\":%{public}d, \"size\":%{public}d}"
+ "{\"msg%{public}.0s\":\"#durian #userstats\", \"error\":%{public, location:escape_only}s, \"payload\":%{public, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#durian #userstats\", \"error\":%{public, location:escape_only}s, \"typeHexString\":%{public, location:escape_only}@, \"type\":%{public}d, \"length\":%{public}d, \"valueHexString\":%{public, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#durian #userstats\", \"type\":%{public, location:escape_only}s, \"offset\":%{public}d, \"typeHex\":%{public, location:escape_only}@, \"type\":%{public}d, \"length\":%{public}d, \"valueHex\":%{public, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#durian #userstats\", \"type\":%{public, location:escape_only}s, \"typeByte\":%{public}d, \"length\":%{public}d, \"valueHex\":%{public, location:escape_only}@, \"value\":%{public}u}"
+ "{\"msg%{public}.0s\":\"#ficConnectionManager _pauseLocationUpdater\", \"self\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"#ficConnectionManager _resumeLocationUpdater\", \"self\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"#ficConnectionManager cannnot be created without a response-handler\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#ficConnectionManager connection created\", \"identityToken\":%{public, location:escape_only}@, \"self\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"#ficConnectionManager destroyUponDisconnection(DIC)\", \"identityToken\":%{public, location:escape_only}s, \"self\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"#ficConnectionManager destroying connection (dealloc)\"}"
+ "{\"msg%{public}.0s\":\"#ficConnectionManager destroying connection\", \"identityToken\":%{public, location:escape_only}s, \"self\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"#ficConnectionManager has nil silo; Creating locally\", \"self\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"#ficConnectionManager init\", \"self\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"#ficConnectionManager manageConnection\", \"self\":\"%{public}p\", \"identityToken\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#ficConnectionManager pause\", \"self\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"#ficConnectionManager resume\", \"self\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"#ficConnectionManager tearDown\", \"self\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"#ficConnectionManager updateIdentityToken\", \"self\":\"%{public}p\", \"identityToken\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#fullAccuracySession Default handler received message\", \"self\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"#fullAccuracySession handleMessageDiagnostics\", \"self\":\"%{public}p\", \"diagnosticMask\":%{public}d}"
+ "{\"msg%{public}.0s\":\"#monitor monitor-config with onBehalfOfBundleId\", \"self\":%{public, location:escape_only}@, \"OnBehalfBundleId\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#serviceSession Default handler received message\", \"self\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"#serviceSession handleMessageDiagnostics\", \"self\":\"%{public}p\", \"diagnosticMask\":%{public}d}"
+ "{\"msg%{public}.0s\":\"CLInternalGetLearnedRoutesAccess\", \"event\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"CLInternalGetVisitHistoryAccess\", \"event\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"CLInternalGetVisitHistoryAccessAllowedTime\", \"event\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"CLInternalSetLearnedRoutesAccess\", \"event\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"CLInternalSetVisitHistoryAccess\", \"event\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"CLLocationManager\", \"event\":%{public, location:escape_only}s, \"_cmd\":%{public, location:escape_only}@, \"self\":\"%{public}p\", \"bundleID\":%{public, location:escape_only}s, \"bundlePath\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"Can't load data from file\", \"filename\":%{public, location:escape_only}s, \"exception\":%{public, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"Invalid fileURL\", \"filename\":%{public, location:escape_only}s}"
+ "{?=\"x\"d\"y\"d\"z\"d\"magneticHeading\"d\"trueHeading\"d\"accuracy\"d\"timestamp\"d\"temperature\"d\"magnitude\"d\"inclination\"d\"calibration\"i\"headingMode\"i}"
+ "{CLRacingRoute=\"fDistanceCalculator\"{CLDistanceCalc=\"fM\"d\"fN\"d\"fRefLatRads\"d\"fRefLatDegs\"d\"fCosRefLat\"d}\"fSignalEnvironmentType\"i\"fWorkoutActivity\"i\"fRoutePoints\"@\"NSMutableArray\"\"fRouteBoundingBox\"{RouteBoundingBox=\"fMinLatitude_deg\"d\"fMaxLatitude_deg\"d\"fMinLongitude_deg\"d\"fMaxLongitude_deg\"d\"fRows\"i\"fColumns\"i}\"fRouteMatrixIndexVec\"{vector<std::vector<std::pair<int, int>>, std::allocator<std::vector<std::pair<int, int>>>>=\"__begin_\"^v\"__end_\"^v\"__cap_\"^v}\"fRaceStartPointOnCurrentRoute\"{RacingRouteState=\"fLatitude_deg\"d\"fLongitude_deg\"d\"fAltitude_m\"d\"fOdometer_m\"d\"fTimestamp_s\"d\"fTimeSinceStartOfRace_s\"d\"fOffRouteTraveledTime_s\"d\"fDistanceSinceStartOfRace_m\"d\"fOffRouteTraveledDistance_m\"d\"fAveragePace_s_per_m\"d\"fDistanceAlongReferenceRoute_m\"d}\"fRaceStartPointOnReferenceRoute\"{RacingRouteState=\"fLatitude_deg\"d\"fLongitude_deg\"d\"fAltitude_m\"d\"fOdometer_m\"d\"fTimestamp_s\"d\"fTimeSinceStartOfRace_s\"d\"fOffRouteTraveledTime_s\"d\"fDistanceSinceStartOfRace_m\"d\"fOffRouteTraveledDistance_m\"d\"fAveragePace_s_per_m\"d\"fDistanceAlongReferenceRoute_m\"d}\"fLastOnRouteDataPoint\"{RacingRouteState=\"fLatitude_deg\"d\"fLongitude_deg\"d\"fAltitude_m\"d\"fOdometer_m\"d\"fTimestamp_s\"d\"fTimeSinceStartOfRace_s\"d\"fOffRouteTraveledTime_s\"d\"fDistanceSinceStartOfRace_m\"d\"fOffRouteTraveledDistance_m\"d\"fAveragePace_s_per_m\"d\"fDistanceAlongReferenceRoute_m\"d}\"fLastProjectedDataPoint\"{RacingRouteState=\"fLatitude_deg\"d\"fLongitude_deg\"d\"fAltitude_m\"d\"fOdometer_m\"d\"fTimestamp_s\"d\"fTimeSinceStartOfRace_s\"d\"fOffRouteTraveledTime_s\"d\"fDistanceSinceStartOfRace_m\"d\"fOffRouteTraveledDistance_m\"d\"fAveragePace_s_per_m\"d\"fDistanceAlongReferenceRoute_m\"d}\"fRoutePointsArrayInitialized\"B\"fRecoveryMode\"B\"fRaceStartPointDetected\"B\"fRaceEndPointDetected\"B\"fUserIsOffRoute\"B\"fProjectedOnNearestPoint\"B\"fRaceSessionExpired\"B\"fRollingBufferReachedEndOfReferenceRoute\"B\"fRouteConfigurationSuccessful\"B\"fRacingRouteAnalyticsSent\"B\"fPrematureRaceEndDetected\"B\"fReferenceRouteTotalLengthDetermined\"B\"fLocationPointIsOutsideOfAcceptedRange\"B\"fLocationPointNotMatched\"B\"fRoutePointsBufferSize\"i\"fNumberOfRoutePointsToAdd\"i\"fOffRouteGraceDuration_s\"i\"fMatchedPointCounter\"i\"fReferenceRouteDataPointCounter\"i\"fCurrentRouteDataPointCounter\"i\"fOffRouteDataPointCounter\"i\"fInutileDataPointCounter\"i\"fRollingBufferUpdateCounter\"i\"fLastMatchedPointIndex\"i\"fLastMatchedPointIndexOnReferenceRoute\"i\"fRollingBufferStartIndexOnReferenceRoute\"i\"fMatrixCellIndexForLastMatchedPoint\"i\"fRaceStartLineProximityIndex\"i\"fReferenceRouteTotalLength_m\"d\"fTimestampOfLastMatchedPointOnReferenceRoute_s\"d\"fRegisteredTimeAtThresholdDistance_s\"d\"fEndOfRaceTimeThreshold_s\"d\"fNearestNeighborMaximumAcceptedDistance_m\"d}"
+ "{CLTripSegmentProcessor=\"fDistanceCalculator\"{CLDistanceCalc=\"fM\"d\"fN\"d\"fRefLatRads\"d\"fRefLatDegs\"d\"fCosRefLat\"d}\"fRecorder\"{CLTripSegmentRecorder=\"fRecordingEnabled\"B\"fFileNameShouldContainTime\"B\"fRecordingDirectory\"@\"NSString\"}}"
+ "{shared_ptr<CLMapRoad>=^{CLMapRoad}^{__shared_weak_count}}60@0:8{CLLocationCoordinate2D=dd}16Q32Q40B48B52B56"
+ "{unique_ptr<CLConnectionClient, std::default_delete<CLConnectionClient>>=\"__ptr_\"^{CLConnectionClient}}"
+ "{unique_ptr<CLGNSSStateQueryAssertionResponseInternal, std::default_delete<CLGNSSStateQueryAssertionResponseInternal>>=\"__ptr_\"^{CLGNSSStateQueryAssertionResponseInternal}}"
+ "{unique_ptr<CLGnssDisablementAssertionInternal, std::default_delete<CLGnssDisablementAssertionInternal>>=\"__ptr_\"^{CLGnssDisablementAssertionInternal}}"
+ "{unique_ptr<CLRegulatoryConfigInternal, std::default_delete<CLRegulatoryConfigInternal>>=\"__ptr_\"^{CLRegulatoryConfigInternal}}"
+ "\xa1"
- "\n supportsFC1ND %s\n supports NBAMMS %s\n capabilities %u\n"
- "#Spi, Error with proxy, error: %@"
- "#Warning CLMM, GEOMapFeatureRoad id,%{private}lld,has less than two coordinate,%{public}ld"
- "#Warning could not check %s (errno %d)"
- "#Warning refAlt < %.1lf,refAlt,%.1lf,using the min"
- "#Warning refAlt > %.1lf,refAlt,%.1lf,using the max"
- "#Warning, same coordinates input"
- "#locationUpdater Default handler received message"
- "#locationUpdater client callback handler should not be nil when attempting to -resume"
- "#locationUpdater connection created"
- "#locationUpdater destroyUponDisconnection(DIC)"
- "#locationUpdater destroying connection"
- "#locationUpdater destroying connection (dealloc)"
- "#locationUpdater pause is called"
- "#locationUpdater resume is called"
- "%+08.4lf%+09.4lf%+08.3lf/"
- "%+08.4lf%+09.4lf/"
- "%.1f"
- "%@,%@,%@,%02x,%02x,%@,%@,%d,%d"
- "%@,cfAbsTimestamp, %.3f, machContinuousTimestamp_s, %.3f, sampleInterval_s, %.3f, deltaPosition_m.X, %.3f, deltaPosition_m.Y, %.3f, deltaPosition_m.Z, %.3f, deltaVelocity_mps.X, %.3f, deltaVelocity_mps.Y, %.3f, deltaVelocity_mps.Z, %.3f, quaternion.X, %.3f, quaternion.Y, %.3f, quaternion.Z, %.3f, quaternion.W, %.3f, referenceFrameContinuity, %zu, sessionReferenceFrame, %zu, staticFlag, %zu"
- "%d%d%f%f%f%f"
- "%ld <%+.8f,%+.8f> %.2f %d %d %d"
- "%s,os_transaction already taken, not taking another"
- "-[CLLocationSmoother smoothLocations:workoutActivityType:shouldReconstructRoute:timeIntervalsThatNeedPopulated:handler:]"
- "-[CLLocationUpdater createConnection]"
- "-[CLLocationUpdater dealloc]_block_invoke"
- "-initWithMachServiceName:options: is declared to return nonnull but failed to return an object"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Daemon/Positioning/GPS/CLStateMachine.h"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Framework/CoreLocation/CLLocationSmoother.mm"
- "/System/Library/Frameworks/CoreLocation.framework/Support/WMM.dat"
- "18:29:08"
- "<"
- "<%+.8f,%+.8f> +/- %.2fm (speed %.2f mps / course %.2f) @ %@"
- "<build>"
- "<empty>\n"
- "<name>"
- "<null>"
- "@\"CLLocationGnssOdometerInfo\""
- "@\"CLLocationMatchInfo\""
- "@\"CLLocationTrackRunInfo\""
- "@\"_CLLocationFusionInfo\""
- "@\"_CLLocationGroundAltitude\""
- "@100@0:8d16d24d32d40d48d56d64d72d80i88@92"
- "@104@0:8{?=ddddddddddi}16"
- "@104@0:8{CLLocationCoordinate2D=dd}16d32d40d48d56d64d72d80@88@96"
- "@116@0:8{CLLocationCoordinate2D=dd}16d32d40d48d56d64d72d80@88i96i100@104i112"
- "@136@0:8{?=iddddd{?=dd}dd}16q96q104@112q120i128i132"
- "@172@0:8{?=i{?=dd}ddddddddidi{?=dd}diIiiidB}16"
- "@180@0:8{?=i{?=dd}ddddddddidi{?=dd}diIiiidB}16@172"
- "@188@0:8{?=i{?=dd}ddddddddidi{?=dd}diIiiidB}16@172d180"
- "@196@0:8{?=i{?=dd}ddddddddidi{?=dd}diIiiidB}16@172d180@188"
- "@216@0:8q16q24d32d40d48q56d64q72d80d88d96d104d112d120d128d136q144d152d160q168q176q184q192q200Q208"
- "@236@0:8{?=i{?=dd}ddddddddidi{?=dd}diIiiidB}16@172d180@188@196@204d212d220@228"
- "@24@0:8B16B20"
- "@272@0:8{?=i{?=dd}ddddddddidi{?=dd}diIiiidB}16@172d180@188@196@204d212d220d228d236i244d248d256@264"
- "@280@0:8{?=i{?=dd}ddddddddidi{?=dd}diIiiidB}16@172d180@188@196@204d212d220d228d236i244d248d256@264@272"
- "@28@0:8B16B20I24"
- "@44@0:8@16B24q28@36"
- "@44@0:8d16d24d32i40"
- "@48@0:8@16{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>=(__rep={__short=[23c][0C]b7b1}{__long=*Qb63b1})}}24"
- "@60@0:8q16{CLLocationCoordinate2D=dd}24d40i48i52B56"
- "@64@0:8{CLLocationCoordinate2D=dd}16d32d40d48@56"
- "@68@0:8q16{CLLocationCoordinate2D=dd}24d40i48i52B56@60"
- "@68@0:8{CLLocationCoordinate2D=dd}16d32d40d48@56i64"
- "@732@0:8{?=i{?=dd}ddddddddidi{?=dd}diIiiidB}16{?=dddddfffBi{?=dd}diiB{?=ddBBidqddd}{?={?=iddddd{?=dd}dd}iQiiiidB}{?=dd}if{?=dd}ddiBddddddddBB{?=dd}diddddddiddi{?=I}{?=if}B}172"
- "@740@0:8{?=i{?=dd}ddddddddidi{?=dd}diIiiidB}16{?=dddddfffBi{?=dd}diiB{?=ddBBidqddd}{?={?=iddddd{?=dd}dd}iQiiiidB}{?=dd}if{?=dd}ddiBddddddddBB{?=dd}diddddddiddi{?=I}{?=if}B}172@732"
- "@80@0:8{CLLocationCoordinate2D=dd}16d32d40d48d56d64@72"
- "@84@0:8B16B20{?=dd}24d40i48d52d60d68d76"
- "@96@0:8{CLLocationCoordinate2D=dd}16d32d40d48d56d64d72d80@88"
- "Apr 27 2025"
- "CLFloor"
- "CLLocation"
- "CLLocationGnssOdometerInfo"
- "CLLocationInternal"
- "CLLocationManager should not get multile locations with coarseMetaData"
- "CLLocationMatchInfo"
- "CLLocationMatchInfoInternal"
- "CLLocationSourceInformation"
- "CLLocationTrackRunInfo"
- "CLMM,CLTSP,fillFromMapHelperNSDictionaryArray,array is null"
- "CLMM,CLTSP,id,%{private}lld,has less than two coordinate,%{public}d"
- "CLMM,GEOMapFeatureRoad is null"
- "CLMM,GeoMapDataID,less than two coordinates,roadID,%{private}lld"
- "CLMM,GeoMapDataID,null feature"
- "CLMM,GeoMapDataID,unable to make CLRoadID from CLMapRoadPtr,%{private}lld"
- "CLMM,GeoMapDataID,unable to make CLRoadID from GeoMapFeatureAccess,%{private}lld"
- "CLMM,computeSegmentLengthsAndHeading,CoordinateCount is 0"
- "CLMM,getHeadingForSegment,stored bearing value unavailble,had to be calculated,%{private}lld,index,%{public}d"
- "CLMM,invalid heading for CLMapRoad coordinate,%{sensitive}.7lf,%{sensitive}.7lf,prev,%{sensitive}.7lf,%{sensitive}.7lf"
- "CLMapRoadPtr CLGeoMapFeatureAccessGeometryCommon::makeRoadFromGEOMapFeatureRoad(CLDistanceCalc &, GEOMapFeatureRoad * _Nonnull, bool)"
- "CLRS,timeIntervalsThatNeedPopulated,index,%zu,start,%.lf,stop,%.1lf"
- "CLTSP,%{public}.3lf,aStarConstruct,processing time,%{public}.2lf,exceeded max,%{public}.2lf"
- "CLTSP,%{public}.3lf,aStarConstruct,unable to init destinationRouteRoad"
- "CLTSP,%{public}.3lf,aStarConstruct,unable to init startRouteRoad"
- "CLTSP,Analytics,tripID,%{public}s,modeOfTransport,%{public}d,bcCount,%{public}d,tripDuration,%{public}d,tripDistance,%{public}d,reconstructedCount,%{public}d,origPct,%{public}.2lf,liPct,%{public}.2lf,iiPct,%{public}.2lf,miPct,%{public}.2lf,miSegments,%{public}d,astarAttemptCount,%{public}d,miRouteRejectedPct,%{public}.2lf,astarFailPct,%{public}.2lf,astarIterationExceededMaxPct,%{public}.2lf,astarRoadCountExceededMaxPct,%{public}.2lf,astarMaxIterations,%{public}.2lf,astarAvgIterations,%{public}.2lf,astarProcessingTime,%{public}.2lf,mapQueryCount,%{public}d,mapFailPct,%{public}.2lf,maxTimeBetweenEpochs,%{public}.2lf,avgTimeBetweenEpochs,%{public}.2lf,invalidSpeedPct,%{public}.2lf,invalidCoursePct,%{public}.2lf,tripChunksCount,%{public}d,processingTime,%{public}.2lf"
- "CLTSP,MI,%{public}.2lf,constructSegment,dT less that minimum interval,dT,%{public}.2lf"
- "CLTSP,MI,%{public}.3lf,constructing astar route between,startPoint,%{sensitive}.7lf,%{sensitive}.7lf,endPoint,%{sensitive}.7lf,%{sensitive}.7lf,distance,%{public}.3lf,endTime,%{public}.3lf,maxDistance,%{public}.3lf,speed,%{public}.3lf"
- "CLTSP,Recorder,recording data for date,%{public}s,time,%{public}s"
- "CLTSP,Recorder,writeToFile,success,type,%{public}d,length,%{public}d"
- "CLTSP,Unable to find mid-point"
- "CLTSP,filterWiFiFixes,boundingBoxCheck removed,time,%{public}.2lf,LL,%{sensitive}.7lf,%{sensitive}.7lf,hunc,%{public}.3lf,speed,%{public}.3lf,course,%{public}.3lf"
- "CLTSP,filterWiFiFixes,huncCheck removed,time,%{public}.2lf,LL,%{sensitive}.7lf,%{sensitive}.7lf,hunc,%{public}.3lf,speed,%{public}.3lf,course,%{public}.3lf"
- "CLTSP,processData,output,tripSegmentID,%{public}s,modeOfTransport,%{public}d,isFinalPart,%{public}d,sparseLocationsCount,%{public}d,reconstructedLocCount,%{public}d,totalDistance,%{public}.2lf,processingTimeMSec,%{public}.1lf,simulated,%{public}d,date,%{public}s,time,%{public}s"
- "CLTSP,zero tripLocations"
- "CLTripSegmentMapIntegratorSparse"
- "CoarseMetaData"
- "Compass"
- "E"
- "Encoded coarse meta data found"
- "GnssOdometerInfo"
- "LocationsPrivate"
- "N"
- "NE"
- "NSArray * _Nonnull copyLocationsFromLocationMessagePayload(NSDictionary * _Nonnull)"
- "NSValueCoreLocationExtensions"
- "NW"
- "SE"
- "SW"
- "T@\"CLFloor\",R,C,N"
- "T@\"CLLocationGnssOdometerInfo\",R,N"
- "T@\"CLLocationMatchInfo\",R,N"
- "T@\"CLLocationSourceInformation\",R,N"
- "T@\"CLLocationTrackRunInfo\",R,N"
- "T@\"NSData\",R,N"
- "T@\"NSNumber\",R,N,V_trackId"
- "T@\"_CLLocationFusionInfo\",R,N"
- "T@\"_CLLocationGroundAltitude\",R,N"
- "TB,R,N,GisCoordinateFused"
- "TB,R,N,GisCoordinateFused,V_coordinateFused"
- "TB,R,N,GisCoordinateFusedWithVL"
- "TB,R,N,GisCoordinateFusedWithVL,V_coordinateFusedWithVL"
- "TB,R,N,GisMatchShifted"
- "TB,R,N,V_isAltitudeWgs84Available"
- "TB,R,N,VisProducedByAccessory"
- "TB,R,N,VisSimulatedBySoftware"
- "TI,R,N"
- "Td,R,N,V_altitudeWgs84"
- "Td,R,N,V_course"
- "Td,R,N,V_courseAccuracy"
- "Td,R,N,V_deltaDistance"
- "Td,R,N,V_deltaDistanceAccuracy"
- "Td,R,N,V_estimate"
- "Td,R,N,V_uncertainty"
- "Td,R,N,V_uncertaintyWgs84"
- "Td,R,N,V_undulation"
- "Td,R,N,V_verticalAccuracy"
- "Td,R,V_bootR1Time"
- "Td,R,V_dualConnTime"
- "Td,R,V_dualLeashedTime"
- "Td,R,V_lastClear"
- "Td,R,V_leashedTime"
- "Td,R,V_multiLeashedTime"
- "Td,R,V_multiTime"
- "Td,R,V_multiTimeV2"
- "Td,R,V_nearOwnerTime"
- "Td,R,V_nearOwnerTimeV2"
- "Td,R,V_rangingTime"
- "Td,R,V_singleConnTime"
- "Td,R,V_soundTime"
- "Td,R,V_wildTime"
- "Ti,R,N,V_estimatedLaneConfidence"
- "Ti,R,N,V_trackProximity"
- "Ti,R,N,V_undulationModel"
- "Tq,R,N,V_estimatedLaneNumber"
- "Tq,R,N,V_laneCount"
- "Tq,R,N,V_laneNumber"
- "Tq,R,N,Vlevel"
- "Tq,R,V_bomSoundCount"
- "Tq,R,V_crashCount"
- "Tq,R,V_overflowFlag"
- "Tq,R,V_ownerLongSoundCount"
- "Tq,R,V_ownerShortSoundCount"
- "Tq,R,V_rangingCount"
- "Tq,R,V_soundCount"
- "Tq,R,V_utAccelCount"
- "Tq,R,V_utLongSoundCount"
- "Tq,R,V_utShortSoundCount"
- "T{?=dd},R,N,V_coordinate"
- "T{?=iddddd{?=dd}dd},R,N,V_lapInfo"
- "T{?=i{?=dd}ddddddddidi{?=dd}diIiiidB},R,N"
- "T{CLLocationCoordinate2D=dd},R,N"
- "WMM evaluation encountered an error"
- "WMM initialization encountered an error"
- "[CLPedestrianRTSSmoother]:[runRTS] Returned false. Last consumed measurement is not initialized."
- "[CLPedestrianRTSSmoother]:[runRTS] There is no inertialOdometry sample between consecutive location samples. timestamp of coming location sample %{public}.3f, timestamp of consumed location sample %{public}.3f."
- "[CLTrajectorySmootherUtilities] Conversion from lat/lon to NWU failed. location sample, latitude, %.1f, longitude, %.1f, selected origin, latitude, %.1f, longitude, %.1f."
- "[CLTrajectorySmoother]:[runPedestrianTrajectorySmoothing] ratioOfDenseUrbanLocation, %{private}.2f, durationOfSession_inSec, %{public}.2f, shouldRunRANSAC, %{public}d."
- "_CLLocationFusionInfo"
- "_CLLocationGroundAltitude"
- "_altitudeWgs84"
- "_bootR1Time"
- "_callbackDropManager"
- "_clientCallback != nullptr"
- "_connectionMessageHandler"
- "_coordinateFused"
- "_coordinateFusedWithVL"
- "_deltaDistance"
- "_deltaDistanceAccuracy"
- "_dualConnTime"
- "_dualLeashedTime"
- "_estimate"
- "_estimatedLaneConfidence"
- "_estimatedLaneNumber"
- "_fusionInfo"
- "_groundAltitude"
- "_initWithCoordinate:altitude:horizontalAccuracy:verticalAccuracy:course:courseAccuracy:speed:speedAccuracy:timestamp:floor:type:sourceParams:referenceFrame:"
- "_isAltitudeWgs84Available"
- "_laneCount"
- "_laneNumber"
- "_lapInfo"
- "_lastTimestamp"
- "_leashedTime"
- "_multiLeashedTime"
- "_multiTimeV2"
- "_singleConnTime"
- "_trackId"
- "_trackProximity"
- "_uncertainty"
- "_uncertaintyWgs84"
- "_undulation"
- "_undulationModel"
- "_verticalAccuracy"
- "altitudeWgs84"
- "averageAcceleration"
- "bool CLAStarRouteConstructor::construct(CLDistanceCalc &, const CFAbsoluteTime, const CLGeoMapSnapDataPtr, const CLGeoMapSnapDataPtr, std::shared_ptr<CLGeoMapFeatureRoadGeometryBuffer>, const double)"
- "bool CLAStarRouteConstructor::constructPedestrian(CLDistanceCalc &, const CFAbsoluteTime, const CLMapRoadPtr &, const CLMapRoadPtr &, std::shared_ptr<CLGeoMapFeatureRoadGeometryBuffer>, const GEOLocationCoordinate2D &, const double, double, const std::optional<double>)"
- "bool CLMapRoad::computeSegmentDistances()"
- "bool CLMapRoad::computeSegmentHeadings()"
- "bool CLMapRoad::fillFromMapHelperNSDictionaryArray(CLDistanceCalc &, NSDictionary * _Nonnull, bool)"
- "bool CLRouteRoad::initialize(CLDistanceCalc &, const CLMapRoadPtr)"
- "bool CLTrajectorySmoother::runPedestrianTrajectorySmoothing(NSArray<CLTripSegmentLocation *> * _Nonnull, NSArray<CLBackgroundInertialOdometrySample *> * _Nullable, NSMutableArray<CLTripSegmentLocation *> * _Nonnull, double &)"
- "bool CLTripSegmentMapIntegratorSparse::constructSegment(const std::vector<CLGeoMapSnapDataPtr> &, const std::vector<CLGeoMapSnapDataPtr> &, bool, const CLTripSegmentModeOfTransport)"
- "bool CLTripSegmentProcessor::processPedestrianData(CLTripSegmentProcessorOptions * _Nonnull, NSUUID * _Nonnull, const bool, const CLTripSegmentModeOfTransport, NSArray<CLTripSegmentLocation *> * _Nonnull, NSArray<CLBackgroundInertialOdometrySample *> * _Nonnull, NSMutableArray<CLTripSegmentLocation *> * _Nonnull)"
- "bool CLTripSegmentProcessor::processVehicularData(CLTripSegmentProcessorOptions * _Nonnull, NSUUID * _Nonnull, const bool, const CLTripSegmentModeOfTransport, NSArray<CLTripSegmentLocation *> * _Nonnull, NSArray<CLTripSegmentInertialData *> * _Nonnull, NSMutableArray<CLTripSegmentLocation *> * _Nonnull)"
- "bool CLTripSegmentProcessor::runMapIntegrator(CLTripSegmentProcessorOptions * _Nonnull, NSUUID * _Nonnull, const CLTripSegmentModeOfTransport, const bool, NSArray<CLTripSegmentLocation *> * _Nonnull, NSArray<CLTripSegmentLocation *> * _Nonnull, NSMutableArray<CLTripSegmentLocation *> * _Nonnull)"
- "bool CLTripSegmentRouteBuilder::generateRouteCandidatesForOneSegment(const CFAbsoluteTime, std::shared_ptr<CLGeoMapFeatureRoadGeometryBuffer>, const std::vector<CLGeoMapSnapDataPtr> &, const std::vector<CLGeoMapSnapDataPtr> &, const std::vector<CLRouteCandidateVector> &, std::vector<CLRouteCandidatePtr> &, std::vector<CLRouteCandidateVector> &)"
- "bool CLTripSegmentUtilities::CLGPSFixTracker::canUseThisFix(NSArray<CLTripSegmentLocation *> * _Nonnull, int, const double, const double, const double)"
- "bootR1Time"
- "characteristicSpeed"
- "components:fromDate:"
- "components:fromDate:toDate:options:"
- "coordinateFused"
- "coordinateFusedWithVL"
- "coordinateLatitude"
- "coordinateLongitude"
- "could not open geomagnetic data file %s (%{public}s)"
- "currentCalendar"
- "dateFromComponents:"
- "day"
- "deltaDistance"
- "deltaDistanceAccuracy"
- "double CLDistanceCalc::calculateAzimuth(double, double, double, double)"
- "double CLDistanceCalc::calculateDistance(const CLDaemonLocation &, const CLDaemonLocation &)"
- "double CLMapRoad::getHeadingForSegment(const int)"
- "dualConnTime"
- "dualLeashedTime"
- "estimate"
- "estimatedLaneConfidence"
- "estimatedLaneNumber"
- "fCoarseMetaData"
- "fFusionInfo"
- "fGnssOdometerInfo"
- "fGroundAltitude"
- "fMatchCoordinate"
- "fMatchCourse"
- "fMatchDataArray"
- "fMatchFormOfWay"
- "fMatchInfo"
- "fMatchQuality"
- "fMatchRoadClass"
- "fMatchShifted"
- "fPositionContextState"
- "fProbabilityPositionContextStateIndoor"
- "fProbabilityPositionContextStateOutdoor"
- "fRawAltitude"
- "fRawCourseAccuracy"
- "fRawHorizontalAccuracy"
- "fRawVerticalAccuracy"
- "fTrackRunInfo"
- "fTrustedTimestamp"
- "floor"
- "geomagnetic data file appears to be empty"
- "geomagnetic data file appears to have invalid dimensions"
- "geomagnetic model invalid near poles (%f, %f, %f)"
- "gnssOdometerInfo"
- "grossElevationGain"
- "initWithCalendarIdentifier:"
- "initWithClientLocation:clientLocationPrivate:coarseMetaData:"
- "initWithClientLocation:coarseMetaData:"
- "initWithClientLocation:matchInfo:"
- "initWithClientLocation:matchInfo:trustedTimestamp:"
- "initWithClientLocation:matchInfo:trustedTimestamp:groundAltitude:"
- "initWithClientLocation:matchInfo:trustedTimestamp:groundAltitude:fusionInfo:trackRunInfo:rawHorizontalAccuracy:rawAltitude:rawVerticalAccuracy:rawCourseAccuracy:positionContextStateType:probabilityPositionContextStateIndoor:probabilityPositionContextStateOutdoor:gnssOdometerInfo:"
- "initWithClientLocation:matchInfo:trustedTimestamp:groundAltitude:fusionInfo:trackRunInfo:rawHorizontalAccuracy:rawAltitude:rawVerticalAccuracy:rawCourseAccuracy:positionContextStateType:probabilityPositionContextStateIndoor:probabilityPositionContextStateOutdoor:gnssOdometerInfo:coarseMetaData:"
- "initWithClientLocation:matchInfo:trustedTimestamp:groundAltitude:fusionInfo:trackRunInfo:rawHorizontalAccuracy:rawCourseAccuracy:coarseMetaData:"
- "initWithCoordinate:altitude:horizontalAccuracy:verticalAccuracy:course:courseAccuracy:speed:speedAccuracy:timestamp:"
- "initWithCoordinate:altitude:horizontalAccuracy:verticalAccuracy:course:courseAccuracy:speed:speedAccuracy:timestamp:sourceInfo:"
- "initWithCoordinate:altitude:horizontalAccuracy:verticalAccuracy:course:speed:timestamp:"
- "initWithCoordinateFused:coordinateFusedWithVL:coordinate:horizontalAccuracy:referenceFrame:altitude:verticalAccuracy:course:courseAccuracy:"
- "initWithEstimate:uncertainty:"
- "initWithLapInfo:laneNumber:laneCount:trackId:estimatedLaneNumber:estimatedLaneConfidence:trackProximity:"
- "initWithLatitude:longitude:altitude:speed:course:horizontalAccuracy:verticalAccuracy:speedAccuracy:courseAccuracy:type:timestamp:"
- "initWithLevel:"
- "initWithMatchQuality:matchCoordinate:matchCourse:matchFormOfWay:matchRoadClass:matchShifted:"
- "initWithMatchQuality:matchCoordinate:matchCourse:matchFormOfWay:matchRoadClass:matchShifted:matchDataArray:"
- "initWithOdometer:deltaDistance:deltaDistanceAccuracy:"
- "initWithOverflowFlag:crashCount:multiTime:nearOwnerTime:wildTime:soundCount:soundTime:rangingCount:rangingTime:multiLeashedTime:multiTimeV2:nearOwnerTimeV2:leashedTime:singleConnTime:dualConnTime:dualLeashedTime:utAccelCount:lastClear:bootR1Time:ownerLongSoundCount:ownerShortSoundCount:utLongSoundCount:utShortSoundCount:bomSoundCount:version:"
- "initWithSoftwareSimulationState:andExternalAccessoryState:"
- "initWithSupportsFC1ND:supportsNBAMMS:capabilities:"
- "initWithTripSegmentID:isFinalPart:modeOfTransport:tripLocations:"
- "initWithUnsignedLongLong:"
- "instancesRespondToSelector:"
- "int E0000(int, int *, float, float, float, float, float *, float *, float *, float *)"
- "int declinationCalc(const float, const float, const float, const float, GeomagneticData *)"
- "isAltitudeWgs84Available"
- "isCoordinateFused"
- "isCoordinateFusedWithVL"
- "isFromExternalAccessory"
- "isMatchShifted"
- "isProducedByAccessory"
- "isSimulatedBySoftware"
- "isSoftwareSimulated"
- "iso6709Notation"
- "jsonObject"
- "kCLConnectionMessageLocationUpdaterEndDateKey"
- "kCLConnectionMessageLocationUpdaterStartDateKey"
- "kCLLocationCodingKeyAltitude"
- "kCLLocationCodingKeyCoarseMetaData"
- "kCLLocationCodingKeyCoordinateLatitude"
- "kCLLocationCodingKeyCoordinateLongitude"
- "kCLLocationCodingKeyCourse"
- "kCLLocationCodingKeyCourseAccuracy"
- "kCLLocationCodingKeyEllipsoidalAltitude"
- "kCLLocationCodingKeyFloor"
- "kCLLocationCodingKeyFromExternalAccessory"
- "kCLLocationCodingKeyFromSoftwareSimulator"
- "kCLLocationCodingKeyFusionInfo"
- "kCLLocationCodingKeyGnssOdometerInfo"
- "kCLLocationCodingKeyGroundAltitude"
- "kCLLocationCodingKeyGroundAltitudeEstimate"
- "kCLLocationCodingKeyGroundAltitudeUncertainty"
- "kCLLocationCodingKeyGroundAltitudeUndulation"
- "kCLLocationCodingKeyGroundAltitudeUndulationModel"
- "kCLLocationCodingKeyHorizontalAccuracy"
- "kCLLocationCodingKeyIntegrity"
- "kCLLocationCodingKeyLifespan"
- "kCLLocationCodingKeyMatchInfo"
- "kCLLocationCodingKeyPositionContextState"
- "kCLLocationCodingKeyProbabilityPositionContextStateIndoor"
- "kCLLocationCodingKeyProbabilityPositionContextStateOutdoor"
- "kCLLocationCodingKeyRawAltitude"
- "kCLLocationCodingKeyRawCoordinateLatitude"
- "kCLLocationCodingKeyRawCoordinateLongitude"
- "kCLLocationCodingKeyRawCourse"
- "kCLLocationCodingKeyRawCourseAccuracy"
- "kCLLocationCodingKeyRawHorizontalAccuracy"
- "kCLLocationCodingKeyRawReferenceFrame"
- "kCLLocationCodingKeyRawVerticalAccuracy"
- "kCLLocationCodingKeySignalEnvironmentType"
- "kCLLocationCodingKeySimulationParams"
- "kCLLocationCodingKeySpeed"
- "kCLLocationCodingKeySpeedAccuracy"
- "kCLLocationCodingKeyTimestamp"
- "kCLLocationCodingKeyTrackRunInfo"
- "kCLLocationCodingKeyType"
- "kCLLocationCodingKeyVerticalAccuracy"
- "kCLLocationMatchInfoCodingKeyMatchCoordinateLatitude"
- "kCLLocationMatchInfoCodingKeyMatchCoordinateLongitude"
- "kCLLocationMatchInfoCodingKeyMatchCourse"
- "kCLLocationMatchInfoCodingKeyMatchDataArray"
- "kCLLocationMatchInfoCodingKeyMatchFormOfWay"
- "kCLLocationMatchInfoCodingKeyMatchQuality"
- "kCLLocationMatchInfoCodingKeyMatchRoadClass"
- "kCLLocationMatchInfoCodingKeyMatchShifted"
- "kineticEnergyCycling"
- "laneNumber"
- "lapInfo"
- "leashedTime"
- "level"
- "lifespan"
- "magneticDeclination"
- "magneticHeading %.2f trueHeading %.2f accuracy %.2f x %+.3f y %+.3f z %+.3f @ %@"
- "matchCoordinate"
- "matchCourse"
- "matchDataArray"
- "matchFormOfWay"
- "matchInfo"
- "matchQuality"
- "matchQuality %ld matchCoordinate <%+.8f,%+.8f> matchCourse %.2f matchFormOfWay %d matchRoadClass %d matchShifted %d"
- "matchRoadClass"
- "matchShifted"
- "maxAcceleration"
- "multiLeashedTime"
- "multiTimeV2"
- "netElevationGain"
- "positionContextState"
- "probabilityPositionContextStateIndoor"
- "probabilityPositionContextStateOutdoor"
- "processTripSegmentData:outputHandler:completionHandler:"
- "propagateLocationToTime:"
- "r"
- "rawAltitude"
- "rawCoordinate"
- "rawCourse"
- "rawCourseAccuracy"
- "rawHorizontalAccuracy"
- "rawVerticalAccuracy"
- "setDay:"
- "setMonth:"
- "singleConnTime"
- "snapToResolution:"
- "sourceInformation"
- "stageTADetection:deviceType:detailsBitmask:"
- "static uint64_t CLGeoMapFeatureAccessGeometryCommon::CLGeoMapDataID::getRoadID(const CLMapRoadPtr &)"
- "static uint64_t CLGeoMapFeatureAccessGeometryCommon::CLGeoMapDataID::getRoadID(const GEOMapFeatureRoad * _Nonnull)"
- "suitability"
- "supplied date (%{public}f) outside valid range (epoch=%{public}f)"
- "trackId"
- "trackProximity"
- "trackRunCurrentLapDistanceInMeters"
- "trackRunCurrentLapDurationInSeconds"
- "trackRunCurrentLapStartTime"
- "trackRunCurrentTrackRunSessionDistanceInMeters"
- "trackRunCurrentTrackRunSessionDurationInSeconds"
- "trackRunEstimatedLaneConfidence"
- "trackRunEstimatedLaneNumber"
- "trackRunInfo"
- "trackRunLaneCount"
- "trackRunLaneNumber"
- "trackRunLapCount"
- "trackRunPreviousLapDistanceInMeters"
- "trackRunPreviousLapDurationInSeconds"
- "trackRunPreviousLapPositionAtCompletionInDegreesLatitude"
- "trackRunPreviousLapPositionAtCompletionInDegreesLongitude"
- "trackRunTrackId"
- "trackRunTrackProximity"
- "uncertainty"
- "uncertaintyWgs84"
- "undulation"
- "undulationModel"
- "v40@0:8@16@?24@?32"
- "valueWithCLLocationCoordinate2D:"
- "void CLAStarRouteConstructor::constructRouteCandidates(std::shared_ptr<CLGeoMapFeatureRoadGeometryBuffer>, const std::vector<CLGeoMapSnapDataPtr> &, const std::vector<CLGeoMapSnapDataPtr> &, std::vector<CLRouteCandidatePtr> &)"
- "void CLOSTransactionWrapper::Create()"
- "void CLTripSegmentAnalyticsSimulatedTripSegment::comparseAndSubmitCoreAnalytics(NSUUID * _Nonnull, NSUUID * _Nonnull, const int, NSArray<CLTripSegmentLocation *> * _Nonnull, CLTripSegmentOutputData * _Nonnull, const double)"
- "void getGeoMapGeometrySettingsForRouteReconstruction(CLTripSegmentProcessorOptions * _Nonnull, CLGeoMapFeatureGeometrySettings &, const CLTripSegmentModeOfTransport)"
- "year"
- "{\"msg%{public}.0s\":\"#fullAccuracySession Default handler received message\", \"identityToken\":%{public, location:escape_only}s, \"self\":\"%{public}p\"}"
- "{\"msg%{public}.0s\":\"#locationUpdater Default handler received message\", \"identityToken\":%{public, location:escape_only}s, \"self\":\"%{public}p\"}"
- "{\"msg%{public}.0s\":\"#locationUpdater client callback handler should not be nil when attempting to -resume\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"#locationUpdater connection created\", \"identityToken\":%{public, location:escape_only}@, \"self\":\"%{public}p\"}"
- "{\"msg%{public}.0s\":\"#locationUpdater destroyUponDisconnection(DIC)\", \"identityToken\":%{public, location:escape_only}s, \"self\":\"%{public}p\"}"
- "{\"msg%{public}.0s\":\"#locationUpdater destroying connection\", \"identityToken\":%{public, location:escape_only}s, \"self\":\"%{public}p\"}"
- "{\"msg%{public}.0s\":\"#locationUpdater pause is called\", \"self\":\"%{public}p\"}"
- "{\"msg%{public}.0s\":\"#locationUpdater resume is called\", \"self\":\"%{public}p\"}"
- "{\"msg%{public}.0s\":\"#serviceSession Default handler received message\", \"identityToken\":%{public, location:escape_only}s, \"self\":\"%{public}p\"}"
- "{\"msg%{public}.0s\":\"-initWithMachServiceName:options: is declared to return nonnull but failed to return an object\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{?=\"lapCount\"i\"currentLapStartTime\"d\"currentLapDurationInSeconds\"d\"currentLapDistanceInMeters\"d\"previousLapDurationInSeconds\"d\"previousLapDistanceInMeters\"d\"previousLapPositionAtCompletionInDegrees\"{?=\"latitude\"d\"longitude\"d}\"currentTrackRunSessionDurationInSeconds\"d\"currentTrackRunSessionDistanceInMeters\"d}"
- "{?=\"latitude\"d\"longitude\"d}"
- "{?=\"x\"d\"y\"d\"z\"d\"magneticHeading\"d\"trueHeading\"d\"accuracy\"d\"timestamp\"d\"temperature\"d\"magnitude\"d\"inclination\"d\"calibration\"i}"
- "{?=dd}16@0:8"
- "{?=iddddd{?=dd}dd}16@0:8"
- "{?=i{?=dd}ddddddddidi{?=dd}diIiiidB}16@0:8"
- "{CLCallbackDropManager=\"_vptr$CLCallbackDropManager\"^^?\"fToken\"{shared_ptr<int>=\"__ptr_\"^i\"__cntrl_\"^{__shared_weak_count}}}"
- "{CLLocationCoordinate2D=dd}"
- "{CLRacingRoute=\"fDistanceCalculator\"{CLDistanceCalc=\"fM\"d\"fN\"d\"fRefLatRads\"d\"fRefLatDegs\"d\"fCosRefLat\"d}\"fSignalEnvironmentType\"i\"fWorkoutActivity\"i\"fRoutePoints\"@\"NSMutableArray\"\"fRouteBoundingBox\"{RouteBoundingBox=\"fMinLatitude_deg\"d\"fMaxLatitude_deg\"d\"fMinLongitude_deg\"d\"fMaxLongitude_deg\"d\"fRows\"i\"fColumns\"i}\"fRouteMatrixIndexVec\"{vector<std::vector<std::pair<int, int>>, std::allocator<std::vector<std::pair<int, int>>>>=\"__begin_\"^v\"__end_\"^v\"__end_cap_\"{__compressed_pair<std::vector<std::pair<int, int>> *, std::allocator<std::vector<std::pair<int, int>>>>=\"__value_\"^v}}\"fRaceStartPointOnCurrentRoute\"{RacingRouteState=\"fLatitude_deg\"d\"fLongitude_deg\"d\"fAltitude_m\"d\"fOdometer_m\"d\"fTimestamp_s\"d\"fTimeSinceStartOfRace_s\"d\"fOffRouteTraveledTime_s\"d\"fDistanceSinceStartOfRace_m\"d\"fOffRouteTraveledDistance_m\"d\"fAveragePace_s_per_m\"d\"fDistanceAlongReferenceRoute_m\"d}\"fRaceStartPointOnReferenceRoute\"{RacingRouteState=\"fLatitude_deg\"d\"fLongitude_deg\"d\"fAltitude_m\"d\"fOdometer_m\"d\"fTimestamp_s\"d\"fTimeSinceStartOfRace_s\"d\"fOffRouteTraveledTime_s\"d\"fDistanceSinceStartOfRace_m\"d\"fOffRouteTraveledDistance_m\"d\"fAveragePace_s_per_m\"d\"fDistanceAlongReferenceRoute_m\"d}\"fLastOnRouteDataPoint\"{RacingRouteState=\"fLatitude_deg\"d\"fLongitude_deg\"d\"fAltitude_m\"d\"fOdometer_m\"d\"fTimestamp_s\"d\"fTimeSinceStartOfRace_s\"d\"fOffRouteTraveledTime_s\"d\"fDistanceSinceStartOfRace_m\"d\"fOffRouteTraveledDistance_m\"d\"fAveragePace_s_per_m\"d\"fDistanceAlongReferenceRoute_m\"d}\"fLastProjectedDataPoint\"{RacingRouteState=\"fLatitude_deg\"d\"fLongitude_deg\"d\"fAltitude_m\"d\"fOdometer_m\"d\"fTimestamp_s\"d\"fTimeSinceStartOfRace_s\"d\"fOffRouteTraveledTime_s\"d\"fDistanceSinceStartOfRace_m\"d\"fOffRouteTraveledDistance_m\"d\"fAveragePace_s_per_m\"d\"fDistanceAlongReferenceRoute_m\"d}\"fRoutePointsArrayInitialized\"B\"fRecoveryMode\"B\"fRaceStartPointDetected\"B\"fRaceEndPointDetected\"B\"fUserIsOffRoute\"B\"fProjectedOnNearestPoint\"B\"fRaceSessionExpired\"B\"fRollingBufferReachedEndOfReferenceRoute\"B\"fRouteConfigurationSuccessful\"B\"fRacingRouteAnalyticsSent\"B\"fPrematureRaceEndDetected\"B\"fReferenceRouteTotalLengthDetermined\"B\"fLocationPointIsOutsideOfAcceptedRange\"B\"fLocationPointNotMatched\"B\"fRoutePointsBufferSize\"i\"fNumberOfRoutePointsToAdd\"i\"fOffRouteGraceDuration_s\"i\"fMatchedPointCounter\"i\"fReferenceRouteDataPointCounter\"i\"fCurrentRouteDataPointCounter\"i\"fOffRouteDataPointCounter\"i\"fInutileDataPointCounter\"i\"fRollingBufferUpdateCounter\"i\"fLastMatchedPointIndex\"i\"fLastMatchedPointIndexOnReferenceRoute\"i\"fRollingBufferStartIndexOnReferenceRoute\"i\"fMatrixCellIndexForLastMatchedPoint\"i\"fRaceStartLineProximityIndex\"i\"fReferenceRouteTotalLength_m\"d\"fTimestampOfLastMatchedPointOnReferenceRoute_s\"d\"fRegisteredTimeAtThresholdDistance_s\"d\"fEndOfRaceTimeThreshold_s\"d\"fNearestNeighborMaximumAcceptedDistance_m\"d}"
- "{CLTripSegmentProcessor=\"fDistanceCalculator\"{CLDistanceCalc=\"fM\"d\"fN\"d\"fRefLatRads\"d\"fRefLatDegs\"d\"fCosRefLat\"d}\"fOSTransaction\"{CLOSTransactionWrapper=\"inMemoryTransaction_\"@\"CLOSTransaction\"\"name_\"{basic_string<char, std::char_traits<char>, std::allocator<char>>=\"__r_\"{__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>=\"__value_\"(__rep=\"__s\"{__short=\"__data_\"[23c]\"__padding_\"[0C]\"__size_\"b7\"__is_long_\"b1}\"__l\"{__long=\"__data_\"*\"__size_\"Q\"__cap_\"b63\"__is_long_\"b1})}}}\"fRecorder\"{CLTripSegmentRecorder=\"fRecordingEnabled\"B\"fFileNameShouldContainTime\"B\"fRecordingDirectory\"@\"NSString\"}\"fRouteBuilder\"{shared_ptr<CLTripSegmentRouteBuilder>=\"__ptr_\"^{CLTripSegmentRouteBuilder}\"__cntrl_\"^{__shared_weak_count}}}"
- "{unique_ptr<CLConnectionClient, std::default_delete<CLConnectionClient>>=\"__ptr_\"{__compressed_pair<CLConnectionClient *, std::default_delete<CLConnectionClient>>=\"__value_\"^{CLConnectionClient}}}"
- "{unique_ptr<CLGNSSStateQueryAssertionResponseInternal, std::default_delete<CLGNSSStateQueryAssertionResponseInternal>>=\"__ptr_\"{__compressed_pair<CLGNSSStateQueryAssertionResponseInternal *, std::default_delete<CLGNSSStateQueryAssertionResponseInternal>>=\"__value_\"^{CLGNSSStateQueryAssertionResponseInternal}}}"
- "{unique_ptr<CLGnssDisablementAssertionInternal, std::default_delete<CLGnssDisablementAssertionInternal>>=\"__ptr_\"{__compressed_pair<CLGnssDisablementAssertionInternal *, std::default_delete<CLGnssDisablementAssertionInternal>>=\"__value_\"^{CLGnssDisablementAssertionInternal}}}"
- "{unique_ptr<CLRegulatoryConfigInternal, std::default_delete<CLRegulatoryConfigInternal>>=\"__ptr_\"{__compressed_pair<CLRegulatoryConfigInternal *, std::default_delete<CLRegulatoryConfigInternal>>=\"__value_\"^{CLRegulatoryConfigInternal}}}"
- "\xe1"

```
