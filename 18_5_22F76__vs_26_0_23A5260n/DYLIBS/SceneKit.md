## SceneKit

> `/System/Library/Frameworks/SceneKit.framework/SceneKit`

```diff

-603.500.0.0.0
-  __TEXT.__text: 0x36bd8c
+607.0.0.0.0
+  __TEXT.__text: 0x36c030
   __TEXT.__auth_stubs: 0x2f00
-  __TEXT.__objc_methlist: 0x177d4
-  __TEXT.__const: 0x26268
-  __TEXT.__oslogstring: 0x164d6
-  __TEXT.__cstring: 0x97903
-  __TEXT.__gcc_except_tab: 0x43f4
+  __TEXT.__objc_methlist: 0x1791c
+  __TEXT.__const: 0x262a8
+  __TEXT.__oslogstring: 0x16656
+  __TEXT.__cstring: 0x97905
+  __TEXT.__gcc_except_tab: 0x42f8
   __TEXT.__dlopen_cstrs: 0x45
   __TEXT.__ustring: 0x2e
-  __TEXT.__unwind_info: 0xaed0
-  __TEXT.__objc_classname: 0x1cd5
-  __TEXT.__objc_methname: 0x24503
-  __TEXT.__objc_methtype: 0x12555
-  __TEXT.__objc_stubs: 0x1d4c0
-  __DATA_CONST.__got: 0xbd8
-  __DATA_CONST.__const: 0x7ad8
-  __DATA_CONST.__objc_classlist: 0x6d8
+  __TEXT.__unwind_info: 0xaf30
+  __TEXT.__objc_classname: 0x1d04
+  __TEXT.__objc_methname: 0x248af
+  __TEXT.__objc_methtype: 0x121c5
+  __TEXT.__objc_stubs: 0x1d5e0
+  __DATA_CONST.__got: 0xbf0
+  __DATA_CONST.__const: 0x7b38
+  __DATA_CONST.__objc_classlist: 0x6e0
   __DATA_CONST.__objc_catlist: 0xa0
   __DATA_CONST.__objc_protolist: 0x338
   __DATA_CONST.__objc_imageinfo: 0x8
-  __DATA_CONST.__objc_selrefs: 0x9650
-  __DATA_CONST.__objc_protorefs: 0x220
-  __DATA_CONST.__objc_superrefs: 0x5f8
+  __DATA_CONST.__objc_selrefs: 0x9748
+  __DATA_CONST.__objc_protorefs: 0x228
+  __DATA_CONST.__objc_superrefs: 0x600
   __DATA_CONST.__objc_arraydata: 0x270
   __AUTH_CONST.__auth_got: 0x1798
   __AUTH_CONST.__const: 0x9410
-  __AUTH_CONST.__cfstring: 0x20c40
-  __AUTH_CONST.__objc_const: 0x23228
+  __AUTH_CONST.__cfstring: 0x20d20
+  __AUTH_CONST.__objc_const: 0x23410
   __AUTH_CONST.__objc_intobj: 0x558
   __AUTH_CONST.__objc_arrayobj: 0xa8
   __AUTH_CONST.__objc_doubleobj: 0x20
   __AUTH_CONST.__objc_dictobj: 0xf0
   __AUTH_CONST.__objc_floatobj: 0x10
-  __AUTH.__objc_data: 0x4240
+  __AUTH.__objc_data: 0x4290
   __AUTH.__data: 0x4d90
-  __DATA.__objc_ivar: 0x1c90
+  __DATA.__objc_ivar: 0x1c94
   __DATA.__data: 0x293c
-  __DATA.__bss: 0x2ed8
+  __DATA.__bss: 0x2eb8
   __DATA.__common: 0x1d1
   __DATA_DIRTY.__objc_data: 0x230
   - /System/Library/Frameworks/AVFAudio.framework/AVFAudio

   - /usr/lib/libobjc.A.dylib
   - /usr/lib/libxml2.2.dylib
   - /usr/lib/libz.1.dylib
-  UUID: 2C60462F-FD86-3BBD-8685-2745B25AD5F3
-  Functions: 19107
-  Symbols:   57078
-  CStrings:  20331
+  UUID: 36391F16-50F3-33B5-8160-BD01A11106DF
+  Functions: 19163
+  Symbols:   56925
+  CStrings:  20403
 
Symbols:
+ -[SCNCommonProfileProgramGeneratorMetal splitInputOutputStructsIfNeededForSourceCode:generatedFromReplacementStrings:perPixelLighting:clipDistanceCount:hasBezierCurveDeformer:]
+ -[SCNKeyedArchiver encodeValueOfObjCType:at:]
+ -[SCNKeyedUnarchiver decodeValueOfObjCType:at:]
+ -[SCNMTLRenderContext beginFrame:].cold.1
+ -[SCNMTLRenderContext beginFrame:].cold.2
+ -[SCNMaterialProperty _customEncodingOfSCNMaterialProperty:].cold.1
+ -[SCNMaterialProperty _customEncodingOfSCNMaterialProperty:].cold.2
+ -[_SCNCoderMaterialPropertyTextureProviderHelper cachedTextureWithURL:token:]
+ -[_SCNCoderMaterialPropertyTextureProviderHelper cachedTextureWithURL:token:didFallbackToDefaultTexture:]
+ -[_SCNCoderMaterialPropertyTextureProviderHelper dealloc]
+ -[_SCNCoderMaterialPropertyTextureProviderHelper initWithDevice:]
+ GCC_except_table103
+ GCC_except_table107
+ GCC_except_table111
+ GCC_except_table112
+ GCC_except_table122
+ GCC_except_table137
+ GCC_except_table146
+ GCC_except_table150
+ GCC_except_table157
+ GCC_except_table174
+ GCC_except_table195
+ GCC_except_table196
+ GCC_except_table199
+ GCC_except_table201
+ GCC_except_table264
+ GCC_except_table268
+ GCC_except_table41
+ GCC_except_table60
+ GCC_except_table67
+ GCC_except_table84
+ GCC_except_table96
+ GCC_except_table98
+ _C3DDeformerStackAreDeformedNodesCompatibleWithInstancing
+ _C3DGeometryOpenSubdivGPUUpdateAuthoringEnvironmentData.cold.2
+ _C3DNodeGetPresentationMeshLegacy
+ _CGImageDestinationCreateWithData
+ _OBJC_CLASS_$_MTLCommandBufferDescriptor
+ _OBJC_CLASS_$__SCNCoderMaterialPropertyTextureProviderHelper
+ _OBJC_IVAR_$_SCNMTLMorphDeformer._runtimeMorphTargetCount
+ _OBJC_IVAR_$_SCNMTLMorphDeformer._runtimeMorphTargets
+ _OBJC_IVAR_$__SCNCoderMaterialPropertyTextureProviderHelper._engineContext
+ _OBJC_METACLASS_$__SCNCoderMaterialPropertyTextureProviderHelper
+ _SCNEncodeC3DImageForKey
+ _SCNEncodeImageArrayForKey
+ _SCNEncodeImageContentsForKey
+ _SCNEncodeImageFromMaterialPropertyTextureProviderForKey
+ _UTTypeHEIC
+ __C3DNodeGetMeshToRenderLegacy
+ __OBJC_$_INSTANCE_METHODS__SCNCoderMaterialPropertyTextureProviderHelper
+ __OBJC_$_INSTANCE_VARIABLES__SCNCoderMaterialPropertyTextureProviderHelper
+ __OBJC_$_PROP_LIST__SCNCoderMaterialPropertyTextureProviderHelper
+ __OBJC_CLASS_PROTOCOLS_$__SCNCoderMaterialPropertyTextureProviderHelper
+ __OBJC_CLASS_RO_$__SCNCoderMaterialPropertyTextureProviderHelper
+ __OBJC_METACLASS_RO_$__SCNCoderMaterialPropertyTextureProviderHelper
+ __OBJC_PROTOCOL_REFERENCE_$_NSCoding
+ __ZN10OpenSubdiv6v3_1_13Far12GregoryBasis5PointC1Ei
+ __ZN20btConvexHullInternal14getCoordinatesEPKNS_6VertexE
+ __ZN22btC3DRayResultCallbackD2Ev
+ __ZN27C3DSubdivGPUFVarPrimvarDataD2Ev
+ __ZN29C3DSubdivGPUPrimvarDescriptorD2Ev
+ __ZN9btHashMapI9btHashInt14btTriangleInfoED2Ev
+ __ZNKSt3__111__copy_implclB8nn200100INS_14__bit_iteratorINS_6vectorIbNS_9allocatorIbEEEELb0ELm0EEES7_S7_EENS_4pairIT_T1_EES9_T0_SA_
+ __ZNKSt3__14lessINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEclB8nn200100ERKS6_S9_
+ __ZNSt3__110unique_ptrINS_11__tree_nodeINS_12__value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_6vectorIP19CAKeyframeAnimationNS6_ISB_EEEEEEPvEENS_22__tree_node_destructorINS6_ISG_EEEEED1B8nn200100Ev
+ __ZNSt3__110unique_ptrINS_11__tree_nodeINS_12__value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_6vectorIS8_NS6_IS8_EEEEEEPvEENS_22__tree_node_destructorINS6_ISE_EEEEED1B8nn200100Ev
+ __ZNSt3__110unique_ptrINS_11__tree_nodeINS_12__value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES8_EEPvEENS_22__tree_node_destructorINS6_ISB_EEEEED1B8nn200100Ev
+ __ZNSt3__111__introsortINS_17_ClassicAlgPolicyERNS_7greaterIiEEPiLb1EEEvT1_S6_T0_NS_15iterator_traitsIS6_E15difference_typeEb
+ __ZNSt3__111__sift_downB8nn200100INS_17_ClassicAlgPolicyER12__VolumeCompPsEEvT1_OT0_NS_15iterator_traitsIS5_E15difference_typeES5_
+ __ZNSt3__111__sift_downB8nn200100INS_17_ClassicAlgPolicyER13__SphereZCompPsEEvT1_OT0_NS_15iterator_traitsIS5_E15difference_typeES5_
+ __ZNSt3__111__sift_downB8nn200100INS_17_ClassicAlgPolicyER18CompareCornerAngleP13ClippedCornerEEvT1_OT0_NS_15iterator_traitsIS6_E15difference_typeES6_
+ __ZNSt3__111__sift_downB8nn200100INS_17_ClassicAlgPolicyERNS_6__lessIvvEEPP9__C3DNodeEEvT1_OT0_NS_15iterator_traitsIS8_E15difference_typeES8_
+ __ZNSt3__111__sift_downB8nn200100INS_17_ClassicAlgPolicyERNS_7greaterIiEEPiEEvT1_OT0_NS_15iterator_traitsIS6_E15difference_typeES6_
+ __ZNSt3__111__sift_downB8nn200100INS_17_ClassicAlgPolicyERPFbRK9HitResultS4_EPS2_EEvT1_OT0_NS_15iterator_traitsIS9_E15difference_typeES9_
+ __ZNSt3__112__destroy_atB8nn200100INS_4pairIKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_6vectorIP19CAKeyframeAnimationNS5_ISB_EEEEEELi0EEEvPT_
+ __ZNSt3__112__destroy_atB8nn200100INS_4pairIKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_6vectorIS7_NS5_IS7_EEEEEELi0EEEvPT_
+ __ZNSt3__112__destroy_atB8nn200100INS_4pairIKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7_EELi0EEEvPT_
+ __ZNSt3__112__rotate_gcdB8nn200100INS_17_ClassicAlgPolicyEPN3C3D16PassIODescriptorEEET0_S5_S5_S5_
+ __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE20__throw_out_of_rangeB8nn200100Ev
+ __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6resizeEmc
+ __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1B8nn200100ILi0EEEPKc
+ __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC2B8nn200100ENS_24__uninitialized_size_tagEmRKS4_
+ __ZNSt3__113__fill_n_boolB8nn200100ILb0ENS_6vectorIbNS_9allocatorIbEEEEEEvNS_14__bit_iteratorIT0_Lb0EXLi0EEEENS_29__size_difference_type_traitsIS6_vE9size_typeE
+ __ZNSt3__113__fill_n_boolB8nn200100ILb1ENS_6vectorIbNS_9allocatorIbEEEEEEvNS_14__bit_iteratorIT0_Lb0EXLi0EEEENS_29__size_difference_type_traitsIS6_vE9size_typeE
+ __ZNSt3__113__tree_removeB8nn200100IPNS_16__tree_node_baseIPvEEEEvT_S5_
+ __ZNSt3__113unordered_mapIi25SCNPerformanceDataMappingNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEED1B8nn200100Ev
+ __ZNSt3__114__copy_alignedB8nn200100INS_6vectorIbNS_9allocatorIbEEEELb1EEENS_14__bit_iteratorIT_Lb0EXLi0EEEENS5_IS6_XT0_EXLi0EEEES8_S7_
+ __ZNSt3__114__split_bufferI11MaterialMapRNS_9allocatorIS1_EEE17__destruct_at_endB8nn200100EPS1_
+ __ZNSt3__114__split_bufferI23C3DSubdivCPUPrimvarDataIDv2_fERNS_9allocatorIS3_EEE5clearB8nn200100Ev
+ __ZNSt3__114__split_bufferI23C3DSubdivCPUPrimvarDataIDv3_fERNS_9allocatorIS3_EEE5clearB8nn200100Ev
+ __ZNSt3__114__split_bufferI23C3DSubdivCPUPrimvarDataIDv4_fERNS_9allocatorIS3_EEE5clearB8nn200100Ev
+ __ZNSt3__114__split_bufferI27C3DSubdivCPUFVarPrimvarInfoRNS_9allocatorIS1_EEE17__destruct_at_endB8nn200100EPS1_
+ __ZNSt3__114__split_bufferI27C3DSubdivGPUFVarPrimvarDataRNS_9allocatorIS1_EEE5clearB8nn200100Ev
+ __ZNSt3__114__split_bufferI28C3DSubdivCPUPrimvarDataGroupRNS_9allocatorIS1_EEE5clearB8nn200100Ev
+ __ZNSt3__114__split_bufferI8VariableRNS_9allocatorIS1_EEE5clearB8nn200100Ev
+ __ZNSt3__114__split_bufferIN10OpenSubdiv6v3_1_13Far10PatchTable16FVarPatchChannelERNS_9allocatorIS5_EEE5clearB8nn200100Ev
+ __ZNSt3__114__split_bufferINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS4_IS6_EEE17__destruct_at_endB8nn200100EPS6_
+ __ZNSt3__114__split_bufferINS_6vectorIN10OpenSubdiv6v3_1_13Osd10PatchArrayENS_9allocatorIS5_EEEERNS6_IS8_EEE17__destruct_at_endB8nn200100EPS8_
+ __ZNSt3__114__split_bufferINS_6vectorIN10OpenSubdiv6v3_1_13Osd10PatchParamENS_9allocatorIS5_EEEERNS6_IS8_EEE17__destruct_at_endB8nn200100EPS8_
+ __ZNSt3__114__split_bufferINS_6vectorIfNS_9allocatorIfEEEERNS2_IS4_EEE17__destruct_at_endB8nn200100EPS4_
+ __ZNSt3__114__split_bufferINS_6vectorIiNS_9allocatorIiEEEERNS2_IS4_EEE17__destruct_at_endB8nn200100EPS4_
+ __ZNSt3__114__split_bufferIPiNS_9allocatorIS1_EEE12emplace_backIJRS1_EEEvDpOT_
+ __ZNSt3__114__split_bufferIPiNS_9allocatorIS1_EEE12emplace_backIJS1_EEEvDpOT_
+ __ZNSt3__114__split_bufferIPiNS_9allocatorIS1_EEE13emplace_frontIJS1_EEEvDpOT_
+ __ZNSt3__114__split_bufferIPiRNS_9allocatorIS1_EEE12emplace_backIJS1_EEEvDpOT_
+ __ZNSt3__114__split_bufferIPiRNS_9allocatorIS1_EEE13emplace_frontIJRS1_EEEvDpOT_
+ __ZNSt3__115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEE15__init_buf_ptrsB8nn200100Ev
+ __ZNSt3__115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEEC2B8nn200100Ej
+ __ZNSt3__116__insertion_sortB8nn200100INS_17_ClassicAlgPolicyER12__VolumeCompPsEEvT1_S5_T0_
+ __ZNSt3__116__insertion_sortB8nn200100INS_17_ClassicAlgPolicyER13__SphereZCompPsEEvT1_S5_T0_
+ __ZNSt3__116__insertion_sortB8nn200100INS_17_ClassicAlgPolicyER18CompareCornerAngleP13ClippedCornerEEvT1_S6_T0_
+ __ZNSt3__116__insertion_sortB8nn200100INS_17_ClassicAlgPolicyERPFbRK9HitResultS4_EPS2_EEvT1_S9_T0_
+ __ZNSt3__116__pad_and_outputB8nn200100IcNS_11char_traitsIcEEEENS_19ostreambuf_iteratorIT_T0_EES6_PKS4_S8_S8_RNS_8ios_baseES4_
+ __ZNSt3__116allocator_traitsINS_9allocatorI23C3DSubdivCPUPrimvarDataIDv2_fEEEE7destroyB8nn200100IS4_Li0EEEvRS5_PT_
+ __ZNSt3__116allocator_traitsINS_9allocatorI23C3DSubdivCPUPrimvarDataIDv3_fEEEE7destroyB8nn200100IS4_Li0EEEvRS5_PT_
+ __ZNSt3__116allocator_traitsINS_9allocatorI23C3DSubdivCPUPrimvarDataIDv4_fEEEE7destroyB8nn200100IS4_Li0EEEvRS5_PT_
+ __ZNSt3__116allocator_traitsINS_9allocatorI28C3DSubdivCPUPrimvarDataGroupEEE7destroyB8nn200100IS2_Li0EEEvRS3_PT_
+ __ZNSt3__116allocator_traitsINS_9allocatorI8VariableEEE7destroyB8nn200100IS2_Li0EEEvRS3_PT_
+ __ZNSt3__118__bitset_partitionB8nn200100INS_17_ClassicAlgPolicyEPiRNS_7greaterIiEEEENS_4pairIT0_bEES7_S7_T1_
+ __ZNSt3__118basic_stringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEC1B8nn200100Ev
+ __ZNSt3__118basic_stringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI10SCNVector3EEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI10simd_quatfEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI11MaterialMapEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI13ClippedCornerEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI13simd_float4x4EEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI14simd_double4x4EEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI16C3DSubdivCPUDataIDv2_fEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS8_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI16C3DSubdivCPUDataIDv3_fEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS8_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI16C3DSubdivCPUDataIDv4_fEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS8_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI18SCNSemanticBindingEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI19C3DTransformIndexesEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI19SCNPassInputBindingEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI23C3DSubdivCPUPrimvarDataIDv2_fEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS8_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI23C3DSubdivCPUPrimvarDataIDv3_fEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS8_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI23C3DSubdivCPUPrimvarDataIDv4_fEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS8_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI23C3DSubdivCPUPrimvarInfoEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI23C3DSubdivGPUPrimvarInfoEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI27C3DSubdivCPUFVarPrimvarInfoEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI27C3DSubdivGPUFVarPrimvarDataEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI27C3DSubdivisionOsdGPURefinerEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI28C3DSubdivCPUPrimvarDataGroupEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI30C3DSubdivisionOsdGPUPatchTableEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI31C3DSubdivMeshSourceIndexingInfoEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI34C3DSubdivCPUMeshCreationSourceInfoEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI4PairEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI5TokenEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI7CFRangeEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI8TriangleEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI8VariableEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorI9C3DColor4EEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIDv2_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIN10OpenSubdiv6v3_1_13Far10PatchParamEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS9_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIN10OpenSubdiv6v3_1_13Far10PatchTable10PatchArrayEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSA_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIN10OpenSubdiv6v3_1_13Far10PatchTable16FVarPatchChannelEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSA_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIN10OpenSubdiv6v3_1_13Far13TopologyLevelEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS9_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIN10OpenSubdiv6v3_1_13Far17PatchTableFactory14BuilderContext10PatchTupleEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIN10OpenSubdiv6v3_1_13Osd10PatchArrayEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS9_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIN10OpenSubdiv6v3_1_13Osd10PatchParamEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS9_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIN10OpenSubdiv6v3_1_13Osd15EvaluatorCacheTINS4_19MTLComputeEvaluatorEE5EntryEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSC_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIN10OpenSubdiv6v3_1_13Vtr8internal5Level4VTagEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIN10OpenSubdiv6v3_1_13Vtr8internal9FVarLevel13CreaseEndPairEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIN16SCNMTLBufferPool6BufferEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIN17SCNMTLTexturePool13CachedTextureEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIN5vmesh15SubdivisionInfoEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIN5vmesh8TriangleEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIN9AnimCodec17ArithmeticContextEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIN9AnimCodec7Vector3IfEEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS8_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorINS_12basic_stringIcNS_11char_traitsIcEENS1_IcEEEEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSA_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorINS_4pairIP7SCNNodeP8SkeletonEEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorINS_4pairIP9__C3DMeshP16__C3DMeshElementEEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorINS_6vectorI7CFRangeNS1_IS3_EEEEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS9_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorINS_6vectorIN10OpenSubdiv6v3_1_13Osd10PatchArrayENS1_IS6_EEEEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSC_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorINS_6vectorIN10OpenSubdiv6v3_1_13Osd10PatchParamENS1_IS6_EEEEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSC_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorINS_6vectorINS2_I7CFRangeNS1_IS3_EEEENS1_IS5_EEEEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorINS_6vectorIfNS1_IfEEEEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS8_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorINS_6vectorIiNS1_IiEEEEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS8_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIP10BlendShapeEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIP10SCNCActionEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIP11MaterialMapEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIP13TextureLookupEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIP15c3dPhysicsFieldEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIP19CAKeyframeAnimationEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIP21WireframeMeshInstanceEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIP4SkinEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIP7SCNNodeEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIP7UITouchEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIP8SkeletonEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIP9StatementEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIPKN10OpenSubdiv6v3_1_13Far12StencilTableEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIPN10OpenSubdiv6v3_1_13Vtr8internal10RefinementEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIPN10OpenSubdiv6v3_1_13Vtr8internal14FVarRefinementEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIPN10OpenSubdiv6v3_1_13Vtr8internal5LevelEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIPN10OpenSubdiv6v3_1_13Vtr8internal9FVarLevelEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIPU19objcproto9MTLBuffer11objc_objectEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIPiEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIdEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS5_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIfEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS5_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIiEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS5_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorIjEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS5_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorImEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS5_m
+ __ZNSt3__119__allocate_at_leastB8nn200100INS_9allocatorItEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS5_m
+ __ZNSt3__119__partial_sort_implB8nn200100INS_17_ClassicAlgPolicyER12__VolumeCompPsS4_EET1_S5_S5_T2_OT0_
+ __ZNSt3__119__partial_sort_implB8nn200100INS_17_ClassicAlgPolicyER13__SphereZCompPsS4_EET1_S5_S5_T2_OT0_
+ __ZNSt3__119__partial_sort_implB8nn200100INS_17_ClassicAlgPolicyER18CompareCornerAngleP13ClippedCornerS5_EET1_S6_S6_T2_OT0_
+ __ZNSt3__119__partial_sort_implB8nn200100INS_17_ClassicAlgPolicyERNS_6__lessIvvEEPP9__C3DNodeS7_EET1_S8_S8_T2_OT0_
+ __ZNSt3__119__partial_sort_implB8nn200100INS_17_ClassicAlgPolicyERNS_7greaterIiEEPiS5_EET1_S6_S6_T2_OT0_
+ __ZNSt3__119__partial_sort_implB8nn200100INS_17_ClassicAlgPolicyERPFbRK9HitResultS4_EPS2_S8_EET1_S9_S9_T2_OT0_
+ __ZNSt3__122__tree_node_destructorINS_9allocatorINS_11__tree_nodeINS_12__value_typeINS_12basic_stringIcNS_11char_traitsIcEENS1_IcEEEENS_4pairIiiEEEEPvEEEEEclB8nn200100EPSD_
+ __ZNSt3__122__tree_node_destructorINS_9allocatorINS_11__tree_nodeINS_12basic_stringIcNS_11char_traitsIcEENS1_IcEEEEPvEEEEEclB8nn200100EPS9_
+ __ZNSt3__124__copy_move_unwrap_itersB8nn200100INS_11__copy_implENS_14__bit_iteratorINS_6vectorIbNS_9allocatorIbEEEELb0ELm0EEES7_S7_Li0EEENS_4pairIT0_T2_EES9_T1_SA_
+ __ZNSt3__124__put_character_sequenceB8nn200100IcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_PKS4_m
+ __ZNSt3__126__insertion_sort_unguardedB8nn200100INS_17_ClassicAlgPolicyER12__VolumeCompPsEEvT1_S5_T0_
+ __ZNSt3__126__insertion_sort_unguardedB8nn200100INS_17_ClassicAlgPolicyER13__SphereZCompPsEEvT1_S5_T0_
+ __ZNSt3__126__insertion_sort_unguardedB8nn200100INS_17_ClassicAlgPolicyERPFbRK9HitResultS4_EPS2_EEvT1_S9_T0_
+ __ZNSt3__127__insertion_sort_incompleteB8nn200100INS_17_ClassicAlgPolicyER12__VolumeCompPsEEbT1_S5_T0_
+ __ZNSt3__127__insertion_sort_incompleteB8nn200100INS_17_ClassicAlgPolicyER13__SphereZCompPsEEbT1_S5_T0_
+ __ZNSt3__127__insertion_sort_incompleteB8nn200100INS_17_ClassicAlgPolicyER18CompareCornerAngleP13ClippedCornerEEbT1_S6_T0_
+ __ZNSt3__127__insertion_sort_incompleteB8nn200100INS_17_ClassicAlgPolicyERNS_6__lessIvvEEPP9__C3DNodeEEbT1_S8_T0_
+ __ZNSt3__127__insertion_sort_incompleteB8nn200100INS_17_ClassicAlgPolicyERNS_7greaterIiEEPiEEbT1_S6_T0_
+ __ZNSt3__127__insertion_sort_incompleteB8nn200100INS_17_ClassicAlgPolicyERPFbRK9HitResultS4_EPS2_EEbT1_S9_T0_
+ __ZNSt3__127__insertion_sort_incompleteB8nn200100INS_17_ClassicAlgPolicyERZN3C3D11RenderGraph26resolvePartialDependenciesEvE3$_0PNS3_4LinkEEEbT1_S8_T0_
+ __ZNSt3__127__insertion_sort_incompleteB8nn200100INS_17_ClassicAlgPolicyERZN3C3D11RenderGraph8validateEvE3$_0PNS3_9PortsPairEEEbT1_S8_T0_
+ __ZNSt3__127__tree_balance_after_insertB8nn200100IPNS_16__tree_node_baseIPvEEEEvT_S5_
+ __ZNSt3__130__uninitialized_allocator_copyB8nn200100INS_9allocatorINS_12basic_stringIcNS_11char_traitsIcEENS1_IcEEEEEEPS6_S8_S8_EET2_RT_T0_T1_S9_
+ __ZNSt3__131__partition_with_equals_on_leftB8nn200100INS_17_ClassicAlgPolicyEP13ClippedCornerR18CompareCornerAngleEET0_S6_S6_T1_
+ __ZNSt3__131__partition_with_equals_on_leftB8nn200100INS_17_ClassicAlgPolicyEP9HitResultRPFbRKS2_S5_EEET0_S9_S9_T1_
+ __ZNSt3__131__partition_with_equals_on_leftB8nn200100INS_17_ClassicAlgPolicyEPP9__C3DNodeRNS_6__lessIvvEEEET0_S8_S8_T1_
+ __ZNSt3__131__partition_with_equals_on_leftB8nn200100INS_17_ClassicAlgPolicyEPiRNS_7greaterIiEEEET0_S6_S6_T1_
+ __ZNSt3__131__partition_with_equals_on_leftB8nn200100INS_17_ClassicAlgPolicyEPsR12__VolumeCompEET0_S5_S5_T1_
+ __ZNSt3__131__partition_with_equals_on_leftB8nn200100INS_17_ClassicAlgPolicyEPsR13__SphereZCompEET0_S5_S5_T1_
+ __ZNSt3__132__partition_with_equals_on_rightB8nn200100INS_17_ClassicAlgPolicyEP13ClippedCornerR18CompareCornerAngleEENS_4pairIT0_bEES7_S7_T1_
+ __ZNSt3__132__partition_with_equals_on_rightB8nn200100INS_17_ClassicAlgPolicyEP9HitResultRPFbRKS2_S5_EEENS_4pairIT0_bEESA_SA_T1_
+ __ZNSt3__132__partition_with_equals_on_rightB8nn200100INS_17_ClassicAlgPolicyEPP9__C3DNodeRNS_6__lessIvvEEEENS_4pairIT0_bEES9_S9_T1_
+ __ZNSt3__132__partition_with_equals_on_rightB8nn200100INS_17_ClassicAlgPolicyEPsR12__VolumeCompEENS_4pairIT0_bEES6_S6_T1_
+ __ZNSt3__132__partition_with_equals_on_rightB8nn200100INS_17_ClassicAlgPolicyEPsR13__SphereZCompEENS_4pairIT0_bEES6_S6_T1_
+ __ZNSt3__134__uninitialized_allocator_relocateB8nn200100INS_9allocatorI11MaterialMapEEPS2_EEvRT_T0_S7_S7_
+ __ZNSt3__134__uninitialized_allocator_relocateB8nn200100INS_9allocatorI23C3DSubdivCPUPrimvarDataIDv2_fEEEPS4_EEvRT_T0_S9_S9_
+ __ZNSt3__134__uninitialized_allocator_relocateB8nn200100INS_9allocatorI23C3DSubdivCPUPrimvarDataIDv3_fEEEPS4_EEvRT_T0_S9_S9_
+ __ZNSt3__134__uninitialized_allocator_relocateB8nn200100INS_9allocatorI23C3DSubdivCPUPrimvarDataIDv4_fEEEPS4_EEvRT_T0_S9_S9_
+ __ZNSt3__134__uninitialized_allocator_relocateB8nn200100INS_9allocatorI27C3DSubdivCPUFVarPrimvarInfoEEPS2_EEvRT_T0_S7_S7_
+ __ZNSt3__134__uninitialized_allocator_relocateB8nn200100INS_9allocatorI27C3DSubdivGPUFVarPrimvarDataEEPS2_EEvRT_T0_S7_S7_
+ __ZNSt3__134__uninitialized_allocator_relocateB8nn200100INS_9allocatorI28C3DSubdivCPUPrimvarDataGroupEEPS2_EEvRT_T0_S7_S7_
+ __ZNSt3__134__uninitialized_allocator_relocateB8nn200100INS_9allocatorI8VariableEEPS2_EEvRT_T0_S7_S7_
+ __ZNSt3__134__uninitialized_allocator_relocateB8nn200100INS_9allocatorIN10OpenSubdiv6v3_1_13Far10PatchTable16FVarPatchChannelEEEPS6_EEvRT_T0_SB_SB_
+ __ZNSt3__14pairIKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES6_EC2B8nn200100ERKS8_
+ __ZNSt3__14pairIKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES6_ED2Ev
+ __ZNSt3__15dequeIiNS_9allocatorIiEEED2B8nn200100Ev
+ __ZNSt3__16localeC1Ev
+ __ZNSt3__16vectorI10SCNVector3NS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI10simd_quatfNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI11MaterialMapNS_9allocatorIS1_EEE16__destroy_vectorclB8nn200100Ev
+ __ZNSt3__16vectorI11MaterialMapNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI11MaterialMapNS_9allocatorIS1_EEE24__emplace_back_slow_pathIJS1_EEEPS1_DpOT_
+ __ZNSt3__16vectorI11MaterialMapNS_9allocatorIS1_EEE5clearB8nn200100Ev
+ __ZNSt3__16vectorI13ClippedCornerNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI13ClippedCornerNS_9allocatorIS1_EEE9push_backB8nn200100ERKS1_
+ __ZNSt3__16vectorI13simd_float4x4NS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI14simd_double4x4NS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI14simd_double4x4NS_9allocatorIS1_EEE9push_backB8nn200100ERKS1_
+ __ZNSt3__16vectorI16C3DSubdivCPUDataIDv2_fENS_9allocatorIS3_EEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorI16C3DSubdivCPUDataIDv2_fENS_9allocatorIS3_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI16C3DSubdivCPUDataIDv3_fENS_9allocatorIS3_EEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorI16C3DSubdivCPUDataIDv3_fENS_9allocatorIS3_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI16C3DSubdivCPUDataIDv4_fENS_9allocatorIS3_EEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorI16C3DSubdivCPUDataIDv4_fENS_9allocatorIS3_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI18SCNSemanticBindingNS_9allocatorIS1_EEE12emplace_backIJRKS1_EEERS1_DpOT_
+ __ZNSt3__16vectorI18SCNSemanticBindingNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI19C3DTransformIndexesNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI19SCNPassInputBindingNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv2_fENS_9allocatorIS3_EEE16__destroy_vectorclB8nn200100Ev
+ __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv2_fENS_9allocatorIS3_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv2_fENS_9allocatorIS3_EEE24__emplace_back_slow_pathIJRKS3_EEEPS3_DpOT_
+ __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv2_fENS_9allocatorIS3_EEE5clearB8nn200100Ev
+ __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv2_fENS_9allocatorIS3_EEE9push_backB8nn200100ERKS3_
+ __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv3_fENS_9allocatorIS3_EEE16__destroy_vectorclB8nn200100Ev
+ __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv3_fENS_9allocatorIS3_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv3_fENS_9allocatorIS3_EEE24__emplace_back_slow_pathIJRKS3_EEEPS3_DpOT_
+ __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv3_fENS_9allocatorIS3_EEE5clearB8nn200100Ev
+ __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv3_fENS_9allocatorIS3_EEE9push_backB8nn200100ERKS3_
+ __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv4_fENS_9allocatorIS3_EEE16__destroy_vectorclB8nn200100Ev
+ __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv4_fENS_9allocatorIS3_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv4_fENS_9allocatorIS3_EEE24__emplace_back_slow_pathIJRKS3_EEEPS3_DpOT_
+ __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv4_fENS_9allocatorIS3_EEE5clearB8nn200100Ev
+ __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv4_fENS_9allocatorIS3_EEE9push_backB8nn200100ERKS3_
+ __ZNSt3__16vectorI23C3DSubdivCPUPrimvarInfoNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI23C3DSubdivGPUPrimvarInfoNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI27C3DSubdivCPUFVarPrimvarInfoNS_9allocatorIS1_EEE12emplace_backIJS1_EEERS1_DpOT_
+ __ZNSt3__16vectorI27C3DSubdivCPUFVarPrimvarInfoNS_9allocatorIS1_EEE16__destroy_vectorclB8nn200100Ev
+ __ZNSt3__16vectorI27C3DSubdivCPUFVarPrimvarInfoNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI27C3DSubdivCPUFVarPrimvarInfoNS_9allocatorIS1_EEE24__emplace_back_slow_pathIJS1_EEEPS1_DpOT_
+ __ZNSt3__16vectorI27C3DSubdivCPUFVarPrimvarInfoNS_9allocatorIS1_EEE5clearB8nn200100Ev
+ __ZNSt3__16vectorI27C3DSubdivGPUFVarPrimvarDataNS_9allocatorIS1_EEE12emplace_backIJS1_EEERS1_DpOT_
+ __ZNSt3__16vectorI27C3DSubdivGPUFVarPrimvarDataNS_9allocatorIS1_EEE16__destroy_vectorclB8nn200100Ev
+ __ZNSt3__16vectorI27C3DSubdivGPUFVarPrimvarDataNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI27C3DSubdivGPUFVarPrimvarDataNS_9allocatorIS1_EEE24__emplace_back_slow_pathIJS1_EEEPS1_DpOT_
+ __ZNSt3__16vectorI27C3DSubdivisionOsdGPURefinerNS_9allocatorIS1_EEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorI27C3DSubdivisionOsdGPURefinerNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI27C3DSubdivisionOsdGPURefinerNS_9allocatorIS1_EEE20__throw_out_of_rangeB8nn200100Ev
+ __ZNSt3__16vectorI27C3DSubdivisionOsdGPURefinerNS_9allocatorIS1_EEEC2B8nn200100Em
+ __ZNSt3__16vectorI28C3DSubdivCPUPrimvarDataGroupNS_9allocatorIS1_EEE16__destroy_vectorclB8nn200100Ev
+ __ZNSt3__16vectorI28C3DSubdivCPUPrimvarDataGroupNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI28C3DSubdivCPUPrimvarDataGroupNS_9allocatorIS1_EEE5clearB8nn200100Ev
+ __ZNSt3__16vectorI30C3DSubdivisionOsdGPUPatchTableNS_9allocatorIS1_EEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorI30C3DSubdivisionOsdGPUPatchTableNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI30C3DSubdivisionOsdGPUPatchTableNS_9allocatorIS1_EEE20__throw_out_of_rangeB8nn200100Ev
+ __ZNSt3__16vectorI30C3DSubdivisionOsdGPUPatchTableNS_9allocatorIS1_EEEC2B8nn200100Em
+ __ZNSt3__16vectorI31C3DSubdivMeshSourceIndexingInfoNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI34C3DSubdivCPUMeshCreationSourceInfoNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI34C3DSubdivCPUMeshCreationSourceInfoNS_9allocatorIS1_EEE9push_backB8nn200100ERKS1_
+ __ZNSt3__16vectorI4PairNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI5TokenNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI5TokenNS_9allocatorIS1_EEE9push_backB8nn200100ERKS1_
+ __ZNSt3__16vectorI7CFRangeNS_9allocatorIS1_EEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorI7CFRangeNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI7CFRangeNS_9allocatorIS1_EEE9push_backB8nn200100EOS1_
+ __ZNSt3__16vectorI7CFRangeNS_9allocatorIS1_EEEC2B8nn200100ERKS4_
+ __ZNSt3__16vectorI8TriangleNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI8TriangleNS_9allocatorIS1_EEE9push_backB8nn200100ERKS1_
+ __ZNSt3__16vectorI8VariableNS_9allocatorIS1_EEE16__destroy_vectorclB8nn200100Ev
+ __ZNSt3__16vectorI8VariableNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI8VariableNS_9allocatorIS1_EEE24__emplace_back_slow_pathIJS1_EEEPS1_DpOT_
+ __ZNSt3__16vectorI8VariableNS_9allocatorIS1_EEE9push_backB8nn200100EOS1_
+ __ZNSt3__16vectorI9C3DColor4NS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorI9C3DColor4NS_9allocatorIS1_EEE9push_backB8nn200100ERKS1_
+ __ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE9push_backB8nn200100EOS1_
+ __ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE9push_backB8nn200100ERKS1_
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Far10PatchParamENS_9allocatorIS4_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Far10PatchTable10PatchArrayENS_9allocatorIS5_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Far10PatchTable16FVarPatchChannelENS_9allocatorIS5_EEE16__destroy_vectorclB8nn200100Ev
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Far10PatchTable16FVarPatchChannelENS_9allocatorIS5_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Far13TopologyLevelENS_9allocatorIS4_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Far17PatchTableFactory14BuilderContext10PatchTupleENS_9allocatorIS6_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Osd10PatchArrayENS_9allocatorIS4_EEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Osd10PatchArrayENS_9allocatorIS4_EEE18__assign_with_sizeB8nn200100IPKS4_SA_EEvT_T0_l
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Osd10PatchArrayENS_9allocatorIS4_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Osd10PatchArrayENS_9allocatorIS4_EEE9push_backB8nn200100ERKS4_
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Osd10PatchParamENS_9allocatorIS4_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Osd10PatchParamENS_9allocatorIS4_EEE9push_backB8nn200100ERKS4_
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Osd15EvaluatorCacheTINS3_19MTLComputeEvaluatorEE5EntryENS_9allocatorIS7_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Vtr8internal10Refinement8ChildTagENS_9allocatorIS6_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Vtr8internal10Refinement9SparseTagENS_9allocatorIS6_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Vtr8internal5Level4ETagENS_9allocatorIS6_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Vtr8internal5Level4FTagENS_9allocatorIS6_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Vtr8internal5Level4VTagENS_9allocatorIS6_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Vtr8internal9FVarLevel13CreaseEndPairENS_9allocatorIS6_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Vtr8internal9FVarLevel4ETagENS_9allocatorIS6_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Vtr8internal9FVarLevel8ValueTagENS_9allocatorIS6_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN16SCNMTLBufferPool6BufferENS_9allocatorIS2_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN17SCNMTLTexturePool13CachedTextureENS_9allocatorIS2_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN5vmesh15SubdivisionInfoENS_9allocatorIS2_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN5vmesh8TriangleENS_9allocatorIS2_EEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorIN5vmesh8TriangleENS_9allocatorIS2_EEE18__assign_with_sizeB8nn200100IPS2_S7_EEvT_T0_l
+ __ZNSt3__16vectorIN5vmesh8TriangleENS_9allocatorIS2_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN5vmesh8TriangleENS_9allocatorIS2_EEE9push_backB8nn200100EOS2_
+ __ZNSt3__16vectorIN9AnimCodec17ArithmeticContextENS_9allocatorIS2_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIN9AnimCodec7Vector3IfEENS_9allocatorIS3_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorINS0_I7CFRangeNS_9allocatorIS1_EEEENS2_IS4_EEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorINS0_I7CFRangeNS_9allocatorIS1_EEEENS2_IS4_EEE16__destroy_vectorclB8nn200100Ev
+ __ZNSt3__16vectorINS0_I7CFRangeNS_9allocatorIS1_EEEENS2_IS4_EEE16__init_with_sizeB8nn200100IPS4_S8_EEvT_T0_m
+ __ZNSt3__16vectorINS0_I7CFRangeNS_9allocatorIS1_EEEENS2_IS4_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorINS0_I7CFRangeNS_9allocatorIS1_EEEENS2_IS4_EEE20__throw_out_of_rangeB8nn200100Ev
+ __ZNSt3__16vectorINS0_I7CFRangeNS_9allocatorIS1_EEEENS2_IS4_EEE5clearB8nn200100Ev
+ __ZNSt3__16vectorINS0_I7CFRangeNS_9allocatorIS1_EEEENS2_IS4_EEEC2B8nn200100Em
+ __ZNSt3__16vectorINS0_IN10OpenSubdiv6v3_1_13Osd10PatchArrayENS_9allocatorIS4_EEEENS5_IS7_EEE16__destroy_vectorclB8nn200100Ev
+ __ZNSt3__16vectorINS0_IN10OpenSubdiv6v3_1_13Osd10PatchArrayENS_9allocatorIS4_EEEENS5_IS7_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorINS0_IN10OpenSubdiv6v3_1_13Osd10PatchArrayENS_9allocatorIS4_EEEENS5_IS7_EEE5clearB8nn200100Ev
+ __ZNSt3__16vectorINS0_IN10OpenSubdiv6v3_1_13Osd10PatchParamENS_9allocatorIS4_EEEENS5_IS7_EEE16__destroy_vectorclB8nn200100Ev
+ __ZNSt3__16vectorINS0_IN10OpenSubdiv6v3_1_13Osd10PatchParamENS_9allocatorIS4_EEEENS5_IS7_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorINS0_IN10OpenSubdiv6v3_1_13Osd10PatchParamENS_9allocatorIS4_EEEENS5_IS7_EEE5clearB8nn200100Ev
+ __ZNSt3__16vectorINS0_INS0_I7CFRangeNS_9allocatorIS1_EEEENS2_IS4_EEEENS2_IS6_EEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorINS0_INS0_I7CFRangeNS_9allocatorIS1_EEEENS2_IS4_EEEENS2_IS6_EEE16__destroy_vectorclB8nn200100Ev
+ __ZNSt3__16vectorINS0_INS0_I7CFRangeNS_9allocatorIS1_EEEENS2_IS4_EEEENS2_IS6_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorINS0_INS0_I7CFRangeNS_9allocatorIS1_EEEENS2_IS4_EEEENS2_IS6_EEE20__throw_out_of_rangeB8nn200100Ev
+ __ZNSt3__16vectorINS0_INS0_I7CFRangeNS_9allocatorIS1_EEEENS2_IS4_EEEENS2_IS6_EEEC2B8nn200100EmRKS6_
+ __ZNSt3__16vectorINS0_IfNS_9allocatorIfEEEENS1_IS3_EEE16__destroy_vectorclB8nn200100Ev
+ __ZNSt3__16vectorINS0_IfNS_9allocatorIfEEEENS1_IS3_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorINS0_IfNS_9allocatorIfEEEENS1_IS3_EEE5clearB8nn200100Ev
+ __ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE16__destroy_vectorclB8nn200100Ev
+ __ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE5clearB8nn200100Ev
+ __ZNSt3__16vectorINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS4_IS6_EEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS4_IS6_EEE16__destroy_vectorclB8nn200100Ev
+ __ZNSt3__16vectorINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS4_IS6_EEE18__assign_with_sizeB8nn200100IPS6_SA_EEvT_T0_l
+ __ZNSt3__16vectorINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS4_IS6_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS4_IS6_EEE22__construct_one_at_endB8nn200100IJRKS6_EEEvDpOT_
+ __ZNSt3__16vectorINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS4_IS6_EEE24__emplace_back_slow_pathIJRKS6_EEEPS6_DpOT_
+ __ZNSt3__16vectorINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS4_IS6_EEE5clearB8nn200100Ev
+ __ZNSt3__16vectorINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS4_IS6_EEE9push_backB8nn200100ERKS6_
+ __ZNSt3__16vectorINS_4pairIP7SCNNodeP8SkeletonEENS_9allocatorIS6_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorINS_4pairIP9__C3DMeshP16__C3DMeshElementEENS_9allocatorIS6_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIP10BlendShapeNS_9allocatorIS2_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIP10SCNCActionNS_9allocatorIS2_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIP10SCNCActionNS_9allocatorIS2_EEE20__throw_out_of_rangeB8nn200100Ev
+ __ZNSt3__16vectorIP10SCNCActionNS_9allocatorIS2_EEE9push_backB8nn200100EOS2_
+ __ZNSt3__16vectorIP11MaterialMapNS_9allocatorIS2_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIP11MaterialMapNS_9allocatorIS2_EEE9push_backB8nn200100EOS2_
+ __ZNSt3__16vectorIP13TextureLookupNS_9allocatorIS2_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIP13TextureLookupNS_9allocatorIS2_EEE9push_backB8nn200100ERKS2_
+ __ZNSt3__16vectorIP15c3dPhysicsFieldNS_9allocatorIS2_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIP15c3dPhysicsFieldNS_9allocatorIS2_EEE9push_backB8nn200100ERKS2_
+ __ZNSt3__16vectorIP19CAKeyframeAnimationNS_9allocatorIS2_EEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorIP19CAKeyframeAnimationNS_9allocatorIS2_EEE18__assign_with_sizeB8nn200100IPS2_S7_EEvT_T0_l
+ __ZNSt3__16vectorIP19CAKeyframeAnimationNS_9allocatorIS2_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIP19CAKeyframeAnimationNS_9allocatorIS2_EEE9push_backB8nn200100ERKS2_
+ __ZNSt3__16vectorIP21WireframeMeshInstanceNS_9allocatorIS2_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIP4SkinNS_9allocatorIS2_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIP7SCNNodeNS_9allocatorIS2_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIP7SCNNodeNS_9allocatorIS2_EEE9push_backB8nn200100ERKS2_
+ __ZNSt3__16vectorIP7UITouchNS_9allocatorIS2_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIP7UITouchNS_9allocatorIS2_EEE9push_backB8nn200100ERKS2_
+ __ZNSt3__16vectorIP8SkeletonNS_9allocatorIS2_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIP8SkeletonNS_9allocatorIS2_EEE9push_backB8nn200100ERKS2_
+ __ZNSt3__16vectorIP9StatementNS_9allocatorIS2_EEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorIP9StatementNS_9allocatorIS2_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIP9StatementNS_9allocatorIS2_EEE9push_backB8nn200100ERKS2_
+ __ZNSt3__16vectorIP9StatementNS_9allocatorIS2_EEEC2B8nn200100ERKS5_
+ __ZNSt3__16vectorIPKN10OpenSubdiv6v3_1_13Far12StencilTableENS_9allocatorIS6_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIPN10OpenSubdiv6v3_1_13Vtr8internal10RefinementENS_9allocatorIS6_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIPN10OpenSubdiv6v3_1_13Vtr8internal14FVarRefinementENS_9allocatorIS6_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIPN10OpenSubdiv6v3_1_13Vtr8internal5LevelENS_9allocatorIS6_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIPN10OpenSubdiv6v3_1_13Vtr8internal5LevelENS_9allocatorIS6_EEE9push_backB8nn200100EOS6_
+ __ZNSt3__16vectorIPN10OpenSubdiv6v3_1_13Vtr8internal9FVarLevelENS_9allocatorIS6_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIPU19objcproto9MTLBuffer11objc_objectNS_9allocatorIS2_EEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIbNS_9allocatorIbEEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorIbNS_9allocatorIbEEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIdNS_9allocatorIdEEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorIdNS_9allocatorIdEEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIfNS_9allocatorIfEEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorIfNS_9allocatorIfEEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIfNS_9allocatorIfEEE9push_backB8nn200100EOf
+ __ZNSt3__16vectorIfNS_9allocatorIfEEE9push_backB8nn200100ERKf
+ __ZNSt3__16vectorIfNS_9allocatorIfEEEC2B8nn200100ERKS3_
+ __ZNSt3__16vectorIhNS_9allocatorIhEEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIiNS_9allocatorIiEEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorIiNS_9allocatorIiEEE18__assign_with_sizeB8nn200100IPKiS6_EEvT_T0_l
+ __ZNSt3__16vectorIiNS_9allocatorIiEEE18__insert_with_sizeB8nn200100IPKiS6_EENS_11__wrap_iterIPiEENS7_IS6_EET_T0_l
+ __ZNSt3__16vectorIiNS_9allocatorIiEEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backB8nn200100EOi
+ __ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backB8nn200100ERKi
+ __ZNSt3__16vectorIiNS_9allocatorIiEEEC2B8nn200100ERKS3_
+ __ZNSt3__16vectorIjNS_9allocatorIjEEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorIjNS_9allocatorIjEEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__16vectorIjNS_9allocatorIjEEE9push_backB8nn200100EOj
+ __ZNSt3__16vectorIjNS_9allocatorIjEEE9push_backB8nn200100ERKj
+ __ZNSt3__16vectorIjNS_9allocatorIjEEEC2B8nn200100ERKS3_
+ __ZNSt3__16vectorItNS_9allocatorItEEE11__vallocateB8nn200100Em
+ __ZNSt3__16vectorItNS_9allocatorItEEE20__throw_length_errorB8nn200100Ev
+ __ZNSt3__17__sort5B8nn200100INS_17_ClassicAlgPolicyER12__VolumeCompPsLi0EEEvT1_S5_S5_S5_S5_T0_
+ __ZNSt3__17__sort5B8nn200100INS_17_ClassicAlgPolicyER13__SphereZCompPsLi0EEEvT1_S5_S5_S5_S5_T0_
+ __ZNSt3__17__sort5B8nn200100INS_17_ClassicAlgPolicyER18CompareCornerAngleP13ClippedCornerLi0EEEvT1_S6_S6_S6_S6_T0_
+ __ZNSt3__17__sort5B8nn200100INS_17_ClassicAlgPolicyERPFbRK9HitResultS4_EPS2_Li0EEEvT1_S9_S9_S9_S9_T0_
+ __ZNSt3__17__sort5B8nn200100INS_17_ClassicAlgPolicyERZN3C3D11RenderGraph26resolvePartialDependenciesEvE3$_0PNS3_4LinkELi0EEEvT1_S8_S8_S8_S8_T0_
+ __ZNSt3__17__sort5B8nn200100INS_17_ClassicAlgPolicyERZN3C3D11RenderGraph8validateEvE3$_0PNS3_9PortsPairELi0EEEvT1_S8_S8_S8_S8_T0_
+ __ZNSt3__18__rotateB8nn200100INS_17_ClassicAlgPolicyEPN3C3D16PassIODescriptorES4_EENS_4pairIT0_S6_EES6_S6_T1_
+ __ZNSt3__19__sift_upB8nn200100INS_17_ClassicAlgPolicyER12__VolumeCompPsEEvT1_S5_OT0_NS_15iterator_traitsIS5_E15difference_typeE
+ __ZNSt3__19__sift_upB8nn200100INS_17_ClassicAlgPolicyER13__SphereZCompPsEEvT1_S5_OT0_NS_15iterator_traitsIS5_E15difference_typeE
+ __ZNSt3__19__sift_upB8nn200100INS_17_ClassicAlgPolicyER18CompareCornerAngleP13ClippedCornerEEvT1_S6_OT0_NS_15iterator_traitsIS6_E15difference_typeE
+ __ZNSt3__19__sift_upB8nn200100INS_17_ClassicAlgPolicyERPFbRK9HitResultS4_EPS2_EEvT1_S9_OT0_NS_15iterator_traitsIS9_E15difference_typeE
+ __ZNSt3__19allocatorI27C3DSubdivGPUFVarPrimvarDataE7destroyB8nn200100EPS1_
+ __ZNSt3__19allocatorI28C3DSubdivCPUPrimvarDataGroupE9constructB8nn200100IS1_JS1_EEEvPT_DpOT0_
+ __ZNSt3__19allocatorIN10OpenSubdiv6v3_1_13Far10PatchTable16FVarPatchChannelEE7destroyB8nn200100EPS5_
+ __ZNSt3__1eqB8nn200100IcNS_11char_traitsIcEENS_9allocatorIcEEEEbRKNS_12basic_stringIT_T0_T1_EEPKS6_
+ __ZSt28__throw_bad_array_new_lengthB8nn200100v
+ __ZTVNSt3__115basic_streambufIcNS_11char_traitsIcEEEE
+ ___105-[_SCNCoderMaterialPropertyTextureProviderHelper cachedTextureWithURL:token:didFallbackToDefaultTexture:]_block_invoke
+ ___176-[SCNCommonProfileProgramGeneratorMetal splitInputOutputStructsIfNeededForSourceCode:generatedFromReplacementStrings:perPixelLighting:clipDistanceCount:hasBezierCurveDeformer:]_block_invoke
+ ___87-[SCNMTLResourceManager(Compilation) _createPipelineStateWithDescriptor:desc:pipeline:]_block_invoke.11
+ ___SCNEncodeImageFromMaterialPropertyTextureProviderForKey_block_invoke
+ ___SCNEncodeImageFromMaterialPropertyTextureProviderForKey_block_invoke_2
+ ___SCNEncodeImageFromMaterialPropertyTextureProviderForKey_block_invoke_3
+ ___SetupCommonProfileEffectProperty.cold.4
+ ___SetupCommonProfileEffectProperty.done.58
+ ____ZL17__renderToTexturePU45objcproto34SCNMaterialPropertyTextureProvider11objc_objectPU21objcproto10MTLTexture11objc_objectPU51objcproto40SCNMaterialPropertyTextureProviderHelper11objc_objectP19SCNMTLRenderContext_block_invoke.79
+ ____ZL17__renderToTexturePU45objcproto34SCNMaterialPropertyTextureProvider11objc_objectPU21objcproto10MTLTexture11objc_objectPU51objcproto40SCNMaterialPropertyTextureProviderHelper11objc_objectP19SCNMTLRenderContext_block_invoke.79.cold.1
+ ____ZL17__renderToTexturePU45objcproto34SCNMaterialPropertyTextureProvider11objc_objectPU21objcproto10MTLTexture11objc_objectPU51objcproto40SCNMaterialPropertyTextureProviderHelper11objc_objectP19SCNMTLRenderContext_block_invoke.82
+ ____ZL17__renderToTexturePU45objcproto34SCNMaterialPropertyTextureProvider11objc_objectPU21objcproto10MTLTexture11objc_objectPU51objcproto40SCNMaterialPropertyTextureProviderHelper11objc_objectP19SCNMTLRenderContext_block_invoke.82.cold.1
+ ____ZL49C3DSubdivisionOsdGPURuntimeDataCreateWithGeometryP13__C3DGeometryP18__C3DEngineContextRK36C3DSubdivisionOsdGPUSubdivParametersP21SCNMTLResourceManagerPU26objcproto15MTLCommandQueue11objc_objectU13block_pointerFvPU27objcproto16MTLCommandBuffer11objc_objectbE_block_invoke.537
+ ____ZL49C3DSubdivisionOsdGPURuntimeDataCreateWithGeometryP13__C3DGeometryP18__C3DEngineContextRK36C3DSubdivisionOsdGPUSubdivParametersP21SCNMTLResourceManagerPU26objcproto15MTLCommandQueue11objc_objectU13block_pointerFvPU27objcproto16MTLCommandBuffer11objc_objectbE_block_invoke.537.cold.1
+ ____ZL49C3DSubdivisionOsdGPURuntimeDataCreateWithGeometryP13__C3DGeometryP18__C3DEngineContextRK36C3DSubdivisionOsdGPUSubdivParametersP21SCNMTLResourceManagerPU26objcproto15MTLCommandQueue11objc_objectU13block_pointerFvPU27objcproto16MTLCommandBuffer11objc_objectbE_block_invoke.537.cold.2
+ ____ZL49C3DSubdivisionOsdGPURuntimeDataCreateWithGeometryP13__C3DGeometryP18__C3DEngineContextRK36C3DSubdivisionOsdGPUSubdivParametersP21SCNMTLResourceManagerPU26objcproto15MTLCommandQueue11objc_objectU13block_pointerFvPU27objcproto16MTLCommandBuffer11objc_objectbE_block_invoke.537.cold.3
+ ___block_descriptor_56_e8_32o40r48r_e40_v16?0?<v?"<MTLBlitCommandEncoder>">8lr40l8r48l8s32l8
+ ___block_descriptor_56_e8_32o40r48r_e43_v16?0?<v?"<MTLComputeCommandEncoder>">8lr40l8r48l8s32l8
+ ___block_literal_global.513
+ ___block_literal_global.524
+ ___block_literal_global.526
+ ___block_literal_global.528
+ ___block_literal_global.530
+ ___block_literal_global.532
+ ___block_literal_global.534
+ ___block_literal_global.669
+ _objc_msgSend$classForCoder
+ _objc_msgSend$commandBufferWithDescriptor:
+ _objc_msgSend$copyFromTexture:toTexture:
+ _objc_msgSend$decodeBytesWithReturnedLength:
+ _objc_msgSend$edgeCreasesElement
+ _objc_msgSend$edgeCreasesSource
+ _objc_msgSend$encodeBytes:length:
+ _objc_msgSend$replacementObjectForCoder:
+ _objc_msgSend$scn_decodeArrayOfObjectsOfClasses:containingNestedContainersForKey:
+ _objc_msgSend$setErrorOptions:
+ _objc_msgSend$splitInputOutputStructsIfNeededForSourceCode:generatedFromReplacementStrings:perPixelLighting:clipDistanceCount:hasBezierCurveDeformer:
- -[SCNCamera _checkSettingsConsistency].cold.2
- -[SCNCommonProfileProgramGeneratorMetal splitInputOutputStructsIfNeededForSourceCode:generatedFromReplacementStrings:perPixelLighting:clipDistanceCount:]
- GCC_except_table110
- GCC_except_table114
- GCC_except_table120
- GCC_except_table121
- GCC_except_table138
- GCC_except_table151
- GCC_except_table173
- GCC_except_table178
- GCC_except_table193
- GCC_except_table197
- GCC_except_table266
- GCC_except_table273
- GCC_except_table274
- GCC_except_table58
- GCC_except_table75
- GCC_except_table90
- GCC_except_table93
- GCC_except_table95
- _C3DCommandQueueAppendNewCommand
- _C3DCommandQueueAppendNewCommand.cold.1
- _C3DFXTechniqueSetValueForSymbolWithCount.cold.5
- _OBJC_IVAR_$_SCNMTLMorphDeformer._morphTargetCount
- _OBJC_IVAR_$_SCNMTLMorphDeformer._morphTargets
- _SCNEncodeC3DImage
- _SCNEncodeImageArray
- _SCNEncodeImageContents
- __ZN10OpenSubdiv6v3_1_13Far12GregoryBasis5PointC2Ei
- __ZN10OpenSubdiv6v3_1_13Far15TopologyRefiner11appendLevelERNS0_3Vtr8internal5LevelE
- __ZN10OpenSubdiv6v3_1_13Far8internal11WeightTable17ScalarAccumulator8PushBackEf
- __ZN10OpenSubdiv6v3_1_13Vtr8internal12_GLOBAL__N_115DynamicRelation16appendCompMemberEii
- __ZN13ShapeBlending16createBlendShapeEi
- __ZN17btTriangleInfoMapD2Ev
- __ZN27C3DSubdivGPUFVarPrimvarDataD1Ev
- __ZN29C3DSubdivGPUPrimvarDescriptorD1Ev
- __ZN3C3D5ArrayIP9__C3DNodeLj0ENS_16ScratchAllocatorEE7reserveEj
- __ZN4Mesh8AddColorERK9C3DColor4
- __ZN8Skinning7addSkinEP4Skin
- __ZN9Statement12AddStatementEPS_
- __ZNK20btConvexHullInternal6Vertex6xvalueEv
- __ZNK20btConvexHullInternal6Vertex6yvalueEv
- __ZNK20btConvexHullInternal6Vertex6zvalueEv
- __ZNKSt3__111__copy_implINS_17_ClassicAlgPolicyEEclB8nn190102INS_14__bit_iteratorINS_6vectorIbNS_9allocatorIbEEEELb0ELm0EEES9_S9_EENS_4pairIT_T1_EESB_T0_SC_
- __ZNKSt3__14lessINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEclB8nn190102ERKS6_S9_
- __ZNSt3__110unique_ptrINS_11__tree_nodeINS_12__value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_6vectorIP19CAKeyframeAnimationNS6_ISB_EEEEEEPvEENS_22__tree_node_destructorINS6_ISG_EEEEE5resetB8nn190102EPSG_
- __ZNSt3__110unique_ptrINS_11__tree_nodeINS_12__value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_6vectorIS8_NS6_IS8_EEEEEEPvEENS_22__tree_node_destructorINS6_ISE_EEEEE5resetB8nn190102EPSE_
- __ZNSt3__110unique_ptrINS_11__tree_nodeINS_12__value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES8_EEPvEENS_22__tree_node_destructorINS6_ISB_EEEEE5resetB8nn190102EPSB_
- __ZNSt3__111__introsortINS_17_ClassicAlgPolicyERNS_7greaterIiEEPiLb0EEEvT1_S6_T0_NS_15iterator_traitsIS6_E15difference_typeEb
- __ZNSt3__111__sift_downB8nn190102INS_17_ClassicAlgPolicyER12__VolumeCompPsEEvT1_OT0_NS_15iterator_traitsIS5_E15difference_typeES5_
- __ZNSt3__111__sift_downB8nn190102INS_17_ClassicAlgPolicyER13__SphereZCompPsEEvT1_OT0_NS_15iterator_traitsIS5_E15difference_typeES5_
- __ZNSt3__111__sift_downB8nn190102INS_17_ClassicAlgPolicyER18CompareCornerAngleP13ClippedCornerEEvT1_OT0_NS_15iterator_traitsIS6_E15difference_typeES6_
- __ZNSt3__111__sift_downB8nn190102INS_17_ClassicAlgPolicyERNS_6__lessIvvEEPP9__C3DNodeEEvT1_OT0_NS_15iterator_traitsIS8_E15difference_typeES8_
- __ZNSt3__111__sift_downB8nn190102INS_17_ClassicAlgPolicyERNS_7greaterIiEEPiEEvT1_OT0_NS_15iterator_traitsIS6_E15difference_typeES6_
- __ZNSt3__111__sift_downB8nn190102INS_17_ClassicAlgPolicyERPFbRK9HitResultS4_EPS2_EEvT1_OT0_NS_15iterator_traitsIS9_E15difference_typeES9_
- __ZNSt3__112__destroy_atB8nn190102INS_4pairIKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_6vectorIP19CAKeyframeAnimationNS5_ISB_EEEEEELi0EEEvPT_
- __ZNSt3__112__destroy_atB8nn190102INS_4pairIKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_6vectorIS7_NS5_IS7_EEEEEELi0EEEvPT_
- __ZNSt3__112__destroy_atB8nn190102INS_4pairIKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7_EELi0EEEvPT_
- __ZNSt3__112__rotate_gcdB8nn190102INS_17_ClassicAlgPolicyEPN3C3D16PassIODescriptorEEET0_S5_S5_S5_
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC2B8nn190102ENS_24__uninitialized_size_tagEmRKS4_
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC2B8nn190102EPKcm
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC2B8nn190102Emc
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC2B8nn190102ILi0EEEPKc
- __ZNSt3__113__fill_n_boolB8nn190102ILb0ENS_6vectorIbNS_9allocatorIbEEEEEEvNS_14__bit_iteratorIT0_Lb0EXLi0EEEENS6_9size_typeE
- __ZNSt3__113__fill_n_boolB8nn190102ILb1ENS_6vectorIbNS_9allocatorIbEEEEEEvNS_14__bit_iteratorIT0_Lb0EXLi0EEEENS6_9size_typeE
- __ZNSt3__113__tree_removeB8nn190102IPNS_16__tree_node_baseIPvEEEEvT_S5_
- __ZNSt3__113unordered_mapIi25SCNPerformanceDataMappingNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEED1B8nn190102Ev
- __ZNSt3__114__copy_alignedB8nn190102INS_6vectorIbNS_9allocatorIbEEEELb1EEENS_14__bit_iteratorIT_Lb0EXLi0EEEENS5_IS6_XT0_EXLi0EEEES8_S7_
- __ZNSt3__114__split_bufferI11MaterialMapRNS_9allocatorIS1_EEE17__destruct_at_endB8nn190102EPS1_
- __ZNSt3__114__split_bufferI23C3DSubdivCPUPrimvarDataIDv2_fERNS_9allocatorIS3_EEE5clearB8nn190102Ev
- __ZNSt3__114__split_bufferI23C3DSubdivCPUPrimvarDataIDv3_fERNS_9allocatorIS3_EEE5clearB8nn190102Ev
- __ZNSt3__114__split_bufferI23C3DSubdivCPUPrimvarDataIDv4_fERNS_9allocatorIS3_EEE5clearB8nn190102Ev
- __ZNSt3__114__split_bufferI27C3DSubdivCPUFVarPrimvarInfoRNS_9allocatorIS1_EEE17__destruct_at_endB8nn190102EPS1_
- __ZNSt3__114__split_bufferI27C3DSubdivGPUFVarPrimvarDataRNS_9allocatorIS1_EEE5clearB8nn190102Ev
- __ZNSt3__114__split_bufferI28C3DSubdivCPUPrimvarDataGroupRNS_9allocatorIS1_EEE5clearB8nn190102Ev
- __ZNSt3__114__split_bufferI8VariableRNS_9allocatorIS1_EEE5clearB8nn190102Ev
- __ZNSt3__114__split_bufferIN10OpenSubdiv6v3_1_13Far10PatchTable16FVarPatchChannelERNS_9allocatorIS5_EEE5clearB8nn190102Ev
- __ZNSt3__114__split_bufferINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS4_IS6_EEE17__destruct_at_endB8nn190102EPS6_
- __ZNSt3__114__split_bufferINS_6vectorIN10OpenSubdiv6v3_1_13Osd10PatchArrayENS_9allocatorIS5_EEEERNS6_IS8_EEE17__destruct_at_endB8nn190102EPS8_
- __ZNSt3__114__split_bufferINS_6vectorIN10OpenSubdiv6v3_1_13Osd10PatchParamENS_9allocatorIS5_EEEERNS6_IS8_EEE17__destruct_at_endB8nn190102EPS8_
- __ZNSt3__114__split_bufferINS_6vectorIfNS_9allocatorIfEEEERNS2_IS4_EEE17__destruct_at_endB8nn190102EPS4_
- __ZNSt3__114__split_bufferINS_6vectorIiNS_9allocatorIiEEEERNS2_IS4_EEE17__destruct_at_endB8nn190102EPS4_
- __ZNSt3__114__split_bufferIPiNS_9allocatorIS1_EEE10push_frontEOS1_
- __ZNSt3__114__split_bufferIPiNS_9allocatorIS1_EEE9push_backEOS1_
- __ZNSt3__114__split_bufferIPiRNS_9allocatorIS1_EEE10push_frontERKS1_
- __ZNSt3__114__split_bufferIPiRNS_9allocatorIS1_EEE9push_backEOS1_
- __ZNSt3__115basic_streambufIcNS_11char_traitsIcEEEC2Ev
- __ZNSt3__115basic_streambufIcNS_11char_traitsIcEEED2Ev
- __ZNSt3__116__insertion_sortB8nn190102INS_17_ClassicAlgPolicyER12__VolumeCompPsEEvT1_S5_T0_
- __ZNSt3__116__insertion_sortB8nn190102INS_17_ClassicAlgPolicyER13__SphereZCompPsEEvT1_S5_T0_
- __ZNSt3__116__insertion_sortB8nn190102INS_17_ClassicAlgPolicyER18CompareCornerAngleP13ClippedCornerEEvT1_S6_T0_
- __ZNSt3__116__insertion_sortB8nn190102INS_17_ClassicAlgPolicyERPFbRK9HitResultS4_EPS2_EEvT1_S9_T0_
- __ZNSt3__116__pad_and_outputB8nn190102IcNS_11char_traitsIcEEEENS_19ostreambuf_iteratorIT_T0_EES6_PKS4_S8_S8_RNS_8ios_baseES4_
- __ZNSt3__118basic_stringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEC1B8nn190102Ev
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI10SCNVector3EEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI10simd_quatfEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI11MaterialMapEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI13ClippedCornerEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI13simd_float4x4EEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI14simd_double4x4EEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI16C3DSubdivCPUDataIDv2_fEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS8_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI16C3DSubdivCPUDataIDv3_fEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS8_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI16C3DSubdivCPUDataIDv4_fEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS8_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI18SCNSemanticBindingEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI19C3DTransformIndexesEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI19SCNPassInputBindingEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI23C3DSubdivCPUPrimvarDataIDv2_fEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS8_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI23C3DSubdivCPUPrimvarDataIDv3_fEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS8_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI23C3DSubdivCPUPrimvarDataIDv4_fEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS8_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI23C3DSubdivCPUPrimvarInfoEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI23C3DSubdivGPUPrimvarInfoEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI27C3DSubdivCPUFVarPrimvarInfoEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI27C3DSubdivGPUFVarPrimvarDataEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI27C3DSubdivisionOsdGPURefinerEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI28C3DSubdivCPUPrimvarDataGroupEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI30C3DSubdivisionOsdGPUPatchTableEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI31C3DSubdivMeshSourceIndexingInfoEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI34C3DSubdivCPUMeshCreationSourceInfoEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI4PairEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI5TokenEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI7CFRangeEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI8TriangleEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI8VariableEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorI9C3DColor4EEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIDv2_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIN10OpenSubdiv6v3_1_13Far10PatchParamEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS9_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIN10OpenSubdiv6v3_1_13Far10PatchTable10PatchArrayEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSA_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIN10OpenSubdiv6v3_1_13Far10PatchTable16FVarPatchChannelEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSA_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIN10OpenSubdiv6v3_1_13Far13TopologyLevelEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS9_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIN10OpenSubdiv6v3_1_13Far17PatchTableFactory14BuilderContext10PatchTupleEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIN10OpenSubdiv6v3_1_13Osd10PatchArrayEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS9_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIN10OpenSubdiv6v3_1_13Osd10PatchParamEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS9_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIN10OpenSubdiv6v3_1_13Osd15EvaluatorCacheTINS4_19MTLComputeEvaluatorEE5EntryEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSC_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIN10OpenSubdiv6v3_1_13Vtr8internal5Level4VTagEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIN10OpenSubdiv6v3_1_13Vtr8internal9FVarLevel13CreaseEndPairEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIN16SCNMTLBufferPool6BufferEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIN17SCNMTLTexturePool13CachedTextureEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIN5vmesh15SubdivisionInfoEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIN5vmesh8TriangleEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIN9AnimCodec17ArithmeticContextEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIN9AnimCodec7Vector3IfEEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS8_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorINS_12basic_stringIcNS_11char_traitsIcEENS1_IcEEEEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSA_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorINS_4pairIP7SCNNodeP8SkeletonEEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorINS_4pairIP9__C3DMeshP16__C3DMeshElementEEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorINS_6vectorI7CFRangeNS1_IS3_EEEEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS9_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorINS_6vectorIN10OpenSubdiv6v3_1_13Osd10PatchArrayENS1_IS6_EEEEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSC_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorINS_6vectorIN10OpenSubdiv6v3_1_13Osd10PatchParamENS1_IS6_EEEEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSC_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorINS_6vectorINS2_I7CFRangeNS1_IS3_EEEENS1_IS5_EEEEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorINS_6vectorIfNS1_IfEEEEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS8_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorINS_6vectorIiNS1_IiEEEEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS8_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIP10BlendShapeEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIP10SCNCActionEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIP11MaterialMapEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIP13TextureLookupEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIP15c3dPhysicsFieldEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIP19CAKeyframeAnimationEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIP21WireframeMeshInstanceEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIP4SkinEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIP7SCNNodeEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIP7UITouchEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIP8SkeletonEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIP9StatementEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIPKN10OpenSubdiv6v3_1_13Far12StencilTableEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIPN10OpenSubdiv6v3_1_13Vtr8internal10RefinementEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIPN10OpenSubdiv6v3_1_13Vtr8internal14FVarRefinementEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIPN10OpenSubdiv6v3_1_13Vtr8internal5LevelEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIPN10OpenSubdiv6v3_1_13Vtr8internal9FVarLevelEEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERSB_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIPU19objcproto9MTLBuffer11objc_objectEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS7_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIPiEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIdEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS5_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIfEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS5_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIiEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS5_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorIjEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS5_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorImEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS5_m
- __ZNSt3__119__allocate_at_leastB8nn190102INS_9allocatorItEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS5_m
- __ZNSt3__119__partial_sort_implB8nn190102INS_17_ClassicAlgPolicyER12__VolumeCompPsS4_EET1_S5_S5_T2_OT0_
- __ZNSt3__119__partial_sort_implB8nn190102INS_17_ClassicAlgPolicyER13__SphereZCompPsS4_EET1_S5_S5_T2_OT0_
- __ZNSt3__119__partial_sort_implB8nn190102INS_17_ClassicAlgPolicyER18CompareCornerAngleP13ClippedCornerS5_EET1_S6_S6_T2_OT0_
- __ZNSt3__119__partial_sort_implB8nn190102INS_17_ClassicAlgPolicyERNS_6__lessIvvEEPP9__C3DNodeS7_EET1_S8_S8_T2_OT0_
- __ZNSt3__119__partial_sort_implB8nn190102INS_17_ClassicAlgPolicyERNS_7greaterIiEEPiS5_EET1_S6_S6_T2_OT0_
- __ZNSt3__119__partial_sort_implB8nn190102INS_17_ClassicAlgPolicyERPFbRK9HitResultS4_EPS2_S8_EET1_S9_S9_T2_OT0_
- __ZNSt3__120get_temporary_bufferB8nn190102IN3C3D16PassIODescriptorEEENS_4pairIPT_lEEl
- __ZNSt3__122__tree_node_destructorINS_9allocatorINS_11__tree_nodeINS_12__value_typeINS_12basic_stringIcNS_11char_traitsIcEENS1_IcEEEENS_4pairIiiEEEEPvEEEEEclB8nn190102EPSD_
- __ZNSt3__122__tree_node_destructorINS_9allocatorINS_11__tree_nodeINS_12basic_stringIcNS_11char_traitsIcEENS1_IcEEEEPvEEEEEclB8nn190102EPS9_
- __ZNSt3__124__copy_move_unwrap_itersB8nn190102INS_11__copy_implINS_17_ClassicAlgPolicyEEENS_14__bit_iteratorINS_6vectorIbNS_9allocatorIbEEEELb0ELm0EEES9_S9_Li0EEENS_4pairIT0_T2_EESB_T1_SC_
- __ZNSt3__124__put_character_sequenceB8nn190102IcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_PKS4_m
- __ZNSt3__126__insertion_sort_unguardedB8nn190102INS_17_ClassicAlgPolicyER12__VolumeCompPsEEvT1_S5_T0_
- __ZNSt3__126__insertion_sort_unguardedB8nn190102INS_17_ClassicAlgPolicyER13__SphereZCompPsEEvT1_S5_T0_
- __ZNSt3__126__insertion_sort_unguardedB8nn190102INS_17_ClassicAlgPolicyERPFbRK9HitResultS4_EPS2_EEvT1_S9_T0_
- __ZNSt3__127__insertion_sort_incompleteB8nn190102INS_17_ClassicAlgPolicyER12__VolumeCompPsEEbT1_S5_T0_
- __ZNSt3__127__insertion_sort_incompleteB8nn190102INS_17_ClassicAlgPolicyER13__SphereZCompPsEEbT1_S5_T0_
- __ZNSt3__127__insertion_sort_incompleteB8nn190102INS_17_ClassicAlgPolicyER18CompareCornerAngleP13ClippedCornerEEbT1_S6_T0_
- __ZNSt3__127__insertion_sort_incompleteB8nn190102INS_17_ClassicAlgPolicyERNS_6__lessIvvEEPP9__C3DNodeEEbT1_S8_T0_
- __ZNSt3__127__insertion_sort_incompleteB8nn190102INS_17_ClassicAlgPolicyERNS_7greaterIiEEPiEEbT1_S6_T0_
- __ZNSt3__127__insertion_sort_incompleteB8nn190102INS_17_ClassicAlgPolicyERPFbRK9HitResultS4_EPS2_EEbT1_S9_T0_
- __ZNSt3__127__insertion_sort_incompleteB8nn190102INS_17_ClassicAlgPolicyERZN3C3D11RenderGraph26resolvePartialDependenciesEvE3$_0PNS3_4LinkEEEbT1_S8_T0_
- __ZNSt3__127__insertion_sort_incompleteB8nn190102INS_17_ClassicAlgPolicyERZN3C3D11RenderGraph8validateEvE3$_0PNS3_9PortsPairEEEbT1_S8_T0_
- __ZNSt3__127__tree_balance_after_insertB8nn190102IPNS_16__tree_node_baseIPvEEEEvT_S5_
- __ZNSt3__130__uninitialized_allocator_copyB8nn190102INS_9allocatorINS_12basic_stringIcNS_11char_traitsIcEENS1_IcEEEEEEPS6_S8_S8_EET2_RT_T0_T1_S9_
- __ZNSt3__131__partition_with_equals_on_leftB8nn190102INS_17_ClassicAlgPolicyEP13ClippedCornerR18CompareCornerAngleEET0_S6_S6_T1_
- __ZNSt3__131__partition_with_equals_on_leftB8nn190102INS_17_ClassicAlgPolicyEP9HitResultRPFbRKS2_S5_EEET0_S9_S9_T1_
- __ZNSt3__131__partition_with_equals_on_leftB8nn190102INS_17_ClassicAlgPolicyEPP9__C3DNodeRNS_6__lessIvvEEEET0_S8_S8_T1_
- __ZNSt3__131__partition_with_equals_on_leftB8nn190102INS_17_ClassicAlgPolicyEPiRNS_7greaterIiEEEET0_S6_S6_T1_
- __ZNSt3__131__partition_with_equals_on_leftB8nn190102INS_17_ClassicAlgPolicyEPsR12__VolumeCompEET0_S5_S5_T1_
- __ZNSt3__131__partition_with_equals_on_leftB8nn190102INS_17_ClassicAlgPolicyEPsR13__SphereZCompEET0_S5_S5_T1_
- __ZNSt3__132__partition_with_equals_on_rightB8nn190102INS_17_ClassicAlgPolicyEP13ClippedCornerR18CompareCornerAngleEENS_4pairIT0_bEES7_S7_T1_
- __ZNSt3__132__partition_with_equals_on_rightB8nn190102INS_17_ClassicAlgPolicyEP9HitResultRPFbRKS2_S5_EEENS_4pairIT0_bEESA_SA_T1_
- __ZNSt3__132__partition_with_equals_on_rightB8nn190102INS_17_ClassicAlgPolicyEPP9__C3DNodeRNS_6__lessIvvEEEENS_4pairIT0_bEES9_S9_T1_
- __ZNSt3__132__partition_with_equals_on_rightB8nn190102INS_17_ClassicAlgPolicyEPiRNS_7greaterIiEEEENS_4pairIT0_bEES7_S7_T1_
- __ZNSt3__132__partition_with_equals_on_rightB8nn190102INS_17_ClassicAlgPolicyEPsR12__VolumeCompEENS_4pairIT0_bEES6_S6_T1_
- __ZNSt3__132__partition_with_equals_on_rightB8nn190102INS_17_ClassicAlgPolicyEPsR13__SphereZCompEENS_4pairIT0_bEES6_S6_T1_
- __ZNSt3__134__uninitialized_allocator_relocateB8nn190102INS_9allocatorI11MaterialMapEES2_EEvRT_PT0_S7_S7_
- __ZNSt3__134__uninitialized_allocator_relocateB8nn190102INS_9allocatorI23C3DSubdivCPUPrimvarDataIDv2_fEEES4_EEvRT_PT0_S9_S9_
- __ZNSt3__134__uninitialized_allocator_relocateB8nn190102INS_9allocatorI23C3DSubdivCPUPrimvarDataIDv3_fEEES4_EEvRT_PT0_S9_S9_
- __ZNSt3__134__uninitialized_allocator_relocateB8nn190102INS_9allocatorI23C3DSubdivCPUPrimvarDataIDv4_fEEES4_EEvRT_PT0_S9_S9_
- __ZNSt3__134__uninitialized_allocator_relocateB8nn190102INS_9allocatorI27C3DSubdivCPUFVarPrimvarInfoEES2_EEvRT_PT0_S7_S7_
- __ZNSt3__134__uninitialized_allocator_relocateB8nn190102INS_9allocatorI27C3DSubdivGPUFVarPrimvarDataEES2_EEvRT_PT0_S7_S7_
- __ZNSt3__134__uninitialized_allocator_relocateB8nn190102INS_9allocatorI28C3DSubdivCPUPrimvarDataGroupEES2_EEvRT_PT0_S7_S7_
- __ZNSt3__134__uninitialized_allocator_relocateB8nn190102INS_9allocatorI8VariableEES2_EEvRT_PT0_S7_S7_
- __ZNSt3__134__uninitialized_allocator_relocateB8nn190102INS_9allocatorIN10OpenSubdiv6v3_1_13Far10PatchTable16FVarPatchChannelEEES6_EEvRT_PT0_SB_SB_
- __ZNSt3__14pairIKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES6_EC2B8nn190102ERKS8_
- __ZNSt3__14pairIKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES6_ED1Ev
- __ZNSt3__15dequeIiNS_9allocatorIiEEED2B8nn190102Ev
- __ZNSt3__16vectorI11MaterialMapNS_9allocatorIS1_EEE16__destroy_vectorclB8nn190102Ev
- __ZNSt3__16vectorI11MaterialMapNS_9allocatorIS1_EEE21__push_back_slow_pathIS1_EEPS1_OT_
- __ZNSt3__16vectorI11MaterialMapNS_9allocatorIS1_EEE7__clearB8nn190102Ev
- __ZNSt3__16vectorI16C3DSubdivCPUDataIDv2_fENS_9allocatorIS3_EEE11__vallocateB8nn190102Em
- __ZNSt3__16vectorI16C3DSubdivCPUDataIDv3_fENS_9allocatorIS3_EEE11__vallocateB8nn190102Em
- __ZNSt3__16vectorI16C3DSubdivCPUDataIDv4_fENS_9allocatorIS3_EEE11__vallocateB8nn190102Em
- __ZNSt3__16vectorI18SCNSemanticBindingNS_9allocatorIS1_EEE9push_backB8nn190102ERKS1_
- __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv2_fENS_9allocatorIS3_EEE16__destroy_vectorclB8nn190102Ev
- __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv2_fENS_9allocatorIS3_EEE21__push_back_slow_pathIRKS3_EEPS3_OT_
- __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv3_fENS_9allocatorIS3_EEE16__destroy_vectorclB8nn190102Ev
- __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv3_fENS_9allocatorIS3_EEE21__push_back_slow_pathIRKS3_EEPS3_OT_
- __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv4_fENS_9allocatorIS3_EEE16__destroy_vectorclB8nn190102Ev
- __ZNSt3__16vectorI23C3DSubdivCPUPrimvarDataIDv4_fENS_9allocatorIS3_EEE21__push_back_slow_pathIRKS3_EEPS3_OT_
- __ZNSt3__16vectorI27C3DSubdivCPUFVarPrimvarInfoNS_9allocatorIS1_EEE16__destroy_vectorclB8nn190102Ev
- __ZNSt3__16vectorI27C3DSubdivCPUFVarPrimvarInfoNS_9allocatorIS1_EEE21__push_back_slow_pathIS1_EEPS1_OT_
- __ZNSt3__16vectorI27C3DSubdivCPUFVarPrimvarInfoNS_9allocatorIS1_EEE7__clearB8nn190102Ev
- __ZNSt3__16vectorI27C3DSubdivCPUFVarPrimvarInfoNS_9allocatorIS1_EEE9push_backB8nn190102EOS1_
- __ZNSt3__16vectorI27C3DSubdivGPUFVarPrimvarDataNS_9allocatorIS1_EEE16__destroy_vectorclB8nn190102Ev
- __ZNSt3__16vectorI27C3DSubdivGPUFVarPrimvarDataNS_9allocatorIS1_EEE21__push_back_slow_pathIS1_EEPS1_OT_
- __ZNSt3__16vectorI27C3DSubdivGPUFVarPrimvarDataNS_9allocatorIS1_EEE9push_backB8nn190102EOS1_
- __ZNSt3__16vectorI27C3DSubdivisionOsdGPURefinerNS_9allocatorIS1_EEE11__vallocateB8nn190102Em
- __ZNSt3__16vectorI27C3DSubdivisionOsdGPURefinerNS_9allocatorIS1_EEEC2B8nn190102Em
- __ZNSt3__16vectorI28C3DSubdivCPUPrimvarDataGroupNS_9allocatorIS1_EEE16__destroy_vectorclB8nn190102Ev
- __ZNSt3__16vectorI30C3DSubdivisionOsdGPUPatchTableNS_9allocatorIS1_EEE11__vallocateB8nn190102Em
- __ZNSt3__16vectorI30C3DSubdivisionOsdGPUPatchTableNS_9allocatorIS1_EEEC2B8nn190102Em
- __ZNSt3__16vectorI5TokenNS_9allocatorIS1_EEE9push_backB8nn190102ERKS1_
- __ZNSt3__16vectorI7CFRangeNS_9allocatorIS1_EEE11__vallocateB8nn190102Em
- __ZNSt3__16vectorI7CFRangeNS_9allocatorIS1_EEEC2ERKS4_
- __ZNSt3__16vectorI8VariableNS_9allocatorIS1_EEE16__destroy_vectorclB8nn190102Ev
- __ZNSt3__16vectorI8VariableNS_9allocatorIS1_EEE21__push_back_slow_pathIS1_EEPS1_OT_
- __ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE11__vallocateB8nn190102Em
- __ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE11__vallocateB8nn190102Em
- __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Far10PatchTable10PatchArrayENS_9allocatorIS5_EEE9push_backB8nn190102EOS5_
- __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Far10PatchTable16FVarPatchChannelENS_9allocatorIS5_EEE16__destroy_vectorclB8nn190102Ev
- __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Osd10PatchArrayENS_9allocatorIS4_EEE11__vallocateB8nn190102Em
- __ZNSt3__16vectorIN10OpenSubdiv6v3_1_13Osd10PatchArrayENS_9allocatorIS4_EEE18__assign_with_sizeB8nn190102IPKS4_SA_EEvT_T0_l
- __ZNSt3__16vectorIN5vmesh8TriangleENS_9allocatorIS2_EEE11__vallocateB8nn190102Em
- __ZNSt3__16vectorIN5vmesh8TriangleENS_9allocatorIS2_EEE18__assign_with_sizeB8nn190102IPS2_S7_EEvT_T0_l
- __ZNSt3__16vectorINS0_I7CFRangeNS_9allocatorIS1_EEEENS2_IS4_EEE11__vallocateB8nn190102Em
- __ZNSt3__16vectorINS0_I7CFRangeNS_9allocatorIS1_EEEENS2_IS4_EEE16__destroy_vectorclB8nn190102Ev
- __ZNSt3__16vectorINS0_I7CFRangeNS_9allocatorIS1_EEEENS2_IS4_EEE16__init_with_sizeB8nn190102IPS4_S8_EEvT_T0_m
- __ZNSt3__16vectorINS0_I7CFRangeNS_9allocatorIS1_EEEENS2_IS4_EEE7__clearB8nn190102Ev
- __ZNSt3__16vectorINS0_I7CFRangeNS_9allocatorIS1_EEEENS2_IS4_EEEC2B8nn190102Em
- __ZNSt3__16vectorINS0_IN10OpenSubdiv6v3_1_13Osd10PatchArrayENS_9allocatorIS4_EEEENS5_IS7_EEE16__destroy_vectorclB8nn190102Ev
- __ZNSt3__16vectorINS0_IN10OpenSubdiv6v3_1_13Osd10PatchArrayENS_9allocatorIS4_EEEENS5_IS7_EEE7__clearB8nn190102Ev
- __ZNSt3__16vectorINS0_IN10OpenSubdiv6v3_1_13Osd10PatchParamENS_9allocatorIS4_EEEENS5_IS7_EEE16__destroy_vectorclB8nn190102Ev
- __ZNSt3__16vectorINS0_IN10OpenSubdiv6v3_1_13Osd10PatchParamENS_9allocatorIS4_EEEENS5_IS7_EEE7__clearB8nn190102Ev
- __ZNSt3__16vectorINS0_INS0_I7CFRangeNS_9allocatorIS1_EEEENS2_IS4_EEEENS2_IS6_EEE11__vallocateB8nn190102Em
- __ZNSt3__16vectorINS0_INS0_I7CFRangeNS_9allocatorIS1_EEEENS2_IS4_EEEENS2_IS6_EEE16__destroy_vectorclB8nn190102Ev
- __ZNSt3__16vectorINS0_INS0_I7CFRangeNS_9allocatorIS1_EEEENS2_IS4_EEEENS2_IS6_EEEC2B8nn190102EmRKS6_
- __ZNSt3__16vectorINS0_IfNS_9allocatorIfEEEENS1_IS3_EEE16__destroy_vectorclB8nn190102Ev
- __ZNSt3__16vectorINS0_IfNS_9allocatorIfEEEENS1_IS3_EEE7__clearB8nn190102Ev
- __ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE16__destroy_vectorclB8nn190102Ev
- __ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE7__clearB8nn190102Ev
- __ZNSt3__16vectorINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS4_IS6_EEE11__vallocateB8nn190102Em
- __ZNSt3__16vectorINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS4_IS6_EEE16__destroy_vectorclB8nn190102Ev
- __ZNSt3__16vectorINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS4_IS6_EEE18__assign_with_sizeB8nn190102IPS6_SA_EEvT_T0_l
- __ZNSt3__16vectorINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS4_IS6_EEE21__push_back_slow_pathIRKS6_EEPS6_OT_
- __ZNSt3__16vectorINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS4_IS6_EEE7__clearB8nn190102Ev
- __ZNSt3__16vectorIP19CAKeyframeAnimationNS_9allocatorIS2_EEE11__vallocateB8nn190102Em
- __ZNSt3__16vectorIP19CAKeyframeAnimationNS_9allocatorIS2_EEE18__assign_with_sizeB8nn190102IPS2_S7_EEvT_T0_l
- __ZNSt3__16vectorIP19CAKeyframeAnimationNS_9allocatorIS2_EEE9push_backB8nn190102ERKS2_
- __ZNSt3__16vectorIP9StatementNS_9allocatorIS2_EEE11__vallocateB8nn190102Em
- __ZNSt3__16vectorIP9StatementNS_9allocatorIS2_EEEC2ERKS5_
- __ZNSt3__16vectorIbNS_9allocatorIbEEE11__vallocateB8nn190102Em
- __ZNSt3__16vectorIdNS_9allocatorIdEEE11__vallocateB8nn190102Em
- __ZNSt3__16vectorIfNS_9allocatorIfEEE11__vallocateB8nn190102Em
- __ZNSt3__16vectorIfNS_9allocatorIfEEEC2ERKS3_
- __ZNSt3__16vectorIiNS_9allocatorIiEEE11__vallocateB8nn190102Em
- __ZNSt3__16vectorIiNS_9allocatorIiEEE18__assign_with_sizeB8nn190102IPKiS6_EEvT_T0_l
- __ZNSt3__16vectorIiNS_9allocatorIiEEE18__insert_with_sizeB8nn190102IPKiS6_EENS_11__wrap_iterIPiEENS7_IS6_EET_T0_l
- __ZNSt3__16vectorIiNS_9allocatorIiEEEC2ERKS3_
- __ZNSt3__16vectorIjNS_9allocatorIjEEE11__vallocateB8nn190102Em
- __ZNSt3__16vectorIjNS_9allocatorIjEEEC2ERKS3_
- __ZNSt3__16vectorItNS_9allocatorItEEE11__vallocateB8nn190102Em
- __ZNSt3__17__sort3B8nn190102INS_17_ClassicAlgPolicyER12__VolumeCompPsEEjT1_S5_S5_T0_
- __ZNSt3__17__sort3B8nn190102INS_17_ClassicAlgPolicyER13__SphereZCompPsEEjT1_S5_S5_T0_
- __ZNSt3__17__sort3B8nn190102INS_17_ClassicAlgPolicyER18CompareCornerAngleP13ClippedCornerEEjT1_S6_S6_T0_
- __ZNSt3__17__sort3B8nn190102INS_17_ClassicAlgPolicyERNS_6__lessIvvEEPP9__C3DNodeEEjT1_S8_S8_T0_
- __ZNSt3__17__sort3B8nn190102INS_17_ClassicAlgPolicyERNS_7greaterIiEEPiEEjT1_S6_S6_T0_
- __ZNSt3__17__sort3B8nn190102INS_17_ClassicAlgPolicyERPFbRK9HitResultS4_EPS2_EEjT1_S9_S9_T0_
- __ZNSt3__17__sort3B8nn190102INS_17_ClassicAlgPolicyERZN3C3D11RenderGraph26resolvePartialDependenciesEvE3$_0PNS3_4LinkEEEjT1_S8_S8_T0_
- __ZNSt3__17__sort3B8nn190102INS_17_ClassicAlgPolicyERZN3C3D11RenderGraph8validateEvE3$_0PNS3_9PortsPairEEEjT1_S8_S8_T0_
- __ZNSt3__17__sort4B8nn190102INS_17_ClassicAlgPolicyER12__VolumeCompPsEEvT1_S5_S5_S5_T0_
- __ZNSt3__17__sort4B8nn190102INS_17_ClassicAlgPolicyER13__SphereZCompPsEEvT1_S5_S5_S5_T0_
- __ZNSt3__17__sort4B8nn190102INS_17_ClassicAlgPolicyER18CompareCornerAngleP13ClippedCornerEEvT1_S6_S6_S6_T0_
- __ZNSt3__17__sort4B8nn190102INS_17_ClassicAlgPolicyERNS_6__lessIvvEEPP9__C3DNodeEEvT1_S8_S8_S8_T0_
- __ZNSt3__17__sort4B8nn190102INS_17_ClassicAlgPolicyERPFbRK9HitResultS4_EPS2_EEvT1_S9_S9_S9_T0_
- __ZNSt3__17__sort4B8nn190102INS_17_ClassicAlgPolicyERZN3C3D11RenderGraph26resolvePartialDependenciesEvE3$_0PNS3_4LinkEEEvT1_S8_S8_S8_T0_
- __ZNSt3__17__sort4B8nn190102INS_17_ClassicAlgPolicyERZN3C3D11RenderGraph8validateEvE3$_0PNS3_9PortsPairEEEvT1_S8_S8_S8_T0_
- __ZNSt3__17__sort5B8nn190102INS_17_ClassicAlgPolicyER12__VolumeCompPsEEvT1_S5_S5_S5_S5_T0_
- __ZNSt3__17__sort5B8nn190102INS_17_ClassicAlgPolicyER13__SphereZCompPsEEvT1_S5_S5_S5_S5_T0_
- __ZNSt3__17__sort5B8nn190102INS_17_ClassicAlgPolicyER18CompareCornerAngleP13ClippedCornerEEvT1_S6_S6_S6_S6_T0_
- __ZNSt3__17__sort5B8nn190102INS_17_ClassicAlgPolicyERNS_6__lessIvvEEPP9__C3DNodeEEvT1_S8_S8_S8_S8_T0_
- __ZNSt3__17__sort5B8nn190102INS_17_ClassicAlgPolicyERPFbRK9HitResultS4_EPS2_EEvT1_S9_S9_S9_S9_T0_
- __ZNSt3__18__rotateB8nn190102INS_17_ClassicAlgPolicyEPN3C3D16PassIODescriptorES4_EENS_4pairIT0_S6_EES6_S6_T1_
- __ZNSt3__19__sift_upB8nn190102INS_17_ClassicAlgPolicyER12__VolumeCompPsEEvT1_S5_OT0_NS_15iterator_traitsIS5_E15difference_typeE
- __ZNSt3__19__sift_upB8nn190102INS_17_ClassicAlgPolicyER13__SphereZCompPsEEvT1_S5_OT0_NS_15iterator_traitsIS5_E15difference_typeE
- __ZNSt3__19__sift_upB8nn190102INS_17_ClassicAlgPolicyER18CompareCornerAngleP13ClippedCornerEEvT1_S6_OT0_NS_15iterator_traitsIS6_E15difference_typeE
- __ZNSt3__19__sift_upB8nn190102INS_17_ClassicAlgPolicyERPFbRK9HitResultS4_EPS2_EEvT1_S9_OT0_NS_15iterator_traitsIS9_E15difference_typeE
- __ZNSt3__19allocatorI23C3DSubdivCPUPrimvarDataIDv2_fEE7destroyB8nn190102EPS3_
- __ZNSt3__19allocatorI23C3DSubdivCPUPrimvarDataIDv3_fEE7destroyB8nn190102EPS3_
- __ZNSt3__19allocatorI23C3DSubdivCPUPrimvarDataIDv4_fEE7destroyB8nn190102EPS3_
- __ZNSt3__19allocatorI27C3DSubdivGPUFVarPrimvarDataE7destroyB8nn190102EPS1_
- __ZNSt3__19allocatorI28C3DSubdivCPUPrimvarDataGroupE7destroyB8nn190102EPS1_
- __ZNSt3__19allocatorI28C3DSubdivCPUPrimvarDataGroupE9constructB8nn190102IS1_JS1_EEEvPT_DpOT0_
- __ZNSt3__19allocatorI8VariableE7destroyB8nn190102EPS1_
- __ZNSt3__19allocatorIN10OpenSubdiv6v3_1_13Far10PatchTable16FVarPatchChannelEE7destroyB8nn190102EPS5_
- __ZNSt3__1eqB8nn190102IcNS_11char_traitsIcEENS_9allocatorIcEEEEbRKNS_12basic_stringIT_T0_T1_EEPKS6_
- __ZSt28__throw_bad_array_new_lengthB8nn190102v
- ___153-[SCNCommonProfileProgramGeneratorMetal splitInputOutputStructsIfNeededForSourceCode:generatedFromReplacementStrings:perPixelLighting:clipDistanceCount:]_block_invoke
- ___87-[SCNMTLResourceManager(Compilation) _createPipelineStateWithDescriptor:desc:pipeline:]_block_invoke.8
- ____ZL17__renderToTexturePU45objcproto34SCNMaterialPropertyTextureProvider11objc_objectPU21objcproto10MTLTexture11objc_objectPU51objcproto40SCNMaterialPropertyTextureProviderHelper11objc_objectP19SCNMTLRenderContext_block_invoke.72
- ____ZL17__renderToTexturePU45objcproto34SCNMaterialPropertyTextureProvider11objc_objectPU21objcproto10MTLTexture11objc_objectPU51objcproto40SCNMaterialPropertyTextureProviderHelper11objc_objectP19SCNMTLRenderContext_block_invoke.72.cold.1
- ____ZL17__renderToTexturePU45objcproto34SCNMaterialPropertyTextureProvider11objc_objectPU21objcproto10MTLTexture11objc_objectPU51objcproto40SCNMaterialPropertyTextureProviderHelper11objc_objectP19SCNMTLRenderContext_block_invoke.75
- ____ZL17__renderToTexturePU45objcproto34SCNMaterialPropertyTextureProvider11objc_objectPU21objcproto10MTLTexture11objc_objectPU51objcproto40SCNMaterialPropertyTextureProviderHelper11objc_objectP19SCNMTLRenderContext_block_invoke.75.cold.1
- ____ZL49C3DSubdivisionOsdGPURuntimeDataCreateWithGeometryP13__C3DGeometryP18__C3DEngineContextRK36C3DSubdivisionOsdGPUSubdivParametersP21SCNMTLResourceManagerPU26objcproto15MTLCommandQueue11objc_objectU13block_pointerFvPU27objcproto16MTLCommandBuffer11objc_objectbE_block_invoke.530
- ____ZL49C3DSubdivisionOsdGPURuntimeDataCreateWithGeometryP13__C3DGeometryP18__C3DEngineContextRK36C3DSubdivisionOsdGPUSubdivParametersP21SCNMTLResourceManagerPU26objcproto15MTLCommandQueue11objc_objectU13block_pointerFvPU27objcproto16MTLCommandBuffer11objc_objectbE_block_invoke.530.cold.1
- ____ZL49C3DSubdivisionOsdGPURuntimeDataCreateWithGeometryP13__C3DGeometryP18__C3DEngineContextRK36C3DSubdivisionOsdGPUSubdivParametersP21SCNMTLResourceManagerPU26objcproto15MTLCommandQueue11objc_objectU13block_pointerFvPU27objcproto16MTLCommandBuffer11objc_objectbE_block_invoke.530.cold.2
- ____ZL49C3DSubdivisionOsdGPURuntimeDataCreateWithGeometryP13__C3DGeometryP18__C3DEngineContextRK36C3DSubdivisionOsdGPUSubdivParametersP21SCNMTLResourceManagerPU26objcproto15MTLCommandQueue11objc_objectU13block_pointerFvPU27objcproto16MTLCommandBuffer11objc_objectbE_block_invoke.530.cold.3
- ___block_literal_global.506
- ___block_literal_global.517
- ___block_literal_global.519
- ___block_literal_global.521
- ___block_literal_global.523
- ___block_literal_global.525
- ___block_literal_global.527
- ___block_literal_global.634
- _objc_msgSend$scn_decodeArrayOfObjectsOfClasses:forKey:
- _objc_msgSend$splitInputOutputStructsIfNeededForSourceCode:generatedFromReplacementStrings:perPixelLighting:clipDistanceCount:
- _wmemchr
CStrings:
+ "\n\n\n\n\n#include <TargetConditionals.h>\n\n\n#if TARGET_OS_OSX || TARGET_OS_MACCATALYST\n    \n    \n    #define SHOULD_CHECK_IF_OUTSIDE_TEXTURE  0\n    #define RETURN_IF_OUTSIDE_TEXTURE(dst)\n    #define RETURN_IF_OUTSIDE_TEXTURE3D(dst)\n#else\n    #define SHOULD_CHECK_IF_OUTSIDE_TEXTURE  1\n    #define RETURN_IF_OUTSIDE_TEXTURE(dst)   if ((index.x >= dst.get_width()) || (index.y >= dst.get_height())) return;\n    #define RETURN_IF_OUTSIDE_TEXTURE3D(dst) if ((index.x >= dst.get_width()) || (index.y >= dst.get_height()) || (index.z >= dst.get_depth())) return;\n#endif\n\n#if __METAL_VERSION__ >= 220\n    #define SUPPORTS_LAYERED_RENDERING           1\n    #define SUPPORTS_MULTIPLE_VIEWPORT_RENDERING 1\n#else\n    #if TARGET_OS_OSX || TARGET_OS_MACCATALYST\n        #define SUPPORTS_LAYERED_RENDERING           (__METAL_VERSION__ >= 200)\n        #define SUPPORTS_MULTIPLE_VIEWPORT_RENDERING (__METAL_VERSION__ >= 200)\n    #else\n        #define SUPPORTS_LAYERED_RENDERING           (__METAL_VERSION__ >= 210)\n        #define SUPPORTS_MULTIPLE_VIEWPORT_RENDERING (__METAL_VERSION__ >= 210)\n    #endif\n#endif\n\n\n\nnamespace scn {\n    \n    \n    static inline float4 reduce_op(float4 d0, float4 d1)\n    {\n        d0.x = min(d0.x, d1.x);\n        d0.y = max(d0.y, d1.y);\n        d0.z += d1.z;\n        d0.w += d1.w;\n        return d0;\n    }\n    \n    inline float vector_reduce_min(float4 v)\n    {\n        float2 min_lh = min(v.xy, v.zw);\n        return min(min_lh.x, min_lh.y);\n    }\n    \n    inline float vector_reduce_max(float4 v)\n    {\n        float2 max_lh = max(v.xy, v.zw);\n        return max(max_lh.x, max_lh.y);\n    }\n    \n    inline int vector_reduce_add(int4 v)\n    {\n        int2 add_lh = v.xy + v.zw;\n        return add_lh.x + add_lh.y;\n    }\n    \n    inline float3x3 mat3(float4x4 mat4)\n    {\n        return float3x3(mat4[0].xyz, mat4[1].xyz, mat4[2].xyz);\n    }\n    \n    inline float3 mat4_mult_float3_normalized(float4x4 matrix, float3 src)\n    {\n        float3 dst  =  src.xxx * matrix[0].xyz;\n        dst         += src.yyy * matrix[1].xyz;\n        dst         += src.zzz * matrix[2].xyz;\n        return normalize(dst);\n    }\n    \n    inline float3 mat4_mult_float3(float4x4 matrix, float3 src)\n    {\n        float3 dst  =  src.xxx * matrix[0].xyz;\n        dst         += src.yyy * matrix[1].xyz;\n        dst         += src.zzz * matrix[2].xyz;\n        return dst;\n    }\n\n    inline float3 matrix_rotate(float4x4 mat, float3 dir)\n    {\n        return  dir.xxx * mat[0].xyz +\n                dir.yyy * mat[1].xyz +\n                dir.zzz * mat[2].xyz;\n    }\n\n    inline float4 matrix_transform(float4x4 mat, float3 pos)\n    {\n        return  pos.xxxx * mat[0] +\n                pos.yyyy * mat[1] +\n                pos.zzzz * mat[2] +\n                           mat[3];\n    }\n\n    inline float3 quaternion_rotate_vector(float4 q, float3 v)\n    {\n        float3 t = 2.f * cross(q.xyz, v);\n        return v + q.w * t + cross(q.xyz, t);\n    }\n\n    \n    template <class T>\n    inline vec<T, 3> robust_normalize(vec<T, 3> v)\n    {\n        vec<T, 3> zero = 0.;\n        return all(v == zero) ? zero : normalize(v);\n    }\n\n    template <class T>\n    inline void generate_basis(vec<T, 3> inR, thread vec<T, 3> *outS, thread vec<T, 3> *outT)\n    {\n        \n        T x  = -inR.x;\n        T y  = inR.y;\n        T z  = inR.z;\n        T sz = copysign(T(1.), z);\n        T a  = y / (abs(z) + T(1.));\n        T b  = y * a;\n        T c  = x * a;\n        *outS = (vec<T, 3>){ z + sz * b,  sz * c,       x       };\n        *outT = (vec<T, 3>){ c,           T(1.) - b,    -sz * y };\n    }\n    \n    \n    \n    inline float3 blend_add(float3 base, float3 blend)\n    {\n        return min(base + blend, 1.0);\n    }\n    \n    inline float3 blend_lighten(float3 base, float3 blend)\n    {\n        return max(blend, base);\n    }\n    \n    inline float3 blend_screen(float3 base, float3 blend)\n    {\n        return (1.0 - ((1.0 - base) * (1.0 - blend)));\n    }\n\n    \n    \n    inline half sq(half f) {\n        return f * f;\n    }\n\n    inline float sq(float f) {\n        return f * f;\n    }\n    \n    inline float2 sincos(float angle) {\n        float cs;\n        float sn = ::sincos(angle, cs);\n        return float2(sn, cs);\n    }\n    \n    \n    inline float acos_fast(float f) {\n        float x = abs(f);\n        float res = -0.156583f * x + M_PI_2_F;\n        res *= sqrt(1.0f - x);\n        return (f >= 0.f) ? res : M_PI_F - res;\n    }\n\n    inline float asin_fast(float f)\n    {\n        return M_PI_2_F - acos_fast(f);\n    }\n\n    \n    inline float atan_fast(float inX)\n    {\n        float  x = inX;\n        return x*(-0.1784f * abs(x) - 0.0663f * x * x + 1.0301f);\n    }\n    \n    inline float atan2_fast(float y, float x)\n    {\n        float sx = x > 0.f ? -1.f : 1.f;\n        float abs_y = abs(y) + 1e-10f; \n        float r = (x + abs_y*sx) / (abs_y - x*sx);\n        float angle = sx * M_PI_4_F + M_PI_2_F;\n        angle      += (0.1963f * r * r - 0.9817f) * r;\n        return y > 0.f ? angle : -angle;\n    }\n    \n    \n    template <class T>\n    inline vec<T, 3> cartesian_from_spherical(vec<T, 2> uv)\n    {\n        \n        \n        T cos_phi;\n        T phi = uv.x * 2.0f * M_PI_F;\n        T sin_phi = ::sincos(phi, cos_phi);\n        \n        T cos_theta;\n        T theta     = uv.y * M_PI_F;\n        T sin_theta = ::sincos(theta, cos_theta);\n\n        return vec<T, 3>(cos_phi * sin_theta,\n                         cos_theta,\n                         -sin_phi * sin_theta);\n    }\n\n    inline float2 spherical_from_cartesian(float3 dir)\n    {\n        return float2( atan2(-dir.z, dir.x) * (0.5f * M_1_PI_F), acos(dir.y) * M_1_PI_F);\n    }\n\n    inline half2 spherical_from_cartesian(half3 dir)\n    {\n        return half2(atan2(-dir.z, dir.x) * 0.5h, acos(dir.y)) * M_1_PI_H;\n    }\n\n    inline float2 spherical_from_cartesian_fast(float3 dir)\n    {\n        return float2( atan2_fast(-dir.z, dir.x) * (0.5f * M_1_PI_F), acos_fast(dir.y) * M_1_PI_F);\n    }\n\n    inline half2 spherical_from_cartesian_fast(half3 dir)\n    {\n        return half2( atan2_fast(-dir.z, dir.x) * 0.5h, acos_fast(dir.y)) * M_1_PI_H;\n    }\n\n    #define dual_contract_factor  1.0\n\n    template <class T>\n    inline vec<T, 2> dual_paraboloid_from_cartesian(vec<T, 3> dir)\n    {\n        dir.xy /= abs(dir.z) + 1.0;\n\n        dir.y = 0.5 - dir.y * 0.5;\n        T s   = sign(dir.z) * 0.25;\n        dir.x = s * (dir.x - 1.0) + 0.5;\n        return dir.xy;\n    }\n    \n    \n    template <class T>\n    inline vec<T, 3> cartesian_from_dual_paraboloid(vec<T, 2>  uv)\n    {\n        \n        T zside = 0.5 * sign(0.5 - uv.x);\n        uv.x = 1.0 - abs(4.0 * uv.x - 2.0); \n        uv.y   = 1.0 - uv.y * 2.0;\n        T z = length_squared(uv); \n        z = (1.0 - z) * zside;\n        \n        return vec<T, 3>(uv.x, uv.y, z);\n    }\n\n    inline float reduce_min(float3 v) {\n        return min(v.x, min(v.y, v.z));\n    }\n    \n    inline float reduce_min(float4 v) {\n        return min(min(v.x, v.y), min(v.z, v.w));\n    }\n\n    inline float reduce_max(float3 v) {\n        return max(v.x, max(v.y, v.z));\n    }\n\n    inline float reduce_max(float4 v) {\n        return max(max(v.x, v.y), max(v.z, v.w));\n    }\n    \n    inline float3 randomSphereDir(float2 rnd)\n    {\n        float s = rnd.x * M_PI_F * 2.f;\n        float t = rnd.y * 2.f - 1.f;\n        return float3(sin(s), cos(s), t) / sqrt(1.f + t * t);\n    }\n    \n    \n    template <class T>\n    inline T interleaved_gradient_noise(vec<T, 2> pos)\n    {\n        vec<T, 3> magic( 0.06711056f, 0.00583715f, 52.9829189f );\n        return fract( magic.z * fract( dot( pos, magic.xy ) ) );\n    }\n    \n    inline float3 hemisphere_reflect(float3 v, float3 nrm)\n    {\n        return v * sign(dot(v, nrm));\n    }\n    \n    inline float3 randomHemisphereDir(float3 dir, float2 rnd)\n    {\n        return hemisphere_reflect(randomSphereDir( rnd ), dir);\n    }\n    \n    inline void orthogonal_basis(float3 n, thread float3& xp, thread float3& yp)\n    {\n        \n        float sz = n.z >= 0.f ? 1.f : -1.f;\n        float a  =  n.y / (1.f + abs(n.z));\n        float b  =  n.y * a;\n        float c  = -n.x * a;\n        \n        xp = float3(n.z + sz * b,   sz * c,     -n.x);\n        yp = float3(c,              1.f - b,    -sz * n.y);\n    }\n\n    template <class U>\n    inline float2 normalized_coordinate(ushort2 index, U texture)\n    {\n        uint width  = texture.get_width();\n        uint height = texture.get_height();\n        \n        float u = width  == 1 ? 0.5f : float(index.x) / float(width - 1);\n        float v = height == 1 ? 0.5f : float(index.y) / float(height - 1);\n        \n        return float2(u, v);\n    }\n\n    template <class U>\n    inline float2 normalized_coordinate(uint2 index, U texture)\n    {\n        uint width  = texture.get_width();\n        uint height = texture.get_height();\n        \n        float u = width  == 1 ? 0.5f : float(index.x) / float(width - 1);\n        float v = height == 1 ? 0.5f : float(index.y) / float(height - 1);\n        \n        return float2(u, v);\n    }\n\n    template <class U>\n    inline half2 normalized_coordinate_half(uint2 index, U texture)\n    {\n        uint width  = texture.get_width();\n        uint height = texture.get_height();\n        \n        half u = width  == 1 ? 0.5h : half(index.x) / half(width - 1);\n        half v = height == 1 ? 0.5h : half(index.y) / half(height - 1);\n        \n        return half2(u, v);\n    }\n\n    \n\n    template <class T>\n    inline vec<T, 3> cubemap_dir_from_sampleCoord(uint face, vec<T, 2> sampleCoord) \n    {\n        switch(face) {\n            case 0: \n                return vec<T, 3>( 1.0, -sampleCoord.y, -sampleCoord.x);\n\n            case 1: \n                return vec<T, 3>(-1.0, -sampleCoord.y,  sampleCoord.x);\n\n            case 2: \n                return vec<T, 3>(sampleCoord.x,  1.0,  sampleCoord.y);\n\n            case 3: \n                return vec<T, 3>(sampleCoord.x, -1.0, -sampleCoord.y);\n\n            case 4: \n                return vec<T, 3>( sampleCoord.x, -sampleCoord.y,  1.0);\n\n            default: \n                return vec<T, 3>(-sampleCoord.x, -sampleCoord.y, -1.0);\n        }\n    }\n\n    \n    template <class T>\n    inline T signed_unit(T uv) {\n        return uv * 2.0 - 1.0;\n    }\n\n    \n    template <class T>\n    inline T unsigned_unit(T uv) {\n        return uv * 0.5 + 0.5;\n    }\n\n    template <class T>\n    inline vec<T, 3> cubemap_dir_from_uv(uint face, vec<T, 2> uv) \n    {\n        return cubemap_dir_from_sampleCoord(face, signed_unit(uv));\n    }\n\n    template <class T>\n    inline vec<T, 3> cubemap_dir_from_uv_unit(uint face, vec<T, 2> uv) \n    {\n        return normalize(cubemap_dir_from_uv(face, uv));\n    }\n\n    \n    \n    inline float2 barycentric_mix(float2 __x, float2 __y, float2 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }\n    inline float3 barycentric_mix(float3 __x, float3 __y, float3 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }\n    inline float4 barycentric_mix(float4 __x, float4 __y, float4 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }\n    \n    static inline float rect(float2 lt, float2 rb, float2 uv)\n    {\n        float2 borders = step(lt, uv) * step(uv, rb);\n        return borders.x * borders.y;\n    }\n    \n    inline half4 debugColorForCascade(int cascade)\n    {\n        switch (cascade) {\n            case 0:\n            return half4(1.h, 0.h, 0.h, 1.h);\n            case 1:\n            return half4(0.9, 0.5, 0., 1.);\n            case 2:\n            return half4(1., 1., 0., 1.);\n            case 3:\n            return half4(0., 1., 0., 1.);\n            default:\n            return half4(0., 0., 0., 1.);\n        }\n    }\n\n    inline half3 debugColorForFace(int count)\n    {\n        switch (count) {\n            case 0:  return half3(1.0h, 0.1h, 0.1h);\n            case 1:  return half3(0.1h, 1.0h, 1.0h);\n            case 2:  return half3(0.1h, 1.0h, 0.1h);\n            case 3:  return half3(1.0h, 0.1h, 1.0h);\n            case 4:  return half3(0.1h, 0.1h, 1.0h);\n            default: return half3(1.0h, 1.0h, 0.1h);\n        }\n    }\n\n    inline half4 debugColorForCount(int count)\n    {\n        switch (count) {\n            case 0: return half4(0.0h, 0.0h, 0.0h, 1.h);\n            case 1: return half4(0.0h, 0.0h, 0.4h, 1.h);\n            case 2: return half4(0.0h, 0.0h, 0.9h, 1.h);\n            case 3: return half4(0.0h, 0.4h, 0.7h, 1.h);\n            case 4: return half4(0.0h, 0.9h, 0.4h, 1.h);\n            case 5: return half4(0.0h, 0.9h, 0.0h, 1.h);\n            case 6: return half4(0.4h, 0.7h, 0.0h, 1.h);\n            case 7: return half4(0.9h, 0.7h, 0.0h, 1.h);\n            default: return half4(1., 0., 0., 1.);\n        }\n    }\n\n    inline float grid(float2 lt, float2 rb, float2 gridSize, float thickness, float2 uv)\n    {\n        float insideRect = rect(lt, rb + thickness, uv);\n        float2 gt = thickness * gridSize;\n        float2 lines = step(abs(lt - fract(uv * gridSize)), gt);\n        return insideRect * (lines.x + lines.y);\n    }\n\n    inline float checkerboard(float2 gridSize, float2 uv)\n    {\n        float2 check = floor(uv * gridSize);\n        return step(fmod(check.x + check.y, 2.f), 0.f);\n    }\n\n    \n    \n    inline float luminance(float3 color)\n    {\n        \n        \n        return color.r * 0.212671 + color.g * 0.715160 + color.b * 0.072169;\n    }\n    \n    inline float srgb_to_linear(float c)\n    {\n        return (c <= 0.04045f) ? c / 12.92f : powr((c + 0.055f) / 1.055f, 2.4f);\n    }\n    \n    inline half srgb_to_linear_fast(half c)\n    {\n        return powr(c, 2.2h);\n    }\n    \n    inline half3 srgb_to_linear_fast(half3 c)\n    {\n        return powr(c, 2.2h);\n    }\n    \n    inline half srgb_to_linear(half c)\n    {\n        \n        return (c <= 0.04045h) ? (c * 0.0773993808h) :  powr(0.9478672986h * c + 0.05213270142h, 2.4h);\n    }\n    \n    inline float3 srgb_to_linear(float3 c)\n    {\n        return float3(srgb_to_linear(c.x), srgb_to_linear(c.y), srgb_to_linear(c.z));\n    }\n    \n    inline float linear_to_srgb(float c)\n    {\n        return (c < 0.0031308f) ? (12.92f * c) : (1.055f * powr(c, 1.f/2.4f) - 0.055f);\n    }\n    \n    inline float3 linear_to_srgb(float3 v) { \n        return float3(linear_to_srgb(v.x), linear_to_srgb(v.y), linear_to_srgb(v.z));\n    }\n    \n}\n\n\n\ntemplate <typename T>\ninline T dFdx(T v) {\n    return dfdx(v);\n}\n\n\ntemplate <typename T>\ninline T dFdy(T v) {\n    return -dfdy(v);\n}\n\n\n\ninline float4 texture2DProj(texture2d<float> tex, sampler smp, float4 uv)\n{\n    return tex.sample(smp, uv.xy / uv.w);\n}\n\ninline half4 texture2DProj(texture2d<half> tex, sampler smp, float4 uv)\n{\n    return tex.sample(smp, uv.xy / uv.w);\n}\n\nstatic constexpr sampler scn_shadow_sampler_rev_z = sampler(coord::normalized, filter::linear, mip_filter::none, address::clamp_to_zero, compare_func::less_equal);\nstatic constexpr sampler scn_shadow_sampler_ord_z = sampler(coord::normalized, filter::linear, mip_filter::none, address::clamp_to_edge, compare_func::greater_equal);\n\n#if defined(USE_REVERSE_Z) && USE_REVERSE_Z\nstatic constexpr sampler scn_shadow_sampler = scn_shadow_sampler_rev_z;\n#else\nstatic constexpr sampler scn_shadow_sampler = scn_shadow_sampler_ord_z;\n#endif\n\ninline float shadow2D(sampler shadow_sampler, depth2d<float> tex, float3 uv)\n{\n    return tex.sample_compare(shadow_sampler, uv.xy, uv.z);\n}\n\ninline float shadow2DProj(sampler shadow_sampler, depth2d<float> tex, float4 uv)\n{\n    float3 uvp = uv.xyz / uv.w;\n    return tex.sample_compare(shadow_sampler, uvp.xy, uvp.z);\n}\n\ninline float shadow2DArray(sampler shadow_sampler, depth2d_array<float> tex, float3 uv, uint slice)\n{\n    return tex.sample_compare(shadow_sampler, uv.xy, slice, uv.z);\n}\n\ninline float shadow2DArrayProj(sampler shadow_sampler, depth2d_array<float> tex, float4 uv, uint slice)\n{\n    float3 uvp = uv.xyz / uv.w;\n    return tex.sample_compare(shadow_sampler, uvp.xy, slice, uvp.z);\n}\n\n\n\ninline float4 transformViewPosInShadowSpace(float3 pos, float4x4 shadowMatrix, bool reverseZ)\n{\n    \n    float4 lightScreen =  shadowMatrix * float4(pos, 1.f);\n    \n    \n    \n    if (!reverseZ) {\n        lightScreen.z = min(lightScreen.z, 0.9999f * lightScreen.w);\n    } else {\n        if (lightScreen.z <= 0.0) { \n            lightScreen.z = 2.0;\n        }\n\n    }\n\n    return lightScreen;\n}\n\ninline float ComputeShadow(sampler shadow_sampler, float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap, bool reverseZ)\n{\n    float4 lightScreen =  transformViewPosInShadowSpace(worldPos, shadowMatrix, reverseZ);\n\n    float shadow = shadow2DProj(shadow_sampler, shadowMap, lightScreen);\n\n    \n    shadow *= step(0., lightScreen.w);\n    \n    return shadow;\n}\n\ninline float ComputeSoftShadowGrid(sampler shadow_sampler, float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap, int sampleCount, bool reverseZ)\n{\n    float4 lightScreen =  transformViewPosInShadowSpace(worldPos, shadowMatrix, reverseZ);\n\n    \n    float shadow;\n    if (sampleCount <= 1) {\n        shadow = shadow2DProj(shadow_sampler, shadowMap, lightScreen);\n    } else {\n\n        float3 uvp = lightScreen.xyz / lightScreen.w;\n        uvp.z += reverseZ ? 0.005f : -0.005f; \n\n        float2 texelSize = 2.f / float2(shadowMap.get_width(), shadowMap.get_height());\n        float2 origin    = uvp.xy - (sampleCount * 0.5f) * texelSize;\n\n        \n        if (sampleCount <= 4) { \n            half totalAccum = 0.h;\n            for (int y = 0; y < sampleCount; ++y) {\n                for (int x = 0; x < sampleCount; ++x) {\n                    totalAccum  += half(shadowMap.sample_compare(shadow_sampler, origin, uvp.z, 2 * int2(x,y)));\n                }\n            }\n            shadow = totalAccum / half(sampleCount * sampleCount);\n        } else {\n            float totalAccum = 0.f;\n            for (int y = 0; y < sampleCount; ++y) {\n                for (int x = 0; x < sampleCount; ++x) {\n                    float2 samplePos = origin + texelSize * float2(x, y);\n                    totalAccum  += shadowMap.sample_compare(shadow_sampler, samplePos, uvp.z);\n                }\n            }\n            shadow = totalAccum / float(sampleCount * sampleCount);\n        }\n    }\n\n    \n    shadow *= step(0., lightScreen.w);\n\n    return shadow;\n}\n\ninline float ComputeSoftShadow(sampler shadow_sampler, float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount, float shadowRadius, bool reverseZ)\n{\n    float4 lightScreen =  transformViewPosInShadowSpace(worldPos, shadowMatrix, reverseZ);\n\n    \n    float shadow;\n    if (sampleCount <= 1) {\n        shadow = shadow2DProj(shadow_sampler, shadowMap, lightScreen);\n    } else {\n        \n        float3 center_uv = lightScreen.xyz / lightScreen.w;\n        float3 scale_uv  = float3(shadowRadius, shadowRadius, reverseZ ? shadowRadius * center_uv.z : shadowRadius / lightScreen.w );\n\n        \n        float totalAccum = 0.0;\n        for (int i = 0; i < sampleCount; i++) {\n            totalAccum += shadow2D(shadow_sampler, shadowMap, center_uv + shadowKernel[i].xyz * scale_uv);\n        }\n        \n        shadow = totalAccum / float(sampleCount);\n    }\n\n    \n    shadow *= step(0., lightScreen.w);\n\n    return shadow;\n}\n\ninline float ComputeCascadeBlendAmount(float3 shadowPos, bool cascadeBlending)\n{\n    const float cascadeBlendingFactor = 0.1f; \n\n    float3 cascadePos = abs(shadowPos.xyz * 2.f - 1.f);\n    \n    if (cascadeBlending) {\n#if 0\n        const float edge = 1.f - cascadeBlendingFactor;\n        \n        cascadePos = 1.f - saturate((cascadePos - edge) / cascadeBlendingFactor);\n        return cascadePos.x * cascadePos.y * cascadePos.z; \n#else\n        \n        float distToEdge = 1.0f - max(max(cascadePos.x, cascadePos.y), cascadePos.z);\n        return smoothstep(0.0f, cascadeBlendingFactor, distToEdge);\n#endif\n    } else {\n        return step(cascadePos.x, 1.f) * step(cascadePos.y, 1.f) * step(cascadePos.z, 1.f);\n    }\n}\n\ninline float4 SampleShadowCascade(sampler shadow_sampler, depth2d_array<float> shadowMaps, float3 shadowPosition, uint cascadeIndex, constant float4* shadowKernel, int sampleCount, float shadowRadius)\n{\n    \n    float2 gridSize = float2(shadowMaps.get_width(), shadowMaps.get_height()) / 32;\n    float gd = scn::checkerboard(shadowPosition.xy, gridSize);\n    float3 gridCol = mix(float3(scn::debugColorForCascade(cascadeIndex).rgb), float3(0.f), float3(gd > 0.f));\n    \n    float shadow = 0.f;\n    if (sampleCount > 1) {\n\n        \n        for (int i = 0; i < sampleCount; ++i) {\n            shadow += shadow2DArray(shadow_sampler, shadowMaps, shadowKernel[i].xyz * shadowRadius + shadowPosition, cascadeIndex);\n        }\n        shadow /= float(sampleCount);\n    } else {\n        \n        shadow = shadow2DArray(shadow_sampler, shadowMaps, shadowPosition, cascadeIndex);\n    }\n    return float4(gridCol, shadow);\n}\n\ninline float4 ComputeCascadedShadow(sampler shadow_sampler, float3 viewPos, float4x4 shadowMatrix, constant float4 *cascadeScale, constant float4 *cascadeBias, int cascadeCount, depth2d_array<float> shadowMaps, bool enableCascadeBlending, constant float4* shadowKernel, int sampleCount, float shadowRadius)\n{\n    float4 shadow = 0.f;\n    float opacitySum = 1.f;\n    \n    \n    float3 pos_ls =  (shadowMatrix * float4(viewPos, 1.f)).xyz;\n\n    for (int c = 0; c < cascadeCount; ++c) {\n        \n        float3 pos_cs =  pos_ls * cascadeScale[c].xyz + cascadeBias[c].xyz;\n\n        \n        float cascadeRadius = shadowRadius * cascadeScale[c].x;\n\n        float opacity = ComputeCascadeBlendAmount(pos_cs, enableCascadeBlending);\n        if (opacity > 0.f) { \n            \n            float alpha = opacity * opacitySum;\n            shadow += SampleShadowCascade(shadow_sampler, shadowMaps, pos_cs, c, shadowKernel, sampleCount, cascadeRadius) * alpha;\n            opacitySum -= alpha;\n        }\n        if (opacitySum <= 0.f) \n            break;\n    }\n\n    return shadow;\n}\n"
+ "\n#import <metal_stdlib>\n\nusing namespace metal;\n\n#import \"scn_metal\"\n#import \"scn_util.h\"\n#import \"C3D-PBR.metal\"\n#import \"scn_tessellation.h\"\n\n\n\n#ifdef USE_LAYERED_RENDERING\n#define texture2d_layer texture2d_array\n#define sampleLayer(a,b) sample(a,b,in.sliceIndex)\n#else\n#define texture2d_layer texture2d\n#define sampleLayer(a,b) sample(a,b)\n#endif\n\n#ifdef C3D_USE_TEXTURE_FOR_LIGHT_INDICES\n#define LightIndex(lid) u_lightIndicesTexture.read((ushort)lid).x\n#else\n#define LightIndex(lid) u_lightIndicesBuffer[lid]\n#endif\n\n#ifdef IS_BEZIER_CURVE\n[[visible]] bool scn_is_inside_bezier_curve(float2 p, device void const* curveData, device packed_float3 const* controlPoints);\n[[visible]] float scn_distance_to_bezier_curve(float2 p, thread float2& directionToCurve, float maximumDistance, device void const* curveData, device packed_float3 const* controlPoints);\n#endif\n\n\n\ntypedef struct {\n\n#ifdef USE_MODELTRANSFORM\n    float4x4 modelTransform;\n#endif\n#ifdef USE_INVERSEMODELTRANSFORM\n    float4x4 inverseModelTransform;\n#endif\n#ifdef USE_MODELVIEWTRANSFORM\n    float4x4 modelViewTransform;\n#endif\n#ifdef USE_INVERSEMODELVIEWTRANSFORM\n    float4x4 inverseModelViewTransform;\n#endif\n#ifdef USE_NORMALTRANSFORM\n    float4x4 normalTransform;\n#endif\n#ifdef USE_MODELVIEWPROJECTIONTRANSFORM\n    float4x4 modelViewProjectionTransform;\n#endif\n#ifdef USE_INVERSEMODELVIEWPROJECTIONTRANSFORM\n    float4x4 inverseModelViewProjectionTransform;\n#endif\n#ifdef USE_MOTIONBLUR\n    float4x4 lastFrameModelTransform;\n    float motionBlurIntensity;\n#endif\n#ifdef USE_BOUNDINGBOX\n    float2x3 boundingBox;\n#endif\n#ifdef USE_WORLDBOUNDINGBOX\n    float2x3 worldBoundingBox;\n#endif\n#ifdef USE_NODE_OPACITY\n    float nodeOpacity;\n#endif\n#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)\n    sh2_coefficients shCoefficients;\n#elif defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 3)\n    sh3_coefficients shCoefficients;\n#endif\n} commonprofile_node;\n\ntypedef struct {\n    float3 position         [[attribute(SCNVertexSemanticPosition)]];\n#ifdef HAS_NORMAL\n    float3 normal           [[attribute(SCNVertexSemanticNormal)]];\n#endif\n#ifdef USE_TANGENT\n    float4 tangent          [[attribute(SCNVertexSemanticTangent)]];\n#endif\n#ifdef USE_VERTEX_COLOR\n    float4 color            [[attribute(SCNVertexSemanticColor)]];\n#endif\n#if defined(NEED_IN_TEXCOORD0) || defined(DEBUG_PIXEL)\n    float2 texcoord0        [[attribute(SCNVertexSemanticTexcoord0)]];\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    float2 texcoord1        [[attribute(SCNVertexSemanticTexcoord1)]];\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    float2 texcoord2        [[attribute(SCNVertexSemanticTexcoord2)]];\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    float2 texcoord3        [[attribute(SCNVertexSemanticTexcoord3)]];\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    float2 texcoord4        [[attribute(SCNVertexSemanticTexcoord4)]];\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    float2 texcoord5        [[attribute(SCNVertexSemanticTexcoord5)]];\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    float2 texcoord6        [[attribute(SCNVertexSemanticTexcoord6)]];\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    float2 texcoord7        [[attribute(SCNVertexSemanticTexcoord7)]];\n#endif\n} scn_vertex_t; \n\ntypedef struct {\n    float4 fragmentPosition [[position]]; \n#ifdef USE_POINT_RENDERING\n    float fragmentSize [[point_size]];\n#endif\n#ifdef USE_VERTEX_COLOR\n    float4 vertexColor;\n#endif\n#ifdef USE_PER_VERTEX_LIGHTING\n    float3 diffuse;\n#ifdef USE_SPECULAR\n    float3 specular;\n#endif\n#ifdef USE_CLEARCOAT\n    float clearCoat;\n#endif\n#ifdef USE_CLEARCOATROUGHNESS\n    float clearCoatRoughness;\n#endif\n#ifdef USE_CLEARCOATNORMAL\n    float clearCoatNormal;\n#endif\n#endif\n#if defined(USE_POSITION) && (USE_POSITION == 2)\n    float3 position;\n#endif\n#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)\n    float3 normal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    float3 tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    float3 bitangent;\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n    float2 displacementTexcoord;   \n#endif\n#ifdef USE_CLEARCOAT_MAP\n    float2 clearCoatTexcoord;   \n#endif\n#ifdef USE_CLEARCOATROUGHNESS_MAP\n    float2 clearCoatRoughnessTexcoord;   \n#endif\n#ifdef USE_CLEARCOATNORMAL_MAP\n    float2 clearCoatNormalTexcoord;   \n#endif\n#if defined(USE_PBR_TRANSPARENCY) && defined(USE_TRANSPARENCY)\n    float transparency;\n#endif\n#ifdef USE_NODE_OPACITY\n    float nodeOpacity;\n#endif\n#ifdef USE_TEXCOORD\n    __TexcoordDecl__\n#endif\n    \n#ifdef USE_EXTRA_VARYINGS\n    __ExtraVaryingsDecl__\n#endif\n    \n#ifdef USE_MOTIONBLUR\n    float3 mv_fragment;\n    float3 mv_lastFragment;\n#endif\n#ifdef USE_OUTLINE\n    float outlineHash [[ flat ]];\n#endif\n#ifdef USE_INSTANCING\n    uint   instanceID [[ flat ]];\n#endif\n#ifndef USE_VERTEX_AMPLIFICATION \n#ifdef USE_LAYERED_RENDERING\n    uint   sliceIndex [[render_target_array_index]];\n#endif\n#ifdef USE_MULTIPLE_VIEWPORTS_RENDERING\n    uint   sliceIndex [[viewport_array_index]];\n#endif\n#endif\n#if DEBUG_PIXEL\n    float2 uv0;\n#endif\n} commonprofile_io;\n\n\n#ifdef USE_SHADER_MODIFIERS\n__ShaderModifiersDecl__\n#endif\n\n\n#import \"C3D-Lighting.metal\"\n\nenum C3DColorMask {\n    kC3DColorMaskRed    = 0x1 << 3,\n    kC3DColorMaskGreen  = 0x1 << 2,\n    kC3DColorMaskBlue   = 0x1 << 1,\n    kC3DColorMaskAlpha  = 0x1 << 0\n};\n\ninline float4 colorFromMask(float4 col, int mask)\n{\n    switch (mask) {\n\n        case kC3DColorMaskRed:                      return col.r;\n        case kC3DColorMaskRed|kC3DColorMaskGreen:   return float4(col.rg, 0.f, 1.f);\n        case kC3DColorMaskRed|kC3DColorMaskBlue:    return float4(col.rb, 0.f, 1.f);\n        case kC3DColorMaskRed|kC3DColorMaskAlpha:   return float4(col.ra, 0.f, 1.f);\n\n        case kC3DColorMaskGreen:                    return col.g;\n        case kC3DColorMaskGreen|kC3DColorMaskBlue:  return float4(col.bg, 0.f, 1.f);\n        case kC3DColorMaskGreen|kC3DColorMaskAlpha: return float4(col.ag, 0.f, 1.f);\n\n        case kC3DColorMaskBlue:     return col.b;\n        case kC3DColorMaskBlue|kC3DColorMaskAlpha:  return float4(col.ab, 0.f, 1.f);\n\n        case kC3DColorMaskAlpha:    return col.a;\n    }\n    return col;\n}\n\n#ifndef USE_PBR\n\ninline float3 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)\n{\n    float3 albedo = surface.diffuse.rgb * surface.ambientOcclusion;\n    float3 color = lighting.diffuse * albedo;\n#if defined(USE_AMBIENT_LIGHTING) && (defined(LOCK_AMBIENT_WITH_DIFFUSE) || defined(USE_AMBIENT_AS_AMBIENTOCCLUSION))\n    color +=  lighting.ambient * albedo;\n#endif\n#ifdef USE_SELFILLUMINATION\n    color += surface.diffuse.rgb * surface.selfIllumination.rgb;\n#endif\n    \n    \n    \n#ifdef USE_SPECULAR\n    float3 S = lighting.specular;\n#elif defined(USE_REFLECTIVE)\n    float3 S = float3(0.);\n#endif\n#ifdef USE_REFLECTIVE\n    S += surface.reflective.rgb * surface.ambientOcclusion;\n#endif\n#ifdef USE_SPECULAR\n    S *= surface.specular.rgb;\n#endif\n#if (defined(USE_SPECULAR) || defined(USE_REFLECTIVE)) && !defined(DISABLE_SPECULAR)\n    color += S;\n#endif\n#if defined(USE_AMBIENT) && !defined(USE_AMBIENT_AS_AMBIENTOCCLUSION)\n    color += surface.ambient.rgb * lighting.ambient;\n#endif\n#ifdef USE_EMISSION\n    color += surface.emission.rgb;\n#endif\n#ifdef USE_MULTIPLY\n    color *= surface.multiply.rgb;\n#endif\n#ifdef USE_MODULATE\n    color *= lighting.modulate;\n#endif\n    return color;\n}\n#endif\n\nstruct SCNShaderGeometry\n{\n    float4 position;\n    float3 normal;\n    float4 tangent;\n    float4 color;\n    float pointSize;\n    float2 texcoords[8]; \n#ifdef USE_CLIP_DISTANCE0\n    float clipDistance0;\n#endif\n#ifdef USE_CLIP_DISTANCE1\n    float clipDistance1;\n#endif\n#ifdef USE_CLIP_DISTANCE2\n    float clipDistance2;\n#endif\n#ifdef USE_CLIP_DISTANCE3\n    float clipDistance3;\n#endif\n};\n\nstruct commonprofile_uniforms {\n    \n    float4 diffuseColor;\n    float4 specularColor;\n    float4 ambientColor;\n    float4 emissionColor;\n    float4 selfIlluminationColor;\n    float4 reflectiveColor;\n    float4 multiplyColor;\n    float4 transparentColor;\n    float clearCoat;\n    float clearCoatRoughness;\n    float3 clearCoatNormal;\n    float metalness;\n    \n    float roughness;\n    float diffuseIntensity;\n    float specularIntensity;\n    float normalIntensity;\n    float ambientIntensity;\n    float emissionIntensity;\n    float selfIlluminationIntensity;\n    float reflectiveIntensity;\n    float multiplyIntensity;\n    float transparentIntensity;\n    \n    float metalnessIntensity;\n    float roughnessIntensity;\n    float clearCoatIntensity;\n    float clearCoatRoughnessIntensity;\n    float clearCoatNormalIntensity;\n    float displacementIntensity;\n    float materialShininess;\n    float selfIlluminationOcclusion;\n    float transparency;\n    float3 fresnel; \n#if USE_ARGUMENT_BUFFERS\n    \n    texture2d<float>    emissionTexture;\n    sampler             emissionSampler;\n    texture2d<float>    ambientTexture;\n    sampler             ambientSampler;\n    \n    texture2d<float>    diffuseTexture;\n    sampler             diffuseSampler;\n    texture2d<float>    specularTexture;\n    sampler             specularSampler;\n#if defined(USE_REFLECTIVE_CUBEMAP)\n    texturecube<float>  reflectiveTexture;\n#else\n    texture2d<float>    reflectiveTexture;\n#endif\n    sampler             reflectiveSampler;\n    texture2d<float>    transparentTexture;\n    sampler             transparentSampler;\n    texture2d<float>    multiplyTexture;\n    sampler             multiplySampler;\n    \n    texture2d<float>    normalTexture;\n    sampler             normalSampler;\n    texture2d<float>    selfIlluminationTexture;\n    sampler             selfIlluminationSampler;\n    texture2d<float>    metalnessTexture;\n    sampler             metalnessSampler;\n    texture2d<float>    roughnessTexture;\n    sampler             roughnessSampler;\n    texture2d<float>    displacementTexture;\n    sampler             displacementSampler;\n    \n    \n#endif \n#ifdef TEXTURE_TRANSFORM_COUNT\n    float4x4 textureTransforms[TEXTURE_TRANSFORM_COUNT];\n#endif\n};\n\n#ifdef USE_OPENSUBDIV\n\n__OpenSubdivDeclPerGeometry__\n__OpenSubdivDeclPerPatchType__\n__OpenSubdivDeclShared__\n\nstruct osd_packed_vertex {\n    packed_float3 position;\n#if defined(OSD_USER_VARYING_DECLARE_PACKED)\n    OSD_USER_VARYING_DECLARE_PACKED\n#endif\n};\n\n#endif\n\n\n#ifdef USE_DISPLACEMENT_MAP\nstatic void applyDisplacement(texture2d<float>                 displacementTexture,\n                              sampler                          displacementTextureSampler,\n                              float2                           displacementTexcoord,\n                              thread SCNShaderGeometry&        geometry,\n                              constant commonprofile_uniforms& scn_commonprofile)\n{\n#ifdef USE_DISPLACEMENT_TEXTURE_COMPONENT\n\tfloat altitude = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n#ifdef USE_DISPLACEMENT_INTENSITY\n\taltitude *= scn_commonprofile.displacementIntensity;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n\tfloat3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));\n\tgeometry.position.xyz += geometry.normal * altitude;\n\t\n\tfloat3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);\n\tfloat3 h;\n\th.x = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\th.y = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\th.z = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord-offset.zy), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\t\n#ifdef USE_DISPLACEMENT_INTENSITY\n\th *= scn_commonprofile.displacementIntensity;\n#endif\n\t\n\tfloat3 n = normalize( float3( (h.x - h.y)/offset.x, 1., (h.x - h.z)/offset.y) );\n\tgeometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;\n\tgeometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));\n#endif \n#else \n\tfloat3 displacement = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;\n#ifdef USE_DISPLACEMENT_INTENSITY\n\tdisplacement *= scn_commonprofile.displacementIntensity;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n\tfloat3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));\n\tgeometry.position.xyz += geometry.tangent.xyz * displacement.x + geometry.normal.xyz * displacement.y + bitangent.xyz * displacement.z;\n\t\n\tfloat3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);\n\tfloat3 a = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;\n\tfloat3 b = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz).rgb;\n\tfloat3 c = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.zy).rgb;\n\t\n#ifdef USE_DISPLACEMENT_INTENSITY\n\ta *= scn_commonprofile.displacementIntensity;\n\tb *= scn_commonprofile.displacementIntensity;\n\tc *= scn_commonprofile.displacementIntensity;\n#endif\n\t\n\tb += offset.xzz;\n\tc -= offset.zzy;\n\tfloat3 n = (normalize( cross( b-a, c-a ) ));\n\tgeometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;\n\tgeometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));\n#endif \n#endif \n}\n#endif \n\n#ifdef USE_OUTLINE\nstatic inline float hash(float2 p)\n{\n    const float2 kMod2 = float2(443.8975f, 397.2973f);\n    p  = fract(p * kMod2);\n    p += dot(p.xy, p.yx+19.19f);\n    return fract(p.x * p.y);\n}\n#endif\n    \n\n\n\n\n#if defined(USE_TESSELLATION)\nstruct scn_patch_t {\n    patch_control_point<scn_vertex_t> controlPoints;\n};\n#endif\n\n#if defined(USE_OPENSUBDIV)\n#if OSD_IS_ADAPTIVE\n[[ patch(quad, VERTEX_CONTROL_POINTS_PER_PATCH) ]]\n#endif\n#elif defined(USE_TESSELLATION)\n[[ patch(triangle, 3) ]]\n#endif\n    \n    \nvertex commonprofile_io commonprofile_vert(\n#if !defined(USE_TESSELLATION)\n                                           scn_vertex_t                       in                               [[ stage_in ]]\n                                           , uint                             scn_vertexID                     [[ vertex_id ]]\n#else \n                                           \n#ifdef USE_OPENSUBDIV\n#if OSD_IS_ADAPTIVE\n#if USE_STAGE_IN\n                                           PatchInput                         patchInput                       [[ stage_in ]]\n#else\n                                           OsdVertexBufferSet                 patchInput\n#endif\n                                           , float2                           patchCoord                       [[ position_in_patch ]]\n                                           , uint                             patchID                          [[ patch_id ]]\n                                           , constant float&                  osdTessellationLevel             [[ buffer(TESSELLATION_LEVEL_BUFFER_INDEX) ]]\n#else \n                                           constant unsigned*                 osdIndicesBuffer                 [[ buffer(INDICES_BUFFER_INDEX) ]]\n                                           , constant osd_packed_vertex*      osdVertexBuffer                  [[ buffer(VERTEX_BUFFER_INDEX) ]]\n                                           , uint                             vertexID                         [[ vertex_id ]]\n#endif \n#if defined(OSD_FVAR_WIDTH)\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n                                           , constant uint32_t&               osdFaceVaryingChannelCount       [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_COUNT_INDEX) ]]\n                                           , constant OsdFVarChannelDesc*     osdFaceVaryingChannelDescriptors [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_DESCRIPTORS_INDEX) ]]\n                                           , constant uint32_t&               osdFaceVaryingPatchArrayIndex    [[ buffer(OSD_FVAR_CHANNELS_PATCH_ARRAY_INDEX_BUFFER_INDEX) ]]\n                                           , constant void*                   osdFaceVaryingChannelsPackedData [[ buffer(OSD_FVAR_CHANNELS_PACKED_DATA_BUFFER_INDEX) ]]\n#else\n                                           , constant float*                  osdFaceVaryingData               [[ buffer(OSD_FVAR_DATA_BUFFER_INDEX) ]]\n                                           , constant int*                    osdFaceVaryingIndices            [[ buffer(OSD_FVAR_INDICES_BUFFER_INDEX) ]]\n#if OSD_IS_ADAPTIVE\n                                           , constant packed_int3*            osdFaceVaryingPatchParams        [[ buffer(OSD_FVAR_PATCHPARAM_BUFFER_INDEX) ]]\n                                           , constant packed_int4&            osdFaceVaryingPatchArray         [[ buffer(OSD_FVAR_PATCH_ARRAY_BUFFER_INDEX) ]]\n#endif\n#endif \n#endif \n#else \n                                           scn_patch_t                        in                               [[ stage_in ]]\n                                           , float3                           patchCoord                       [[ position_in_patch ]]\n#endif \n#endif \n                                           \n#ifdef USE_MULTIPLE_RENDERING\n                                           , constant SCNSceneBuffer*         scn_frame_multi                  [[ buffer(0) ]]\n#else\n                                           , constant SCNSceneBuffer&         scn_frame                        [[ buffer(0) ]]\n#endif\n#if defined(USE_INSTANCING) || defined(USE_MULTIPLE_RENDERING)\n                                           , constant commonprofile_node*     scn_nodes                        [[ buffer(1) ]]\n#else\n                                           , constant commonprofile_node&     scn_node                         [[ buffer(1) ]]\n#endif\n#ifdef USE_PER_VERTEX_LIGHTING\n                                           , constant scn_light*              scn_lights                       [[ buffer(2) ]]\n                                           , constant float4*                 u_shadowKernel\n                                           , texture2d_array<float>           u_areaLightBakedDataTexture\n#endif\n                                           \n                                           , constant commonprofile_uniforms& scn_commonprofile\n#ifdef USE_INSTANCING\n                                           , uint                             scn_instanceID                   [[ instance_id ]]\n#endif\n#ifdef USE_VERTEX_AMPLIFICATION\n                                           , ushort                           amplificationID                  [[ amplification_id ]]\n#endif\n\n#ifdef USE_POINT_RENDERING\n                                           \n                                           , constant float3&                 scn_pointSize\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n#if USE_ARGUMENT_BUFFERS\n#define u_displacementTexture           scn_commonprofile.displacementTexture\n#define u_displacementTextureSampler    scn_commonprofile.displacementSampler\n#else\n                                           , texture2d<float>                 u_displacementTexture\n                                           , sampler                          u_displacementTextureSampler\n#endif \n#endif \n#ifdef USE_VERTEX_EXTRA_ARGUMENTS\n                                           __VertexExtraArguments__\n#endif\n                                           )\n{\n    commonprofile_io out;\n    \n#ifdef USE_MULTIPLE_RENDERING\n\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant SCNSceneBuffer& scn_frame = scn_frame_multi[amplificationID];\n#else\n    out.instanceID = scn_instanceID / USE_MULTIPLE_RENDERING;\n    out.sliceIndex = scn_instanceID % USE_MULTIPLE_RENDERING;\n    constant SCNSceneBuffer& scn_frame = scn_frame_multi[out.sliceIndex];\n#endif\n    \n#ifdef USE_INSTANCING\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& scn_node = scn_nodes[USE_MULTIPLE_RENDERING * scn_instanceID + amplificationID];\n#else\n    \n    \n    constant commonprofile_node& scn_node = scn_nodes[scn_instanceID];\n#endif\n#else\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& scn_node = scn_nodes[amplificationID];\n#else\n    constant commonprofile_node& scn_node = scn_nodes[out.sliceIndex];\n#endif\n#endif\n    \n#else \n    \n#ifdef USE_INSTANCING\n    out.instanceID = scn_instanceID;\n    constant commonprofile_node& scn_node = scn_nodes[scn_instanceID];\n#endif\n    \n#endif \n    \n    \n#ifdef USE_TESSELLATION\n    uint scn_vertexID; \n    scn_vertexID = 0;\n#endif\n    \n    \n    \n    \n    \n    SCNShaderGeometry _geometry;\n    \n#if !defined(USE_TESSELLATION)\n    \n    \n    _geometry.position = float4(in.position, 1.f);\n#if defined(USE_NORMAL) && defined(HAS_NORMAL)\n    _geometry.normal = in.normal;\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = in.tangent;\n#endif\n#ifdef NEED_IN_TEXCOORD0\n    _geometry.texcoords[0] = in.texcoord0;\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    _geometry.texcoords[1] = in.texcoord1;\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    _geometry.texcoords[2] = in.texcoord2;\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    _geometry.texcoords[3] = in.texcoord3;\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    _geometry.texcoords[4] = in.texcoord4;\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    _geometry.texcoords[5] = in.texcoord5;\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    _geometry.texcoords[6] = in.texcoord6;\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    _geometry.texcoords[7] = in.texcoord7;\n#endif\n#ifdef HAS_VERTEX_COLOR\n    _geometry.color = in.color;\n#elif USE_VERTEX_COLOR\n    _geometry.color = float4(1.);\n#endif\n    \n#else \n    \n#ifdef USE_OPENSUBDIV\n#if OSD_IS_ADAPTIVE\n#if USE_STAGE_IN\n    int3 patchParam = patchInput.patchParam;\n#else\n    int3 patchParam = patchInput.patchParamBuffer[patchID];\n#endif\n    \n    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);\n    float tessellationLevel = min(osdTessellationLevel, (float)OSD_MAX_TESS_LEVEL) / exp2((float)refinementLevel - 1);\n    \n    OsdPatchVertex patchVertex = OsdComputePatch(tessellationLevel, patchCoord, patchID, patchInput);\n    \n#if defined(OSD_FVAR_WIDTH)\n    int patchIndex = OsdGetPatchIndex(patchID);\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);\n#else\n    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingIndices, osdFaceVaryingData, osdFaceVaryingPatchParams, osdFaceVaryingPatchArray);\n#endif\n#endif\n    \n    _geometry.position = float4(patchVertex.position, 1.f);\n    \n#if defined(USE_NORMAL)\n    _geometry.normal = patchVertex.normal;\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = float4(patchVertex.tangent, -1.f);\n    \n#endif\n#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[0] = patchVertex.texcoord0;\n#endif\n#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[1] = patchVertex.texcoord1;\n#endif\n#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[2] = patchVertex.texcoord2;\n#endif\n#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[3] = patchVertex.texcoord3;\n#endif\n#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[4] = patchVertex.texcoord4;\n#endif\n#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[5] = patchVertex.texcoord5;\n#endif\n#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[6] = patchVertex.texcoord6;\n#endif\n#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[7] = patchVertex.texcoord7;\n#endif\n#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.color = patchVertex.color;\n#endif\n    \n#else \n    \n#if OSD_PATCH_QUADS\n    const uint primitiveIndex = vertexID / 6;\n#ifdef USE_NORMAL\n    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 0]].position;\n    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 1]].position;\n    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 2]].position;\n    float3 normal = normalize(cross(p2 - p1, p0 - p1));\n#endif\n    const uint triangleIndices[6] = { 0, 1, 2, 0, 2, 3 };\n    const uint quadVertexIndex = triangleIndices[vertexID % 6];\n    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + quadVertexIndex]];\n#elif OSD_PATCH_TRIANGLES\n    const uint primitiveIndex = vertexID / 3;\n#ifdef USE_NORMAL\n    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 0]].position;\n    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 1]].position;\n    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 2]].position;\n    float3 normal = normalize(cross(p2 - p1, p0 - p1));\n#endif\n    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[vertexID]];\n#endif\n    \n    float3 position = osdVertex.position;\n    \n#if defined(OSD_FVAR_WIDTH)\n    int patchIndex = OsdGetPatchIndex(primitiveIndex);\n#if OSD_PATCH_QUADS\n    float2 quadUVs[4] = { float2(0,0), float2(1,0), float2(1,1), float2(0,1) };\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);\n#else\n    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingIndices, osdFaceVaryingData);\n#endif\n#elif OSD_PATCH_TRIANGLES\n    \n#endif\n#endif \n    \n#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[0] = osdVertex.texcoord0;\n#endif\n#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[1] = osdVertex.texcoord1;\n#endif\n#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[2] = osdVertex.texcoord2;\n#endif\n#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[3] = osdVertex.texcoord3;\n#endif\n#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[4] = osdVertex.texcoord4;\n#endif\n#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[5] = osdVertex.texcoord5;\n#endif\n#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[6] = osdVertex.texcoord6;\n#endif\n#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[7] = osdVertex.texcoord7;\n#endif\n#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.color = osdVertex.color;\n#endif\n    \n    _geometry.position = float4(position, 1.f);\n#ifdef USE_NORMAL\n    _geometry.normal = normal;\n#endif\n    \n#endif \n    \n#else \n    \n    \n    \n    \n    \n#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE) || defined(TESSELLATION_SMOOTHING_MODE_PHONG)\n    float3 P0 = in.controlPoints[0].position;\n    float3 P1 = in.controlPoints[1].position;\n    float3 P2 = in.controlPoints[2].position;\n    float3 N0 = in.controlPoints[0].normal;\n    float3 N1 = in.controlPoints[1].normal;\n    float3 N2 = in.controlPoints[2].normal;\n#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE)\n    float3 position, normal;\n    scn_smooth_geometry_pn_triangle(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);\n#elif defined(TESSELLATION_SMOOTHING_MODE_PHONG)\n    float3 position, normal;\n    scn_smooth_geometry_phong(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);\n#endif\n    _geometry.position = float4(position, 1.f);\n#ifdef USE_NORMAL\n    _geometry.normal = normal;\n#endif\n#else \n    \n    _geometry.position = float4(scn::barycentric_mix(in.controlPoints[0].position, in.controlPoints[1].position, in.controlPoints[2].position, patchCoord), 1.f);\n#if defined(USE_NORMAL) && defined(HAS_NORMAL)\n    _geometry.normal = normalize(scn::barycentric_mix(in.controlPoints[0].normal, in.controlPoints[1].normal, in.controlPoints[2].normal, patchCoord));\n#endif\n#endif \n    \n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = normalize(scn::barycentric_mix(in.controlPoints[0].tangent, in.controlPoints[1].tangent, in.controlPoints[2].tangent, patchCoord));\n#endif\n#ifdef NEED_IN_TEXCOORD0\n    _geometry.texcoords[0] = scn::barycentric_mix(in.controlPoints[0].texcoord0, in.controlPoints[1].texcoord0, in.controlPoints[2].texcoord0, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    _geometry.texcoords[1] = scn::barycentric_mix(in.controlPoints[0].texcoord1, in.controlPoints[1].texcoord1, in.controlPoints[2].texcoord1, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    _geometry.texcoords[2] = scn::barycentric_mix(in.controlPoints[0].texcoord2, in.controlPoints[1].texcoord2, in.controlPoints[2].texcoord2, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    _geometry.texcoords[3] = scn::barycentric_mix(in.controlPoints[0].texcoord3, in.controlPoints[1].texcoord3, in.controlPoints[2].texcoord3, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    _geometry.texcoords[4] = scn::barycentric_mix(in.controlPoints[0].texcoord4, in.controlPoints[1].texcoord4, in.controlPoints[2].texcoord4, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    _geometry.texcoords[5] = scn::barycentric_mix(in.controlPoints[0].texcoord5, in.controlPoints[1].texcoord5, in.controlPoints[2].texcoord5, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    _geometry.texcoords[6] = scn::barycentric_mix(in.controlPoints[0].texcoord6, in.controlPoints[1].texcoord6, in.controlPoints[2].texcoord6, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    _geometry.texcoords[7] = scn::barycentric_mix(in.controlPoints[0].texcoord7, in.controlPoints[1].texcoord7, in.controlPoints[2].texcoord7, patchCoord);\n#endif\n#ifdef HAS_VERTEX_COLOR\n    _geometry.color = scn::barycentric_mix(in.controlPoints[0].color, in.controlPoints[1].color, in.controlPoints[2].color, patchCoord);\n#elif USE_VERTEX_COLOR\n    _geometry.color = float4(1.);\n#endif\n    \n#endif \n    \n#endif \n    \n#ifdef USE_POINT_RENDERING\n    _geometry.pointSize = scn_pointSize.x;\n#endif\n    \n#ifdef USE_TEXCOORD\n    __VertexDoVertexOnlyTexcoord__\n#endif\n    \n#ifdef USE_DISPLACEMENT_MAP\n    applyDisplacement(u_displacementTexture, u_displacementTextureSampler, _displacementTexcoord, _geometry, scn_commonprofile);\n    out.displacementTexcoord = _displacementTexcoord;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_GEOMETRY_MODIFIER\n    \n    __DoGeometryModifier__\n    \n#endif\n    \n#ifdef USE_CLIP_DISTANCE0\n    out.clipDistance[0] = _geometry.clipDistance0;\n#endif\n#ifdef USE_CLIP_DISTANCE1\n    out.clipDistance[1] = _geometry.clipDistance1;\n#endif\n#ifdef USE_CLIP_DISTANCE2\n    out.clipDistance[2] = _geometry.clipDistance2;\n#endif\n#ifdef USE_CLIP_DISTANCE3\n    out.clipDistance[3] = _geometry.clipDistance3;\n#endif\n    \n    \n    \n    \n    \n    \n#if defined(USE_POSITION) || (defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)) || defined(USE_TANGENT) || defined(USE_BITANGENT) || defined(USE_INSTANCING)\n    SCNShaderSurface _surface;\n#endif\n#if defined(USE_POSITION) || defined(USE_INSTANCING)\n    _surface.position = (scn_node.modelViewTransform * _geometry.position).xyz;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n#ifdef HINT_UNIFORM_SCALE\n    float3x3 nrmTransform = scn::mat3(scn_node.modelViewTransform);\n    _surface.normal = nrmTransform * _geometry.normal;\n#else\n    float3x3 modelViewTransform = scn::mat3(scn_node.modelViewTransform);\n    float3 invScaleSquared = 1.f / float3(length_squared(modelViewTransform[0]),\n                                          length_squared(modelViewTransform[1]),\n                                          length_squared(modelViewTransform[2]));\n    _surface.normal = normalize(modelViewTransform * (_geometry.normal * invScaleSquared));\n#endif\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _surface.tangent = normalize(scn::mat3(scn_node.modelViewTransform) * _geometry.tangent.xyz);\n    _surface.bitangent = _geometry.tangent.w * cross(_surface.tangent, _surface.normal); \n    \n#endif\n    \n    \n#ifdef USE_VIEW\n    _surface.view = normalize(-_surface.position);\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_PER_VERTEX_LIGHTING\n    \n    SCNShaderLightingContribution _lightingContribution(_surface, out);\n    _lightingContribution.diffuse = 0.;\n  #ifdef USE_SPECULAR\n    _lightingContribution.specular = 0.;\n    _surface.shininess = scn_commonprofile.materialShininess;\n  #endif\n    \n    __VertexDoLighting__\n    \n    out.diffuse = _lightingContribution.diffuse;\n  #ifdef USE_SPECULAR\n    out.specular = _lightingContribution.specular;\n  #endif\n#endif\n#if defined(USE_POSITION) && (USE_POSITION == 2)\n    out.position = _surface.position;\n#endif\n#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)\n    out.normal = _surface.normal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    out.tangent = _surface.tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    out.bitangent = _surface.bitangent;\n#endif\n#ifdef USE_VERTEX_COLOR\n    out.vertexColor = _geometry.color;\n#endif\n    \n#if DEBUG_PIXEL\n    out.uv0 = in.texcoord0;\n#endif\n\n#ifdef USE_TEXCOORD\n    __VertexDoTexcoord__\n#endif\n    \n#ifdef IS_BEZIER_CURVE\n    out.bezierCurveUV = in.texcoord0;\n#endif\n    \n    \n    \n    \n    \n#if defined(USE_POSITION) || defined(USE_INSTANCING)\n    out.fragmentPosition = scn_frame.projectionTransform * float4(_surface.position, 1.);\n#elif defined(USE_MODELVIEWPROJECTIONTRANSFORM) \n    out.fragmentPosition = scn_node.modelViewProjectionTransform * _geometry.position;\n#endif\n    \n#if defined(USE_PBR_TRANSPARENCY) && defined(USE_TRANSPARENCY)\n    out.transparency = scn_commonprofile.transparency;\n#endif\n#ifdef USE_NODE_OPACITY\n    out.nodeOpacity = scn_node.nodeOpacity;\n#endif\n    \n#ifdef USE_POINT_RENDERING\n    float screenSize = _geometry.pointSize / out.fragmentPosition.w;\n    out.fragmentSize = clamp(screenSize, scn_pointSize.y, scn_pointSize.z);\n#endif\n    \n#ifdef USE_MOTIONBLUR\n    float4 lastFrameFragmentPosition = scn_frame.lastFrameViewProjectionTransform * scn_node.lastFrameModelTransform * _geometry.position;\n    out.mv_fragment = out.fragmentPosition.xyw;\n    out.mv_lastFragment = lastFrameFragmentPosition.xyw;\n#endif\n    \n#ifdef USE_OUTLINE\n\tout.outlineHash = hash(scn_node.modelTransform[3].xy)+1.f/255.f;\n#endif\n    \n    return out;\n}\n\n\n\n\n\nstruct SCNOutput\n{\n    float4 color [[ color(0) ]];\n#ifdef USE_COLOR1_OUTPUT\n    half4 color1 [[ color(1) ]];\n#endif\n#ifdef USE_NORMALS_OUTPUT\n    half4 normals [[ color(2) ]];\n#endif\n#ifdef USE_MOTIONBLUR\n    half4 motionblur [[ color(3) ]];\n#endif\n#ifdef USE_REFLECTANCE_ROUGHNESS_OUTPUT\n    half4 reflectanceRoughnessOutput [[ color(4) ]];\n#endif\n#ifdef USE_RADIANCE_OUTPUT\n    half4 radiance [[ color(5) ]];\n#endif\n};\n    \n#ifdef USE_MODIFIER_FRAMEBUFFER\nstruct SCNFramebuffer\n{\n    float4 color;\n};\n#endif\n\nfragment SCNOutput commonprofile_frag(commonprofile_io                   in                          [[ stage_in  ]]\n                                      , constant commonprofile_uniforms& scn_commonprofile           [[ buffer(0) ]]\n#ifdef USE_MULTIPLE_RENDERING\n                                      , constant SCNSceneBuffer*         scn_frame_multi             [[ buffer(1) ]]\n#else\n                                      , constant SCNSceneBuffer&         scn_frame                   [[ buffer(1) ]]\n#endif\n#if defined(USE_INSTANCING) || defined(USE_MULTIPLE_RENDERING)\n                                      , constant commonprofile_node*     scn_nodes                   [[ buffer(2) ]]\n#else\n                                      , constant commonprofile_node&     scn_node                    [[ buffer(2) ]]\n#endif\n#ifdef USE_PER_PIXEL_LIGHTING\n                                      , constant scn_light*              scn_lights                  [[ buffer(3) ]]\n                                      , constant float4*                 u_shadowKernel\n                                      , texture2d_array<float>           u_areaLightBakedDataTexture\n#ifdef C3D_SUPPORT_CUBE_ARRAY\n                                      , texturecube_array<half>          u_reflectionProbeTexture\n#else\n                                      , texture2d_array<half>            u_reflectionProbeTexture\n#endif\n                                      , texture3d<ushort>                u_clusterTexture\n#ifdef C3D_USE_TEXTURE_FOR_LIGHT_INDICES\n                                      , texture1d<ushort>                u_lightIndicesTexture\n#else\n                                      , constant C3DLightIndexType*      u_lightIndicesBuffer\n#endif\n#endif\n#if defined(C3D_SUPPORTS_PROGRAMMABLE_BLENDING) && defined(USE_MODIFIER_FRAMEBUFFER_COLOR0)\n                                      , float4                           framebufferColor0           [[ color(0) ]]\n#endif\n#if USE_ARGUMENT_BUFFERS\n\n#define u_emissionTexture               scn_commonprofile.emissionTexture\n#define u_emissionTextureSampler        scn_commonprofile.emissionSampler\n#define u_ambientTexture                scn_commonprofile.ambientTexture\n#define u_ambientTextureSampler         scn_commonprofile.ambientSampler\n#define u_diffuseTexture                scn_commonprofile.diffuseTexture\n#define u_diffuseTextureSampler         scn_commonprofile.diffuseSampler\n#define u_specularTexture               scn_commonprofile.specularTexture\n#define u_specularTextureSampler        scn_commonprofile.specularSampler\n#define u_reflectiveTexture             scn_commonprofile.reflectiveTexture\n#define u_reflectiveTextureSampler      scn_commonprofile.reflectiveSampler\n#define u_transparentTexture            scn_commonprofile.transparentTexture\n#define u_transparentTextureSampler     scn_commonprofile.transparentSampler\n#define u_multiplyTexture               scn_commonprofile.multiplyTexture\n#define u_multiplyTextureSampler        scn_commonprofile.multiplySampler\n#define u_normalTexture                 scn_commonprofile.normalTexture\n#define u_normalTextureSampler          scn_commonprofile.normalSampler\n#define u_selfIlluminationTexture       scn_commonprofile.selfIlluminationTexture\n#define u_selfIlluminationTextureSampler scn_commonprofile.selfIlluminationSampler\n#define u_metalnessTexture              scn_commonprofile.metalnessTexture\n#define u_metalnessTextureSampler       scn_commonprofile.metalnessSampler\n#define u_roughnessTexture              scn_commonprofile.roughnessTexture\n#define u_roughnessTextureSampler       scn_commonprofile.roughnessSampler\n\n#else\n#ifdef USE_EMISSION_MAP\n                                      , texture2d<float>              u_emissionTexture\n                                      , sampler                       u_emissionTextureSampler\n#endif\n#ifdef USE_AMBIENT_MAP\n                                      , texture2d<float>              u_ambientTexture\n                                      , sampler                       u_ambientTextureSampler\n#endif\n#ifdef USE_DIFFUSE_MAP\n                                      , texture2d<float>              u_diffuseTexture\n                                      , sampler                       u_diffuseTextureSampler\n#endif\n#ifdef USE_SPECULAR_MAP\n                                      , texture2d<float>              u_specularTexture\n                                      , sampler                       u_specularTextureSampler\n#endif\n#ifdef USE_REFLECTIVE_MAP\n                                      , texture2d<float>              u_reflectiveTexture\n                                      , sampler                       u_reflectiveTextureSampler\n#elif defined(USE_REFLECTIVE_CUBEMAP)\n                                      , texturecube<float>            u_reflectiveTexture\n                                      , sampler                       u_reflectiveTextureSampler\n#endif\n#ifdef USE_TRANSPARENT_MAP\n                                      , texture2d<float>              u_transparentTexture\n                                      , sampler                       u_transparentTextureSampler\n#endif\n#ifdef USE_MULTIPLY_MAP\n                                      , texture2d<float>              u_multiplyTexture\n                                      , sampler                       u_multiplyTextureSampler\n#endif\n#ifdef USE_NORMAL_MAP\n                                      , texture2d<float>              u_normalTexture\n                                      , sampler                       u_normalTextureSampler\n#endif\n#ifdef USE_SELFILLUMINATION_MAP\n                                      , texture2d<float>              u_selfIlluminationTexture\n                                      , sampler                       u_selfIlluminationTextureSampler\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n                                      , texture2d<float>              u_displacementTexture\n                                      , sampler                       u_displacementTextureSampler\n#endif\n#ifdef USE_PBR\n#ifdef USE_METALNESS_MAP\n                                      , texture2d<float>              u_metalnessTexture\n                                      , sampler                       u_metalnessTextureSampler\n#endif\n#ifdef USE_ROUGHNESS_MAP\n                                      , texture2d<float>              u_roughnessTexture\n                                      , sampler                       u_roughnessTextureSampler\n#endif\n#ifdef USE_CLEARCOAT_MAP\n                                      , texture2d<float>              u_clearCoatTexture\n                                      , sampler                       u_clearCoatTextureSampler\n#endif\n#ifdef USE_CLEARCOATROUGHNESS_MAP\n                                      , texture2d<float>              u_clearCoatRoughnessTexture\n                                      , sampler                       u_clearCoatRoughnessTextureSampler\n#endif\n#ifdef USE_CLEARCOATNORMAL_MAP\n                                      , texture2d<float>              u_clearCoatNormalTexture\n                                      , sampler                       u_clearCoatNormalTextureSampler\n#endif\n#endif \n#endif \n#ifdef USE_PBR\n                                      , texturecube<float>            u_radianceTexture\n                                      , texture2d<float>              u_specularDFGDiffuseHammonTexture\n#if !defined(USE_SELFILLUMINATION_MAP)\n                                      , texturecube<float>            u_irradianceTexture\n#endif\n#endif \n#ifdef USE_SSAO\n                                      , texture2d<float>              u_ssaoTexture\n#endif\n#ifdef USE_FRAGMENT_EXTRA_ARGUMENTS\n                                      __FragmentExtraArguments__\n#endif\n#if defined(USE_DOUBLE_SIDED)\n                                      , bool                          isFrontFacing                    [[front_facing]]\n#endif\n#ifdef USE_POINT_RENDERING\n                                      , float2                        pointCoord                       [[point_coord]]\n#endif\n#ifdef USE_VERTEX_AMPLIFICATION\n                                      , ushort                        amplificationID                  [[amplification_id]]\n#endif\n                                      )\n{\n#ifdef USE_MULTIPLE_RENDERING\n    \n#ifdef USE_VERTEX_AMPLIFICATION\n    constant SCNSceneBuffer& scn_frame = scn_frame_multi[amplificationID];\n#else\n    constant SCNSceneBuffer& scn_frame = scn_frame_multi[in.sliceIndex];\n#endif\n    \n#ifdef USE_INSTANCING\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& scn_node = scn_nodes[USE_MULTIPLE_RENDERING * in.instanceID + amplificationID];\n#else\n    constant commonprofile_node& scn_node = scn_nodes[USE_MULTIPLE_RENDERING * in.instanceID + in.sliceIndex];\n#endif\n#else\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& scn_node = scn_nodes[amplificationID];\n#else\n    constant commonprofile_node& scn_node = scn_nodes[in.sliceIndex];\n#endif\n#endif\n    \n#else \n    \n#ifdef USE_INSTANCING\n    constant commonprofile_node& scn_node = scn_nodes[in.instanceID];\n#endif\n    \n#endif \n    \n#ifdef IS_BEZIER_CURVE\n    int scn_bezierCurveCoverage = 0;\n    for (uint sampleID = 0; sampleID < get_num_samples(); ++sampleID) {\n        float2 uv = in.bezierCurveUV.interpolate_at_sample(sampleID);\n        bool insideCurve = scn_is_inside_bezier_curve(uv, scn_bezier_curve_data, scn_bezier_curve_controlPoints);\n        scn_bezierCurveCoverage += insideCurve;\n    }\n    if (scn_bezierCurveCoverage == 0) {\n        discard_fragment();\n    }\n#endif\n    \n    SCNOutput _output;\n\n    \n    \n    \n    \n    SCNShaderSurface _surface;\n#ifdef USE_TEXCOORD\n    __FragmentDoTexcoord__\n#endif\n    _surface.ambientOcclusion = 1.f; \n#ifdef USE_AMBIENT_MAP\n    #ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION\n        #if defined(USE_AMBIENT_TEXTURE_COMPONENT)\n            _surface.ambientOcclusion = colorFromMask(u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord), USE_AMBIENT_TEXTURE_COMPONENT).r;\n        #else\n            _surface.ambientOcclusion = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord).r;\n        #endif\n        #ifdef USE_AMBIENT_INTENSITY\n            _surface.ambientOcclusion = saturate(mix(1.f, _surface.ambientOcclusion, scn_commonprofile.ambientIntensity));\n        #endif\n    #else \n        _surface.ambient = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord);\n        #if defined(USE_AMBIENT_TEXTURE_COMPONENT)\n            _surface.ambient = colorFromMask(_surface.ambient, USE_AMBIENT_TEXTURE_COMPONENT);\n        #endif\n        #ifdef USE_AMBIENT_INTENSITY\n            _surface.ambient *= scn_commonprofile.ambientIntensity;\n        #endif\n    #endif \n#elif defined(USE_AMBIENT_COLOR)\n    _surface.ambient = scn_commonprofile.ambientColor;\n#elif defined(USE_AMBIENT)\n    _surface.ambient = float4(0.);\n#endif\n#if defined(USE_AMBIENT) && defined(USE_VERTEX_COLOR)\n    _surface.ambient *= in.vertexColor;\n#endif\n#if  defined(USE_SSAO)\n    _surface.ambientOcclusion *= u_ssaoTexture.sample( sampler(filter::linear), in.fragmentPosition.xy * scn_frame.inverseResolution.xy ).x;\n#endif\n    \n#ifdef USE_DIFFUSE_MAP\n    _surface.diffuse = u_diffuseTexture.sample(u_diffuseTextureSampler, _surface.diffuseTexcoord);\n#if defined(USE_DIFFUSE_TEXTURE_COMPONENT)\n    _surface.diffuse = colorFromMask(_surface.diffuse, USE_DIFFUSE_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_DIFFUSE_INTENSITY\n    _surface.diffuse.rgb *= scn_commonprofile.diffuseIntensity;\n#endif\n#elif defined(USE_DIFFUSE_COLOR)\n    _surface.diffuse = scn_commonprofile.diffuseColor;\n#else\n    _surface.diffuse = float4(0.f,0.f,0.f,1.f);\n#endif\n#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)\n    _surface.diffuse.rgb    *= in.vertexColor.rgb;\n    _surface.diffuse        *= in.vertexColor.a; \n#endif\n#ifdef USE_SPECULAR_MAP\n    _surface.specular = u_specularTexture.sample(u_specularTextureSampler, _surface.specularTexcoord);\n#if defined(USE_SPECULAR_TEXTURE_COMPONENT)\n    _surface.specular = colorFromMask(_surface.specular, USE_SPECULAR_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_SPECULAR_INTENSITY\n    _surface.specular *= scn_commonprofile.specularIntensity;\n#endif\n#elif defined(USE_SPECULAR_COLOR)\n    _surface.specular = scn_commonprofile.specularColor;\n#elif defined(USE_SPECULAR)\n    _surface.specular = float4(0.f);\n#endif\n    \n#ifdef USE_CLEARCOAT_MAP\n    _surface.clearCoat = u_clearCoatTexture.sample(u_clearCoatTextureSampler, _surface.clearCoatTexcoord).r;\n#if defined(USE_CLEARCOAT_TEXTURE_COMPONENT)\n    _surface.clearCoat = colorFromMask(_surface.clearCoat, USE_CLEARCOAT_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_CLEARCOAT_INTENSITY\n    _surface.clearCoat *= scn_commonprofile.clearCoatIntensity;\n#endif\n#elif defined(USE_CLEARCOAT_COLOR)\n    _surface.clearCoat = scn_commonprofile.clearCoat;\n#elif defined(USE_CLEARCOAT)\n    _surface.clearCoat = 0.f;\n#endif\n    \n#ifdef USE_CLEARCOATROUGHNESS_MAP\n#if defined(USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT)\n    _surface.clearCoatRoughness = colorFromMask(u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord), USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.clearCoatRoughness = u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord).r;\n#endif\n#ifdef USE_CLEARCOATROUGHNESS_INTENSITY\n    _surface.clearCoatRoughness *= scn_commonprofile.clearCoatRoughnessIntensity;\n#endif\n#elif defined(USE_CLEARCOATROUGHNESS_COLOR)\n    _surface.clearCoatRoughness = scn_commonprofile.clearCoatRoughness;\n#else\n    _surface.clearCoatRoughness = 0.03f;\n#endif\n \n#ifdef USE_EMISSION_MAP\n    _surface.emission = u_emissionTexture.sample(u_emissionTextureSampler, _surface.emissionTexcoord);\n#if defined(USE_EMISSION_TEXTURE_COMPONENT)\n    _surface.emission = colorFromMask(_surface.emission, USE_EMISSION_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_EMISSION_INTENSITY\n    _surface.emission *= scn_commonprofile.emissionIntensity;\n#endif\n#elif defined(USE_EMISSION_COLOR)\n    _surface.emission = scn_commonprofile.emissionColor;\n#elif defined(USE_EMISSION)\n    _surface.emission = float4(0.);\n#endif\n#ifdef USE_SELFILLUMINATION_MAP\n    _surface.selfIllumination = u_selfIlluminationTexture.sample(u_selfIlluminationTextureSampler, _surface.selfIlluminationTexcoord);\n#if defined(USE_SELFILLUMINATION_TEXTURE_COMPONENT)\n    _surface.selfIllumination = colorFromMask(_surface.selfIllumination, USE_SELFILLUMINATION_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_SELFILLUMINATION_INTENSITY\n    _surface.selfIllumination *= scn_commonprofile.selfIlluminationIntensity;\n#endif\n#elif defined(USE_SELFILLUMINATION_COLOR)\n    _surface.selfIllumination = scn_commonprofile.selfIlluminationColor;\n#elif defined(USE_SELFILLUMINATION)\n    _surface.selfIllumination = float4(0.);\n#endif\n#ifdef USE_MULTIPLY_MAP\n    _surface.multiply = u_multiplyTexture.sample(u_multiplyTextureSampler, _surface.multiplyTexcoord);\n#if defined(USE_MULTIPLY_TEXTURE_COMPONENT)\n    _surface.multiply = colorFromMask(_surface.multiply, USE_MULTIPLY_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_MULTIPLY_INTENSITY\n    _surface.multiply = mix(float4(1.), _surface.multiply, scn_commonprofile.multiplyIntensity);\n#endif\n#elif defined(USE_MULTIPLY_COLOR)\n    _surface.multiply = scn_commonprofile.multiplyColor;\n#elif defined(USE_MULTIPLY)\n    _surface.multiply = float4(1.);\n#endif\n#ifdef USE_TRANSPARENT_MAP\n    _surface.transparent = u_transparentTexture.sample(u_transparentTextureSampler, _surface.transparentTexcoord);\n#if defined(USE_TRANSPARENT_TEXTURE_COMPONENT)\n    _surface.transparent = colorFromMask(_surface.transparent, USE_TRANSPARENT_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_TRANSPARENT_INTENSITY\n    _surface.transparent *= scn_commonprofile.transparentIntensity;\n#endif\n#elif defined(USE_TRANSPARENT_COLOR)\n    _surface.transparent = scn_commonprofile.transparentColor;\n#elif defined(USE_TRANSPARENT)\n    _surface.transparent = float4(1.f);\n#endif\n    \n#ifdef USE_METALNESS_MAP\n#if defined(USE_METALNESS_TEXTURE_COMPONENT)\n    _surface.metalness = colorFromMask(u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord), USE_METALNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.metalness = u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord).r;\n#endif\n#ifdef USE_METALNESS_INTENSITY\n    _surface.metalness *= scn_commonprofile.metalnessIntensity;\n#endif\n#elif defined(USE_METALNESS_COLOR)\n    _surface.metalness = scn_commonprofile.metalness;\n#else\n    _surface.metalness = 0.f;\n#endif\n    \n#ifdef USE_ROUGHNESS_MAP\n#if defined(USE_ROUGHNESS_TEXTURE_COMPONENT)\n    _surface.roughness = colorFromMask(u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord), USE_ROUGHNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.roughness = u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord).r;\n#endif\n#ifdef USE_ROUGHNESS_INTENSITY\n    _surface.roughness *= scn_commonprofile.roughnessIntensity;\n#endif\n#elif defined(USE_ROUGHNESS_COLOR)\n    _surface.roughness = scn_commonprofile.roughness;\n#else\n    _surface.roughness = 0.f;\n#endif\n#if (defined USE_POSITION) && (USE_POSITION == 2)\n    _surface.position = in.position;\n#endif\n#if (defined USE_NORMAL) && (USE_NORMAL == 2)\n#if defined(HAS_NORMAL) || defined(USE_OPENSUBDIV)\n#ifdef USE_DOUBLE_SIDED\n    _surface.geometryNormal = normalize(in.normal.xyz) * (isFrontFacing ? 1.f : -1.f );\n#else\n    _surface.geometryNormal = normalize(in.normal.xyz);\n#endif\n#else \n    _surface.geometryNormal = normalize( cross(dfdy( _surface.position ), dfdx( _surface.position ) ));\n#endif\n    _surface.normal = _surface.geometryNormal;\n    _surface.clearCoatNormal = _surface.geometryNormal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    _surface.tangent = in.tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    _surface.bitangent = in.bitangent;\n#endif\n#if (defined USE_VIEW) && (USE_VIEW == 2)\n    _surface.view = normalize(-in.position);\n    {\n        \n        \n        float NoV = dot(_surface.geometryNormal, _surface.view);\n        _surface.view = _surface.view + max(0.f, -2.f * NoV) * _surface.geometryNormal;         \n        \n    }\n#endif\n#if defined(USE_NORMAL_MAP)\n    {\n        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.normal);\n#ifdef USE_NORMAL_MAP\n#if defined(USE_NORMAL_TEXTURE_COMPONENT)\n        _surface._normalTS.xy = colorFromMask(u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord), USE_NORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;\n        _surface._normalTS.z = sqrt(1.f - saturate(length_squared(_surface._normalTS.xy)));\n#else\n        _surface._normalTS = u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord).rgb;\n        _surface._normalTS = _surface._normalTS * 2.f - 1.f;\n#endif\n#ifdef USE_NORMAL_INTENSITY\n        _surface._normalTS = mix(float3(0.f, 0.f, 1.f), _surface._normalTS, scn_commonprofile.normalIntensity);\n#endif\n#else\n        _surface._normalTS = float3(0.f, 0.f, 1.f);\n#endif\n        _surface.normal.rgb = normalize(ts2vs * _surface._normalTS.xyz );\n    }\n#else\n    _surface._normalTS = float3(0.f, 0.f, 1.f);\n#endif\n#ifdef USE_PBR\n    {\n        float roughness = clamp(_surface.roughness, PBR_MIN_ROUGHNESS, 1.0);\n        float alpha = scn_filteredAlphaFromRoughness(_surface.normal, roughness);\n        _surface.roughness = sqrt(alpha);\n    }\n#endif\n#if defined(USE_CLEARCOATNORMAL_MAP)\n    {\n        \n        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.geometryNormal);\n#ifdef USE_CLEARCOATNORMAL_MAP\n#if defined(USE_CLEARCOATNORMAL_TEXTURE_COMPONENT)\n        _surface._clearCoatNormalTS.xy = colorFromMask(u_clearCoatNormalTexture.sample(u_clearCoatnormalTextureSampler, _surface.clearCoatNormalTexcoord), USE_CLEARCOATNORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;\n        _surface._clearCoatNormalTS.z = sqrt(1.f - saturate(length_squared(_surface._clearCoatNormalTS.xy)));\n#else\n        _surface._clearCoatNormalTS = u_clearCoatNormalTexture.sample(u_clearCoatNormalTextureSampler, _surface.clearCoatNormalTexcoord).rgb;\n        _surface._clearCoatNormalTS = _surface._clearCoatNormalTS * 2.f - 1.f;\n#endif\n#ifdef USE_CLEARCOATNORMAL_INTENSITY\n        _surface._clearCoatNormalTS = mix(float3(0.f, 0.f, 1.f), _surface._clearCoatNormalTS, scn_commonprofile.clearCoatNormalIntensity);\n#endif\n#else\n        _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);\n#endif\n        _surface.clearCoatNormal.rgb = normalize(ts2vs * _surface._clearCoatNormalTS.xyz );\n    }\n#else\n    _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);\n#endif\n    \n#ifdef USE_REFLECTIVE_MAP\n    float3 refl = reflect( -_surface.view, _surface.normal );\n    float m = 2.f * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.f)*(refl.z+1.f));\n    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, float2(float2(refl.x,-refl.y) / m) + 0.5f);\n#if defined(USE_REFLECTIVE_TEXTURE_COMPONENT)\n    _surface.reflective = colorFromMask(_surface.reflective, USE_REFLECTIVE_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_REFLECTIVE_INTENSITY\n    _surface.reflective *= scn_commonprofile.reflectiveIntensity;\n#endif\n#elif defined(USE_REFLECTIVE_CUBEMAP)\n    float3 refl = reflect( _surface.position, _surface.normal );\n    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, scn::mat4_mult_float3(scn_frame.viewToCubeTransform, refl)); \n#ifdef USE_REFLECTIVE_INTENSITY\n    _surface.reflective *= scn_commonprofile.reflectiveIntensity;\n#endif\n#elif defined(USE_REFLECTIVE_COLOR)\n    _surface.reflective = scn_commonprofile.reflectiveColor;\n#elif defined(USE_REFLECTIVE)\n    _surface.reflective = float4(0.);\n#endif\n#ifdef USE_FRESNEL\n    _surface.fresnel = scn_commonprofile.fresnel.x + scn_commonprofile.fresnel.y * pow(1.f - saturate(dot(_surface.view, _surface.normal)), scn_commonprofile.fresnel.z);\n    _surface.reflective *= _surface.fresnel;\n#endif\n#ifdef USE_SHININESS\n    _surface.shininess = scn_commonprofile.materialShininess;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_SURFACE_MODIFIER\n    \n    __DoSurfaceModifier__\n    \n#endif\n    \n    \n    \n    \n    \n    SCNShaderLightingContribution _lightingContribution(_surface, in);\n#ifdef USE_LIGHT_MODIFIER\n    __LightModifierCopyDecl__\n#endif\n#ifdef USE_AMBIENT_LIGHTING\n    _lightingContribution.ambient = scn_frame.ambientLightingColor.rgb;\n#endif\n#ifdef USE_LIGHTING\n#ifdef USE_PER_PIXEL_LIGHTING\n#ifdef USE_CLUSTERED_LIGHTING\n    uint3 clusterIndex;\n    clusterIndex.xy = uint2(in.fragmentPosition.xy * scn_frame.clusterScale.xy); \n    clusterIndex.z = in.position.z * scn_frame.clusterScale.z + scn_frame.clusterScale.w; \n    \n    \n    ushort4 cluster_offset_count = u_clusterTexture.read(clusterIndex);\n    int lid = cluster_offset_count.x;\n#endif\n\n#ifdef USE_PBR\n    _lightingContribution.prepareForPBR(u_specularDFGDiffuseHammonTexture, scn_commonprofile.selfIlluminationOcclusion);\n    \n    \n#ifdef USE_SELFILLUMINATION\n    _lightingContribution.add_irradiance_from_selfIllum();\n#else\n#ifdef USE_PROBES_LIGHTING \n    _lightingContribution.add_global_irradiance_from_sh(scn_frame.viewToCubeTransform, scn_node.shCoefficients);\n#else\n    _lightingContribution.add_global_irradiance_probe(u_irradianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);\n#endif\n#endif\n\n    \n#ifndef DISABLE_SPECULAR\n#ifdef C3D_USE_REFLECTION_PROBES\n    int probe_count = (cluster_offset_count.z & 0xff);\n    for (int i = 0 ; i < probe_count; ++i, ++lid) {\n        _lightingContribution.add_local_probe(scn_lights[LightIndex(lid)], u_reflectionProbeTexture);\n    }\n#if PROBES_NORMALIZATION\n#if PROBES_OUTER_BLENDING\n    _lightingContribution.specular += _lightingContribution.probesWeightedSum.rgb / max(1.f, _lightingContribution.probesWeightedSum.a);\n#else\n    _lightingContribution.specular += _lightingContribution.probesWeightedSum.rgb / _lightingContribution.probesWeightedSum.a;\n#endif\n    float globalFactor = saturate(1.f - _lightingContribution.probesWeightedSum.a);\n#else\n    float globalFactor = _lightingContribution.probeRadianceRemainingFactor;\n#endif\n    _lightingContribution.add_global_probe(scn_frame.viewToCubeTransform, globalFactor * scn_frame.environmentIntensity,\n                                           u_reflectionProbeTexture);\n#else \n   _lightingContribution.add_global_probe(u_radianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);\n    \n#ifdef USE_CLEARCOAT\n    _lightingContribution.add_global_probeClearCoat(u_radianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);\n#endif\n\n    \n#endif \n#endif \n\n#endif \n    #if DEBUG_PIXEL\n        switch (DEBUG_PIXEL) {\n            case 1: _output.color = float4(_surface.normal * 0.5f + 0.5f, 1.f); break;\n            case 2: _output.color = float4(_surface.geometryNormal * 0.5f + 0.5f, 1.f); break;\n            case 3: _output.color = float4(_surface.tangent * 0.5f + 0.5f, 1.f); break;\n            case 4: _output.color = float4(in.uv0, 0.f, 1.f); break;\n            case 5: _output.color = float4(_surface.diffuse.rgb, 1.f); break;\n            case 6: _output.color = float4(float3(_surface.roughness), 1.f); break;\n            case 7: _output.color = float4(float3(_surface.metalness), 1.f); break;\n            case 8: _output.color = float4(float3(_surface.ambientOcclusion), 1.f); break;\n            default: break;\n        }\n        return _output;\n    #endif\n    \n    __FragmentDoLighting__\n    \n    #ifdef USE_CLUSTERED_LIGHTING\n        \n        int omni_count = cluster_offset_count.y & 0xff;\n        for (int i = 0 ; i < omni_count; ++i, ++lid) {\n            _lightingContribution.add_local_omni(scn_lights[LightIndex(lid)]);\n        }\n\n        \n        int spot_count = (cluster_offset_count.y >> 8);\n        for (int i = 0 ; i < spot_count; ++i, ++lid) {\n            _lightingContribution.add_local_spot(scn_lights[LightIndex(lid)]);\n        }\n\n    #endif\n#else \n        _lightingContribution.diffuse = in.diffuse;\n    #ifdef USE_SPECULAR\n        _lightingContribution.specular = in.specular;\n    #endif\n#endif \n    #ifdef AVOID_OVERLIGHTING\n        _lightingContribution.diffuse = saturate(_lightingContribution.diffuse);\n    #ifdef USE_SPECULAR\n        _lightingContribution.specular = saturate(_lightingContribution.specular);\n    #endif \n    #endif \n#else \n    _lightingContribution.diffuse = float3(1.);\n#endif \n\n    \n    \n    \n    \n#ifdef USE_PBR\n    { \n        float3 diffuseAlbedo = mix(_lightingContribution.pbr.albedo, float3(0.0), _surface.metalness);\n        \n        \n#ifdef USE_PBR_TRANSPARENCY\n        float3 color = (_lightingContribution.ambient * _surface.ambientOcclusion) * _lightingContribution.pbr.albedo;\n#else\n        float3 color = (_lightingContribution.ambient * _surface.ambientOcclusion) * _surface.diffuse.rgb;\n#endif\n        \n        color += _lightingContribution.pbr.envDiffuse;\n        color += _lightingContribution.diffuse * diffuseAlbedo;\n#ifndef DISABLE_SPECULAR\n        color += _lightingContribution.pbr.envSpecular;\n        color += _lightingContribution.specular;\n#endif\n#ifdef USE_EMISSION\n        color += _surface.emission.rgb;\n#endif\n#ifdef USE_MULTIPLY\n        color *= _surface.multiply.rgb;\n#endif\n#ifdef USE_MODULATE\n        color *= _lightingContribution.modulate;\n#endif\n        _output.color.rgb = color;\n    }\n#else \n\n#ifdef USE_SHADOWONLY\n    _output.color.rgb = float3(0.0);\n    _output.color.a = 1. - _lightingContribution.shadowFactor;\n#else\n    _output.color.rgb = illuminate(_surface, _lightingContribution);\n#endif\n#endif\n\n#ifndef USE_SHADOWONLY\n  #ifdef USE_PBR_TRANSPARENCY\n    _output.color.a = _lightingContribution.pbr.transparency;\n  #else\n    _output.color.a = _surface.diffuse.a;\n  #endif\n#endif\n\n#ifdef USE_FOG\n    float fogFactor = pow(clamp(length(_surface.position.xyz) * scn_frame.fogParameters.x + scn_frame.fogParameters.y, 0., scn_frame.fogColor.a), scn_frame.fogParameters.z);\n    _output.color.rgb = mix(_output.color.rgb, scn_frame.fogColor.rgb * _output.color.a, fogFactor);\n#endif\n\n#if !defined(DIFFUSE_PREMULTIPLIED) && !defined(USE_PBR_TRANSPARENCY)\n    _output.color.rgb *= _surface.diffuse.a;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_SHADOWONLY\n    float transparencyFactor = 1.0;\n  #ifdef USE_NODE_OPACITY\n    transparencyFactor *= in.nodeOpacity;\n  #endif\n    _output.color.a *= transparencyFactor; \n\n#else \n\n#ifdef USE_TRANSPARENT \n    \n#ifdef USE_TRANSPARENCY\n    _surface.transparent *= scn_commonprofile.transparency;\n#endif\n    \n#ifdef USE_TRANSPARENCY_RGBZERO\n    \n    _surface.transparent.a = (_surface.transparent.r * 0.212671f) + (_surface.transparent.g * 0.715160f) + (_surface.transparent.b * 0.072169f);\n    _output.color *= (float4(1.f) - _surface.transparent);\n#else\n  #ifndef USE_PBR_TRANSPARENCY\n    _output.color *= _surface.transparent.a;\n  #endif\n#endif\n    \n#else \n    \n#ifdef USE_TRANSPARENCY \n  #ifndef USE_PBR_TRANSPARENCY\n    _output.color *= scn_commonprofile.transparency;\n  #endif\n#endif\n    \n#endif \n    \n#ifdef USE_NODE_OPACITY\n    _output.color *= in.nodeOpacity;\n#endif\n    \n#endif \n    \n    \n    \n    \n    \n#ifdef USE_MODIFIER_FRAMEBUFFER\n    const SCNFramebuffer _framebuffer = {\n#if defined(C3D_SUPPORTS_PROGRAMMABLE_BLENDING) && defined(USE_MODIFIER_FRAMEBUFFER_COLOR0)\n        .color = framebufferColor0\n#else\n        .color = 0.f\n#endif\n    };\n#endif\n    \n#ifdef USE_FRAGMENT_MODIFIER\n    \n    __DoFragmentModifier__\n    \n#endif\n#if defined(USE_CLUSTERED_LIGHTING) && defined(DEBUG_CLUSTER_TILE)\n    _output.color.rgb = mix(_output.color.rgb, float3(scn::debugColorForCount(clusterIndex.z).xyz), 0.1f);\n    _output.color.rgb = mix(_output.color.rgb, float3(clusterIndex.x & 0x1 ^ clusterIndex.y & 0x1).xyz, 0.01f);\n#endif\n#ifdef DISABLE_LINEAR_RENDERING\n    _output.color.rgb = scn::linear_to_srgb(_output.color.rgb);\n#endif\n    \n#ifdef USE_DISCARD\n    if (_output.color.a == 0.) \n        discard_fragment();\n#endif\n\n#ifdef USE_POINT_RENDERING\n    if ((dfdx(pointCoord.x) < 0.5f) && (length_squared(pointCoord * 2.f - 1.f) > 1.f)) {\n        discard_fragment();\n    }\n#endif\n    \n    \n#ifdef USE_OUTLINE\n    _output.color.rgb = in.outlineHash;\n#endif\n    \n\n#ifdef USE_MOTIONBLUR\n#ifdef USE_MULTIPLE_RENDERING\n    _output.motionblur.xy = half2((in.mv_fragment.xy - scn_frame.viewportSize.zw) / in.mv_fragment.z - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * scn_frame.motionBlurIntensity;\n#else\n    _output.motionblur.xy = half2((in.mv_fragment.xy / in.mv_fragment.z) - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * scn_frame.motionBlurIntensity;\n#endif\n    _output.motionblur.z = length(_output.motionblur.xy);\n    _output.motionblur.w = half(-_surface.position.z);\n#endif\n\n#ifdef USE_NORMALS_OUTPUT\n    _output.normals = half4( half3(_surface.normal.xyz), half(_surface.roughness) );\n#endif\n    \n#ifdef USE_RADIANCE_OUTPUT\n    _output.radiance.rgb = half3(_lightingContribution.specular.rgb);\n#endif\n                                 \n#ifdef USE_REFLECTANCE_ROUGHNESS_OUTPUT\n#ifdef USE_PBR\n    _output.reflectanceRoughnessOutput = half4( half3(_lightingContribution.pbr.probeReflectance), half(_surface.roughness) );\n#else \n    _output.reflectanceRoughnessOutput = half4( 0.h );\n#endif\n#endif\n    \n    return _output;\n}\n"
+ "@\"<MTL4Archive>\"32@0:8@\"NSURL\"16^@24"
+ "@\"<MTL4ArgumentTable>\"32@0:8@\"MTL4ArgumentTableDescriptor\"16^@24"
+ "@\"<MTL4CommandAllocator>\"16@0:8"
+ "@\"<MTL4CommandAllocator>\"32@0:8@\"MTL4CommandAllocatorDescriptor\"16^@24"
+ "@\"<MTL4CommandBuffer>\"16@0:8"
+ "@\"<MTL4CommandQueue>\"16@0:8"
+ "@\"<MTL4CommandQueue>\"32@0:8@\"MTL4CommandQueueDescriptor\"16^@24"
+ "@\"<MTL4Compiler>\"32@0:8@\"MTL4CompilerDescriptor\"16^@24"
+ "@\"<MTL4CounterHeap>\"32@0:8@\"MTL4CounterHeapDescriptor\"16^@24"
+ "@\"<MTL4PipelineDataSetSerializer>\"24@0:8@\"MTL4PipelineDataSetSerializerDescriptor\"16"
+ "@\"<MTLBuffer>\"40@0:8Q16Q24q32"
+ "@\"<MTLFunctionHandle>\"24@0:8@\"<MTL4BinaryFunction>\"16"
+ "@\"<MTLFunctionHandle>\"24@0:8@\"<MTLFunction>\"16"
+ "@\"<MTLTensor>\"32@0:8@\"MTLTensorDescriptor\"16^@24"
+ "@\"<MTLTensor>\"40@0:8@\"MTLTensorDescriptor\"16Q24^@32"
+ "@\"<MTLTexture>\"24@0:8@\"MTLTextureViewDescriptor\"16"
+ "@\"<MTLTextureViewPool>\"32@0:8@\"MTLResourceViewPoolDescriptor\"16^@24"
+ "@\"<SCNSceneRendererDelegate>\""
+ "@40@0:8Q16Q24q32"
+ "@48@0:8@16@24B32Q36B44"
+ "Assertion '%s' failed. Inconsistent physically-based camera settings"
+ "Assertion '%s' failed. Inconsistent physically-based camera settings: %fº fov with a %.2fmm sensor should lead to an expected focal length of %.2f (got %.2f)"
+ "Assertion '%s' failed. Internal consistency error - unexpected sparse morph target"
+ "Error: SCNDecodeImage: invalid archive"
+ "Error: Unsupported coder class %@ for material property contents %@"
+ "Error: Unsupported coder for material property contents %@"
+ "Error: We do not handle property %d to get the program attribute enum for the intensity (using default: diffuse)\n"
+ "Unreachable code: Unsupported edge crease vertex format (%d)"
+ "Welcome to SceneKit 607 (May 24 2025 05:16:15)"
+ "_SCNCoderMaterialPropertyTextureProviderHelper"
+ "_runtimeMorphTargetCount"
+ "_runtimeMorphTargets"
+ "classForCoder"
+ "commandBufferWithDescriptor:"
+ "copyFromTexture:toTexture:"
+ "decodeBytesWithReturnedLength:"
+ "decodeValueOfObjCType:at:"
+ "drawableSize.x > 0 && drawableSize.y > 0"
+ "encodeBytes:length:"
+ "encodeValueOfObjCType:at:"
+ "float2 bezierCurveUV;\n"
+ "functionHandleWithBinaryFunction:"
+ "functionHandleWithFunction:"
+ "h"
+ "innerLayerNode"
+ "interpolant<float2, interpolation::perspective> bezierCurveUV;\n"
+ "newArchiveWithURL:error:"
+ "newArgumentTableWithDescriptor:error:"
+ "newBufferWithLength:options:placementSparsePageSize:"
+ "newCommandAllocator"
+ "newCommandAllocatorWithDescriptor:error:"
+ "newCommandBuffer"
+ "newCompilerWithDescriptor:error:"
+ "newCounterHeapWithDescriptor:error:"
+ "newMTL4CommandQueue"
+ "newMTL4CommandQueueWithDescriptor:error:"
+ "newPipelineDataSetSerializerWithDescriptor:"
+ "newTensorWithDescriptor:error:"
+ "newTensorWithDescriptor:offset:error:"
+ "newTextureViewPoolWithDescriptor:error:"
+ "newTextureViewWithDescriptor:"
+ "outerLayerNode"
+ "queryTimestampFrequency"
+ "replacementObjectForCoder:"
+ "scn_distance_to_bezier_curve"
+ "setErrorOptions:"
+ "sizeOfCounterHeapEntry:"
+ "sparseBufferTier"
+ "sparseTextureTier"
+ "splitInputOutputStructsIfNeededForSourceCode:generatedFromReplacementStrings:perPixelLighting:clipDistanceCount:hasBezierCurveDeformer:"
+ "src_type_size"
+ "tensorSizeAndAlignWithDescriptor:"
+ "v32@0:8r*16^v24"
+ "v32@0:8r*16r^v24"
+ "weightCount == _runtimeMorphTargetCount"
+ "{?=\"currentLightingSet\"{?=\"lights\"[8C]}\"currentShadowMaps\"[8@\"<MTLTexture>\"]\"currentGoboMaps\"[8@\"<MTLTexture>\"]\"frameLightingSetDatas\"{unordered_map<unsigned long long, SCNMTLLightSetData, std::hash<unsigned long long>, std::equal_to<unsigned long long>, std::allocator<std::pair<const unsigned long long, SCNMTLLightSetData>>>=\"__table_\"{__hash_table<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::__unordered_map_hasher<unsigned long long, std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::hash<unsigned long long>, std::equal_to<unsigned long long>>, std::__unordered_map_equal<unsigned long long, std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::equal_to<unsigned long long>, std::hash<unsigned long long>>, std::allocator<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>>>=\"__bucket_list_\"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *>>>=\"__ptr_\"^^v\"__deleter_\"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *>>=\"__size_\"Q}}\"__first_node_\"{__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *>=\"__next_\"^v}\"__size_\"Q\"__max_load_factor_\"f}}\"currentLightingHashKey\"Q\"currentLightingDesc\"{?=\"count\"q\"lights\"[8^{__C3DLight}]\"lightsData\"[8^{__C3DLightRuntimeData}]}\"currentLightingSpace\"{?=\"columns\"[4]}\"currentLightingSpaceShadow\"{?=\"columns\"[4]}\"needLightingSpaceTransformation\"B\"clusterSystem\"{SCNMTLClusterSystem=\"clustersCount\"\"tileSize\"\"selectedDebugClusterIndex\"\"_debugClusterTilesPipeline\"@\"SCNMTLRenderPipeline\"\"_debugLightIndicesBufferPipeline\"@\"SCNMTLRenderPipeline\"\"_debugClusterSlicesPipeline\"@\"SCNMTLRenderPipeline\"\"_debugProgram\"[7^{__C3DFXMetalProgram}]\"_debugShapes\"[7^{__C3DMesh}]}\"clusterInfo\"{Info=\"clusterBuffer\"{?=\"memory\"*\"buffer\"@\"<MTLBuffer>\"\"offset\"Q}\"clusterTexture\"@\"<MTLTexture>\"\"lightIndicesTexture\"@\"<MTLTexture>\"\"cellSize\"\"clusterScale\"\"cellPixelSize\"\"omniLightsRange\"\"spotLightsRange\"\"probeLightsRange\"\"lightsBuffer\"{?=\"memory\"*\"buffer\"@\"<MTLBuffer>\"\"offset\"Q}\"lightsBufferLightCount\"I\"shadowTextures\"[8@\"<MTLTexture>\"]\"iesOrGoboTextures\"[8@\"<MTLTexture>\"]\"samplerStates\"[8@\"<MTLSamplerState>\"]\"areaBuffer\"@\"<MTLBuffer>\"\"areaBufferOffset\"Q\"areaBufferOffsets\"[8Q]}\"reflectionProbesTextureArray\"@\"<MTLTexture>\"}"
+ "{?=\"frameBuffer\"^{__C3DFramebuffer}\"multisamplingFrameBuffer\"^{__C3DFramebuffer}\"drawableSize\"}"
+ "{?=\"lock\"{os_unfair_lock_s=\"_os_unfair_lock_opaque\"I}\"keyCodeConfiguration\"@\"NSDictionary\"\"keyDown\"{set<unsigned short, std::less<unsigned short>, std::allocator<unsigned short>>=\"__tree_\"{__tree<unsigned short, std::less<unsigned short>, std::allocator<unsigned short>>=\"__begin_node_\"^v\"__end_node_\"{__tree_end_node<std::__tree_node_base<void *> *>=\"__left_\"^v}\"__size_\"Q}}\"forward\"{vector<unsigned short, std::allocator<unsigned short>>=\"__begin_\"^S\"__end_\"^S\"__cap_\"^S}\"backward\"{vector<unsigned short, std::allocator<unsigned short>>=\"__begin_\"^S\"__end_\"^S\"__cap_\"^S}\"left\"{vector<unsigned short, std::allocator<unsigned short>>=\"__begin_\"^S\"__end_\"^S\"__cap_\"^S}\"right\"{vector<unsigned short, std::allocator<unsigned short>>=\"__begin_\"^S\"__end_\"^S\"__cap_\"^S}}"
+ "{?=QQ}24@0:8@\"MTLTensorDescriptor\"16"
+ "{c3dAether=\"_fields\"{vector<c3dPhysicsField *, std::allocator<c3dPhysicsField *>>=\"__begin_\"^^{c3dPhysicsField}\"__end_\"^^{c3dPhysicsField}\"__cap_\"^^{c3dPhysicsField}}\"_activeFields\"{vector<c3dPhysicsField *, std::allocator<c3dPhysicsField *>>=\"__begin_\"^^{c3dPhysicsField}\"__end_\"^^{c3dPhysicsField}\"__cap_\"^^{c3dPhysicsField}}\"_lastOverrideIndex\"I}"
+ "} commonprofile_io_vert;"
- "\n\n\n\n\n\n#if __METAL_VERSION__ >= 220 \n    #include <TargetConditionals.h>\n    #if TARGET_OS_OSX || TARGET_OS_MACCATALYST\n        \n        \n        #define SHOULD_CHECK_IF_OUTSIDE_TEXTURE  0\n        #define RETURN_IF_OUTSIDE_TEXTURE(dst)\n        #define RETURN_IF_OUTSIDE_TEXTURE3D(dst)\n    #else\n        #define SHOULD_CHECK_IF_OUTSIDE_TEXTURE  1\n        #define RETURN_IF_OUTSIDE_TEXTURE(dst)   if ((index.x >= dst.get_width()) || (index.y >= dst.get_height())) return;\n        #define RETURN_IF_OUTSIDE_TEXTURE3D(dst) if ((index.x >= dst.get_width()) || (index.y >= dst.get_height()) || (index.z >= dst.get_depth())) return;\n    #endif\n    #define SUPPORTS_LAYERED_RENDERING           1\n    #define SUPPORTS_MULTIPLE_VIEWPORT_RENDERING 1\n#else\n    #if defined(__METAL_MACOS__)\n        \n        \n        #define SHOULD_CHECK_IF_OUTSIDE_TEXTURE      0\n        #define RETURN_IF_OUTSIDE_TEXTURE(dst)\n        #define RETURN_IF_OUTSIDE_TEXTURE3D(dst)\n        #define SUPPORTS_LAYERED_RENDERING           (__METAL_VERSION__ >= 200)\n        #define SUPPORTS_MULTIPLE_VIEWPORT_RENDERING (__METAL_VERSION__ >= 200)\n    #elif defined(__METAL_IOS__)\n        #define SHOULD_CHECK_IF_OUTSIDE_TEXTURE      1\n        #define RETURN_IF_OUTSIDE_TEXTURE(dst)       if ((index.x >= dst.get_width()) || (index.y >= dst.get_height())) return;\n        #define RETURN_IF_OUTSIDE_TEXTURE3D(dst)     if ((index.x >= dst.get_width()) || (index.y >= dst.get_height()) || (index.z >= dst.get_depth())) return;\n        #define SUPPORTS_LAYERED_RENDERING           (__METAL_VERSION__ >= 210)\n        #define SUPPORTS_MULTIPLE_VIEWPORT_RENDERING (__METAL_VERSION__ >= 210)\n    #endif\n#endif\n\n\n\nnamespace scn {\n    \n    \n    static inline float4 reduce_op(float4 d0, float4 d1)\n    {\n        d0.x = min(d0.x, d1.x);\n        d0.y = max(d0.y, d1.y);\n        d0.z += d1.z;\n        d0.w += d1.w;\n        return d0;\n    }\n    \n    inline float vector_reduce_min(float4 v)\n    {\n        float2 min_lh = min(v.xy, v.zw);\n        return min(min_lh.x, min_lh.y);\n    }\n    \n    inline float vector_reduce_max(float4 v)\n    {\n        float2 max_lh = max(v.xy, v.zw);\n        return max(max_lh.x, max_lh.y);\n    }\n    \n    inline int vector_reduce_add(int4 v)\n    {\n        int2 add_lh = v.xy + v.zw;\n        return add_lh.x + add_lh.y;\n    }\n    \n    inline float3x3 mat3(float4x4 mat4)\n    {\n        return float3x3(mat4[0].xyz, mat4[1].xyz, mat4[2].xyz);\n    }\n    \n    inline float3 mat4_mult_float3_normalized(float4x4 matrix, float3 src)\n    {\n        float3 dst  =  src.xxx * matrix[0].xyz;\n        dst         += src.yyy * matrix[1].xyz;\n        dst         += src.zzz * matrix[2].xyz;\n        return normalize(dst);\n    }\n    \n    inline float3 mat4_mult_float3(float4x4 matrix, float3 src)\n    {\n        float3 dst  =  src.xxx * matrix[0].xyz;\n        dst         += src.yyy * matrix[1].xyz;\n        dst         += src.zzz * matrix[2].xyz;\n        return dst;\n    }\n\n    inline float3 matrix_rotate(float4x4 mat, float3 dir)\n    {\n        return  dir.xxx * mat[0].xyz +\n                dir.yyy * mat[1].xyz +\n                dir.zzz * mat[2].xyz;\n    }\n\n    inline float4 matrix_transform(float4x4 mat, float3 pos)\n    {\n        return  pos.xxxx * mat[0] +\n                pos.yyyy * mat[1] +\n                pos.zzzz * mat[2] +\n                           mat[3];\n    }\n\n    inline float3 quaternion_rotate_vector(float4 q, float3 v)\n    {\n        float3 t = 2.f * cross(q.xyz, v);\n        return v + q.w * t + cross(q.xyz, t);\n    }\n\n    \n    template <class T>\n    inline vec<T, 3> robust_normalize(vec<T, 3> v)\n    {\n        vec<T, 3> zero = 0.;\n        return all(v == zero) ? zero : normalize(v);\n    }\n\n    template <class T>\n    inline void generate_basis(vec<T, 3> inR, thread vec<T, 3> *outS, thread vec<T, 3> *outT)\n    {\n        \n        T x  = -inR.x;\n        T y  = inR.y;\n        T z  = inR.z;\n        T sz = copysign(T(1.), z);\n        T a  = y / (abs(z) + T(1.));\n        T b  = y * a;\n        T c  = x * a;\n        *outS = (vec<T, 3>){ z + sz * b,  sz * c,       x       };\n        *outT = (vec<T, 3>){ c,           T(1.) - b,    -sz * y };\n    }\n    \n    \n    \n    inline float3 blend_add(float3 base, float3 blend)\n    {\n        return min(base + blend, 1.0);\n    }\n    \n    inline float3 blend_lighten(float3 base, float3 blend)\n    {\n        return max(blend, base);\n    }\n    \n    inline float3 blend_screen(float3 base, float3 blend)\n    {\n        return (1.0 - ((1.0 - base) * (1.0 - blend)));\n    }\n\n    \n    \n    inline half sq(half f) {\n        return f * f;\n    }\n\n    inline float sq(float f) {\n        return f * f;\n    }\n    \n    inline float2 sincos(float angle) {\n        float cs;\n        float sn = ::sincos(angle, cs);\n        return float2(sn, cs);\n    }\n    \n    \n    inline float acos_fast(float f) {\n        float x = abs(f);\n        float res = -0.156583f * x + M_PI_2_F;\n        res *= sqrt(1.0f - x);\n        return (f >= 0.f) ? res : M_PI_F - res;\n    }\n\n    inline float asin_fast(float f)\n    {\n        return M_PI_2_F - acos_fast(f);\n    }\n\n    \n    inline float atan_fast(float inX)\n    {\n        float  x = inX;\n        return x*(-0.1784f * abs(x) - 0.0663f * x * x + 1.0301f);\n    }\n    \n    inline float atan2_fast(float y, float x)\n    {\n        float sx = x > 0.f ? -1.f : 1.f;\n        float abs_y = abs(y) + 1e-10f; \n        float r = (x + abs_y*sx) / (abs_y - x*sx);\n        float angle = sx * M_PI_4_F + M_PI_2_F;\n        angle      += (0.1963f * r * r - 0.9817f) * r;\n        return y > 0.f ? angle : -angle;\n    }\n    \n    \n    template <class T>\n    inline vec<T, 3> cartesian_from_spherical(vec<T, 2> uv)\n    {\n        \n        \n        T cos_phi;\n        T phi = uv.x * 2.0f * M_PI_F;\n        T sin_phi = ::sincos(phi, cos_phi);\n        \n        T cos_theta;\n        T theta     = uv.y * M_PI_F;\n        T sin_theta = ::sincos(theta, cos_theta);\n\n        return vec<T, 3>(cos_phi * sin_theta,\n                         cos_theta,\n                         -sin_phi * sin_theta);\n    }\n\n    inline float2 spherical_from_cartesian(float3 dir)\n    {\n        return float2( atan2(-dir.z, dir.x) * (0.5f * M_1_PI_F), acos(dir.y) * M_1_PI_F);\n    }\n\n    inline half2 spherical_from_cartesian(half3 dir)\n    {\n        return half2(atan2(-dir.z, dir.x) * 0.5h, acos(dir.y)) * M_1_PI_H;\n    }\n\n    inline float2 spherical_from_cartesian_fast(float3 dir)\n    {\n        return float2( atan2_fast(-dir.z, dir.x) * (0.5f * M_1_PI_F), acos_fast(dir.y) * M_1_PI_F);\n    }\n\n    inline half2 spherical_from_cartesian_fast(half3 dir)\n    {\n        return half2( atan2_fast(-dir.z, dir.x) * 0.5h, acos_fast(dir.y)) * M_1_PI_H;\n    }\n\n    #define dual_contract_factor  1.0\n\n    template <class T>\n    inline vec<T, 2> dual_paraboloid_from_cartesian(vec<T, 3> dir)\n    {\n        dir.xy /= abs(dir.z) + 1.0;\n\n        dir.y = 0.5 - dir.y * 0.5;\n        T s   = sign(dir.z) * 0.25;\n        dir.x = s * (dir.x - 1.0) + 0.5;\n        return dir.xy;\n    }\n    \n    \n    template <class T>\n    inline vec<T, 3> cartesian_from_dual_paraboloid(vec<T, 2>  uv)\n    {\n        \n        T zside = 0.5 * sign(0.5 - uv.x);\n        uv.x = 1.0 - abs(4.0 * uv.x - 2.0); \n        uv.y   = 1.0 - uv.y * 2.0;\n        T z = length_squared(uv); \n        z = (1.0 - z) * zside;\n        \n        return vec<T, 3>(uv.x, uv.y, z);\n    }\n\n    inline float reduce_min(float3 v) {\n        return min(v.x, min(v.y, v.z));\n    }\n    \n    inline float reduce_min(float4 v) {\n        return min(min(v.x, v.y), min(v.z, v.w));\n    }\n\n    inline float reduce_max(float3 v) {\n        return max(v.x, max(v.y, v.z));\n    }\n\n    inline float reduce_max(float4 v) {\n        return max(max(v.x, v.y), max(v.z, v.w));\n    }\n    \n    inline float3 randomSphereDir(float2 rnd)\n    {\n        float s = rnd.x * M_PI_F * 2.f;\n        float t = rnd.y * 2.f - 1.f;\n        return float3(sin(s), cos(s), t) / sqrt(1.f + t * t);\n    }\n    \n    \n    template <class T>\n    inline T interleaved_gradient_noise(vec<T, 2> pos)\n    {\n        vec<T, 3> magic( 0.06711056f, 0.00583715f, 52.9829189f );\n        return fract( magic.z * fract( dot( pos, magic.xy ) ) );\n    }\n    \n    inline float3 hemisphere_reflect(float3 v, float3 nrm)\n    {\n        return v * sign(dot(v, nrm));\n    }\n    \n    inline float3 randomHemisphereDir(float3 dir, float2 rnd)\n    {\n        return hemisphere_reflect(randomSphereDir( rnd ), dir);\n    }\n    \n    inline void orthogonal_basis(float3 n, thread float3& xp, thread float3& yp)\n    {\n        \n        float sz = n.z >= 0.f ? 1.f : -1.f;\n        float a  =  n.y / (1.f + abs(n.z));\n        float b  =  n.y * a;\n        float c  = -n.x * a;\n        \n        xp = float3(n.z + sz * b,   sz * c,     -n.x);\n        yp = float3(c,              1.f - b,    -sz * n.y);\n    }\n\n    template <class U>\n    inline float2 normalized_coordinate(ushort2 index, U texture)\n    {\n        uint width  = texture.get_width();\n        uint height = texture.get_height();\n        \n        float u = width  == 1 ? 0.5f : float(index.x) / float(width - 1);\n        float v = height == 1 ? 0.5f : float(index.y) / float(height - 1);\n        \n        return float2(u, v);\n    }\n\n    template <class U>\n    inline float2 normalized_coordinate(uint2 index, U texture)\n    {\n        uint width  = texture.get_width();\n        uint height = texture.get_height();\n        \n        float u = width  == 1 ? 0.5f : float(index.x) / float(width - 1);\n        float v = height == 1 ? 0.5f : float(index.y) / float(height - 1);\n        \n        return float2(u, v);\n    }\n\n    template <class U>\n    inline half2 normalized_coordinate_half(uint2 index, U texture)\n    {\n        uint width  = texture.get_width();\n        uint height = texture.get_height();\n        \n        half u = width  == 1 ? 0.5h : half(index.x) / half(width - 1);\n        half v = height == 1 ? 0.5h : half(index.y) / half(height - 1);\n        \n        return half2(u, v);\n    }\n\n    \n\n    template <class T>\n    inline vec<T, 3> cubemap_dir_from_sampleCoord(uint face, vec<T, 2> sampleCoord) \n    {\n        switch(face) {\n            case 0: \n                return vec<T, 3>( 1.0, -sampleCoord.y, -sampleCoord.x);\n\n            case 1: \n                return vec<T, 3>(-1.0, -sampleCoord.y,  sampleCoord.x);\n\n            case 2: \n                return vec<T, 3>(sampleCoord.x,  1.0,  sampleCoord.y);\n\n            case 3: \n                return vec<T, 3>(sampleCoord.x, -1.0, -sampleCoord.y);\n\n            case 4: \n                return vec<T, 3>( sampleCoord.x, -sampleCoord.y,  1.0);\n\n            default: \n                return vec<T, 3>(-sampleCoord.x, -sampleCoord.y, -1.0);\n        }\n    }\n\n    \n    template <class T>\n    inline T signed_unit(T uv) {\n        return uv * 2.0 - 1.0;\n    }\n\n    \n    template <class T>\n    inline T unsigned_unit(T uv) {\n        return uv * 0.5 + 0.5;\n    }\n\n    template <class T>\n    inline vec<T, 3> cubemap_dir_from_uv(uint face, vec<T, 2> uv) \n    {\n        return cubemap_dir_from_sampleCoord(face, signed_unit(uv));\n    }\n\n    template <class T>\n    inline vec<T, 3> cubemap_dir_from_uv_unit(uint face, vec<T, 2> uv) \n    {\n        return normalize(cubemap_dir_from_uv(face, uv));\n    }\n\n    \n    \n    inline float2 barycentric_mix(float2 __x, float2 __y, float2 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }\n    inline float3 barycentric_mix(float3 __x, float3 __y, float3 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }\n    inline float4 barycentric_mix(float4 __x, float4 __y, float4 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }\n    \n    static inline float rect(float2 lt, float2 rb, float2 uv)\n    {\n        float2 borders = step(lt, uv) * step(uv, rb);\n        return borders.x * borders.y;\n    }\n    \n    inline half4 debugColorForCascade(int cascade)\n    {\n        switch (cascade) {\n            case 0:\n            return half4(1.h, 0.h, 0.h, 1.h);\n            case 1:\n            return half4(0.9, 0.5, 0., 1.);\n            case 2:\n            return half4(1., 1., 0., 1.);\n            case 3:\n            return half4(0., 1., 0., 1.);\n            default:\n            return half4(0., 0., 0., 1.);\n        }\n    }\n\n    inline half3 debugColorForFace(int count)\n    {\n        switch (count) {\n            case 0:  return half3(1.0h, 0.1h, 0.1h);\n            case 1:  return half3(0.1h, 1.0h, 1.0h);\n            case 2:  return half3(0.1h, 1.0h, 0.1h);\n            case 3:  return half3(1.0h, 0.1h, 1.0h);\n            case 4:  return half3(0.1h, 0.1h, 1.0h);\n            default: return half3(1.0h, 1.0h, 0.1h);\n        }\n    }\n\n    inline half4 debugColorForCount(int count)\n    {\n        switch (count) {\n            case 0: return half4(0.0h, 0.0h, 0.0h, 1.h);\n            case 1: return half4(0.0h, 0.0h, 0.4h, 1.h);\n            case 2: return half4(0.0h, 0.0h, 0.9h, 1.h);\n            case 3: return half4(0.0h, 0.4h, 0.7h, 1.h);\n            case 4: return half4(0.0h, 0.9h, 0.4h, 1.h);\n            case 5: return half4(0.0h, 0.9h, 0.0h, 1.h);\n            case 6: return half4(0.4h, 0.7h, 0.0h, 1.h);\n            case 7: return half4(0.9h, 0.7h, 0.0h, 1.h);\n            default: return half4(1., 0., 0., 1.);\n        }\n    }\n\n    inline float grid(float2 lt, float2 rb, float2 gridSize, float thickness, float2 uv)\n    {\n        float insideRect = rect(lt, rb + thickness, uv);\n        float2 gt = thickness * gridSize;\n        float2 lines = step(abs(lt - fract(uv * gridSize)), gt);\n        return insideRect * (lines.x + lines.y);\n    }\n\n    inline float checkerboard(float2 gridSize, float2 uv)\n    {\n        float2 check = floor(uv * gridSize);\n        return step(fmod(check.x + check.y, 2.f), 0.f);\n    }\n\n    \n    \n    inline float luminance(float3 color)\n    {\n        \n        \n        return color.r * 0.212671 + color.g * 0.715160 + color.b * 0.072169;\n    }\n    \n    inline float srgb_to_linear(float c)\n    {\n        return (c <= 0.04045f) ? c / 12.92f : powr((c + 0.055f) / 1.055f, 2.4f);\n    }\n    \n    inline half srgb_to_linear_fast(half c)\n    {\n        return powr(c, 2.2h);\n    }\n    \n    inline half3 srgb_to_linear_fast(half3 c)\n    {\n        return powr(c, 2.2h);\n    }\n    \n    inline half srgb_to_linear(half c)\n    {\n        \n        return (c <= 0.04045h) ? (c * 0.0773993808h) :  powr(0.9478672986h * c + 0.05213270142h, 2.4h);\n    }\n    \n    inline float3 srgb_to_linear(float3 c)\n    {\n        return float3(srgb_to_linear(c.x), srgb_to_linear(c.y), srgb_to_linear(c.z));\n    }\n    \n    inline float linear_to_srgb(float c)\n    {\n        return (c < 0.0031308f) ? (12.92f * c) : (1.055f * powr(c, 1.f/2.4f) - 0.055f);\n    }\n    \n    inline float3 linear_to_srgb(float3 v) { \n        return float3(linear_to_srgb(v.x), linear_to_srgb(v.y), linear_to_srgb(v.z));\n    }\n    \n}\n\n\n\ntemplate <typename T>\ninline T dFdx(T v) {\n    return dfdx(v);\n}\n\n\ntemplate <typename T>\ninline T dFdy(T v) {\n    return -dfdy(v);\n}\n\n\n\ninline float4 texture2DProj(texture2d<float> tex, sampler smp, float4 uv)\n{\n    return tex.sample(smp, uv.xy / uv.w);\n}\n\ninline half4 texture2DProj(texture2d<half> tex, sampler smp, float4 uv)\n{\n    return tex.sample(smp, uv.xy / uv.w);\n}\n\nstatic constexpr sampler scn_shadow_sampler_rev_z = sampler(coord::normalized, filter::linear, mip_filter::none, address::clamp_to_zero, compare_func::less_equal);\nstatic constexpr sampler scn_shadow_sampler_ord_z = sampler(coord::normalized, filter::linear, mip_filter::none, address::clamp_to_edge, compare_func::greater_equal);\n\n#if defined(USE_REVERSE_Z) && USE_REVERSE_Z\nstatic constexpr sampler scn_shadow_sampler = scn_shadow_sampler_rev_z;\n#else\nstatic constexpr sampler scn_shadow_sampler = scn_shadow_sampler_ord_z;\n#endif\n\ninline float shadow2D(sampler shadow_sampler, depth2d<float> tex, float3 uv)\n{\n    return tex.sample_compare(shadow_sampler, uv.xy, uv.z);\n}\n\ninline float shadow2DProj(sampler shadow_sampler, depth2d<float> tex, float4 uv)\n{\n    float3 uvp = uv.xyz / uv.w;\n    return tex.sample_compare(shadow_sampler, uvp.xy, uvp.z);\n}\n\ninline float shadow2DArray(sampler shadow_sampler, depth2d_array<float> tex, float3 uv, uint slice)\n{\n    return tex.sample_compare(shadow_sampler, uv.xy, slice, uv.z);\n}\n\ninline float shadow2DArrayProj(sampler shadow_sampler, depth2d_array<float> tex, float4 uv, uint slice)\n{\n    float3 uvp = uv.xyz / uv.w;\n    return tex.sample_compare(shadow_sampler, uvp.xy, slice, uvp.z);\n}\n\n\n\ninline float4 transformViewPosInShadowSpace(float3 pos, float4x4 shadowMatrix, bool reverseZ)\n{\n    \n    float4 lightScreen =  shadowMatrix * float4(pos, 1.f);\n    \n    \n    \n    if (!reverseZ) {\n        lightScreen.z = min(lightScreen.z, 0.9999f * lightScreen.w);\n    } else {\n        if (lightScreen.z <= 0.0) { \n            lightScreen.z = 2.0;\n        }\n\n    }\n\n    return lightScreen;\n}\n\ninline float ComputeShadow(sampler shadow_sampler, float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap, bool reverseZ)\n{\n    float4 lightScreen =  transformViewPosInShadowSpace(worldPos, shadowMatrix, reverseZ);\n\n    float shadow = shadow2DProj(shadow_sampler, shadowMap, lightScreen);\n\n    \n    shadow *= step(0., lightScreen.w);\n    \n    return shadow;\n}\n\ninline float ComputeSoftShadowGrid(sampler shadow_sampler, float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap, int sampleCount, bool reverseZ)\n{\n    float4 lightScreen =  transformViewPosInShadowSpace(worldPos, shadowMatrix, reverseZ);\n\n    \n    float shadow;\n    if (sampleCount <= 1) {\n        shadow = shadow2DProj(shadow_sampler, shadowMap, lightScreen);\n    } else {\n\n        float3 uvp = lightScreen.xyz / lightScreen.w;\n        uvp.z += reverseZ ? 0.005f : -0.005f; \n\n        float2 texelSize = 2.f / float2(shadowMap.get_width(), shadowMap.get_height());\n        float2 origin    = uvp.xy - (sampleCount * 0.5f) * texelSize;\n\n        \n        if (sampleCount <= 4) { \n            half totalAccum = 0.h;\n            for (int y = 0; y < sampleCount; ++y) {\n                for (int x = 0; x < sampleCount; ++x) {\n                    totalAccum  += half(shadowMap.sample_compare(shadow_sampler, origin, uvp.z, 2 * int2(x,y)));\n                }\n            }\n            shadow = totalAccum / half(sampleCount * sampleCount);\n        } else {\n            float totalAccum = 0.f;\n            for (int y = 0; y < sampleCount; ++y) {\n                for (int x = 0; x < sampleCount; ++x) {\n                    float2 samplePos = origin + texelSize * float2(x, y);\n                    totalAccum  += shadowMap.sample_compare(shadow_sampler, samplePos, uvp.z);\n                }\n            }\n            shadow = totalAccum / float(sampleCount * sampleCount);\n        }\n    }\n\n    \n    shadow *= step(0., lightScreen.w);\n\n    return shadow;\n}\n\ninline float ComputeSoftShadow(sampler shadow_sampler, float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount, float shadowRadius, bool reverseZ)\n{\n    float4 lightScreen =  transformViewPosInShadowSpace(worldPos, shadowMatrix, reverseZ);\n\n    \n    float shadow;\n    if (sampleCount <= 1) {\n        shadow = shadow2DProj(shadow_sampler, shadowMap, lightScreen);\n    } else {\n        \n        float3 center_uv = lightScreen.xyz / lightScreen.w;\n        float3 scale_uv  = float3(shadowRadius, shadowRadius, reverseZ ? shadowRadius * center_uv.z : shadowRadius / lightScreen.w );\n\n        \n        float totalAccum = 0.0;\n        for (int i = 0; i < sampleCount; i++) {\n            totalAccum += shadow2D(shadow_sampler, shadowMap, center_uv + shadowKernel[i].xyz * scale_uv);\n        }\n        \n        shadow = totalAccum / float(sampleCount);\n    }\n\n    \n    shadow *= step(0., lightScreen.w);\n\n    return shadow;\n}\n\ninline float ComputeCascadeBlendAmount(float3 shadowPos, bool cascadeBlending)\n{\n    const float cascadeBlendingFactor = 0.1f; \n\n    float3 cascadePos = abs(shadowPos.xyz * 2.f - 1.f);\n    \n    if (cascadeBlending) {\n#if 0\n        const float edge = 1.f - cascadeBlendingFactor;\n        \n        cascadePos = 1.f - saturate((cascadePos - edge) / cascadeBlendingFactor);\n        return cascadePos.x * cascadePos.y * cascadePos.z; \n#else\n        \n        float distToEdge = 1.0f - max(max(cascadePos.x, cascadePos.y), cascadePos.z);\n        return smoothstep(0.0f, cascadeBlendingFactor, distToEdge);\n#endif\n    } else {\n        return step(cascadePos.x, 1.f) * step(cascadePos.y, 1.f) * step(cascadePos.z, 1.f);\n    }\n}\n\ninline float4 SampleShadowCascade(sampler shadow_sampler, depth2d_array<float> shadowMaps, float3 shadowPosition, uint cascadeIndex, constant float4* shadowKernel, int sampleCount, float shadowRadius)\n{\n    \n    float2 gridSize = float2(shadowMaps.get_width(), shadowMaps.get_height()) / 32;\n    float gd = scn::checkerboard(shadowPosition.xy, gridSize);\n    float3 gridCol = mix(float3(scn::debugColorForCascade(cascadeIndex).rgb), float3(0.f), float3(gd > 0.f));\n    \n    float shadow = 0.f;\n    if (sampleCount > 1) {\n\n        \n        for (int i = 0; i < sampleCount; ++i) {\n            shadow += shadow2DArray(shadow_sampler, shadowMaps, shadowKernel[i].xyz * shadowRadius + shadowPosition, cascadeIndex);\n        }\n        shadow /= float(sampleCount);\n    } else {\n        \n        shadow = shadow2DArray(shadow_sampler, shadowMaps, shadowPosition, cascadeIndex);\n    }\n    return float4(gridCol, shadow);\n}\n\ninline float4 ComputeCascadedShadow(sampler shadow_sampler, float3 viewPos, float4x4 shadowMatrix, constant float4 *cascadeScale, constant float4 *cascadeBias, int cascadeCount, depth2d_array<float> shadowMaps, bool enableCascadeBlending, constant float4* shadowKernel, int sampleCount, float shadowRadius)\n{\n    float4 shadow = 0.f;\n    float opacitySum = 1.f;\n    \n    \n    float3 pos_ls =  (shadowMatrix * float4(viewPos, 1.f)).xyz;\n\n    for (int c = 0; c < cascadeCount; ++c) {\n        \n        float3 pos_cs =  pos_ls * cascadeScale[c].xyz + cascadeBias[c].xyz;\n\n        \n        float cascadeRadius = shadowRadius * cascadeScale[c].x;\n\n        float opacity = ComputeCascadeBlendAmount(pos_cs, enableCascadeBlending);\n        if (opacity > 0.f) { \n            \n            float alpha = opacity * opacitySum;\n            shadow += SampleShadowCascade(shadow_sampler, shadowMaps, pos_cs, c, shadowKernel, sampleCount, cascadeRadius) * alpha;\n            opacitySum -= alpha;\n        }\n        if (opacitySum <= 0.f) \n            break;\n    }\n\n    return shadow;\n}\n"
- "\n#import <metal_stdlib>\n\nusing namespace metal;\n\n#import \"scn_metal\"\n#import \"scn_util.h\"\n#import \"C3D-PBR.metal\"\n#import \"scn_tessellation.h\"\n\n\n\n#ifdef USE_LAYERED_RENDERING\n#define texture2d_layer texture2d_array\n#define sampleLayer(a,b) sample(a,b,in.sliceIndex)\n#else\n#define texture2d_layer texture2d\n#define sampleLayer(a,b) sample(a,b)\n#endif\n\n#ifdef C3D_USE_TEXTURE_FOR_LIGHT_INDICES\n#define LightIndex(lid) u_lightIndicesTexture.read((ushort)lid).x\n#else\n#define LightIndex(lid) u_lightIndicesBuffer[lid]\n#endif\n\n#ifdef IS_BEZIER_CURVE\n[[visible]] bool scn_is_inside_bezier_curve(float2 p, device void const* curveData, device packed_float3 const* controlPoints);\n#endif\n\n\n\ntypedef struct {\n\n#ifdef USE_MODELTRANSFORM\n    float4x4 modelTransform;\n#endif\n#ifdef USE_INVERSEMODELTRANSFORM\n    float4x4 inverseModelTransform;\n#endif\n#ifdef USE_MODELVIEWTRANSFORM\n    float4x4 modelViewTransform;\n#endif\n#ifdef USE_INVERSEMODELVIEWTRANSFORM\n    float4x4 inverseModelViewTransform;\n#endif\n#ifdef USE_NORMALTRANSFORM\n    float4x4 normalTransform;\n#endif\n#ifdef USE_MODELVIEWPROJECTIONTRANSFORM\n    float4x4 modelViewProjectionTransform;\n#endif\n#ifdef USE_INVERSEMODELVIEWPROJECTIONTRANSFORM\n    float4x4 inverseModelViewProjectionTransform;\n#endif\n#ifdef USE_MOTIONBLUR\n    float4x4 lastFrameModelTransform;\n    float motionBlurIntensity;\n#endif\n#ifdef USE_BOUNDINGBOX\n    float2x3 boundingBox;\n#endif\n#ifdef USE_WORLDBOUNDINGBOX\n    float2x3 worldBoundingBox;\n#endif\n#ifdef USE_NODE_OPACITY\n    float nodeOpacity;\n#endif\n#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)\n    sh2_coefficients shCoefficients;\n#elif defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 3)\n    sh3_coefficients shCoefficients;\n#endif\n} commonprofile_node;\n\ntypedef struct {\n    float3 position         [[attribute(SCNVertexSemanticPosition)]];\n#ifdef HAS_NORMAL\n    float3 normal           [[attribute(SCNVertexSemanticNormal)]];\n#endif\n#ifdef USE_TANGENT\n    float4 tangent          [[attribute(SCNVertexSemanticTangent)]];\n#endif\n#ifdef USE_VERTEX_COLOR\n    float4 color            [[attribute(SCNVertexSemanticColor)]];\n#endif\n#if defined(NEED_IN_TEXCOORD0) || defined(DEBUG_PIXEL)\n    float2 texcoord0        [[attribute(SCNVertexSemanticTexcoord0)]];\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    float2 texcoord1        [[attribute(SCNVertexSemanticTexcoord1)]];\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    float2 texcoord2        [[attribute(SCNVertexSemanticTexcoord2)]];\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    float2 texcoord3        [[attribute(SCNVertexSemanticTexcoord3)]];\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    float2 texcoord4        [[attribute(SCNVertexSemanticTexcoord4)]];\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    float2 texcoord5        [[attribute(SCNVertexSemanticTexcoord5)]];\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    float2 texcoord6        [[attribute(SCNVertexSemanticTexcoord6)]];\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    float2 texcoord7        [[attribute(SCNVertexSemanticTexcoord7)]];\n#endif\n} scn_vertex_t; \n\ntypedef struct {\n    float4 fragmentPosition [[position]]; \n#ifdef USE_POINT_RENDERING\n    float fragmentSize [[point_size]];\n#endif\n#ifdef USE_VERTEX_COLOR\n    float4 vertexColor;\n#endif\n#ifdef USE_PER_VERTEX_LIGHTING\n    float3 diffuse;\n#ifdef USE_SPECULAR\n    float3 specular;\n#endif\n#ifdef USE_CLEARCOAT\n    float clearCoat;\n#endif\n#ifdef USE_CLEARCOATROUGHNESS\n    float clearCoatRoughness;\n#endif\n#ifdef USE_CLEARCOATNORMAL\n    float clearCoatNormal;\n#endif\n#endif\n#if defined(USE_POSITION) && (USE_POSITION == 2)\n    float3 position;\n#endif\n#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)\n    float3 normal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    float3 tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    float3 bitangent;\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n    float2 displacementTexcoord;   \n#endif\n#ifdef USE_CLEARCOAT_MAP\n    float2 clearCoatTexcoord;   \n#endif\n#ifdef USE_CLEARCOATROUGHNESS_MAP\n    float2 clearCoatRoughnessTexcoord;   \n#endif\n#ifdef USE_CLEARCOATNORMAL_MAP\n    float2 clearCoatNormalTexcoord;   \n#endif\n#if defined(USE_PBR_TRANSPARENCY) && defined(USE_TRANSPARENCY)\n    float transparency;\n#endif\n#ifdef USE_NODE_OPACITY\n    float nodeOpacity;\n#endif\n#ifdef USE_TEXCOORD\n    __TexcoordDecl__\n#endif\n    \n#ifdef USE_EXTRA_VARYINGS\n    __ExtraVaryingsDecl__\n#endif\n    \n#ifdef USE_MOTIONBLUR\n    float3 mv_fragment;\n    float3 mv_lastFragment;\n#endif\n#ifdef USE_OUTLINE\n    float outlineHash [[ flat ]];\n#endif\n#ifdef USE_INSTANCING\n    uint   instanceID [[ flat ]];\n#endif\n#ifndef USE_VERTEX_AMPLIFICATION \n#ifdef USE_LAYERED_RENDERING\n    uint   sliceIndex [[render_target_array_index]];\n#endif\n#ifdef USE_MULTIPLE_VIEWPORTS_RENDERING\n    uint   sliceIndex [[viewport_array_index]];\n#endif\n#endif\n#if DEBUG_PIXEL\n    float2 uv0;\n#endif\n} commonprofile_io;\n\n\n#ifdef USE_SHADER_MODIFIERS\n__ShaderModifiersDecl__\n#endif\n\n\n#import \"C3D-Lighting.metal\"\n\nenum C3DColorMask {\n    kC3DColorMaskRed    = 0x1 << 3,\n    kC3DColorMaskGreen  = 0x1 << 2,\n    kC3DColorMaskBlue   = 0x1 << 1,\n    kC3DColorMaskAlpha  = 0x1 << 0\n};\n\ninline float4 colorFromMask(float4 col, int mask)\n{\n    switch (mask) {\n\n        case kC3DColorMaskRed:                      return col.r;\n        case kC3DColorMaskRed|kC3DColorMaskGreen:   return float4(col.rg, 0.f, 1.f);\n        case kC3DColorMaskRed|kC3DColorMaskBlue:    return float4(col.rb, 0.f, 1.f);\n        case kC3DColorMaskRed|kC3DColorMaskAlpha:   return float4(col.ra, 0.f, 1.f);\n\n        case kC3DColorMaskGreen:                    return col.g;\n        case kC3DColorMaskGreen|kC3DColorMaskBlue:  return float4(col.bg, 0.f, 1.f);\n        case kC3DColorMaskGreen|kC3DColorMaskAlpha: return float4(col.ag, 0.f, 1.f);\n\n        case kC3DColorMaskBlue:     return col.b;\n        case kC3DColorMaskBlue|kC3DColorMaskAlpha:  return float4(col.ab, 0.f, 1.f);\n\n        case kC3DColorMaskAlpha:    return col.a;\n    }\n    return col;\n}\n\n#ifndef USE_PBR\n\ninline float3 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)\n{\n    float3 albedo = surface.diffuse.rgb * surface.ambientOcclusion;\n    float3 color = lighting.diffuse * albedo;\n#if defined(USE_AMBIENT_LIGHTING) && (defined(LOCK_AMBIENT_WITH_DIFFUSE) || defined(USE_AMBIENT_AS_AMBIENTOCCLUSION))\n    color +=  lighting.ambient * albedo;\n#endif\n#ifdef USE_SELFILLUMINATION\n    color += surface.diffuse.rgb * surface.selfIllumination.rgb;\n#endif\n    \n    \n    \n#ifdef USE_SPECULAR\n    float3 S = lighting.specular;\n#elif defined(USE_REFLECTIVE)\n    float3 S = float3(0.);\n#endif\n#ifdef USE_REFLECTIVE\n    S += surface.reflective.rgb * surface.ambientOcclusion;\n#endif\n#ifdef USE_SPECULAR\n    S *= surface.specular.rgb;\n#endif\n#if (defined(USE_SPECULAR) || defined(USE_REFLECTIVE)) && !defined(DISABLE_SPECULAR)\n    color += S;\n#endif\n#if defined(USE_AMBIENT) && !defined(USE_AMBIENT_AS_AMBIENTOCCLUSION)\n    color += surface.ambient.rgb * lighting.ambient;\n#endif\n#ifdef USE_EMISSION\n    color += surface.emission.rgb;\n#endif\n#ifdef USE_MULTIPLY\n    color *= surface.multiply.rgb;\n#endif\n#ifdef USE_MODULATE\n    color *= lighting.modulate;\n#endif\n    return color;\n}\n#endif\n\nstruct SCNShaderGeometry\n{\n    float4 position;\n    float3 normal;\n    float4 tangent;\n    float4 color;\n    float pointSize;\n    float2 texcoords[8]; \n#ifdef USE_CLIP_DISTANCE0\n    float clipDistance0;\n#endif\n#ifdef USE_CLIP_DISTANCE1\n    float clipDistance1;\n#endif\n#ifdef USE_CLIP_DISTANCE2\n    float clipDistance2;\n#endif\n#ifdef USE_CLIP_DISTANCE3\n    float clipDistance3;\n#endif\n};\n\nstruct commonprofile_uniforms {\n    \n    float4 diffuseColor;\n    float4 specularColor;\n    float4 ambientColor;\n    float4 emissionColor;\n    float4 selfIlluminationColor;\n    float4 reflectiveColor;\n    float4 multiplyColor;\n    float4 transparentColor;\n    float clearCoat;\n    float clearCoatRoughness;\n    float3 clearCoatNormal;\n    float metalness;\n    \n    float roughness;\n    float diffuseIntensity;\n    float specularIntensity;\n    float normalIntensity;\n    float ambientIntensity;\n    float emissionIntensity;\n    float selfIlluminationIntensity;\n    float reflectiveIntensity;\n    float multiplyIntensity;\n    float transparentIntensity;\n    \n    float metalnessIntensity;\n    float roughnessIntensity;\n    float clearCoatIntensity;\n    float clearCoatRoughnessIntensity;\n    float clearCoatNormalIntensity;\n    float displacementIntensity;\n    float materialShininess;\n    float selfIlluminationOcclusion;\n    float transparency;\n    float3 fresnel; \n#if USE_ARGUMENT_BUFFERS\n    \n    texture2d<float>    emissionTexture;\n    sampler             emissionSampler;\n    texture2d<float>    ambientTexture;\n    sampler             ambientSampler;\n    \n    texture2d<float>    diffuseTexture;\n    sampler             diffuseSampler;\n    texture2d<float>    specularTexture;\n    sampler             specularSampler;\n#if defined(USE_REFLECTIVE_CUBEMAP)\n    texturecube<float>  reflectiveTexture;\n#else\n    texture2d<float>    reflectiveTexture;\n#endif\n    sampler             reflectiveSampler;\n    texture2d<float>    transparentTexture;\n    sampler             transparentSampler;\n    texture2d<float>    multiplyTexture;\n    sampler             multiplySampler;\n    \n    texture2d<float>    normalTexture;\n    sampler             normalSampler;\n    texture2d<float>    selfIlluminationTexture;\n    sampler             selfIlluminationSampler;\n    texture2d<float>    metalnessTexture;\n    sampler             metalnessSampler;\n    texture2d<float>    roughnessTexture;\n    sampler             roughnessSampler;\n    texture2d<float>    displacementTexture;\n    sampler             displacementSampler;\n    \n    \n#endif \n#ifdef TEXTURE_TRANSFORM_COUNT\n    float4x4 textureTransforms[TEXTURE_TRANSFORM_COUNT];\n#endif\n};\n\n#ifdef USE_OPENSUBDIV\n\n__OpenSubdivDeclPerGeometry__\n__OpenSubdivDeclPerPatchType__\n__OpenSubdivDeclShared__\n\nstruct osd_packed_vertex {\n    packed_float3 position;\n#if defined(OSD_USER_VARYING_DECLARE_PACKED)\n    OSD_USER_VARYING_DECLARE_PACKED\n#endif\n};\n\n#endif\n\n\n#ifdef USE_DISPLACEMENT_MAP\nstatic void applyDisplacement(texture2d<float>                 displacementTexture,\n                              sampler                          displacementTextureSampler,\n                              float2                           displacementTexcoord,\n                              thread SCNShaderGeometry&        geometry,\n                              constant commonprofile_uniforms& scn_commonprofile)\n{\n#ifdef USE_DISPLACEMENT_TEXTURE_COMPONENT\n\tfloat altitude = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n#ifdef USE_DISPLACEMENT_INTENSITY\n\taltitude *= scn_commonprofile.displacementIntensity;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n\tfloat3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));\n\tgeometry.position.xyz += geometry.normal * altitude;\n\t\n\tfloat3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);\n\tfloat3 h;\n\th.x = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\th.y = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\th.z = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord-offset.zy), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\t\n#ifdef USE_DISPLACEMENT_INTENSITY\n\th *= scn_commonprofile.displacementIntensity;\n#endif\n\t\n\tfloat3 n = normalize( float3( (h.x - h.y)/offset.x, 1., (h.x - h.z)/offset.y) );\n\tgeometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;\n\tgeometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));\n#endif \n#else \n\tfloat3 displacement = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;\n#ifdef USE_DISPLACEMENT_INTENSITY\n\tdisplacement *= scn_commonprofile.displacementIntensity;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n\tfloat3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));\n\tgeometry.position.xyz += geometry.tangent.xyz * displacement.x + geometry.normal.xyz * displacement.y + bitangent.xyz * displacement.z;\n\t\n\tfloat3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);\n\tfloat3 a = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;\n\tfloat3 b = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz).rgb;\n\tfloat3 c = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.zy).rgb;\n\t\n#ifdef USE_DISPLACEMENT_INTENSITY\n\ta *= scn_commonprofile.displacementIntensity;\n\tb *= scn_commonprofile.displacementIntensity;\n\tc *= scn_commonprofile.displacementIntensity;\n#endif\n\t\n\tb += offset.xzz;\n\tc -= offset.zzy;\n\tfloat3 n = (normalize( cross( b-a, c-a ) ));\n\tgeometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;\n\tgeometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));\n#endif \n#endif \n}\n#endif \n\n#ifdef USE_OUTLINE\nstatic inline float hash(float2 p)\n{\n    const float2 kMod2 = float2(443.8975f, 397.2973f);\n    p  = fract(p * kMod2);\n    p += dot(p.xy, p.yx+19.19f);\n    return fract(p.x * p.y);\n}\n#endif\n    \n\n\n\n\n#if defined(USE_TESSELLATION)\nstruct scn_patch_t {\n    patch_control_point<scn_vertex_t> controlPoints;\n};\n#endif\n\n#if defined(USE_OPENSUBDIV)\n#if OSD_IS_ADAPTIVE\n[[ patch(quad, VERTEX_CONTROL_POINTS_PER_PATCH) ]]\n#endif\n#elif defined(USE_TESSELLATION)\n[[ patch(triangle, 3) ]]\n#endif\n    \n    \nvertex commonprofile_io commonprofile_vert(\n#if !defined(USE_TESSELLATION)\n                                           scn_vertex_t                       in                               [[ stage_in ]]\n                                           , uint                             scn_vertexID                     [[ vertex_id ]]\n#else \n                                           \n#ifdef USE_OPENSUBDIV\n#if OSD_IS_ADAPTIVE\n#if USE_STAGE_IN\n                                           PatchInput                         patchInput                       [[ stage_in ]]\n#else\n                                           OsdVertexBufferSet                 patchInput\n#endif\n                                           , float2                           patchCoord                       [[ position_in_patch ]]\n                                           , uint                             patchID                          [[ patch_id ]]\n                                           , constant float&                  osdTessellationLevel             [[ buffer(TESSELLATION_LEVEL_BUFFER_INDEX) ]]\n#else \n                                           constant unsigned*                 osdIndicesBuffer                 [[ buffer(INDICES_BUFFER_INDEX) ]]\n                                           , constant osd_packed_vertex*      osdVertexBuffer                  [[ buffer(VERTEX_BUFFER_INDEX) ]]\n                                           , uint                             vertexID                         [[ vertex_id ]]\n#endif \n#if defined(OSD_FVAR_WIDTH)\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n                                           , constant uint32_t&               osdFaceVaryingChannelCount       [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_COUNT_INDEX) ]]\n                                           , constant OsdFVarChannelDesc*     osdFaceVaryingChannelDescriptors [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_DESCRIPTORS_INDEX) ]]\n                                           , constant uint32_t&               osdFaceVaryingPatchArrayIndex    [[ buffer(OSD_FVAR_CHANNELS_PATCH_ARRAY_INDEX_BUFFER_INDEX) ]]\n                                           , constant void*                   osdFaceVaryingChannelsPackedData [[ buffer(OSD_FVAR_CHANNELS_PACKED_DATA_BUFFER_INDEX) ]]\n#else\n                                           , constant float*                  osdFaceVaryingData               [[ buffer(OSD_FVAR_DATA_BUFFER_INDEX) ]]\n                                           , constant int*                    osdFaceVaryingIndices            [[ buffer(OSD_FVAR_INDICES_BUFFER_INDEX) ]]\n#if OSD_IS_ADAPTIVE\n                                           , constant packed_int3*            osdFaceVaryingPatchParams        [[ buffer(OSD_FVAR_PATCHPARAM_BUFFER_INDEX) ]]\n                                           , constant packed_int4&            osdFaceVaryingPatchArray         [[ buffer(OSD_FVAR_PATCH_ARRAY_BUFFER_INDEX) ]]\n#endif\n#endif \n#endif \n#else \n                                           scn_patch_t                        in                               [[ stage_in ]]\n                                           , float3                           patchCoord                       [[ position_in_patch ]]\n#endif \n#endif \n                                           \n#ifdef USE_MULTIPLE_RENDERING\n                                           , constant SCNSceneBuffer*         scn_frame_multi                  [[ buffer(0) ]]\n#else\n                                           , constant SCNSceneBuffer&         scn_frame                        [[ buffer(0) ]]\n#endif\n#if defined(USE_INSTANCING) || defined(USE_MULTIPLE_RENDERING)\n                                           , constant commonprofile_node*     scn_nodes                        [[ buffer(1) ]]\n#else\n                                           , constant commonprofile_node&     scn_node                         [[ buffer(1) ]]\n#endif\n#ifdef USE_PER_VERTEX_LIGHTING\n                                           , constant scn_light*              scn_lights                       [[ buffer(2) ]]\n                                           , constant float4*                 u_shadowKernel\n                                           , texture2d_array<float>           u_areaLightBakedDataTexture\n#endif\n                                           \n                                           , constant commonprofile_uniforms& scn_commonprofile\n#ifdef USE_INSTANCING\n                                           , uint                             scn_instanceID                   [[ instance_id ]]\n#endif\n#ifdef USE_VERTEX_AMPLIFICATION\n                                           , ushort                           amplificationID                  [[ amplification_id ]]\n#endif\n\n#ifdef USE_POINT_RENDERING\n                                           \n                                           , constant float3&                 scn_pointSize\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n#if USE_ARGUMENT_BUFFERS\n#define u_displacementTexture           scn_commonprofile.displacementTexture\n#define u_displacementTextureSampler    scn_commonprofile.displacementSampler\n#else\n                                           , texture2d<float>                 u_displacementTexture\n                                           , sampler                          u_displacementTextureSampler\n#endif \n#endif \n#ifdef USE_VERTEX_EXTRA_ARGUMENTS\n                                           __VertexExtraArguments__\n#endif\n                                           )\n{\n    commonprofile_io out;\n    \n#ifdef USE_MULTIPLE_RENDERING\n\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant SCNSceneBuffer& scn_frame = scn_frame_multi[amplificationID];\n#else\n    out.instanceID = scn_instanceID / USE_MULTIPLE_RENDERING;\n    out.sliceIndex = scn_instanceID % USE_MULTIPLE_RENDERING;\n    constant SCNSceneBuffer& scn_frame = scn_frame_multi[out.sliceIndex];\n#endif\n    \n#ifdef USE_INSTANCING\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& scn_node = scn_nodes[USE_MULTIPLE_RENDERING * scn_instanceID + amplificationID];\n#else\n    \n    \n    constant commonprofile_node& scn_node = scn_nodes[scn_instanceID];\n#endif\n#else\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& scn_node = scn_nodes[amplificationID];\n#else\n    constant commonprofile_node& scn_node = scn_nodes[out.sliceIndex];\n#endif\n#endif\n    \n#else \n    \n#ifdef USE_INSTANCING\n    out.instanceID = scn_instanceID;\n    constant commonprofile_node& scn_node = scn_nodes[scn_instanceID];\n#endif\n    \n#endif \n    \n    \n#ifdef USE_TESSELLATION\n    uint scn_vertexID; \n    scn_vertexID = 0;\n#endif\n    \n    \n    \n    \n    \n    SCNShaderGeometry _geometry;\n    \n#if !defined(USE_TESSELLATION)\n    \n    \n    _geometry.position = float4(in.position, 1.f);\n#if defined(USE_NORMAL) && defined(HAS_NORMAL)\n    _geometry.normal = in.normal;\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = in.tangent;\n#endif\n#ifdef NEED_IN_TEXCOORD0\n    _geometry.texcoords[0] = in.texcoord0;\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    _geometry.texcoords[1] = in.texcoord1;\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    _geometry.texcoords[2] = in.texcoord2;\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    _geometry.texcoords[3] = in.texcoord3;\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    _geometry.texcoords[4] = in.texcoord4;\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    _geometry.texcoords[5] = in.texcoord5;\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    _geometry.texcoords[6] = in.texcoord6;\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    _geometry.texcoords[7] = in.texcoord7;\n#endif\n#ifdef HAS_VERTEX_COLOR\n    _geometry.color = in.color;\n#elif USE_VERTEX_COLOR\n    _geometry.color = float4(1.);\n#endif\n    \n#else \n    \n#ifdef USE_OPENSUBDIV\n#if OSD_IS_ADAPTIVE\n#if USE_STAGE_IN\n    int3 patchParam = patchInput.patchParam;\n#else\n    int3 patchParam = patchInput.patchParamBuffer[patchID];\n#endif\n    \n    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);\n    float tessellationLevel = min(osdTessellationLevel, (float)OSD_MAX_TESS_LEVEL) / exp2((float)refinementLevel - 1);\n    \n    OsdPatchVertex patchVertex = OsdComputePatch(tessellationLevel, patchCoord, patchID, patchInput);\n    \n#if defined(OSD_FVAR_WIDTH)\n    int patchIndex = OsdGetPatchIndex(patchID);\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);\n#else\n    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingIndices, osdFaceVaryingData, osdFaceVaryingPatchParams, osdFaceVaryingPatchArray);\n#endif\n#endif\n    \n    _geometry.position = float4(patchVertex.position, 1.f);\n    \n#if defined(USE_NORMAL)\n    _geometry.normal = patchVertex.normal;\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = float4(patchVertex.tangent, -1.f);\n    \n#endif\n#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[0] = patchVertex.texcoord0;\n#endif\n#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[1] = patchVertex.texcoord1;\n#endif\n#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[2] = patchVertex.texcoord2;\n#endif\n#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[3] = patchVertex.texcoord3;\n#endif\n#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[4] = patchVertex.texcoord4;\n#endif\n#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[5] = patchVertex.texcoord5;\n#endif\n#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[6] = patchVertex.texcoord6;\n#endif\n#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[7] = patchVertex.texcoord7;\n#endif\n#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.color = patchVertex.color;\n#endif\n    \n#else \n    \n#if OSD_PATCH_QUADS\n    const uint primitiveIndex = vertexID / 6;\n#ifdef USE_NORMAL\n    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 0]].position;\n    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 1]].position;\n    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 2]].position;\n    float3 normal = normalize(cross(p2 - p1, p0 - p1));\n#endif\n    const uint triangleIndices[6] = { 0, 1, 2, 0, 2, 3 };\n    const uint quadVertexIndex = triangleIndices[vertexID % 6];\n    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + quadVertexIndex]];\n#elif OSD_PATCH_TRIANGLES\n    const uint primitiveIndex = vertexID / 3;\n#ifdef USE_NORMAL\n    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 0]].position;\n    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 1]].position;\n    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 2]].position;\n    float3 normal = normalize(cross(p2 - p1, p0 - p1));\n#endif\n    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[vertexID]];\n#endif\n    \n    float3 position = osdVertex.position;\n    \n#if defined(OSD_FVAR_WIDTH)\n    int patchIndex = OsdGetPatchIndex(primitiveIndex);\n#if OSD_PATCH_QUADS\n    float2 quadUVs[4] = { float2(0,0), float2(1,0), float2(1,1), float2(0,1) };\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);\n#else\n    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingIndices, osdFaceVaryingData);\n#endif\n#elif OSD_PATCH_TRIANGLES\n    \n#endif\n#endif \n    \n#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[0] = osdVertex.texcoord0;\n#endif\n#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[1] = osdVertex.texcoord1;\n#endif\n#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[2] = osdVertex.texcoord2;\n#endif\n#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[3] = osdVertex.texcoord3;\n#endif\n#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[4] = osdVertex.texcoord4;\n#endif\n#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[5] = osdVertex.texcoord5;\n#endif\n#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[6] = osdVertex.texcoord6;\n#endif\n#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[7] = osdVertex.texcoord7;\n#endif\n#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.color = osdVertex.color;\n#endif\n    \n    _geometry.position = float4(position, 1.f);\n#ifdef USE_NORMAL\n    _geometry.normal = normal;\n#endif\n    \n#endif \n    \n#else \n    \n    \n    \n    \n    \n#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE) || defined(TESSELLATION_SMOOTHING_MODE_PHONG)\n    float3 P0 = in.controlPoints[0].position;\n    float3 P1 = in.controlPoints[1].position;\n    float3 P2 = in.controlPoints[2].position;\n    float3 N0 = in.controlPoints[0].normal;\n    float3 N1 = in.controlPoints[1].normal;\n    float3 N2 = in.controlPoints[2].normal;\n#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE)\n    float3 position, normal;\n    scn_smooth_geometry_pn_triangle(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);\n#elif defined(TESSELLATION_SMOOTHING_MODE_PHONG)\n    float3 position, normal;\n    scn_smooth_geometry_phong(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);\n#endif\n    _geometry.position = float4(position, 1.f);\n#ifdef USE_NORMAL\n    _geometry.normal = normal;\n#endif\n#else \n    \n    _geometry.position = float4(scn::barycentric_mix(in.controlPoints[0].position, in.controlPoints[1].position, in.controlPoints[2].position, patchCoord), 1.f);\n#if defined(USE_NORMAL) && defined(HAS_NORMAL)\n    _geometry.normal = normalize(scn::barycentric_mix(in.controlPoints[0].normal, in.controlPoints[1].normal, in.controlPoints[2].normal, patchCoord));\n#endif\n#endif \n    \n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = normalize(scn::barycentric_mix(in.controlPoints[0].tangent, in.controlPoints[1].tangent, in.controlPoints[2].tangent, patchCoord));\n#endif\n#ifdef NEED_IN_TEXCOORD0\n    _geometry.texcoords[0] = scn::barycentric_mix(in.controlPoints[0].texcoord0, in.controlPoints[1].texcoord0, in.controlPoints[2].texcoord0, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    _geometry.texcoords[1] = scn::barycentric_mix(in.controlPoints[0].texcoord1, in.controlPoints[1].texcoord1, in.controlPoints[2].texcoord1, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    _geometry.texcoords[2] = scn::barycentric_mix(in.controlPoints[0].texcoord2, in.controlPoints[1].texcoord2, in.controlPoints[2].texcoord2, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    _geometry.texcoords[3] = scn::barycentric_mix(in.controlPoints[0].texcoord3, in.controlPoints[1].texcoord3, in.controlPoints[2].texcoord3, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    _geometry.texcoords[4] = scn::barycentric_mix(in.controlPoints[0].texcoord4, in.controlPoints[1].texcoord4, in.controlPoints[2].texcoord4, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    _geometry.texcoords[5] = scn::barycentric_mix(in.controlPoints[0].texcoord5, in.controlPoints[1].texcoord5, in.controlPoints[2].texcoord5, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    _geometry.texcoords[6] = scn::barycentric_mix(in.controlPoints[0].texcoord6, in.controlPoints[1].texcoord6, in.controlPoints[2].texcoord6, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    _geometry.texcoords[7] = scn::barycentric_mix(in.controlPoints[0].texcoord7, in.controlPoints[1].texcoord7, in.controlPoints[2].texcoord7, patchCoord);\n#endif\n#ifdef HAS_VERTEX_COLOR\n    _geometry.color = scn::barycentric_mix(in.controlPoints[0].color, in.controlPoints[1].color, in.controlPoints[2].color, patchCoord);\n#elif USE_VERTEX_COLOR\n    _geometry.color = float4(1.);\n#endif\n    \n#endif \n    \n#endif \n    \n#ifdef USE_POINT_RENDERING\n    _geometry.pointSize = scn_pointSize.x;\n#endif\n    \n#ifdef USE_TEXCOORD\n    __VertexDoVertexOnlyTexcoord__\n#endif\n    \n#ifdef USE_DISPLACEMENT_MAP\n    applyDisplacement(u_displacementTexture, u_displacementTextureSampler, _displacementTexcoord, _geometry, scn_commonprofile);\n    out.displacementTexcoord = _displacementTexcoord;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_GEOMETRY_MODIFIER\n    \n    __DoGeometryModifier__\n    \n#endif\n    \n#ifdef USE_CLIP_DISTANCE0\n    out.clipDistance[0] = _geometry.clipDistance0;\n#endif\n#ifdef USE_CLIP_DISTANCE1\n    out.clipDistance[1] = _geometry.clipDistance1;\n#endif\n#ifdef USE_CLIP_DISTANCE2\n    out.clipDistance[2] = _geometry.clipDistance2;\n#endif\n#ifdef USE_CLIP_DISTANCE3\n    out.clipDistance[3] = _geometry.clipDistance3;\n#endif\n    \n    \n    \n    \n    \n    \n#if defined(USE_POSITION) || (defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)) || defined(USE_TANGENT) || defined(USE_BITANGENT) || defined(USE_INSTANCING)\n    SCNShaderSurface _surface;\n#endif\n#if defined(USE_POSITION) || defined(USE_INSTANCING)\n    _surface.position = (scn_node.modelViewTransform * _geometry.position).xyz;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n#ifdef HINT_UNIFORM_SCALE\n    float3x3 nrmTransform = scn::mat3(scn_node.modelViewTransform);\n    _surface.normal = nrmTransform * _geometry.normal;\n#else\n    float3x3 modelViewTransform = scn::mat3(scn_node.modelViewTransform);\n    float3 invScaleSquared = 1.f / float3(length_squared(modelViewTransform[0]),\n                                          length_squared(modelViewTransform[1]),\n                                          length_squared(modelViewTransform[2]));\n    _surface.normal = normalize(modelViewTransform * (_geometry.normal * invScaleSquared));\n#endif\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _surface.tangent = normalize(scn::mat3(scn_node.modelViewTransform) * _geometry.tangent.xyz);\n    _surface.bitangent = _geometry.tangent.w * cross(_surface.tangent, _surface.normal); \n    \n#endif\n    \n    \n#ifdef USE_VIEW\n    _surface.view = normalize(-_surface.position);\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_PER_VERTEX_LIGHTING\n    \n    SCNShaderLightingContribution _lightingContribution(_surface, out);\n    _lightingContribution.diffuse = 0.;\n  #ifdef USE_SPECULAR\n    _lightingContribution.specular = 0.;\n    _surface.shininess = scn_commonprofile.materialShininess;\n  #endif\n    \n    __VertexDoLighting__\n    \n    out.diffuse = _lightingContribution.diffuse;\n  #ifdef USE_SPECULAR\n    out.specular = _lightingContribution.specular;\n  #endif\n#endif\n#if defined(USE_POSITION) && (USE_POSITION == 2)\n    out.position = _surface.position;\n#endif\n#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)\n    out.normal = _surface.normal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    out.tangent = _surface.tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    out.bitangent = _surface.bitangent;\n#endif\n#ifdef USE_VERTEX_COLOR\n    out.vertexColor = _geometry.color;\n#endif\n    \n#if DEBUG_PIXEL\n    out.uv0 = in.texcoord0;\n#endif\n\n#ifdef USE_TEXCOORD\n    __VertexDoTexcoord__\n#endif\n    \n#ifdef IS_BEZIER_CURVE\n    out.bezierCurveUV = in.texcoord0;\n#endif\n    \n    \n    \n    \n    \n#if defined(USE_POSITION) || defined(USE_INSTANCING)\n    out.fragmentPosition = scn_frame.projectionTransform * float4(_surface.position, 1.);\n#elif defined(USE_MODELVIEWPROJECTIONTRANSFORM) \n    out.fragmentPosition = scn_node.modelViewProjectionTransform * _geometry.position;\n#endif\n    \n#if defined(USE_PBR_TRANSPARENCY) && defined(USE_TRANSPARENCY)\n    out.transparency = scn_commonprofile.transparency;\n#endif\n#ifdef USE_NODE_OPACITY\n    out.nodeOpacity = scn_node.nodeOpacity;\n#endif\n    \n#ifdef USE_POINT_RENDERING\n    float screenSize = _geometry.pointSize / out.fragmentPosition.w;\n    out.fragmentSize = clamp(screenSize, scn_pointSize.y, scn_pointSize.z);\n#endif\n    \n#ifdef USE_MOTIONBLUR\n    float4 lastFrameFragmentPosition = scn_frame.lastFrameViewProjectionTransform * scn_node.lastFrameModelTransform * _geometry.position;\n    out.mv_fragment = out.fragmentPosition.xyw;\n    out.mv_lastFragment = lastFrameFragmentPosition.xyw;\n#endif\n    \n#ifdef USE_OUTLINE\n\tout.outlineHash = hash(scn_node.modelTransform[3].xy)+1.f/255.f;\n#endif\n    \n    return out;\n}\n\n\n\n\n\nstruct SCNOutput\n{\n    float4 color [[ color(0) ]];\n#ifdef USE_COLOR1_OUTPUT\n    half4 color1 [[ color(1) ]];\n#endif\n#ifdef USE_NORMALS_OUTPUT\n    half4 normals [[ color(2) ]];\n#endif\n#ifdef USE_MOTIONBLUR\n    half4 motionblur [[ color(3) ]];\n#endif\n#ifdef USE_REFLECTANCE_ROUGHNESS_OUTPUT\n    half4 reflectanceRoughnessOutput [[ color(4) ]];\n#endif\n#ifdef USE_RADIANCE_OUTPUT\n    half4 radiance [[ color(5) ]];\n#endif\n};\n    \n#ifdef USE_MODIFIER_FRAMEBUFFER\nstruct SCNFramebuffer\n{\n    float4 color;\n};\n#endif\n\nfragment SCNOutput commonprofile_frag(commonprofile_io                   in                          [[ stage_in  ]]\n                                      , constant commonprofile_uniforms& scn_commonprofile           [[ buffer(0) ]]\n#ifdef USE_MULTIPLE_RENDERING\n                                      , constant SCNSceneBuffer*         scn_frame_multi             [[ buffer(1) ]]\n#else\n                                      , constant SCNSceneBuffer&         scn_frame                   [[ buffer(1) ]]\n#endif\n#if defined(USE_INSTANCING) || defined(USE_MULTIPLE_RENDERING)\n                                      , constant commonprofile_node*     scn_nodes                   [[ buffer(2) ]]\n#else\n                                      , constant commonprofile_node&     scn_node                    [[ buffer(2) ]]\n#endif\n#ifdef USE_PER_PIXEL_LIGHTING\n                                      , constant scn_light*              scn_lights                  [[ buffer(3) ]]\n                                      , constant float4*                 u_shadowKernel\n                                      , texture2d_array<float>           u_areaLightBakedDataTexture\n#ifdef C3D_SUPPORT_CUBE_ARRAY\n                                      , texturecube_array<half>          u_reflectionProbeTexture\n#else\n                                      , texture2d_array<half>            u_reflectionProbeTexture\n#endif\n                                      , texture3d<ushort>                u_clusterTexture\n#ifdef C3D_USE_TEXTURE_FOR_LIGHT_INDICES\n                                      , texture1d<ushort>                u_lightIndicesTexture\n#else\n                                      , constant C3DLightIndexType*      u_lightIndicesBuffer\n#endif\n#endif\n#if defined(C3D_SUPPORTS_PROGRAMMABLE_BLENDING) && defined(USE_MODIFIER_FRAMEBUFFER_COLOR0)\n                                      , float4                           framebufferColor0           [[ color(0) ]]\n#endif\n#if USE_ARGUMENT_BUFFERS\n\n#define u_emissionTexture               scn_commonprofile.emissionTexture\n#define u_emissionTextureSampler        scn_commonprofile.emissionSampler\n#define u_ambientTexture                scn_commonprofile.ambientTexture\n#define u_ambientTextureSampler         scn_commonprofile.ambientSampler\n#define u_diffuseTexture                scn_commonprofile.diffuseTexture\n#define u_diffuseTextureSampler         scn_commonprofile.diffuseSampler\n#define u_specularTexture               scn_commonprofile.specularTexture\n#define u_specularTextureSampler        scn_commonprofile.specularSampler\n#define u_reflectiveTexture             scn_commonprofile.reflectiveTexture\n#define u_reflectiveTextureSampler      scn_commonprofile.reflectiveSampler\n#define u_transparentTexture            scn_commonprofile.transparentTexture\n#define u_transparentTextureSampler     scn_commonprofile.transparentSampler\n#define u_multiplyTexture               scn_commonprofile.multiplyTexture\n#define u_multiplyTextureSampler        scn_commonprofile.multiplySampler\n#define u_normalTexture                 scn_commonprofile.normalTexture\n#define u_normalTextureSampler          scn_commonprofile.normalSampler\n#define u_selfIlluminationTexture       scn_commonprofile.selfIlluminationTexture\n#define u_selfIlluminationTextureSampler scn_commonprofile.selfIlluminationSampler\n#define u_metalnessTexture              scn_commonprofile.metalnessTexture\n#define u_metalnessTextureSampler       scn_commonprofile.metalnessSampler\n#define u_roughnessTexture              scn_commonprofile.roughnessTexture\n#define u_roughnessTextureSampler       scn_commonprofile.roughnessSampler\n\n#else\n#ifdef USE_EMISSION_MAP\n                                      , texture2d<float>              u_emissionTexture\n                                      , sampler                       u_emissionTextureSampler\n#endif\n#ifdef USE_AMBIENT_MAP\n                                      , texture2d<float>              u_ambientTexture\n                                      , sampler                       u_ambientTextureSampler\n#endif\n#ifdef USE_DIFFUSE_MAP\n                                      , texture2d<float>              u_diffuseTexture\n                                      , sampler                       u_diffuseTextureSampler\n#endif\n#ifdef USE_SPECULAR_MAP\n                                      , texture2d<float>              u_specularTexture\n                                      , sampler                       u_specularTextureSampler\n#endif\n#ifdef USE_REFLECTIVE_MAP\n                                      , texture2d<float>              u_reflectiveTexture\n                                      , sampler                       u_reflectiveTextureSampler\n#elif defined(USE_REFLECTIVE_CUBEMAP)\n                                      , texturecube<float>            u_reflectiveTexture\n                                      , sampler                       u_reflectiveTextureSampler\n#endif\n#ifdef USE_TRANSPARENT_MAP\n                                      , texture2d<float>              u_transparentTexture\n                                      , sampler                       u_transparentTextureSampler\n#endif\n#ifdef USE_MULTIPLY_MAP\n                                      , texture2d<float>              u_multiplyTexture\n                                      , sampler                       u_multiplyTextureSampler\n#endif\n#ifdef USE_NORMAL_MAP\n                                      , texture2d<float>              u_normalTexture\n                                      , sampler                       u_normalTextureSampler\n#endif\n#ifdef USE_SELFILLUMINATION_MAP\n                                      , texture2d<float>              u_selfIlluminationTexture\n                                      , sampler                       u_selfIlluminationTextureSampler\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n                                      , texture2d<float>              u_displacementTexture\n                                      , sampler                       u_displacementTextureSampler\n#endif\n#ifdef USE_PBR\n#ifdef USE_METALNESS_MAP\n                                      , texture2d<float>              u_metalnessTexture\n                                      , sampler                       u_metalnessTextureSampler\n#endif\n#ifdef USE_ROUGHNESS_MAP\n                                      , texture2d<float>              u_roughnessTexture\n                                      , sampler                       u_roughnessTextureSampler\n#endif\n#ifdef USE_CLEARCOAT_MAP\n                                      , texture2d<float>              u_clearCoatTexture\n                                      , sampler                       u_clearCoatTextureSampler\n#endif\n#ifdef USE_CLEARCOATROUGHNESS_MAP\n                                      , texture2d<float>              u_clearCoatRoughnessTexture\n                                      , sampler                       u_clearCoatRoughnessTextureSampler\n#endif\n#ifdef USE_CLEARCOATNORMAL_MAP\n                                      , texture2d<float>              u_clearCoatNormalTexture\n                                      , sampler                       u_clearCoatNormalTextureSampler\n#endif\n#endif \n#endif \n#ifdef USE_PBR\n                                      , texturecube<float>            u_radianceTexture\n                                      , texture2d<float>              u_specularDFGDiffuseHammonTexture\n#if !defined(USE_SELFILLUMINATION_MAP)\n                                      , texturecube<float>            u_irradianceTexture\n#endif\n#endif \n#ifdef USE_SSAO\n                                      , texture2d<float>              u_ssaoTexture\n#endif\n#ifdef USE_FRAGMENT_EXTRA_ARGUMENTS\n                                      __FragmentExtraArguments__\n#endif\n#if defined(USE_DOUBLE_SIDED)\n                                      , bool                          isFrontFacing                    [[front_facing]]\n#endif\n#ifdef USE_POINT_RENDERING\n                                      , float2                        pointCoord                       [[point_coord]]\n#endif\n#ifdef USE_VERTEX_AMPLIFICATION\n                                      , ushort                        amplificationID                  [[amplification_id]]\n#endif\n                                      )\n{\n#ifdef USE_MULTIPLE_RENDERING\n    \n#ifdef USE_VERTEX_AMPLIFICATION\n    constant SCNSceneBuffer& scn_frame = scn_frame_multi[amplificationID];\n#else\n    constant SCNSceneBuffer& scn_frame = scn_frame_multi[in.sliceIndex];\n#endif\n    \n#ifdef USE_INSTANCING\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& scn_node = scn_nodes[USE_MULTIPLE_RENDERING * in.instanceID + amplificationID];\n#else\n    constant commonprofile_node& scn_node = scn_nodes[USE_MULTIPLE_RENDERING * in.instanceID + in.sliceIndex];\n#endif\n#else\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& scn_node = scn_nodes[amplificationID];\n#else\n    constant commonprofile_node& scn_node = scn_nodes[in.sliceIndex];\n#endif\n#endif\n    \n#else \n    \n#ifdef USE_INSTANCING\n    constant commonprofile_node& scn_node = scn_nodes[in.instanceID];\n#endif\n    \n#endif \n    \n#ifdef IS_BEZIER_CURVE\n    bool insideCurve = scn_is_inside_bezier_curve(in.bezierCurveUV, scn_bezier_curve_data, scn_bezier_curve_controlPoints);\n    if (insideCurve == false) {\n        discard_fragment();\n    }\n#endif\n    \n    SCNOutput _output;\n\n    \n    \n    \n    \n    SCNShaderSurface _surface;\n#ifdef USE_TEXCOORD\n    __FragmentDoTexcoord__\n#endif\n    _surface.ambientOcclusion = 1.f; \n#ifdef USE_AMBIENT_MAP\n    #ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION\n        #if defined(USE_AMBIENT_TEXTURE_COMPONENT)\n            _surface.ambientOcclusion = colorFromMask(u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord), USE_AMBIENT_TEXTURE_COMPONENT).r;\n        #else\n            _surface.ambientOcclusion = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord).r;\n        #endif\n        #ifdef USE_AMBIENT_INTENSITY\n            _surface.ambientOcclusion = saturate(mix(1.f, _surface.ambientOcclusion, scn_commonprofile.ambientIntensity));\n        #endif\n    #else \n        _surface.ambient = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord);\n        #if defined(USE_AMBIENT_TEXTURE_COMPONENT)\n            _surface.ambient = colorFromMask(_surface.ambient, USE_AMBIENT_TEXTURE_COMPONENT);\n        #endif\n        #ifdef USE_AMBIENT_INTENSITY\n            _surface.ambient *= scn_commonprofile.ambientIntensity;\n        #endif\n    #endif \n#elif defined(USE_AMBIENT_COLOR)\n    _surface.ambient = scn_commonprofile.ambientColor;\n#elif defined(USE_AMBIENT)\n    _surface.ambient = float4(0.);\n#endif\n#if defined(USE_AMBIENT) && defined(USE_VERTEX_COLOR)\n    _surface.ambient *= in.vertexColor;\n#endif\n#if  defined(USE_SSAO)\n    _surface.ambientOcclusion *= u_ssaoTexture.sample( sampler(filter::linear), in.fragmentPosition.xy * scn_frame.inverseResolution.xy ).x;\n#endif\n    \n#ifdef USE_DIFFUSE_MAP\n    _surface.diffuse = u_diffuseTexture.sample(u_diffuseTextureSampler, _surface.diffuseTexcoord);\n#if defined(USE_DIFFUSE_TEXTURE_COMPONENT)\n    _surface.diffuse = colorFromMask(_surface.diffuse, USE_DIFFUSE_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_DIFFUSE_INTENSITY\n    _surface.diffuse.rgb *= scn_commonprofile.diffuseIntensity;\n#endif\n#elif defined(USE_DIFFUSE_COLOR)\n    _surface.diffuse = scn_commonprofile.diffuseColor;\n#else\n    _surface.diffuse = float4(0.f,0.f,0.f,1.f);\n#endif\n#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)\n    _surface.diffuse.rgb    *= in.vertexColor.rgb;\n    _surface.diffuse        *= in.vertexColor.a; \n#endif\n#ifdef USE_SPECULAR_MAP\n    _surface.specular = u_specularTexture.sample(u_specularTextureSampler, _surface.specularTexcoord);\n#if defined(USE_SPECULAR_TEXTURE_COMPONENT)\n    _surface.specular = colorFromMask(_surface.specular, USE_SPECULAR_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_SPECULAR_INTENSITY\n    _surface.specular *= scn_commonprofile.specularIntensity;\n#endif\n#elif defined(USE_SPECULAR_COLOR)\n    _surface.specular = scn_commonprofile.specularColor;\n#elif defined(USE_SPECULAR)\n    _surface.specular = float4(0.f);\n#endif\n    \n#ifdef USE_CLEARCOAT_MAP\n    _surface.clearCoat = u_clearCoatTexture.sample(u_clearCoatTextureSampler, _surface.clearCoatTexcoord).r;\n#if defined(USE_CLEARCOAT_TEXTURE_COMPONENT)\n    _surface.clearCoat = colorFromMask(_surface.clearCoat, USE_CLEARCOAT_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_CLEARCOAT_INTENSITY\n    _surface.clearCoat *= scn_commonprofile.clearCoatIntensity;\n#endif\n#elif defined(USE_CLEARCOAT_COLOR)\n    _surface.clearCoat = scn_commonprofile.clearCoat;\n#elif defined(USE_CLEARCOAT)\n    _surface.clearCoat = 0.f;\n#endif\n    \n#ifdef USE_CLEARCOATROUGHNESS_MAP\n#if defined(USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT)\n    _surface.clearCoatRoughness = colorFromMask(u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord), USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.clearCoatRoughness = u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord).r;\n#endif\n#ifdef USE_CLEARCOATROUGHNESS_INTENSITY\n    _surface.clearCoatRoughness *= scn_commonprofile.clearCoatRoughnessIntensity;\n#endif\n#elif defined(USE_CLEARCOATROUGHNESS_COLOR)\n    _surface.clearCoatRoughness = scn_commonprofile.clearCoatRoughness;\n#else\n    _surface.clearCoatRoughness = 0.03f;\n#endif\n \n#ifdef USE_EMISSION_MAP\n    _surface.emission = u_emissionTexture.sample(u_emissionTextureSampler, _surface.emissionTexcoord);\n#if defined(USE_EMISSION_TEXTURE_COMPONENT)\n    _surface.emission = colorFromMask(_surface.emission, USE_EMISSION_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_EMISSION_INTENSITY\n    _surface.emission *= scn_commonprofile.emissionIntensity;\n#endif\n#elif defined(USE_EMISSION_COLOR)\n    _surface.emission = scn_commonprofile.emissionColor;\n#elif defined(USE_EMISSION)\n    _surface.emission = float4(0.);\n#endif\n#ifdef USE_SELFILLUMINATION_MAP\n    _surface.selfIllumination = u_selfIlluminationTexture.sample(u_selfIlluminationTextureSampler, _surface.selfIlluminationTexcoord);\n#if defined(USE_SELFILLUMINATION_TEXTURE_COMPONENT)\n    _surface.selfIllumination = colorFromMask(_surface.selfIllumination, USE_SELFILLUMINATION_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_SELFILLUMINATION_INTENSITY\n    _surface.selfIllumination *= scn_commonprofile.selfIlluminationIntensity;\n#endif\n#elif defined(USE_SELFILLUMINATION_COLOR)\n    _surface.selfIllumination = scn_commonprofile.selfIlluminationColor;\n#elif defined(USE_SELFILLUMINATION)\n    _surface.selfIllumination = float4(0.);\n#endif\n#ifdef USE_MULTIPLY_MAP\n    _surface.multiply = u_multiplyTexture.sample(u_multiplyTextureSampler, _surface.multiplyTexcoord);\n#if defined(USE_MULTIPLY_TEXTURE_COMPONENT)\n    _surface.multiply = colorFromMask(_surface.multiply, USE_MULTIPLY_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_MULTIPLY_INTENSITY\n    _surface.multiply = mix(float4(1.), _surface.multiply, scn_commonprofile.multiplyIntensity);\n#endif\n#elif defined(USE_MULTIPLY_COLOR)\n    _surface.multiply = scn_commonprofile.multiplyColor;\n#elif defined(USE_MULTIPLY)\n    _surface.multiply = float4(1.);\n#endif\n#ifdef USE_TRANSPARENT_MAP\n    _surface.transparent = u_transparentTexture.sample(u_transparentTextureSampler, _surface.transparentTexcoord);\n#if defined(USE_TRANSPARENT_TEXTURE_COMPONENT)\n    _surface.transparent = colorFromMask(_surface.transparent, USE_TRANSPARENT_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_TRANSPARENT_INTENSITY\n    _surface.transparent *= scn_commonprofile.transparentIntensity;\n#endif\n#elif defined(USE_TRANSPARENT_COLOR)\n    _surface.transparent = scn_commonprofile.transparentColor;\n#elif defined(USE_TRANSPARENT)\n    _surface.transparent = float4(1.f);\n#endif\n    \n#ifdef USE_METALNESS_MAP\n#if defined(USE_METALNESS_TEXTURE_COMPONENT)\n    _surface.metalness = colorFromMask(u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord), USE_METALNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.metalness = u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord).r;\n#endif\n#ifdef USE_METALNESS_INTENSITY\n    _surface.metalness *= scn_commonprofile.metalnessIntensity;\n#endif\n#elif defined(USE_METALNESS_COLOR)\n    _surface.metalness = scn_commonprofile.metalness;\n#else\n    _surface.metalness = 0.f;\n#endif\n    \n#ifdef USE_ROUGHNESS_MAP\n#if defined(USE_ROUGHNESS_TEXTURE_COMPONENT)\n    _surface.roughness = colorFromMask(u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord), USE_ROUGHNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.roughness = u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord).r;\n#endif\n#ifdef USE_ROUGHNESS_INTENSITY\n    _surface.roughness *= scn_commonprofile.roughnessIntensity;\n#endif\n#elif defined(USE_ROUGHNESS_COLOR)\n    _surface.roughness = scn_commonprofile.roughness;\n#else\n    _surface.roughness = 0.f;\n#endif\n#if (defined USE_POSITION) && (USE_POSITION == 2)\n    _surface.position = in.position;\n#endif\n#if (defined USE_NORMAL) && (USE_NORMAL == 2)\n#if defined(HAS_NORMAL) || defined(USE_OPENSUBDIV)\n#ifdef USE_DOUBLE_SIDED\n    _surface.geometryNormal = normalize(in.normal.xyz) * (isFrontFacing ? 1.f : -1.f );\n#else\n    _surface.geometryNormal = normalize(in.normal.xyz);\n#endif\n#else \n    _surface.geometryNormal = normalize( cross(dfdy( _surface.position ), dfdx( _surface.position ) ));\n#endif\n    _surface.normal = _surface.geometryNormal;\n    _surface.clearCoatNormal = _surface.geometryNormal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    _surface.tangent = in.tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    _surface.bitangent = in.bitangent;\n#endif\n#if (defined USE_VIEW) && (USE_VIEW == 2)\n    _surface.view = normalize(-in.position);\n    {\n        \n        \n        float NoV = dot(_surface.geometryNormal, _surface.view);\n        _surface.view = _surface.view + max(0.f, -2.f * NoV) * _surface.geometryNormal;         \n        \n    }\n#endif\n#if defined(USE_NORMAL_MAP)\n    {\n        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.normal);\n#ifdef USE_NORMAL_MAP\n#if defined(USE_NORMAL_TEXTURE_COMPONENT)\n        _surface._normalTS.xy = colorFromMask(u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord), USE_NORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;\n        _surface._normalTS.z = sqrt(1.f - saturate(length_squared(_surface._normalTS.xy)));\n#else\n        _surface._normalTS = u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord).rgb;\n        _surface._normalTS = _surface._normalTS * 2.f - 1.f;\n#endif\n#ifdef USE_NORMAL_INTENSITY\n        _surface._normalTS = mix(float3(0.f, 0.f, 1.f), _surface._normalTS, scn_commonprofile.normalIntensity);\n#endif\n#else\n        _surface._normalTS = float3(0.f, 0.f, 1.f);\n#endif\n        _surface.normal.rgb = normalize(ts2vs * _surface._normalTS.xyz );\n    }\n#else\n    _surface._normalTS = float3(0.f, 0.f, 1.f);\n#endif\n#ifdef USE_PBR\n    {\n        float roughness = clamp(_surface.roughness, PBR_MIN_ROUGHNESS, 1.0);\n        float alpha = scn_filteredAlphaFromRoughness(_surface.normal, roughness);\n        _surface.roughness = sqrt(alpha);\n    }\n#endif\n#if defined(USE_CLEARCOATNORMAL_MAP)\n    {\n        \n        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.geometryNormal);\n#ifdef USE_CLEARCOATNORMAL_MAP\n#if defined(USE_CLEARCOATNORMAL_TEXTURE_COMPONENT)\n        _surface._clearCoatNormalTS.xy = colorFromMask(u_clearCoatNormalTexture.sample(u_clearCoatnormalTextureSampler, _surface.clearCoatNormalTexcoord), USE_CLEARCOATNORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;\n        _surface._clearCoatNormalTS.z = sqrt(1.f - saturate(length_squared(_surface._clearCoatNormalTS.xy)));\n#else\n        _surface._clearCoatNormalTS = u_clearCoatNormalTexture.sample(u_clearCoatNormalTextureSampler, _surface.clearCoatNormalTexcoord).rgb;\n        _surface._clearCoatNormalTS = _surface._clearCoatNormalTS * 2.f - 1.f;\n#endif\n#ifdef USE_CLEARCOATNORMAL_INTENSITY\n        _surface._clearCoatNormalTS = mix(float3(0.f, 0.f, 1.f), _surface._clearCoatNormalTS, scn_commonprofile.clearCoatNormalIntensity);\n#endif\n#else\n        _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);\n#endif\n        _surface.clearCoatNormal.rgb = normalize(ts2vs * _surface._clearCoatNormalTS.xyz );\n    }\n#else\n    _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);\n#endif\n    \n#ifdef USE_REFLECTIVE_MAP\n    float3 refl = reflect( -_surface.view, _surface.normal );\n    float m = 2.f * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.f)*(refl.z+1.f));\n    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, float2(float2(refl.x,-refl.y) / m) + 0.5f);\n#if defined(USE_REFLECTIVE_TEXTURE_COMPONENT)\n    _surface.reflective = colorFromMask(_surface.reflective, USE_REFLECTIVE_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_REFLECTIVE_INTENSITY\n    _surface.reflective *= scn_commonprofile.reflectiveIntensity;\n#endif\n#elif defined(USE_REFLECTIVE_CUBEMAP)\n    float3 refl = reflect( _surface.position, _surface.normal );\n    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, scn::mat4_mult_float3(scn_frame.viewToCubeTransform, refl)); \n#ifdef USE_REFLECTIVE_INTENSITY\n    _surface.reflective *= scn_commonprofile.reflectiveIntensity;\n#endif\n#elif defined(USE_REFLECTIVE_COLOR)\n    _surface.reflective = scn_commonprofile.reflectiveColor;\n#elif defined(USE_REFLECTIVE)\n    _surface.reflective = float4(0.);\n#endif\n#ifdef USE_FRESNEL\n    _surface.fresnel = scn_commonprofile.fresnel.x + scn_commonprofile.fresnel.y * pow(1.f - saturate(dot(_surface.view, _surface.normal)), scn_commonprofile.fresnel.z);\n    _surface.reflective *= _surface.fresnel;\n#endif\n#ifdef USE_SHININESS\n    _surface.shininess = scn_commonprofile.materialShininess;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_SURFACE_MODIFIER\n    \n    __DoSurfaceModifier__\n    \n#endif\n    \n    \n    \n    \n    \n    SCNShaderLightingContribution _lightingContribution(_surface, in);\n#ifdef USE_LIGHT_MODIFIER\n    __LightModifierCopyDecl__\n#endif\n#ifdef USE_AMBIENT_LIGHTING\n    _lightingContribution.ambient = scn_frame.ambientLightingColor.rgb;\n#endif\n#ifdef USE_LIGHTING\n#ifdef USE_PER_PIXEL_LIGHTING\n#ifdef USE_CLUSTERED_LIGHTING\n    uint3 clusterIndex;\n    clusterIndex.xy = uint2(in.fragmentPosition.xy * scn_frame.clusterScale.xy); \n    clusterIndex.z = in.position.z * scn_frame.clusterScale.z + scn_frame.clusterScale.w; \n    \n    \n    ushort4 cluster_offset_count = u_clusterTexture.read(clusterIndex);\n    int lid = cluster_offset_count.x;\n#endif\n\n#ifdef USE_PBR\n    _lightingContribution.prepareForPBR(u_specularDFGDiffuseHammonTexture, scn_commonprofile.selfIlluminationOcclusion);\n    \n    \n#ifdef USE_SELFILLUMINATION\n    _lightingContribution.add_irradiance_from_selfIllum();\n#else\n#ifdef USE_PROBES_LIGHTING \n    _lightingContribution.add_global_irradiance_from_sh(scn_frame.viewToCubeTransform, scn_node.shCoefficients);\n#else\n    _lightingContribution.add_global_irradiance_probe(u_irradianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);\n#endif\n#endif\n\n    \n#ifndef DISABLE_SPECULAR\n#ifdef C3D_USE_REFLECTION_PROBES\n    int probe_count = (cluster_offset_count.z & 0xff);\n    for (int i = 0 ; i < probe_count; ++i, ++lid) {\n        _lightingContribution.add_local_probe(scn_lights[LightIndex(lid)], u_reflectionProbeTexture);\n    }\n#if PROBES_NORMALIZATION\n#if PROBES_OUTER_BLENDING\n    _lightingContribution.specular += _lightingContribution.probesWeightedSum.rgb / max(1.f, _lightingContribution.probesWeightedSum.a);\n#else\n    _lightingContribution.specular += _lightingContribution.probesWeightedSum.rgb / _lightingContribution.probesWeightedSum.a;\n#endif\n    float globalFactor = saturate(1.f - _lightingContribution.probesWeightedSum.a);\n#else\n    float globalFactor = _lightingContribution.probeRadianceRemainingFactor;\n#endif\n    _lightingContribution.add_global_probe(scn_frame.viewToCubeTransform, globalFactor * scn_frame.environmentIntensity,\n                                           u_reflectionProbeTexture);\n#else \n   _lightingContribution.add_global_probe(u_radianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);\n    \n#ifdef USE_CLEARCOAT\n    _lightingContribution.add_global_probeClearCoat(u_radianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);\n#endif\n\n    \n#endif \n#endif \n\n#endif \n    #if DEBUG_PIXEL\n        switch (DEBUG_PIXEL) {\n            case 1: _output.color = float4(_surface.normal * 0.5f + 0.5f, 1.f); break;\n            case 2: _output.color = float4(_surface.geometryNormal * 0.5f + 0.5f, 1.f); break;\n            case 3: _output.color = float4(_surface.tangent * 0.5f + 0.5f, 1.f); break;\n            case 4: _output.color = float4(in.uv0, 0.f, 1.f); break;\n            case 5: _output.color = float4(_surface.diffuse.rgb, 1.f); break;\n            case 6: _output.color = float4(float3(_surface.roughness), 1.f); break;\n            case 7: _output.color = float4(float3(_surface.metalness), 1.f); break;\n            case 8: _output.color = float4(float3(_surface.ambientOcclusion), 1.f); break;\n            default: break;\n        }\n        return _output;\n    #endif\n    \n    __FragmentDoLighting__\n    \n    #ifdef USE_CLUSTERED_LIGHTING\n        \n        int omni_count = cluster_offset_count.y & 0xff;\n        for (int i = 0 ; i < omni_count; ++i, ++lid) {\n            _lightingContribution.add_local_omni(scn_lights[LightIndex(lid)]);\n        }\n\n        \n        int spot_count = (cluster_offset_count.y >> 8);\n        for (int i = 0 ; i < spot_count; ++i, ++lid) {\n            _lightingContribution.add_local_spot(scn_lights[LightIndex(lid)]);\n        }\n\n    #endif\n#else \n        _lightingContribution.diffuse = in.diffuse;\n    #ifdef USE_SPECULAR\n        _lightingContribution.specular = in.specular;\n    #endif\n#endif \n    #ifdef AVOID_OVERLIGHTING\n        _lightingContribution.diffuse = saturate(_lightingContribution.diffuse);\n    #ifdef USE_SPECULAR\n        _lightingContribution.specular = saturate(_lightingContribution.specular);\n    #endif \n    #endif \n#else \n    _lightingContribution.diffuse = float3(1.);\n#endif \n\n    \n    \n    \n    \n#ifdef USE_PBR\n    { \n        float3 diffuseAlbedo = mix(_lightingContribution.pbr.albedo, float3(0.0), _surface.metalness);\n        \n        \n#ifdef USE_PBR_TRANSPARENCY\n        float3 color = (_lightingContribution.ambient * _surface.ambientOcclusion) * _lightingContribution.pbr.albedo;\n#else\n        float3 color = (_lightingContribution.ambient * _surface.ambientOcclusion) * _surface.diffuse.rgb;\n#endif\n        \n        color += _lightingContribution.pbr.envDiffuse;\n        color += _lightingContribution.diffuse * diffuseAlbedo;\n#ifndef DISABLE_SPECULAR\n        color += _lightingContribution.pbr.envSpecular;\n        color += _lightingContribution.specular;\n#endif\n#ifdef USE_EMISSION\n        color += _surface.emission.rgb;\n#endif\n#ifdef USE_MULTIPLY\n        color *= _surface.multiply.rgb;\n#endif\n#ifdef USE_MODULATE\n        color *= _lightingContribution.modulate;\n#endif\n        _output.color.rgb = color;\n    }\n#else \n\n#ifdef USE_SHADOWONLY\n    _output.color.rgb = float3(0.0);\n    _output.color.a = 1. - _lightingContribution.shadowFactor;\n#else\n    _output.color.rgb = illuminate(_surface, _lightingContribution);\n#endif\n#endif\n\n#ifndef USE_SHADOWONLY\n  #ifdef USE_PBR_TRANSPARENCY\n    _output.color.a = _lightingContribution.pbr.transparency;\n  #else\n    _output.color.a = _surface.diffuse.a;\n  #endif\n#endif\n\n#ifdef USE_FOG\n    float fogFactor = pow(clamp(length(_surface.position.xyz) * scn_frame.fogParameters.x + scn_frame.fogParameters.y, 0., scn_frame.fogColor.a), scn_frame.fogParameters.z);\n    _output.color.rgb = mix(_output.color.rgb, scn_frame.fogColor.rgb * _output.color.a, fogFactor);\n#endif\n\n#if !defined(DIFFUSE_PREMULTIPLIED) && !defined(USE_PBR_TRANSPARENCY)\n    _output.color.rgb *= _surface.diffuse.a;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_SHADOWONLY\n    float transparencyFactor = 1.0;\n  #ifdef USE_NODE_OPACITY\n    transparencyFactor *= in.nodeOpacity;\n  #endif\n    _output.color.a *= transparencyFactor; \n\n#else \n\n#ifdef USE_TRANSPARENT \n    \n#ifdef USE_TRANSPARENCY\n    _surface.transparent *= scn_commonprofile.transparency;\n#endif\n    \n#ifdef USE_TRANSPARENCY_RGBZERO\n    \n    _surface.transparent.a = (_surface.transparent.r * 0.212671f) + (_surface.transparent.g * 0.715160f) + (_surface.transparent.b * 0.072169f);\n    _output.color *= (float4(1.f) - _surface.transparent);\n#else\n  #ifndef USE_PBR_TRANSPARENCY\n    _output.color *= _surface.transparent.a;\n  #endif\n#endif\n    \n#else \n    \n#ifdef USE_TRANSPARENCY \n  #ifndef USE_PBR_TRANSPARENCY\n    _output.color *= scn_commonprofile.transparency;\n  #endif\n#endif\n    \n#endif \n    \n#ifdef USE_NODE_OPACITY\n    _output.color *= in.nodeOpacity;\n#endif\n    \n#endif \n    \n    \n    \n    \n    \n#ifdef USE_MODIFIER_FRAMEBUFFER\n    const SCNFramebuffer _framebuffer = {\n#if defined(C3D_SUPPORTS_PROGRAMMABLE_BLENDING) && defined(USE_MODIFIER_FRAMEBUFFER_COLOR0)\n        .color = framebufferColor0\n#else\n        .color = 0.f\n#endif\n    };\n#endif\n    \n#ifdef USE_FRAGMENT_MODIFIER\n    \n    __DoFragmentModifier__\n    \n#endif\n#if defined(USE_CLUSTERED_LIGHTING) && defined(DEBUG_CLUSTER_TILE)\n    _output.color.rgb = mix(_output.color.rgb, float3(scn::debugColorForCount(clusterIndex.z).xyz), 0.1f);\n    _output.color.rgb = mix(_output.color.rgb, float3(clusterIndex.x & 0x1 ^ clusterIndex.y & 0x1).xyz, 0.01f);\n#endif\n#ifdef DISABLE_LINEAR_RENDERING\n    _output.color.rgb = scn::linear_to_srgb(_output.color.rgb);\n#endif\n    \n#ifdef USE_DISCARD\n    if (_output.color.a == 0.) \n        discard_fragment();\n#endif\n\n#ifdef USE_POINT_RENDERING\n    if ((dfdx(pointCoord.x) < 0.5f) && (length_squared(pointCoord * 2.f - 1.f) > 1.f)) {\n        discard_fragment();\n    }\n#endif\n    \n    \n#ifdef USE_OUTLINE\n    _output.color.rgb = in.outlineHash;\n#endif\n    \n\n#ifdef USE_MOTIONBLUR\n#ifdef USE_MULTIPLE_RENDERING\n    _output.motionblur.xy = half2((in.mv_fragment.xy - scn_frame.viewportSize.zw) / in.mv_fragment.z - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * scn_frame.motionBlurIntensity;\n#else\n    _output.motionblur.xy = half2((in.mv_fragment.xy / in.mv_fragment.z) - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * scn_frame.motionBlurIntensity;\n#endif\n    _output.motionblur.z = length(_output.motionblur.xy);\n    _output.motionblur.w = half(-_surface.position.z);\n#endif\n\n#ifdef USE_NORMALS_OUTPUT\n    _output.normals = half4( half3(_surface.normal.xyz), half(_surface.roughness) );\n#endif\n    \n#ifdef USE_RADIANCE_OUTPUT\n    _output.radiance.rgb = half3(_lightingContribution.specular.rgb);\n#endif\n                                 \n#ifdef USE_REFLECTANCE_ROUGHNESS_OUTPUT\n#ifdef USE_PBR\n    _output.reflectanceRoughnessOutput = half4( half3(_lightingContribution.pbr.probeReflectance), half(_surface.roughness) );\n#else \n    _output.reflectanceRoughnessOutput = half4( 0.h );\n#endif\n#endif\n    \n    return _output;\n}\n"
- "@44@0:8@16@24B32Q36"
- "Assertion '%s' failed. Internal consistency error - unexpected sparse moprh target"
- "Assertion '%s' failed. inconsistent physically-based camera settings"
- "Error: C3DFXTechniqueSetValueForSymbol - expect an image for paramName %@"
- "Error: SCNDecodemage: invalid archive"
- "Welcome to SceneKit 603.500 (Apr 19 2025 02:59:03)"
- "_morphTargetCount"
- "_morphTargets"
- "float2 bezierCurveUV [[ sample_perspective ]];\n"
- "splitInputOutputStructsIfNeededForSourceCode:generatedFromReplacementStrings:perPixelLighting:clipDistanceCount:"
- "vecSize.x > 0.0 && vecSize.y > 0.0"
- "weightCount == _morphTargetCount"
- "{?=\"currentLightingSet\"{?=\"lights\"[8C]}\"currentShadowMaps\"[8@\"<MTLTexture>\"]\"currentGoboMaps\"[8@\"<MTLTexture>\"]\"frameLightingSetDatas\"{unordered_map<unsigned long long, SCNMTLLightSetData, std::hash<unsigned long long>, std::equal_to<unsigned long long>, std::allocator<std::pair<const unsigned long long, SCNMTLLightSetData>>>=\"__table_\"{__hash_table<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::__unordered_map_hasher<unsigned long long, std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::hash<unsigned long long>, std::equal_to<unsigned long long>>, std::__unordered_map_equal<unsigned long long, std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::equal_to<unsigned long long>, std::hash<unsigned long long>>, std::allocator<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>>>=\"__bucket_list_\"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *>>>=\"__ptr_\"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *>>>=\"__value_\"^^v\"__value_\"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *>>=\"__data_\"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *>>=\"__value_\"Q}}}}\"__p1_\"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *>>>=\"__value_\"{__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *>=\"__next_\"^v}}\"__p2_\"{__compressed_pair<unsigned long, std::__unordered_map_hasher<unsigned long long, std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::hash<unsigned long long>, std::equal_to<unsigned long long>>>=\"__value_\"Q}\"__p3_\"{__compressed_pair<float, std::__unordered_map_equal<unsigned long long, std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::equal_to<unsigned long long>, std::hash<unsigned long long>>>=\"__value_\"f}}}\"currentLightingHashKey\"Q\"currentLightingDesc\"{?=\"count\"q\"lights\"[8^{__C3DLight}]\"lightsData\"[8^{__C3DLightRuntimeData}]}\"currentLightingSpace\"{?=\"columns\"[4]}\"currentLightingSpaceShadow\"{?=\"columns\"[4]}\"needLightingSpaceTransformation\"B\"clusterSystem\"{SCNMTLClusterSystem=\"clustersCount\"\"tileSize\"\"selectedDebugClusterIndex\"\"_debugClusterTilesPipeline\"@\"SCNMTLRenderPipeline\"\"_debugLightIndicesBufferPipeline\"@\"SCNMTLRenderPipeline\"\"_debugClusterSlicesPipeline\"@\"SCNMTLRenderPipeline\"\"_debugProgram\"[7^{__C3DFXMetalProgram}]\"_debugShapes\"[7^{__C3DMesh}]}\"clusterInfo\"{Info=\"clusterBuffer\"{?=\"memory\"*\"buffer\"@\"<MTLBuffer>\"\"offset\"Q}\"clusterTexture\"@\"<MTLTexture>\"\"lightIndicesTexture\"@\"<MTLTexture>\"\"cellSize\"\"clusterScale\"\"cellPixelSize\"\"omniLightsRange\"\"spotLightsRange\"\"probeLightsRange\"\"lightsBuffer\"{?=\"memory\"*\"buffer\"@\"<MTLBuffer>\"\"offset\"Q}\"lightsBufferLightCount\"I\"shadowTextures\"[8@\"<MTLTexture>\"]\"iesOrGoboTextures\"[8@\"<MTLTexture>\"]\"samplerStates\"[8@\"<MTLSamplerState>\"]\"areaBuffer\"@\"<MTLBuffer>\"\"areaBufferOffset\"Q\"areaBufferOffsets\"[8Q]}\"reflectionProbesTextureArray\"@\"<MTLTexture>\"}"
- "{?=\"frameBuffer\"^{__C3DFramebuffer}\"multisamplingFrameBuffer\"^{__C3DFramebuffer}\"drawableSize\"{CGSize=\"width\"d\"height\"d}}"
- "{?=\"lock\"{os_unfair_lock_s=\"_os_unfair_lock_opaque\"I}\"keyCodeConfiguration\"@\"NSDictionary\"\"keyDown\"{set<unsigned short, std::less<unsigned short>, std::allocator<unsigned short>>=\"__tree_\"{__tree<unsigned short, std::less<unsigned short>, std::allocator<unsigned short>>=\"__begin_node_\"^v\"__pair1_\"{__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<unsigned short, void *>>>=\"__value_\"{__tree_end_node<std::__tree_node_base<void *> *>=\"__left_\"^v}}\"__pair3_\"{__compressed_pair<unsigned long, std::less<unsigned short>>=\"__value_\"Q}}}\"forward\"{vector<unsigned short, std::allocator<unsigned short>>=\"__begin_\"^S\"__end_\"^S\"__end_cap_\"{__compressed_pair<unsigned short *, std::allocator<unsigned short>>=\"__value_\"^S}}\"backward\"{vector<unsigned short, std::allocator<unsigned short>>=\"__begin_\"^S\"__end_\"^S\"__end_cap_\"{__compressed_pair<unsigned short *, std::allocator<unsigned short>>=\"__value_\"^S}}\"left\"{vector<unsigned short, std::allocator<unsigned short>>=\"__begin_\"^S\"__end_\"^S\"__end_cap_\"{__compressed_pair<unsigned short *, std::allocator<unsigned short>>=\"__value_\"^S}}\"right\"{vector<unsigned short, std::allocator<unsigned short>>=\"__begin_\"^S\"__end_\"^S\"__end_cap_\"{__compressed_pair<unsigned short *, std::allocator<unsigned short>>=\"__value_\"^S}}}"
- "{c3dAether=\"_fields\"{vector<c3dPhysicsField *, std::allocator<c3dPhysicsField *>>=\"__begin_\"^^{c3dPhysicsField}\"__end_\"^^{c3dPhysicsField}\"__end_cap_\"{__compressed_pair<c3dPhysicsField **, std::allocator<c3dPhysicsField *>>=\"__value_\"^^{c3dPhysicsField}}}\"_activeFields\"{vector<c3dPhysicsField *, std::allocator<c3dPhysicsField *>>=\"__begin_\"^^{c3dPhysicsField}\"__end_\"^^{c3dPhysicsField}\"__end_cap_\"{__compressed_pair<c3dPhysicsField **, std::allocator<c3dPhysicsField *>>=\"__value_\"^^{c3dPhysicsField}}}\"_lastOverrideIndex\"I}"

```
