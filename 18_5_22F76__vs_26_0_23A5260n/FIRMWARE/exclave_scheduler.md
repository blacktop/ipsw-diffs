## exclave_scheduler

> `exclave_scheduler`

```diff

-839.120.30.0.0
-  __TEXT.__text: 0x2fafd0
-  __TEXT.__lcxx_override: 0x200
-  __TEXT.__cstring: 0x20400
-  __TEXT.__const: 0xd7e8e
-  __TEXT.__constg_swiftt: 0xa4c8
-  __TEXT.__swift5_typeref: 0x5b20
-  __TEXT.__swift5_builtin: 0xa8c
-  __TEXT.__swift5_reflstr: 0x2441
-  __TEXT.__swift5_fieldmd: 0x609c
-  __TEXT.__swift5_assocty: 0x48e8
-  __TEXT.__swift5_proto: 0x14a8
-  __TEXT.__swift5_types: 0x8f4
-  __TEXT.__swift5_protos: 0x228
-  __TEXT.__swift5_types2: 0x8
-  __TEXT.__swift5_mpenum: 0xe8
+1195.0.10.0.0
+  __TEXT.__text: 0x310010
+  __TEXT.__lcxx_override: 0x34c
+  __TEXT.__cstring: 0x21c40
+  __TEXT.__const: 0xd90d2
+  __TEXT.__constg_swiftt: 0xa86c
+  __TEXT.__swift5_typeref: 0x5db2
+  __TEXT.__swift5_builtin: 0xab4
+  __TEXT.__swift5_reflstr: 0x2615
+  __TEXT.__swift5_fieldmd: 0x6500
+  __TEXT.__swift5_assocty: 0x4a10
+  __TEXT.__swift5_proto: 0x1540
+  __TEXT.__swift5_types: 0x930
+  __TEXT.__swift5_protos: 0x238
+  __TEXT.__swift5_types2: 0x2c
+  __TEXT.__swift5_mpenum: 0x14c
   __TEXT.__swift5_entry: 0x8
-  __TEXT.__swift5_capture: 0x388
-  __TEXT.__swift_as_entry: 0x210
-  __TEXT.__swift_as_ret: 0x298
+  __TEXT.__swift5_capture: 0x408
+  __TEXT.__swift_as_entry: 0x224
+  __TEXT.__swift_as_ret: 0x2ac
   __TEXT.__swift5_replace: 0x0
   __TEXT.__constructor: 0x0
   __TEXT.__init_offsets: 0x0
   __TEXT.__term_offsets: 0x0
   __TEXT.__thread_starts: 0x24
-  __TEXT.__eh_frame: 0xfaac
+  __TEXT.__eh_frame: 0xfd48
   __DATA.__got: 0x8
-  __DATA.__auth_ptr: 0x50
+  __DATA.__auth_ptr: 0x58
   __DATA.__mod_init_func: 0x48
-  __DATA.__const: 0x19358
+  __DATA.__const: 0x1a4a8
   __DATA.__objc_imageinfo: 0x8
   __DATA.__ENDPOINTS: 0xc54
-  __DATA.__data: 0x46a8
+  __DATA.__data: 0x4330
   __DATA.__thread_vars: 0x90
   __DATA.__shared_cache: 0x38
   __DATA.__mod_term_func: 0x0
   __DATA.__thread_data: 0x0
   __DATA.__thread_bss: 0x38
-  __DATA.__bss: 0x499b0
-  __DATA.__common: 0x1efc
+  __DATA.__bss: 0x498c0
+  __DATA.__common: 0x1f7b
   __PDATA.__shared_cache: 0x0
   __PDATA.__mod_init_func: 0x0
   __DATA_CONST.__mod_init_func: 0x0
   __DATA_CONST.__mod_term_func: 0x0
-  UUID: EB7C1DDC-5193-3A40-878E-4B9057AFCE59
-  Functions: 11450
-  Symbols:   24
-  CStrings:  3895
+  UUID: 9F131903-116C-30B4-BAD7-76BCCF6B9B17
+  Functions: 11744
+  Symbols:   27
+  CStrings:  3964
 
Symbols:
+ __ZnamSt11align_val_t
+ __ZnamSt11align_val_tRKSt9nothrow_t
+ __ZnwmSt11align_val_tRKSt9nothrow_t
CStrings:
+ " x "
+ "$e"
+ "%s #%03zu @ ????:0x%012zx\n"
+ "+0x0"
+ ".invalidNonSurrogateCodePointByte"
+ ".overlongEncodingByte"
+ ".surrogateCodePointByte"
+ ".truncatedScalar"
+ ".unexpectedContinuationByte"
+ "/AppleInternal/Library/BuildRoots/4~B1gjugDsddWwV53lEm2VsrI55-hGcddtlhG1mJw/Applications/Xcode.app/Contents/Developer/Platforms/ExclaveCore.iPhoneOS.platform/Developer/SDKs/ExclaveCore.iPhoneOS26.0.Internal.sdk/System/ExclaveCore/System/Library/Frameworks/xrt.framework/Headers/thread.h"
+ "/Library/Caches/com.apple.xbs/Sources/Tightbeam_exclavecore/Runtime/Tightbeam/Transports/cL4_large/cL4_large_transport.c"
+ "::mtx_init(&handle, ::mtx_recursive) failed with error %d\n"
+ "@const "
+ "A SwiftSetting should never actually be constructed"
+ "Allocation capacity must be greater than or equal to zero"
+ "COW"
+ "CompileTimeLiteral"
+ "ConstValue"
+ "CoroFunctionPointer"
+ "Count must not be negative"
+ "DefaultOverride"
+ "DependentProtocolConformanceOpaque"
+ "Error %d"
+ "FAULTABLE"
+ "FAULTABLE_DEFAULT_NOT"
+ "FAULTABLE_GUARD_END"
+ "FAULTABLE_GUARD_START"
+ "Fatal error: Attempted to read an unowned reference but object %p was already deallocated\n"
+ "Fatal error: Attempted to read an unowned reference but the object was already deallocated\n"
+ "Fatal error: Object was retained too many times\n"
+ "Fatal error: Object's unowned reference was retained too many times\n"
+ "Fatal error: Object's weak reference was retained too many times\n"
+ "Fatal error: failed to allocate %zu bytes of memory with alignment %zu\n"
+ "HO"
+ "Incorrect actor executor assumption; expected '%.*s' executor.\n"
+ "KeyPathAppliedMethodThunkHelper"
+ "KeyPathUnappliedMethodThunkHelper"
+ "L4_Type_Arm64_Sme"
+ "NonIsolatedCallerFunctionType"
+ "OPTOUT_SPANMAP"
+ "Optional("
+ "POPULATE_MAY_FAIL"
+ "SCAN_FROM_START_ADDRESS"
+ "SHARED_CL4"
+ "SHARED_XNU"
+ "Span over the small string form is not supported yet."
+ "SugaredInlineArray"
+ "Swift/EnumeratedSequence.swift"
+ "Swift/MutableSpan.swift"
+ "Swift/Span.swift"
+ "Swift/SwiftSettings.swift"
+ "Swift/TemporaryAllocation.swift"
+ "Swift/UTF8EncodingError.swift"
+ "Swift/UTF8SpanFundamentals.swift"
+ "TB_ASSERT: (disposition == TB_MESSAGE_DISPOSITION_REPLY || disposition == TB_MESSAGE_DISPOSITION_QUERY), %hhu (%s:%d)\n"
+ "TB_ASSERT: L4_ErrorCode(err) == L4_ErrorCode(L4_Success), %lu (%s:%d)\n"
+ "TB_ASSERT: accumulator->total_size >= total, %zu, %zu (%s:%d)\n"
+ "TB_ASSERT: end <= msg->transport_buffer->size, %zu, %zu (%s:%d)\n"
+ "TB_ASSERT: end <= msg_buf->size, %zu, %zu (%s:%d)\n"
+ "TB_ASSERT: end <= tpt_buf->size, %zu, %zu (%s:%d)\n"
+ "TB_ASSERT: err == TB_ERROR_SUCCESS, %lu (%s:%d)\n"
+ "TB_ASSERT: err == TB_ERROR_SUCCESS, %u (%s:%d)\n"
+ "TB_ASSERT: error == TB_ERROR_SUCCESS, %u (%s:%d)\n"
+ "TB_ASSERT: msg->state == TB_MESSAGE_STATE_RECEIVED, %u (%s:%d)\n"
+ "TB_ASSERT: msg_buf->position >= msg_buf->reserved, %zu, %zu (%s:%d)\n"
+ "TB_ASSERT: msg_err == TB_ERROR_SUCCESS, %u (%s:%d)\n"
+ "TB_ASSERT: new_slot != L4_Nil, %lu (%s:%d)\n"
+ "TB_ASSERT: num_caps <= TB_MAX_CAPS, %zu (%s:%d)\n"
+ "TB_ASSERT: num_rcv_caps <= TB_MAX_CAPS, %zu (%s:%d)\n"
+ "TB_ASSERT: payload_size <= max_sz, %zu (%s:%d)\n"
+ "TB_ASSERT: query->disposition == TB_MESSAGE_DISPOSITION_QUERY, %hhu (%s:%d)\n"
+ "TB_ASSERT: query->state == TB_MESSAGE_STATE_READY, %u (%s:%d)\n"
+ "TB_ASSERT: query->state == TB_MESSAGE_STATE_SENT, %u (%s:%d)\n"
+ "TB_ASSERT: rcv_caps <= TB_MAX_CAPS, %zu (%s:%d)\n"
+ "TB_ASSERT: rcv_err == TB_ERROR_SUCCESS, %u (%s:%d)\n"
+ "TB_ASSERT: received_caps_count <= TB_MAX_CAPS, %zu (%s:%d)\n"
+ "TB_ASSERT: self->state == TB_MESSAGE_STATE_UNINITIALIZED, %u (%s:%d)\n"
+ "TB_ASSERT: start <= msg->transport_buffer->size, %llu, %zu (%s:%d)\n"
+ "TB_ASSERT: tb_message_get_disposition(message) == TB_MESSAGE_DISPOSITION_QUERY, %hhu (%s:%d)\n"
+ "TB_ASSERT: tb_message_get_state(message) == TB_MESSAGE_STATE_RECEIVED, %u (%s:%d)\n"
+ "TB_ASSERT: td->allocated_slot_count <= TB_MAX_CAPS, %zu (%s:%d)\n"
+ "TB_ASSERT: td->allocated_slot_count == 0, %zu (%s:%d)\n"
+ "TB_ASSERT: td->received_slot_count <= td->allocated_slot_count, %zu, %zu (%s:%d)\n"
+ "TB_ASSERT: td->received_slot_count == 0, %zu (%s:%d)\n"
+ "TB_ASSERT: td->slots[i] != L4_Nil, %lu (%s:%d)\n"
+ "TB_FATAL: Copyin size did not match expected word_count (%s:%d)\n"
+ "There is no executor implementation active"
+ "TkMA"
+ "Tkmu"
+ "Twc"
+ "Twd"
+ "UTF8.ValidationError("
+ "Unexpected L4_Error: %s(%zu) err='L4_Ec_SetExtension( thread->ec, L4_Arm64_Extension_Sme, thread->sme_cap )'"
+ "V0_0"
+ "V0_1"
+ "V10_0"
+ "V10_1"
+ "V11_0"
+ "V11_1"
+ "V12_0"
+ "V12_1"
+ "V13_0"
+ "V13_1"
+ "V14_0"
+ "V14_1"
+ "V15_0"
+ "V15_1"
+ "V16_0"
+ "V16_1"
+ "V17_0"
+ "V17_1"
+ "V18_0"
+ "V18_1"
+ "V19_0"
+ "V19_1"
+ "V1_0"
+ "V1_1"
+ "V20_0"
+ "V20_1"
+ "V21_0"
+ "V21_1"
+ "V22_0"
+ "V22_1"
+ "V23_0"
+ "V23_1"
+ "V24_0"
+ "V24_1"
+ "V25_0"
+ "V25_1"
+ "V26_0"
+ "V26_1"
+ "V27_0"
+ "V27_1"
+ "V28_0"
+ "V28_1"
+ "V29_0"
+ "V29_1"
+ "V2_0"
+ "V2_1"
+ "V30_0"
+ "V30_1"
+ "V31_0"
+ "V31_1"
+ "V3_0"
+ "V3_1"
+ "V4_0"
+ "V4_1"
+ "V5_0"
+ "V5_1"
+ "V6_0"
+ "V6_1"
+ "V7_0"
+ "V7_1"
+ "V8_0"
+ "V8_1"
+ "V9_0"
+ "V9_1"
+ "XSA"
+ "YC"
+ "Yg"
+ "[VAS abort in function %s at line %d] [true: (%s)] max_slot calculation overflowed\n"
+ "[VAS abort in function %s at line %d] [true: (%s)] only DEFAULT or NOT faultable allowed, got %d\n"
+ "_$e"
+ "_Concurrency/DummyExecutor.swift"
+ "_Concurrency/ExecutorImpl.swift"
+ "_sme_fault_handler"
+ "baseAddress must be properly aligned to access Element"
+ "cL4_large_transport.c"
+ "cL4_transport.c"
+ "cL4_transport_slots.c"
+ "clock_gettime_nsec_np failed: %s"
+ "coro function pointer to "
+ "default override of "
+ "default_faultstate != VAS_SPAN_NOT_FAULTABLE"
+ "failed to allocate SME capability"
+ "frame_manager.c"
+ "internal.h"
+ "key path applied method "
+ "key path unapplied method "
+ "libc++ was configured with exceptions disabled and `operator new(size_t, align_val_t)` has been overridden, but `operator new(size_t, align_val_t, nothrow_t)` has not been overridden. This is problematic because `operator new(size_t, align_val_t, nothrow_t)` must call `operator new(size_t, align_val_t)`, which will terminate in case it fails to allocate, making it impossible for `operator new(size_t, align_val_t, nothrow_t)` to fulfill its contract (since it should return nullptr upon failure). Please make sure you override `operator new(size_t, align_val_t, nothrow_t)` as well."
+ "libc++ was configured with exceptions disabled and `operator new[](size_t, align_val_t)` has been overridden, but `operator new[](size_t, align_val_t, nothrow_t)` has not been overridden. This is problematic because `operator new[](size_t, align_val_t, nothrow_t)` must call `operator new[](size_t, align_val_t)`, which will terminate in case it fails to allocate, making it impossible for `operator new[](size_t, align_val_t, nothrow_t)` to fulfill its contract (since it should return nullptr upon failure). Please make sure you override `operator new[](size_t, align_val_t, nothrow_t)` as well."
+ "message_accumulator.c"
+ "message_splitter.c"
+ "mu"
+ "nonisolated(nonsending) "
+ "null_transport.c"
+ "opaque result conformance "
+ "os_mul_and_add_overflow(vascommon->num_easm, EASM_ADD_MAX_SLOT_CREATIONS, BASE_MAX_SLOT_CREATIONS, &max_slot_creations)"
+ "recalc_max_slots"
+ "requested %zu stack bytes, only have %zu remaining out of %zu frames"
+ "run(until condition:) not supported on this executor"
+ "self must be a properly aligned pointer for type T"
+ "should not have stopped key path projection"
+ "swift_task_enqueueMainExecutor() not supported for task-to-thread"
+ "tb_connection.c"
+ "tb_forwarding_connection.c"
+ "tb_message.c"
+ "timed out acquiring scheduler lock '%p', started @ %llu, time now %llu"
+ "unexpected error "
+ "unwrapped nil optional"
+ "vas_core_fault_table_insert"
+ "vas_slot_alloc(): created %#x/%#x slots, allocating cnode failed\n"
+ "vas_slot_alloc(): created %#x/%#x slots, allocating cnode metadata failed\n"
+ "vas_slot_alloc(): created %#x/%#x slots, at the slot creation limit. Maybe you're leaking slots?\n"
- "!init_err"
- "(disposition == TB_MESSAGE_DISPOSITION_REPLY || disposition == TB_MESSAGE_DISPOSITION_QUERY)"
- "(saved->bitmap & (1 << index)) != 0 && \"_tb_local_msg_buffer_destruct: free of unallocated buffer\""
- "/AppleInternal/Library/BuildRoots/6ea8983d-1d96-11f0-ab86-ae4c1e672297/Applications/Xcode.app/Contents/Developer/Platforms/ExclaveCore.iPhoneOS.platform/Developer/SDKs/ExclaveCore.iPhoneOS18.5.Internal.sdk/System/ExclaveCore/usr/include/xrt/thread.h"
- "/Library/Caches/com.apple.xbs/Sources/Tightbeam_exclavecore/Runtime/Tightbeam/Transports/Null/null_transport.c"
- "/Library/Caches/com.apple.xbs/Sources/Tightbeam_exclavecore/Runtime/Tightbeam/Transports/cL4/cL4_transport_slots.c"
- "/Library/Caches/com.apple.xbs/Sources/Tightbeam_exclavecore/Runtime/Tightbeam/internal.h"
- "0 && \"copyin size did not match expected ipc_words\""
- "0 && \"copyin size did not match expected word_count\""
- "0 && \"copyout did not yeild expected ipc_words\""
- "0 && \"copyout size did not match expected ipc_words\""
- "CompileTimeConst"
- "Could not resolve KeyPath"
- "D0"
- "D1"
- "D10"
- "D11"
- "D12"
- "D13"
- "D14"
- "D15"
- "D16"
- "D17"
- "D18"
- "D19"
- "D2"
- "D20"
- "D21"
- "D22"
- "D23"
- "D24"
- "D25"
- "D26"
- "D27"
- "D28"
- "D29"
- "D3"
- "D30"
- "D31"
- "D32"
- "D33"
- "D34"
- "D35"
- "D36"
- "D37"
- "D38"
- "D39"
- "D4"
- "D40"
- "D41"
- "D42"
- "D43"
- "D44"
- "D45"
- "D46"
- "D47"
- "D48"
- "D49"
- "D5"
- "D50"
- "D51"
- "D52"
- "D53"
- "D54"
- "D55"
- "D56"
- "D57"
- "D58"
- "D59"
- "D6"
- "D60"
- "D61"
- "D62"
- "D63"
- "D7"
- "D8"
- "D9"
- "Fatal error: Attempted to read an unowned reference but object %p was already deallocated"
- "Fatal error: Attempted to read an unowned reference but the object was already deallocated"
- "Fatal error: Object was retained too many times"
- "Fatal error: Object's unowned reference was retained too many times"
- "Fatal error: Object's weak reference was retained too many times"
- "ImplicitlyUnwrappedOptional"
- "L4_ErrorCode(err) == L4_ErrorCode(L4_Success)"
- "SILThunkHopToMainActorIfNeeded"
- "Swift/UTF32.swift"
- "TB_ASSERT: %s (%s:%d)\n"
- "VAS slot allocations have exceeded the slot creation limit. Maybe you're leaking slots?"
- "Waiting on a status record lock that is owned by self"
- "accumulator->total_size >= total"
- "buffer"
- "buffer->payload != NULL"
- "end <= msg->transport_buffer->size"
- "end <= msg_buf->size"
- "end <= tpt_buf->size"
- "err == TB_ERROR_SUCCESS"
- "error == TB_ERROR_SUCCESS"
- "hop to main actor thunk of "
- "local_storage != NULL"
- "msg->state == TB_MESSAGE_STATE_PREPARING"
- "msg->state == TB_MESSAGE_STATE_RECEIVED"
- "msg_buf->position >= msg_buf->reserved"
- "msg_err == TB_ERROR_SUCCESS"
- "new_slot != L4_Nil"
- "num_caps <= TB_MAX_CAPS"
- "num_rcv_caps <= TB_MAX_CAPS"
- "operation unsupported swift_task_enqueueGlobal"
- "operation unsupported swift_task_enqueueMainExecutor"
- "original_buffer->connection_owned"
- "payload_size <= max_sz"
- "ptr != NULL"
- "ptr <= saved->buffer[TB_MSG_MAX_BUFFER_COUNT-1] && \"_tb_local_msg_buffer_destruct: ptr exceeds thread local buffer count\""
- "ptr >= saved->buffer[0] && \"_tb_local_msg_buffer_destruct: ptr not within the thread local range\""
- "query->disposition == TB_MESSAGE_DISPOSITION_QUERY"
- "query->state == TB_MESSAGE_STATE_READY"
- "query->state == TB_MESSAGE_STATE_SENT"
- "rcv_caps <= TB_MAX_CAPS"
- "rcv_err == TB_ERROR_SUCCESS"
- "received_caps_count <= TB_MAX_CAPS"
- "response == &msg"
- "saved && \"_tb_local_msg_buffer_destruct: called with null buffer\""
- "self->state == TB_MESSAGE_STATE_UNINITIALIZED"
- "start <= msg->transport_buffer->size"
- "tb_message_get_disposition(message) == TB_MESSAGE_DISPOSITION_QUERY"
- "tb_message_get_state(message) == TB_MESSAGE_STATE_RECEIVED"
- "tb_priv(transport)->static_vtable != NULL"
- "td->allocated_slot_count <= TB_MAX_CAPS"
- "td->allocated_slot_count == 0"
- "td->received_slot_count <= td->allocated_slot_count"
- "td->received_slot_count == 0"
- "td->slots[i] != L4_Nil"
- "tp_priv->static_vtable != NULL"
- "tpt_buf->wrapping == false"
- "transport_buffer->connection_owned"
- "transport_buffer->wrapping == false"

```
