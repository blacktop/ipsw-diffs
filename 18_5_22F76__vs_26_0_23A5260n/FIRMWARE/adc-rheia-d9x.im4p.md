## adc-rheia-d9x.im4p

> `adc-rheia-d9x.im4p`

```diff

 
-  __TEXT.__text: 0x836ffc
-  __TEXT.__const: 0x9b59a0
-  __TEXT.text_env: 0x4fda4
-  __TEXT._rtk_mtab: 0x2b8
-  __TEXT.__cstring: 0xa378c
-  __TEXT.__data_copy: 0x200000
+  __TEXT.__text: 0xc3d0c4
+  __TEXT.__const: 0x9dac6c
+  __TEXT.text_env: 0x4f1a4
+  __TEXT.__cstring: 0x13fd6d
   __TEXT.__constructor: 0x0
-  __TEXT.__chain_starts: 0x0
-  __TEXT.__eh_frame: 0x944
-  __DATA.__const: 0x51da0
+  __TEXT.__init_offsets: 0x0
+  __TEXT.__eh_frame: 0x914
+  __DATA.__const: 0x553f0
   __DATA._rtk_heap: 0x1000
-  __DATA.__data: 0xe2a30
-  __DATA._rtk_power: 0x3a8
-  __DATA._rtk_patchbay: 0x258
+  __DATA.__data: 0xe2c60
+  __DATA._rtk_power: 0x3f8
+  __DATA._rtk_patchbay: 0x241
   __DATA._rtk_init_stack: 0x2000
   __DATA._rtk_irq_stack: 0x2000
   __DATA._rtk_exc_stack: 0x2000
   __DATA._rtk_tunables: 0x1410
-  __DATA._rtk_boot: 0x8000
+  __DATA._rtk_boot: 0xc000
   __DATA._rtk_page_tables: 0x400000
-  __DATA._rtk_threads: 0x0
+  __DATA.__data_copy: 0x180000
   __DATA._fwinfo: 0x100
-  __DATA.__mod_init_func: 0x20
   __DATA.__sysvars: 0x4
   __DATA._rtk_smp_main: 0x8
   __DATA._rtk_boot_l1: 0x80
   __DATA.__gxf_data: 0x10
-  __DATA.__zerofill: 0x5bb620
-  UUID: A2980555-B9DD-3A5B-A5A7-F3BE3986507C
-  Functions: 0
+  __DATA._rtk_mtab: 0x2b8
+  __DATA.__chain_starts: 0x2c
+  __DATA.__mod_init_func: 0x0
+  __DATA._rtk_threads: 0x0
+  __DATA.__zerofill: 0x373500
+  UUID: 7EA2788E-00C1-36BF-9E78-DE55E17569C4
+  Functions: 10998
   Symbols:   0
-  CStrings:  17879
+  CStrings:  35293
 
CStrings:
+ "\t\t\t Access a Table %u %d\n"
+ "\t\t\tComparing Section No %d\n"
+ "\t\t\tComparing Segment No %d\n"
+ "\t\t\tCopy Table %d : with noVersionCheck = %d\n"
+ "\t\t\tDumping Section %d Registers with base %p\n"
+ "\t\t\tFinished CmpnRtrDesc copy now %d From DRAM to HW\n"
+ "\t\t\tFinished section Result Read now %d From HW to DRAM\n"
+ "\t\t\tFinished section copy now %d From DRAM to HW\n"
+ "\t\t\tFinished section copy now %d From HW to DRAM\n"
+ "\t\t\tFinished table copy now %d From DRAM to HW\n"
+ "\t\t\tFinished table copy now %d From HW to DRAM\n"
+ "\t\t\tFound Table Config\n"
+ "\t\t\tOffset is 0x%x Value 0x%x\n"
+ "\t\t\tOffset is 0x%zx Value 0x%x\n"
+ "\t\t\tPower Off Section %d Registers with base %p\n"
+ "\t\t\tRead HW\n"
+ "\t\t\tRead Result for Section %d\n"
+ "\t\t\tRead Table Config\n"
+ "\t\t\tReset Section %d\n"
+ "\t\t\tSeg No %u Dst 0x%x Src 0x%x\n"
+ "\t\t\tTable %u Component %u Index 0x%x Dst 0x%x Src 0x%x\n"
+ "\t\t %s ir pattern (%d, %d) bioCaptureExpTime %d\n"
+ "\t\t Set meta ir pattern %d, subMode %u, probeMode %u, validPDEFrame %d\n"
+ "\t\t ch %zu, set v %u rd %u, exp (%llu, %llu), spd %d\n"
+ "\t\t ir test %d\n"
+ "\t\t set bktM: mode %d, (%d,%d,%d,%d,%d), g %d, flow %d bgen %d\n"
+ "\t\t set exp (%llu, %llu), \n"
+ "\t\t set focusPos %u\n"
+ "\t\t set hdrRatio 0x%x\n"
+ "\t\t set meta exposure %llu, expT %u, hdrRatio 0x%x spd %d\n"
+ "\t\t set meta gA 0x%x\n"
+ "\t\t set meta gD 0x%x(0x%x), gDigiSen 0x%x\n"
+ "\t\t set meta v %u, rd %u\n"
+ "\t\t set v %u, rd %u\n"
+ "\t\tblinkLeft: %d"
+ "\t\tblinkRight: %d"
+ "\t\teyeCoveringConfidence %d"
+ "\t\teyeRectLeft height: %f"
+ "\t\teyeRectLeft width: %f"
+ "\t\teyeRectLeft x: %f"
+ "\t\teyeRectLeft y: %f"
+ "\t\teyeRectRight height: %f"
+ "\t\teyeRectRight width: %f"
+ "\t\teyeRectRight x: %f"
+ "\t\teyeRectRight y: %f"
+ "\t\tfaceMaskConfidence %d"
+ "\t\tgroupId %d"
+ "\t\thasBlinkData: %i"
+ "\t\thasEyeData: %i"
+ "\t\thasPoseData: %i"
+ "\t\thasSkinToneData %d"
+ "\t\thasSmileData: %i"
+ "\t\tmodality %d"
+ "\t\trefinedPitch %d"
+ "\t\trefinedRoll %d"
+ "\t\trefinedYaw %d"
+ "\t %s @%llu us delta=%llu us, diff=%llu us\n"
+ "\t Bypass AiCam %d\n"
+ "\t Draw Face %d\n"
+ "\t Pose (%.3f %.3f %.3f) Position (%.3f %.3f) Orig %d"
+ "\t Pose (%.3f %.3f %.3f) Z %.3f"
+ "\t [%llu %llu]"
+ "\t anstAttr MpEn %x\n"
+ "\t enableAttr %d\n"
+ "\t enableAttrOfflineTest attrEn %d\n"
+ "\t metaEnableDebug %d\n"
+ "\t metaEnableReplay %d\n"
+ "\t%.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f"
+ "\t(%.3f %.3f) score %.3f"
+ "\tId: %d, type: %d (%.1f %.1f %.1f %.1f) c %d"
+ "\tId: %d, type: %d (%.1f %.1f %.1f %.1f) c %d pose (%d %d) s %d"
+ "\tdetected %s, pose (%.3f %.3f %.3f %.3f)"
+ "\tdstInitX: %d, dstInitY: %d"
+ "\tdstWidth: %d, dstHeight: %d"
+ "\teyesOcclusionScore=%.8f"
+ "\tframeId: %d"
+ "\thasAttn %d score %.8f"
+ "\thasEyeOcclusion %d"
+ "\thasGlasses %d score %.8f"
+ "\thasOcclusion %d"
+ "\thasRealAttn %d"
+ "\thasRelaxedOcclusion %d, FW_DETECTOR_RELAXED_EYE_THRESHOLD %.8f"
+ "\tisSingleFrameMode: %s"
+ "\tleftEyeOcclusionScore=%.8f\trightEyeOcclusionScore=%.8f\tnoseOcclusionScore=%.8f\tmouthOcclusionScore=%.8f"
+ "\tnoGlasses prediction %d"
+ "\tnumFaces: %d"
+ "\tnumModels: %d"
+ "\tnumObjects: %d"
+ "\tnumSaliencyObjects: %d"
+ "\trsModeX: %d, rsModeY: %d"
+ "\tscoreThreshold: %f"
+ "\tscoreThresholdDiscard: %f"
+ "\tsrcInitX: %d, srcInitY: %d"
+ "\tsrcStepX: %d, srcStepY: %d"
+ "\ttransparentGlasses prediction %d"
+ "\tunsupportedGlasses prediction %d"
+ "\n focus =\n %f, %f"
+ "\nFINAL[%d],nPts[%d],nInliers[%d],inlierPct[%5.4f],biasIn[%5.4f],biasOut[%5.4f]\n "
+ "\nISP[%d],nPts[%d],nInliers[%d],inlierPct[%5.4f],biasIn[%5.4f],biasOut[%5.4f],ts[%5.4f]ms\n "
+ "\n[besOutValidRect] final values = [%d, %d, %u, %u] (apsPFL = %.6f)\n\n"
+ "\n[besOutValidRect] initial values = [%d, %d, %u, %u] (apsPFL = %.6f)\n\n"
+ "                   d: (0xA:LC Event, 0xB:LC Data, 0xC:CH Data, 0xD:CH Event)\n"
+ "                   m: Mask (1bit/ch), effective if d=0xC/0xD only\n"
+ "                   t: (0:Save Data, 1:Print Data, Otherwise:ignore)\n"
+ "       range [%d..%d], cnt %d (%d%%)"
+ "       range [%d..], cnt %d (%d%%)"
+ "      low diff (%d) => trust ANFD=%d"
+ "     CCM: local=%i, glob=%i"
+ "     Curr: mode=%i, gam=%i, Drv state=%i, mode=%i, gam=%i"
+ "     ExpBias=%.3f, aeExpBias=%.3f, realExpBias=%.3f"
+ "     ExpRat=%.3f, faceExp=%.3f, luxLevel=%.1f"
+ "     Gains soft=%.3f,hard=%.3f,hith=%.3f,fwdEITRatio=%.3f"
+ "     LTM DRV ch=%i,statFc=%i,single=%i,gam=%i,digiFl=%i,strobe=%i"
+ "     PreBiasExpRat=%.3f"
+ "     average Net time %.3u us"
+ "     average PP+Meta  time %.3u us"
+ "     average Post-processing  time %.3u us"
+ "     channel=%hhu iir=%u unstable=%u fallback=%u daylight=%u indoor=%u coolStrength=%u%%"
+ "     darkExpRat=%.3f, flareScl=%.3f, darkEIT=%.3f"
+ "     filtToUse=%d={in:%.0f out:%.0f ltcClip:%.3f}"
+ "     firstFrm=%i, imuFilt=%i, mainFlash=%d"
+ "     frame received %d / detected %d / dropped %d"
+ "     globalWP R=%u B=%u targetCool R=%u B=%u prevCool R=%u B=%u skyWeight=%u"
+ "     linLTC=%i, softGainGlobLUT=%i CB=%i"
+ "     ltmGrid={TL:(%d,%d) BR:(%d,%d)}"
+ "     mthCoolGainOut R=%u B=%u fNo=%u itnFNo=%u lvtFlt=%03u CCT=%u lux=%u"
+ "     network : %d us"
+ "     pp      : %d us"
+ "     quadra=%d snsRect=(%i,%i,%i,%i)"
+ "     total   : %d us"
+ "    #%d (%x): %d - %d, {%d, %d, %d}, {%d, %d, %d}, {%d, %d, %d}\n"
+ "    CCM mode=%i, lumaMode=%i pano=%i"
+ "    Gain split: ispDG=%.3f nxtHrd=%.3f nxtSft=%.3f fwdEITR=%.3f"
+ "    Gains tot=%.3f linFilt=%.3f GOC1=%.3f GOC2=%.3f gocClip=(%d,%d)"
+ "    HPP ltcResampleRatio=%i goc1GainR=%d"
+ "    HR=%d,hrGn=%.3f,expBias=%.3f,pnExpR=%.3f,bktExpR=%.3f,faceExpR=%.3f,SpatialVideo=%i"
+ "    LTM eit=%.3f sftGn=%.3f curveExpRat=%.3f Quadra=%d snsRect=(%i,%i,%i,%i)"
+ "    LTMDmaSrcGrid: addr=%p stride=%i size=%i XY=(%i,%i) WH=(%i,%i)\n"
+ "    LTMGrid offset=(%i,%i)(%.3f,%.3f) px=(%i,%i); size=(%i,%i)x(%i,%i)"
+ "    Resampling LTCs ratio=%d=%.3f"
+ "    Scalers ySc=%.3f outSc=%.3f gocSc=%.3f hithSc=%.3f hithExtraGain=%.3f gSc=%.3f,%.3f lumSh=%i"
+ "    Scalers ySc=%.3f outSc=%.3f gocSc=%.3f hithSc=%.3f,%.3f gSc=%.3f,%.3f lumSh=%i"
+ "    applied: %d  {%d - %d}\n"
+ "    ch=%zu,frame=%d,ltmFrame=%d,latency=%d,statCh=%i,LTM:lin=%i,susp=%i,val=%i,frRate=%d,csc2Hi=%u"
+ "    pnExpR=%.3f,bktCap=%d"
+ "    skip to: %d  {%d - %d}, %x %d %p\n"
+ "    start <%d, %d> maxFR:%f minFR:%f, binning <%d %d>, sifr %s\n"
+ "   %6u : [P:%d, %s] -- [T:%d, %s] -> ERROR: %s\n"
+ "   %6u : [P:%d, %s] -- [T:%d, %s] -> [S:%d, %s]\n"
+ "   %6u : [P:%d, %s] -- [T:%d] -> ERROR: WRONG EVENT\n"
+ "   0x21 : Report Event info\n"
+ "   0x22 : Start EventLogger\n"
+ "   0x23 : Stop EventLogger\n"
+ "   0x24 : Resume EventLogger\n"
+ "   0x25 : Pause EventLogger\n"
+ "   0x26 : Report all Events\n"
+ "   From RAW (norm) (x,y)=(%.3f,%.3f) (w,h)=(%.3f,%.3f) ch=%i(%i) fr=%i"
+ "   LPDP Eq {%d, %d, %d, %d}, lanes <%s>, swap %x, swing volt %d mv\n"
+ "   RAW absolute (w,h)=(%i,%i) ch=%zu(%i) fr=%i"
+ "   To RAW (norm) (x,y)=(%.3f,%.3f) (w,h)=(%.3f,%.3f) ch=%zu(%i)"
+ "   rbn=%d %d rbn_gw=%d %d gray=%d gray_gw=%d d=[%d,%d|%d,%d|%d,%d]"
+ "  %s : There no state transitions\n"
+ "  %s [%p]: Last %zu transitions [total = %zu]:\n"
+ "  - %s, %04x, %p %p %p\n"
+ "  - %s, %x, %p %p\n"
+ "  - %s, %x, %p %p %p\n"
+ "  0x10e: LCCM\n"
+ "  0x10f: MTHSTF\n"
+ "  Arch: arm64e\n"
+ "  Bufs[%d] size %zu stride %zu"
+ "  ColAE: %#08x%08x, exp %#08x%08x\n"
+ "  ColAF: %#08x%08x, exp %#08x%08x\n"
+ "  ColAWB: %#08x%08x, exp %#08x%08x\n"
+ "  Mailboxes: Total: %zd, Available = %d\n"
+ "  Mutexes: Total: %zd, Available = %d\n"
+ "  Queues: Total: %zd, Available = %d\n"
+ "  RG : %x not found!\n"
+ "  RIGEL : %x not found!\n"
+ "  Semaphore %#x [%s]\n"
+ "  Semaphores: Total: %zd, Available = %d\n"
+ "  Signals: Total: %d, Available = %d\n"
+ "  Signals: Total: %zd, Available = %d\n"
+ "  [%03d] %s+ %p - %s\n"
+ "  [%u] valid %d frm %llu ref %d ts %llu us"
+ "  add fake face[0]: %.2f,%.2f + %.2fx%.2f id=%d f=%d roll=%.0f"
+ "  apsMode = %u\n"
+ "  apsModeRequested = %u\n"
+ "  apsPos = %f\n"
+ "  ch=%d sc=%d map=%dx%d => x(%d)+w(%d),y=%d => doesn't fit /max %d,%d"
+ "  flows (%d):\n"
+ "  fr %d  [crc update] fd %x"
+ "  fr %d valid %d [crc] proj 0x%x input 0x%x fd 0x%x %.3fms"
+ "  gravity ~= ANFD (diff:%d vs %d) => keep ANFD=%d"
+ "  gravity ~= body (diff:%d vs %d) => use BODY::roll=%d"
+ "  no gravity+bad config(%u): use BODY::roll=%d"
+ "  no gravity+decent confid(%u): keep ANFD=%d"
+ "  oisMode = %u\n"
+ "  oisModeRequested = %u\n"
+ "  oisPosX = %f\n"
+ "  oisPosY = %f\n"
+ "  { contrast: (inside=%.1f >= %.1f) || (outside=%.1f >= %.1f) }"
+ "  { histo: hist[0:%d]=%.3f >=? %.2f}"
+ "  { model[%.4f + %.4f*%.2f + %.4f*%.2f]=t=%.2f => resp *=%.1f = %.3f >=? %.2f}"
+ " !!!!!!!!!Gyrohomography is  enabled"
+ " !!!!!!sensorID = %#x, ISPDgain= %d, channelID = %d"
+ " %3.2f %3.2f %3.2f %3.2f %3.2f %3.2f %3.2f %3.2f %3.2f %3.2f %3.2f %3.2f %3.2f %3.2f %3.2f %3.2f"
+ " %4.3f %4.3f %4.3f %4.3f %4.3f %4.3f %4.3f %4.3f"
+ " %d"
+ " %d %d %d %d"
+ " %d %s"
+ " %d : handle 0x%x offset 0x%lx len 0x%lx with Remap count %d\n"
+ " %d : handle 0x%x offset 0x%lx len 0x%lx with map count %d\n"
+ " %d [%#x]"
+ " %d, %d"
+ " %d, %d\n"
+ " %f"
+ " %f, %f, %f, %f"
+ " %ld, type=%d, count=%d, id=%ld, compress=%d, dataBlocks=%d"
+ " %p"
+ " %s"
+ " %s %s arrived buffer: pool=%s ch=%zu buffIdx=%zu"
+ " %s W,H = [%d, %d] DownSizeRatio:%d\n"
+ " %s: AWB buffer dropped!"
+ " %s: All requests in pending queue are done!"
+ " %s: Capture reconfigured!"
+ " %s: Created! (%p)"
+ " %s: ER NET process"
+ " %s: LSC buffer dropped!"
+ " %s: LSC buffer unavailable!"
+ " %s: Notification sent."
+ " %s: Restore old exposure setting"
+ " %s: SIB hdr %#02x len %u addr %#02x"
+ " %s: Sensor detected. Id: 0x%x"
+ " %s: Setup DMA next frame %p, stride = %zu"
+ " %s: Setup DMA next frm: %p, str: %zu\n"
+ " %s: Streaming mode switched from %d to %d."
+ " %s: Write %#02x"
+ " %s: event (%d, %s)"
+ " %s: event (%d, %s), rc = %d [%#x]"
+ " %s: event=%d [%s] cb %s"
+ " %s: restore AE"
+ " %s:master %f slave %f size %d\n"
+ " %u: apply2ReqId %llu, curFC %llu currReqId %llu rMask 0x%x req %llu "
+ " %zu: ch=%zu iBuffer=%zu iOutPipe=%zu"
+ " %zu: numKeys =%d, numMatch=%d, minPairsRequired=%d, avgSNR=%f,isReg2h=%d"
+ " (%d) Task(%s[0x%llx]%s%s) Inst(%d) ETime(%llums)\n"
+ " (%i,%i,%i,%i)->(%.3f,%.3f,%.3f,%.3f)"
+ " .apsMode           = %u\n"
+ " .estimatedOffset   = %.2f\n"
+ " .estimatedOffsetMI = %.2f\n"
+ " .m_channelState     = %u\n"
+ " .m_isFirstAfBuffer  = %u\n"
+ " .m_isInitialFocusPosSet = %u\n"
+ " .m_isRequestPending = %u\n"
+ " .m_isSensorRunning  = %u\n"
+ " .sensorSaturated   ? %d\n"
+ " <BESCoeffTable4Taps> scale=%#x, tabIdx=%d\n"
+ " AE st=%i sh=%i,AG=%.3f,snDG=%.3f,DG=%.3f,hdrR=%.3f,ev0R=%.3f,ovflw=%.3f,harDG=%.3f"
+ " Acquired %p"
+ " Acquiring %p"
+ " Active slave channel switching detected: ch=%d, lastActiveSlaveCh=%d, frame=%d"
+ " Adjust GOC clip max to %d"
+ " AfeProc0 %p AfeProc1 %p AfeProc2 %p"
+ " Allocate MLAFBuf[%d]=%p from MLAF Filter"
+ " Arm Error : %s"
+ " AuxPyrSrcChroma:base=%p,dmaFmt=%d,packType=%d"
+ " AuxPyrSrcLuma:base=%p,w=%d,h=%d,x=%d,y=%d"
+ " BWR=%d"
+ " BayerProcOut:baseAddr=%p,w=%d,h=%d,x=%d,y=%d,format=%d"
+ " Buf[%d] valid %d, id %d, type %d, sz %llu"
+ " Bypass LTC: hithOnly=%d linLTC=%d ltmBuf=%p ltcAddr=%p"
+ " Bypass LTM: flashAux=%d hithEn=%d bypassLTC=%d"
+ " CAEApple::CmdSmoothingActivationSet"
+ " CAEApple::CmdSmoothingSamplingRateSet"
+ " CAEApple::CmdTimelapseConfigSet"
+ " CAFA cas: baseAddr=%p"
+ " CAFB cas: baseAddr=%p"
+ " CAFC cas: baseAddr=%p"
+ " CAFD cas: baseAddr=%p"
+ " CAFEProcDrvH17 firstPix %u frameWidth %u frameHeight %u"
+ " CAR0 fov x=%d, y=%d width=%d, height=%d"
+ " CAR:baseAddr=%p, w=%d, h=%d, x=%d, y=%d"
+ " CAWBApple::CmdSmoothingActivationSet"
+ " CAWBApple::CmdSmoothingSamplingRateSet"
+ " CB: %i "
+ " CDSControllerH8:: ch = %zu, streamingMode=%d, bAuxSclPyrEn=%d"
+ " CFFCoeff[%d]=%d"
+ " CH = %zu, mbnrMode = %d, useCase = %d, enableChroma = %d"
+ " CIC_CMD_MULTICAM_SYNC_OFFSET_TYPE_SET %d"
+ " CImageFlowH17,ch=%ld, poolId=%d, pool=%p"
+ " CImageFlowH17::ch=%ld, mode=%d, dualStatPipe=%d"
+ " CLTM17::CmdLaccHFFImgSet"
+ " CLTM17::CmdLaccOccupied"
+ " CLTM17::CmdPropertyWrite"
+ " CLTM::CmdFilterStrengthGet"
+ " CLTM::CmdFilterStrengthSet"
+ " CLTM::CmdGammaSet"
+ " CLTM::CmdInitParamsSet"
+ " CLTM::CmdModeSet"
+ " CLTM::CmdMultiCamSyncSet"
+ " CLTM::CmdParamsReset"
+ " CLTM::CmdPropertyRead"
+ " CLTM::CmdReset"
+ " CLTM::CmdSmoothingActivationSet"
+ " CLTM::CmdSmoothingSamplingRateSet"
+ " CLTM::CmdStateSet"
+ " CLTM::CmdTuningParamGet"
+ " CLTM::CmdTuningParamSet"
+ " CLTM::CmdUpdateResume"
+ " CLTM::CmdUpdateSuspend"
+ " CMD=CIC_CMD_CAPTURE_START received"
+ " CMD=CIC_CMD_STREAMING_START, capturePrepareState=%d"
+ " CVPipe%d DmaOut: base=%p,w=%d,h=%d,outDmaFmt=%d,stride=%ld,size=%ld"
+ " Calling new CLTMDrvLTM57 ch=%zu"
+ " Calling pLTMDrv->Reset ch=%zu"
+ " Camera ROI (norm) (x,y)=(%.3f,%.3f) (w,h)=(%.3f,%.3f)"
+ " Camera ROI RAW (x,y)=(%i,%i) (w,h)=(%i,%i)"
+ " Camera ROI RAW adjusted (x,y)=(%i,%i) (w,h)=(%i,%i)"
+ " Camera ROI adjusted (norm) (x,y)=(%.3f,%.3f) (w,h)=(%.3f,%.3f)"
+ " Camera ROI in ClrProc (px) (x,y)=(%i,%i) (w,h)=(%i,%i)"
+ " Ch:%zu (%s) Sensor captureStart done @%f"
+ " Ch=%ld,fr=%d,optCenter:%ux%u,%ux%u"
+ " Ch=%u,fr=%d,optCenter:%ux%u,%ux%u"
+ " ChannelProcess 1st Hist: En=%d, bin=%d,offset=%d,size=%d"
+ " ChannelProcess 2nd Hist: En=%d, bin=%d,offset=%i,size=%d"
+ " ClrProc bHist x,y=%i,%i w,h=%i,%i"
+ " ClrProc ltmGrid (x,y)=(%i,%i) (w,h)=(%i,%i)"
+ " ClrProc sCCMGrid (x,y)=(%i,%i) (w,h)=(%i,%i)"
+ " ClrProcHist x,y=%i,%i w,h=%i,%i"
+ " ClrProcLceKnob = %d ch = %zu"
+ " ClrProcYshKnob = %d ch = %zu"
+ " Companion DMA: maxInputTileLines=%d, dataBufferSize=%ld:%ld"
+ " Complete: %s\n"
+ " Config mode set to noise model: %u\n"
+ " Config not valid. ch %zu masterCamPreview %d isQueueFrame %d ProcMode %d"
+ " CvPipe. pipe %d mms %d csc %d"
+ " DMADone vc %zu fc %d state %d\n"
+ " DPCEn=%d"
+ " Debug Frame Recovery : %s"
+ " Dest Not Ready : %s"
+ " DmaTile0: base=%#lx, size=%d"
+ " Done"
+ " Done\n"
+ " Done GDCMeshBuf: gdcMeshBufSizeInWord=%d"
+ " Done!"
+ " Enter AiCam ch %zu"
+ " Executed command function"
+ " FATE: faces supported=%u, faces available=%u"
+ " FDEnable completed"
+ " FDMapAllocated"
+ " FEPThumb=%p bBufOutFepThumbnail %u"
+ " FLASH: ltmBuffer=%p bRestoreFlashOffLTM=%d->0"
+ " FLASH: preStillCaptureLTMBuf=%p bRestoreFlashOffLTM=%d->1"
+ " FOUND: Consistent motion, Gyro based Registration, DONE!"
+ " FOUND: Small motion, Gyro based Reggistration, DONE!"
+ " FOVScale=%0.3f %0.3f dst (norm) (x,y)=(%.3f,%.3f) (w,h)=(%.3f,%.3f) ch=%hhu fr=%i"
+ " FPNR PyrOutProc1 Width:%d, Height:%d needs to be power of 2"
+ " FPNR: Dynamic rFPN array size %d is larger than hardware limit (64)"
+ " FPNR: baseAddr=%p"
+ " FPNR: rFPN size mismatch: rFPN array size %d, width %f, height %f"
+ " Face map for FATE"
+ " Face map for tone"
+ " Fails:  %4d\n"
+ " FailureSet=%#x"
+ " Focus has changed in previous or current frame"
+ " From RAW (norm) (x,y)=(%.3f,%.3f) (w,h)=(%.3f,%.3f) ch=%hhu fr=%i"
+ " From RAW (px) (x,y)=(%i,%i) (w,h)=(%i,%i) ch=%i(%i) fr=%i still=%i"
+ " From RAW (x,y)=(%d,%d) (w,h)=(%d,%d) ch=%hhu fr=%i"
+ " GDC: [ocX,ocY,mm2px,px2mm] [%f,%f,%f,%f]"
+ " GDC: [width,height,ocXShift,ocYShift] [%.0f,%.0f,%f,%f]"
+ " GDC: apsPFL %f, gdcRadMax %f, radscale %d, radShift %.2f"
+ " GDC: gdcRadMax %f, radScale %d"
+ " GDC: gdcRadiusInd %d maxValidInd %d"
+ " GDC: gdcscale: %u, gdcscaleInv: %u"
+ " GDC: maxValidInd %d radDistPx[%d] %f"
+ " GDC: maxValidRad %f, Extrapolated GDC out to index %u"
+ " GDC: ocx %f/%d ocy %f/%d px %u py %u radscale %u"
+ " GDC: radDistMM[%d] %f radDistPx[%d] %f"
+ " GDC: radius %f, radiusInd: %d"
+ " GDC: reduce maxValidInd! gdcRadiusInd %d, maxValidInd %d"
+ " GDCTable:frame=%d,ch=%ld,BesInRect:%d %d %d %d,BesOut:w=%d,h=%d,Raw:w=%d,h=%d,sensorBin:%d %d"
+ " GDCTable:frame=%d,ch=%ld,rawIn:%dx%d,BesInFOV:x=%d,y=%d,w=%d,h=%d,bStill=%d,scl=%.2f,d=%f"
+ " GOC1GainsSet goc1Gains=(%d %d %d)"
+ " GOC2GainsSet goc2Gains=(%d %d %d)"
+ " GTB Timeout : %s"
+ " GetBESCoeffs scale=%#x (%f), tabIdx=%d\n"
+ " GetFSCLCoeffs scale=%#x (%f), tabIdx=%d\n"
+ " GetFSCLCoeffs7Taps scale=%#x (%f), tabIdx=%d\n"
+ " GetMsBePYRCoeffs scale=%#x (%f), tabIdx=%d\n"
+ " GetRTBWRbyDMA[%d]: bRTDma %d, ch=%d, r=%x w=%d\n"
+ " GlobalHist2 dimensions: w=%u, h=%u"
+ " GocClipMax: prev=%d(%d,%d) curr=%d"
+ " Gyro-OIS OIS missing!"
+ " Gyro-OIS SUCESSEDED!"
+ " HALT ALL CORES:"
+ " HFF face map after filtering (downsampled 2x)"
+ " HFF face map before filtering (downsampled 2x)"
+ " HITH HiRes Thumb: baseAddr=%#lx"
+ " HITH LTM Grid RAW (x,y)=(%i,%i) (w,h)=(%i,%i) rel=(%.3f,%.3f)"
+ " HITH LTM Grid in ClrProc (x,y)=(%i,%i) (w,h)=(%i,%i)"
+ " HITH stat ROI in ClrProc (x,y)=(%i,%i) (w,h)=(%i,%i)"
+ " HITH thumb blocks (%i %i) -> (%i %i) -> (%i %i), Scale = %i\n"
+ " HITH thumbnail scale factor = %i within ltmRect (w, h) = (%i, %i)"
+ " HITHStatProc:ch=%ld, frame=%d, passId=%d, mpMode=%d, msMode=%d"
+ " HPPGridConfig: bGlobLUTEn=%d, CPGOC1Bypass=%d, CPGammaBypass=%d,RPInvGammaEn=%d, is10b: %d"
+ " HPPGridConfig: goc1GainR=%d"
+ " HPPGridConfig: ltcResampleRatio=%i, goc1Gain=%#x, isLTMenabled=%d"
+ " HPPGridConfig:ch=%ld, frame=%d, GridSizeX=%d, GridSizeY=%d, ltmGridBuf=%p"
+ " High resolution HITH thumbail available, use large buffer for thumbnail stat data"
+ " HithLhist: baseAddr=%#lx,size=%d"
+ " HithThumb: baseAddr=%#lx"
+ " Homography row %d: %9.3f %9.3f %9.3f"
+ " IC: CIC_OUTPUT_LSC error\n"
+ " IR buffer release"
+ " IR buffer size=%ld"
+ " ISP_PROPERTY_ALGOCONTROL_TILE_GDC_ENABLE:%d"
+ " ISP_PROPERTY_ALGOCONTROL_YUV_REPLAY_ENABLE:en=%d,ch=%ld"
+ " ISP_PROPERTY_IR_POWER_SAVE_MODE_SET ch=%ld, bitmap=%u\n"
+ " ISP_PROPERTY_VIDEOFLOW_DUMP_PYRAMID_BUF dumping frame=%d, %d frame(s) left"
+ " InCrop[AuxScl]:w=%d,h=%d,out:w=%d,h=%d"
+ " InCrop[BesScl]:w=%d,h=%d,out:w=%d,h=%d"
+ " InCrop[ClrBe]:w=%d,h=%d,out:w=%d,h=%d"
+ " Input AE luxLevelSat = %.3f, adjusted luxLevelSat = %.3f"
+ " It is replaced by frame %u AWB: r %u, gr %u, b %u, gb %u"
+ " It's reprocess, outputBuf=%p"
+ " LACC CIspLACCResource initialization starting..."
+ " LACC resource Release done !!!"
+ " LACC resource initialization done !!!"
+ " LTMLinFiltCoeffSet linFiltCoeff=(%d %d %d)"
+ " LTMSetup restore prebracket LTM=%p\n"
+ " LTMSetup save prebracket LTM=%p\n"
+ " Luma scale=%.3f, scaleToEV0=%.3f"
+ " M/S switching detected: ch=%d, lastMasterCh=%d, frame=%d"
+ " M2M GDC input memory allocated %zu x %zu"
+ " MAMABEAR\n"
+ " MAMABEAR %d\n"
+ " MCTF ActionCam mode, enableThreshold = %d, disableThreshold = %d, ch = %zu"
+ " MLVNR with TP PYROUTPROC need force to use YCC Fusion Type"
+ " MTHOutputProc:ch=%ld, frame=%d, passId=%d, mpMode=%d, msMode=%d"
+ " MeshGrid bufferSize=%ld"
+ " MeshIn:baseAddr=%p,size=%d"
+ " MlnrProcKernelType = %u ch = %zu"
+ " MlnrProcMlnrFiltSize = %u ch = %zu"
+ " MlnrProcMlnrKnobMbnr = %d ch = %zu"
+ " MlnrProcMsMlnrFiltSize = %u ch = %zu"
+ " MlnrProcMsMlnrKnobChroma0 = %d ch = %zu"
+ " MlnrProcMsMlnrKnobChroma1 = %d ch = %zu"
+ " MlnrProcMsMlnrKnobChroma2 = %d ch = %zu"
+ " MlnrProcMsMlnrKnobChroma3 = %d ch = %zu"
+ " MlnrProcMsMlnrKnobChroma4 = %d ch = %zu"
+ " MlnrProcMsMlnrKnobLuma0 = %d ch = %zu"
+ " MlnrProcMsMlnrKnobLuma1 = %d ch = %zu"
+ " MlnrProcMsMlnrKnobLuma2 = %d ch = %zu"
+ " MlnrProcMsMlnrKnobLuma3 = %d ch = %zu"
+ " MlnrProcMsMlnrKnobLuma4 = %d ch = %zu"
+ " MsBeOut:baseAddr=%p,x=%d,y=%d,w=%d,h=%d,size=%ld,format=%d"
+ " MsBeProcFuseKnob = %d ch = %zu"
+ " Mth Semantic Map: baseAddr%p"
+ " MthOutput: baseAddr=%#lx numberOfScene %u"
+ " N-SHOT UPDATE: nShotUpdateCounter=%d"
+ " No active channel."
+ " No body+bad confidence(%u) => use gravity=%d"
+ " No body, no gravity => keep ANFD=%d"
+ " No pendng step and it's time to run processrawgo"
+ " Normgain: r %u, gr %u, b %u, gb %u. maxWBGainDown %u"
+ " Normgains: r %u, gr %u, b %u, gb %u."
+ " Normgains: r %u, gr %u, b %u, gb %u. maxWBGainDown %u"
+ " Not enabling AFEProc Dma ch=%ld,frame=%d,afeProcPipe=%d enable %u %u %u"
+ " Not ready to prepare!"
+ " Not ready yet!frame=%d,ch=%ld,mpMode=%d,msMode=%d,still=%d,pMS=%d,sMS=%d,syncTag=%d,S=%d,P=%d"
+ " OK"
+ " OL : apsPFL=%f mm, thickPFLOL=%f mm, upperBoundPFL=%f mm\n"
+ " OL : apsPosition=%f mm, apsModelLinearM=%f, apsModelLinearB=%f\n"
+ " OL : thickLensEFL=%f mm, apsModelLinearM=%f\n"
+ " Offset:%d,%d,%d,%d"
+ " OffsetIn[%d]=%d, pClrProcCSCOffset[%d]=%d, pWMixCSCOffset[%d]=%d\n"
+ " PDE buffer size=%ld"
+ " PDE max width=%d height=%d"
+ " PYRChromaB:base=%p,w=%d,h=%d,stride=%ld,size=%ld,%d"
+ " PYRChromaC:base=%p,w=%d,h=%d,stride=%ld,size=%ld,%d"
+ " PYRChromaD:base=%p,w=%d,h=%d,stride=%ld,size=%ld,%d"
+ " PYRChromaE:base=%p,w=%d,h=%d,stride=%ld,size=%ld,%d"
+ " PYRChromaF:base=%p,w=%d,h=%d,stride=%ld,size=%ld,%d"
+ " PYRLumaA:base=%p,w=%d,h=%d,stride=%ld,size=%ld,%d"
+ " PYRLumaB:base=%p,w=%d,h=%d,stride=%ld,size=%ld,%d"
+ " PYRLumaC:base=%p,w=%d,h=%d,stride=%ld,size=%ld,%d"
+ " PYRLumaD:base=%p,w=%d,h=%d,stride=%ld,size=%ld,%d"
+ " PYRLumaE:base=%p,w=%d,h=%d,stride=%ld,size=%ld,%d"
+ " PYRLumaF:base=%p,w=%d,h=%d,stride=%ld,size=%ld,%d"
+ " Passes: %4d\n"
+ " Positive offsets (x,y)=(%i,%i) (w,h)=(%i,%i)"
+ " Preview AWB frame %u gains: r %u, gr %u, b %u, gb %u"
+ " Preview FSCL:ch=%ld,inW=%d,inH=%d,x=%d,y=%d,outW=%d,outH=%d"
+ " Preview Master switch from %d to %d\n"
+ " ProRes en %d ch = %zu"
+ " ProcessPerFrameRequest begin"
+ " ProcessPerFrameRequest end"
+ " QUARK - %x, led type %d\n"
+ " Quadra=%i snsRect=(%i,%i,%i,%i) binGain=%.3f nxBinGain=%.3f"
+ " RAW absolute (w,h)=(%i,%i) ch=%hhu fr=%i"
+ " RG - %x, led type %d\n"
+ " RG - B0 %d B1 %d S0 %d S1 %d pw %d\n\n"
+ " RG- ProjectorModeControl: %x, current %d\n"
+ " RGBHistProc:ch=%ld, frame=%d, passId=%d, mpMode=%d"
+ " RGBpixScale=%.3f, ylinScale=%.3f"
+ " RIGEL\n"
+ " RIGEL - %x, led type %d\n"
+ " RIGEL - A0 %d B0 %d B1 %d S0 %d S1 %d pw %d\n\n"
+ " RIGEL- ProjectorModeControl: %x, current %d\n"
+ " RNFSetup ch=%ld, frame=%d, rnfKnobLevel=%d, totGain=%.3f, totGainDown=%.3f"
+ " RSCLOut:baseAddr=%p,w=%d,h=%d,stride=%ld,format=%d"
+ " RSCLPreScaleOut:baseAddr=%p,w=%d,h=%d,format=%d"
+ " Re-send HITHStat to LTM ch=%zu frame=%d pStatBuff=%p"
+ " Re-send LTM buffer ch=%zu hithCh=%d ltmFrame=%d pLTMOut=%p"
+ " Re-send to AlgoServer ch=%zu frame=%d"
+ " Received enable=%d numSyncGroups=%d"
+ " Receiving MTHOutput ch=%zu frame=%d mthOutputBuf=%p pProcessedFrame=%p pFlowExtra %p"
+ " Reflow AWB frame %u bGenerateReflowAWB %u  bUsingSingleStillAWB %u."
+ " Reflow AWB frame %u: r %u, gr %u, b %u, gb %u."
+ " Reflow: Using previous single frame: %u awb for current frame %u with single pass\n"
+ " Reflow: cached AWB is not ready. Cached awb frame %u, current frame %u \n"
+ " Reflow: pChInfo->awbData.frameCount %u, current frameCount %u"
+ " Regulus\n"
+ " Released %p"
+ " RestartCTF (Still) for ch=%ld, frame=%d"
+ " RestartCTF for ch=%ld, frame=%d"
+ " Restore AE"
+ " RsmOut:W=%d,H=%d"
+ " SIF%d BusySrc=%d busySrcFE 0x%x 0x%x srcBE:0x%lx 0x%lx"
+ " SIFR cur sh=%i,AG=%.3f fwd sh=%i,AG=%.3f vHDR=%d"
+ " STF WeightMap: baseAddr%p"
+ " SUSPENDED or BENCHMARK: save to suspendedFrame"
+ " SUSPENDED: nShotUpdateCounter=%d"
+ " Save buffer ch=%zu tag=%x channelsInSync=%d sifr=%d frame=%d masterCh %d"
+ " Saving %s, size=%ld"
+ " Saving PDE buffer ch=%u, stride=%zu"
+ " Saving buffer %s successfully"
+ " Saving buffer %s, size=%u, stride=%zu"
+ " Saving buffer %s, size=%zu, stride=%zu"
+ " Scalers ySc=%.3f outSc=%.3f gocSc=%.3f hithSc=%.3f,%.3f gSc=%.3f,%.3f"
+ " Send HITHStat ch=%zu frame=%d syncTag=%d pStatBuff=%p isPrvMs=%d prvMsCh=%d"
+ " Send LTM buffer ch=%zu hithCh=%d ltmFrame=%d pLTMOut=%p"
+ " Send ch=%zu frame=%d metaBuf=%p mthOutputBuf=%p"
+ " Sensor reg RAW (x,y)=(%i,%i) (w,h)=(%i,%i)"
+ " Sensor reg in ClrProc (x,y)=(%i,%i) (w,h)=(%i,%i)"
+ " Sensor reg in ClrProcBE x,y=%i,%i, w,h=%i,%i"
+ " Sensor reg in ClrProcFE x,y=%i,%i, w,h=%i,%i"
+ " Sensor reg x,y=%i,%i, w,h=%i,%i"
+ " Set CVPipe1 output 512x384, ch = %zu"
+ " Set DPE_CAT_VSOC @%#lx=%#x"
+ " Set SISP_DPE_CAT_CPU_VSOC @%#lx=%#x"
+ " Setup CTI trigger"
+ " StartCTF (Still) for ch=%ld, frame=%d"
+ " StartCTF for ch=%ld, frame=%d"
+ " Stat0lsc: baseAddr=%p, Stride=%d"
+ " Stats Master switch from %d to %d\n"
+ " Stats0 %p Stats1 %p"
+ " Still FSCL: crop [%d %d %d %d],outW=%d,outH=%d"
+ " Still FSCL:inW=%d, inH=%d,outW=%d,outH=%d"
+ " StopCTF (Still) for ch=%ld, frame=%d, bRelBuf=%d"
+ " StopCTF for ch=%ld, frame=%d, bRelBuf=%d"
+ " StrModDisableThreshold = %d ch = %zu"
+ " StrModEnableThreshold = %d ch = %zu"
+ " Stride%u, srcWidth%u, srcHeight%u, OFFSETX%u, Y%u, s%u "
+ " SyncOutputEn=%d"
+ " Thumb scale = %i, rescale to 34x26"
+ " Thumb: Area=%ld, size=%d"
+ " Time Elapsed (ms): %d\n"
+ " Timelapse capture, enable TF Still"
+ " To ClrProc XY=(%i,%i) WH=(%i,%i) DmaSrc XY=(%i,%i) WH=(%i,%i) ch=%zu(%i)"
+ " To ClrProc XY=(%i,%i) WH=(%i,%i) ch=%zu(%i)"
+ " To FES clipped(%i,%i,%i,%i) unclipped(%i,%i,%i,%i) ch=%zu(%i) fr=%i"
+ " To RAW (px) (x,y)=(%i,%i) (w,h)=(%i,%i) ch=%hhu"
+ " To RAW (px) (x,y)=(%i,%i) (w,h)=(%i,%i) ch=%zu(%i)"
+ " To negative offsets (x,y)=(%i,%i) (w,h)=(%i,%i) ch=%zu(%i) fr=%i"
+ " To release %p"
+ " Transformation=[ \n %f, %f, %f \n %f, %f, %f \n %f, %f, 1.0 \n ] \n"
+ " TuningParamsUpdate, hrGainDownRatio = %d, HROn = %d, totGainDown = %d, gainToCeiling = %d, stdScaleAdj: %.3f, knobScaleZoom: %.3f"
+ " Type[%d] max %llu"
+ " Unsupported RAW BPP %u packed %u"
+ " VisP. pipe %d  mms %d"
+ " VisPipe0Dst:W=%d,H=%d,base=%p,packed=%d"
+ " VisPipe:preScaleFactor:%d %d, preScaleOut:%dx%d, crop:%d %d %dx%d"
+ " WBG:%#x,%#x,%#x,%#x"
+ " YUV Replay ch=%d,frame=%d[%#zx],dataSrc=%d,outSel=%#x,p=%d,s=%d,mp=%d,ms=%d,dst=%#x,cfg=%d,tGDC=%d"
+ " [%d] [m] [-] [-]: Set endstop calibration method\n"
+ " [%d] [x] [-] [-]: Set APE maximum retention time (x sec)\n"
+ " [%d] [y] [-] [-]: Set APE drop detection threshold (y in Q16; g)\n"
+ " [%d] ch=%ld,frame=%d,p=%d,s=%d,mpMode=%d,msMode=%d,ispConfig=%d"
+ " [%d] ch=%ld,nextSeq=%d,pendingJobs=%d(%d),outStrms=%d"
+ " [%d]: baseInverseCoef=%f,baseOrder=%d, dynInverseCoef=%f, dynOrder=%d"
+ " [%d]ch=%ld, Size=%ld"
+ " [800] [t] [d] [m]: special functions for internal trace & validation\n"
+ " [DSI] %s cascading self destruction"
+ " [DSI] Released flows from ch=%zu"
+ " [DSI] ST %u %s_efl/%s_ps - %s_efl/%s_ps = %f"
+ " [DSI] WMAT BSP 0x%08lx (%d %d) tile = %d"
+ " [DSI] Wanted to run GMC, but GMC is already running!"
+ " [DSI] ch=%zu partialGdcScale=%f distorted=%u"
+ " [DSI] isReplay=%u bReplayEnableGMSLoop=%u"
+ " [SM3][%s][Line: %d] UInt64 0x%llx [TS: %u ms]\n"
+ " [SM3][%s][Line: %d]Float %f, %f [TS: %u ms]\n"
+ " [SM3][%s][Line: %d]UInt16 0x%x, 0x%x, 0x%x, 0x%x [TS: %u ms]\n"
+ " [SM3][%s][Line: %d]UInt32 0x%x, 0x%x [TS: %u ms]\n"
+ " allocate vHDR still ch=%ld,w=%ld,h=%ld,bScale0En=%d,maxBufCnt=%ld"
+ " apsPixPFL=%d,PFLScale=%d,PPffset:%d %d"
+ " bCaptureNow=%d,currFrameCount=%d,ch=%d"
+ " bCaptureNow=%d,frame=%d,ch=%d"
+ " bEnLTC=%i, bEnLUT=%i, bEnSCCM=%i"
+ " bGenerateReflowAWB %u, bUsingAWBSingle %u\n"
+ " bLTCFlexGridEnable = %u ch = %zu"
+ " bLVTEnable = %u ch = %zu"
+ " bMLAFEn=%d bMLAFOutputEn=%d bMLAF1stFrameSet=%d ch=%zu"
+ " bMLNRCAFEn = %u ch = %zu"
+ " bMLNRConfInterpEn = %u ch = %zu"
+ " bMLNRConfInterpType = %u ch = %zu"
+ " bMLNRInterpEn = %u ch = %zu"
+ " bMLNRInterpType = %u ch = %zu"
+ " bMLNRTuningEn = %u ch = %zu"
+ " bMSTFScale0StrModCtrl = %d ch = %zu"
+ " bMTHEnable = %u ch = %zu"
+ " bMsMLNRCAFEn = %u ch = %zu"
+ " bSTFEnable = %u ch = %zu"
+ " bank %d dstBank %d"
+ " bankBitMast=%#x"
+ " bankId=%d"
+ " bankId=%d, tunableMode=%d, bank_base_addr=%#zx, tunable_entry_cnt=%d"
+ " bank_base_addr=%#lx, tunable_entry_cnt=%d"
+ " bayerProcDmaEn:%#x,%#x"
+ " body~=face + bad confid(%u) + no gravity => keep ANFD=%d"
+ " body~=face + bad confidence(%u) => use gravity=%d"
+ " bound %.3f-%.3f modSc=%.3f sc=%.0f max=%.2f blend=%.2f"
+ " bufIninWidth %u bufWidth %u stride %zu flowid %u"
+ " buffEit=%f currEit=%f ratio=%f"
+ " buffers=%d, imgW=%ld, imgH=%ld, bufferSize=%ld"
+ " buffers=%d,width=%ld,height=%ld,size=%ld,mallocSize=%ld"
+ " ch %d FD enabled with option 0x%x"
+ " ch %d fdOption 0x%x AHFDEnabled %d useAHFD %d fdCnt %d"
+ " ch %zu NONSYNC stillBufferCount %zu GetNumberOfChannelsInSync(ch) %d"
+ " ch %zu SYNC stillBufferCount %zu GetNumberOfChannelsInSync(ch) %d"
+ " ch %zu ertype %d"
+ " ch %zu masterCamPreview %d QueueFrame %d ProcMode %d qSize %zu"
+ " ch %zu stillBufferCount %zu GetNumberOfChannelsInSync(ch) %d"
+ " ch %zu syncOffsetType %d"
+ " ch = %ld,  VHDR update %d -> %d"
+ " ch%ld,frame%d,fCap%d,RER%d,bCap%d,preB%d,bCapNow%d,f.bMCam%d,ae.bMCam%d,preMS%d"
+ " ch:%zu, FPNR is Bypassed"
+ " ch:%zu, isFPNREnable:%d"
+ " ch:%zu, isFPNRTileEnable:%d"
+ " ch=%d frame=%d isPrvMs=%d ltm=%d ltc=%d gtc=%d goc1=%d goc2=%d linF=%d clut=%d sCCM=%d gCCM=%d rEV0=%d"
+ " ch=%d hDistMulti=%p available=%i"
+ " ch=%d isSync=%d chMask=0x%X t2w=%.3f sw2w=%.3f minRoiSize=%.3f maxRoiOffset=%.3f"
+ " ch=%d mpPrep=%d mpMode=%d passId=%d ltmBuf=%p"
+ " ch=%d msLtmBuffer=%p"
+ " ch=%d pLtmBufOld=%p pltmBufNew=%p notLtmBuffer=%d bSetupLTM=%d"
+ " ch=%d replaceLTMBuf=%d bufRef=%p"
+ " ch=%d settingBuf=%p"
+ " ch=%d stillImageCaptureNow=%d stillCap=%d ltmBuffer=%p"
+ " ch=%d(%i) frame=%d syncTag=%d isPrvMs=%d prvMsCh=%d pendingPrvMsCh=%zu inSync=%d"
+ " ch=%d, clrProcDmaEn:%#x,%#x"
+ " ch=%d, previewFrameRate=%#x, standardFrameRate=%f"
+ " ch=%d, srcPipe=%d, dataSource=%d,inSrc:W=%d,H=%d,X=%d,Y=%d"
+ " ch=%d,afeProcPipe=%d,%d,%d,afeProcDmaEn=%#x, dataSrc=%d"
+ " ch=%d,frame=%d,MsProcDmaEn=%#x"
+ " ch=%d,frame=%d,bMSTFEn=%d,bMSTFInit=%d,delayCnt=%d"
+ " ch=%d,frame=%d[%#zx],dataSrc=%d,outSel=%#x,tGDC=%d"
+ " ch=%d,frame=%d[%#zx],seq=%d,p=%d,s=%d,mp=%d,ms=%d,dst=%#x,cfg=%d"
+ " ch=%d,isReady=%d"
+ " ch=%d,job=%#zx,pyramidIn:w=%d,h=%d,msMode=%d,packType=%d,dmaFmt=%d"
+ " ch=%d,seq=%d,PDE UV:%p, size=%ld"
+ " ch=%d,seq=%d,p=%d,s=%d,configId=%d"
+ " ch=%d,seq=%d,pendingFrmCount=%d,%d"
+ " ch=%d,statsPipe=%d,%d,statsDmaEn=%#x, dataSrc=%d, in:W=%d,H=%d,X=%d,Y=%d"
+ " ch=%d,statsPipe=%d,%d,statsDmaEn=%#x, dataSrc=%d, in:W=%d,H=%d,X=%d,Y=%d sifrStats:%d"
+ " ch=%i fc=%i expRat=%.3f hardGain=%.3f hithscl=%.3f"
+ " ch=%i fc=%i inputEIT=%.3f fwdEitR=%.3f gDn=%.3f binGain=%.3f darkEIT=%.3f"
+ " ch=%i fc=%i nxBinGain=%.3f"
+ " ch=%i fr=%i fwdRatio=%.3f totalEIT=%.3f\n"
+ " ch=%i->%zu quadra=%i->%i m2sFOVscl=%.3f %.3f fr=%i->%i"
+ " ch=%ld"
+ " ch=%ld Recv LTMbuf=%p ltmFrame=%d valid=%d"
+ " ch=%ld clrBeTileBm=%#lx bufCnt=%d"
+ " ch=%ld cropPDE: %d %d %dx%d mappedCrop: %d %d %dx%d"
+ " ch=%ld cropPDE: %d %d %dx%d mappedCrop: %d %d %dx%d,BESIn:%dx%d"
+ " ch=%ld cropPDE: %d %d %dx%d mappedCrop: %d %d %dx%d,BESIn:%dx%d outPDE: %dx%d"
+ " ch=%ld cropPDE[%d %d %d %d]->[%d %d %d %d] pde[%d %d]"
+ " ch=%ld en:%u W:%u H:%u X:%u Y:%u S%u"
+ " ch=%ld frame=%d,M3Buf updated:warpM3BufSizeInWord=%d, Overlap=%d"
+ " ch=%ld m2mTileBm=%#lx bufCnt=%d"
+ " ch=%ld strmEn(%d %d %d),previewMaster=%d,scalerCroppe[%d %d] pde[%d %d]"
+ " ch=%ld strmEn(%d %d %d),previewMaster=%d,scalerCroppedRect[%d %d] pde[%d %d]"
+ " ch=%ld strmEn(%d %d %d),previewMaster=%d,scaler[%d %d]out[%d %d] pde[%d %d]"
+ " ch=%ld toDomain=%d cropBeforeRound: %.4f %.4f %.4fx%.4f"
+ " ch=%ld, ANSTThumbnailEn=%d"
+ " ch=%ld, AuxPyrUVBufSize=%ld, AuxPyrUVBufCnt=%d"
+ " ch=%ld, AuxPyrUVLevel=%d, W=%ld, H=%ld, Size=%ld"
+ " ch=%ld, AuxPyrYBufSize=%ld, AuxPyrYBufCnt=%d"
+ " ch=%ld, AuxPyrYLevel=%d, W=%ld, H=%ld, Size=%ld"
+ " ch=%ld, CPPMode=%d\n"
+ " ch=%ld, CTFPixFmt=%d,%d"
+ " ch=%ld, GDC Strenghth=%.2f, %.2f"
+ " ch=%ld, GDREnable=%d"
+ " ch=%ld, MLAF ROI is not ready, send 1 patch only, rowIndex=%d, regionIndex=%d, dump=%d"
+ " ch=%ld, MLAF patchCountX=%d, patchCountY=%d, rowIndex=%d, regionIndex=%d, dump=%d"
+ " ch=%ld, No HW Reg source"
+ " ch=%ld, PDEEnable=%d,%d"
+ " ch=%ld, RBGRegistered=%d"
+ " ch=%ld, SetMLAF1stFrame=%d"
+ " ch=%ld, SetMLVNR1stFrame=%d"
+ " ch=%ld, TimeLapseStillTFFeature=%d\n"
+ " ch=%ld, VHDR Enable = %d"
+ " ch=%ld, Virtual Output Crop disabled, will use normal Output Crop Set!"
+ " ch=%ld, W=%ld, H=%ld, AuxPryScale0BufSize=%ld, AuxPryScale0BufCnt=%d"
+ " ch=%ld, W=%ld, H=%ld, Size=%ld, mallocSize=%ld, BufCnt=%d"
+ " ch=%ld, YUV-FOV:%d %d %dx%d,raw-FOV:%d %d %dx%d"
+ " ch=%ld, afeProcId=%ld"
+ " ch=%ld, bCTFCircularEn=%d\n"
+ " ch=%ld, bCTFCircularEnStill=%d\n"
+ " ch=%ld, bMSTFScale0En=%d\n"
+ " ch=%ld, bMSTFScale0EnStill=%d\n"
+ " ch=%ld, bMSTFScale0LightingCtrl=%d\n"
+ " ch=%ld, bMsBePYRScalerSupported=%d\n"
+ " ch=%ld, bRegistraionPrioritized=%d\n"
+ " ch=%ld, bSMVAWBEn=%d\n"
+ " ch=%ld, bSMVEn=%d\n"
+ " ch=%ld, bUseSecondaryStatAF=%d, bSBSEnabled=%d, bFHSEnabled=%d"
+ " ch=%ld, buffers=%ld, pin=%ld"
+ " ch=%ld, buffers=%ld, pin=%ld, state=%s"
+ " ch=%ld, component=%d, en=%d"
+ " ch=%ld, depth=%ld"
+ " ch=%ld, en=%d"
+ " ch=%ld, en=%d,%d"
+ " ch=%ld, enPrev=%d enStill=%d"
+ " ch=%ld, format=%d, bCmp=%d"
+ " ch=%ld, fpnrRBCCalDataPtr[%d]=%p, fpnrRBCCalDataAddr[%d]=%p"
+ " ch=%ld, frame=%d"
+ " ch=%ld, frame=%d, bCurrSMVEn=%d, LCECAS segMapframeCount=%d"
+ " ch=%ld, frame=%d, bCurrSMVEn=%d, YSHCAS segMapframeCount=%d"
+ " ch=%ld, frame=%d, binW/H=%d %d. previewFOVInRaw:%d %d %dx%d"
+ " ch=%ld, frame=%d, bracketingMode=%d, EV=%d,"
+ " ch=%ld, frame=%d, lceEn=%d"
+ " ch=%ld, frame=%d, masterCh=%ld, previewMasterFOVInRaw:%d %d %dx%d"
+ " ch=%ld, frame=%d, outType=%d, BES in (%d, %d), (%d, %d), out (%d, %d)"
+ " ch=%ld, frame=%d, s=%d, msMode=%d, bGenHuemap=%d"
+ " ch=%ld, frame=%d, still=%d, GDCEnabled=%d, GDCStrength=%f"
+ " ch=%ld, frame=%d, yshEn=%d"
+ " ch=%ld, frame=%d,ch=%ld,useCase=%d"
+ " ch=%ld, frame=%d,p=%d,s=%d,mpMode=%d,msMode=%d"
+ " ch=%ld, fusionType=%d\n"
+ " ch=%ld, fusionTypeStill=%d\n"
+ " ch=%ld, imgW=%d, imgH=%d, Size(scale0)=%ld"
+ " ch=%ld, imgW=%d, imgH=%d, Size(scale1)=%ld"
+ " ch=%ld, imgW=%d, imgH=%d, Size(scale1)=%ld,%ld,%ld"
+ " ch=%ld, imgW=%d, imgH=%d, Size(scale2To5)=%ld"
+ " ch=%ld, imgW=%ld, imgH=%ld, ClrBeTile bufferSize=%ld"
+ " ch=%ld, m2mGdcBufferWidth=%d, m2mGdcBufferHeight=%d\n"
+ " ch=%ld, maxFrameRateAllowed=%d\n"
+ " ch=%ld, mode=%d"
+ " ch=%ld, mpAllIncomingList->Size()=%ld"
+ " ch=%ld, numOfStrms=%d, outStrmSelect=%d"
+ " ch=%ld, outStrmSelect=%d (%#x), en=%d, passId=%d, bOutput2Sink=%d"
+ " ch=%ld, p=%d,s=%d: new ispConfigId=%d, old ispConfigId=%d"
+ " ch=%ld, peopleEn=%d, hairEn=%d, skinEn=%d, skyEn=%d"
+ " ch=%ld, put ispJob=%#zx to Q"
+ " ch=%ld, rBWR=%d, wBWR=%d"
+ " ch=%ld, splitPDModeOverride=%d\n"
+ " ch=%ld, statsId=%ld"
+ " ch=%ld, strip[0]::inRect:%d,%d,%dx%d,(%d),outRect:%d,%d,%dx%d,(%d),outOffset:%d,%d"
+ " ch=%ld, strip[1]::inRect:%d,%d,%dx%d,outRect:%d,%d,%dx%d,outOffset:%d,%d"
+ " ch=%ld, w=%ld, h=%ld, format=%d"
+ " ch=%ld, x=(%d,%d), y=(%d,%d), w=(%d,%d), h=(%d,%d), dataSrc=%d, srcPipe=%d"
+ " ch=%ld,BESType=%d,outFmt=%d,w=%d,h=%d,refW=%d,refH=%d,paddingRows=%d,cmp=%d"
+ " ch=%ld,PDE:bUseVis=%d,bUseBes=%d,scl=%d,VisInput %dx%d PDEenable %d flowType %d"
+ " ch=%ld,bStillCap=%d,bMSTFEn=%d, bMSTFEnStill=%d, IsOnTripod()=%d"
+ " ch=%ld,band=%d,strength(%d,%d), useCase=%d"
+ " ch=%ld,besCrop:%d %d %dx%d, visCrop:%d %d %dx%d"
+ " ch=%ld,enable=%d,enableChroma=%d,numberOfLevels=%d,dmaFmt=%d,packType=%d"
+ " ch=%ld,enable=%d,rtDmaId=%d,bwr=%d"
+ " ch=%ld,fc=%i,HLG=%i,log=%i,still=%i,HDRCen=%i\n"
+ " ch=%ld,fr=%d,SBSEn=%d,bSBMHPPUpdated=%d,LTMGridBufValid=%d,mbnrMode=%d,MsMBNREn=%d,offLoad=%d"
+ " ch=%ld,frame=%d pass=%d,step=%d,latency=%d,syncTag=%d,MsMBNR=%d,Wait=%d"
+ " ch=%ld,frame=%d,%d,prevMS=%d,inFrameDelta=%d (us) HR=%d, vHDR=%d"
+ " ch=%ld,frame=%d,HITHEn=%d,bNewLtmBuf=%d,strobStatus=%d,FS=%d,replace=%d,aux=%d"
+ " ch=%ld,frame=%d,LTC=%i,hithEn=%i,hithOnly=%i,linLTC=%i,sCCM=%i,ms=%i,prevMs=%i,still=%i"
+ " ch=%ld,frame=%d,TCFrame=%d,braketingCap=%d,Mode=%d,bUseBCapSqrtTone=%d"
+ " ch=%ld,frame=%d,afeProcPipe=%d"
+ " ch=%ld,frame=%d,apsPixPFL=%f,PFLScale=%f,PPffset:%f %f"
+ " ch=%ld,frame=%d,awbFrame=%d awbGains=%d %d"
+ " ch=%ld,frame=%d,bDoVis=%d,GDCEn=%d,cpuMode=%d,updateMesh=%d,bDoGDC=%d"
+ " ch=%ld,frame=%d,gravity:%f,%f,%f cxyCM[2]:%f,%f"
+ " ch=%ld,frame=%d,inRaw:%dx%d,downSample:%dx%d,GridSize:%dx%d,fepThumbBuf=%p"
+ " ch=%ld,frame=%d,inRawSize:%dx%d,hrDMASrcSize:%dx%d"
+ " ch=%ld,frame=%d,inRawSize:%dx%d,hrDMASrcSize:%dx%d,bStillCap=%d"
+ " ch=%ld,frame=%d,ispConfig=%d,p=%d,s=%d,msMbnr=%d,sifrStatFrame:%d wait:%d to flow"
+ " ch=%ld,frame=%d,ltmFrame=%d,toneFrame=%d,softIspDGain=%#x,aeDGain=%#x"
+ " ch=%ld,frame=%d,msMode=%d,mpMode=%d,s=%d,p=%d,streamEn=%d,%d"
+ " ch=%ld,frame=%d,optCenter:%fx%f,%fx%f,ratio=%f"
+ " ch=%ld,frame=%d,p=%d,mpMode=%d,HWReg=%p,bStillCap=%d"
+ " ch=%ld,frame=%d,p=%d,mpMode=%d,s=%d,msMode=%d,HWReg=%p bStillCap %d"
+ " ch=%ld,frame=%d,p=%d,s=%d,mpMode=%d,msMode=%d"
+ " ch=%ld,frame=%d,p=%d,s=%d,mpMode=%d,msMode=%d,lastPass=%d,LastStep=%d,MsMBNR=%d"
+ " ch=%ld,frame=%d,pceCrop YUV:{%d,%d,%d,%d}, Raw:{%d,%d,%d,%d}"
+ " ch=%ld,frame=%d,pceEn=%d,strmEn(%d %d %d),GDC=%d,TileGDC=%d,master=%d,chInSync=%d,skipDepth=%d"
+ " ch=%ld,frame=%d,pdeCrop:%d %d %d %d, %d %d %d %d"
+ " ch=%ld,frame=%d,pipe=%d,rawSel=%d, src:W=%d,H=%d"
+ " ch=%ld,frame=%d,raw=%p,dynamic=%d,retain=%d,sushiRaw=%p,type=%d"
+ " ch=%ld,frame=%d,s=%d,dstEn=%#x %d"
+ " ch=%ld,frame=%d,s=%d,stripInW:%d,%d,stripOutW:%d,%d"
+ " ch=%ld,frame=%d,shKnobLevel=%d,isVHDR=%d,isVideo=%d is10bHDR: %d"
+ " ch=%ld,frame=%d,tnrFrame=%d,tnrFrameStill=%d,bFusionEn=%d,bMLVNRConfig=%d,MeshDMA=%d"
+ " ch=%ld,frame=%d,w=%d,h=%d BLURM:Y0=%p"
+ " ch=%ld,frame=%d,w=%d,h=%d VIO:size=%ld,addr=%p"
+ " ch=%ld,frame=%d,w=%d,h=%d,AuxPyr:Y=%p,UV=%p"
+ " ch=%ld,frame=%d,w=%d,h=%d,Semantic Video:=%p"
+ " ch=%ld,id=%d,BufferSize=%d,%d"
+ " ch=%ld,ispConfigId=%d,passId=%d"
+ " ch=%ld,mbnrMode=%d,chromaEn=%d, useCase=%d"
+ " ch=%ld,msgQueueSize=%ld,numOfReqFrames=%d"
+ " ch=%ld,previewFrameRate=%#x, standardFrameRate=%f"
+ " ch=%ld,scale[%d],CAFenable=%d,frame=%d,bCurrSMVEn=%d,segMapframeCount=%d"
+ " ch=%ld,scaler=%d,src:%dx%d,cropIn:%d %d %dx%d,out:%dx%d"
+ " ch=%zu bEnablePyramidWhenNotMaster=%d"
+ " ch=%zu cropPDE: %d %d %dx%d mappedCrop: %d %d %dx%d"
+ " ch=%zu fr=%i rotation=%f %f %f mag=%f"
+ " ch=%zu frame=%d invalid prvMsCh or !frameInOrder"
+ " ch=%zu frame=%d ltmMsCh=%d updateCh=[%zu,%zu) updateSuspend=%d pendingPano=%d"
+ " ch=%zu frame=%d stillCap=%d isPrvMs=%d prvMsCh=%d pendingPrvMsCh=%i prvMsSwitch=%d"
+ " ch=%zu frame=%d syncT=%d ltmSyncT=%d chInSync=%d frInSync=%d frInOder=%d isPrvMs=%d"
+ " ch=%zu frame=%d syncTag=%d recv HITHStat=%p"
+ " ch=%zu syncGroupID=%d"
+ " ch=%zu thre=%.3f outIIR=%.0f thumbHistIIR:buf=%.2f,cur=%.2f thumbHistBlend=%.2f"
+ " ch=%zu, YCC totalScaleX=%d, totalScaleY=%d\n"
+ " ch=%zu, gamma=%i, gammaChanged=%i"
+ " ch=%zu, isStreaming=%d, vHDR_enable = %d"
+ " ch=%zu, still totalScaleX0=%d, totalScaleY0=%d\n"
+ " ch=%zu,UseCase=%d,CtrlMode=%d,bMLVNREn=%d,bMLVNROutputEn=%d,bMLVNR1stFrameSet=%d"
+ " ch=%zu,frame=%d crop: %d %d %dx%d out: %dx%d"
+ " ch=%zu,frame=%d,types:%u to Algo Control"
+ " chId=%d, ispJobId=%#zx"
+ " chId=%ld"
+ " chTot=%ld"
+ " channel = %d, prevfrm_timeStamp = %llu, currfrm_timeStamp = %llu, gap = %d"
+ " chroma: Stride=%ld, TexDataSize=%ld, MetaDataSize=%ld"
+ " chroma: w=%d, h=%d, dma=0x%X, isYUV420=%d"
+ " chroma:TileMetaData:offset=%ld,size=%ld,bufsize=%ld"
+ " chroma:TileTexData:offset=%ld,stride=%ld,size=%ld"
+ " chromaIn(Bes):baseAddr=%p,stride=%d,size=%ld"
+ " chromaOut(%d): baseAddr=%p, Stride=%d"
+ " chromaOut(%d):baseAddr=%p,stride=%d,size=%ld"
+ " chromaOut(Clr):baseAddr=%p,stride=%d,size=%ld"
+ " chromaOut: baseAddr=%p, Stride=%ld"
+ " clrProcDmaEn %u bufferMthSemanticMap %p\n"
+ " clrProcDmaEn=%#x"
+ " cmdId=%ld, insize=%ld, outSize=%ld, ch=%ld"
+ " could not find jobId=%#zx"
+ " curr deltaIIR=%f deltaFlt=%f"
+ " curr=%i(%i %i %i %i)->%i(%i %i %i %i)"
+ " dataSrc=%d"
+ " dmaEnInfo=%#x,besProcDmaEn=%#x,inSelBes=%#x,inSelAuxScl=%#x,numOfOutputStreams=%d"
+ " dmaGroupId=%d, dmaId=%d, enable=%d"
+ " dmaOut %dx%d sif config %dx%d"
+ " done stillcap for ch=%ld, frame=%d,pass=%d,step=%d,state=%s"
+ " dpcStat:baseAddr=%p"
+ " dsEnabled=%#x (%#x)"
+ " dumping ch=%ld, frame=%d, %d frame(s) left"
+ " eit %lld exp %llu ag 0x%x dg 0x%x v %d sdg 0x%x"
+ " fType%u, pMetaDatafType %u, aefType%u"
+ " faceFrac=%f"
+ " fdRectClrProc:  %d %d %d %d"
+ " fesOut:w=%d, h=%d\n"
+ " flow=%d, Sent PDE bufs: frame=%d,%d ch=%d"
+ " flow=%d, Sent still PDE bufs orderId=%d: frame=%d, ch=%ld"
+ " flow=%d, ch=%d, ispJobId=%#lx"
+ " flow=%d, ch=%d, issued ispJob=%#zx to ispEngine"
+ " flow=%d, ch=%ld, issued ispJob=%#zx to ispEngine Src:%d"
+ " flow=%d, ch=%ld, issued ispJob=%#zx to ispEngine src:%d"
+ " flow=%d, chId=%ld, issued ispJob=%#zx job done"
+ " flow=%d, frame=%d, ch=%d, syncOrder=%d"
+ " flow=%d,ch=%d,seq=%d,ispJob=%#zx,pass=%d,step=%d"
+ " fn=%d ch=%d otf=%d fdRects=%d %d %d %d"
+ " focusPos = %f"
+ " frame rate: %d, not in active faceID session %d"
+ " frame=%d, ch=%ld Done"
+ " frame=%d, mpMode=%d,%d,msMode=%d,%d"
+ " frame=%d,ch=%ld,BesOut:w=%d,h=%d,Raw:w=%d,h=%d,sensorBin:%d %d,GDCStrength=%f"
+ " frame=%d,ch=%ld,Map Bes:x=0,y=0,w=%d,h=%d to Raw:x=%d,y=%d,w=%d,h=%d,bStill=%d"
+ " frame=%d,ch=%ld,fes=[%d %d],purpleW=[%d %d],besInRect=[%d %d %d %d]"
+ " frame=%d,ch=%zu,masterCh %d,lastProcessedChStill 0x%x,processedChMaskStill 0x%x,bOk %d,sync %d "
+ " frameCount=%d PFL=%f, delta=%f"
+ " free vHDR still ch=%ld, ctfChEnMask=%#lx, bufCnt=%d"
+ " gainTotal=%f, knobValueLuma=%d, knobValueChroma=%d\n"
+ " get buffer: stride %zu, bufferSize %zu"
+ " globalHist2Rect in ClrProc adjusted startXY=(%i,%i) endXY=(%i,%i)"
+ " globalHistRect in ClrProc adjusted startXY=(%i,%i) endXY=(%i,%i)"
+ " globalHistRect in ClrProc startXY=(%i,%i) endXY=(%i,%i)"
+ " globalHistRect2 in ClrProc startXY=(%i,%i) endXY=(%i,%i)"
+ " globalWeight=%.3f"
+ " goc1Gains=(%d %d %d) goc2Gains=(%d %d %d) linFilt=(%d %d %d)"
+ " goc2Offsets=(%d %d %d)"
+ " gocThre=%.3f,%.3f"
+ " groupID=%zu chMask=0x%X"
+ " header stride %zu size %zu offset %zu tile offset %zu tile data %zu"
+ " height=%d"
+ " hist:x=%d,%d,y=%d,%d"
+ " history=(%i %i %i %i)"
+ " hpp: baseAddr=%p, Stride=%d, offsetX=%d, offsetY=%d"
+ " hr: %p baseAddr=%p, Stride=%d"
+ " hr: baseAddr=%p, Stride=%ld"
+ " i %d numOfReqFrames %d start %d frameIndex %d frameType %d"
+ " id %llu frameInfoMask 0x%x apply %llu aeCount %llu"
+ " imuFilt=%i IIRFilt=%i motionData=%i ch=%i aeStable=%i"
+ " inChannels=%d, outChannels=%d"
+ " inW %d inH %d ix %d iy %d step %d %d nx %d ny %d"
+ " inWidth=%d, inHeight=%d"
+ " inputCh=%zu syncChTot=%zu"
+ " inputTileLines=%d,groupID=%d,BufferSize=%d,%d\n"
+ " invStd[%d]=%f\n"
+ " ispConfigId=%d"
+ " ispInputOffsetX=%d, ispInputOffsetY=%d, inOffsetX=%d, inOffsetY=%d"
+ " job=%#zx,%#zx, seqNum=%d,%d,dropped=%d"
+ " lce cas: baseAddr=%p"
+ " lensType=%d configIndex=%d"
+ " lhEn=%i,lhHM=%u,lhME=%i,lcHM=%u,lcME=%i,hiHM=%u,hiME=%i"
+ " linearIIR=%.2f bound %.3f-%.3f cycle %.0f-%.0f modulatedIIR=%.2f"
+ " localhistGridClrProc in Clr startXY=(%i,%i) width,height=(%i,%i) histblksize=(%i, %i)"
+ " localhistGridClrProc in RAW startXY=(%i,%i) width,height=(%i,%i) "
+ " lsc: baseAddr=%p, Stride=%d"
+ " lsc: baseAddr=%p, Stride=%ld"
+ " ltm ltc: baseAddr=%p"
+ " ltm spatialccm: baseAddr%p"
+ " ltm: baseAddr=%p, Stride=%ld"
+ " ltmBuffer ltmGrid (x,y)=(%i,%i) (w,h)=(%i,%i)"
+ " ltmBuffer sCCMGrid (x,y)=(%i,%i) (w,h)=(%i,%i)"
+ " ltmBufferToUse=%p bMultiPassMode=%d mpMode=%d"
+ " ltmGridRaw (x,y)=(%i,%i) (w,h)=(%i,%i)"
+ " ltmSpatialCCMGridConfig:(x,y)=(%i,%i),(w,h)=(%i,%i)"
+ " luma: Stride=%ld, TexDataSize=%ld, MetaDataSize=%ld"
+ " luma:TileMetaData:offset=%ld,size=%ld,bufsize=%ld"
+ " luma:TileTexData:offset=%ld,stride=%ld,size=%ld"
+ " luma:outWidth:outHeight=%d:%d,texWidth:texHeight=%d:%d,bTileGDC=%d,bCmpnDma=%d"
+ " luma:outWidth:outHeight=%d:%d,x:y=%d:%d,texWidth:texHeight=%d:%d Fmt=%d scaler=%d"
+ " lumaIn(Bes):baseAddr=%p,stride=%d,size=%ld,w:h=%d:%d,x:y=%d:%d"
+ " lumaOut(%d): baseAddr=%p, Stride=%d"
+ " lumaOut(%d): dmaId=%d, baseAddr=%p, Stride=%d x %d y %d w=%d h=%d"
+ " lumaOut(%d):baseAddr=%p,stride=%d,size=%ld,w:h=%d:%d,x:y=%d:%d,padRow=%d"
+ " lumaOut(Clr):baseAddr=%p,stride=%d,size=%ld,w:h=%d:%d,x:y=%d:%d"
+ " lumaOut: baseAddr=%p, Stride=%ld"
+ " lumaOut:offset:X=%d,Y=%d,Region:X=%d %d, Y=%d %d"
+ " mallocSize=%ld "
+ " mask=%#x"
+ " master exp %llu v %d sifr %llu skip %d rdo %d ratio %f"
+ " master vFrameTime %f slave vFrameTime %f"
+ " masterChannel=%ld for ch=%d, %d,%d,%d,%d"
+ " maxFESOutH=%d,BESOutH=%d"
+ " mbnrCSC2Coeffs[%d]=%d"
+ " mpAllIncomingList=%ld,stillInQ=%d,outGoingQ=%ld,%ld\n"
+ " mpMode=%d, frame=%d, bSushiRawCap=%d, bGenHuemap=%d"
+ " mpMode=%d,totalP=%d,msMode=%d,totalS=%d"
+ " mstfScale0WindingDownFrames = %d ch = %zu"
+ " multiCamMask=%#x"
+ " name=%s chTot=%zu"
+ " newScale= %d HITH Ratio:%f"
+ " no buffer to process"
+ " no padding row when pde is enabled"
+ " no update. Incoming ae counter %d vs. current counter %d"
+ " nxAE sh=%i,AG=%.3f,snDG=%.3f,DG=%.3f,hdrR=%.3f,ev0R=%.3f,ovflw=%.3f,harDG=%.3f"
+ " offset and faceX/Y: %4.2f %4.2f %4.2f %4.2f "
+ " offset=%#x, value=(%#x, %#x, %#x)"
+ " onLat:%d, offLat:%d MExpT %d SExpT %d"
+ " one of the frame info not valid"
+ " optCenter:x=%f,y=%f, minPFL=%f, maxPFL=%f, pixelSizeUm=%f"
+ " outStreams=%d, pplMode=%d"
+ " outW=%d,outH=%d"
+ " output=%d, offsetH=%d, offsetV=%d"
+ " pConfig->width %u pConfig->height %u dx %u, dy %u configNum %u\n"
+ " pLTMHostMeta=%p bUpdateLTMHostMeta=%d"
+ " pLTMLutsHostMeta=%p bUpdateLtmMetaData=%d bStillCap=%d"
+ " pMetaDataOutgoing->channel %d chId %zu"
+ " pOutgoingQ->Size() %zu"
+ " pPplInfo->jobDoneCntExp=%d, enableInfo %u afeProcDmaEn %u "
+ " pceCrop YUV:{%d,%d,%d,%d}, Raw:{%d,%d,%d,%d}"
+ " pdcStatic: baseAddr=%p"
+ " pdeCrop:%d %d %d %d, %d %d %d %d"
+ " prev deltaIIR=%f deltaFlt=%f"
+ " prevLTM=%p currLTM=%p curveClipMax=%d prevGocClipMax=%d"
+ " qIndex %lu reqID %d AECounter %d data %u"
+ " rBWR=%d, wBWR=%d"
+ " ratio=%d,gravity:%d,%d,%d"
+ " rawDMASrcCropRectX=%d, rawDMASrcCropRectY=%d"
+ " rawIn: baseAddr=%p, Stride=%ld, inWidth=%d, inHeight=%d"
+ " rawIn: input X=%d,Y=%d,Width=%d,Height=%d\n"
+ " rawIn: srcDmaId=%d,comp %d baseAddr=%p,Stride=%ld\n"
+ " recipX = %d, recipY = %d"
+ " regAddr=%#lx, value=%#x"
+ " requestId %llu frameCount %llu %llu request 0x%x ae# %d"
+ " reset PMP control"
+ " restoreEV0LTM=%d linLTC=%d mpMode=%d(%d) passId=%d(%d)"
+ " rotDelta=%f-%f=%f"
+ " rscl FPNR fpnrDMAOffsetX=%d, fpnrDMAOffsetY=%d, fpnrDMASrcWidth=%d, fpnrDMASrcHeight=%d"
+ " rscl0 CAR GridOffsetX=%d, GridOffsetY=%d, GridSizeX=%d, GridSizeY=%d"
+ " rsclProcDmaEn:%#x,%#x"
+ " save ToneCurve, toneFrame=%d, bSqrt=%d"
+ " scale%d:w=%d,h=%d,$lines=%d,dmaFmt=%d,base=%p"
+ " scale%d:w=%d,h=%d,$lines=%d,dmaFmt=%d,size=%ld,base=%p"
+ " scale0:w=%d,h=%d,$lines=%d,dmaFmt=%d,base=%p"
+ " scale0:w=%d,h=%d,$lines=%d,dmaFmt=%d,size=%ld,base=%p"
+ " scale1(chroma):$lines=%d, size=%ld,base=%p"
+ " scale1(chroma):base=%p"
+ " scale1(luma):w=%d,h=%d,$lines=%d,dmaFmt=%d,base=%p"
+ " scale1(luma):w=%d,h=%d,$lines=%d,dmaFmt=%d,size=%ld,base=%p"
+ " select=%d,w=%d,h=%d"
+ " sensorReadOutCropRectX=%d, sensorReadOutCropRectY=%d"
+ " sensorRect: curr=%i(%i %i %i %i) hist=%i(%i %i %i %i)"
+ " set msSyncOffset %d"
+ " should Sync %ld dynamic bufs for ch=%ld, pin =%ld"
+ " signal=%p\n"
+ " size=%ld,w=%d,h=%d"
+ " slave ch %zu frameIndex %d"
+ " slave exp %llu v %d sifr %llu skip %d rdo %d ratio %f"
+ " spawn task ID=%lld"
+ " srcDmaId=%d,comp %d companding:%d baseAddr=%p,Stride=%ld,inW=%d,inH=%d\n"
+ " startOffset=%d, regCnt=%d, ispConfigId=%#x"
+ " store hostmeta pMeta->fusion.inlierPctEV0 = %f"
+ " store hostmeta pMeta->fusion.inlierPctEVm = %f"
+ " stride %zu, addr %p bufferSize %zu numScene %u"
+ " stride=%d, srcWidth%u, srcHeight%u, OFFSETX%u, Y%u, s%u"
+ " stride=%zu, dstWidth%u, dstHeight%u, OFFSETX%u, Y%u, s%zu"
+ " stride=%zu, srcWidth%u, srcHeight%u, OFFSETX%u, Y%u, s%zu"
+ " syncGpCnt=%d, actualGpCnt=%d, activeChMask=%#x, totalGrps=%d"
+ " syncMode %d msSyncOffset %d"
+ " tableEntries=%d, staticTunableId=%d"
+ " tableEntries=%d, tunableMode=%d"
+ " thumb:x=%d,%d,y=%d,%d"
+ " totalH %d lineTime %f totalV %d"
+ " twDet%s:   Create next Det(ch=%d, id=%d, '%s', depth+1=%d"
+ " twDet%s:  # %u   pNextDetector->setFloatMap done"
+ " twDet%s:  => #%d chg=%.3f"
+ " twDet%s:  => this=%p"
+ " twDet%s:  forward size change: %dx%d => %dx%d"
+ " twDet%s: #%d processDiff, cur=%dx%d"
+ " twDet%s: Create Det(ch=%d, id=%d, '%s', depth+1=%d"
+ " twDet%s: First frame, init images"
+ " twDet%s: Process r:%d..%d, c:%d..%d grow=%d"
+ " twDet%s: RESET (%dx%d)"
+ " twDet%s: Seed=(%d,%d) => blob=%d,%d..%d,%d : %u pix"
+ " twDet%s: Size changed => %dx%d => rc=%d"
+ " twDet%s: Size changed: %dx%d => %dx%d => realloc"
+ " twDet%s: depth=%d dt=%.4fs upd=%.3f dtCumul=%.3f roi=%d,%d+%dx%d chg=%.1f%%"
+ " twDet%s: dt=%.3f timeScale=%.1f updt=%.3f skip=%d"
+ " twDet%s: dt=%.4f s > timescale=%.2f/2 => don't return result, keep mChangeLevel=%.3f??"
+ " twDet%s: dt=%f => update=%.4f,slow=%.4f roi=%d,%d..%d,%d maxTh=%.2f"
+ " twDet%s: final [%d] => blob=%2d,%2d..%2d,%2d : %ux%u, %u pix"
+ " twDet%s: mOutputMask=%p"
+ " twDet%s: pNextDetector->setFloatMap(%p, stride:%d, w=%d, h=%d)"
+ " twDet%s: purge depth=%d (%dx%d)"
+ " twDet%s: purge imageDiff, depth=%d"
+ " twDet%s: purge mOutputMask, mOutputMaskAllocated=%d"
+ " twDet%s: purged depth=%d"
+ " twDet%s: purged next depth"
+ " type=%d, sif2memory=%d"
+ " useCase=%d, section=%d, en=%d"
+ " value %d msSyncOffset %d"
+ " vc %zu sifrSkipRatio %d hrEnable %d sifrCtrl %d"
+ " visProcDmaEn:%#x,%#x"
+ " w=%d,h=%d,id=%d,levels=%d,LineBfrSize=%d,%d\n"
+ " wbgG[0]=%d, wbgG[1]=%d, wbgG[2]=%d, wbgG[3]=%d"
+ " width=%d"
+ " width=%d,height=%d,format=%d,stride.y=%d,stride.uv=%d\n"
+ " ysh cas: baseAddr=%p"
+ " yuvRect (x,y)=(%i,%i) (w,h)=(%i,%i)"
+ " yuvRect=(%i,%i) ltmGrid=(%i,%i) clrGrid=(%i,%i)"
+ "!!! Please add proper Max BWR based on plattform ids"
+ "!!!! LACC SUCCEEDED, status = %d"
+ "!!!!!!LACC DIFF DETECTED %llu"
+ "!!!!!!LACC ISP Diff = %d"
+ "!!!!!!RPC not available"
+ "!!!CHANNEL INIT"
+ "!((activeTMSyncGroup[groupID].startedChMask >> ch) & 0x01)"
+ "!((bLtmEnabled == false) && bLtmLinear)"
+ "!(ch != DEPTH_CAM_CH && statUsageMode[statResMap[ch]] == ISP_STAT_USAGE_MODE_INVALID)"
+ "!(chDescr->bFESAllowed && chDescr->bPYRAllowed)"
+ "!(dstWidth & 0x01) && !(dstHeight & 0x01)"
+ "!(eitUpdateParams.request & AE_USEMAP_CONTEXT_SWITCH)"
+ "!(fpPreserveEn && fpExclude)"
+ "!(hICCore[ICWrapper_ch]->hSensor->IsStreaming())"
+ "!(outStrmSelect & FLOW_OUT_STRM_BAYERPROC_BIT_MASK)"
+ "!(outStrmSelect & FLOW_OUT_STRM_CLRPROC_BIT_MASK)"
+ "!(pMetaData->HROn && pMetaData->vHDROn)"
+ "!(pOutConfig->x & (15))"
+ "!(pOutConfig->y & (1))"
+ "!(partialFlow->GetInitializedChannelsBM() & ((1 << inputChannel)))"
+ "!(preScaleOutputWidth & 1)"
+ "!(ret.f.isCmpnWithCompSrc && ret.f.isCmpnWithCompDst)"
+ "!(sUpdate->request & AE_USEMAP_CONTEXT_SWITCH)"
+ "!(srcOffsetX & 3) && !(pipeWidth & 3)"
+ "!(srcOffsetY & 1) && !(pipeHeight & 1)"
+ "!(width & 1)"
+ "!(x & 3)"
+ "!IsInTerminalState(m_channelState[ch])"
+ "!OPB_AVG_SEC_SIDEBAND_STREAM_ENABLED(streamProperties)"
+ "!WARNING! Client task overflow w/Task[%s(0x%llx)]\n"
+ "!afPDAFFocusStable"
+ "!afeDmaEnabled"
+ "!afeTuning.sizeMaxX || (clipRectRequest.size.x <= afeTuning.sizeMaxX)"
+ "!afeTuning.sizeMaxY || (clipRectRequest.size.y <= afeTuning.sizeMaxY)"
+ "!axiDma.enabled"
+ "!bEnabled || addr"
+ "!bufInFrame->Owner()->IsIcCompressBufferPool()"
+ "!bypass"
+ "!chDescr->isSifrMode || (chDescr->isSifrMode && !chDescr->bHREnabled && !chDescr->bVHDREnabled && chDescr->sifrCtrl == CIC_SIFR_CTRL_SKIP)"
+ "!chDescr->sensorConfigs[chDescr->configNum].bAsymmetricCropSupported"
+ "!channelInfo[channel].isSifrMode || (channelInfo[channel].isSifrMode && !channelInfo[channel].bHREnabled && channelInfo[channel].sifrCtrl == CIC_SIFR_CTRL_SKIP)"
+ "!clrBeTileBufReqdBitMask"
+ "!config.output.format.bSifDMACompress"
+ "!cropEnabled || (cropSizeX < 8704)"
+ "!cropEnabled || (cropStartX < 8192)"
+ "!currSetting->ae.contextSwitchCompleted"
+ "!descrCommon->pyrOutProc1BufCnt"
+ "!descrCommon->pyrOutProc1BufCntStill"
+ "!enabled || (NULL != patchDma.coordBuf && 0 != patchDma.coordBufSize)"
+ "!endPointCb[pCmd->endPointId].shareMem.item[i].used"
+ "!forCvd"
+ "!fpPattern.onR && (fpPattern.onG || fpPattern.onB)"
+ "!h->pTMStillMetaDataCBufArray[ch]"
+ "!hICExclave[camIndex]->GetExclaveOnlyMode()"
+ "!hSensor->IsYsizeUpdateConflict()"
+ "!inited[endPointId]"
+ "!invRes"
+ "!isDefault || newCount == 0"
+ "!isEmpty"
+ "!isEnabled()"
+ "!isExclaveOnlyMode || !streamingStarted"
+ "!isHwMapped"
+ "!isMoving"
+ "!isReprocess"
+ "!isStreaming"
+ "!isinf(pOutCheck[xx*LTM_LTC_NUM_NODES+i])"
+ "!isnan(pOutCheck[xx*LTM_LTC_NUM_NODES+i])"
+ "!m2mTileGDCBufReqBitMask"
+ "!mInstance"
+ "!m_isAFStarted"
+ "!m_selectBuf"
+ "!m_settings.module.readBeforeUpdate || m_i2cState.busStatus == LC_I2C_STATE_WAITING_FOR_REPLY"
+ "!m_sortBuf && !m_selectBuf"
+ "!memcmp(&pMetaData->zoom.centeredSensorReadOutCropRect, &pMetaData->zoom.sensorReadOutCropRect, sizeof(struct sBTRect))"
+ "!memcmp(pExtra, pBuff->entry.buffRef.extra, sizeof(struct sFrameExtraInfo))"
+ "!onR"
+ "!onR && !onB"
+ "!onR && !onG"
+ "!pAwb->awbReflow.bGenerateReflowAWB"
+ "!pChInfo->bAWBSuspend"
+ "!pChInfo->bCurrMLVNREn || !pChInfo->bCurrMLAFEn"
+ "!pChInfo->bStillCap || !pCurrMpInfo->bOnGoing || frameCount == INVALID_FRAME_COUNT"
+ "!pChInfo->currMultiPassInfo.bOnGoing || !bStillCap"
+ "!pChInfo->currMultiStepInfo.bOnGoing || !bStillCap"
+ "!pChInfo->inputFrameBufQ->Size()"
+ "!pChInfo->ispEngJobQ->Size()"
+ "!pChInfo->pplInfoQ->Size()"
+ "!pContext->aneClient"
+ "!pDescr->bCurrFrameMsMBNREnabled"
+ "!pDescr->bStillCap"
+ "!pDescr->bStillCap || ch == TELE_CAM_CH || ch == SWIDE_CAM_CH"
+ "!pDescr->paramBES.bUseBESWarpWorkaround"
+ "!pDescr->paramNoiClr.bGenerateDoViMetaData"
+ "!pDescr->paramNoiClr.bStaticCLUTEnable"
+ "!pDescr->paramRaw.bCurrFsclEn"
+ "!pDescr->paramRaw.bFHSEnabled || !bUseRBBinning"
+ "!pEntry->child"
+ "!pFrameDesc->outBuffEV0 || pFrameDesc->outBuffEV0->Size() >= (outWidth * outHeight)"
+ "!pFrameDesc->outBuffEVm || pFrameDesc->outBuffEVm->Size() >= (outWidth * outHeight)"
+ "!pItem->validPending"
+ "!pMetaData->bSifrStatsExpected"
+ "!pMetaData->fepDMAOutputBinH || pMetaData->binW == 0"
+ "!pMetaData->fepDMAOutputBinV || pMetaData->binH == 0"
+ "!pMetaData->slinEnable && !pMetaData->performStatsBLCInSlin"
+ "!pMetaDataAEBracketing->bTimeMachineBracket"
+ "!pMsDmaConfig->bCompressionEn"
+ "!pPplInfo->bTileGDCEn"
+ "!pPplInfo->bufOutMth"
+ "!pSifrCapturedFrame"
+ "!pTMStillMetaDataCBufArray[ch]"
+ "!pTMStillMetaDataCBufArray[pDescr->ch]"
+ "!pTMStillMetaDataCBufArray[pDescrMaster->ch]"
+ "!pUser->isPending"
+ "!patchDma.enabled"
+ "!pcaeRec->bFirstFrame"
+ "!pdp.GridConfig[k].GridEn || !ended"
+ "!rc"
+ "!reader"
+ "!rect.isEmpty()"
+ "!req->InterruptEnabled()"
+ "!reqPendingStatus[sourceIndex]"
+ "!shiftMap.rect.isEmpty()"
+ "!statsOutputEn || !previewOutputEn"
+ "!taskAborted"
+ "!temp"
+ "!this->_doAbort"
+ "!this->isHoldingBuffers()"
+ "!this->m_trace[ch].cached"
+ "!useDualBank_"
+ "!users[i].isUsed"
+ "#%d D-Auto Master (%lld): exp %llu (%f), v %u, gain %f"
+ "#%d D-Auto Slave  (%lld): exp %llu (%f), gain %f"
+ "#%d D-SIS Master (%lld): exp %llu (%f), gain %f"
+ "#%d D-SIS Slave  (%lld): exp %llu (%f), gain %f"
+ "#%d Dual HDR BKT IR: exp %llu (%.3f), v %u, gain 0x%x, strobe %d\n"
+ "#%d Dual HDR BKT RGB exp %.3f us, v %u, gain 0x%x\n"
+ "#%d Dual SIS BKT IR: exp %llu (%.3f), gain 0x%x, strobe %d"
+ "#%d Dual SIS BKT RGB (%lld): exp %llu (%.3f), v %u, gain 0x%x (%.3f)"
+ "#%d OIS Bracketing (%d), (%lld): exp %llu (%f), gain 0x%x (%f)"
+ "#%d SIS Bracketing (%lld): exp %llu (%f), gain 0x%x (%f)"
+ "%-30s %-16.4f %-16lld %-16lld %-8lld\n"
+ "%-30s %-16s %-16s %-16s %-8s\n"
+ "%-30s %-6s %-8.4f %-8.4f\n"
+ "%-30s %-6s %-8.4f %-8s %-10.4f %-16lld %-16lld %-8lld\n"
+ "%-30s %-6s %-8s %-8.4f %-10.4f %-16lld %-16lld %-8lld\n"
+ "%-30s %-6s %-8s %-8s %-10.4f %-16lld %-16lld %-8lld\n"
+ "%-30s %-6s %-8s %-8s %-10s %-16s %-16s %-8s\n"
+ "%.3f %.3f %.3f\n"
+ "%016llx\n"
+ "%02x (0x%04x, 0x%02x)\n"
+ "%1d"
+ "%d %d"
+ "%d %d %d %d"
+ "%d %d %d %d %d %d %d %d"
+ "%d %d %f %f %d"
+ "%d %zu"
+ "%d : MAIN stats fc %d bk %d"
+ "%d : SIFR stats fc %d bk %d"
+ "%d : buf %p size 0x%lx index 0x%x\n"
+ "%d >= %d"
+ "%d ch %zu hybrid, FES width=%d, bes=%d/%d"
+ "%d coefTL %d coefSW %d %d mA"
+ "%d faces detected"
+ "%d.%04d "
+ "%d: Sz:%zu W:%d H:%d [%d %d %d %d] [%d %d]"
+ "%d[%p] set to HiZ\n"
+ "%f"
+ "%f %.6f %.3f"
+ "%f, %f, %f\n"
+ "%f, %f, %f, %f"
+ "%i + %i <= %i"
+ "%i <= %i - %i"
+ "%i >= %i"
+ "%lu >= %i\n"
+ "%lu,%s,%llu,%d,%d\n"
+ "%p 0x%x"
+ "%p TS: %f \n"
+ "%p bEnable %d"
+ "%p bSecondary %d"
+ "%p ch %u fc %u: force HR off. old HR %u vHDRon %u"
+ "%p enable %d bSecondary %d"
+ "%s %04x = %02x %02x\n"
+ "%s %d bytes 0x%x <== 0x%x, 0x%x <== 0x%x\n"
+ "%s %d out of %d, ave (%.3f vs. %.3f)"
+ "%s %d: loggingLevel=%d\n"
+ "%s %d: set bAWBMultiStatsEnable=%d\n"
+ "%s %d: timeStampGo - timeStampRVsync=%f\n"
+ "%s %ds"
+ "%s %f\n"
+ "%s %llu\n"
+ "%s %p %d %llx %p %d\n"
+ "%s %p %x %016llx\n"
+ "%s %p size %zu stride %d : %zu\n"
+ "%s %s"
+ "%s %s 0x%02x%02x - 0x%02x%02x%02x%02x"
+ "%s %s 0x%04x - 0x%02x"
+ "%s %s 0x%04x - 0x%08x"
+ "%s %s Created! (%p)"
+ "%s %s Face IR Timeout: %d"
+ "%s %s GMC Debug: %d"
+ "%s %s GMS algo done, received results data"
+ "%s %s Got PDEOutputConfig: Type:%d Width:%d Height:%d Options:0x%x, ch %zu"
+ "%s %s Received Output Config command: type=%#x optionsBM=%#x height=%d width=%d"
+ "%s %s Set CMD = %#08x, Issuer = %s"
+ "%s %s buffers arrived, channel=%zu port=%zu portPin=%zu"
+ "%s %s full:%ux%u crop:%ux%u wh:%ux%u\n"
+ "%s %s received cmd %#zx"
+ "%s %s received cmd property write %#x"
+ "%s %s received data %#zx"
+ "%s %s sending data to destination: %s"
+ "%s %s sending outputs to destination: %s"
+ "%s %s signal arrived: %s"
+ "%s %s: %s %d\n"
+ "%s %s: %x = %d\n"
+ "%s %s: Read SIB CR1 failed\n"
+ "%s %s: Set SMB clock speed to %u\n"
+ "%s %s: Write SIB CR1 failed\n"
+ "%s %s: config%zu - w %d x h %d, totalH:%llu totalV: %u\n"
+ "%s %s: frm#%d ag %x dg %d it %d fl %d, temp %f C\n"
+ "%s %s: frm#%d ag %x dg %x it %d\n"
+ "%s %x\n"
+ "%s %x %llx %x %x %x\n"
+ "%s (subMode=%d, flowType=%d)"
+ "%s *****LCAF DEBUG***** %s\n"
+ "%s - Guad mixed mode %d set (%x,%x,%x) %x(%x) count (%d,%d,%d) @ %llu %llu %llu\n"
+ "%s - Guad mixed mode set %x %x @ %llu\n"
+ "%s : *** ACK: Endpoint command %d with ticket %u seq %u\n"
+ "%s : *** endPoint %d cmd %d ack 0x%x ack_rc 0x%x ticket %u seq %u\n"
+ "%s : Accumulated frame skipped happened %u times\n"
+ "%s : AneIpcSap Register userId = 0x%x sapId = 0x%x\n"
+ "%s : CallProc userId = 0x%x sapId = 0x%x builtinProgramId = %d\n"
+ "%s : Configure pCmd endPointId = %d\n"
+ "%s : Free Shared Memory endPointId = %d at %p\n"
+ "%s : Get EndPoint Status %d\n"
+ "%s : Get Outstanding Ticket Cnt %d\n"
+ "%s : GetBuffer size = 0x%zx\n"
+ "%s : Malloc Shared Memory endPointId = %d\n"
+ "%s : Received %u frames\n"
+ "%s : Received more than one frame in one interrupt occured %d times\n"
+ "%s : ReturnBuffer %p index %d\n"
+ "%s : SAP Register endPointId = %d sapId = 0x%x\n"
+ "%s : SAP UnRegister endPointId = %d sapId = 0x%x\n"
+ "%s : Send Buf endPointId %d sapId 0x%x %d\n"
+ "%s : Sensor OCL Type %d \n"
+ "%s : Unset pCmd endPointId = %d\n"
+ "%s : maxInterval (%f microsecond) is bigger than 10 *1000 microsecond\n"
+ "%s : streaming not started yet\n"
+ "%s ==> %s"
+ "%s @ %llu\n"
+ "%s @ %llu uS\n"
+ "%s AD final result verification %d"
+ "%s AD2AE succuess!"
+ "%s ADC reading 0x%x\n"
+ "%s Attached device FEP %p"
+ "%s BEGIN --> FastLinkTraining AUX-Less operation config:%d lane:%d \n"
+ "%s Bufs[%d] verification"
+ "%s Ch%u: post (ack) failed - rc = %d"
+ "%s Current %dmA => reg 0x%x"
+ "%s DPCDefectPixelCount=%d MaxDPCDefectPixelCount=%d"
+ "%s Delayed Guad VDD off at %llu for %llu ms\n"
+ "%s ER Network output verification"
+ "%s ER Postprocessed output verification"
+ "%s ER Preprocessing output verification"
+ "%s FD Net output verification"
+ "%s FD Pass[%d] v.s Ref"
+ "%s FD final result verification"
+ "%s Failed to send buffer to sink"
+ "%s GRIEVOUS LOCK(%d): state %02x @%llu\n"
+ "%s GRIEVOUS UNLOCK(%d): state %02x @%llu\n"
+ "%s GRIEVOUS state %s @%llu\n"
+ "%s GetResistance %d = %02x%02x, %f\n"
+ "%s Grp: %d level %d bits: 0x%llx\n"
+ "%s Grp: %d level %d bits: 0x%llx, curr %d uA\n"
+ "%s Grp: %d level %d bits: 0x%llx, curr %dmA\n"
+ "%s Host eph public key not ready\n"
+ "%s IGNORE FAULT, Leader write response IRQ recieved %u"
+ "%s IMX575: temp %f\n"
+ "%s IMX633: spd %s - step1 registers updated @%llu\n"
+ "%s IMX803: splitPD enabled @%llu cfg %d pending %d\n"
+ "%s IMX903: splitPD enabled @%llu cfg %d pending %d\n"
+ "%s IMX913: splitPD disabled @%llu cfg %d pending %d\n"
+ "%s IMX913: splitPD enabled @%llu cfg %d pending %d\n"
+ "%s IMX972: splitPD disable @%llu cfg %d pending %d\n"
+ "%s IMX972: splitPD enabled @%llu cfg %d pending %d\n"
+ "%s Init radial gain asymscale asymScaleX %f asymScaleY %f"
+ "%s Invalid subMode (subMode=%d, flowType=%d)"
+ "%s LED EN: 0x%x Reg: Center 0x%x Corner 0x%x Side 0x%x\n"
+ "%s Latency DB:"
+ "%s OD final result verification %d"
+ "%s Out2ExtSlaf"
+ "%s Paused\n"
+ "%s Polling BusyDest (#%d) = %#x\n"
+ "%s Polling BusyDest (#%d) = Be %#x Fe %#x\n"
+ "%s Prepare Stop start @ %llu\n"
+ "%s Prepare Stop start done @ %llu\n"
+ "%s ResetAllPartialFlows didn't release all flows as needed"
+ "%s Resumed\n"
+ "%s S totalV %d (sent %d) exp %llu sifrExp %llu\n"
+ "%s SN %s size %d\n"
+ "%s SplitPDCropSet: x %u, y %u, width %u, height %u"
+ "%s SplitPDLineLenGet: Cannot get line length\n"
+ "%s Start to initialize programe[%d] %d"
+ "%s WRN: Center XY set for %s failed"
+ "%s add defect list for ch %zu cfg %u type %u numDefects %u"
+ "%s ch %d: Can't use this for updating FC estimator \n"
+ "%s ch %d: Can't use this for updating PFL estimator \n"
+ "%s ch %d: Depth Latency: %f (lim %f) \n"
+ "%s ch %d: Received Depth: %f %f, ispTimeStamp= %llu \n"
+ "%s ch %d: currentPos: %d deFocus %f (PDAF %d, %d)\n"
+ "%s ch %d: defocusChange %f pdafPos change %d \n"
+ "%s ch %d: depthChange during deFocus %f (%d) , %f (%d)  hist %d %d (%d) \n"
+ "%s ch %d: ispTime: %llu, largeShiftSinceLastDepth: %d (%.2f)\n"
+ "%s ch %d: lastDepthVld %d, pdafConfNG %d, chngDepth %d, spot %d halt %d\n"
+ "%s ch %d: pdafTgtPos[%d] %d (%d, %d) \n"
+ "%s ch %d: spot depth (%d) delta %f, logical delta = %f (%d)\n"
+ "%s ch %zu mode %u"
+ "%s cmd %d\n"
+ "%s exit @ %llu\n"
+ "%s expP %x shutter %x FO %x"
+ "%s expP %x shutter %x, orientation:%d"
+ "%s failed set property=%d value=%d"
+ "%s fc %d master %d slave %d\n"
+ "%s flow could not contain pearl flow and also fusion flow at same time"
+ "%s flow state after set primary data should be %u, but it's %u"
+ "%s flow with this input already exists (ch=%zu, ST=%d)"
+ "%s get key wrap %x %x, HMAC %x %x, IV %x %x\n"
+ "%s get key wrap %x %x, HMAC %x %x, IV %x %x tag %x %x\n"
+ "%s get result ch=%zu %llu %llu"
+ "%s get semantic anstBuf ch=%zu previewCh=%zu %llu %llu"
+ "%s in %dx%d out %dx%d outtype %d"
+ "%s inputCrop %d %d %dx%d pMetaData %d %d valid %d %d %dx%d"
+ "%s inputRect %d %d %dx%d PreCrop %d %d %dx%d adj %d %d %dx%d preScalerRatio %d %d\n"
+ "%s is already running yet\n"
+ "%s is already started\n"
+ "%s is full"
+ "%s is not started yet\n"
+ "%s is not suppored\n"
+ "%s len %zu"
+ "%s modesig 0x%x type_grp %d bitmap 0x%llx\n"
+ "%s numOfReqFrames %d queue size %zu start idx %d bracketMode %u"
+ "%s numOfReqFrames %d queue size %zu start idx %d mode %u\n"
+ "%s pearl depth depending on IR inputs..."
+ "%s property %d not handled"
+ "%s reading ...\n"
+ "%s reset contextSwitchTag %d\n"
+ "%s resolutions should have been the same! %d != %d"
+ "%s retain buffer fc %d master %d slave %d\n"
+ "%s sensor index %d\n"
+ "%s sensor index %d > host index %d\n"
+ "%s set key %x %x ... %x %x\n"
+ "%s size %zu stride %d:\n"
+ "%s start %d end %d ref %d frameType %d\n"
+ "%s start %d end %d retain %d\n"
+ "%s start: totalV %d (sent %d) %f\n"
+ "%s started\n"
+ "%s stop before finishing all files"
+ "%s stopped\n"
+ "%s stream paused @ %llu fl %d\n"
+ "%s support frame abort %u continousSync %u \n"
+ "%s try to release a released buf ID=%ld\n"
+ "%s try to retain a released buf ID=%ld\n"
+ "%s type_grp %d \n"
+ "%s type_grp %d curr %dmA\n"
+ "%s unexpected calib type %u"
+ "%s unsuported payload to destination type (%d)"
+ "%s unsupported control type provided (%d)"
+ "%s unsupported inputChannel %zu"
+ "%s update gain %d sensorGain %d"
+ "%s%02d"
+ "%s%s%u"
+ "%s%u%s"
+ "%s(%p) : GetProgDesc"
+ "%s(%p) : LoadProg userId = 0x%x sapId = 0x%x builtinProgramId = %d\n"
+ "%s(%p) : UnloadProg userId = 0x%x sapId = 0x%x builtinProgramId = %d\n"
+ "%s(%p) ProgramInfo cmd %d"
+ "%s(%p) ProgramInfo cmd %d, sapId = 0x%x builtinProgramId = %d"
+ "%s(%p) done !!!"
+ "%s(%p) started !!!"
+ "%s() writing %s\n "
+ "%s():L%u invalid OIS recenter time"
+ "%s, %d: IC ch %zu wait total %.4fms\n"
+ "%s, %d: [%s] ch %zu stop done! @%.4f IC takes %fms to stop\n"
+ "%s, chtot%d"
+ "%s, context %lu irq %d userId %ld"
+ "%s, evtCounter %d \n"
+ "%s, evtCounter %d statsId %d\n"
+ "%s, flags 0x%x\n"
+ "%s, gpio %d, on: %d"
+ "%s, gpio 0x%x\n"
+ "%s, gpio 0x%x, set to %s\n"
+ "%s,%d: Does not release pFrame in first frame of dual flash process\n"
+ "%s,%d: Does not release pFrame in main frame Output under main_sifr_case\n"
+ "%s,%d: force to release ae bracketing\n"
+ "%s,file=ch_%d_src_%02d_frm_%08d_s_%d_i_%d.lut\n"
+ "%s,file=ch_%d_src_%02d_frm_%08d_s_%d_i_%d.reg\n"
+ "%s,file=ch_%d_src_%02d_frm_%09d_fe_%08x_be_%08x.lut\n"
+ "%s.dif"
+ "%s.msk"
+ "%s:  CMD = %x - Wrong FSM index: %u > %zu\n"
+ "%s:  CMD = %x - handle : %p [%s] - Wrong child index: %d > %d\n"
+ "%s: #%d Old AE Updates before start"
+ "%s: %d\n"
+ "%s: %d - %f mV %d ch %ld\n"
+ "%s: %d = 0x%02x%02x, %f\n"
+ "%s: %d mW %d fps %d mS, %f sec %d pulse\n"
+ "%s: %d sfir %d"
+ "%s: %lu %p, TS: %f \n"
+ "%s: %lu %x %x TS: %f \n"
+ "%s: %lx fep%d qBin %d HBinEn %d VBinEn%d fepOutType %d"
+ "%s: %p\n"
+ "%s: %p %d, TS: %f \n"
+ "%s: %s - program fab (0x%x) settings\n"
+ "%s: %s 0x%4x: %umV"
+ "%s: %s ERROR status EVENT %#02x, on SIB_%zu"
+ "%s: %s EVENT %#02x, NACK not on SIB_%zu, skip"
+ "%s: %s I2C follower device ID %#02x cmd ID %#02x"
+ "%s: %s Not Supported channel: %d\n"
+ "%s: %s TS: %f AldaST in active state"
+ "%s: %s TS: %f AldaST in idle state"
+ "%s: %s TS: %f Waiting for active state..."
+ "%s: %s TS: %f Waiting for idle state..."
+ "%s: %s common ERROR EVENT %#02x, on SIB_%zu"
+ "%s: %s fail: Flash in progress"
+ "%s: %s failedSend[%d]: %d"
+ "%s: %s setting delayed. Sensor not streaming"
+ "%s: %s: %s I2C%d\n"
+ "%s: %s: Act %zu Max %zu"
+ "%s: %s: Context didn't switch exp %u act %u"
+ "%s: %s: FDRSysCfg parse failed"
+ "%s: %s: FileID %#x does not support lookup by module"
+ "%s: %s: Full resolution host metadata unavailable. fc %d"
+ "%s: %s: GIC invalid"
+ "%s: %s: Get FDRSysCfg block %u failed proj %#x:%c"
+ "%s: %s: No buffer found, Buf %p DP %p"
+ "%s: %s: Not supported ch %u"
+ "%s: %s: One time ALDAST config"
+ "%s: %s: Param %u Val %u %f"
+ "%s: %s: Skipping LSC for Quadra HiRes capture"
+ "%s: %s: Skipping LTM for Quadra HiRes capture"
+ "%s: %s: ch %u context switch cfg %u apply highres AEAWB windows for new context\n"
+ "%s: %s: ch %zu id %#x"
+ "%s: %s: ch %zu sensor DistCal data get single"
+ "%s: %s: exp %u act %u\n"
+ "%s: %s: flushed SIB%d, sib common error: 0x%02x\n"
+ "%s: %s: gain %d sensorGain %d"
+ "%s: %s: gpio: %d, drv: %d"
+ "%s: %s: gpio: %d, on: %d spmi: %p"
+ "%s: %s: gpio: %u, addr: 0x%04x, data: 0x%08x\n"
+ "%s: %s: id %#x module %#x:%c"
+ "%s: %s: inval %#08x%06x%08x != %#08x%06x%08x (BldInf)"
+ "%s: %s: no valid ext cal : model number 0"
+ "%s: %s: preserving model 3"
+ "%s: %s: preserving model 4"
+ "%s: %s: proj frameCount %u, afDepthSrcFrameRateDecimationFactor %u slafDepth %u"
+ "%s: %s: reset SIB%d\n"
+ "%s: %s: size %u, max %lu"
+ "%s: %s: switching from model 1 to model 3"
+ "%s: %s: switching from model 2 to model 3"
+ "%s: %s: unexpected ts %f not in range low %f high %f\n"
+ "%s: (%d, %s): [%d, %s]->[%d, %s]"
+ "%s: 0x%llu, 0x%llu, 0x%llu, 0x%llu\n"
+ "%s: 0x%x %d\n"
+ "%s: 0x%x is not honored any more!"
+ "%s: 0x%x,(tot) maxStrCurrent: 0x%x = %d mA, mainStrCurrent: 0x%x\n"
+ "%s: AE stats collected @ %f, src(%#08llx). isrCnt:%d"
+ "%s: AE%d finished!"
+ "%s: AESettingsUpdate %d (%d)"
+ "%s: AEWindow[%d], enable=%d."
+ "%s: AF stats collected @ %#llx, src(%#08llx)."
+ "%s: AFWindow[%d], enable=%d\n"
+ "%s: AWB stats collected @ %#llx, src(%#08llx)."
+ "%s: AWBWindow[%d], enable=%d."
+ "%s: Absolute current update. Resetting Ratio \n"
+ "%s: AdjustEIT: ExpAdj %#X, ShutterEIT %d, AGain %#X, DGain %#X"
+ "%s: After SmoothAE: exp %llu xA %u xD %u; sifr: exp %llu xA %u xD %u\n"
+ "%s: After SmoothAE: flag 0x%x, status %d, CountDown %d\n"
+ "%s: All stats collected deferred signal msk %x @ %f. "
+ "%s: Alloc Bank %d srcDMAIndex %d hDMAIn %p"
+ "%s: Analog gain updated to %d (%d)"
+ "%s: Bank %lx Set AWBWindow[%d], x=%d, y=%d, w=%d, h=%d."
+ "%s: Before SmoothAE: nextMain exp=%llu xA %u xD %u; nextSifr exp=%llu xA %u xD %u\n"
+ "%s: Binning updated to %s \n"
+ "%s: Boot status 0xA8 - 0x%x\n"
+ "%s: BracketingParamsSet ignored."
+ "%s: Buffer String %s from host.\n"
+ "%s: CH = %zu START"
+ "%s: CH = %zu STOP"
+ "%s: CHILD BY INDEX - handle : %p [%s], child[%03d] %p [%s]\n"
+ "%s: CHILDREN TOT - handle : %p [%s], children %d\n"
+ "%s: CMD = %x - No object with such name : %s\n"
+ "%s: CMD = %x - String name too long [> %d]\n"
+ "%s: CMD = %x - Wrong FSM handle : %p\n"
+ "%s: CMD = %x - Wrong component handle : %p\n"
+ "%s: Calc Main: Frame skipped."
+ "%s: Ch:%u Input wd %d ht %d addr %lx %lx"
+ "%s: Clearing request list %zu"
+ "%s: Clearing request list %zu\n"
+ "%s: Clock %u TotalH %d LineTime %f"
+ "%s: CmdAGCSet =%d"
+ "%s: CmdDGCSet =%d"
+ "%s: CmdExposureGainSet expT %d, agc 0x%x, ispG 0x%x, sDG 0x%x"
+ "%s: CmdExposureTimeSet =%d"
+ "%s: CmdFrameRateSet =%d"
+ "%s: CmdInitExposureTimeSet =%d"
+ "%s: CmdInitFrameRateSet =%d"
+ "%s: CmdLSCTableSourceSet, source=%d"
+ "%s: CmdSDGCSet =%d"
+ "%s: CmdSetfileInfoSet, main =%d, sub=%d"
+ "%s: CmdSifConfig, format=%d, pack=%d compression=%d companding %d\n"
+ "%s: CmdSifConfigGet, format=%d, pack=%d compression=%d companding %d\n"
+ "%s: CmdTestPatternConfig, enable=%d"
+ "%s: CmdUnifiedBracketingParamsSet ignored."
+ "%s: CmdWarmStartupSet, enable=%d"
+ "%s: Converting vSizeLB %d ==> %d due to LLPCK change."
+ "%s: Coordinates not a rectangle."
+ "%s: Created! (%p)"
+ "%s: Creating CapturePrepTask for ch=%lu\n"
+ "%s: Creating SensorBootTask for ch=%lu\n"
+ "%s: DMA done, (%x == %x)"
+ "%s: DPC_revision %d unsupported"
+ "%s: DVC ch%d voltage override %fV\n"
+ "%s: Deleted! (%p)"
+ "%s: Delta: sensor=x%.2f, stopEV=%.2f; tuneStep=%.2f\n"
+ "%s: EA"
+ "%s: EB"
+ "%s: EN 0x%x, regval 0x%x"
+ "%s: EN: 0x%x, ch0/1 : 2 : 3 0x%x 0x%x 0x%x \n"
+ "%s: ENV GET - Environment handle : %p\n"
+ "%s: Error Notification  (%d) returned from host with rc %d\n"
+ "%s: Error Notification (%d) ch %d being sent to the host.\n"
+ "%s: Exceeds maximum tries %i while waiting!, occupancy level = %d"
+ "%s: Exceeds maximum tries while waiting!, pendingCount = %d"
+ "%s: ExpAdj %#X, TargetBR %d, CurEIT %d, TargetLux %.2f"
+ "%s: Exposure %d (%llu) totalV %d sifr %llu eit sifrRDO %d"
+ "%s: Exposure time updated to %d (%llu)"
+ "%s: Exposure time updated to %d (%llu), %d %d\n"
+ "%s: Exposure time updated to %u (%llu)"
+ "%s: ExposureTimeUpdate pending exp %d\n"
+ "%s: FD4AF CropScaleSet: w %d, h%d  %d , %d, w %d h %d\n "
+ "%s: FE roi %d,%d+%dx%d => in tiles: %.1f,%.1f..%.1f,%.1f => %d,%d+%dx%d"
+ "%s: FSM BY INDEX - FSM[%03d] %p [%s]\n"
+ "%s: FSM BY NAME - handle : %p, name %s\n"
+ "%s: Filter not expected to handle this irq %lx (DMA: %lx, HAT %lx)"
+ "%s: Flashlight (per driver): %f mA. Cool0: %f mA, Warm0: %f mA,Cool1: %f mA, Warm1: %f mA\n"
+ "%s: Found face for FID (%s), engaged (%s)\n"
+ "%s: Frame rate updated to %d.%d"
+ "%s: Frame skipped."
+ "%s: Free hDMAIn %p"
+ "%s: GET DEBUG LEVEL - object: %p - level = %d\n"
+ "%s: GET FSM DEBUG LEVEL - handle: %p [%s] - level = %d\n"
+ "%s: GOING TO STOP"
+ "%s: GPIO(%d): 0x%04x - 0x%08x"
+ "%s: GPIO-PWR-SLOT(%d): 0x%04x - 0x%08x"
+ "%s: GPIO-SLOT-DURATION: 0x%04x - 0x%08x"
+ "%s: GetSafetyState() failed"
+ "%s: HAT DMA done, (%x == %x)"
+ "%s: HR stats collected @ %#llx, src(%#08llx)."
+ "%s: HiResAWBWindow[%d] cannot be enabled because window too small"
+ "%s: HighResAEAWBWin[%d], enable=%d."
+ "%s: Hostmeta #%d, ts %lld"
+ "%s: Hostmeta #%d, ts %lld, w %d, h %d"
+ "%s: IN: cfg %-2u PD%s (%#04x, %#04x) ll %.3fus slope %.3f"
+ "%s: ISP_PROPERTY_TIMEWARP_MAXRECORDINGFPS: hTimewarp is null\n"
+ "%s: ISP_PROPERTY_TIMEWARP_MINRECORDINGFPS: hTimewarp is null\n"
+ "%s: ISP_PROPERTY_TIMEWARP_SETMODE: hTimewarp is null\n"
+ "%s: Inheritance Func: '%s' Not Exist\n"
+ "%s: Input wd %d addr %p bank %d"
+ "%s: IntFlashEnable: 0x%x, Ext: 0x%x\n"
+ "%s: Integration x Gain is too low, skip processing.\n"
+ "%s: Invalid startup delay for buck0"
+ "%s: Ip %lx wd %d ht %d addr %lx %lx-%lx %d"
+ "%s: LTM stats collected @ %#llx, src(%#08llx)."
+ "%s: Line: %d LED Register values: 0x%02x 0x%02x 0x%02x 0x%02x\n"
+ "%s: Linear gain is less than one"
+ "%s: Lookup id %#x module %#x:%c"
+ "%s: Lux: Off %d, Pre %d, Sel Pre %f, DiffPreAndOff %f, DiffMainAndOff %f, Main %f"
+ "%s: MCache Release Notification  (0x%x) returned from host with rc %d\n"
+ "%s: MCache Release Notification (0x%x) being sent to the host with streamid %d.\n"
+ "%s: MCache Request Notification  (0x%x) returned from host with rc %d\n"
+ "%s: MCache Request Notification (0x%x) being sent to the host with streamid %d and requested cachesize 0x%x.\n"
+ "%s: MCache Update Notification  (0x%x) returned from host with rc %d\n"
+ "%s: MCache Update Notification (0x%x) being sent to the host with streamid %d and updated cachesize 0x%x.\n"
+ "%s: Misc stat DONE @ %#llx"
+ "%s: Mode: 0x%02x Level: 0x%04x \n"
+ "%s: Mode: 0x%02x Level: 0x%04x, CstrNom: 0x%x \n"
+ "%s: NO IIR FILTER: clippingDiscontinuity=%u"
+ "%s: NOTHING TO DRAW => set 1"
+ "%s: No SIFR, clear adaptiveDR"
+ "%s: Nonvolatile storage device detected. "
+ "%s: Not Posting HighRes Results for fc %d"
+ "%s: Not able to catch up, dropping frames to AWB\n"
+ "%s: Not able to catch up, dropping frames to LSC (fullstats %s)!\n"
+ "%s: Not able to catch up, dropping frames to LSC!\n"
+ "%s: Not implemented"
+ "%s: Notification sent."
+ "%s: OA"
+ "%s: OB"
+ "%s: OBJECT BY NAME - handle : %p, name %s\n"
+ "%s: OUT:cfg %-2u PD%s (%#04x, %#04x) ll %.3fus slope %.3f"
+ "%s: One shot AF has been kicked off.\n"
+ "%s: Output buffer unAvailable."
+ "%s: Output buffer unavailable."
+ "%s: Output buffer unavailable.\n"
+ "%s: Output buffer unavailalbe."
+ "%s: Output image too small."
+ "%s: Parameters uninitialized, %s may not have FDR support!\n"
+ "%s: Parameters unitialized, %s may not have NVM support\n"
+ "%s: Percent current update. maxMainflashCurrentRatio: 0x%08x\n"
+ "%s: Power Control Notification  (0x%x) returned from host with rc %d\n"
+ "%s: Power Control Notification (0x%x) being sent to the host with Norm %d.\n"
+ "%s: Pri cfg %d exp %llu AG %d DG %d OG %d V %d"
+ "%s: Pri cfg %d exp %llu LG %d SG %d OG %d V %d"
+ "%s: Queue reset and clear IRQ"
+ "%s: READ (%#02x) -> Reg: %#02x num-bytes: %lu @ %f"
+ "%s: READ (%#02x) -> Reg: %#02x%02x num-bytes: %lu @ %f"
+ "%s: READ (%#02x) -> Reg: %#02x%02x num-bytes: %lu @ %f, "
+ "%s: READ (%#02x) -> Reg: %#04x num-bytes: %lu @ %f"
+ "%s: READ (%#02x) -> Val: 0x%s"
+ "%s: READ (%#02x) num-bytes: %lu @ %f"
+ "%s: ROOT GET - Root handle : %p\n"
+ "%s: RPC Call (%d) being sent to the host.\n"
+ "%s: RPC Call (%d) retured from host with rc %d\n"
+ "%s: Raw DMA Output buffer pool unavailable."
+ "%s: Raw DMA Output buffer unavailable."
+ "%s: Raw frame re-processing"
+ "%s: Re-send bufs to AF STAT0, ch=%ld, frames=%d\n"
+ "%s: Re-send bufs to PDAF, ch=%ld, frames=%d\n"
+ "%s: Reg Counter Notification %d being sent to the host.\n"
+ "%s: Reg Counter Notification (%d) returned from host with rc %d\n"
+ "%s: Replay frame (#%zu repeatIdx %zu)  [%d, %d]"
+ "%s: Replay started "
+ "%s: Replay stopped currRI %zu numFrame %zu currFI %zu"
+ "%s: ReplayFrameTrigger with vblank %d us @%f "
+ "%s: Report mRBWR=%d,mWBWR=%d,RTBandwidth=%d in 100MBps to PMP @ %f"
+ "%s: Req header %#08x"
+ "%s: Req pay_ld %#08x"
+ "%s: Requested Strobe Curr (per driver) 0x%x, val= %f A\n"
+ "%s: Requested Torch Current  val= %.1f mA\n"
+ "%s: Reset"
+ "%s: Reset\n"
+ "%s: Resp header %#08x"
+ "%s: Resp pay_ld %#08x"
+ "%s: Response match request! cmdId 0x%02x"
+ "%s: S-WRI (%#02x) -> Reg: 0x%s num-bytes: %lu @ %f"
+ "%s: S-WRI (%#02x) -> Val: 0x%s"
+ "%s: S-WRI (%#02x) -> num-bytes: %lu @ %f"
+ "%s: SB data size - DMA group 0: [%u %u], DMA group 1: [%u %u]\n"
+ "%s: SDP mode: 0x%X, AE SPD result: %u, Sec SPD: %u, Decimate SPD: %u, Lumi Out: %u, fc: %llu\n"
+ "%s: SET DEBUG LEVEL - FSM: %p [%s] - level = %d [before = %d]\n"
+ "%s: SET DEBUG LEVEL - object: %p - level = %d [before = %d]\n"
+ "%s: SET RECURSIVE DEBUG LEVEL - root: %p - level = %d\n"
+ "%s: SETUP"
+ "%s: SPD line length not found in config %d"
+ "%s: SPD off, new vW %d, vH %d, maxvH %d"
+ "%s: SPD on, new vW %d, vH %d, maxvH %d"
+ "%s: SPECIAL FN - object: %p - return = %llX \n"
+ "%s: START"
+ "%s: STOP"
+ "%s: Send AE update to Master %zu"
+ "%s: Send AE update to Slave %zu"
+ "%s: Sensitivity parameter uninitialized, %s may not have NVM support\n"
+ "%s: Sensor detected. Id: %d"
+ "%s: Set AEWindow[%d], x=%d, y=%d, w=%d, h=%d."
+ "%s: Set AFWindow[%d], x=%d, y=%d, w=%d, h=%d.\n"
+ "%s: Set AWBWindow[%d], x=%d, y=%d, w=%d, h=%d."
+ "%s: Set AWBWindow[%d], x=%d, y=%d, w=%d, h=%d.\n"
+ "%s: Set HiResAWBWindow[%d], x=%d, y=%d, w=%d, h=%d.\n"
+ "%s: Set HighResAWBWindow, ch=%zu, pipe=%u, id=%u, x=%d, y=%d, w=%d, h=%d.\n"
+ "%s: Shutter=%llu AG=%d DG=%d VSize=%d ev0Ratio=0x%x OG=%d"
+ "%s: Shutter=%llu LG=%d SG=%d TG=(%.1f) VSize=%d ev0Ratio=0x%x"
+ "%s: Sifr Linear gain is less than one"
+ "%s: Sifr exp %llu AG %d RDO %d spd %d eit %llu"
+ "%s: Sifr exp %llu LG %d RDO %d spd %d eit %llu"
+ "%s: Sifr=%d %d (%f), Shutter=%llu AG=%d DG=%d RDOffset=%d"
+ "%s: Sifr=%d %d (%f), Shutter=%llu LG=%d RDOffset=%d"
+ "%s: Slow sync integration %d us, onTime %d us margin %d\n"
+ "%s: Smoothing changed %d->%d"
+ "%s: Smoothing changed %d->%d\n"
+ "%s: Start slave streaming, v %d, exp %llu %ffps, status %d, ag %d\n"
+ "%s: Switch ADRC from %d to %d"
+ "%s: TEARDOWN"
+ "%s: TFCONFIG ch=%zu"
+ "%s: TIMEWARP rec=%d, smooth:%.3f Hz lock:%u"
+ "%s: TIMEWARP rec=%d, smoothing rate %.3f Hz"
+ "%s: TS: %f Blocking\n"
+ "%s: TS: %f Non-Blocking\n"
+ "%s: TS: %f Non-Blocking: bitfield: 0x%x\n"
+ "%s: TearDown! (%p)"
+ "%s: The destinations are busy (%#x) !"
+ "%s: Tile stat DONE @ %#llx"
+ "%s: Total V updated 0x%x\n"
+ "%s: Updated: bbox: %d,%d .. %d,%d"
+ "%s: Updated: sc=%d map_h=%d +capt_h=%d = line_h=%d "
+ "%s: WRITE (%#02x) -> Reg: %#04x num-bytes: %u @ %f"
+ "%s: WRITE (%#02x) -> Reg: %#04x num-bytes: %zu @ %f"
+ "%s: WRITE (%#02x) -> Reg: %#04x, Val: 0x%s num-bytes: %lu @ %f"
+ "%s: WRITE (%#02x) -> Val: 0x%s"
+ "%s: [%u us, %llu clk] gravity %f %f %f"
+ "%s: afTileStartX %d Y %d width (%d x %d)\n"
+ "%s: bUpdEIT %d = (%d %d %d %d %d), bUpdSet %d = (%d %d %d)"
+ "%s: bank%d Checksum validation result: %s"
+ "%s: baseLockEIT stored at %llu bias %d"
+ "%s: bypassing..."
+ "%s: ccroi %d,%d+%dx%d / tiles %u,%u+%ux%u => disp %u,%u+%ux%u"
+ "%s: ccroi in %%o:%d,%d+%dx%d  x sensor: %ux%u =>%d,%d+%dx%d"
+ "%s: cfg %u defect table %p, count %d, size %zu"
+ "%s: cfg %u, clk %llu, lnt %f, frmt %d, rdt %d\n"
+ "%s: ch %zu Set AFWindow[%d], x=%d, y=%d, w=%d, h=%d.\n"
+ "%s: ch %zu cnt %zu criticalReqCount %zu"
+ "%s: ch %zu decoupleStats %d\n"
+ "%s: ch %zu fc %d dbg01 Toggle bank %d pMetaDataBuf %p"
+ "%s: ch %zu manual AE ignored."
+ "%s: ch %zu share %d cnt %zu %zu"
+ "%s: ch %zu supports IFP mode"
+ "%s: ch %zu wait for all bufs available %zu/ %zu"
+ "%s: ch %zu, main frame %d processed, request 0x%x, bSkipped %d, out counter %d"
+ "%s: ch %zu, pStatsHdr->lrsEnabled %u masterCam %u, manualFlickerFreq %u, updateFlickerFreq %u"
+ "%s: ch %zu: cfg %u exceed max %zu"
+ "%s: ch%d, ic%lx"
+ "%s: ch:%zu LightSrcMask = %d \n"
+ "%s: ch:%zu fc:%d byte:%d EBD, reg - val: [0x%04X 0x%02X]\n"
+ "%s: ch=%zu, StrModEnableThreshold=%d, StrModDisableThreshold=%d"
+ "%s: ch=%zu, bANSTThumbnailEn=%d"
+ "%s: ch=%zu, bMSTFScale0En=%d"
+ "%s: ch=%zu, bMSTFScale0LightingCtrl=%d"
+ "%s: ch=%zu, bMSTFScale0StrModCtrl=%d"
+ "%s: ch=%zu, bMsBePYRScalerSupported=%d"
+ "%s: ch=%zu, bSMVAWBEn=%d"
+ "%s: ch=%zu, bSMVEn=%d"
+ "%s: ch=%zu, bSMVPeopleEn=%d, bSMVHairEn=%d, bSMVSkinEn=%d, bSMVSkyEn=%d"
+ "%s: ch=%zu, bStillCap=%d, fusionType=%d"
+ "%s: ch=%zu, bStillCap=%d, maxMSTFWidth=%d, maxMSTFHeight=%d"
+ "%s: cmdid %d deferrredack %d\n"
+ "%s: config=%u=> allow jump (while smooth=%u samplingRate=%.3f Hz)"
+ "%s: controller Notification  (%d) returned from host with rc %d\n"
+ "%s: controller Notification (%d) ch %d being sent to the host.\n"
+ "%s: copy flash setting from masterCamPreview %u to %zu. flashCapture %u\n"
+ "%s: created %p, base = %p"
+ "%s: created %p, id = %zu"
+ "%s: defect table %p, count %d, size %zu\n"
+ "%s: digScopeXSta: expected %u, actual %u"
+ "%s: digScopeXSta: expected %u, actual %u\n"
+ "%s: digScopeYSta: expected %u, actual %u"
+ "%s: digScopeYSta: expected %u, actual %u\n"
+ "%s: dropping AFE DMA output, FLD is running behind\n"
+ "%s: dropping AFE DMA output, PDAF is running behind\n"
+ "%s: en: %x\n"
+ "%s: en: 0x%x\n"
+ "%s: enter @ %llu\n"
+ "%s: exe Status is %d\n"
+ "%s: exp %d (%llu) totalV %d"
+ "%s: failed to configure frame rate: max (%d) is lower than configured min (%d)"
+ "%s: failed to configure frame rate: max configured (%d) is lower than min (%d)"
+ "%s: fc %d RV curr %.3f prev %.3f delta %.3f pred %.3f %d"
+ "%s: fc:%d sifDmaDst %d fepDst %d pRaw: %p srcBk:%d dstBk:%d"
+ "%s: ffwSema_WRN: wind %d, %d, %d x %d"
+ "%s: flickerFreq=%llu nextEIT=%lld avg=%d target=%d lux=%d"
+ "%s: fps: 0x%x, totalV: 0x%x\n"
+ "%s: frameCount=%d request=0x%x oneFrameAE=%d cntrs=(%d %d) spd=%d sus=%d stbl=%d llm=(%d %d)"
+ "%s: frameRate %d => use High Frame Rate AE preset."
+ "%s: frm#%d ag %x dg %d it %d fl %d, temp %f C @ %llu\n"
+ "%s: frm#%d ag %x dg %x it %d\n"
+ "%s: frm#%d ag 0x%04x dg 0x%04x it %d fl %d, temp %f C @ %llu\n"
+ "%s: gainAnal %d tmpGain %d, syncRatio %f, expRatio %f"
+ "%s: gains (%.3f %.3f) nextEITs (%llu %llu %llu)"
+ "%s: hI2C2: %p, i2c:0x%x \n"
+ "%s: hI2C2: %p, smbdrv: %p \n"
+ "%s: in vHDR mode, vHDR=%d, sifrEITRatio=%f"
+ "%s: index: %d\n"
+ "%s: index: %d, f: %d, chargePumpFreqTot: %d\n"
+ "%s: init vSizeLB to %d (Max of %d and %d), cfg %d mfrt %d spd %d"
+ "%s: input %f mA, regval %f\n"
+ "%s: input: eit %llu adrc eit %llu sg %d gr (%d, %d)"
+ "%s: inputAmps: 0x%04x, reg: 0x%x\n"
+ "%s: inputmAmps: 0x%08x, reg: 0x%x\n"
+ "%s: intFlash:%x extFlash:%x %f"
+ "%s: levels: 0x%08x.  maxFlashlightCurrent: %d mA\n"
+ "%s: linearGain %d tmpGain %d, syncRatio %f, expRatio %f"
+ "%s: maxDataRate[%d]= %lld freq %lld"
+ "%s: maxExp %d maxEITOfAllFrames %llu"
+ "%s: maxExp %d sifrL %d vSize %d vW %d"
+ "%s: maxExpTime set %u us ==> %llu (clk %d)."
+ "%s: maxMainflashCurr: 0x%08x,maxMainflashCurrRatio:0x%x\n"
+ "%s: minAGC=4 => use pano AE preset."
+ "%s: misc %d tile %d, thumbnail %d, localhist %d, fpns %d\n"
+ "%s: mode: %d, cct: %d, reg: 0x%x, tot: %6.2f cool:%d warm: %d \n"
+ "%s: mode: %d, reg: 0x%x \n"
+ "%s: new sifrTurnoff EIT %.4f sec (%llu clock cycles) for tbEntry %d."
+ "%s: new strobe/torch ratio (8.8): 0x%04x\n"
+ "%s: newBias %d, bias_targetEIT %d, bias_sceneB %d"
+ "%s: no space in the queue, command dropped!"
+ "%s: opMode %d set registerBank %d addr %lx"
+ "%s: orig strobe/torch ratio (8.8): 0x%04x\n"
+ "%s: output: adrc eit %llu adrc gain %d ==> updated sg %d"
+ "%s: overRide %d %d spdMode %d sifrOffEIT %llu sifrSkip %d"
+ "%s: pGenProcessInputParamBuffer == 0\n"
+ "%s: params.gyro:{stable<%.4f unstable>%.4f min interval=%.2fms}"
+ "%s: params.temp:{stable>%.1fms unstable<%.1fms maxStable=%.1fms}"
+ "%s: pendingCfg %d curr config %d totalH %d pending %d"
+ "%s: preMain exp=%llu xA %u xD %u; preSifr exp=%llu xA %u xD %u\n"
+ "%s: pri computed lg %d sg %d"
+ "%s: pri eit %llu exp %llu ag %d dg %d hg %d"
+ "%s: pri ofd %d gdAE %d sdg %d"
+ "%s: projector control skipped, frame #%d dropped"
+ "%s: reg 0x%x %dmA %s\n"
+ "%s: resistance %d temp %04f\n"
+ "%s: retries count: %d\n"
+ "%s: sampling rate changed %.2f Hz ->%.2f Hz"
+ "%s: search pos = %d, measurement = %lld"
+ "%s: secIdx=%d"
+ "%s: sensor state %d, nonce %02x%02x..., IV %02x%02x...LFSR %02x%02x..., index %d\n"
+ "%s: set TableEntry=%u"
+ "%s: setAESuspend %d, needToStore %d, baseLockEIT %llu, bias %d, bApplyBias %d %d"
+ "%s: sifr exp %llu ag %d dg %d dgs %d"
+ "%s: sifr exp %llu lg %d sg %d dgs %d"
+ "%s: sifrExposure max reduced from %d -> %d"
+ "%s: skip Preflash, this is manual."
+ "%s: targetEIT (%llu) clamped to (%llu)..."
+ "%s: temp %f\n"
+ "%s: text=%d nTiles=%d nBins=%d maxHeight=%u => scalemax=%u"
+ "%s: this = %p"
+ "%s: tiles in sensor RAW %d,%d+%ux%u"
+ "%s: traceBufferState %d (%d/%d)"
+ "%s: traceBufferState %d size(%d/%d)"
+ "%s: use extended ADRC range"
+ "%s: vFrame W+H %d, %d, maxVirtFrmHeight %d, splitPD %d"
+ "%s: ver 0x%08x"
+ "%s: weightedSumOfAFScores=%lld, sumOfWeights=%d, averageAFScore=%lld"
+ "%s: windowMode sceneAvg %d, winAvg %d"
+ "%s: xAddEnd: expected %u, actual %u"
+ "%s: xAddEnd: expected %u, actual %u\n"
+ "%s: xAddSta: actual %u\n"
+ "%s: xAddSta: expected %u\n"
+ "%s: xAddSta: expected %u, actual %u"
+ "%s: yAddEnd: expected %u, actual %u"
+ "%s: yAddEnd: expected %u, actual %u\n"
+ "%s: yAddSta: expected %u, actual %u"
+ "%s: yAddSta: expected %u, actual %u\n"
+ "%s: zero gain values in meta data (%d, %d, %d, %d, %d)!"
+ "%s:%d"
+ "%s:%s"
+ "%s:%s Response queue empty"
+ "%s:%s ch %d %s\n"
+ "%s::%s delay: %f, onTime: %f\n"
+ "%s::%s(): section: %d; enable? %c\n"
+ "%s:DONE TS: %f rail: 0x%x, ch: %x\n"
+ "%s:Done@ %llu, st@ %llu, delta %lldms, reqTm %d, FR %d\n"
+ "%s:RV RV %f Prev FV %f fc %d syncedCams %d preB %d br %d fl %d"
+ "%s:START TS: %f rail: 0x%x\n"
+ "%s:Trace to Post returned from host"
+ "%s:[%lld] timer set (%d)ms traceBufferState %d size(%d/%d)"
+ "%s:[%lld] traceFlushSema is up traceBufferState %d size(%d/%d)"
+ "%s:bg"
+ "%s:cfg %u spd err: lumiW %u roi %u %u,SF %u\n"
+ "%s:cfg %u spd err: lumiW %u roi %u %u,SF %u B %u\n"
+ "%s:cfg %u spd err: lumiW %u roi %u %u,SF %u qB %u\n"
+ "%s:cfg %u spd err: lumiW %u roi %u %u,SF %u qB %u B %u\n"
+ "%s:f# %u cfg %u spd err: w %u h %u, LS(%u %u) roi (%u %u %u %u) total %u\n"
+ "%s:frame(%f) slave line %f master %f\n"
+ "%s:hab"
+ "%s:in"
+ "%s:post message bufferState(%d) size(%d/%d)"
+ "%s:prv"
+ "%s:sq"
+ "%s:var"
+ "%s[%d]: %x %d\n"
+ "%s[%zu]: AWB%d finished!"
+ "%s[%zu]: Gains for main flash\n            1st RGGB: %#X, %#X, %#X, %#X, Req: %#X"
+ "%s[%zu]: Yn_str %d, Ynl_str %d, Yoff %d"
+ "%u vs %u"
+ "%zu\t\t set gA 0x%x skipratio %d curr %d\n"
+ "%zu %s Switching Dst Banks at fc:%d bank:%d sifDMA:%zx"
+ "%zu %s Switching Src Banks at fc:%d bank:%d"
+ "%zu %s currFC:%d PDFC:%llu PPFC:%llu sifEnCurr:%d sifEnNxt:%d"
+ "%zu %s fc:%d destEn:0x%x stat:%s sifr:%d srcBk:%d dstBk:%d"
+ "%zu <= %d"
+ "%zu Prepare %s frm %d currFrm:%d srcBk:%d dstBk:%d sM:%d sEn:%d"
+ "%zu Prepare FC:%llu in FC:%d sifrEN:%d"
+ "%zu Replay requested"
+ "%zu dmamode %d %p csRaw %p intCollectedDMA 0x%x 0x%x\n"
+ "%zu fc:%d %s dstBank:%d SS:%d SSE:%d"
+ "%zu perCfg %d %d sensorRO %d %d dig %d %d st %d %d end %d %d"
+ "%zu: BufPool id %zu, width %u height %u stride %u cntxBit:%x"
+ "%zu: Buffers for fc:%d [m:%d s:%d fep:%d fepS:%d]"
+ "%zu:Buf %p,(%zu > %zu) %d %d"
+ "(!enableFPX && !enableFPC) || (!pdafSensor) || ((pMetaData->binW > 0) && (pMetaData->binH > 0))"
+ "(!in420) || (in420 == out420)"
+ "(!pMetaData->spd.enabled || (pMetaData->spd.width % 2 == 0))"
+ "(%d %d %u %u)"
+ "(%dx%d)<=vio max i/p, dwnsclfactor:%d, org dwnsclfactor:%d"
+ "(%dx%d)<=vio max i/p, no need to dwnscl despite factor:%d"
+ "(%s) %s\n"
+ "(((*(volatile uint32_t *)(((size_t)((((0 == 0) ? 0x323aa8000 : 0xbad00001) + 0x00004000))) + (size_t)(0))) >> 1) & 0x00000001) == 0"
+ "(((size_t)(blockArray[dBlock])) % alignment[dBlock]) == 0"
+ "(((size_t)(pCurPrintPtr)) + logSpaceLetf) == (((size_t)(pSharedMemory)) + sharedMemorySize)"
+ "(((splitPDMetadata->paddedLineSize) & ((64)-1)) == 0)"
+ "(((splitPDMetadata->totalSize+63)&(~((1<<6) -1 ))) + ((576) * (200)) + sizeof(struct sMetaSplitPD)) <= ((CBuffer*) ((m_inputFrame)->inputsBuffers)[((0))])->Size() - metadata->splitPDBufOffset"
+ "((1 << inputChannel)) & m_supportedChannels"
+ "((CBuffer*) ((frame)->inputsBuffers)[((0))]) != nullptr"
+ "((afeRect.start.x - sensorDescr.focusGrid.startX) % sensorDescr.focusGrid.spacingX) == 0"
+ "((afeRect.start.y - sensorDescr.focusGrid.startY) % sensorDescr.focusGrid.spacingY) == 0"
+ "((bracketingCaptureCountNextStart - bracketingCaptureCountStart) % 2) == 0"
+ "((cfgNum < configTot) || ((int)cfgNum == -1))"
+ "((configIdx < 0) ? 0 : (uint32_t)configIdx) < m_sensorConfigsTot"
+ "((crops[k].start.x - sensorDescr.focusGrid.startX) % sensorDescr.focusGrid.spacingX) == 0"
+ "((crops[k].start.y - sensorDescr.focusGrid.startY) % sensorDescr.focusGrid.spacingY) == 0"
+ "((fpnMgr->GetCorrectionImageHeight(ch) - pDescr->paramRaw.inHeight) % 16) == 0"
+ "((index + (comps * entries) + 2) * sizeof(uint32_t)) <= bufSize"
+ "((metadata->masterCamPreview) && (inputChannel == m_primaryCamCh)) || ((!metadata->masterCamPreview) && (inputChannel == m_secondaryCamCh))"
+ "((pFDInputCmd->width * pFDInputCmd->height) % 8) == 0"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L61_REG16_LEN_BYTE) == sizeof(CS40L61_MODE00_AOR_G0a_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L61_REG16_LEN_BYTE) == sizeof(CS40L61_MODE00_AOR_G0b_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L61_REG16_LEN_BYTE) == sizeof(CS40L61_MODE00_AOR_G0c_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L61_REG16_LEN_BYTE) == sizeof(CS40L61_MODE00_AOR_G1_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L61_REG16_LEN_BYTE) == sizeof(CS40L61_MODE00_AOR_G2_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L61_REG16_LEN_BYTE) == sizeof(CS40L61_MODE00_AOR_G3a_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L61_REG16_LEN_BYTE) == sizeof(CS40L61_MODE00_AOR_G3b_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L61_REG16_LEN_BYTE) == sizeof(CS40L61_MODE00_AOR_G3c_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L61_REG16_LEN_BYTE) == sizeof(CS40L61_MODE00_AOR_G3d_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L61_REG16_LEN_BYTE) == sizeof(CS40L61_MODE00_AOR_G4a_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L61_REG16_LEN_BYTE) == sizeof(CS40L61_MODE00_AOR_G4b_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L61_REG16_LEN_BYTE) == sizeof(CS40L61_MODE00_AOR_G5a_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L61_REG16_LEN_BYTE) == sizeof(CS40L61_MODE00_AOR_G5b_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L61_REG16_LEN_BYTE) == sizeof(CS40L61_MODE00_AOR_G6a_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L62_REG16_LEN_BYTE) == sizeof(CS40L62_MODE00_AOR_G0a_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L62_REG16_LEN_BYTE) == sizeof(CS40L62_MODE00_AOR_G1_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L62_REG16_LEN_BYTE) == sizeof(CS40L62_MODE00_AOR_G2a_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L62_REG16_LEN_BYTE) == sizeof(CS40L62_MODE00_AOR_G3a_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L62_REG16_LEN_BYTE) == sizeof(CS40L62_MODE00_AOR_G3b_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L62_REG16_LEN_BYTE) == sizeof(CS40L62_MODE00_AOR_G4_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L62_REG16_LEN_BYTE) == sizeof(CS40L62_MODE00_AOR_G5_Type)"
+ "((pGroupParams->addrEnd - pGroupParams->addrStart + 1) * CS40L62_REG16_LEN_BYTE) == sizeof(CS40L62_MODE00_AOR_G6a_Type)"
+ "((pVISLTM->ltm.ltmGridStride & 63) == 0) && \"LTM grid stride violation\""
+ "((pattern.grid.startX - vStartX) % vIntX) == 0"
+ "((size_t)((((264) - sizeof(struct ffwMsgHeader)) - (((264) - sizeof(struct ffwMsgHeader)) - (sizeof(size_t) + ((20) * sizeof (class CBuffer *)))) + ((buffRef->size))))) <= sizeof((((&msg)))->payload)"
+ "((size_t)((((264) - sizeof(struct ffwMsgHeader)) - (((264) - sizeof(struct ffwMsgHeader)) - (sizeof(size_t) + ((20) * sizeof (class CBuffer *)))) + ((buffRef->size))))) <= sizeof((((&msgAWB)))->payload)"
+ "((size_t)((((264) - sizeof(struct ffwMsgHeader)) - (((264) - sizeof(struct ffwMsgHeader)) - (sizeof(size_t) + ((20) * sizeof (class CBuffer *)))) + ((buffRef->size))))) <= sizeof((((&msgFOD)))->payload)"
+ "((size_t)((((264) - sizeof(struct ffwMsgHeader)) - (((264) - sizeof(struct ffwMsgHeader)) - (sizeof(size_t) + ((20) * sizeof (class CBuffer *)))) + ((buffRef->size))))) <= sizeof((((&msgLSC)))->payload)"
+ "((size_t)((((264) - sizeof(struct ffwMsgHeader)) - (((264) - sizeof(struct ffwMsgHeader)) - (sizeof(size_t) + ((20) * sizeof (class CBuffer *)))) + ((buffRef->size))))) <= sizeof((((&msgSIFR)))->payload)"
+ "((size_t)((((264) - sizeof(struct ffwMsgHeader)) - (((264) - sizeof(struct ffwMsgHeader)) - (sizeof(size_t) + ((20) * sizeof (class CBuffer *)))) + ((buffRef->size))))) <= sizeof((((isSifrFrame ? &msgSIFR : &msg)))->payload)"
+ "((size_t)((((264) - sizeof(struct ffwMsgHeader)) - (((264) - sizeof(struct ffwMsgHeader)) - (sizeof(size_t) + ((20) * sizeof (class CBuffer *)))) + ((size))))) <= sizeof((((&msg)))->payload)"
+ "((size_t)((((264) - sizeof(struct ffwMsgHeader)) - (((264) - sizeof(struct ffwMsgHeader)) - (sizeof(size_t) + ((20) * sizeof (class CBuffer *)))) + (size)))) <= sizeof(((&msg))->payload)"
+ "((size_t)(((resources.dataCount * sizeof(uint8_t))))) <= sizeof((((&msg)))->payload)"
+ "((size_t)(pCurPrintPtr)) >= ((size_t)(pSharedMemory))"
+ "((size_t)addr % 64) == 0"
+ "((size_t)addr & 0x3F) == 0"
+ "((size_t)addr & 0x7F) == 0"
+ "((size_t)address % 64) == 0"
+ "((size_t)afTileDstAddr % 64) == 0 && afTileDstAddr != 0"
+ "((size_t)configNumber) < configTot"
+ "((size_t)dataSize % 8) == 0"
+ "((size_t)miscDstAddr % 64) == 0 && miscDstAddr != 0"
+ "((size_t)pPatchWarpOpMem + sharedMemSize) <= (size_t)pOpMemUpperBound"
+ "((size_t)pStatBuff->globalHist2Stat + (HITH_GLOBAL_HISTOGRAM2_BIN * sizeof(uint32_t))) <= ((size_t)hithStatBuf->DataPointer() + hithStatBuf->Size())"
+ "((size_t)pointer) < ((size_t)(h->pMsg)) + h->queueDepth * sizeof(struct ffwInterProcMsg)"
+ "((size_t)pointer) >= ((size_t)(h->pMsg))"
+ "((size_t)statsFEThumbDstAddr % 64) == 0 && statsFEThumbDstAddr != 0"
+ "((size_t)stride & 0x3F) == 0"
+ "((size_t)tileDstAddr % 64) == 0 && tileDstAddr != 0"
+ "((startX & 0x7) == 0) && ((endX & 0x7) == 0)"
+ "((struct sCIOObjectChCmdHdr *)extra)->immediate == true"
+ "((struct sCIspMetaDataShared *)((void*) ((CBuffer*) (((frame)->inputsBuffers))[(((2)))])->DataPointer())) != nullptr"
+ "((sums[0] == 256) && (sums[1] == 0) && (sums[2] == 0)) || ((sums[0] == 0) && (sums[1] == 256) && (sums[2] == 0)) || ((sums[0] == 0) && (sums[1] == 0) && (sums[2] == 256))"
+ "((tileCount - 1) * tileSize < sensorRect.size).all()"
+ "((uint32_t)miredLutIn[i]) < (1 << 18)"
+ "((uint32_t)miredLutOut[i]) < (1 << 18)"
+ "((uint8_t*)pPatchDma + (((widthDma + 63) >> 6) << 6)*heightDma) < pRes->chCtx[chId].CtxMemUpperBound"
+ "((uintptr_t)entry->stack & (RTK_CRT_STACK_ALIGNMENT - 1)) == 0"
+ "((void*) ((CBuffer*) (((frame)->inputsBuffers))[(((0)))])->DataPointer()) != nullptr"
+ "(*netOutput).height >= kOutputCount"
+ "(*pFifoOccu) >= pCurReq->fifoByteSize"
+ "(*parent == logDepth) || (*parent == index)"
+ "(*parent == logDepth) || (*parent == pEntry->parent)"
+ "(-2048 <= coeff) && (coeff < +2048)"
+ "(0 == packNbr) && (0 == pioSizeInDW)"
+ "(0x%04x), cool: 0x%x, warm: 0x%x"
+ "(0x%04x), cool: 0x%x, warm: 0x%x, torLEDC[0]: %d, torLEDC[1]: %d "
+ "(0xFFFF - *pFifoOccu) >= pElem->fifoByteSize"
+ "(CSystemConfigurator::GetDPCDefectPixelCount(pCmd->ch)*sizeof(uint32_t)) >= pCmd->size"
+ "(FFWMUTEX)0 != lock"
+ "(FFWMUTEX)0 != mutex"
+ "(FFWMUTEX)0 != staticCountLock"
+ "(GetTMPreviewMaster(ch) == masterCh) || IsSyncGroupInMSSwitch(ch)"
+ "(IOP_RINGBUFFER_VERSION == (pBuf->_header._version>>16)) || (IOP_RINGBUFFER_VERSION_V2 == (pBuf->_header._version>>16))"
+ "(NULL != traceBuffer_1) && (NULL != traceBuffer_2)"
+ "(PDAF::PixelEngine::CORR_SHIFTMAX % profileUpsampling) == 0"
+ "(SEMA)0 != cmd.syncCmdSema"
+ "(SEMA)0 != syncCmdDoneSema_"
+ "(SEMA)NULL != pRequest->sem"
+ "(SEMA)NULL == pCmd->sem"
+ "(activeTMSyncGroup[groupID].chStartedCount) || (activeTMSyncGroup[groupID].startedChMask == 0)"
+ "(activeTMSyncGroup[groupID].syncChMask >> ch) & 0x01"
+ "(afeProcDmaEn & FLOWH17_DMA_ID_BIT_MASK(AfeProcAFEDmaDst0))"
+ "(afeProcDmaEn & FLOWH17_DMA_ID_BIT_MASK(AfeProcAFEDmaDst1))"
+ "(afeProcDmaEn & FLOWH17_DMA_ID_BIT_MASK(AfeProcAFEDmaDst2))"
+ "(afeRect.size.x % sensorDescr.focusGrid.spacingX) == 0"
+ "(afeRect.size.y % sensorDescr.focusGrid.spacingY) == 0"
+ "(auto): torchOn=%d => ignored cct=%d"
+ "(avgBrightnessSize.numTilesX * avgBrightnessSize.numTilesY) == (AE_YMAP_TILES_X * AE_YMAP_TILES_Y)"
+ "(awbScheme == AWB_SCHEME_2D_HISTOGRAM) || (awbScheme == AWB_SCHEME_GRAYWORLD) || (awbScheme == AWB_SCHEME_TAP_TO_WB) || (awbScheme == AWB_SCHEME_MANUAL_WB)"
+ "(bankSeqStatus == PERIDOT_BANK_SEQ_STATUS_WAITING_FSYNC) || (bankSeqStatus == PERIDOT_BANK_SEQ_STATUS_END_OF_SEQUENCE)"
+ "(bayerProcDmaEn & FLOWH17_DMA_ID_BIT_MASK(BayerProcHRDmaSrc)) ? pAlgBuf->bufferHr != NULL : 1"
+ "(bayerProcDmaEn & FLOWH17_DMA_ID_BIT_MASK(BayerProcLSCDmaSrc) ? pAlgBuf->bufferLsc != NULL : 1)"
+ "(bayerProcDmaEn & FLOWH17_DMA_ID_BIT_MASK(BayerProcLSCDmaSrc)) ? pAlgBuf->bufferLsc != NULL : 1"
+ "(bracketingCaptureCountNextStart - bracketingCaptureCountStart) <= 2"
+ "(bracketingCaptureCountNextStart - bracketingCaptureCountStart) == 1"
+ "(bufList[i]->stride * bufList[i]->height + (uint8_t *)bufList[i]->baseAddr) < maxDmaAddr[i]"
+ "(bufList[i]->width * bufList[i]->height + (uint8_t *)bufList[i]->baseAddr) < maxDmaAddr[i]"
+ "(bwrTimerValue != 0) ? 0 : 1"
+ "(cacheSize % sizeof(uint32_t)) == 0"
+ "(callback == NULL) || (user_signal == 0)"
+ "(cellCountXH == 0) || (cellCountXH == (signed)geometry.roi.cellCountX)"
+ "(cellCountXV == 0) || (cellCountXV == (signed)geometry.roi.cellCountX)"
+ "(cfg.config.numPatch > 0) && (cfg.config.numPatch <= CISP_GENERAL_PROCESS_PW_MAX_PATCH_SIZE)"
+ "(cfg.cropHeight + cfg.res.yCropStart) <= cfg.inputHeight"
+ "(cfg.cropWidth + cfg.res.xCropStart) <= cfg.inputWidth"
+ "(cfg.desMatch.inputWidth & 1) == 0"
+ "(cfg.inputWidth & 1) == 0"
+ "(ch != IR_CAM_CH && ch != DEPTH_CAM_CH)"
+ "(ch < CAE_MAX_CAM_TOT) && (ch >= 0)"
+ "(ch < CAWB_MAX_CAM_TOT) && (ch >= 0)"
+ "(ch < CISP_CH_TOT && ch >= 0) || ch == lc::ALL_CHANNELS"
+ "(ch < ISP_CAMERA_CHANNEL_TOT) && obj"
+ "(ch < totVCs) && ((master3ACh == (size_t)~0) || (master3ACh < totVCs))"
+ "(ch < totVCs) && ((masterCh == (size_t)~0) || (masterCh < totVCs))"
+ "(ch < totVCs) && (index < totMultiChannels)"
+ "(ch < totVCs) && pLpdp"
+ "(ch == (1) && isMaster) || (ch == (4) && (!isMaster)) || (ch == (0))"
+ "(chDescr->croppedRectScaler[scaler].x + chDescr->croppedRectScaler[scaler].width) <= chDescr->croppedRect.width"
+ "(chDescr->croppedRectScaler[scaler].y + chDescr->croppedRectScaler[scaler].height) <= chDescr->croppedRect.height"
+ "(clrProcDmaEn & FLOWH17_DMA_ID_BIT_MASK(ClrProcDmaDstLuma))"
+ "(clrProcDmaEn & FLOWH17_DMA_ID_BIT_MASK(ClrProcHPPDmaSrc)) ? pAlgBuf->bufferHpp != NULL : 1"
+ "(clrProcDmaEn & FLOWH17_DMA_ID_BIT_MASK(ClrProcLCcmDmaSrc)) ? pAlgBuf->bufferLtmSccm != NULL : 1"
+ "(clrProcDmaEn & FLOWH17_DMA_ID_BIT_MASK(ClrProcLTMDmaSrc) ? pAlgBuf->bufferLtmLtc != NULL : 1)"
+ "(clrProcDmaEn & FLOWH17_DMA_ID_BIT_MASK(ClrProcLTMDmaSrc)) ? pAlgBuf->bufferLtmLtc != NULL : 1"
+ "(clrProcDmaEn & FLOWH17_DMA_ID_BIT_MASK(ClrProcMThDmaSrc)) ? pAlgBuf->bufferMthSemanticMap != NULL : 1"
+ "(clrProcDmaEn & FLOWH17_DMA_ID_BIT_MASK(ClrProcSTFWMDmaSrc)) ? pAlgBuf->bufferStfWeightMap != NULL : 1"
+ "(colorCalRgGain != 0) && (colorCalBgGain != 0)"
+ "(crops[k].size.x % sensorDescr.focusGrid.spacingX) == 0"
+ "(crops[k].size.y % sensorDescr.focusGrid.spacingY) == 0"
+ "(currRequestId + _updateDelay[aeRequestType]) <= requestUpdate.requestId"
+ "(currSetting->hr.downSampleX >> secondaryExtraBinW) == sifrDownSampleX"
+ "(currSetting->hr.downSampleY >> secondaryExtraBinH) == sifrDownSampleY"
+ "(cvPipeId ? pPplInfo->bufOutCVPipe1 : pPplInfo->bufOutCVPipe0)->Size() != 0"
+ "(cvdCfg->desMatch.inputWidth & 1) == 0"
+ "(dataLen > 0) && (dataLen <= sizeof(data))"
+ "(dataSize % 4) == 0"
+ "(depthData->stride & 1) == 0"
+ "(depthRegPool + depthDBRegPool) >= 28"
+ "(dest == ISP_RESOURCE_EXCLAVE_VC_PIPELINE_1) || (dest == ISP_RESOURCE_EXCLAVE_VC_PIPELINE_2)"
+ "(deviceID[2] & CS40L61_DEVICE_REVISION_ID_MASK) == CS40L61_DEVICE_REVISION_ID"
+ "(deviceID[2] & CS40L62_DEVICE_REVISION_ID_MASK) == CS40L62_DEVICE_REVISION_ID"
+ "(eUseCase < AE_MULTICH_TOTAL) && (eUseCase >= AE_MULTICH_DEFAULT)"
+ "(eUseCase < AWB_MULTICH_TOTAL) && (eUseCase >= AWB_MULTICH_DEFAULT)"
+ "(endX % 2) == 0"
+ "(endX & 1) == 0"
+ "(endXY.f.EndX % 4) == 0"
+ "(endXY.f.EndX - startXY.f.StartX) % 16 == 0"
+ "(endXY.f.EndY % 4) == 0"
+ "(endXY.f.EndY - startXY.f.StartY) % 16 == 0"
+ "(endY % 2) == 0"
+ "(extraX / 2) <= startX"
+ "(extraX/2) <= startX"
+ "(ffwQueueCount (queue) == 0) || (((size_t) ffwQueueCount (queue)) == buffers)"
+ "(firstSetBit - 1) < AE_REQ_TOT"
+ "(focusTileSize.x % step.x) == 0"
+ "(focusTileSize.y % step.y) == 0"
+ "(frameSizeX == extraInfo.imageWidth)"
+ "(frameSizeY == extraInfo.imageHeight ) || (frameSizeY == extraInfo.imageHeight >> 1)"
+ "(freq * 1000000) <= ISP_PIPELINE_CLOCK"
+ "(freq * 1000000) >= ISP_PIPELINE_CLOCK_VMIN"
+ "(g0a.STATIC_CFG_b.inner_loop_rate == CS40L61_MODE00_AOR_STATIC_CFG_INNER_LOOP_RATE_2P5_KHZ) || (g0a.STATIC_CFG_b.inner_loop_rate == CS40L61_MODE00_AOR_STATIC_CFG_INNER_LOOP_RATE_5P0_KHZ)"
+ "(gpio == ALDAST_GPIO_BUCK0) || (gpio == ALDAST_GPIO_BUCK1)"
+ "(id < MAX_SIFQ_USERS) && (sifQueueClients[id] != 0)"
+ "(id < MAX_SIFQ_USERS) && (sifQueueClients[id] == 0)"
+ "(id >= ISPHWH17DMAId_AISPDMA_PIPE_MsFeProcWarpDmaSrcA && id <= ISPHWH17DMAId_AISPDMA_PIPE_MsFeProcWarpDmaSrcF) || (id >= ISPHWH17DMAId_AISPDMA_PIPE_PyrOutProcDmaDstA1 && id <= ISPHWH17DMAId_AISPDMA_PIPE_PyrOutProcDmaDstF1)"
+ "(in[i] >= -65536) && (in[i] <= 65535)"
+ "(index + runLength + 3) * sizeof(uint32_t) <= bufSize"
+ "(index > 2) && (index < ACI_BE_VIRTUAL_CHANNEL_PACKET_TYPE_COUNT_MAX)"
+ "(index >= 0) && (index < LPDP2ACI_SHIM_GEN_LONG_PKT_COUNT_MAX)"
+ "(index) < sizeof(lt_offset)/sizeof(lt_offset[0])"
+ "(index) < sizeof(lutSensorInterfaceQueue)/sizeof(lutSensorInterfaceQueue[0])"
+ "(input.sizeX % 2) == 0"
+ "(input.sizeY % 2) == 0"
+ "(input.startX % 2) == 0"
+ "(input.startY % 2) == 0"
+ "(inputHeight * outStride) <= pCapturedFrame->Size()"
+ "(inputHeight * outStride) <= pSifrCapturedFrame->Size()"
+ "(inputs > 0) || (outputs > 0)"
+ "(int) config->thumbnailRect.start_x >= HITHStatROI->x"
+ "(int) config->thumbnailRect.start_y >= HITHStatROI->y"
+ "(int16_t)index < (int16_t)NUM_ELEMENTS(IMX591_ALPDP_Freq)"
+ "(int32_t)value <= 100000 && (int32_t)value >= -100000"
+ "(leftUpperCornerAlignFlag+rightUpperCornerAlignFlag+leftLowerCornerAlignFlag+rightLowerCornerAlignFlag) == 1"
+ "(lumiWidth % 2 == 0)"
+ "(lutX < iWidth)"
+ "(lutX < widthDma)"
+ "(lutY < heightDma)"
+ "(lutY < iHeight)"
+ "(mEventCnt + 1) < mMaxEvents"
+ "(m_outputDxBuffer != nullptr)"
+ "(m_outputDxBuffer != nullptr) != (m_debugMode == true)"
+ "(m_outputScaledLeftBuffer != nullptr)"
+ "(m_outputScaledRightBuffer != nullptr)"
+ "(m_outputScoreBuffer != nullptr)"
+ "(maxGain[i] <= 65535)"
+ "(maxLineLength % 4) == 0"
+ "(metadata->sensorQuadraBinFactor <= 2)"
+ "(minGain[i] >= -65536) && (minGain[i] <= 65535)"
+ "(minVal[i] >= -65536) && (minVal[i] <= 65535)"
+ "(min[i] >= -65536) && (min[i] <= 65535)"
+ "(ml.tiles[rId].subsetSensorRect.size >= 0).all()"
+ "(ml.tiles[rId].subsetSensorRect.start >= 0).all()"
+ "(ml.tiles[rId].tileCount >= 0).all()"
+ "(msg.hdr.data0 & FFWMSG_TYPE_MASK) == FFWMSG_TYPE_DATA"
+ "(new_end & HEAP_OFFSET) == 0"
+ "(nowGPMemoryOffset + (stride+64) * height) < gpBufSize"
+ "(num >= (int)ARRAY_SIZE(defaultModeLutC51)) && pLUT"
+ "(numPass == 1) || (numPass == 2)"
+ "(nvmGain != nullptr) == (nvmXtalk != nullptr)"
+ "(offset + (NbrOfValue << 2)) <= maxOffset"
+ "(offset + size) <= nvmDataSize"
+ "(offset - (CVD_BASE_ADDR(0) - AISP_BASE_ADDR(0)) + (NbrOfValue << 2)) <= CVD_REGION_LENGTH"
+ "(offsetC & 0x1) == 0"
+ "(offsetVal[i] >= -16777216) && (offsetVal[i] <= 16777215)"
+ "(offsetX % 2) == 0"
+ "(offsetY % 2) == 0"
+ "(offset[i] >= -16777216) && (offset[i] <= 16777215)"
+ "(operation == LOG_OPERATION_WIRED) || (operation == LOG_OPERATION_UNWIRED)"
+ "(out[i] >= -65536) && (out[i] <= 65535)"
+ "(outputPipe[OutputPin(CPDEPROC_CHANNEL_SECURE, CPDEPROC_OUT_PORT_0, CPDEPROC_OUTPUT_SECURE_MODE_SIGNALING)]) != nullptr"
+ "(outputWidth%8)==0 && (outputHeight%8)==0"
+ "(pChInfo->awbData.frameCount == pMetaData->frameCount) || (pMetaData->syncTag.msEnabled && (pChInfo->awbData.syncTag == pMetaData->syncTag.tag))"
+ "(pCmd->hdr.id == CISP_CMD_CH_OUTPUT_CONFIG_SET && pSetCamOutConfig->width <= CSystemConfigurator::Instance()->GetMaxSysImageWidth()) || (pCmd->hdr.id == CISP_CMD_CH_OUTPUT_CONFIG_SCL1_SET && pSetCamOutConfig->width <= CSystemConfigurator::Instance()->GetMaxSysImageWidth())"
+ "(pCmd->pBufIndex[i] & ~maskRemapIndex) < sizeof(endPointCb[pCmd->endPointId].shareMem.remap)/sizeof(endPointCb[pCmd->endPointId].shareMem.remap[0])"
+ "(pCmd->pBufIndex[i]) < sizeof(endPointCb[pCmd->endPointId].shareMem.item)/sizeof(endPointCb[pCmd->endPointId].shareMem.item[0])"
+ "(pCmd->size / sizeof(struct sRawProcDPCDefect)) <= CSystemConfigurator::GetDPCDefectPixelCount(pCmd->ch)"
+ "(pDescr->hClrDrv->IsCLUTBypass() == true) || (goc2Gains[0] == (1 << CLRPROC_GOC_GAIN_BIT_DEPTH))"
+ "(pDescr->paramRaw.bFPNRRBCEnabled + pDescr->paramRaw.bFPNRFrameEnabled + pDescr->paramRaw.bFPNRTileEnabled) <= 1"
+ "(pDescr->paramRaw.fpnrDataSize%64 == 0)"
+ "(pDescr->paramRaw.sensorReadOutCropRect.height / preISPDownsizeRatio) >= pDescr->paramRaw.inHeight"
+ "(pDescr->paramRaw.sensorReadOutCropRect.width / preISPDownsizeRatio) >= pDescr->paramRaw.inWidth"
+ "(pDualColorReCal->cc_Revision) == 1"
+ "(pFDInputCmd->height & 0x1) == 0"
+ "(pFDInputCmd->width & 0x1) == 0"
+ "(pLoc_offset[0] + inputNumPoints * 2) < VisSDetMaxNumOfKeyPoints"
+ "(pMeta->primIOBufferValidMark & (0x1UL << GPISP_GC_PRIMITIVE_TAHITI_CVDALL_IO_BUFFER_ID_DESMATCH_INPUT)) == 0"
+ "(pMetaData->SIFRBinFactorFullBinMode <= 1)"
+ "(pMetaData->SIFRBinFactorFullBinMode == 1)"
+ "(pParams->stride.rgbPlanar.b % CDSControllerBase::outputStrideDivider[2]) == 0"
+ "(pParams->stride.rgbPlanar.g % CDSControllerBase::outputStrideDivider[1]) == 0"
+ "(pParams->stride.rgbPlanar.r % CDSControllerBase::outputStrideDivider[0]) == 0"
+ "(pParams->stride.yOnly.y % CDSControllerBase::outputStrideDivider[0]) == 0"
+ "(pParams->stride.yuv420SemiPlanar.uv % CDSControllerBase::outputStrideDivider[1]) == 0"
+ "(pParams->stride.yuv420SemiPlanar.y % CDSControllerBase::outputStrideDivider[0]) == 0"
+ "(pParams->stride.yuv422.yuv % CDSControllerBase::outputStrideDivider[0]) == 0"
+ "(pPicTileInfo->tileCount & 0xFF) == 1"
+ "(pReq->sourceGoReq & mask) != 0"
+ "(pRes->chCtx[chId].pPatchWarpDstBuf + oPatchWidth * countHorPatch * oPatchHeight * countVerPatch)< pRes->chCtx[chId].CtxMemUpperBound"
+ "(pRes->visSDetOpCfg.desgen.paredNumBlocks[0].X *pRes->visSDetOpCfg.desgen.paredNumBlocks[0].Y) < kVisSDetMaxNumOfKeyPointsTotal"
+ "(pResource->primIOBufferMark & (0x1UL << GPISP_GC_PRIMITIVE_TAHITI_CVDALL_IO_BUFFER_ID_DESGEN_INPUT)) != 0"
+ "(pResource->primIOBufferMark & (0x1UL << GPISP_GC_PRIMITIVE_TAHITI_CVDALL_IO_BUFFER_ID_ITCM)) != 0"
+ "(pResource->primIOBufferMark & (0x1UL << GPISP_GC_PRIMITIVE_TAHITI_CVDALL_IO_BUFFER_ID_RMA0_INPUT)) != 0"
+ "(pResource->primIOBufferMark & (0x1UL << GPISP_GC_PRIMITIVE_TAHITI_CVDALL_IO_BUFFER_ID_RMA1_INPUT)) != 0"
+ "(pResource->primIOBufferMark & (0x1UL << GPISP_GC_PRIMITIVE_TAHITI_CVDALL_IO_BUFFER_ID_RMA2_INPUT)) != 0"
+ "(pResource->primIOBufferMark & (0x1UL << GPISP_GC_PRIMITIVE_TAHITI_CVDALL_IO_BUFFER_ID_RMA3_INPUT)) != 0"
+ "(pResource->primIOBufferMark & (0x1UL << GPISP_GC_PRIMITIVE_TAHITI_CVDALL_IO_BUFFER_ID_WMA0)) != 0"
+ "(pResource->primIOBufferMark & (0x1UL << GPISP_GC_PRIMITIVE_TAHITI_CVDALL_IO_BUFFER_ID_WMA1)) != 0"
+ "(pResource->primIOBufferMark & (0x1UL << GPISP_GC_PRIMITIVE_TAHITI_CVDALL_IO_BUFFER_ID_WMA2)) != 0"
+ "(pResource->primIOBufferMark & (0x1UL << GPISP_GC_PRIMITIVE_TAHITI_CVDALL_IO_BUFFER_ID_WMA3)) != 0"
+ "(pRoi != nullptr)"
+ "(pRoi == nullptr)"
+ "(pSensorConfig->totalVMin * pSensorConfig->totalH) > readoutTime"
+ "(pStatBuff->globalHistStatSize + pStatBuff->globalHistOffset) <= pDescr->paramNoiClr.globalHist2Offset"
+ "(pStatBuff->localHistStatSize + pStatBuff->localHistOffset) <= pDescr->paramNoiClr.globalHistOffset"
+ "(pStatBuff->thumbnailStatSize + pStatBuff->thumbnailOffset) <= pDescr->paramNoiClr.localHistOffset"
+ "(pStatParam->preISPCrop.height % 4) == 0"
+ "(pStatParam->preISPCrop.width % 4) == 0"
+ "(pToneCurveSet->channelCount == 1 && pToneCurveSet->points == 257) || (pToneCurveSet->channelCount == 4 && pToneCurveSet->points == 65)"
+ "(pVISLTM->ltm.ltmGridHeight <= CISP_LTM_MAX_LUT_HEIGHT) && \"LTM grid height violation\""
+ "(pVISLTM->ltm.ltmGridWidth <= CISP_LTM_MAX_LUT_WIDTH) && \"LTM grid width violation\""
+ "(pdeByteStride & 1) == 0"
+ "(pin == irPin) || (pin == dtPin)"
+ "(pipe == 0) || (pipe == 1) || (pipe == 2)"
+ "(preset->allTables[i]->eitBiasMap != nullptr) == (preset->allTables[i]->numEITBiasMap != 0)"
+ "(preset->allTables[i]->sifrTbl != nullptr) == (preset->allTables[i]->numEntriesSifr != 0)"
+ "(prevUpdate=%p ? prev.vFrSize=%u : cur.vFrSize=%u) * virtFrmWidth=%u"
+ "(priParams.priCfgIdx2FrameType[currPriCfgIdx] == PERIDOT_FRAME_TYPE_INVALID) || (priParams.priCfgIdx2FrameType[currPriCfgIdx] == metadataCfg.frameType[currBnkCfgIdx])"
+ "(pstAWBMetaData->gains.r.v16 != 0) && (pstAWBMetaData->gains.gr.v16 != 0) && (pstAWBMetaData->gains.gb.v16 != 0) && (pstAWBMetaData->gains.b.v16 != 0)"
+ "(roiSize > 0).all()"
+ "(roiSize.x % grid.spacingX) == 0"
+ "(roiSize.y % grid.spacingY) == 0"
+ "(rsclProcDmaEn & FLOWH17_DMA_ID_BIT_MASK(RsclProcCARDmaSrc)) ? pAlgBuf->bufferCar != NULL : 1"
+ "(rsclProcDmaEn & FLOWH17_DMA_ID_BIT_MASK(RsclProcFPNRDmaSrc)) ? pAlgBuf->fpnrDataAddr != nullptr : 1"
+ "(rsclProcDmaEn & FLOWH17_DMA_ID_BIT_MASK(RsclProcPDCDmaSrcStatic)) ? pAlgBuf->bufferPdcStatic != NULL : 1"
+ "(scale % 2) == 0"
+ "(scaler == BE_SCALER_0 || scaler == BE_SCALER_1) && pSetCamBesAuxSclCropOutputConfig->scaler_output[scaler].width <= CSystemConfigurator::Instance()->GetMaxSysImageWidth()"
+ "(scaler == BE_SCALER_0 || scaler == BE_SCALER_1) && pSetCamCropOutputConfig->output.width <= CSystemConfigurator::Instance()->GetMaxSysImageWidth()"
+ "(scaler == BE_SCALER_0 || scaler == BE_SCALER_1) && pSetCamYccSclCropOutputConfig->output.width <= CSystemConfigurator::Instance()->GetMaxSysImageWidth()"
+ "(scalerId != VFLOWH17_AUX_SCL || pOutConfig->width <= 3072)"
+ "(sibCmdHdrCnt + dataLen) <= headerLen"
+ "(sibCmdHdrCnt + subAddrLen) <= headerLen"
+ "(sifBinH != NULL) && (sifBinV != NULL)"
+ "(sifBinH == currSetting->fepDMAOutputBinH + (uint32_t)currSetting->fepQbinEnable) && (sifBinV == currSetting->fepDMAOutputBinV + (uint32_t) currSetting->fepQbinEnable)"
+ "(sifBinH == currSetting->sifrFepDMAOutputBinH + (uint32_t)currSetting->sifrFepQbinEnable) && (sifBinV == currSetting->sifrFepDMAOutputBinV + (uint32_t) currSetting->sifrFepQbinEnable)"
+ "(single[i] >= -16777216) && (single[i] <= 16777215)"
+ "(size_t) base == ISP_PIODMA_BASE_ADDR_2"
+ "(size_t) ffwQueueCount (queue) == available"
+ "(size_t) ffwQueueCount (queueEmptyBuffer) == buffers"
+ "(size_t) pVisPipeOpMem < (size_t) pVisSDetOpMem && (size_t) pVisSDetOpMem < (size_t) pLaccOpMem && (size_t) pLaccOpMem < (size_t) pNccOpMem && (size_t) pNccOpMem < (size_t) pPatchWarpOpMem && (size_t) pPatchWarpOpMem < ((size_t) pOpMem + sharedMemSize)"
+ "(size_t)(&pVISLTM->ltm.ltmGridMem[CISP_LTM_MAX_LUT_SIZE_IN_HWORD - 1]) - (((size_t)&pVISLTM->ltm.ltmGridMem[0] + 63) & ~63) > (size_t)pVISLTM->ltm.ltmGridStride * pVISLTM->ltm.ltmGridHeight && \"LTM mem is small\""
+ "(size_t)(bufList[i]->baseAddr) % 64 == 0"
+ "(size_t)(pSrc - src) == nBytes"
+ "(size_t)gpio < NUM_ELEMENTS(ispGpioOffsets)"
+ "(size_t)hwRegAddr >= AISP_BASE_ADDR(0) && (size_t)hwRegAddr < (AISP_BASE_ADDR(0) + AISP_REGION_LENGTH)"
+ "(size_t)hwRegAddr >= CVD_BASE_ADDR(0) && (size_t)hwRegAddr < (CVD_BASE_ADDR(0) + CVD_REGION_LENGTH)"
+ "(size_t)opbufs[i].data >= (size_t)fileDescs[fileId].pData"
+ "(size_t)p == ((size_t)BSP_SHARED_CACHED_VIRTUAL(pLscMem) + mallocSize)"
+ "(size_t)pLaccOpMem + sharedMemSize < (size_t)pOpMemUpperBound"
+ "(size_t)pNccOpMem + sharedMemSize < (size_t)pOpMemUpperBound"
+ "(size_t)pVisPipeOpMem + sharedMemSize < (size_t)pOpMemUpperBound"
+ "(size_t)pVisSDetOpMem + sharedMemSize < (size_t)pOpMemUpperBound"
+ "(size_t)source < INTERRUPT_SRC_TOTAL"
+ "(size_t)tmp <= ((size_t)pMem + totSize)"
+ "(size_t)vc < CConnectivityTable::Instance()->TotalVCGet()"
+ "(sizeof(sSplitPDDisableCfgIMX633_Ptrs) / sizeof(sSplitPDDisableCfgIMX633_Ptrs[0])) == configTot"
+ "(sizeof(sSplitPDDisableCfgIMX703_Ptrs) / sizeof(sSplitPDDisableCfgIMX703_Ptrs[0])) == configTot"
+ "(sourceGoReq & (0x7UL << (DATA_SOURCE_DESGEN_DMA - DATA_SOURCE_CVD_START))) == 0"
+ "(sr.all & ~0x3FFFFFF) == 0"
+ "(sr.all & ~0x7FF) == 0"
+ "(sr.all & ~0x7FFFF) == 0"
+ "(src >= DATA_SOURCE_CVD_START) && (src < DATA_SOURCE_TOTAL)"
+ "(src >= DATA_SOURCE_SENS0) && (src < DATA_SOURCE_TOTAL)"
+ "(src >= DATA_SOURCE_START) && (src < DATA_SOURCE_TOTAL)"
+ "(srcY + (stride+64) * height) < pRes->chCtx[chId].CtxMemUpperBound"
+ "(stacksize & (RTK_CRT_STACK_ALIGNMENT - 1)) == 0"
+ "(startX % 2) == 0"
+ "(startX & 1) == 0"
+ "(startX + (numTileX * horzInt)) <= ((pCurrPreISPCrop->width * scaleX) >> PRE_FESTAT_SCALE_FIX_POINT) && (startY + (numTileY * vertInt)) <= ((pCurrPreISPCrop->height * scaleY) >> PRE_FESTAT_SCALE_FIX_POINT)"
+ "(startX <= endX) && (startY <= endY)"
+ "(startXY.f.StartX % 4) == 0"
+ "(startXY.f.StartY % 4) == 0"
+ "(startY % 2) == 0"
+ "(statInHeight % 4) == 0"
+ "(statInWidth % 4) == 0"
+ "(statsDmaEn & FLOWH17_DMA_ID_BIT_MASK(IspStatsPipeLSCDmaSrc0)) ? pStatsBufInfo->bufferLsc != NULL : 1"
+ "(statsDmaEn & FLOWH17_DMA_ID_BIT_MASK(IspStatsPipeLSCDmaSrc1)) ? pStatsBufInfo->bufferLsc != NULL : 1"
+ "(status == TB_ERROR_SUCCESS)"
+ "(step > 0).all()"
+ "(strideX << 1) >= x"
+ "(strideY << 1) >= y"
+ "(subAddrLen + dataLen) <= BYTE_COUNT_MAX"
+ "(targetCh==WIDE_CAM_CH) || (targetCh==TELE_CAM_CH) || (targetCh==SWIDE_CAM_CH)"
+ "(targetFld >= DATA_DST_START) && (targetFld <= DATA_DST_END)"
+ "(tempCount + 1 + 1) <= packetSize"
+ "(tempCount) <= dstPacketSize"
+ "(this->_state == Task::State::DISABLED) || (this->_state == Task::State::IDLE) || (this->_state == Task::State::DONE) || (this->_state == Task::State::FINALIZED)"
+ "(this->focusGrid.spacingX % 2) == 0"
+ "(this->focusGrid.startX % 2) == 0"
+ "(this->nRois < this->NROIS_MAX)"
+ "(thumbX + thumbW <= pMeta->configurationAdjustedQuadraHocl.H6.gridCountX * 2) && (thumbY + thumbH <= pMeta->configurationAdjustedQuadraHocl.H6.gridCountY * 2)"
+ "(thumbnail=%p, localHist=%p, fpns=%p)"
+ "(tileCount * tileSize >= sensorRect.size).all()"
+ "(tileCount <= count).all()"
+ "(tileSize * (tiles.size) >= roiSize).all()"
+ "(tileSize > 0).all()"
+ "(tileSize.x % grid.spacingX) == 0"
+ "(tileSize.y % grid.spacingY) == 0"
+ "(tileWindow.x + tileWindow.width) <= (chDescr->sensorReadOutCropRect.x + chDescr->sensorReadOutCropRect.width)"
+ "(tileWindow.x + tileWindow.width) <= chDescr->sensorRect.width"
+ "(tileWindow.y + tileWindow.height) <= (chDescr->sensorReadOutCropRect.y + chDescr->sensorReadOutCropRect.height)"
+ "(tileWindow.y + tileWindow.height) <= chDescr->sensorRect.height"
+ "(tiles.size <= maxOutputSize).all()"
+ "(tiles.size >= 0).all()"
+ "(total <= 8) && (total != 0)"
+ "(totalSizeInWord * 4) % IOP_LCM_CACHE_LINE_SIZE == 0"
+ "(tunable_entry_cnt / 3) <= MAX_TUNABLES_COUNT_H17"
+ "(tuning.tileSizeX % this->focusGrid.spacingX) == 0"
+ "(tuning.tileSizeY % this->focusGrid.spacingY) == 0"
+ "(uint32_t) id < nbrOfObject"
+ "(uint32_t)(pCmd->afWins.configIdx < 0 ? 0 : pCmd->afWins.configIdx) < pDescr->paramRaw.sensorConfigsTot"
+ "(uint32_t)(pCmd->configIdx < 0 ? 0 : pCmd->configIdx) < pDescr->paramRaw.sensorConfigsTot"
+ "(uint32_t)gpio < CConnectivityTable::Instance()->GpioLUTSizeGet()"
+ "(uint32_t)id < nbrOfDmaManager"
+ "(uint32_t)id < nbrOfReq"
+ "(uint32_t)pCmd->configIdx < h->m_sensorConfigsTot"
+ "(uint32_t)pCmd->connId < maxUsrNbr"
+ "(uint32_t)pExtra->rc >> 16 < maxAneProgramItem"
+ "(uint64_t)poolStartBase <= ((uint64_t)poolBase[ch] + totalAll)"
+ "(uint64_t)runSlotConfig < ((uint64_t)1<<period)"
+ "(uint8_t)nChannelId == pMetaData->channel"
+ "(unmatchedDetObjectCount + newNumTrkObjects) <= maxTrkObjects"
+ "(unsigned int)dmaId < H17RTDMA_ID_TOT"
+ "(update.sensorRect.size > 0).all()"
+ "(update.subsetTileRect.end() <= update.tileCount).all()"
+ "(vcPipeID >=0) && (vcPipeID < CIC_VC_PIPELINE_TOT)"
+ "(void *)endX != NULL"
+ "(void *)endY != NULL"
+ "(void *)pBuff == (void *)pQueue->Peek()"
+ "(void *)pMetaData == (void *)pBuff->entry.buffRef.ref[1]->DataPointer()"
+ "(void *)startX != NULL"
+ "(void *)startY != NULL"
+ "(width % 4) == 0"
+ "(window.x + window.width) <= chDescr->sensorRect.width"
+ "(window.x + window.width) <= chDescr->sensorRect.width + configOffsetX"
+ "(window.y + window.height) <= chDescr->sensorRect.height"
+ "(window.y + window.height) <= chDescr->sensorRect.height + configOffsetY"
+ "(x < 0) || (x == xx)"
+ "(y < 0) || (y == yy)"
+ "*"
+ "*(pData + 2) == (IMX575_DIG_SCOPE_X_SIZE_A_HI + 1)"
+ "*(pData + 2) == (IMX575_DIG_SCOPE_Y_SIZE_A_HI + 1)"
+ "*(pData + 2) == (IMX575_EXCK_FREQ + 1)"
+ "*(pData + 2) == (IMX575_FRAME_LENGTH_HI + 1) && *(pData + 4) == (IMX575_FRAME_LENGTH_HI + 2)"
+ "*(pData + 2) == (IMX575_LINE_LENGTH_HI + 1)"
+ "*(pData + 2) == (IMX575_PLL_VT_MPY_REG + 1)"
+ "*(pData + 2) == (IMX575_X_START_HI + 1)"
+ "*(pData + 2) == (IMX575_Y_START_HI + 1)"
+ "*(pData + 2) == 0x0156 && *(pData + 4) == 0x0157"
+ "*(pData + 2) == 0x015B"
+ "*(pData + 2) == 0x015D"
+ "*(pData + 2) == 0x0165"
+ "*(pData + 2) == 0x0179"
+ "*(pData + 2) == 0x017B"
+ "*(pData + 4) == (regSpec[REG_FRAME_LENGTH].addr + 2)"
+ "*** non channel event logger resumed in buffer return.\n"
+ "*** non channel event logger resumed in context switch.\n"
+ "*** non channel event logger resumed in output enable.\n"
+ "*** non channel event logger resumed.\n"
+ "****** i = %d, pVectorOut ******\n"
+ "******** WriteMessage() return sts  = %d ********\n"
+ "******** loopBackTest enabled! ********\n"
+ "***Create session*** %d %d %d raw %d"
+ "***Destroy session***"
+ "**WARNING**:  apeDropDetectThreshold changed from %.3f to %.3f g's.\n"
+ "**WARNING**:  maxApeRetentionTimeSec changed from %d to %d seconds.\n"
+ "*exposure != 0"
+ "*exposureTargetedDuration>0"
+ "*extra_heap_size >= extra_heap_size_min"
+ "*gainAnal >= AE_GAIN_IDENTITY"
+ "*idx < CTASKPOOL_MAXTASK_HIST_ENTRIES"
+ "*indexOut == logDepth"
+ "*isPaused == true"
+ "*mainflashTargetDuration>0"
+ "*newGainCap > 0"
+ "*newGainLimit > 0"
+ "*newMaxIntegrationTimeInMicroseconds > 0"
+ "*numXGrid <= CISP_MAX_CIC_GRID_X"
+ "*numXGrid <= CISP_MAX_GIC_GRID_X"
+ "*numXGrid <= CISP_MAX_LSC_GRID_X"
+ "*numXGrid <= CISP_MAX_LUMA_GRID_X"
+ "*numYGrid <= CISP_MAX_CIC_GRID_Y"
+ "*numYGrid <= CISP_MAX_GIC_GRID_Y"
+ "*numYGrid <= CISP_MAX_LSC_GRID_Y"
+ "*numYGrid <= CISP_MAX_LUMA_GRID_Y"
+ "*outsize <= maxOutsize"
+ "*outsize >= sizeof(struct sCIspCmdAppleChAEDynamicSceneMeteringConfigSet)"
+ "*outsize >= sizeof(struct sCIspCmdAppleChAEDynamicSceneMeteringStart)"
+ "*outsize >= sizeof(struct sCIspCmdAppleChAEDynamicSceneMeteringStop)"
+ "*outsize >= sizeof(struct sCIspCmdAppleChAEFDSceneMeteringConfigGet)"
+ "*outsize >= sizeof(struct sCIspCmdAppleChAEFDSceneMeteringConfigSet)"
+ "*outsize >= sizeof(struct sCIspCmdAppleChAEWindowParamGet)"
+ "*outsize >= sizeof(struct sCIspCmdAppleChAEWindowParamSet)"
+ "*outsize >= sizeof(struct sCIspCmdAppleChAFWindowParamGet)"
+ "*outsize >= sizeof(struct sCIspCmdAppleChAFWindowParamSet)"
+ "*outsize >= sizeof(struct sCIspCmdAppleChAWBWindowParamGet)"
+ "*outsize >= sizeof(struct sCIspCmdAppleChFEStatConfigGet)"
+ "*outsize >= sizeof(struct sCIspCmdAppleChRowColSumWindowParamSet)"
+ "*outsize >= sizeof(struct sCIspCmdAppleChTileRegionSet)"
+ "*outsize >= sizeof(struct sCIspCmdAppleChTileWeightsSet)"
+ "*outsize >= sizeof(struct sCIspCmdChAWBCCTGet)"
+ "*outsize >= sizeof(struct sCIspCmdChAWBManualCCTRangeGet)"
+ "*outsize >= sizeof(struct sCIspCmdChNVStorageInfoGet)"
+ "*outsize >= sizeof(struct sCIspCmdConfigGet)"
+ "*outsize >= sizeof(struct sCIspCmdConfigGetExt)"
+ "*outsize >= sizeof(struct sCIspCmdGetBesParam)"
+ "*outsize >= sizeof(struct sCIspCmdPlatformInfo)"
+ "*outsize >= sizeof(struct sCIspCmdPowerSupplyControl)"
+ "*outsize >= sizeof(struct sCIspCmdPrintEnable)"
+ "*outsize >= sizeof(struct sCIspCmdTraceEnable)"
+ "*pGain >= AE_GAIN_IDENTITY"
+ "*pLinearGain >= AE_GAIN_IDENTITY"
+ "*pOp != nullptr"
+ "*pTemp != nullptr"
+ "*param == 1"
+ "*print_buffer_base != 0"
+ "*radscale > 8 + RadScaleOffset"
+ "*size <= SENSOR_PERMODULE_GIC_SIZE_MAX_BYTES"
+ "*size <= SENSOR_PERMODULE_LSC_QUADRA_CH_SHADING_SIZE_MAX_BYTES"
+ "*size <= SENSOR_PERMODULE_LUMA_SHADING_SIZE_MAX_BYTES"
+ "*size >= QCH_SHADING_FORMAT1_DECODED_DATA_SIZE"
+ "*size >= QCH_SHADING_FORMAT3_DECODED_DATA_SIZE"
+ "*size >= QCH_SHADING_FORMAT4_DECODED_DATA_SIZE * sizeof(uint16_t)"
+ "*size >= QCH_SHADING_FORMAT5_DECODED_DATA_SIZE"
+ "*sm_base != 0"
+ "*sm_size != 0"
+ "+Registered Client Task List (%d/%d)\n"
+ "--"
+ "-----------interval------------\n"
+ "--sifr:\t\t exp=%llu (%dus), ag 0x%x, dg 0x%x, lux %u\n"
+ "-1 != pMultiChGrp->subChannels[sub]"
+ "-RGB-IR"
+ ". LumaChg[%d]:{"
+ "./ffw64_rtxc/ffw/CBuffer.cpp"
+ "./ffw64_rtxc/ffw/CBufferPool.cpp"
+ "./ffw64_rtxc/ffw/CBufferPoolDiscrete.cpp"
+ "./ffw64_rtxc/ffw/CBufferPoolDynamicDummy.cpp"
+ "./ffw64_rtxc/ffw/CBufferPoolProxy.cpp"
+ "./ffw64_rtxc/ffw/CBufferPoolStatic.cpp"
+ "./ffw64_rtxc/ffw/CBufferProxy.cpp"
+ "./ffw64_rtxc/ffw/CBundle.cpp"
+ "./ffw64_rtxc/ffw/CChannelManager.cpp"
+ "./ffw64_rtxc/ffw/CController.cpp"
+ "./ffw64_rtxc/ffw/CFifo.cpp"
+ "./ffw64_rtxc/ffw/CFile.cpp"
+ "./ffw64_rtxc/ffw/CFilter.cpp"
+ "./ffw64_rtxc/ffw/CGPIOManager.cpp"
+ "./ffw64_rtxc/ffw/CIPSynchro.cpp"
+ "./ffw64_rtxc/ffw/CInterruptBuffer.cpp"
+ "./ffw64_rtxc/ffw/CList.cpp"
+ "./ffw64_rtxc/ffw/CLoggerInterProcessor.cpp"
+ "./ffw64_rtxc/ffw/CLoggerSharedBuffer.cpp"
+ "./ffw64_rtxc/ffw/CMMU.cpp"
+ "./ffw64_rtxc/ffw/CMMULoggerVA.cpp"
+ "./ffw64_rtxc/ffw/CMsgQueue.cpp"
+ "./ffw64_rtxc/ffw/CMultiFilter.cpp"
+ "./ffw64_rtxc/ffw/CMultiSink.cpp"
+ "./ffw64_rtxc/ffw/CObject.cpp"
+ "./ffw64_rtxc/ffw/CObjectTree.cpp"
+ "./ffw64_rtxc/ffw/CPipe.cpp"
+ "./ffw64_rtxc/ffw/CPool.cpp"
+ "./ffw64_rtxc/ffw/CRoot.cpp"
+ "./ffw64_rtxc/ffw/CSharedMemory.cpp"
+ "./ffw64_rtxc/ffw/CSignalPool.cpp"
+ "./ffw64_rtxc/ffw/CTaskProfiler.cpp"
+ "./ffw64_rtxc/ffw/CTerminalOut.cpp"
+ "./ffw64_rtxc/ffw/CTimeProfiler.cpp"
+ "./ffw64_rtxc/ffw/CVideoBufferPoolDynamicDummy.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CDebugAgent.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CEnvironment.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CISRManager.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CKDebug.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CMailboxPool.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CQueuePool.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CRTOSObjectPool.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CRTOSStat.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CResourcePool.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CScopedLock.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CSemaphorePool.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CSharedMemoryHeap.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CSharedMemoryHost.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CTaskPool.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CTimerManager.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CTimerPool.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CTraceEventBuffer.cpp"
+ "./ffw64_rtxc/platform/common/CCoredump.cpp"
+ "./ffw64_rtxc/platform/common/CEndpointChannel.cpp"
+ "./ffw64_rtxc/platform/common/CFakeChannel.cpp"
+ "./ffw64_rtxc/platform/common/CIPSynchroFake.cpp"
+ "./ffw64_rtxc/platform/common/CSecureM3Manager.cpp"
+ "./ffw64_rtxc/platform/common/ChannelTable.cpp"
+ "./ffw64_rtxc/platform/common/FakeChannelTable.cpp"
+ "./ffw64_rtxc/platform/common/RealChannelTable.cpp"
+ "./ffw64_rtxc/platform/rheia/rtkit/CPlatformEnvironment.cpp"
+ "./ffw64_rtxc/platform/rheia/rtkit/CPlatformGPIOManager.cpp"
+ "./ffw64_rtxc/platform/rheia/rtkit/CPlatformISRManager.cpp"
+ "./ffw64_rtxc/platform/rheia/rtkit/RealChannelTableTarget.cpp"
+ "./ffw64_rtxc/rtkit/os/tightbeam_mailbox.c"
+ "./h10isp/AlgoMisc/AlgoMisc.cpp"
+ "./h10isp/AlgoMisc/H17/AlgoMiscH17.cpp"
+ "./h10isp/AlgoMisc/IspMath.cpp"
+ "./h10isp/IspEngine/H17/CIspEngineClientH17.cpp"
+ "./h10isp/IspEngine/H17/CIspEngineExeLoopH17.cpp"
+ "./h10isp/IspEngine/H17/CIspEngineSanityCheckH17.cpp"
+ "./h10isp/IspEngine/H17/CIspEngineServerH17.cpp"
+ "./h10isp/IspEngine/H17/CIspHWRegConfigH17.cpp"
+ "./h10isp/IspEngine/H17/CIspHWStateH17.cpp"
+ "./h10isp/IspEngine/H17/CIspHwResourceServiceH17.cpp"
+ "./h10isp/IspEngine/H17/CIspOperationH17.cpp"
+ "./h10isp/IspEngine/H17/CIspOperationUtilH17.cpp"
+ "./h10isp/IspEngine/agent/CIspEngineAgent.cpp"
+ "./h10isp/IspEngine/agent/H17/CIspEngineAgentH17.cpp"
+ "./h10isp/IspEngine/agent/H17/CIspEngineAgentSecureModeH17.cpp"
+ "./h10isp/IspEngine/common/CIspEngineClient.cpp"
+ "./h10isp/IspEngine/common/CIspEngineExeLoop.cpp"
+ "./h10isp/IspEngine/common/CIspEngineServer.cpp"
+ "./h10isp/IspEngine/common/CIspHWRegConfig.cpp"
+ "./h10isp/IspEngine/common/CIspHWState.cpp"
+ "./h10isp/IspEngine/common/CIspHwResourceService.cpp"
+ "./h10isp/IspEngine/common/CIspLACCResource.cpp"
+ "./h10isp/IspEngine/common/CIspUUId.cpp"
+ "./h10isp/IspEngine/common/CPoolSecured.cpp"
+ "./h10isp/IspEngine/driver/CISPGOCDrv.cpp"
+ "./h10isp/IspEngine/driver/CISPHueMapDrv.cpp"
+ "./h10isp/IspEngine/driver/CISPLSCDrv.cpp"
+ "./h10isp/IspEngine/driver/CISPRawProcDrv.cpp"
+ "./h10isp/IspEngine/driver/CISPRegAction.cpp"
+ "./h10isp/IspEngine/driver/H17/CISPAFEDrvH17.cpp"
+ "./h10isp/IspEngine/driver/H17/CISPAFEProcDrvH17.cpp"
+ "./h10isp/IspEngine/driver/H17/CISPAHFD1p4Drv.cpp"
+ "./h10isp/IspEngine/driver/H17/CISPCLRProcDrvH17.cpp"
+ "./h10isp/IspEngine/driver/H17/CISPCVPipeDrvH17.cpp"
+ "./h10isp/IspEngine/driver/H17/CISPHueMapDrvH17.cpp"
+ "./h10isp/IspEngine/driver/H17/CISPLSCDrvH17.cpp"
+ "./h10isp/IspEngine/driver/H17/CISPLogicalDMAH17.cpp"
+ "./h10isp/IspEngine/driver/H17/CISPLogicalDMAManagerH17.cpp"
+ "./h10isp/IspEngine/driver/H17/CISPPDPDrvH17.cpp"
+ "./h10isp/IspEngine/driver/H17/CISPPyrOutProcDrvH17.cpp"
+ "./h10isp/IspEngine/driver/H17/CISPRawScaleDrvH17.cpp"
+ "./h10isp/IspEngine/driver/H17/CISPRegActionH17.cpp"
+ "./h10isp/IspEngine/driver/H17/CISPVisionResDrvH17.cpp"
+ "./h10isp/IspEngine/driver/H17/CISPVisionStatsDrvH17.cpp"
+ "./h10isp/bases/CAEBase.cpp"
+ "./h10isp/bases/CAFBase.cpp"
+ "./h10isp/bases/CAFilterBase.cpp"
+ "./h10isp/bases/CAMFBase.cpp"
+ "./h10isp/bases/CAWBBase.cpp"
+ "./h10isp/bases/CDeviceDriver.cpp"
+ "./h10isp/bases/CSensorTuningParam.cpp"
+ "./h10isp/bases/CStrobeDriver.cpp"
+ "./h10isp/common/controller/target/CDSControllerBaseFaceDetection.cpp"
+ "./h10isp/common/framework/CParallelTaskProc.cpp"
+ "./h10isp/common/misc/CAllocator.cpp"
+ "./h10isp/common/misc/CAllocatorWrapper.cpp"
+ "./h10isp/common/misc/CProfileUtility.cpp"
+ "./h10isp/common/misc/EventLogger.cpp"
+ "./h10isp/common/misc/H17/CConnectivityTableD9x.cpp"
+ "./h10isp/common/misc/H17/CSystemConfiguratorConnectivityH17.cpp"
+ "./h10isp/common/misc/MemUtil.cpp"
+ "./h10isp/common/misc/ThreadEventTrace.cpp"
+ "./h10isp/controller/target/H17/CDSControllerH17Stats.cpp"
+ "./h10isp/controller/target/H8/CDSControllerH8Stats.cpp"
+ "./h10isp/drivers/APS/CApsModelDrv.cpp"
+ "./h10isp/drivers/Algorithm/3A/AE/CAEAFEFDAssistv2.cpp"
+ "./h10isp/drivers/Algorithm/3A/AE/CAEAFEFDTracker.cpp"
+ "./h10isp/drivers/Algorithm/3A/AE/CAEAdaptiveDR.cpp"
+ "./h10isp/drivers/Algorithm/3A/AE/CAECmd.cpp"
+ "./h10isp/drivers/Algorithm/3A/AE/CAEUtils.cpp"
+ "./h10isp/drivers/Algorithm/3A/AF/CAFAFE.cpp"
+ "./h10isp/drivers/Algorithm/3A/AF/CAFAFEMatrix.cpp"
+ "./h10isp/drivers/Algorithm/3A/AF/CAFAFEPeakTracking.cpp"
+ "./h10isp/drivers/Algorithm/3A/AF/CAFAFESingleAF.cpp"
+ "./h10isp/drivers/Algorithm/3A/AF/CAFAFE_PDAF.cpp"
+ "./h10isp/drivers/Algorithm/3A/AF/H17/CAFAFEH17.cpp"
+ "./h10isp/drivers/Algorithm/3A/AWB/CAWBAFEPhotometerAssistPenrose.cpp"
+ "./h10isp/drivers/Algorithm/3A/AWB/CAWBAFETemporalStabilizer.cpp"
+ "./h10isp/drivers/Algorithm/3A/AWB/CDualLEDsWhitePointProjector.cpp"
+ "./h10isp/drivers/Algorithm/3A/CAEHdrExposureRatio.cpp"
+ "./h10isp/drivers/Algorithm/3A/CFlickerDetection.cpp"
+ "./h10isp/drivers/Algorithm/GlobalMotionEstimation/SLAFMaskGenerator/slafMaskExtractor.cpp"
+ "./h10isp/drivers/Algorithm/GlobalMotionEstimation/ValidMeshGenerator/validMeshGenerator.cpp"
+ "./h10isp/drivers/Algorithm/LTM/CLTMDrv.cpp"
+ "./h10isp/drivers/Algorithm/LensShading/CAdaptiveLS.cpp"
+ "./h10isp/drivers/Algorithm/LensShading/CLensShading.cpp"
+ "./h10isp/drivers/Algorithm/LensShading/CLensShadingH6.cpp"
+ "./h10isp/drivers/Algorithm/Timewarp/CSSense.cpp"
+ "./h10isp/drivers/Algorithm/Timewarp/CSSenseFusion.cpp"
+ "./h10isp/drivers/Algorithm/Timewarp/CSTemporalAestheticsEngine.cpp"
+ "./h10isp/drivers/Algorithm/Timewarp/CTimewarpDrv.cpp"
+ "./h10isp/drivers/Algorithm/Timewarp/twcv.cpp"
+ "./h10isp/drivers/CMPN_RTR_MGR/CCmpnRtrManager.cpp"
+ "./h10isp/drivers/Distortion/CDistLens.cpp"
+ "./h10isp/drivers/Distortion/CDistLensDispatcher.cpp"
+ "./h10isp/drivers/Distortion/CDistMultiDrv2.cpp"
+ "./h10isp/drivers/Distortion/CDistPair.cpp"
+ "./h10isp/drivers/Extrinsics/CExtMultiDrv.cpp"
+ "./h10isp/drivers/Extrinsics/CExtMultiDrvBridge.cpp"
+ "./h10isp/drivers/FE/CConfigDrv.cpp"
+ "./h10isp/drivers/FE/CGOCDrv.cpp"
+ "./h10isp/drivers/FE/CLSCDrv.cpp"
+ "./h10isp/drivers/FE/CVCPipelineInterface.cpp"
+ "./h10isp/drivers/FE/H17/CDMADrvH17Dst.cpp"
+ "./h10isp/drivers/FE/H17/CDMADrvH17Src.cpp"
+ "./h10isp/drivers/FE/H17/CLSCDrvH17.cpp"
+ "./h10isp/drivers/FE/H17/CSideBandDMADrvH17.cpp"
+ "./h10isp/drivers/GPIO/CGPIODriverISPH17.cpp"
+ "./h10isp/drivers/LPDP/CLPDP.cpp"
+ "./h10isp/drivers/LPDP/CLPDPDummy.cpp"
+ "./h10isp/drivers/MIPI/CMipiCsi2SecureM3Wrapper.cpp"
+ "./h10isp/drivers/MIPI/H17/CMipiCsi2_H17.cpp"
+ "./h10isp/drivers/NVMParser/FDRSysCfgManager/CFDRSysCfgManager.cpp"
+ "./h10isp/drivers/NVMParser/FPNDataManager/CFPNDataManager.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/APSComCal/CNVMParserAPSComCal_SC_V3.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/BuildInfo/CNVMParserBuildInfo_H4_Format10.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/BuildInfo/CNVMParserBuildInfo_H4_Format11.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/BuildInfo/CNVMParserBuildInfo_H4_Format12.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/BuildInfo/CNVMParserBuildInfo_H4_Format13.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/BuildInfo/CNVMParserBuildInfo_H4_Format16.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/BuildInfo/CNVMParserBuildInfo_H4_Format17.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/BuildInfo/CNVMParserBuildInfo_H4_Format4.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/BuildInfo/CNVMParserBuildInfo_H4_Format5.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/BuildInfo/CNVMParserBuildInfo_H4_Format7.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/BuildInfo/CNVMParserBuildInfo_H4_Format8.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/BuildInfo/CNVMParserBuildInfo_ST_Format17.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/CNVMParserD9x.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/CNVMParserDualCamera.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/ColorAFCal/CNVMParserColorAFCal_H4_Format2.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/ColorAFCal/CNVMParserColorAFCal_H4_Format4.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/ColorAFCal/CNVMParserColorAFCal_H4_Format6.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/ColorAFCal/CNVMParserColorAFCal_SC_V4.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/ColorAFCal/CNVMParserColorAFCal_VR_V4.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/ColorReCal/CNVMParserColorReCal_BWI_V2.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/ColorReCal/CNVMParserColorReCal_H4_D5xBase.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/ColorShading/CNVMParserColorShading_H4_19x15_Base.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/ColorShading/CNVMParserColorShading_H4_19x38_Base.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/ColorShading/CNVMParserColorShading_H4_Format5.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/ColorShading/CNVMParserColorShading_MEM_V0.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/ColorShading/CNVMParserColorShading_VR_V5.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/ColorShading/CNVMParserColorShading_VR_V7.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/DPCTagging/CNVMParserMultiDPCTagging_H4_Format1.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/DPCTagging/CNVMParserMultiDPCTagging_H4_Format2.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/ExtCal/CNVMParserExtCal_H4_Format2.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/ExtCal/CNVMParserExtCal_H4_Format3.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/FPDC/CNVMParserFPDC_H4_Format2.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/FieldCurve/CNVMParserFieldCurve_H4_Format3.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/FieldCurve/CNVMParserFieldCurve_H4_Format4.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/FieldCurve/CNVMParserFieldCurve_H4_Format5.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/OisZCal/CNVMParserOisZCal_H4_Format3.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/PDAFDisparityCal/CNVMParserPDAFDisparityCal_H4_Format2.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/PDAFDisparityCal/CNVMParserPDAFDisparityCal_H4_Format3.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/PDAFDisparityCal/CNVMParserPDAFDisparityCal_H4_Format4.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/PDAFDisparityCal/CNVMParserPDAFDisparityCal_H4_Format5.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/SphereCal/CNVMParserSphereCal_H4_Format3.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/SphereCal/CNVMParserSphereCal_H4_Format4.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/SphereCal/CNVMParserSphereCal_H4_Format5.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/SphereCal/CNVMParserSphereCal_H4_Format7.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/SphereCal/CNVMParserSphereCal_VR_V7.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/SphereCal/CNVMParserSphereCal_VR_V8.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/SphereReCal/CNVMParserSphereReCal_H4_Format1.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/SphereReCal/CNVMParserSphereReCal_H4_Format5.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/SphereReCal/CNVMParserSphereReCal_VR_V6.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/bases/CNVMParserBuildInfoBase.cpp"
+ "./h10isp/drivers/NVMParser/NVMParserDualCameraV2/bases/CNVMParserSphereCalBase.cpp"
+ "./h10isp/drivers/NVSTORAGE/FORMATS/NVStorageFormats.cpp"
+ "./h10isp/drivers/NVSTORAGE/VIRTUAL/CNVStorageSection.cpp"
+ "./h10isp/drivers/PDE/GMS/GMSLineFitting.cpp"
+ "./h10isp/drivers/PDE/RegsUpdateH17/RU_FillDscCommon.cpp"
+ "./h10isp/drivers/PDE/RegsUpdateH17/RU_GeometricTransformations.cpp"
+ "./h10isp/drivers/PDE/RegsUpdateH17/RU_PcePath_SCL01_DR01_ROT01.cpp"
+ "./h10isp/drivers/PDE/RegsUpdateH17/RU_PcePath_Scaler_DR_RG_Post2.cpp"
+ "./h10isp/drivers/PDE/RegsUpdateH17/RU_PcePath_Scaler_DR_RG_Post3.cpp"
+ "./h10isp/drivers/PDE/RegsUpdateH17/RU_PcePath_Unpacker0_Scaler1_DR_RG_Post2.cpp"
+ "./h10isp/drivers/PDE/RegsUpdateH17/RU_PcePath_Unpacker_RG_Post1.cpp"
+ "./h10isp/drivers/PDE/RegsUpdateH17/RU_PceStage.cpp"
+ "./h10isp/drivers/PDE/RegsUpdateH17/RU_PceStage_SPLIT_PD.cpp"
+ "./h10isp/drivers/PDE/RegsUpdateH17/RU_PceStage_SPLIT_PD_SCALE.cpp"
+ "./h10isp/drivers/PDE/RegsUpdateH17/RU_RgsBlock.cpp"
+ "./h10isp/drivers/PDP/H17/CPDPDrvH17.cpp"
+ "./h10isp/drivers/PIODMA/H17/CPIODMAH17.cpp"
+ "./h10isp/drivers/SENSOR/Dummy/CImageSensorDummy.cpp"
+ "./h10isp/drivers/SENSOR/Dummy/CImageSensorDummyCore.cpp"
+ "./h10isp/drivers/SENSOR/IMX575/IMX575RegSetting.cpp"
+ "./h10isp/drivers/SENSOR/IMX591/IMX591RegSetting.cpp"
+ "./h10isp/drivers/SENSOR/IMX633/IMX633RegSetting.cpp"
+ "./h10isp/drivers/SENSOR/IMX703/IMX703RegSetting.cpp"
+ "./h10isp/drivers/SENSOR/IMX713/IMX713RegSetting.cpp"
+ "./h10isp/drivers/SENSOR/IMX714/CImageSensorIMX714_M3.cpp"
+ "./h10isp/drivers/SENSOR/IMX714/IMX714BootSetting.cpp"
+ "./h10isp/drivers/SENSOR/IMX714/IMX714RegSetting.cpp"
+ "./h10isp/drivers/SENSOR/IMX803/IMX803RegSetting.cpp"
+ "./h10isp/drivers/SENSOR/IMX903/IMX903RegSetting.cpp"
+ "./h10isp/drivers/SENSOR/IMX913/IMX913BootSetting.cpp"
+ "./h10isp/drivers/SENSOR/IMX913/IMX913RegSetting.cpp"
+ "./h10isp/drivers/SENSOR/IMX972/IMX972RegSetting.cpp"
+ "./h10isp/drivers/SENSOR/VD56G8/CImageSensorVD56G8Utility.cpp"
+ "./h10isp/drivers/SENSOR/VD56G8/CNVMParserBuildInfo_Centaur.cpp"
+ "./h10isp/drivers/STAT/H17/CAFEProcDrvH17.cpp"
+ "./h10isp/drivers/Timer/CISPTimer.cpp"
+ "./h10isp/drivers/Timer/H17/CISPTimerH17.cpp"
+ "./h10isp/drivers/VIS/CGVSCore.cpp"
+ "./h10isp/drivers/VIS/adaptiveBandwidthController.cpp"
+ "./h10isp/drivers/Vision/H17/CVisionResDrvH17.cpp"
+ "./h10isp/drivers/Vision/H17/CVisionStatsDrvH17.cpp"
+ "./h10isp/filters/AICam/CAICamProc.cpp"
+ "./h10isp/filters/AICam/anst/CAICamAlgoContainerAnst.cpp"
+ "./h10isp/filters/AICam/anst/CAICamUtilAnst.cpp"
+ "./h10isp/filters/AlgoControl/CAlgoControlCmdAFEProc.cpp"
+ "./h10isp/filters/AlgoControl/CAlgoControlCmdANST.cpp"
+ "./h10isp/filters/AlgoControl/CAlgoControlCmdColor.cpp"
+ "./h10isp/filters/AlgoControl/CAlgoControlCmdNoise.cpp"
+ "./h10isp/filters/AlgoControl/CAlgoControlCmdRaw.cpp"
+ "./h10isp/filters/AlgoControl/CAlgoControlFSM.cpp"
+ "./h10isp/filters/AlgoControl/H17/CAlgoControlH17InterfaceToFlow.cpp"
+ "./h10isp/filters/Algorithm/3A/CAEAppleFSM.cpp"
+ "./h10isp/filters/Algorithm/3A/CAFAppleCmd.cpp"
+ "./h10isp/filters/Algorithm/3A/CAFFocusHint.cpp"
+ "./h10isp/filters/Algorithm/3A/CAFProcess.cpp"
+ "./h10isp/filters/Algorithm/3A/CAWBAppleFSM.cpp"
+ "./h10isp/filters/Algorithm/BlurM/BlurM.cpp"
+ "./h10isp/filters/Algorithm/DepthHistProc/CDepthHistProc.cpp"
+ "./h10isp/filters/Algorithm/DepthHistProc/CDepthHistProcCmd.cpp"
+ "./h10isp/filters/Algorithm/FingerOcclusionDetection/FOD.cpp"
+ "./h10isp/filters/Algorithm/Keypoint/CKeypoint.cpp"
+ "./h10isp/filters/Algorithm/Keypoint/H17/CKeypointH17.cpp"
+ "./h10isp/filters/Algorithm/Keypoint/H17/CKeypointH17Cmd.cpp"
+ "./h10isp/filters/Algorithm/LTM/CLTM.cpp"
+ "./h10isp/filters/Algorithm/LensShading/CLSC2.cpp"
+ "./h10isp/filters/Algorithm/LensShading/CLSCCmd.cpp"
+ "./h10isp/filters/Algorithm/PDAF/config.cpp"
+ "./h10isp/filters/Algorithm/PDAF/control.cpp"
+ "./h10isp/filters/Algorithm/PDAF/filter/CFocusPixelMapDecoder.cpp"
+ "./h10isp/filters/Algorithm/PDAF/histogram.cpp"
+ "./h10isp/filters/Algorithm/PDAF/isp/afe.cpp"
+ "./h10isp/filters/Algorithm/PDAF/isp/afeproc.cpp"
+ "./h10isp/filters/Algorithm/PDAF/isp/dma.cpp"
+ "./h10isp/filters/Algorithm/PDAF/isp/fpc.cpp"
+ "./h10isp/filters/Algorithm/PDAF/isp/fpx.cpp"
+ "./h10isp/filters/Algorithm/PDAF/isp/pdp.cpp"
+ "./h10isp/filters/Algorithm/PDAF/pixelengine/PDAFPixelEngine.cpp"
+ "./h10isp/filters/Algorithm/PDAF/pixelengine/task.cpp"
+ "./h10isp/filters/Algorithm/PDAF/pixelengine/taskmanager.cpp"
+ "./h10isp/filters/Algorithm/PDAF/region.cpp"
+ "./h10isp/filters/Algorithm/PDAF/roimanager.cpp"
+ "./h10isp/filters/Algorithm/PDAF/scene.cpp"
+ "./h10isp/filters/Algorithm/PDAF/shared.cpp"
+ "./h10isp/filters/Algorithm/PDAF/trace.cpp"
+ "./h10isp/filters/Algorithm/SPD/SPD.cpp"
+ "./h10isp/filters/Algorithm/TimeWarp/CTimeWarp.cpp"
+ "./h10isp/filters/Algorithm/ToneCurve/CToneCurve.cpp"
+ "./h10isp/filters/Algorithm/ZF/Fw/CZF.cpp"
+ "./h10isp/filters/DCN/CDcnProc.cpp"
+ "./h10isp/filters/DCN/CFidAttentionAlgoCtn.cpp"
+ "./h10isp/filters/DCN/CFidAttentionAlgoCtnSimple.cpp"
+ "./h10isp/filters/DPCPROC/CDPCApple.cpp"
+ "./h10isp/filters/DPCPROC/CDPCAppleBufferProc.cpp"
+ "./h10isp/filters/DPCPROC/CDPCAppleH17.cpp"
+ "./h10isp/filters/DeferBufAlloc/CDeferBufAlloc.cpp"
+ "./h10isp/filters/DepthProc/CDepthProcAfAssist.cpp"
+ "./h10isp/filters/DepthProc/CDepthProcBase.cpp"
+ "./h10isp/filters/DepthProc/DepthProcAfAssist.cpp"
+ "./h10isp/filters/ER/ERInterface.cpp"
+ "./h10isp/filters/FESTAT/CFEStat.cpp"
+ "./h10isp/filters/FESTAT/CFEStatH6Cmd.cpp"
+ "./h10isp/filters/FESTAT/CFEStatH6Device.cpp"
+ "./h10isp/filters/IC/CImageCaptureMultiQ.cpp"
+ "./h10isp/filters/IC/CImageCaptureUtil.cpp"
+ "./h10isp/filters/IC/PeridotSensorControl/CPeridotConfigManager.cpp"
+ "./h10isp/filters/LensController/AuxiliaryThread/CLCChannelAuxiliaryThread.cpp"
+ "./h10isp/filters/LensController/CLCScheduler.cpp"
+ "./h10isp/filters/LensController/CLensController.cpp"
+ "./h10isp/filters/LensController/CLensControllerHxCmd.cpp"
+ "./h10isp/filters/LensController/CLensControllerHxTrace.cpp"
+ "./h10isp/filters/LensController/drivers/AFAlgorithm/CAFAlgorithmCommon.cpp"
+ "./h10isp/filters/LensController/drivers/AFAlgorithm/CLensCtrlAFAssist_APE.cpp"
+ "./h10isp/filters/LensController/drivers/AFAlgorithm/CLensCtrlAFAssist_FC.cpp"
+ "./h10isp/filters/LensController/drivers/AFAlgorithm/CLensCtrlAfAssist_Depth.cpp"
+ "./h10isp/filters/LensController/drivers/AFAlgorithm/CLensCtrlAfAssist_LFAF.cpp"
+ "./h10isp/filters/LensController/drivers/AFAlgorithm/CLensCtrlAfAssist_Persistent.cpp"
+ "./h10isp/filters/LensController/drivers/FOCUS/AD5835/CAutoFocusAD5835.cpp"
+ "./h10isp/filters/LensController/drivers/FOCUS/CAutoFocusDevice.cpp"
+ "./h10isp/filters/LensController/drivers/FOCUS/COisDevice.cpp"
+ "./h10isp/filters/LensController/drivers/FOCUS/CS40L61/CAutoFocusCS40L61.cpp"
+ "./h10isp/filters/LensController/drivers/FOCUS/CS40L61/CAutoFocusCS40L61_A0.cpp"
+ "./h10isp/filters/LensController/drivers/FOCUS/CS40L61/CAutoFocusCS40L61_Bridge.cpp"
+ "./h10isp/filters/LensController/drivers/FOCUS/CS40L62/CAutoFocusCS40L62.cpp"
+ "./h10isp/filters/LensController/drivers/FOCUS/CS40L62/CAutoFocusCS40L62_A0.cpp"
+ "./h10isp/filters/LensController/drivers/FOCUS/CS40L62/CAutoFocusCS40L62_Bridge.cpp"
+ "./h10isp/filters/LensController/drivers/LensCtrlDrv/CLCPlayback.cpp"
+ "./h10isp/filters/LensController/drivers/LensCtrlDrv/CLensCtrlAfDrv.cpp"
+ "./h10isp/filters/LensController/drivers/LensCtrlDrv/CLensCtrlApsDrv.cpp"
+ "./h10isp/filters/LensController/drivers/LensCtrlDrv/CLensCtrlDrvBackground.cpp"
+ "./h10isp/filters/LensController/drivers/LensCtrlDrv/CLensCtrlDrvFaultManager.cpp"
+ "./h10isp/filters/LensController/drivers/LensCtrlDrv/CLensCtrlOisDrv.cpp"
+ "./h10isp/filters/LensController/drivers/Motion/CLCMotion.cpp"
+ "./h10isp/filters/LensController/drivers/Temperature/TMP118/CTemperatureSensorTMP118.cpp"
+ "./h10isp/filters/LensController/drivers/Trace/CEventTracer.cpp"
+ "./h10isp/filters/LensController/drivers/Trace/CFileWriter.cpp"
+ "./h10isp/filters/MLAF/CEXTSLAFProcImp.cpp"
+ "./h10isp/filters/MLAF/CMLAFProc.cpp"
+ "./h10isp/filters/MotionCapture/CMotionCaptureBase.cpp"
+ "./h10isp/filters/MotionEstimator/CMotionEstimator.cpp"
+ "./h10isp/filters/MotionEstimator/H17/CMotionEstimatorH17Cmd.cpp"
+ "./h10isp/filters/PDE/Debug/CPCEDebugService.cpp"
+ "./h10isp/filters/PDE/Debug/CPCEEventLogger.cpp"
+ "./h10isp/filters/PDE/v2/CPCECalibAlgoGmc.cpp"
+ "./h10isp/filters/PDE/v2/CPCECalibAlgoGms.cpp"
+ "./h10isp/filters/PDE/v2/CPCEFlow.cpp"
+ "./h10isp/filters/PDE/v2/CPCEFlowFactory.cpp"
+ "./h10isp/filters/PDE/v2/CPCEFlowManager.cpp"
+ "./h10isp/filters/PDE/v2/CPDEProcV2.cpp"
+ "./h10isp/filters/PDE/v2/FrontStereo/CPCEFlowFactoryFrontStereoFusion.cpp"
+ "./h10isp/filters/PDE/v2/Pearl/CPCEFlowFactoryPearl.cpp"
+ "./h10isp/filters/PDE/v2/Pearl/CPCEFlowPearl.cpp"
+ "./h10isp/filters/PDE/v2/Pearl/SinglePass/CPCEFlowPearlSinglePass.cpp"
+ "./h10isp/filters/PDE/v2/RearStereo/CPCEFlowFactoryRearStereo.cpp"
+ "./h10isp/filters/PDE/v2/RearStereo/SinglePass/CPCEFlowFactoryRearStereoSinglePass.cpp"
+ "./h10isp/filters/PDE/v2/RearStereo/SinglePass/CPCEFlowRearStereoSinglePass.cpp"
+ "./h10isp/filters/PDE/v2/RearStereo/TriplePass/CPCEFlowFactoryRearStereoTriplePass.cpp"
+ "./h10isp/filters/PDE/v2/RearStereo/TriplePass/CPCEFlowRearStereoTriplePass.cpp"
+ "./h10isp/filters/PDE/v2/SplitPD/CPCEFlowSplitPDDisparity.cpp"
+ "./h10isp/filters/PDE/v2/SplitPD/CPCEFlowSplitPDScale.cpp"
+ "./h10isp/filters/TimeMachine/CTimeMachineMultiPass.cpp"
+ "./h10isp/filters/VIO/CVio3Proc.cpp"
+ "./h10isp/filters/VisionProc/CVisionResize.cpp"
+ "./h10isp/filters/ane/CAneUtils.cpp"
+ "./h10isp/service/ClassifierService/CClassifierService.cpp"
+ "./h10isp/service/DepthService/CDepthService.cpp"
+ "./h10isp/service/DepthService/CDepthServiceAE.cpp"
+ "./h10isp/service/HostMetaDataService/CHostMetaDataService.cpp"
+ "./h10isp/service/LensService/CLensService.cpp"
+ "./h10isp/service/MotionService/CMotionService.cpp"
+ "./h10isp/service/NoiseModelService/CNoiseModel.cpp"
+ "./h10isp/service/OverlayService/COverlayService.cpp"
+ "./h10isp/service/PipelineDecimationService/CPipelineDecimationService.cpp"
+ "./h10isp/service/PowerControlService/CPowerControlService.cpp"
+ "./h10isp/service/PowerControlService/H17/CPowerControlServiceH17.cpp"
+ "./h10isp/service/ROIService/CROIService.cpp"
+ "./h10isp/service/TuningParamService/CTuningParamService.cpp"
+ "./h10isp/tuning/CSensorTuningParamIMX633.cpp"
+ "./h10isp/tuning/CSensorTuningParamIMX913.cpp"
+ "./taskHistory%d.txt"
+ "./tracefile_%d_%d.bin"
+ ".bin"
+ "/semanticAWB/DumpSemanticMap_%u_w%u_h%d.data"
+ "0 != isrHandle_"
+ "0 != mutex"
+ "0 != nbrOfReq"
+ "0 != pCmd->sem"
+ "0 && \"YUV 1 plane is obsolete\""
+ "0 < m_fdScoreThreshold && m_fdScoreThreshold < 1"
+ "0 < maxData"
+ "0 <= (int32_t)ix && (int32_t)ix < (int32_t)size - 1"
+ "0 <= (int32_t)iy && (int32_t)iy < (int32_t)size - 1"
+ "0 <= aCol[r]"
+ "0 <= ax && ax <= 1"
+ "0 <= ay && ay <= 1"
+ "0 == endX"
+ "0 == endY"
+ "0 == isrHandle_"
+ "0 == matched || 1 == matched"
+ "0 == memoryPackRegSize"
+ "0 == memoryRegSize"
+ "0 == pFreeUsers->Outstanding()"
+ "0 == pGroupIdIdxPool->Outstanding()"
+ "0 == pRestrictPart->isRestricted"
+ "0 == packetBank"
+ "0 == preIn.rawHBinEn"
+ "0 == res"
+ "0 == result"
+ "0 == ret"
+ "0 == startX"
+ "0 == startY"
+ "0 == staticInit"
+ "0 ==((char*)pLocalEntry - (char*)pool)%objectMallocSize"
+ "0/1"
+ "0x%02x,0x%08x,0x%08x,0x%08x,0x%04x,0x%04x,0x%08x) = 0x%04x"
+ "0x%04x (BUCK%d VSEL): value: 0x%02x => %dmV"
+ "0x%04x (GPIO%x): value: 0x%04x"
+ "0x%04x (LDO%d): value: 0x%02x => %dmV"
+ "0x%04x (SLOT%x): value: 0x%08x"
+ "0x%04x: value: 0x%02x"
+ "0x%04x: value: 0x%04x"
+ "0x%04x: value: 0x%08x"
+ "0x%x"
+ "0x%x  "
+ "0x%x -> 0x%x"
+ "0x%x <= 0x%x\n"
+ "0x00 == (powerstatus & 0xFF)"
+ "0xFF == (powerstatus & 0xFF)"
+ "0xffffffff != anstProcedureId"
+ "1"
+ "1 << targetCh & pChHdr->dest.chBitMask"
+ "1 == U.height || U.rowBytes == U.width * sizeof(float)"
+ "1 == V.height || V.rowBytes == V.width * sizeof(float)"
+ "1 == W.height || W.rowBytes == W.width * sizeof(float)"
+ "1 == isHwMapped"
+ "1 == staticInit"
+ "1-Success 2-Bypass Wrap %d Auth %d Unwrap %d\n"
+ "16 PPC 2nd FEP not available for ACI Sensor"
+ "1v2 mode is not supported for ALDAST GPIO11 and GPIO12"
+ "2 * numPoints <= totalSizeInWord"
+ "2-SCALE REGISTRATION, IN BAND 2"
+ "2-SCALE REGISTRATION, IN BAND 3"
+ "200 <= target_freq_hz && target_freq_hz <= 800"
+ "22:55:49"
+ "2D"
+ "2nd fepPipeType %d"
+ "3C0:3C3 %x %x %x %x\n"
+ "3D"
+ "5a874c187c"
+ "5e9e630"
+ "62ac52b857"
+ "827c1ae9e1"
+ ": CAM0 Current: b1:%f b2:%f bz:%f, i_split_to_cam0 %f, temperature: %f"
+ ": CAM1 Current: b1:%f b2:%f bz:%f, i_split_to_cam1 %f, temperature: %f"
+ ": CAM4 Current: bz:%f, i_split_to_cam4 %f, temperature: %f"
+ ": Changed PVDD_AF to %f [V]"
+ ": Changed PVDD_OIS to %f [V]"
+ ": DynamicVoltage temp=%f margin=%f dynamic margin=%f pvdd_af=%f"
+ ": DynamicVoltage temp=%f margin=%f dynamic margin=%f pvdd_ois=%f"
+ ": DynamicVoltage temp=%f margin=%f pvdd=%f"
+ ": Needed PVDD = %f [V] above maximum; set to %f [V]"
+ ": Needed PVDD = %f [V] below minimum; set to %f [V]"
+ ": Needed PVDD_AF = %f [V] above maximum; set to %f [V]"
+ ": Needed PVDD_AF= %f [V] below minimum; set to %f [V]"
+ ": Needed PVDD_OIS = %f [V] above maximum; set to %f [V]"
+ ": Needed PVDD_OIS= %f [V] below minimum; set to %f [V]"
+ ": cam0_pvdd:%f cam0_sphx:%f cam0_sphy:%f cam0_af_pvdd:%f cam0_af_pvdd2:%f "
+ ": cam0_vdrop_main:%f cam0_vdrop_secondary:%f cam0_vdrop_common:%f cam4_vdrop_common:%f "
+ ": cam1_pvdd_af:%f cam1_af_pvdd:%f "
+ ": cam1_pvdd_ois:%f cam1_sphx_pvdd:%f cam1_sphy_pvdd:%f "
+ ": cam1_vdrop_af:%f cam1_vdrop_ois:%f cam1_vdrop_common:%f "
+ ": cam4_pvdd:%f cam4_af_pvdd:%f "
+ "::ReportEnd Processing Time Stat: %d Recvd, AveProcTime=%llu us, AveOutFrmDelta=%llu us, WorstProcTime=%d us\n\n"
+ "::ReportStart %s (%s):\n"
+ ":CAM1 coil resistance b1:%f b2:%f bz:%f\n"
+ ":External"
+ ":Reserved"
+ "<<<<<<<<<<<<<<< FRAME-%d INFO >>>>>>>>>>>>>>>"
+ "<<<<<<<<<<<<<<< STATS    INFO >>>>>>>>>>>>>>>"
+ "<=: diff %f sample %d\n"
+ "<=== CMMU_LOGGER_FFW_ASSERT from %s\n"
+ "======= AOP Pearl frame version = %d ======="
+ "=================== Debug FFOV v.s OL Initialization ================== "
+ "=================== Debug gdcMapping ================== "
+ "======================================================================== "
+ "============ch %zu config fep for 2nd output fepPipeType %d ================"
+ "===> CMMU_LOGGER_FFW_ASSERT from %s\n"
+ "=> expo params (LUT: %d elts): %.2f x %.2f x %.2f"
+ "=>%f\n"
+ ">: diff %f sample %d\n"
+ "A.height == 1"
+ "A.rowBytes == A.width * sizeof(float)"
+ "A.width == B.width"
+ "A.width == C.width"
+ "A7:AD %x %x %x %x %x %x %x\n"
+ "ABS(((double)cameraCalData.resX / (double)cameraCalData.resY * (double)pConfig->height), (double)pConfig->width) <= 10"
+ "ABS(csConfigs[i].sensorCenterOffsetX, 0) <= chDescr->sensorConfigs[csConfigs[i].config].defaultCropRect.x"
+ "ABS(csConfigs[i].sensorCenterOffsetY, 0) <= chDescr->sensorConfigs[csConfigs[i].config].defaultCropRect.y"
+ "ACTION"
+ "AD GOC"
+ "AD Net  %.3f ms"
+ "AD Post %.3f ms"
+ "AD bypassed immediatly"
+ "AD context created, outputstanding %zu"
+ "AD fake results isUserEngaged %d engagementStatus %d"
+ "AD fr %d ctx %zu IPC Start"
+ "AD fr %d ctx %zu IPC Started aneReqSend %d"
+ "AD init. done."
+ "AD resource init. done"
+ "AD: MmsCfg %d %d %d %d %d %d, useOrig=%d"
+ "AD: Pre-processing failed (e.g, no face), Skip AD"
+ "AD: channel stop failed to clean up internal queue"
+ "AD: fr from pin %zu (%zu|%zu) at %llu"
+ "AD: invalid meta data found"
+ "AD: mean: %f, stddev %f"
+ "AD: meta data section for ATTN not enabled"
+ "AD: pde meta  section (44) not enabled"
+ "ADC GND %d \n"
+ "ADC VRef %d (3276)\n"
+ "ADC reading 0x%x"
+ "ADC_READY masked.\n"
+ "ADDR_ALIGN_UP(kFDInputWidth * kFDInputPixelBytes, 64) == ctx.pBufs[(uint32_t)BufferIndex::PEARL]->Stride(0)"
+ "ADRC2[%u]  tradeoff on AGC only: %u => %u"
+ "ADRC2[%u] Cap offload on exposure for %.2f Hz: %llu => %llu softDGain=%u -> %u"
+ "ADRC2[%u] Cap offload on exposure: %llu => %llu"
+ "ADRC2[%u] TOO MUCH desiredSoftGain => use %u => sifrEIT:%.1f => %.1f EV"
+ "ADRC2[%u] Tradeoff on primary: %llu x %u x %u => %llu x %u x %u clipped:%d,%d"
+ "ADRC2[%u] desiredSoftGain=%u = %.2f EV"
+ "ADRC[%u]    ovrMargin=%.2f vs agc=%.2f EV+ET %.2f EV => return marginET=%.2f"
+ "ADRC[%u]   SIFR ratio=%.2f statsBitDepth=%d => thr=%u"
+ "ADRC[%u]   SNR=%.1f dB for Y>=%.1f in tiles: %.2f %% of Hi res, %.2f of low res"
+ "ADRC[%u]   SNR=%.1f dB for Y>=%.1f in weight: %.2f %% of Hi res, %.2f of low res"
+ "ADRC[%u]   margin_EV_overall(%.2f EV) < margin_EV_analog_gain (%.2f EV) => margin=%.2f EV left"
+ "ADRC[%u]  ====== curBin=%d score=%.3f %% in %d..%d ======"
+ "ADRC[%u]  HR: FORCE CONSTANT: USE Y only => Yfilt:%.2f (%.2f dB)"
+ "ADRC[%u]  ideal HR: maxBin: prim:%d  (%.2f EV) / SIFR=%d (%.2f EV)"
+ "ADRC[%u]  init => alloc histogram buffers"
+ "ADRC[%u] (%ux%u) =>  %ux%u : size changed realloc"
+ "ADRC[%u] (%ux%u) => alloc debug buffers"
+ "ADRC[%u] (%ux%u) => size changed (was %ux%u), realloc"
+ "ADRC[%u] *** [%2d][%5.2f] rec %.2f -shdw:%.2f *%.1f scor=%.3f, scor2=%.3f"
+ "ADRC[%u] == CURR EXPO: %llu xA:%u xD:%u  vs  Orig(%llu *A:%u *D:%u) =="
+ "ADRC[%u] == CURR EXPO: %llu xL:%u xS:%u  vs  Orig(%llu *L:%u *S:%u) =="
+ "ADRC[%u] == CURR SIFR: %llu xA:%u xD:%u  vs  Orig(%llu *A:%u *D:%u) =="
+ "ADRC[%u] == CURR SIFR: %llu xL:%u xS:%u  vs  Orig(%llu *L:%u *S:%u) =="
+ "ADRC[%u] == Cur EIT prim:{sensor=%llu (%.2f) total=%llu (%.2f) sifr=%llu (%.2f) =="
+ "ADRC[%u] === Frame=%d vHDR=%d active=%d ==="
+ "ADRC[%u] === PROCESS SIFR frame=%d clippingDiscontinuity=%d ==="
+ "ADRC[%u] ==== Compute next sifr EIT (# faces=%u) ===="
+ "ADRC[%u] ======== GET STATUS BEFORE STEP ========"
+ "ADRC[%u] => adjusted bin %d\n"
+ "ADRC[%u] => decisionHint=%u"
+ "ADRC[%u] => desired: rel: prim:%.2f sifr:%.2f comb:%.2f"
+ "ADRC[%u] => ol=x%.2f (o:%.2f EV) ET=%.2f (e:%.2f EV)"
+ "ADRC[%u] ADRC results adrc1 %d, adrc2 %d, ori %d"
+ "ADRC[%u] ADRC2: scan %d..%d cur=%d"
+ "ADRC[%u] ADRC[%u]: jump => no TF on next target EIT, step=%.2f EV"
+ "ADRC[%u] ADRCv1 => final SIFR EIT=%llu (EVm:%.2f) / desired=%llu (des:%.2f)"
+ "ADRC[%u] ADRCv1 => finalMain EIT=%llu (%.2f) / before=%llu (%.2f) = %.3f EV"
+ "ADRC[%u] ADRCv1 UNREACHABLE unfilteredNextSifrEV(%.2f) < curSifrEV(%.2f) - v1marginEV(%.2f)"
+ "ADRC[%u] ADRCv1 asks for underex: %d >= orig=%d => use v1"
+ "ADRC[%u] ADRCv2 => final SIFR EIT=%llu (EVm:%.2f) / desired=%llu (des:%.2f)"
+ "ADRC[%u] ADRCv2 asks for overex: %d >= orig=%d => use orig"
+ "ADRC[%u] ADRCv2 off => Use v1 = %d"
+ "ADRC[%u] Best candidate = %d"
+ "ADRC[%u] BrightLight: adjust sifrTargetEIT:%llu (out:%.2f) => %llu (out:%.2f)"
+ "ADRC[%u] Camera switch: updated nextSifrTargetEIT=%llu (%.2f), no further computation needed"
+ "ADRC[%u] Cannot find local max from previous best: %d (%.3f %%)"
+ "ADRC[%u] Change best: %d (%.3f %%) => %d (%.3f)"
+ "ADRC[%u] Clipping jump(%u)=>check the temporal filtering"
+ "ADRC[%u] Cur: %.2f EV overall/max=%.2f ; %.2f EV on ET/max=%.2f AGC=%.2f => ADRC1Marg=%.2f"
+ "ADRC[%u] Cur=%d / orig=%d => scan %d..%d"
+ "ADRC[%u] DESIRED -=%.2f curSifrEV=%.02f (EIT %llu)=>unfilt=%.02f filt=%.02f"
+ "ADRC[%u] DESIRED fc=%d isSifrAltSkipMode=%d curSifrEV=%.2f => raw=%.2f / filt=%.2f"
+ "ADRC[%u] DESIRED step=%.3f EV/ maxstep=%.3f fc=%u clipDisc=%u"
+ "ADRC[%u] ETTR => tradeoff limits: use (EIT:%.1f EV ExpTime=%.2f EV)"
+ "ADRC[%u] ETTR: use maxBin_RGB=%d"
+ "ADRC[%u] EV to apply %.3f, margin for ADRC2=%.3f"
+ "ADRC[%u] FILT: Step=%.4f => nextSifrTargetEIT=%llu (%.2f EV)"
+ "ADRC[%u] FINAL: all sifr ch => bin=%d => SIFR by %.3f EV clears 1 ch"
+ "ADRC[%u] FINAL: one prim ch for HR => bin=%d => PRIM by %.3f EV clears all"
+ "ADRC[%u] FIRST ACTIVATION|jump=%u: fr: %u, set filtered=cur=%.2f EV + update"
+ "ADRC[%u] Final adjust: adrc:%.2f => ajusted=%.2f"
+ "ADRC[%u] Final: nextSifrTargetEIT=%llu = %.2f overEx=+%.2f update=%u status=0x%x"
+ "ADRC[%u] GO FOR OVER-EXPOSURE:  OverEx=%.2f"
+ "ADRC[%u] HR/AbsY: => on cur, shadows=%.2f %% max: %.2f %%"
+ "ADRC[%u] HR: mainTargetEIT=%llu >= currentMainEIT=%llu => overex"
+ "ADRC[%u] New best candidate at %d: score=%.3f %%"
+ "ADRC[%u] No candidate found, stay at current position? (curBin=%d)"
+ "ADRC[%u] No update but nextSifrTargetEIT=%llu (%.3f EV)"
+ "ADRC[%u] Orig: %llu %d Cur: %llu %d %d realizedEV %.3f"
+ "ADRC[%u] Orig: e%llu a%u d%u vs cur=%llu a=%u d=%u"
+ "ADRC[%u] Orig: e:%.1f a:%.1f d:%.1f vs cur e=%.1f a=%.1f d=%.1f EV"
+ "ADRC[%u] Realized:%.2f EV (%.2f on Exp) vs marginV1:%.2f..%.2f EV"
+ "ADRC[%u] SIFRTurnOff: adjust sifrTargetEIT:%llu (out:%.2f) => %llu (out:%.2f)"
+ "ADRC[%u] Switch mode: %d => %u"
+ "ADRC[%u] TL/JUMP(clippingDiscontinuity=%u) ==> recompute range: from origSifr=%llu x %u"
+ "ADRC[%u] Take ADRC1 results: %d"
+ "ADRC[%u] Take ADRC2 results: %d=%d"
+ "ADRC[%u] Tradeoff on Primary: %.1f x %u x %u => %llu x %u x %u"
+ "ADRC[%u] Tradeoff on Primary: sg %u => sg %u; EV %.3f"
+ "ADRC[%u] Tradeoff on Sifr: %llu x %u x %u => %llu x %u x %u"
+ "ADRC[%u] UNREACHABLE unfilteredNextSifrEV(%.2f) < curSifrEV(%.2f) - marginEV(%.2f)"
+ "ADRC[%u] Unfilt: v1:%.2f%% primary clipped, v2: %.2f%%, %.2f%% SIFR clipped"
+ "ADRC[%u] WARNING: Uninitialized tradeoff limits => update (EIT:%u ExpTime=%u)"
+ "ADRC[%u] Yfactor=%f, orig exp %llu AG %d DG %d ==> projected DG %d."
+ "ADRC[%u] Yfactor=%f, orig exp %llu LG %d SG %d ==> projected SG %d."
+ "ADRC[%u] acptbleBin=%d => %.2f EV = rel bin %d, (last-orig) %d"
+ "ADRC[%u] adrc eit clipped to input %llu (%d Hz, flicker eit %llu)"
+ "ADRC[%u] adrc eit clipped to input %llu (sifr turnoff at %llu)"
+ "ADRC[%u] adrc eit interpolated to %llu (sifr turnoff at %llu)"
+ "ADRC[%u] adrc eit soft adjusted to %llu (%d Hz, flicker eit %llu)"
+ "ADRC[%u] analog=%u * %u/256 <? desired=%u"
+ "ADRC[%u] bAllowAdaptiveDRv2=%d bAllowADRv2PerMode=%d curTablEntry=%d"
+ "ADRC[%u] bin ADRCv1:%d ADRCv2:%d => use max=%d"
+ "ADRC[%u] bin ADRCv2:%d < curExpoBin=%d => use v2"
+ "ADRC[%u] bin out of range warning"
+ "ADRC[%u] curSifrEV=%.2f, next=%.2f => scan %d..%d, curMovedTo%d orig=%d"
+ "ADRC[%u] currentMainEIT=%llu / prevMainEIT=%llu"
+ "ADRC[%u] des+=%.2f clamp unfilt=%.2f in curSifEV=%.2f +/- v1:-%.2f v2:+%.2f"
+ "ADRC[%u] eit %llu ==> expo without flick: %llu x %u x %u"
+ "ADRC[%u] expo without flick: %llu x %u x %u"
+ "ADRC[%u] lastAccpBin<0: goto min2(curExpoBin=%d, maxBin_OnePrimaryChannel=%d)=%d"
+ "ADRC[%u] marginEV ADRCv1 %.3f, ADRCv2 %.3f"
+ "ADRC[%u] maxOverExposureEV=%.1f exposureTimeOffloadEV=%.1f => ADRC2MarginEV=%.1f"
+ "ADRC[%u] no overex => minBin=%d"
+ "ADRC[%u] no sifr"
+ "ADRC[%u] no update needed, keep nextSifrTargetEIT=%llu (%.2f)"
+ "ADRC[%u] origExpoBin=%d"
+ "ADRC[%u] original EV to apply %.3f"
+ "ADRC[%u] prev=%d new=%d change direction !!"
+ "ADRC[%u] prevSifrEIT=%llu (%.2f) / curSifrEIT=%llu (%.2f)"
+ "ADRC[%u] prevSifrEIT=%llu / curSifrEIT=%llu => offset=%d bins"
+ "ADRC[%u] primaryMinForSatHist %d, primarySaturationThreshold %d"
+ "ADRC[%u] ratio=%.2f , margin=%.2f EV => in SIFR: clip:%d / reachable=%d : %.2f %%"
+ "ADRC[%u] ratio=%.2f inSifrEIT=%llu (%.2f)/ mainEIT=%llu (%.2f)"
+ "ADRC[%u] ratio=%.2f margin=%.2f EV => in SIFR: clip:%d / reachable=%.1f"
+ "ADRC[%u] real: %.2f => desired: abs: prim:%.2f sifr:%.2f comb:%.2f"
+ "ADRC[%u] roi:%d,%d+%dx%d => %d,%d..%d,%d"
+ "ADRC[%u] score threshold=%.3f %% tiles, scan %d..%d, curBin=%d, origBin=%d"
+ "ADRC[%u] sifrMinForSatHist %d, sifrSaturationThreshold %d"
+ "ADRC[%u] sifrTargetEIT=%llu < turnOffRampEIT=%llu (mainEIT=%llu / ramp:%llu..%llu)"
+ "ADRC[%u] sifrTargetEIT=%llu > minSifrTargetEITforHalfStopUnder=%llu (underR=%.3f)"
+ "ADRC[%u] siftEIT=%llu invBinFactor=%u=%.3f eit[%d].invBinF=%u=%.3f"
+ "ADRC[%u] siftEIT=%llu sifrEV=%.2f invBinFactor=%u=%.3f eit[%d].invBinF=%u=%.3f"
+ "ADRC[%u] stab=%d range(thresh)=%.3f desd=%.4f =>upd=%u maxSt=%.2f flg=0x%x"
+ "ADRC[%u] stable=%d => stability range(threshold)=%.3f EV / desired=%.4f"
+ "ADRC[%u] status_EVm_ratio %f"
+ "ADRC[%u] tableType=%d / TableEntry=%d ADRCv2PerMode=%d"
+ "ADRC[%u] tooDark=%.3f <? %.3f  clipped=%.3f>0.03f => vHDROn=%d"
+ "ADRC[%u] type:%d, entr:%u => tradeoff limits: use (EIT:%u ExpTime=%u)"
+ "ADRC[%u] upd=%d real:%.2f desrd+=%.2f nextSifrTargetEIT=%llu = %.2f"
+ "ADRC[%u] useAbsoluteYforNoise count=%u sumW=%u"
+ "ADRC[%u]:%s:%d: ROI: %d,%d..%d,%d"
+ "ADRCv2: main %llu %d sifr %llu %d, gainDown %d"
+ "AE cached luxlevel %.4f for ch %zu"
+ "AE-IR: BKT (%d)(%u, %u, %u, %u, %u)(%d)\n"
+ "AE-IR:SetProjectorRepeatSequence[%d] = e %llu(%u us), v %d, g 0x%x, p %d\n"
+ "AE2TW ch=%zu, INVALID CHANNEL"
+ "AE2TW ch=%zu, f# %d, luxLevel %.2f, sens %.3f fps, hmeta %d, en=%d\n"
+ "AE2TW: ch=%zu Internal rec:%d FPS=%.3f fps\n"
+ "AE2TWBBufRcvd"
+ "AE2TWBufDone"
+ "AE:MUB: - ch %d:\n"
+ "AE:MUB: --- %d, %d, %d, %d, %d, (%d,%f,%f), %f, %d, %d, agLimit %f, fp %d, hr %d\n"
+ "AEAPPLE"
+ "AESettingsUpdate"
+ "AEStatsHelper"
+ "AETable_Default_Regular_FFC"
+ "AETable_Default_Regular_Qsub_SWide"
+ "AETable_Default_Regular_Qsub_Tele"
+ "AETable_Default_Regular_Qsub_Wide"
+ "AETable_Default_Regular_SWide"
+ "AETable_Default_Regular_Tele"
+ "AETable_Default_Regular_Wide"
+ "AETable_Exp_Time_Priority_FFC"
+ "AETable_Exp_Time_Priority_SWide"
+ "AETable_Exp_Time_Priority_Tele"
+ "AETable_Exp_Time_Priority_Wide"
+ "AETable_HFR_Regular_FFC"
+ "AETable_HFR_Regular_Qsub_SWide"
+ "AETable_HFR_Regular_Qsub_Tele"
+ "AETable_HFR_Regular_Qsub_Wide"
+ "AETable_HFR_Regular_SWide"
+ "AETable_HFR_Regular_Tele"
+ "AETable_HFR_Regular_Wide"
+ "AETable_LLV_Regular_FFC"
+ "AETable_LLV_Regular_Qsub_SW_IMX972"
+ "AETable_LLV_Regular_Qsub_Tele_IMX973"
+ "AETable_LLV_Regular_Qsub_Wide"
+ "AETable_LLV_Regular_SW_IMX972"
+ "AETable_LLV_Regular_Tele_IMX973"
+ "AETable_LLV_Regular_Wide"
+ "AETable_Pano_Regular_SWide"
+ "AETable_Pano_Regular_Wide"
+ "AETable_Photo_Flash_FFC"
+ "AETable_Photo_Flash_SW"
+ "AETable_Photo_Flash_Tele"
+ "AETable_Photo_Flash_Wide"
+ "AETable_Photo_Long_FFC"
+ "AETable_Photo_Long_Qsub_SW_IMX972"
+ "AETable_Photo_Long_Qsub_Tele_IMX973"
+ "AETable_Photo_Long_Qsub_Wide"
+ "AETable_Photo_Long_SW_IMX972"
+ "AETable_Photo_Long_Tele_IMX973"
+ "AETable_Photo_Long_Wide"
+ "AETable_Photo_Regular_FFC"
+ "AETable_Photo_Regular_QsubHiRes_SW_IMX972"
+ "AETable_Photo_Regular_QsubHiRes_Wide"
+ "AETable_Photo_Regular_Qsub_SW_IMX972"
+ "AETable_Photo_Regular_Qsub_Tele_IMX973"
+ "AETable_Photo_Regular_Qsub_Wide"
+ "AETable_Photo_Regular_SW_IMX972"
+ "AETable_Photo_Regular_Tele_IMX973"
+ "AETable_Photo_Regular_Wide"
+ "AETable_Timelapse_Long_FFC"
+ "AETable_Timelapse_Long_SWide"
+ "AETable_Timelapse_Long_Tele"
+ "AETable_Timelapse_Long_Wide"
+ "AETable_Timelapse_Regular_FFC"
+ "AETable_Timelapse_Regular_Qsub_SWide"
+ "AETable_Timelapse_Regular_Qsub_Tele"
+ "AETable_Timelapse_Regular_Qsub_Wide"
+ "AETable_Timelapse_Regular_SWide"
+ "AETable_Timelapse_Regular_Tele"
+ "AETable_Timelapse_Regular_Wide"
+ "AETable_VFR_Regular_FFC"
+ "AETable_VFR_Regular_Qsub_SW_IMX972"
+ "AETable_VFR_Regular_Qsub_Tele_IMX973"
+ "AETable_VFR_Regular_Qsub_Wide"
+ "AETable_VFR_Regular_SW_IMX972"
+ "AETable_VFR_Regular_Tele_IMX973"
+ "AETable_VFR_Regular_Wide"
+ "AETable_pano_Tele_IMX973"
+ "AEUpdateSplitAndEnqueDropBKT"
+ "AEUpdateSplitAndEnqueRepeatingIR"
+ "AEUpdateTrigger"
+ "AEWIndow %d is Disabled"
+ "AEWIndow %d is Enabled %d %d"
+ "AE[%d]"
+ "AE[%u]/TL:  frSz=%u > maxVrFrH=%u => force quantif of maxFrH"
+ "AE[%u]/TL:  nb=0!  maxVrFrH=%u vs frSz=%u => nb=%llu/%u => %llu"
+ "AE[%u]/TL:  nb=0!  maxVrFrH=%u vs frSz=%u => nb=%llu/%u+1 => %llu"
+ "AE[%u]/TL:  nb==0, nb=q(%llu)/maxVFrH(%u)=%llu => quantFrSz=%u"
+ "AE[%u]/TL: =>out=vFrSz=%u vs nonQ=%u=MIN(MAX(min=%u, vFrSzFromExp=%u), maxVFrH=%u)"
+ "AE[%u]/TL: ADRC: Too fast: clipping to %.03f st/samp=%.03f st/fr"
+ "AE[%u]/TL: ADRC: Too slow, don't freeze convergence => %.3f EV = >%.3f"
+ "AE[%u]/TL: ADRC: desired=%.3f, st/spl=%.3f, decim=%.2f"
+ "AE[%u]/TL: ADRC: sampling=%.3f / fr=%.3f dec=%.2f"
+ "AE[%u]/TL: Frame size may chg: cur=%u=%.2f fps => %u (%.1f) / nonQ=%u (%.1f)"
+ "AE[%u]/TL: I=%.2fs => quant=%llu (1Hz=%llu)/frSz=%u => nb=%llu"
+ "AE[%u]/TL: ISP_PROPERTY_TIMELAPSE_AE_SAMPLINGRATE(%u)\n"
+ "AE[%u]/TL: ISP_PROPERTY_TIMELAPSE_AE_SMOOTHING(%u)\n"
+ "AE[%u]/TL: Long Exposure => use AE Table CISPCMD_AE_SET_TABLE_TIMELAPSE_LONGEXPO"
+ "AE[%u]/TL: NonQ=%u / cur=%u => need more space: %u (%.1f->%.1f fps)"
+ "AE[%u]/TL: NonQ=%u: NOT enough margin, refuse reducing to %u (%.1f->%.1f)"
+ "AE[%u]/TL: NonQ=%u: enough margin, accept reducing: %u => %u (%.1f->%.1ffps)"
+ "AE[%u]/TL: Too fast: clipping to %.03f st/samp=%.03f st/fr=%u"
+ "AE[%u]/TL: in=%u Q=%llu * %.1fs=%llu => %llu xQ => %u"
+ "AE[%u]/TL: normal Exposure => use AE Table CISPCMD_AE_SET_TABLE_TIMELAPSE"
+ "AE[%u]/TL: quantifiedFrameSize == 0 => return frmSize=%u =%.3f"
+ "AE[%u]/TL: reqGain=%u=%.3f final=%u=%.3f st/fr:%.3f st/spl=%.3f (dec=%.2f)"
+ "AE[%u]/TL: sampling=%.3f / fr=%.3f dec=%.1f=>speedFrameRateAdjustFactor=%.3f"
+ "AE[%u]/TL: smpl=%.3f => frSz: cur=%u (fps=%.2f) => cand=%u (fps:%.1f) / nonQ=%u (%.1f)"
+ "AE[%u]/TL: vrtFrmWidth=%u => requested FPS=%.3f"
+ "AE[%u]/TL: {%.1fms xA %.1f} +[%.1f ms *A %.1f]: vFrS=%u+%u=%u"
+ "AE[%u]/TUN     Sifr(type=%d) [%u] storing %.3f x %.2f"
+ "AE[%u]/TUN     primary(type=%d)  [%u] storing %.3f x %.2f"
+ "AE[%u]/TUN   Same table for SIFR: use primary[%d](type=%d)"
+ "AE[%u]/TUN   Store table for tableType_Sifr=%d: %p / %u"
+ "AE[%u]/TUN   done"
+ "AE[%u]/TUN   storing table for [tableStorage_Sifr=%d]: TableEntry=%u"
+ "AE[%u]/TUN  ch %u normal reset for tableType=%d, TableEntry=%d"
+ "AE[%u]/TUN  slave=%zu tuning=> primary={tb=0x%x cnt=%d}"
+ "AE[%u]/TUN  slave=%zu tuning=> sifr:{tb=0x%x cnt=%u}"
+ "AE[%u]/TUN  tuning=> [%d]: primary={tb=0x%x cnt=%d}"
+ "AE[%u]/TUN  tuning=> [%d]:Sifr:{tb=0x%x cnt=%u}"
+ "AE[%u]/TUN %s: ch=%zu tableType=%d cnt=%u entry=%u sensorReadoutMode=%d\n"
+ "AE[%u]/TUN ==== PRIMARY: store in ExpGainLUT[storage=%d for tableType=%d]: %d elements."
+ "AE[%u]/TUN ==== SIFR: tb_Sifr=%p %u elt. Storage [%d]"
+ "AE[%u]/TUN Cross mapping of storage: type=%d => storage[%d]"
+ "AE[%u]/TUN ERROR: no tuning service"
+ "AE[%u]/TUN ERROR: no tuning service for channel %zu"
+ "AE[%u]/TUN Reading tuning for tableType=%d"
+ "AE[%u]/TUN Set default AE integration tables"
+ "AE[%u]/TUN Using preset table for ch=%zu"
+ "AE[%u]/TUN Using provided table for ch=%zu: tb=%p, tbSize=%u"
+ "AE[%u]/TUN ch %u Type=%d, minAGC=4 =>force Type=CUSTOM_AE Entry=SET_TABLE_PANORAMA"
+ "AE[%u]/TUN reset to FW deflt tab ch=%zu type=%d Entry=%u"
+ "AE[%u]/VFR LLVideo: vSize constrainted to %d, fps=%.1f"
+ "AE[%u]/VFR minFPS=%d maxFPS=%d curFPS=%d"
+ "AE[%u]/VFR minFrameRate=%d =>  Use 25 fps"
+ "AE[%u]/VFR minFrameRate=%d => Use 50 fps"
+ "AE[%u]/VFR vFrameSize=%u / virtFrmHeight=%u & maxVirtFrmHeight=%u"
+ "AE[%u]/VFR vSize clamped to %d, vH %d maxVH %d flick:%.1f Hz %.2f fps"
+ "AE[%u]: change isExpandedAETableTuning %d to %u\n"
+ "AE[%u]==== Print out input RAW tile stats for AE debug --> B channel ===="
+ "AE[%u]==== Print out input RAW tile stats for AE debug --> G channel ===="
+ "AE[%u]==== Print out input RAW tile stats for AE debug --> R channel ===="
+ "AE[%u]B:L%02d,C%d... %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u],"
+ "AE[%u]B:L%02d,C%d[%u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u..."
+ "AE[%u]G:L%02d,C%d... %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u],"
+ "AE[%u]G:L%02d,C%d[%u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u..."
+ "AE[%u]R:L%02d,C%d... %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u],"
+ "AE[%u]R:L%02d,C%d[%u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u..."
+ "AE_REPEAT_SEQUENCE_SEND"
+ "AF Tile DMA %d and OutSel %d check failed"
+ "AF Tile fc:%d AftileEn:%d"
+ "AF new Stats Enabled :%d ch:%d fc:%d"
+ "AFDBG CH[%zu]: CNR FC=[%d] cnrFDist=[%d][cm] cnrFocusPos=[%d] maxFocusPos=[%d] intent=[%d]\n"
+ "AFDBG CH[%zu]: FOCUS_LOCK_DEFER: lock=[%d] startTime=[%lld] currTime=[%lld] deltaTime=[%d<TL=%d]\n"
+ "AFDBG CH[%zu]: FOCUS_LOCK_START: lock=[%d] lockStartTime=[%lld]\n"
+ "AFDBG CH[%zu]: FOCUS_LOCK_TIMEOUT: lock=[%d] startTime=[%lld] currTime=[%lld] deltaTime=[%d>TL=%d]\n"
+ "AFDBG CH[%zu]: FocusNow pdafEn=[%d] lock=[%d] lockTime=[%d] strict=[%d] method2=[%d] direction=[%d] intent=[%d] speed=[%d] cmdTag=[%x]\n"
+ "AFDBG CH[%zu]: HARD HYPERFOCAL LOCK\n"
+ "AFDBG CH[%zu]: High zoom with densified points\n"
+ "AFDBG CH[%zu]: [TAG DONE] tagState=[%d] lastTag=[%x] newTag=[%x]\n"
+ "AFDBG CH[%zu]: [TAG HOST] tag=[%08x] hostTag=[%08x]\n"
+ "AFDBG CH[%zu]: [TAG STATE] tagState=[%d] lastTag=[%x] newTag=[%x]\n"
+ "AFDBG CH[%zu]: obstructedProjector=[%d]\n"
+ "AFDBG CH[%zu]: quadraBin=[%d] rs_trigger_zThresh=[%f]\n"
+ "AFDBG CH[%zu]: target ∆ [pos, um, coc]=[%0.2f, %0.2f, %0.2f] focusCheck=[%d]\n"
+ "AFE - %s %s %s (total: %d), Tunable Mode %d "
+ "AFEBufferMalloc"
+ "AFEDMA"
+ "AFEPROC"
+ "AFEProcAlgoControlInit"
+ "AFEProcBufferConfig"
+ "AFEProcDrv: addr %p bank %d"
+ "AFEProcEnd"
+ "AFEProcProcess"
+ "AFEProcSetup"
+ "AFEProcSetup for ch %zu dest %d"
+ "AFEProcSetup for ch %zu src %x insel %d dest %d"
+ "AFTER setting with commonDbgModes: channel =%zu dbgModes:"
+ "AFTile ch %zu window start [%d, %d], end [%d, %d], winWd [%d, %d], NumTiles [%d, %d]\n"
+ "AFWIndow %d is disabled"
+ "AFWIndow %d is enabled"
+ "AHFD is DEPRECATED in H17"
+ "ALGO: "
+ "ALGOCTRLCh"
+ "ALGOCTRLSERVERCh"
+ "ALGOCTRLSERVER_BUFFER"
+ "ALGOCTRLSERVER_IDLE"
+ "ALGOCTRLSERVER_PROCESS"
+ "ALGOCTRLSERVER_PROC_DONE"
+ "ALGOCTRLSERVER_READY"
+ "ALGOCTRLSERVER_START"
+ "ALGOCTRLSERVER_STOP"
+ "ALGOCTRL_BUFFER"
+ "ALGOCTRL_GO_WAITING"
+ "ALGOCTRL_IDLE"
+ "ALGOCTRL_PREPARE"
+ "ALGOCTRL_PREP_DONE"
+ "ALGOCTRL_PROCESS_GO"
+ "ALGOCTRL_PROCESS_NEXT_PASS"
+ "ALGOCTRL_PROCESS_NEXT_STEP"
+ "ALGOCTRL_READY"
+ "ALGOCTRL_RESOURCE_READY"
+ "ALGOCTRL_RESOURCE_WAITING"
+ "ALGOCTRL_START"
+ "ALGOCTRL_STOP"
+ "ALGOCTRL_WAIT_GO"
+ "ALGOCTRL_WAIT_RESOURCE"
+ "ALIGN_DOWN(pointer, CMMU::CacheLineSize()) == pointer"
+ "ALL_CPU(%)"
+ "ALS sensor %zu data recived [%llu, %u, %u, %u, %u, %u]."
+ "ANE_NET_AICAM_SSD"
+ "ANE_NET_ANFD2_ATTR"
+ "ANE_NET_ANFD2_OD"
+ "ANE_NET_ANFD2_SAL"
+ "ANE_NET_ANFD2_SSD"
+ "ANE_NET_ANFD2_TRK_EXEMPLAR"
+ "ANE_NET_ANFD2_TRK_XCORR"
+ "ANE_NET_ANFD_ATTR"
+ "ANE_NET_ANFD_TRK_EXEMPLAR"
+ "ANE_NET_ANFD_TRK_XCORR"
+ "ANE_NET_ANOD4_ATTR"
+ "ANE_NET_ANOD4_SAL"
+ "ANE_NET_ANOD4_SSD"
+ "ANE_NET_ANOD4_TRK_EXEMPLAR"
+ "ANE_NET_ANOD4_TRK_XCORR"
+ "ANE_NET_ANST_ANST"
+ "ANE_NET_ANST_ATTR"
+ "ANE_NET_MLAF"
+ "ANE_NET_MLAF_TELE"
+ "ANE_NET_MLVNR"
+ "ANE_NET_SLAF"
+ "ANE_NET_SV_SEG"
+ "ANE_NET_T287_AD"
+ "ANE_NET_T287_AD_LANDSCAPE"
+ "ANE_NET_T287_ER"
+ "ANE_NET_T287_FD2D"
+ "ANE_NET_T287_FD3D"
+ "ANE_NET_T287_GD"
+ "ANE_NET_T287_LO"
+ "ANE_NET_T287_OD"
+ "ANST FOV in ClrProc (%d %d %d %d), in Sensor Raw  (%d %d %d %d)"
+ "ANST delay 5ms to re-try initialization\n"
+ "ANST frSkip BYPASS fr %d"
+ "ANST init. done."
+ "ANST process timeout!"
+ "ANST thumbnail copy is done but failed to retrieve Src buffer out of the queue"
+ "ANST thumbnail copy is done but failed to retrieve dst buffer out of the queue"
+ "ANST unrecognized cmd %zu\n"
+ "ANST: model not init."
+ "ANSTBufRcvd"
+ "ANSTEventLogger"
+ "ANSTThumbnailEnable"
+ "AOP Already Sub. to proximity"
+ "AOP Already sub. to Detection Mode"
+ "AOP Control data version = %d ifNum = %lu"
+ "AOP I2C Write response cmdPacketLen(%d) payLoadSize(%d) Type(%d) Sequence(%d)"
+ "AOP Loopback Cmd Input: Len %zu"
+ "AOP Loopback Cmd Output: Len %zu"
+ "AOP PEARL: PearlCmd WriteMsg sts  = %d"
+ "AOP Pearl: pkt 0x%x SubPkt %d Len %d, payLoad %d (%lu) seq %d"
+ "AOP Prox %d type %d detectionMode %d timestampe %llu"
+ "AOP Read from Motion Service"
+ "AOP Rec kSpuPacketTypeDopplerStateReport"
+ "AOP Receive OSCAR data"
+ "AOP Receive Raw Packet"
+ "AOP Response sts = %x, %.3fms"
+ "AOP Sub. Detection Mode Success"
+ "AOP Sub. to Proximity Success"
+ "AOP Unsub. Detection Mode Success"
+ "AOP Unsub. Proximity Success"
+ "AOP loopback writeMessage sts  = %d"
+ "AOP signal received"
+ "APE(ExStats): ch%d: spdNotActive                   : %d \n"
+ "APP controlled"
+ "APSSetFieldCurvatureCalData"
+ "ARE_CHANNELS_IN_SAME_GROUP(pcaeRec, caeRec[targetCh])"
+ "ARMED"
+ "ATTACH: ch %zu fep %d"
+ "ATTACH: ch %zu fep %d addr %p DMA 0x%zx"
+ "ATTR procedureId %u"
+ "AUSTIN_SYSCTL_TP_VER: %d"
+ "AUX: [%d %d %d %d] -> %dx%d  OutDMA [%d %d %d %d]\n"
+ "AVERAGE"
+ "AWB Hostemetadata copy from statsMaster %d to slave %u done!"
+ "AWB RESET: CAWBAFE::InitialReset"
+ "AWB RESET: CAWBAFE::MinimalReset isAWBSchemeSet=%hhu awbScheme=%d"
+ "AWB RESET: CAWBAFE::~CAWBAFE"
+ "AWB RESET: CAWBAFEH16 (%p)::MinimalReset"
+ "AWB RESET: CAWBAFEH16::CAWBAFEH16 name(%s)"
+ "AWB RESET: CAWBAFEH16::InitialReset"
+ "AWB RESET: CAWBAFEH16::~CAWBAFEH16"
+ "AWB RESET: CAWBApple::CAWBApple channel %zu calling CAWBAFEH17::CAWBAFEH17"
+ "AWB RESET: CAWBApple::~CAWBApple channel %zu calling CAWBAFEx::~CAWBAFEx"
+ "AWB RESET: ch=%d CAWBApple::CmdReset calling CAWBAFEx::MinimalReset"
+ "AWB RESET: ch=%d CAWBApple::FSMStart calling CAWBAFEx::MinimalReset"
+ "AWB RESET: ch=%d master=%d prevSyncTag=%d isFirstFrame=%d"
+ "AWB SYNC: CCM=%5d %5d %5d s_CCM=%5d %5d %5d \n"
+ "AWB SYNC: SkyWBGain=%5.2f %5.2f s_skyWBGain=%5.2f %5.2f"
+ "AWB SYNC: WBGain=%5d %5d s_WBGain=%5d %5d s_comboWBGain=%5d %5d"
+ "AWB SYNC: ch=%d request=%d CAWBApple calling ProcessMatchingSlaveCameraAWBParam"
+ "AWB SYNC: ch=%d request=%d CAWBAppleFSM calling ProcessMatchingSlaveCameraAWBParam"
+ "AWB SYNC: ch=%d syncID=%d MSSyncGet=%d"
+ "AWB SYNC: masterCh=%d hostMeta.slaveChannelId[%d]=%d"
+ "AWB SYNC: masterCh=%d slaveCh=%d"
+ "AWB SYNC: pAWBMetaData=%p"
+ "AWB SYNC: pHostMetaData=%p"
+ "AWB TS multi-cam matching data are not valid."
+ "AWB metadata for ch=%zu (isPreviewChannel=%hhu, isStatsPrimary=%hhu) set."
+ "AWB-Flash: isFlashOn=%hhd flashStatus= 0x%2x lux=%6hu luxLow=%6hu luxHigh=%6hu"
+ "AWB-GW: CCMCoeff[2][0]= %f %f %f sum=%f"
+ "AWB-GW: GW-R=%.2f GW-G=%.2f GW-B=%.2f rn=%.2f bn=%.2f cct=%u"
+ "AWB-GW: bgCalGain=%.2f bgGain=%.2f totalBgGain=%.2f"
+ "AWB-GW: rgCalGain=%.2f rgGain=%.2f totalRgGain=%.2f"
+ "AWB-GW: sumR=%.2f sumG=%.2f sumB=%.2f"
+ "AWB-Torch: isTorchOn=0x%x for ch=%hhu, torchCounter=%u, torchConvergence=%hhu"
+ "AWB2TWBBufRcvd"
+ "AWB2TWBufDone"
+ "AWB: LEDMainFlash=%1hhu ratio=%6.4f pmCalibValid=%1hhu ambientlux=%hu %hu %hu flashLux=%hu %hu %hu"
+ "AWB: Tile STATS meanRGB=[%6.2f,%6.2f,%6.2f]"
+ "AWB: ambient ccm=%d %d %d flash ccm=%f %f %f"
+ "AWB: ambient wbGain=%u %u flash wbGain=%u %u"
+ "AWB: ch=%d fn=%d fusionFn=%d fusionMatrix[0, 4, 2, 5]=[%f, %f, %f, %f]"
+ "AWB: ch=%d set cache control to %d"
+ "AWB: ch=%hhu fn=%4u mS=%hhu mP=%hhu lux/rn/bn/wbGain= %6d %.2f %.2f %.2f %.2f"
+ "AWB: ch=%hhu fn=%u Default=%hhu Valid=%hhu Bypass=%hhu MatchSlave=%hhu bSlave=%hhu stfEnabled=%hhu"
+ "AWB: ch=%hhu fn=%u awbFn=%hu mS=%hhu mP=%hhu scheme=%u lux=%hu luxFloat=%6.2f, colorspace=%d"
+ "AWB: ch=%hhu fn=%u in=%hhu cur=%hhu past=%hhu out=%hhu dayS=%6.4f lightS=%6.4f iniWP=%u"
+ "AWB: ch=%hhu fn=%u lux=%hu RGain=%u BGain=%u ccm[0]=%6d ccm[4]=%6d ccm[8]=%6d"
+ "AWB: ch=%hhu fn=%u rgGainWP=%.2f bgGainWP=%.2f gwRG=%.2f gwGG=%.2f gwBG=%.2f"
+ "AWB: ch=%hhu fn=%u rn=%6.2f bn=%6.2f rgG=%u bgG=%u cct=%u usePrev=%hhu stable=%hhu"
+ "AWB: enable=%hhu cache=%hhu, rn=%.2f bn=%.2f WBGain=%u %u %u"
+ "AWB: torchStatus=%hu torchCounter=%u torchConvergence=%hhu luxLevel=%hu"
+ "AWB:Flash:Cached fn=%d ch=%d GetInternalAWB= %.2f %.2f"
+ "AWB:Flash:Restore ch=%zu GetInternalAWB= %.2f %.2f"
+ "AWBAPPLE"
+ "AWBWinWH=%u,%u tileRegWH=%u,%u tileOffsetXY=%u,%u statWinWH=%u,%u\n"
+ "AWBWindow[%d], x=%d, y=%d, w=%d, h=%d. startX %d startY %d endX %d endY %d sifr:%d\n"
+ "AWBWindow[%d], x=%d, y=%d, w=%d, h=%d. startX %d startY %d sifr:%d\n"
+ "AWB_Process"
+ "AWB_TS: ch=%hhu F=%p D=%p "
+ "Abort"
+ "Aborted!"
+ "Absolute current update. Resetting Ratio"
+ "AcANSTControl::besCropInfo %f %f %f %f"
+ "AcANSTControl::originalImage (%u %u)"
+ "AcCopyNetOut"
+ "AcDumpNetOut"
+ "AcPrintResult"
+ "AccelerateVE LVT filter used."
+ "AccessTable"
+ "AcquireRegistrationResource"
+ "Act: %u Exp: %u"
+ "ActBuf %d (Idx %d) Invalid buffer Idx, Skipping"
+ "ActBuf %d (Idx %d) addr %p stride %d fmt %d w %d h %d"
+ "ActBuf %d (Idx %d) addr %p stride %zu fmt %d w %d h %d"
+ "Action Item %d opId %d"
+ "ActionBuf %d offset %d w %d h %d s %d fmt %d "
+ "ActivateExtendedADRCForPhoto"
+ "Active channels mask:0x%x"
+ "Active streaming channel %zu"
+ "Ad Post  %.3f ms %.3f ms"
+ "Ad Pre  %.3f ms"
+ "AdFrameProcessor"
+ "AdPostProcessor"
+ "AdaptiveSwitchInVideo"
+ "AdaptiveSwitchSensorCropDisable"
+ "Add Lens XY Position Here for Task %s\n"
+ "AddHalfStopBiasForBrightLight"
+ "AddLenXYPos"
+ "AddOrModifyOneConfig"
+ "AddROI"
+ "AdjustAEGainsHelper"
+ "AdjustAELinearSoftGainsHelper"
+ "AdjustBackendCrop"
+ "AdjustEITParams"
+ "AdjustEITParams exposure %.3f ms, gA %d gD %d gSS %d EIT %f slowSyncEnabled %d, slowSyncEnabledByPRW %d, flip %d\n"
+ "AdjustEITParams exposure %.3f ms, gL %d gS %d gSS %d EIT %f slowSyncEnabled %d, slowSyncEnabledByPRW %d, flip %d\n"
+ "AdjustExposure"
+ "AdjustExposureToBlank"
+ "AdjustGridForCurrentFrame"
+ "AdjustParamsForMainFlash"
+ "AdjustSlaveTiming"
+ "AdjustWindowForPreISPCrop"
+ "Adjusted PreISP Crop %d, %d, %d x %d \n"
+ "AeControlRegular"
+ "AfeProcAFEDmaDst0 bufOutAfeProc0 %p, size %u %zu"
+ "AfeProcAFEDmaDst1 bufOutAfeProc1 %p, size %d"
+ "AfeProcAFEDmaDst2 bufOutAfeProc2 %p, size %d"
+ "After DesMatch matching, frame[%d]: BG %d, FG %d"
+ "After LVT"
+ "After NCC matching, frame[%d]: BG %d, FG %d"
+ "After Semantic"
+ "After reducePtsPairs background prev_xy vs. fcurr_xy"
+ "After reducePtsPairs of KeyPoints = %d"
+ "After wait %f: GetLatestIndex: %d nextMotionIndex %llu latestIndex %llu\n"
+ "After: main %llu %d sifr %d %llu %u fll %d rdo %d"
+ "After: main %llu (%lld) %d, sifr %d %llu (%lld) %u, fll %d rdo %d"
+ "AfterFVSync"
+ "AfterGO: SourceCurr %x %x"
+ "Age increases!"
+ "AgentCVDCombGP: Action %d is local"
+ "AgentCVDCombGP: Action %d uses Global Op %d addr %p"
+ "AgentCVDCombGP: Create Global CVDAll CIspOperationCVDCombH17 class"
+ "AgentCVDCombGP: Create Local CVDAll CIspOperationCVDCombH17 class"
+ "AgentCVDCombGP: Prepare DMA"
+ "AgentCVDCombGP: StartOp"
+ "AgentCVDCombGP: Update Global CVDAll CIspOperationCVDCombH17 configuration"
+ "AgentCVDCombGP: Update Local CIspOperationCVDCombH17 configuration"
+ "AgentCVDCombGP: VideoBuffe[%d] %p sz %zu"
+ "AgentCVDCombGP: WaitOP"
+ "AgentCVDCombGP: buf sizes op %zu act %zu meta %zu"
+ "AgentCVDCombGP: init %.3fms exec %.3fms release %.3fms"
+ "AgentCVDCombGP: numOps %d numActs %d"
+ "AgentDesGenGP: Action %d is local"
+ "AgentDesGenGP: Action %d uses Global Op %d addr %p"
+ "AgentDesGenGP: Create Global DesGen Op  %d"
+ "AgentDesGenGP: Create Local DesGen Op  %d"
+ "AgentDesGenGP: Prepare DMA"
+ "AgentDesGenGP: StartOp"
+ "AgentDesGenGP: Update Global DesGen Op  %d"
+ "AgentDesGenGP: Update Local DesGen Op  %d"
+ "AgentDesGenGP: VideoBuffe[%d] %p sz %zu"
+ "AgentDesGenGP: WaitOP"
+ "AgentDesGenGP: buf sizes op %zu act %zu meta %zu"
+ "AgentDesGenGP: init %.3fms exec %.3fms release %.3fms"
+ "AgentDesGenGP: numOps %d numActs %d"
+ "AgentDesMatchGP: Action %d is local"
+ "AgentDesMatchGP: Action %d uses Global Op %d addr %p"
+ "AgentDesMatchGP: Create Global DesMatch Op  %d"
+ "AgentDesMatchGP: Create Local DesMatch Op  %d"
+ "AgentDesMatchGP: DoneOP"
+ "AgentDesMatchGP: Prepare DMA"
+ "AgentDesMatchGP: StartOp"
+ "AgentDesMatchGP: Update Global DesMatch Op  %d"
+ "AgentDesMatchGP: Update Local DesMatch Op  %d"
+ "AgentDesMatchGP: VideoBuffe[%d] %p sz %zu"
+ "AgentDesMatchGP: WaitOP"
+ "AgentDesMatchGP: buf sizes op %zu act %zu meta %zu"
+ "AgentDesMatchGP: init %.3fms exec %.3fms release %.3fms"
+ "AgentDesMatchGP: numOps %d numActs %d"
+ "AggregatedSharedMemoryAllocator"
+ "AiCam bypassNoCheck: release buffer"
+ "AiCam ch %zu start"
+ "AiCam try to load Replay/anst-input-%zu.bgra sz %zu"
+ "AldaGPIOGet(%d): 0x%04x - 0x%02x, %s"
+ "AldaGPIOSet(%d): 0x%x - 0x%04x"
+ "AldaSTEventClear(%d): 0x%04x - 0x%08x"
+ "AldaVSELSet(%d): 0x%x - 0x%02x"
+ "AlexGPIOGet: 0x%x%x - 0x%02x\n"
+ "AlexGPIOSet: 0x%x - 0x%02x\n"
+ "Algo offloading not enabled."
+ "AlgoControl cmd total inqueue %d, bFoundDuplicated %u cmd.id %u"
+ "AlgoCtrlChStop"
+ "All"
+ "All actions done!\n"
+ "All downstreaming pipe started\n"
+ "All endPoints deleted @ %llu\n"
+ "AllChStopped()"
+ "AllDone"
+ "Alloc"
+ "Alloc vcpipeId[%u]"
+ "AllocBufAndFillHeader"
+ "AllocBufForIR"
+ "Allocate"
+ "Allocate %zu bytes at %p with index %d wired %d"
+ "Allocate DPC stat buffers mallocSize=%zu"
+ "Allocate LO %zu"
+ "Allocate srcInDma[%d]=%d, max=%d"
+ "AllocateAndValidateMainRaw"
+ "AllocateAndValidateSifrRaw"
+ "AllocateBufForFEP"
+ "AllocateBufForIR"
+ "AllocateBufForSifr"
+ "AllocateDPCBuffers"
+ "AllocateFDMapPool"
+ "AllocateLSCBuffers"
+ "AllocatePDEBuffers"
+ "AllocateRawBuf"
+ "AllocateStaticDPCBuffers"
+ "Allocating mem buffer depth done"
+ "Allocating mem buffer depth mallocSize:%zu, bufferSize:%zu"
+ "Allocating mem buffer rgb done"
+ "Allocating mem buffer rgb mallocSize:%zu"
+ "Allot %d ch %d FEP %d STATS %d Mode %d AFE %d Mode %d srcDMA %d %d IR %d"
+ "Allow bitmap %#x"
+ "AneClient BufferProcessor cmd %d"
+ "AngledInputs"
+ "AopLoopBackTest"
+ "Apply CalGain: mCh=%d comboWB=%d %d skinWB=%d %d skyWB=%d %d"
+ "Apply CalGain: mCh=%d sCh=%d comboWB=%d %d skinWB=%d %d skyWB=%d %d"
+ "Apply frameCount(%llu) == currFrameCount(%llu)"
+ "Apply updated NCC LUT %d curr %d"
+ "ApplyFrameSkipToSensor"
+ "ApplyIIRFilter"
+ "ApplyMiscSettings"
+ "ApplySpatialMapping"
+ "ApplySynchronziedZoomFactor"
+ "ApplyZoomFactor"
+ "Aries %1x%1x revision 0x%x\n"
+ "Aries %s secure streaming non-signed frames\n"
+ "Aries Auth flow: %s\n"
+ "Aries ChipID 0x%x devRev 0x%08x\n"
+ "Aries KDF not set? idx %d\n"
+ "Aries Link Training failed"
+ "Aries MANIF patch loaded"
+ "Aries MANIF/ROM/VT patch loaded"
+ "Aries eph key read failed\n"
+ "Aries eph key/sig read failed\n"
+ "Aries eph public key read failed\n"
+ "Aries max frame length 0x%x\n"
+ "Aries not powered On\n"
+ "Aries not provisioned\n"
+ "Aries secure streaming idx %d %s frames, status: 0x%x cmd %d\n"
+ "Aries secure streaming non-signed frames\n"
+ "Aries secure streaming signed frames\n"
+ "Aries skip KDF setting 0x%x\n"
+ "Aries state %d \n"
+ "Aries status: 0x%x \n"
+ "Aries stream mode %d\n"
+ "Aries: cannot switch to mode %d with config %d"
+ "ArmFrame"
+ "Asserted instead of retry"
+ "AssignStatDrv"
+ "Associated function for ISP_PROPERTY_FOCUS_ARC_CONTROL is deprecated"
+ "AttachDevice"
+ "AttachFEP"
+ "Attention: RawFmt %d PixFmt %d packType %d, rawInputFmt %d Bufs %zu %zu"
+ "Attention: no valid face found\n"
+ "Attention: post-processing initialization failed"
+ "Attention: pre-processing initialization failed"
+ "Attn: ER enabled, bypass AD\n"
+ "Attn: Enable UI feedback %d"
+ "Attn: Hijack raw frame %d\n"
+ "Attn: Input source %d \n"
+ "Attn: PDP disable %d"
+ "Attn: Set net input"
+ "Attn: save intermediate"
+ "AttnMeta %zu, AttnDebugMeta %zu, FDResult %zu, AdResult %zu\n"
+ "Austin Buckboost1: curV: %d mV (0x%02x)"
+ "Austin Buckboost1: maxV: %d mV (0x%02x)"
+ "Austin Buckboost1: minV: %d mV (0x%02x)"
+ "Austin Buckboost2: curV: %d mV (0x%02x)"
+ "Austin Buckboost2: maxV: %d mV (0x%02x)"
+ "Austin Buckboost2: minV: %d mV (0x%02x)"
+ "AustinGPIOGet: 0x%x%02x - 0x%02x\n"
+ "AustinGPIOSet: 0x%x - 0x%02x\n"
+ "AuthBootSeqSet"
+ "AuthFlow"
+ "Aux%s"
+ "AuxPyrSetup"
+ "AuxScl max output width is 3072, actual width is %d"
+ "AuxSclPyrConfed"
+ "Auxscl_Pyr_Enable %d"
+ "Auxscl_Pyr_Enable_Vio %d"
+ "Available feps:0x%x"
+ "B.height == 1"
+ "B.rowBytes == B.width * sizeof(float)"
+ "B1_mode000_1312x1108_full_gs_lcg_1ms_60fps_1x6p25g_raw12"
+ "B1_mode001_1312x1108_full_mod_lcg_7ms_60fps_1x6p25g_raw12"
+ "BEIFConfig"
+ "BES GP Compress Config: received\n"
+ "BES GP Request: received"
+ "BES Output: addrC %p 0x%x, strideOutC %d, width %d, height %d\n"
+ "BES Output: addrY %p 0x%x, strideOutY %d, width %d, height %d\n"
+ "BES: [%d %d %d %d] -> %dx%d  OutDMA [%d %d %d %d]\n"
+ "BESAgent after operation: lumaOutSize %d chromaOutSize %d"
+ "BESAgent before operation: lumaOutSize %d chromaOutSize %d"
+ "BESAgent: Buf[0] (%zu s %zu h %zu) Buf[1] (%zu s %zu h %zu)"
+ "BESAgent: input (%4d %4d w %4d h %4d), output (%4d %4d w %4d h %4d), slice (%d %d)"
+ "BESAgent: tileCount %d tileMode 0x%x"
+ "BESVirtual: [%d %d %d %d], output[%d,%d]\n"
+ "BES[0]"
+ "BES[1]"
+ "BEpipeDone"
+ "BIOMETRIC_COOLING"
+ "BIOMETRIC_COOLING_ENROLLMENT"
+ "BIOMETRIC_DONE"
+ "BIOMETRIC_DOUBLETS"
+ "BIOMETRIC_DOUBLETS_ENROLLMENT"
+ "BIOMETRIC_GMC_DOUBLETS"
+ "BIOMETRIC_GMC_DOUBLETS_ENROLLMENT"
+ "BIOMETRIC_RETRY_PENDING"
+ "BIO_CAPTURE_DONE"
+ "BISTDone"
+ "BLCGet"
+ "BLNK: FRM=%u, PRICFG %u (%u) --> %u (%u)"
+ "BLNK: FRM=%u, PRICFG=%u changed"
+ "BLURM"
+ "BUFFER"
+ "BUFFER_POOL_RETURN"
+ "BUFFER_POOL_RETURN_DONE"
+ "BUSY"
+ "BUSY_NEXT"
+ "BWR_MISS: ch:%zu fc:%d OFT:%llu blk:%d delta:%d sp:%llu blkTm<delta+DCS\n"
+ "BYPASSED"
+ "Bad sizeKey %u != %zu\n"
+ "Bad state transition: (curr: %d, desired: %d)"
+ "Bagdemagus Auth flow: %s\n"
+ "Balan driver loaded\n"
+ "Bank"
+ "BaseSettingsInit"
+ "BayerProcSetup"
+ "Before ADRC: softGain %d, linearEIT %llu\n"
+ "Before LVT"
+ "Before Semantic"
+ "Before reducePtsPairs prev_xy vs. fcurr_xy"
+ "Before: main %llu %d %d, sifr %d %llu %d"
+ "Before: main %llu %d, sifr %d %llu %d"
+ "Bes agent ref0-3:%p, %p, %p, %p"
+ "Bes agent ref4-6:%p, %p, %p"
+ "BesMatrix3x1Multiply"
+ "BesProcMeshVISLTMProcess"
+ "BesProcMesh_CPUInterrupts = 0x%x\n"
+ "BesSetupInputDma"
+ "BesSetupLRMEOutputDma"
+ "BesSetupOutputDma"
+ "BinConfig"
+ "BinEn %d PowH %d PowV %d"
+ "BindDynamicBufferPool"
+ "Binning %d flash off %d (lux %d), preflash %d (lux %d), mainFlashLux %.1f\n"
+ "Blink threshold out of bounds!"
+ "Boost ISP frequency to Vmax during zooming."
+ "BootSeqLoad"
+ "BootSequence 1"
+ "BootSequence Start"
+ "BootSequence cert"
+ "BootSequence clk"
+ "BootSequence done"
+ "BootSequence patch"
+ "Both output is disabled\n"
+ "Box %zu: %f %f %f %f \n"
+ "BracketingCaptureFocusHelper"
+ "Brunor Auth flow: %s\n"
+ "Brunor driver loaded"
+ "Bst freq to Vmax zoom fctr set."
+ "Buf MSG: sapId 0x%x bufNbr %d subPacketSize %d\n"
+ "Buf0Rcvd"
+ "Buf1Rcvd"
+ "BufDone"
+ "BufPool id %zu, maxBufCnt %u size %u"
+ "BufPool id %zu, width %u height %u stride %u minBufferCount %u"
+ "BufProcDone"
+ "BufRcvd"
+ "BufRecvd"
+ "BufRecvdMaster"
+ "BufRecvdSlave"
+ "BufReleased"
+ "Buffer A and B dont have the same height"
+ "Buffer A and C dont have the same height"
+ "Buffer A is not a column vector!"
+ "Buffer A is not a single row vector"
+ "Buffer B is not a column vector!"
+ "Buffer B is not a single row vector"
+ "Buffer C is not a single row vector"
+ "Buffer heights mismatch!"
+ "Buffer is too small for grouping to happen."
+ "Buffer overrun!"
+ "Buffer pool is already allocated for Double height as vhdr is ON other channel %zu"
+ "Buffer processor in ch=%zu"
+ "Buffer sizes mismatch!"
+ "BufferDiff"
+ "BufferOutputConfigure"
+ "BufferPoolConfig"
+ "BufferPoolInfoGet"
+ "BufferProcessorImp"
+ "BufferSizeInBytes: BufferSizeInBytes=%d"
+ "Buffers: %p %p %zu %zu"
+ "BuffersRelease"
+ "Bypass"
+ "Bypass MTH. ch %zu AlgoEnable %u bMTHDataReady %u okToRun %d"
+ "Bypass STF. ch %zu bSTFDataReady %u, enable %u bShouldEnable %u Frmrate %u"
+ "BytesPerCredit: BytesPerCredit=%d"
+ "BzP1 != BzN1"
+ "C.height == 1"
+ "C.rowBytes == C.width * sizeof(float)"
+ "C0"
+ "C1"
+ "CAFCASCasCategory"
+ "CAFCASCasCoeff"
+ "CAFCASConfOption"
+ "CAFCASConfig"
+ "CAFCASEnable"
+ "CAFCASGridIntervalRecip"
+ "CAFCASGridOffset"
+ "CAFCASGridSize"
+ "CAFCASNoiseAdjust"
+ "CAFCASNoiseratio"
+ "CAFSetup"
+ "CAF_INPUT_TIMEWARP:ch %zu: desired_rec_fps %.3f rec=%u lock=%u"
+ "CAICamProc"
+ "CAICamProcAnst"
+ "CAM Strob used but not set"
+ "CAMS: chId %d, wrapperId %d"
+ "CAMS: totFFCCam %d chBitMask 0x%x"
+ "CAMS: totRFCCam %d chBitMask 0x%x"
+ "CAMS: totRFCCamDepth %d chBitMask 0x%x"
+ "CAPTURE_BIOMETRIC_DOUBLETS"
+ "CAPTURE_SECRET"
+ "CAP_OUT_CROP_SET"
+ "CAP_OUT_CROP_SET_DONE"
+ "CARBypass"
+ "CAREnable"
+ "CARSetup"
+ "CAWBAFEH16"
+ "CAWBAFEPhotometerAssistPenrose"
+ "CAWBApple"
+ "CAWBSemanticProcess"
+ "CAWBSemanticProcess calculation done! total %.2f ms\n"
+ "CAWBSemanticProcess start"
+ "CAdaptiveLS2"
+ "CAdaptiveLS2.cpp"
+ "CAlgoControlH17NonPixelPipeSetup.cpp"
+ "CAlgoCtrl::BufferProcessor: asserting ref[0]!"
+ "CAlgoCtrl::BufferProcessor: received SLAF mask, retain=%d, addr=%p"
+ "CAlloc: %zu bytes %d requests"
+ "CAlloc: Deallocate"
+ "CAneClient"
+ "CAutoFocusCS40L62"
+ "CAutoFocusDevice::GetRange() not implemented!\n"
+ "CBuffer hostMetaBuf = %p\n"
+ "CBuffer inputImage2Buf = %p\n"
+ "CBuffer inputImageBuf = %p\n"
+ "CBuffer inputParamBuf = %p\n"
+ "CBuffer ioDescrBuf = %p\n"
+ "CBufferPool::alignment != 0"
+ "CBufferPool::blockArray != 0"
+ "CBufferPool::compressConfig"
+ "CBufferPool::size != 0"
+ "CBufferPool::stride != 0"
+ "CBufferPoolDynamicManager"
+ "CBv2EndLacc"
+ "CBv2StartLacc"
+ "CBv3EndLacc"
+ "CBv3StartLacc"
+ "CC COEFs  %hd %hd %hd "
+ "CCM: %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f"
+ "CCT: %uK"
+ "CChangeDetector"
+ "CCmpnRtrManagerH17"
+ "CConnectivityTable::Instance()"
+ "CDMediaBusManager"
+ "CDPC: Switch to list type %d, numDefects %d"
+ "CDPC: switch to defect table for sensor cfg %d, type %d, numDefects %d"
+ "CDPCAppleH17::Instance(pMetaData->channel)"
+ "CDSControllerH17"
+ "CDcnAttnH11"
+ "CDcnProc"
+ "CDcnProcH11"
+ "CDcnProcH11::NetProcDone"
+ "CDeferBufAlloc SignalProcessor start"
+ "CDeferBufAlloc calculation done! total %.2f ms\n"
+ "CDualStrmBaseDone"
+ "CERDcnMetaWrite"
+ "CERDcnProcH11"
+ "CEndpointChannel"
+ "CFDDcnMetaWrite"
+ "CFDDcnProcH11"
+ "CFEStatsDrvH17"
+ "CFEStatsDrvH17::Reset Enter - bank %d baseAddr 0x%llx"
+ "CFSM::Get(descr->hMultiPassFSM) == TM_MULTIPASS_IDLE"
+ "CFSM::Get(h->hFSM) == BUSY"
+ "CFSM::Get(hMultiCapFSM) == TM_MULTICAP_IDLE"
+ "CFSM::Get(pChInfo->hFSM) == ALGOCTRL_READY"
+ "CFSM::Instance()->Get(pChInfo->hFSM) == STATE_READY"
+ "CFSM::Instance()->Get(pChInfo->hFSM) == STATE_RUN || pFrameExtra->stillImageCaptureNow == IMAGE_TYPE_GENERAL_PROCESS_SMG"
+ "CFakeChannel::chDescr"
+ "CFileWriter.cpp"
+ "CFloodEFuse"
+ "CGrievous"
+ "CH %zu Time Machine is receiving allocation done notification\n"
+ "CH = %zu"
+ "CH = %zu: CHANNEL CONFIG = %d"
+ "CH = %zu: CHANNEL RESET config = %d"
+ "CH = 0x%zu  FES CROP -> [%d, %d][%d, %d] sensor [%d, %d], FSCL output [%d, %d]"
+ "CH = 0x%zu  PYR CROP -> [%d, %d][%d, %d] PYR output [%d, %d]"
+ "CH = 0x%zu  TSeg thumbnail downscaleMode: %d, genMode: %d, subMode: %d\n"
+ "CH = 0x%zu Bes output=[%d %d] Return BesOutValidRect=[%d %d %d %d]"
+ "CH = 0x%zu Update BesInCropRect from [%d %d %d %d] to [%d %d %d %d]"
+ "CH = 0x%zu Update BesInFOVInRaw from [%d %d %d %d] to [%d %d %d %d]"
+ "CH[%1d]S[%s] F[%1d][%1d]%3d [%2d] D[%5d][%5d] P[%5d]%2d PFPS[%2d] APE[%s] [T %2d] [MFD %3d]%1d"
+ "CH[%1d][%s][%d%d%d%d]  [%s][%s]  [%s][%s]  BLB[%s][%s][%s][%s][%s] [CR %2d][T %2d]"
+ "CH_OUTPUT_DISABLE"
+ "CH_OUTPUT_DISABLE_DONE"
+ "CH_OUTPUT_ENABLE"
+ "CH_OUTPUT_ENABLE_DONE"
+ "CH_START"
+ "CH_START_DONE"
+ "CH_STOP"
+ "CH_STOP_DONE"
+ "CIC_CMD_META_DATA_SIZE_GET, ch %zu exclave meta data size: %zu\n"
+ "CIC_CMD_SENSOR_AGILE_CURRENT_FREQUENCY_ARRAY_SET was called for Peridot"
+ "CIC_UPDATE_UNIT_NOOP == aeUnit[stepIDX][CIC_UPDATE_UNIT_CONTEXT_SWITCH]->id"
+ "CILCal"
+ "CIOOBJECT_MSGDOUBLEREF_SET"
+ "CIOOBJECT_MSGOCTUPLEREF_SET"
+ "CIOOBJECT_MSGQUADRUPLEREF_SET"
+ "CIOOBJECT_MSGQUINTUPLEREF_SET"
+ "CIOOBJECT_MSGSEPTUPLEREF_SET"
+ "CIOOBJECT_MSGSEXTUPLEREF_SET"
+ "CIOOBJECT_MSGSINGLEREF_SET"
+ "CIOOBJECT_MSGTRIPLEREF_SET"
+ "CISP command with Invalid Channel %d ! Max channels = %d"
+ "CISP_CMD_APPLE_CH_AWB_SLAVE_CAMERA_LIST_COLOR_MATCHING_F2F_PARAM_SET"
+ "CISP_CMD_APPLE_CH_GREEN_IMBALANCE_CORRECTION_TABLE_SET"
+ "CISP_CMD_APPLE_CH_MACRO_LENS_SHADING_TABLE_SET"
+ "CISP_CMD_APPLE_CH_SNF_VERTICAL_GAIN_LLM_SET"
+ "CISP_CMD_APPLE_CH_SNF_VERTICAL_GAIN_SET"
+ "CISP_CMD_CH_BES_AUXSCL_CROP_OUTPUT_CONFIG_SET should be used during streaming"
+ "CISP_CMD_CH_BES_AUXSCL_CROP_OUTPUT_CONFIG_SET should set AuxScl cascaded by default"
+ "CISP_CMD_CH_CROP_OUTPUT_CONFIG_SET should be used during streaming"
+ "CISP_CMD_CH_FACE_DETECTION_CONFIG_SET enableAttr = %d\n"
+ "CISP_CMD_CH_FACE_DETECTION_CONFIG_SET enableAttr ignored during offline testing"
+ "CISP_CMD_CH_LED_GET_EXT_STROBE_PARAMS ch: %x"
+ "CISP_CMD_CH_SENSOR_PERMODULE_GIC_GET"
+ "CISP_CMD_CH_SENSOR_SERIAL_NUMBER_GET"
+ "CISP_CMD_CH_VA_ACTUATOR_GET"
+ "CISP_CMD_CH_VA_ACTUATOR_SET"
+ "CISP_CMD_CH_VA_DIAMETER_GET"
+ "CISP_CMD_CH_VA_DIAMETER_SET"
+ "CISP_CMD_CH_VA_RUN_MODE_GET"
+ "CISP_CMD_CH_VA_RUN_MODE_SET"
+ "CISP_CMD_CH_YCC_CROP_DMAOUT_CROP_OUTPUT_CONFIG_SET should be used during streaming"
+ "CISP_CMD_UPDATE_DEVICE_IMPACT"
+ "CISP_LTM_SPATIAL_CCM_MAX_SIZE >= sccmMemSize"
+ "CISRManager::Instance() != nullptr"
+ "CImageCaptureExclave"
+ "CImageCaptureExclave %s %d\n"
+ "CImageCaptureExclave init\n"
+ "CImageFlowH17"
+ "CImageSensorIMX591"
+ "CImageSensorIMX633"
+ "CImageSensorIMX714"
+ "CImageSensorIMX803::%s Line:%d  en: 0x%x\n"
+ "CImageSensorIMX803::%s Line:%d  flashHiPeriod: %d, flashStrobeDiv: %d totalV: %d, Exp:0x%x\n"
+ "CImageSensorIMX803:::%s Line:%d   enable: 0x%x\n"
+ "CImageSensorIMX903::%s Line:%d  en: 0x%x\n"
+ "CImageSensorIMX903::%s Line:%d  flashHiPeriod: %d, flashStrobeDiv: %d totalV: %d, Exp:0x%x\n"
+ "CImageSensorIMX903:::%s Line:%d   enable: 0x%x\n"
+ "CImageSensorIMX913"
+ "CImageSensorIMX972::%s Line:%d  en: 0x%x\n"
+ "CImageSensorIMX972::%s Line:%d  flashHiPeriod: %d, flashStrobeDiv: %d totalV: %d, Exp:0x%x\n"
+ "CImageSensorIMX972:::%s Line:%d   enable: 0x%x\n"
+ "CImageSensorVD56G0Balan"
+ "CImageSensorVD56G0Brunor"
+ "CImageSensorVD56G8"
+ "CIndexPool::invalidIndex != index"
+ "CIspEngineAgentCVDCombH17"
+ "CIspEngineAgentDesGenH17"
+ "CIspEngineAgentDesMatchH17"
+ "CIspEngineCVDExeLoopH17.cpp"
+ "CIspEngineCVDServerH17.cpp"
+ "CIspEngineServerH17"
+ "CIspEngineServerH17::CIspEngineServerH17(): malloc: sizeof=%ld, count=%d\n"
+ "CIspHwResourceServiceH17::InvalidUserHandler != hwUser"
+ "CIspOperationCvPipeH17"
+ "CIspOperationVisPipeH17"
+ "CIspRTResourceManager::Instance()->GetSIFDMAIndex(ch) != ISP_RESOURCE_SIFDMA_NONE"
+ "CLCPlayback"
+ "CLTMDrv"
+ "CLTMDrvLTM57"
+ "CLTMH17"
+ "CLensControllerHxTrace.cpp"
+ "CLensCtrlAFAssist_APE.cpp"
+ "CLensService"
+ "CLensService::Instance()"
+ "CLensShading"
+ "CMD"
+ "CMLAFProcImp"
+ "CMMUI->PageWiringOn()"
+ "CMMULoggerVA::hisEntry != 0"
+ "CMMULoggerVA::logEntry != 0"
+ "CMMU_LOGGER_FFW_ASSERT:%d [%zu] vir = %p, length = 0x%zx\n"
+ "CMOTIONESTIMATOR_INPUT_TIMEWARP:ch %zu: desired_recording_fps %f\n"
+ "CMailboxPool::Instance() != 0"
+ "CMamaBear"
+ "CMotionCaptureAOP"
+ "CMotionEstimator resource initialization done !!!"
+ "CMotionEstimatorH17"
+ "CONTEXTSWITCH"
+ "CONTEXT_SWITCH_CH0"
+ "CONTEXT_SWITCH_CH1"
+ "CONTEXT_SWITCH_CONFIG_ALLOWED(contextSwitchConfigsBitMap, pAEMetaData->contextSwitchConfig)"
+ "CONTEXT_SWITCH_CONFIG_ALLOWED(eitParams[nSensorConfig].contextSwitchConfigsBitMap, sensorConfig)"
+ "CONTROLLER_BOOTSTRAP"
+ "COOLDOWN_DONE"
+ "COverlayService: skipped drawing (null buffer)"
+ "CPCEAlgoCalcRearCamCalib"
+ "CPCEAlgoCalcRearCamCalibVertical"
+ "CPCEAlgoGMSLoopEpipolarConstraintFitting"
+ "CPCEAlgoProcessor"
+ "CPCEAlgoRunGMSLoop"
+ "CPCEAlgoSaveInputRefs"
+ "CPCEAlgoSendGmsOutput"
+ "CPCECalibManager"
+ "CPDEDrv"
+ "CPDEProc"
+ "CPMU%d OTP version: %u.%u.%u"
+ "CPU HFFver=%i"
+ "CPU num: %d\n"
+ "CPU_0(%)"
+ "CPU_1(%)"
+ "CPU_ID"
+ "CPlatformEnvironment"
+ "CPowerSupply::Instance()"
+ "CQueuePool::Instance() != 0"
+ "CRNT[T %2d] [CR %2d] D[%5d] PFLsig[%5d] Z[%3d] PFL[%4d] DFPS[%3d] Lux[%s]"
+ "CROIService::Display ch=%zu frame=%u #wins=%zu buffer=%dx%d"
+ "CROIService::Display mask=0x%08x id=%d ch=%zu"
+ "CROIService::Display node not available for channel %zu"
+ "CROIService::Display skipped drawing (id disabled)"
+ "CROIService::Display skipped drawing (null buffer)"
+ "CROIService::Display skipped drawing (pplMode mismatch)"
+ "CROIService::Display skipped drawing (scale mismatch)"
+ "CROIService::Display skipped drawing (too old)"
+ "CROIService::DrawLatestRect Skipp drawing Rect, roiDrawMask %d, roiIndex %d"
+ "CROIService::DrawLatestRect roiDrawMask %d, roiIndex %d"
+ "CROIService::SaliencyDisplay node not available for channel %zu"
+ "CROIService::SaliencyDisplay skipped drawing (null buffer)"
+ "CROIService::SaliencyDisplay skipped drawing (pplMode mismatch)"
+ "CROIService::SaliencyDisplay skipped drawing (too old)"
+ "CROPRECT[x,y,w,h] = [%d, %d, %d, %d]\n"
+ "CROPRECT[x,y,w,h] = [%d, %d, %d, %d] preISPDownsizeRatio %d\n"
+ "CRPCClientOnlySupportsImmediateCommnds"
+ "CRT: CPCECalibAlgoGmc.cpp:%d [DSI] Info %s\n"
+ "CRT: CPCECalibAlgoGms.cpp:%d [DSI] Info %s\n"
+ "CRT: CPCECalibManager.cpp:%d [DSI] Info %s\n"
+ "CRT: CPCEDebugService.cpp:%d [DSI] Info %s\n"
+ "CRT: CPCEFlow.cpp:%d [DSI] Info %s\n"
+ "CRT: CPCEFlowFactory.cpp:%d [DSI] Info %s\n"
+ "CRT: CPCEFlowFactoryFrontStereoFusion.cpp:%d [DSI] Info %s\n"
+ "CRT: CPCEFlowFactoryPearl.cpp:%d [DSI] Info %s\n"
+ "CRT: CPCEFlowFactoryRearStereo.cpp:%d [DSI] Info %s\n"
+ "CRT: CPCEFlowFactoryRearStereoSinglePass.cpp:%d [DSI] Info %s\n"
+ "CRT: CPCEFlowFactoryRearStereoTriplePass.cpp:%d [DSI] Info %s\n"
+ "CRT: CPCEFlowFactorySplitPD.cpp:%d [DSI] Info %s\n"
+ "CRT: CPCEFlowFrontStereoFusion.cpp:%d [DSI] Info %s\n"
+ "CRT: CPCEFlowManager.cpp:%d [DSI] Entering suspend mode (pwr = %d)\n"
+ "CRT: CPCEFlowManager.cpp:%d [DSI] Info %s\n"
+ "CRT: CPCEFlowManager.cpp:%d [DSI] PCE - Entering Secure Mode (pwr = %d)\n"
+ "CRT: CPCEFlowManager.cpp:%d [DSI] PCE - Exiting Secure Mode (pwr = %d)\n"
+ "CRT: CPCEFlowPearl.cpp:%d [DSI] Info %s\n"
+ "CRT: CPCEFlowPearlSinglePass.cpp:%d [DSI] Info %s\n"
+ "CRT: CPCEFlowRearStereo.cpp:%d [DSI] Info %s\n"
+ "CRT: CPCEFlowRearStereoSinglePass.cpp:%d [DSI] Info %s\n"
+ "CRT: CPCEFlowRearStereoTriplePass.cpp:%d [DSI] Info %s\n"
+ "CRT: CPCEFlowSplitPDDisparity.cpp:%d [DSI] Info %s\n"
+ "CRT: CPCEFlowSplitPDScale.cpp:%d [DSI] Info %s\n"
+ "CRT: CPDEProcV2.cpp:%d [DSI] Info %s\n"
+ "CS40L62_GROUP_4_V24_C6_0"
+ "CS40L62_GROUP_5_V24_C6_0"
+ "CSFus:     avgPerType[ch=%d][typ=%c] = %.3f"
+ "CSFus:     ch=%d rec=%c"
+ "CSFus:   ch=%d typ=%c h=%d => [%d] {TS=%llu %.2f fpsx%u}"
+ "CSFus:  => maxFPS = %.3f"
+ "CSFus:  ch=%d not master, return ovl desFPS=%.3f"
+ "CSFus:  ch=%d not recorded, return -1"
+ "CSFus: %d controls\n"
+ "CSFus: %d pets, dT=%.0f ms/plateau=%.0f => fps=%.2f"
+ "CSFus: ACTIVATE REGISTRATION"
+ "CSFus: Change mode: 0x%x => 0x%x\n"
+ "CSFus: DesiredLumaChangePerFrame[%d]=%.4f\n"
+ "CSFus: FoV scales changed: T2W:%.2f -> %.2f, W2T:%.2f -> %.2f, SW2W:%.2f -> %.2f, W2SW:%.2f -> %.2f\n"
+ "CSFus: NEW PET! prev=%d, cur=%d => use %.1f fps"
+ "CSFus: No control\n"
+ "CSFus: Pets: perCh{%d %d %d %d}=> %d for %u"
+ "CSFus: Rec on Ch=%d"
+ "CSFus: Set debug flags: 0x%x => 0x%x"
+ "CSFus: Set recording(ch=%d, rec=%d)\n"
+ "CSFus: T2W=%.2f W2SW=%.2f\n"
+ "CSFus: [%d]={%.3f, %.3f, %.3f, %.3f}"
+ "CSFus: ch %d at sens=%.2f fps, recFPS=%.3f => %.2f / samples=%d since last rec"
+ "CSFus: ch [%d] gyro{%.3f fps +/- %.3f chg=%.3f smpl=%u} "
+ "CSFus: ch [%d] luma{%.3f fps +/- %.3f chg=%.3f smpl=%u} "
+ "CSFus: ch=%d exp=%llu=%uus xA %.2f xD %.2f vFrS=%u @ %.2f fps"
+ "CSFus: ch=%d fC=%llu  sensFPS=%.3f RecCh[%d]=%d"
+ "CSFus: ch=%d fC=%llu sensor=%.3f rec=%d => %.3f fps"
+ "CSFus: controlCh:%d recCh:%d => growOversc=%d ROI={%.2f,%.2f+%.2fx%.2f}\n"
+ "CSFus: gyroRate=%.2f tripod=%u shaking=%d"
+ "CSFus: imu={gyr=%.1fd/s tr=%d shk=%d has=%d}"
+ "CSFus: mode=0x%x gyro=%.3f rad/s=%.1f d/s inv=%.3f => %.2f fps"
+ "CSFus: recFPS[%d]=%.4f fps mode=0x%x"
+ "CSFus: req_ch=%d => concat AE chg=%.3f, fps=%.3f"
+ "CSFus: samplesSinceLastRecording=%d = sensFPS=%.1f/rec=%.3f vs hist=%d"
+ "CSFusion"
+ "CSIMU/Sett: New ref quat: (%.3f, %.3f, %.3f, %.3f)"
+ "CSIMU:    stable: r=%.4f tripodStabilityCounter=%.3f"
+ "CSIMU:    unstable: tripodStabilityCounter=%.3f"
+ "CSIMU: ACCEL Avg=x=%.2f y=%.2f z=%.2f stddev:x:%.3f y:%.3f z:%.3f norm=%.4f +/-:%.4f"
+ "CSIMU: GRAVITY: avg x=%.2f y=%.2f z=%.2f  +/-:x:%.2f y:%.2f z:%.2f norm=%.3f"
+ "CSIMU: GYRO Avg=x=%.2f y=%.2f z=%.2f stddev:x:%.3f y:%.3f z:%.3f norm=%.4f +/-:%.4f"
+ "CSIMU: RESET IMU detector"
+ "CSIMU: TRIPOD DETECTION: TURN OFF STABLE FLAG\n"
+ "CSIMU: TRIPOD DETECTION: TURN ON STABLE FLAG\n"
+ "CSIMU: dQ{%.3f %.3f %.3f}/%.3f =>gyr{x:%.1f y:%.1f z:%.1f} d/s"
+ "CSIMU: dt=%.0fms %.0f/s stabC=%.0f shkCounter=%.0f isSh=%d hasSh=%d"
+ "CSIMU: dt=%.3f cur=%.1f filt:%.1f trip=%d shk=%d"
+ "CSIMU: output: {.curGyroRate=%.3f .filtGyroRate=%.3f +/- .%3f, trip=%d shk=%d,%d}"
+ "CSIMU::%s:%d: Debug flags = 0x%x"
+ "CSMBusControllerISP"
+ "CSMBusControllerSecureM3Wrapper"
+ "CSPD"
+ "CSSenseIMU"
+ "CSSense[%u]/Luma: AE=id=%d, %dx%d, roi:%.2f,%.2f+%.2fx%.2f => change=%.3f = %.4f fps"
+ "CSSense[%u]/Luma: Process %dx%d"
+ "CSSense[%u]:    depth=%d chg=%.2f timeScale=%.1fs => interval=%.2f"
+ "CSSense[%u]:  changeDetectors[%d]={id=%d, pDet=%p}"
+ "CSSense[%u]: %s =>Int: %.3f, %.3f, %.3f, %.3f"
+ "CSSense[%u]: %s =>fps: %.3f, %.3f, %.3f, %.3f"
+ "CSSense[%u]: %s =>fps: %.3f, %.3f, %.3f, %.3f => ovl=%.4f"
+ "CSSense[%u]: %s Chg: %.4f, %.4f, %.4f, %.4f => ovl=%.4f"
+ "CSSense[%u]: %s Chg: %.4f, %.4f, %.4f, %.4f sumW=%.4f"
+ "CSSense[%u]: %s scale: %.3f, %.3f, %.3f, %.3f"
+ "CSSense[%u]: Adding detector[%d] for id=%d"
+ "CSSense[%u]: Append => [%d]"
+ "CSSense[%u]: Reset resetMultiScaleDetectors (%d)"
+ "CSSense[%u]: Set ROI=%.2f,%.2f+%.2fx%.2f"
+ "CSSense[%u]: Set flags=0x%x => 0x%x"
+ "CSSense[%u]: processing eit=%.1f EV tiles:%dx%d p=%p"
+ "CSSense[%u]: update [%d]/E_CHGDET_AE_TILES"
+ "CSSense[%u]: update [%d]/E_CHGDET_AWB_CHROMAHIST"
+ "CSSense[%u]: updated [%d]/E_CHGDET_AE_TILES"
+ "CSSense[%u]: updated [%d]/E_CHGDET_AWB_CHROMAHIST"
+ "CSSense[%zu]"
+ "CSTAE"
+ "CSTAE/Sett: Just started ch=%d"
+ "CSTAE/Sett: Set recording[ch=%d]==%d"
+ "CSTAE/Sett: Set recording[ch=%d]==%d => RECORDED CHANNEL IS %d"
+ "CSTAE/Sett: setForceFPS(%.2f -> %.2f)"
+ "CSTAE/Sett: setMaxRecordingFPS(%u=%.4f Hz) => use max=%.4f fps"
+ "CSTAE/Sett: setMaxSensorFrameRate(ch=%d, %u=%.4f fps)"
+ "CSTAE/Sett: setMinRecordingFPS(%u=%.4f Hz) => use min=%.4f fps"
+ "CSTAE/Sett: setMinSensorFrameRate(ch=%d, %u=%.4f fps)"
+ "CSTAE:     STOPMOTION: [ch=%d][d=%d]:%.3f => %.3f"
+ "CSTAE:     ch=%d rec=%c"
+ "CSTAE:  ch=%d not master, return ovl desFPS=%.3f"
+ "CSTAE:  ch=%d not recorded, return -1"
+ "CSTAE: => des=%.4f vs prev=%.4f state=%d=%s"
+ "CSTAE: Back from E_SPEED_STOPPED=%d to E_SPEED_STEADY"
+ "CSTAE: DON'T turn around, steady now"
+ "CSTAE: E_SPEED_RAMPING(%d) mSpeedRampConvergedCount=%d => E_SPEED_STOPPING(%d)"
+ "CSTAE: E_SPEED_STOPPING(%d) => E_SPEED_STOPPED(%d)"
+ "CSTAE: First iteration, init pref=%.2f"
+ "CSTAE: Forcing %.4f fps (mode=0x%x)"
+ "CSTAE: From ?=%d to E_SPEED_STEADY(%d)"
+ "CSTAE: From init=%d to E_SPEED_STEADY(%d)"
+ "CSTAE: Initial plateau is done!"
+ "CSTAE: Initial plateau: return %.2f"
+ "CSTAE: Keep high max FPS: maxFPS=cur=%.2f vs desFPS=%.2f"
+ "CSTAE: LOG: des=%.2f prev=%.2f maxstepUp=%.2f Dwn=%.2f => nxt=%.2f clamped=%d rate=%.2f "
+ "CSTAE: LOG: st:%d: desired=%.3f (log=%.2f) prev=%.3f (%.2f) target=%.3f(%.2f)"
+ "CSTAE: Prev=%.4f (log: %.2f) Des=%.4f (%.2f) Tgt=%.4f (%.2f) => dFPS=%.4f (%.2f)"
+ "CSTAE: RESET"
+ "CSTAE: RESET mRecordingStartTimestamp"
+ "CSTAE: Rec:%d -> %d"
+ "CSTAE: Rec=%d recCh=%d"
+ "CSTAE: Record this frame: dt=%.3f for desired=%.3f vs last=%.3f"
+ "CSTAE: START REC => SWITCH TO %.1f FPS"
+ "CSTAE: STOP MOTION: chg=%.3f upCnt=%.2f dwnCnt=%.2f s"
+ "CSTAE: STOPMOTION: RECORD FRAME #%d!!"
+ "CSTAE: STOPMOTION: chgLvl=%.3f max=%.4f dt=%.3f count=Activity:%.2fs Still=%.2fs # %d"
+ "CSTAE: Since last recorded frame: %.2fs vs fps=%.3f => T=%.3fs"
+ "CSTAE: Switch ramping state from %d to %d=ramping"
+ "CSTAE: T=%3.1fs Decimation changed @ rec frames=%d => use %.3f fps"
+ "CSTAE: TURN AROUND at dFpsLog=%.3f rate=%.3f"
+ "CSTAE: Turn around ?? prevRate=%.3f, stepFps=%.3f"
+ "CSTAE: [%d] mode=0x%x fr#%5llu desiredFPS=%.3f vs prev=%.3f rec=%.3fs"
+ "CSTAE: ch=%d %s spSt=%u=%s TWmod=0x%x => desired=%.3f fps"
+ "CSTAE: ch=%d Fusion => Luma chg[%d]=%.4f = {%.3f %.3f %.3f %.3f} => %.4f fps"
+ "CSTAE: ch=%d exp=%.0fms xA %.2f xD %.2f vFrS=%u @ %.2f fps"
+ "CSTAE: ch[%d] => des=%.4f vs prev=%.4f state=%d=%s"
+ "CSTAE: ch[%d] => from fusion, desiredFPS filtered=%.3f"
+ "CSTAE: dCur=%.3f dNxt=%.3f => use cur=%d"
+ "CSTAE: des=%.4f fps curET=%.3f xA%.1f xD%.1f=>wSifr%.4f minET=%.4fs maxFPS=%.2f"
+ "CSTAE: dt=%.3f +sensT=%.3f=next:%.3f des=%.3f rate=%.2f lastDT=%.3f"
+ "CSTAE: keep the same value: %.2f fps"
+ "CSTAE: maxSpdLogDwn=%.3f sens=%.2f fps cur=%.3f fps => dec=%.1f => maxSpdLog=%.5f"
+ "CSTAE: mode=0x%x => 0x%x"
+ "CSTAE: req_ch=%d => mDesiredFPS=%.3f skip=%u"
+ "CSTAE: step=%.2f prevRampLog=%.3f maxDStepLog=%.4f => maxSpeedStepLogDown=%.3f"
+ "CSTAE: unfiltered: %.3f fps => filtered: %.3f"
+ "CSTF"
+ "CSTF Lacc will not be enabled\n"
+ "CSTF channel %zu started"
+ "CSTF channel %zu stopped"
+ "CSTF receives MTHOutput ch %u, fr%u (AWB fr%u), numScene%hu mthEnabled%u"
+ "CSTF receives first AWB on ch %zu"
+ "CSTF spawn"
+ "CSTF stopped all channels."
+ "CSTFMTHCompute linear system build time: %fus"
+ "CSTFMTHCompute sky processed in %fus"
+ "CSTFMTHCompute total compute time: %fus"
+ "CSTwDrv"
+ "CScopedLock"
+ "CSecureM3Driver::GetInstance()"
+ "CSemaphorePool::Instance() != 0"
+ "CSemaphorePool::Instance() != nullptr"
+ "CSharedMemory::Instance () != 0"
+ "CSharedMemory::Malloc failed and exit\n"
+ "CSignalPool::Instance() != nullptr"
+ "CStr=0x%x ratio=%.4f ledType=%d pmData=%.4f %.4f %.4f %.4f"
+ "CStr=0x%x version=%d ledType=%d valid=%d program=%d pmData=%.4f %.4f"
+ "CStrobeCP5100CfgA"
+ "CStrobeLM3566::%s CpreDual=0x%04x oldCool=%d mA oldWarm=%d mA,maxTCurr_mAmps= 0x%08x,maxTCurrRatio=0x%08x\n"
+ "CStrobeLM3566::%s CpreDual=0x%04x oldCool=%d mA oldWarm=%d mA,maxTorchCurrent_mAmps= 0x%08x,maxTorchCurrentRatio=0x%08x\n"
+ "CStrobeLM3566::%s CpreNom=0x%x CstrNom=0x%x \n"
+ "CStrobeLM3566::%s CstrDual=0x%04x cool=0x%02x warm=0x%02x\n"
+ "CStrobeLM3566::%s CstrDual=0x%04x oldCool=%d mA oldWarm=%d mA,max_Amps= 0x%08x,maxRatio=0x%08x\n"
+ "CStrobeLM3566::%s currents[0]=%d currents[1]=%d \n"
+ "CStrobeLM3566::%s isTorchOn=%x, torchRegister=0x%x, tr2: 0x%x\n"
+ "CStrobeLM3566::%s maxStrobeCurrent=%d mainStrobeCurrent=%d i2cMode=%d cStr=0x%04x\n"
+ "CStrobeLM3566::%s newCool=%d mA, newWarm=%d mA, coolStrobeVal= 0x%02x, warmStrobeVal= 0x%02x\n"
+ "CStrobeLM3566::%s newCool=%d mA, newWarm=%d mA, coolTorchVal= 0x%02x, warmTorchVal= 0x%02x\n"
+ "CStrobeLM3566::%s pCoolLEDCurrent=%d pWarmLEDCurrent=%d \n"
+ "CStrobeLM3566::%s: level=0x%x\n"
+ "CStrobeLM3567A"
+ "CStrobeQuark"
+ "CStrobeRegulus"
+ "CStrobeRigel"
+ "CSystemConfigurator::Instance()"
+ "CSystemConfigurator::Instance() != nullptr"
+ "CSystemConfigurator::Instance() && CSystemConfigurator::Instance()->BufferPoolOptimizationGet()"
+ "CSystemConfiguratorH17"
+ "CTFBufferFree"
+ "CTFBufferMalloc"
+ "CTIMEMACHINE_CMD_SLAVE_DECIMATION_ENABLE bEnable %d"
+ "CTaskPool::Instance() != 0"
+ "CTaskProfiler"
+ "CTaskProfiler is not running\n"
+ "CTimeMachine"
+ "CTimeWarp:    AELuma[%zu]: %.3f => %.3f fps\n"
+ "CTimeWarp: %d -> on=%d\n"
+ "CTimeWarp: ALLOCATE DRIVER\n"
+ "CTimeWarp: Allocate CTimewarpDrv\n"
+ "CTimeWarp: Allocate detector[%zu]...\n"
+ "CTimeWarp: FREE DETECTOR[%zu]...\n"
+ "CTimeWarp: FREE DRIVER\n"
+ "CTimeWarp: Process ch=%zu TS=%llu pTWMetaDataHost=%p\n"
+ "CTimeWarp: ch=%zu => recorded=%.3f fps unfilt=%.3f fps, skip=%u\n"
+ "CTimeWarp: host={recFPS=%.4f mode=0x%x luma=%.3f pets:%d gyr=%.2f}\n"
+ "CTimeWarp: mDebugFlags=0x%x\n"
+ "CTimeWarp: mode: 0x%x -> 0x%x\n"
+ "CTimeWarp: setForceFPS(%u fps)\n"
+ "CTimeWarp: setForceFusedFPS(%u = %.3f fps)\n"
+ "CTimeWarp: setForceRawFPS(%u = %.3f fps)\n"
+ "CTimeWarp: setMaxRecordingFPS(%u=%.4f fps)\n"
+ "CTimeWarp: setMaxSensorFPS(ch=%d, %u=%.2f fps)\n"
+ "CTimeWarp: setMinRecordingFPS(%u=%.4f fps)\n"
+ "CTimeWarp: setMinSensorFPS(ch=%d, %u=%.2f fps)\n"
+ "CTimeWarp: setRecordingChannel(ch=%d, rec=%d)\n"
+ "CTraceEventBuffer.cpp"
+ "CTuningParamService::Instance() != 0"
+ "CVA commit: %s %s"
+ "CVCPipelineInterfaceH17"
+ "CVD BeDest:0x%x, addr:0x%zx"
+ "CVD timeout go 0x%x pc 0x%x bootpc 0x%x halt 0x%x int 0x%x"
+ "CVDComb: config dma"
+ "CVDComb: hardware done"
+ "CVDComb: start hardware"
+ "CVDDMACfgSanityCheck"
+ "CVDSourceGo"
+ "CViSegDataService"
+ "CViSegRelease"
+ "CVideoFlowH17"
+ "CViseg:Event logger dump.\n"
+ "Cache the request from the user now here (0x%x 0x%llx userId 0x%lx)\n"
+ "Cache the request from the user sourceGoReq 0x%08x here (0x%x 0x%llx userId 0x%lx)\n"
+ "CacheSetting"
+ "CachedAWB: ch=%d fn=%d gain=%d %d %d ccm=%d %d %d"
+ "CachedReq"
+ "CalcAfRoiTargetDepth"
+ "CalcDoViMetadata"
+ "CalcHPPGridLut"
+ "CalcLTMSetupGains"
+ "CalcLTMandHITHSizes"
+ "CalcMBNRCSC1Coeffs"
+ "CalcMBNRCSC2Coeffs"
+ "CalcMBNRNFCoeff"
+ "CalcMBNRinvStdMemValue"
+ "CalcMaxInputTileLines"
+ "CalcSBMwMixCSCCoeffs"
+ "CalcSBMwMixCSCOffset"
+ "CalcSBMwMixLut"
+ "CalcTdcOffsetForPllfreq"
+ "CalculateBesOutValidRect"
+ "CalculateHDRShadowScore"
+ "CalculateLTMSpatailCCMGrid"
+ "CalculateM3GDCParamters"
+ "CalculateMiniSIFRRdoInUS"
+ "CalculateNextTargetGain"
+ "CalculateScalerInfo"
+ "CalculateSkinTileANODProbMap"
+ "CalculateSkinTileSemanticProbMap"
+ "CalculateSkyWhitePoint"
+ "CalculateUpperBoundPFL"
+ "Calculated rgbIrColorScale = %f"
+ "CalibTypeToStreamType"
+ "Call user registered ISR func"
+ "Called GPPipe->Post()\n"
+ "Called dummyPool->BufferLink(), CBuffer pInputParamBuffer = %p\n"
+ "Called dummyPool->BufferLink(), pOutputMetaDataBuffer = %p\n"
+ "Calling GPPipe->Post() with parameters:\n"
+ "Calling LVT AccelerateVE functions."
+ "CamSyncExit"
+ "Camera Orientation not defined for Channel: %zu"
+ "CameraGroupType == MultiSyncBack || CameraGroupType == MultiSyncDepth"
+ "CameraGroupType == MultiSyncFront"
+ "Can not overwrite binned config %u readout"
+ "Can't get HPP Gain grid buffer"
+ "Can't pass hPoolMan to AlgoControl!\n"
+ "Can't pass hPoolMan to flow!\n"
+ "Cannot change secure mode if task stopped"
+ "Captrue type %u"
+ "Capture abort, ch %u drop frame %d"
+ "CaptureChMask old %x new %x"
+ "CaptureDataConfig"
+ "CaptureDataSend2AE"
+ "CaptureProcess"
+ "CastlePeak ID: %02x"
+ "CastlePeak Rev: %02x OTPREV 0x%x TraceID 0x%02x%02x%02x%02x%02x%02x\n"
+ "CastlePeak: 0x%x 0x%x 0x%x 0x%x 0x%x\n"
+ "Center %d Corner %d Side %d mA\n"
+ "Cert update\n"
+ "Cfg %u %s: xAddSta %u, xEnd %u  xAddDataCount %d digScopeXSize %d -> %d"
+ "Cfg %u %s: xSta %u, xEnd %u, ySta %u->%u, yEnd %u->%u, digScope: ySta %u, ySize %u"
+ "Cfg %u ySta %u yEnd %u"
+ "CfgDmaForCurrDescLocalCopy"
+ "CfgTask_ProcessProjectorCommand"
+ "CfgTask_ProcessStreamingCommand"
+ "Ch %d, tuningP %lx"
+ "Ch %d, tuningP %lx isQuadraSensor %d, oisLSCHighResCalEn %d \n"
+ "Ch %u Frame %u Window %u buffer (%d %d) "
+ "Ch %zu NONIMAGEDATA Static Pool buffers:%zu w:%zu h:%zu s:%zu size %zu singleHeight %d"
+ "Ch %zu currFc %u sifr %u %u fd %u \n"
+ "Ch %zu projector start Done, signal prepareStop sequence"
+ "Ch %zu will use dynamic buffer pool for fep thumbnail"
+ "Ch %zu, config %d, Qbin %d, fepBin(%d, %d), sifBin(%d, %d)\n "
+ "Ch %zu, fc %d, Sideband Busy %d State %d"
+ "Ch %zu: Disable Common buffer pool for %d & %d mask %x"
+ "Ch %zu: Enable Common buffer pool for %d & %d mask %x %llx"
+ "Ch0StartEvent"
+ "Ch0StartEventDMANoneRealtime"
+ "Ch0StopEvent"
+ "Ch:%zu FC:%d state:%d: not enabled first frame stop streaming now"
+ "Ch:%zu stop streaming now FC:%d ICState:%d CapSt:%d ffe:%d"
+ "ChTimeMachineDescr pDescr = %p\n"
+ "Ch[%lu]: Blob %d Blob_64 %d"
+ "Ch[%lu]: Reserve %d Reserve_64 %d"
+ "Ch[%lu]: dumpSize %d dumpSize_64 %d"
+ "Challenge"
+ "Change ch %u fr %u channelsInSync %u to %u"
+ "Change ch %zu registration scheme to static GYRO ONLY"
+ "Change maxVirtFrmHeightToUse from %u to %u"
+ "ChangeEmitterStatus"
+ "Changed customWindowWeights with %ux%u input"
+ "Channel %ld is active, its min/max frame rates: %d/%d, SyncGroupId 0X%02x"
+ "Channel %zu: Put frameId %u in TM queue."
+ "Channel %zu: release frameId %u in TM queue."
+ "Channel (%lu) and usecase (%u) mismatch"
+ "Channel Mask : 0x%x is different from Active sync group Mask: 0x%x\n"
+ "Channel%zu: Getting Property %x Value %x for Stats Debug \n"
+ "Channel: %hhu"
+ "ChannelCleanUp"
+ "ChannelCommand(): pGeneralProcessCompressedOut = %p\n"
+ "ChannelCommand(): pGeneralProcessImage = %p\n"
+ "ChannelCommand(): pGeneralProcessParam = %p\n"
+ "ChannelCommand(): pGeneralProcessSensor = %p\n"
+ "ChannelCommand(): sCIspGeneralProcessOutputCompressedSize = %p\n"
+ "ChannelConfigSelect"
+ "ChannelInMF(ch)"
+ "ChannelInMF(inputCh)"
+ "ChannelInMF(master_ch)"
+ "ChannelInMF(slave_ch)"
+ "ChannelProcessInit"
+ "ChannelReset"
+ "ChannelSetup"
+ "ChannelSetupCommon"
+ "ChannelStart"
+ "ChannelStartRTPipe"
+ "ChannelStartedGP"
+ "ChannelStatProcess"
+ "ChannelStatStillProcess"
+ "ChannelStatsTileWindowConfig"
+ "ChannelStopped"
+ "ChannelStoppedGP"
+ "ChannelTearDown"
+ "ChannelToStreamType"
+ "ChargePumpFreqConfigSet"
+ "ChargePumpFreqGet"
+ "ChckAndAllocTileGdcBuffers"
+ "Check %d"
+ "Check %d\n"
+ "Check %d %p"
+ "Check %d %p\n"
+ "Check %d: primitive %d nbrOfBuffer %d\n"
+ "Check cache after user request nbrOfSecUsed = 0x%x finished @ %llu \n"
+ "CheckAndUpdateAnGlobalOp"
+ "CheckBusySource"
+ "CheckCircularBufferDepthRange"
+ "CheckDepthDataForAPE"
+ "CheckDepthRangeUsingTwoDistances"
+ "CheckDestinations"
+ "CheckDevice"
+ "CheckDevice %x\n"
+ "CheckDriver(idx) != M3_INVALID_DRIVER"
+ "CheckExtSyncCriteria"
+ "CheckFactoryPreconditions() == CPCE_ERRCODE_RES_SUCCESS"
+ "CheckIfSafeToProcessFrameDone"
+ "CheckIfSafeToStop"
+ "CheckLTMHistOutputValidity"
+ "CheckLuxForAPE"
+ "CheckPDAFConfidence"
+ "CheckProcessingDestinations"
+ "CheckQIfAllBufsFromOneCh"
+ "CheckSectionBankAvalible(sectionId, bankId)"
+ "CheckSectionIdle(sectionId)"
+ "CheckSyncBufferQ"
+ "CheckTemperatureCondition"
+ "CheckToPrepareSifrFrame"
+ "CheckTripod"
+ "Chg AE sampling rate from %u (%.3f) to %u (%.3f Hz=every %.1fs)"
+ "Chg AWB sampling rate from %u (%.3f) to %u (%.3f Hz=every %.1fs)\n"
+ "ChooseCalib"
+ "ChooseCalibAndIntrinsics"
+ "ChooseCurConfigTable - ch=%d, configTable=%d, standardFrameRate=%.2f"
+ "ChooseGmsAlgo"
+ "ChooseOutputConfig"
+ "ChoosePCERegsType"
+ "ChromaHist Sky=%.2f Tot=%.2f"
+ "ChromaOffsetGet"
+ "ChromaOffsetGet(): Chroma offset is not supported in H17's BES.\n"
+ "Clear left over irq from src %d irqIndex %x"
+ "ClearDmaChain"
+ "ClearRoutingTable"
+ "ClearRoutingTableSlot"
+ "Clearing Regulus reg 0x%x, 0x%x\n"
+ "Clock Enable/Disable Needs to Move to SecureM3\n"
+ "ClockConfigure"
+ "ClockPadConfig"
+ "ClrBe output frame error: ch=%d frame=%d"
+ "ClrBeProcSetup"
+ "ClrFeProcSetup"
+ "Cmd"
+ "Cmd Processor handling unblocking algoctrl cmds first"
+ "Cmd timeout detected by driver: %p"
+ "CmdAEWindowEnable"
+ "CmdAFEProcConfigSensorSet"
+ "CmdAFEProcEnable"
+ "CmdAFWindowEnable"
+ "CmdAGCSet"
+ "CmdANSTThumbnailEnable"
+ "CmdAOPRingBufferReset"
+ "CmdAOPRingBufferSet"
+ "CmdAWBWindowEnable"
+ "CmdAWBWindowSet"
+ "CmdAcknowledge"
+ "CmdAfFocusNow"
+ "CmdAfFocusNowDone"
+ "CmdAuxSclPyrConfig"
+ "CmdBESOutputValidRectGet"
+ "CmdBesAuxCropOutputSizeSet"
+ "CmdBesVirtualOutputCropSet"
+ "CmdBlockStateChange"
+ "CmdBracketingParamsSet"
+ "CmdCCM2DCoefficientSet"
+ "CmdCSCConfigUpdate"
+ "CmdCacheControlSet"
+ "CmdCallProcedure"
+ "CmdCaptureConfig"
+ "CmdChromaSampleOffsetSet"
+ "CmdClrBesCropOutputSizeSet"
+ "CmdClrProcCropSet"
+ "CmdClrProcOutputEnable"
+ "CmdClrProcOutputFormatSet"
+ "CmdColorHistConfigUpdate"
+ "CmdConfigOutStreamSelect"
+ "CmdConfigOutStrm"
+ "CmdConfigSensorSet"
+ "CmdConfigureMultiPassMultiStep"
+ "CmdContextSwitchActiveConfigsSet"
+ "CmdContextSwitchStreamingConfigsSet"
+ "CmdControllerNotification"
+ "CmdCropOutputSizeSet"
+ "CmdCropScaleWindowSet"
+ "CmdDGCSet"
+ "CmdDPCEnable"
+ "CmdDualRsclEnable"
+ "CmdEnableDma"
+ "CmdEnableOptionalPipeDst"
+ "CmdErrorNotification"
+ "CmdExitFlow"
+ "CmdExposureGainProjectorSet"
+ "CmdExposureGainSet"
+ "CmdExposureTimeSet"
+ "CmdFSCLCropSet"
+ "CmdFSCLOriginalOutputSizeSet"
+ "CmdFSCLOutputSizeSet"
+ "CmdFSCLStillCropSizeSet"
+ "CmdFlickerFreqSet"
+ "CmdFrameRateSet"
+ "CmdFusionTypeSet"
+ "CmdGDREnable"
+ "CmdGetEndPointStatus"
+ "CmdGetIpcSharedBuffer"
+ "CmdGetOutstandingTicketCnt"
+ "CmdGetProgramDescription"
+ "CmdHandleRawBufInit"
+ "CmdHighResAEAWBWindowEnable"
+ "CmdHighResAEAWBWindowSet"
+ "CmdHistogramXToCCTLutSet"
+ "CmdInitExposureTimeSet"
+ "CmdInitFrameRateSet"
+ "CmdIpcEndpointSet"
+ "CmdIpcEndpointUnset"
+ "CmdIpcSharedMemoryFree"
+ "CmdIpcSharedMemoryMalloc"
+ "CmdLSCIdealPctSet"
+ "CmdLSCTableSourceSet"
+ "CmdLSParamsCroppedImagePerConfigInit"
+ "CmdLSParamsCroppedImageSelect"
+ "CmdLaccHFFImgSet"
+ "CmdLaccOccupied"
+ "CmdLoadProgram"
+ "CmdLuxLevelDetectionEnable"
+ "CmdM2MGDCBufferSizeSet"
+ "CmdMCacheRelease"
+ "CmdMCacheRequest"
+ "CmdMCacheUpdate"
+ "CmdMLVNRModeConfigSet"
+ "CmdMLVNRNightModeConfigSet"
+ "CmdMLVNRTimeWarpConfigSet"
+ "CmdMSControlEnable"
+ "CmdMSSyncOffsetTypeSet"
+ "CmdMSTFScale0Enable"
+ "CmdMSTFScale0LightingCtrl"
+ "CmdMSTFScale0StrModCtrl"
+ "CmdMSTFScale0StrModThresSet"
+ "CmdManualControlConfigLTMDynamicLTC"
+ "CmdManualControlConfigLTMLTC"
+ "CmdManualControlConfigLTMSCCM"
+ "CmdMaxGDCStrengthGet"
+ "CmdMsBePYRCropSet"
+ "CmdMsBePYROutputSizeSet"
+ "CmdMsBePYRScalerSupport"
+ "CmdMthCCScaleUpdate"
+ "CmdMthCSCConfigUpdate"
+ "CmdMthMiredLutUpdate"
+ "CmdMultiCamSyncSet"
+ "CmdMultiChUnifiedBracketingParamsSet"
+ "CmdMultiSensorColorCalAbsSet"
+ "CmdOneShotTestANST"
+ "CmdOneShotTestATTR"
+ "CmdOneShotTestImpl"
+ "CmdOutputSizeSet"
+ "CmdOutputStreamEnable"
+ "CmdPCENonSecureToSecurePost"
+ "CmdPCENonSecureToSecurePost failed"
+ "CmdPCESecureToNonSecurePost"
+ "CmdPCESecureToNonSecurePost failed"
+ "CmdPDEEnable"
+ "CmdPowerControl"
+ "CmdProcess Enter ch:%zu id:%zu ts:%f"
+ "CmdProcess Exit ch:%zu id:%zu ts:%f"
+ "CmdProcessorCommon"
+ "CmdProcessorOutputConfig"
+ "CmdProcessorPceSessionStatsGet"
+ "CmdProcessorPropertyWrite"
+ "CmdProjectionPointSet"
+ "CmdPropertyRead"
+ "CmdPyrVIOOutputConfigGet"
+ "CmdRGBRegister"
+ "CmdRNFRadialGainAsymScaleInit"
+ "CmdRadialGainAsymScaleInit"
+ "CmdRegIpcSap"
+ "CmdRegSAP"
+ "CmdRegisterCounterNotification"
+ "CmdReset"
+ "CmdReturnIpcSharedBuffer"
+ "CmdRunAnstOnOneExtFrame"
+ "CmdSDGCSet"
+ "CmdSMVAWBEnable"
+ "CmdSMVEnable"
+ "CmdSTFEnableSet"
+ "CmdScalerCropSet"
+ "CmdSemanticMaskEnable"
+ "CmdSendBufMsg"
+ "CmdSensorCalBiasSet"
+ "CmdSensorCalIdealChannelSet"
+ "CmdSetCompanionWrapConfig"
+ "CmdSetConfig"
+ "CmdSetExrinsics"
+ "CmdSetFileVersionUpdate"
+ "CmdSetMatchSecToPriExposure"
+ "CmdSetMatchSecToPriExposure ch %zu value %d"
+ "CmdSetMetaDataRequired"
+ "CmdSetPreviewBoxMargin"
+ "CmdSetSourcePipeDmaConfig"
+ "CmdSetStripConfig"
+ "CmdSetfileInfoSet"
+ "CmdSetupChannel"
+ "CmdSetupFlow"
+ "CmdSifConfig"
+ "CmdSifConfigGet"
+ "CmdStartCapture"
+ "CmdStartFlow"
+ "CmdStatCropScaleWindowSet"
+ "CmdStaticDefectsTableListAdd"
+ "CmdStfLaccImgSet"
+ "CmdStopCapture"
+ "CmdStopFlow"
+ "CmdStreamingModeSet"
+ "CmdTFBufConfig"
+ "CmdTFConfig"
+ "CmdTFEnable"
+ "CmdTFMaxSizeSet"
+ "CmdTNRStrengthHighEnable"
+ "CmdTailspinNotification"
+ "CmdTestPatternConfig"
+ "CmdThumbnailMaskConfigSet"
+ "CmdTileGDCStrengthSet"
+ "CmdTracePost"
+ "CmdTurnOffAllRail"
+ "CmdTurnOffPower"
+ "CmdTurnOnAllRail"
+ "CmdTurnOnPower"
+ "CmdUnRegSAP"
+ "CmdUnifiedBracketingParamsSet"
+ "CmdUnloadProgram"
+ "CmdUpdateAlgData"
+ "CmdUpdateDeviceImpact"
+ "CmdUpdateInputConfig"
+ "CmdWaitOutputStreamChangeReady"
+ "CmdWarmStartupSet"
+ "CmdZoom1xCropSet"
+ "CmpLoHist"
+ "CmpSectionFrom"
+ "CmpSegmentFrom"
+ "CmpTableFrom"
+ "CmpThHist"
+ "CnfgDrvRstDone"
+ "Coeff != NULL"
+ "Coeffs %d %d %d"
+ "Color2DHist Received!"
+ "ColorCal gains rgGain=%f, bgGain=%f"
+ "ColorHist2DProcess"
+ "ColorMode: %d, CpreNom: 0x%04x CstrNom: 0x%04x cct: %d ambientLux: %d"
+ "ColorMode=%d (param=%d%% warm LED) CpreMan=0x%04x CstrMan=0x%04x"
+ "ColorMode=%d (param=%d) CpreMan=0x%04x CstrMan=0x%04x"
+ "ColorMode=%d (param=0x%04x) CpreMan=0x%04x CstrMan=0x%04x"
+ "CommonInitialization"
+ "Completed Process in FSM stat:%d waiting for s:%d"
+ "ComponentEnable"
+ "CompressedSizeProcess"
+ "Compute ClrBe Tile MCache size=0x%x with format=%d\n"
+ "ComputeAWBChromaHistogram"
+ "ComputeAWBGains"
+ "ComputeAWBGainsCore"
+ "ComputeAWBGainsGrayworld"
+ "ComputeBESZoomParam"
+ "ComputeBLC"
+ "ComputeCameraCalData"
+ "ComputeClrBeTileM$Size"
+ "ComputeControlRateToRecordedRate"
+ "ComputeDepthTof"
+ "ComputeDesiredRecordingFPS"
+ "ComputeDigitalFlashAWBV2"
+ "ComputeExposureSettingsFromTargetEIT"
+ "ComputeGDCLUT"
+ "ComputeGlassDetectIndicator"
+ "ComputeHomography"
+ "ComputeLumaFromThumbnail"
+ "ComputeMTHConfig"
+ "ComputeMTHConfigV2"
+ "ComputeMaxRdOutTm"
+ "ComputeMsWarperM3DmaBuffer"
+ "ComputeMsWarperM3DmaBuffer: mesh size = %u, max M3 buffer size = %zu"
+ "ComputeMsWarperM3DmaBuffer_DMA"
+ "ComputeNextAESettings"
+ "ComputeNextFrameEIT"
+ "ComputeNextSifrEIT"
+ "ComputeOISMargin"
+ "ComputeSafeBWRPeriodAtFV"
+ "ComputeSifrTurnOff"
+ "ComputeSinglePipelineMaxFESOutputSize"
+ "ComputeSkinColor_fdProbApproach"
+ "ComputeSpatialCCMWeightMap"
+ "ComputeThumbnailHistogram"
+ "ComputeVirtualFrameSizeForSampling"
+ "ComputeWeightedAFScore"
+ "ComputerCmpnWrapConfig"
+ "ComputerFrameCmpnM$Config"
+ "ConfidneceMap Buffer not avialble now. ch %zu, frCnt %llu"
+ "Config mode set to noise model: %u\n"
+ "Config mode: %u\n"
+ "Config sensor disabled"
+ "Config sensor size %dx%d"
+ "ConfigAFTile"
+ "ConfigAFWindow"
+ "ConfigAWBWindow"
+ "ConfigAWBWindow4FD"
+ "ConfigAWBWindow4FD bypass!!! ch %zu pipe %u frameCount %u\n"
+ "ConfigCheck"
+ "ConfigCheck: {%d, %d, %d, %d, %d}, %d\n"
+ "ConfigColorHist2DWindow"
+ "ConfigFEPDma2nd"
+ "ConfigFEPPipe2nd"
+ "ConfigFEPSrcSize"
+ "ConfigHighResAEAWBWindow"
+ "ConfigMSGSettings"
+ "ConfigPipeline"
+ "ConfigRTDma"
+ "ConfigSet"
+ "ConfigSet end"
+ "ConfigSet start"
+ "ConfigUpdate"
+ "ConfigUpdate %zu %f\n"
+ "ConfigUpdateDone"
+ "Configure both banks of SIF before CH_START ch %zu fc %d "
+ "Configure endPointId %d @ %llu\n"
+ "ConfigureAFStats"
+ "ConfigureSLAF"
+ "ConfigureSLAFAppControlled"
+ "ConfigureSLAFFWControlled"
+ "Context switch still raw buffer not setup"
+ "ContextSwitchCITLossMsCompute"
+ "ContextSwitchConfigGet"
+ "Control"
+ "Convert2HWAction"
+ "Convert2HWActionCmpnWrap"
+ "Convert2HWActionForSection"
+ "ConvertData"
+ "Cool 0x%x Warm 0x%x, mode %d iCool %dmA iWarm %dmA"
+ "CoolGain updated. coolRgGain: %u, coolBgGain: %u"
+ "Copy GDC table: %lu bytes\n"
+ "Copy Section %d : with noVersionCheck = %d\n"
+ "CopyAWBToMasterChHostMetaData"
+ "CopyActiveEventsToBuffer"
+ "CopyCmpnRtrDescFrom"
+ "CopyIspLutFromDB"
+ "CopyIspRegFromDB"
+ "CopySectionFrom"
+ "CopySectionFromPIODMAList"
+ "CopyTableFrom"
+ "CopyTableFromPIODMAList"
+ "CopyToRegsPIODMA"
+ "Core entering TS %f\n"
+ "Correct Sample ts %f localTs %f (isp %f oscar %f motion %f)\n"
+ "Cost %llu us"
+ "Could not save filename! %s"
+ "Couldn't get distortion parameters"
+ "CpreDual: 0x%x"
+ "CpreDual=0x%04x oldCool=%d mA oldWarm=%d mA,maxCurrent= 0x%08x mA,maxRatio=0x%08x"
+ "CpreDual=0x%04x oldCool=%d mA oldWarm=%d mA,maxTCurr_mAmps= 0x%08x,maxTCurrRatio=0x%08x"
+ "CpreDual=0x%04x oldCool=%d mA oldWarm=%d mA,maxTorchCurrent_mAmps= 0x%08x,maxTorchCurrentRatio=0x%08x"
+ "CpreNom: 0x%04X, CpreMan: 0x%04X"
+ "CpreNom=0x%04x coolreg: 0x%x, warmreg: 0x%x"
+ "CpreNom=0x%4x coolreg: 0x%x, warmreg: 0x%x"
+ "CpreNom=0x%x CstrNom=0x%x"
+ "Create"
+ "Create DesGen operation"
+ "Create Object %s"
+ "Create,%lu,%s"
+ "CreateFlowFactory"
+ "CreateISPEngine"
+ "CreateProcessBackEnd"
+ "CreateSession"
+ "CreateSifDMAInterface"
+ "CreateVCPipelineInterface"
+ "Creating LPDP driver for id %d rev %d"
+ "Crop End(%lld)"
+ "Crop End(%lld) MMS Hw: count %d min %d max %d sum %llu sumSq %llu"
+ "Crop Start(%lld) in (%dX%d) out (%dX%d)"
+ "CropRegionSet"
+ "CropScaleWindowSet"
+ "CstrDual=0x%04x cool=0x%x warm=0x%x"
+ "CstrDual=0x%04x oldCool=%d mA oldWarm=%d mA, max_Amps= 0x%08x, maxRatio=0x%08x"
+ "CstrDual=0x%x maxStrCurrent=0x%x or %dmA, mainStrCurrent: 0x%x or %dmA"
+ "CstrNom: 0x%04X"
+ "CstrobeLM3566::Fp2Cpre(->if (iTorch > Ytarg: 0x%x, pctIntens10: 0x%x\n"
+ "CstrobeLM3566::Fp2Cpre(0x%02x,0x%08x,0x%08x,0x%08x,0x%04x,0x%04x,0x%08x) = 0x%04x\n"
+ "CstrobeLM3566::Fp2Cpre(CpreDual): 0x%x\n"
+ "CstrobeLM3566::Fp2Cpre: cCool=0x%x, iCool=%d, cWarm=0x%x, iWarm=%d, cTorch=0x%x, iTorch=%d, Yled=%lld pctIntens10=%d \n"
+ "CstrobeLM3566::YledIdeal %lld\n"
+ "Ctrl: Enable=%d, ClkGateEn=%d, BufferSize=%d"
+ "CtxSwitch bitmap not set by driver ch:%zu cfg:%d use sensor bitmap:0x%x"
+ "Curr %dmA => 0x%x\n"
+ "Curr request %d uA, regval 0x%x duty %d\n"
+ "CurrFr %u (ch#InSync %u ws %.0f) PrevFr %u (InSync %u ws %.0f)"
+ "Current %dmA => 0x%x\n"
+ "Current Center:Corner:Side %d %d %d mA\n"
+ "Current set to %llumA\n"
+ "Current= 0x%x or %7.2f mA reg= 0x%04x"
+ "Currently other Companion Wrap Groups don't use this method"
+ "CvP MMS[%d] count %d min %d max %d sum %llu sumsq %llu"
+ "CvPipe dma[%d] fmt %d w %d h %d s %zu"
+ "CvPipe timeout"
+ "CvPipe used %.3fms"
+ "CvPipe. pio %d r %zu w %zu"
+ "CvdDp enabled, Host meta not available"
+ "CvdDp is not enabled[%lu]: %d"
+ "D3y"
+ "D4y"
+ "D6 currRange 0x%x, maxCurrentOTP[1] %d mA, [2] %d mA\n"
+ "D8x"
+ "D9x"
+ "DART Error detected by driver: %p"
+ "DATA_DST_END - DATA_DST_START < 32"
+ "DBCopy"
+ "DBG - ch=%ld, chStartedCount=%ld"
+ "DBG - ch=%ld, chStartedCount=%ld - mask=0x%zx, - %d %d %d"
+ "DBG26: ch %zu totVcPipeNeeded %d"
+ "DBG: Full bbox: %f %f %f %f"
+ "DBG: depth cam obstructed."
+ "DBG: depthDist %f"
+ "DBG: m_lastDepthDist %f"
+ "DBG: shifted bbox: %f %f %f %f"
+ "DBG: uxfeedback process %u"
+ "DBG_DB: ch %zu opMode %d fps %f vhdrEnable %d sync %d"
+ "DBG_DB: ch %zu property %d double bank En %d"
+ "DBG_LOG_S_WRI"
+ "DEBUG - personMaskFOV (%d, %d), size (%d, %d)"
+ "DEBUG - pixProcessingFOVRect (%d, %d), size (%d, %d)"
+ "DEBUG - sensorReadOutCropRect (%d, %d), size (%d, %d)"
+ "DEBUG - setFOVs on chId: %zu"
+ "DEC_DUTY_ADD_MOD - ch=%d, stdFR=%.2f, type=%d, valid=%d, runSltCfg=%d, period=%d, dcRate=%.2f"
+ "DEPRECATED"
+ "DESGEN Flow 0"
+ "DESGEN Flow 2"
+ "DESGEN: config dma"
+ "DESGEN: hardware done"
+ "DESGEN: start hardware"
+ "DESGENF2_KEY_DUMP(Pruned&Partitioned): framename %d"
+ "DESGENF2_KEY_DUMP(UnPruned&Partitioned): framename %d"
+ "DESMATCH_ALL_PAIR_DUMP(NoPruning): framename %d"
+ "DESMATCH_BG_PAIR_DUMP(Pruned&Partitioned): framename %d"
+ "DESMATCH_FG_PAIR_DUMP(Pruned&Partitioned): framename %d"
+ "DESMATCH_KEY_DUMP(Pruned&Partitioned): framename %d"
+ "DETTACH: sif %d "
+ "DIST Replay GMSLoop: %f %f %f cfg %u"
+ "DL:%.2f->%.2f upd=%.3f stddev=%.03f slow=%.3f %% flags=0x%x"
+ "DMA %s: BWR %d"
+ "DMA input, Tile mode\n"
+ "DMA input: YUV420_2Plane, Non-tile mode\n"
+ "DMA input: YUV420_2Plane, tile mode\n"
+ "DMA input: YUV422_1Plane, Non-tile mode\n"
+ "DMA output, Non-Tile mode\n"
+ "DMA output, Tile mode\n"
+ "DMA: DesGenDmaSrc: width=%d height=%d"
+ "DMA: DesMatchDmaSrc: width=%d height=%d"
+ "DMA: ID(%d): width=%d height=%d stride=%zu baseAddr=%p"
+ "DMA: LaccMatchDmaDst0: laccMatchWMA0StartAddrLow=0x%08x laccMatchWMA0StartAddrHigh=0x%08x laccWmaCfg=0x%08x"
+ "DMA: LaccMatchDmaDst1: laccMatchWMA1StartAddrLow=0x%08x laccMatchWMA1StartAddrHigh=0x%08x laccWmaCfg=0x%08x"
+ "DMA: LaccMatchDmaDst2: laccMatchWMA1StartAddrLow=0x%08x laccMatchWMA1StartAddrHigh=0x%08x laccWmaCfg=0x%08x"
+ "DMA: LaccMatchDmaDst2: laccMatchWMA2StartAddrLow=0x%08x laccMatchWMA2StartAddrHigh=0x%08x laccWmaCfg=0x%08x"
+ "DMA: LaccMatchDmaSrc0: laccMatchRMA0StartAddrLow=0x%08x laccMatchRMA0StartAddrHigh=0x%08x laccWmaCfg=0x%08x"
+ "DMA: LaccMatchDmaSrc1: laccMatchRMA1StartAddrLow=0x%08x laccMatchRMA1StartAddrHigh=0x%08x laccWmaCfg=0x%08x"
+ "DMA: laccMatchRMA0 Low=0x%08x High=0x%08x laccWmaCfg=0x%08x"
+ "DMA: laccMatchRMA1 Low=0x%08x High=0x%08x laccWmaCfg=0x%08x"
+ "DMA: laccMatchRMA2 Low=0x%08x High=0x%08x laccWmaCfg=0x%08x"
+ "DMA: laccMatchRMA3 Low=0x%08x High=0x%08x laccWmaCfg=0x%08x"
+ "DMA: laccMatchWMA0 Low=0x%08x High=0x%08x laccWmaCfg=0x%08x"
+ "DMA: laccMatchWMA1 Low=0x%08x High=0x%08x laccWmaCfg=0x%08x"
+ "DMA: laccMatchWMA2 Low=0x%08x High=0x%08x laccWmaCfg=0x%08x"
+ "DMA: laccMatchWMA3 Low=0x%08x High=0x%08x laccWmaCfg=0x%08x"
+ "DMA: section[%d] = %d"
+ "DMA: source = %d"
+ "DMAChainSetup"
+ "DMACmpnWrapConfig"
+ "DMACompBfrConfig"
+ "DMACompBfrConfig(): cmpBase=0x%lx, cmpSize=%ld, cmpMax=0x%lx\n"
+ "DMACompBfrConfig(): hdrBase=0x%lx, hdrSize=%ld, hdrMax=0x%lx\n"
+ "DMAConfig=0x%x DMABfrConfig=0x%x DMASTTConfig=0x%x BaseAddr=0x%x Fmt=0x%x Offset=0x%x PixelOffsetScale=0x%x Size=0x%x Stride=0x%x\n"
+ "DMAConfig=0x%x DMABfrConfig=0x%x DMASTTConfig=0x%x BaseAddr=0x%x Fmt=0x%x Offset=0x%x PixelOffsetScale=0x%x Size=0x%x Stride=0x%x RegionStartXY=0x%x RegionEndXY=0x%x PadConfig=0x%x\n"
+ "DMAId < ISPHWH17DMAId_MaxNbr"
+ "DMAInChannelAlloc"
+ "DMAInChannelFree"
+ "DMAModeDoubleBankingGo"
+ "DMAModeGo"
+ "DMAModePrepareForArm"
+ "DMATrigger"
+ "DMA_CHAIN: Clear chain mode at index %d"
+ "DMA_CHAIN: Setup %d -> %d in chain mode using index %d"
+ "DMA_DONE"
+ "DPC STAT WaitUntilFull buffers available:%zu/%d"
+ "DPCBuf"
+ "DPCConfigSettings"
+ "DPCStatProcess"
+ "DPM initialized %s"
+ "DPRXCApplyTunable"
+ "DQReq[%zu] 0x%x (%llu, %llu)(%u %u) {%u %u %u %u}"
+ "DRtemp %f DRtemp1 %f\n"
+ "DSC"
+ "DUALBKT:IR[%d] = req 0x%x(%d), exp %llu (%f),g %.2f, v %u->%u, p (%d, %d), flow %d\n"
+ "Data Processor handle unblocking algoctrl cmds first"
+ "Data is NULL, refIdx=%hu"
+ "DbgPrintHostMetadataInfo"
+ "DeInit"
+ "DebugSavePCEInputToHostMetaData"
+ "DebugTask"
+ "DecideADRCFromScore"
+ "DecideADRCNextSifrTargetEIT"
+ "DecideFromHistory"
+ "DeepCopyAndReleaseBuffers"
+ "DefaultAWB: ch=%d fn=%d gain=%d %d %d ccm=%d %d %d"
+ "DefaultConfigurationCSCMatrix"
+ "DefaultSensorArrayRectInConfig"
+ "DefaultSetupAWB"
+ "Delete"
+ "Delete FloatImage::'%s' %dx%d %p\n"
+ "Delete sharedPool[%d][%d]= %p"
+ "Delete,%lu,%s"
+ "Deleting all action and operation configs"
+ "Depth and IR"
+ "Depth entry type is invalid"
+ "Depth file not found"
+ "Depth processing requires >0 spots"
+ "Depth size is good (%zu)"
+ "DequeueUpdateRequest"
+ "DequeueUpdateRequest requestId %llu"
+ "Dequeued PIODMA nxtFrameId %llu\n"
+ "Destination size must be even numbers!"
+ "DestroySession"
+ "Detected inconsistent motion"
+ "Detected unsteady motion"
+ "Detecting the Fake Sensor now\n"
+ "DetermineFlowType"
+ "DetermineRegisterBankOpMode"
+ "DetermineSensorStreamingMode"
+ "DettachFEP"
+ "Diable ch %zu frame %u color 2d hist.\n"
+ "Diff image CH[%zu]: time = %f ms!\n"
+ "Disable MSTF for ch=%ld, frame=%d which is left in inputFrameBufQ after StopMSTF"
+ "Disable centering from x:%d y:%d to 0 0"
+ "Disable centering from x:%d y:%d to 0 for secondary output"
+ "Disable dither mode for Slo-mo modes or specified devices"
+ "DisableRegistration"
+ "Disabling client task logging for Pool(%s[%p])\n"
+ "Display"
+ "DisplayAll"
+ "DistDrv RGB calibration intrinsics version changed!"
+ "DistortionCalibrationSanityCheck"
+ "DistortionCurveSanityCheck"
+ "DmaModeMeshBufferSanityCheck"
+ "DmaProgDone"
+ "DmaProgStart"
+ "DoSemanticProcAccelerated"
+ "Done torch cntrl TS %f\n"
+ "DoneFrm"
+ "DoneId %llu pipeDoneID %llu pipPrepID %llu process %u aborted %u @%f\n"
+ "DoneToLACCIRQEn"
+ "DoneToLACCMatchIRQEn: CVD_CVDCONFIG_PIPE_CVDCONFIG_DONETOLACCMATCHIRQEN(0x%lx)=0x%08x"
+ "DoneToLACCMatchIRQEn[%d]: CVD_CVDCONFIG_PIPE_CVDCONFIG_DONETOLACCMATCHIRQEN(0x%lx)=0x%08x"
+ "Done_CONTEXTSWITCH"
+ "DopplerSignal"
+ "DownSampleX = %d, hith_width = %d"
+ "DpcBufferProcessor"
+ "DrawLatestRect"
+ "Driver notified: FW crash or panic detected, halt ISPCPU"
+ "Drop unexpected LACCMATCH_STATUS0 irq 0x%x"
+ "DropFrame"
+ "DsIdClrRegCheck"
+ "DsIdClrRegClear"
+ "Dst: isPack=%d, offset=0x%lx\n"
+ "Dst:init  (%d, %d) sz ( %d, %d), mode: (%d, %d)"
+ "DstDMA regOffset=0x%x icCompOffset=%d cmpnOffset=%d cmpnWrapOffset=%d compOffset=%d\n"
+ "Dual OIS M (%lld): exp %llu (%.1f), gain 0x%x (%.2f) vSize %d"
+ "Dual OIS S (%lld): exp %llu (%.1f), gain 0x%x (%.2f) vSize %d"
+ "Dump comeplete - X"
+ "Dump2"
+ "DumpBuffersToDisk"
+ "DumpGroup is %d"
+ "DumpHWRegisters"
+ "DumpHistDataAlgFE"
+ "DumpHistDataFE"
+ "DumpInput"
+ "DumpInputFrame"
+ "DumpIspDmaMemory"
+ "DumpIspRegisters"
+ "DumpOutputsBuffers"
+ "DumpOutputsGMS"
+ "DumpOutputsMetaDataJson"
+ "DumpPCEMem"
+ "DumpRegisters"
+ "DumpSectionRegister"
+ "DumpStatsAlgData"
+ "DumpStatsForDebug"
+ "DumpTableRegister"
+ "DumpYUVBuffer"
+ "Dumping IC Buffers..."
+ "Duplicate endpoint channel"
+ "DvcEnable"
+ "DvcEnable, gpio: %u, addr: 0x%04x, data: 0x%08x\n"
+ "DvcRun"
+ "DvcSetOverride"
+ "DvcVselTarget, gpio: %u, addr: 0x%04x, data: 0x%02x(mV: %u mV)\n"
+ "ECDH boot failed\n"
+ "ECDHKeyGet"
+ "EEP Rtrace %d ohm, ADC %d ohm, Delta %d"
+ "EEPIdle"
+ "EEPRead"
+ "EITs ambient  %f Preflash %f\n"
+ "EN: 0x%x, ch0/1 0x%x, ch2 0x%x ch3 0x%x\n"
+ "END"
+ "ENQOut[%zu] 0x%x (%llu, %llu)(%llu %u) {%u %u %u %u}"
+ "ENT: CAICamProc.cpp, "
+ "ENT: CAICamProcAnst.cpp, "
+ "ENT: CDSControllerH8.cpp, "
+ "ENT: CDcnAttnH11.cpp, "
+ "ENT: CDcnProc.cpp, "
+ "ENT: CDcnProcH11.cpp, "
+ "ENT: CDotEFuse.cpp, "
+ "ENT: CERDcnProcH11.cpp, "
+ "ENT: CFDDcnProcH11.cpp, "
+ "ENT: CFSM.cpp, "
+ "ENT: CFloodEFuse.cpp, "
+ "ENT: CGPIODriverAldaST.cpp, "
+ "ENT: CGrievous.cpp, "
+ "ENT: CImageCaptureFlash.cpp, "
+ "ENT: CImageCaptureMultiSyncCams.cpp, "
+ "ENT: CImageFlowH17.cpp, "
+ "ENT: CIspEngineCVDExeLoopH17.cpp, "
+ "ENT: CIspEngineCVDServerH17.cpp, "
+ "ENT: CIspEngineClientH17.cpp, "
+ "ENT: CIspEngineExeLoopH17.cpp, "
+ "ENT: CIspEngineServerH17.cpp, "
+ "ENT: CIspOperationCVDCombH17.cpp, "
+ "ENT: CIspOperationDesGenH17.cpp, "
+ "ENT: CIspOperationDesMatchH17.cpp, "
+ "ENT: CIspOperationNccH17.cpp, "
+ "ENT: CMamaBear.cpp, "
+ "ENT: CScopedLock.cpp, "
+ "ENT: CStrobeQuark.cpp, "
+ "ENT: CStrobeRegulus.cpp, "
+ "ENT: CStrobeRigel.cpp, "
+ "ENT: CTaskProfiler.cpp, "
+ "ENT: H17TunableManager.cpp, "
+ "ENT: TunableManager.cpp, "
+ "ENTER"
+ "EP[%d] %d tickets outstanding at itr %d\n"
+ "ER Buffer input %zu output %zu scratch %zu"
+ "ER Bufs[%d] size %zu stride %zu"
+ "ER DBG: %zu %zu\n"
+ "ER FW: Projector off for fr %d.\n"
+ "ER PostProcessing time: %llu us\n"
+ "ER PreProcessing time: %llu us\n"
+ "ER RelBuf"
+ "ER bypassed immediately"
+ "ER fr %d ctx %zu IPC started aneReqSend %d"
+ "ER init. done."
+ "ER not enabled!"
+ "ER size of raw net out struct: %zu"
+ "ER: invalid input buffers (IR mismatch)"
+ "ERDCN: %s RawFmt %d PixFmt %d packType %d, Bufs %zu %zu"
+ "ERDCN: No matching extrinsics type\n"
+ "ERDCN: fCam extrinsics set to %f %f %f\n"
+ "ERDCN: model enabled %.3fms\n"
+ "ERDCN: pearlCam extrinsics set to %f %f %f\n"
+ "ERROR\n"
+ "ERROR CSFus: Control is SW, unsupported recCh=%d"
+ "ERROR CSSense[%u]: No detector for E_CHGDET_AE_TILES"
+ "ERROR CSSense[%u]: No more det for E_CHGDET_AE_TILES"
+ "ERROR TimeW+AE[%u]: Invalid desiredFPS=%.3f (mode=%d, rec=%d, smooth=%.4f)\n"
+ "ERROR TimeWDrv: Could not get tw2mi[depth=%d] err=%d"
+ "ERROR TimeWDrv: Error deciding which depth, return 0"
+ "ERROR TimeWDrv: INVALID REQUEST ch=%d rec=%d =================="
+ "ERROR twDet%s: Could not allocate"
+ "ERROR twDet%s: Could not insert blob size=%d, try override smallest>%d?"
+ "ERROR twDet%s: Still too small / new smallest=%d"
+ "ERROR twDet%s: lumaMap not found for depth=%d"
+ "ES2 required for DPC parsing."
+ "ES2.1"
+ "ESLF_DEPTH"
+ "ESLF_RGB"
+ "ESNum != IMX575_SENSOR_ES_UNDEF"
+ "ESNum < IMX575_SENSOR_ES_MAX"
+ "EVENT_EXIT_FLOW"
+ "EVENT_ISP_ERR"
+ "EVENT_ISP_JOBDONE"
+ "EVENT_SETUP_FLOW"
+ "EVENT_STARTED"
+ "EVENT_START_FLOW"
+ "EVENT_STOPPED"
+ "EVENT_STOPPED_FLOW"
+ "EVENT_STOPPING_FLOW"
+ "EVT_AFCTRL_END"
+ "EVT_AFCTRL_START"
+ "EVT_META_AF_END"
+ "EVT_META_START"
+ "EV_AE_BRACKETING_START"
+ "EV_AE_BRACKETING_STOP"
+ "EV_AE_FLASHOFF"
+ "EV_AE_MAINFLASH"
+ "EV_AE_PREFLASH1"
+ "EV_AE_PREFLASH2"
+ "EV_AE_REPEAT_SEQUENCE_START"
+ "EV_AE_REPEAT_SEQUENCE_STOP"
+ "EV_AE_START"
+ "EV_AE_STOP"
+ "EV_AE_SUSPEND1"
+ "EV_AE_SUSPEND2"
+ "EV_AWB_BRACKETING_START"
+ "EV_AWB_BRACKETING_STOP"
+ "EV_AWB_FLASHOFF"
+ "EV_AWB_MAINFLASH"
+ "EV_AWB_PREFLASH1"
+ "EV_AWB_PREFLASH2"
+ "EV_AWB_START"
+ "EV_AWB_STOP"
+ "EV_AWB_SUSPEND1"
+ "EV_AWB_SUSPEND2"
+ "EV_FORCE_TO_STABLE"
+ "EV_FORCE_TO_STABLE_DONE"
+ "EXIT"
+ "EXP_GAIN_LUT_MAX_COUNT >= count"
+ "EXT: CDSControllerH17.cpp, "
+ "EXT: CDSControllerH8.cpp, "
+ "EXT: CDcnProcH11.cpp, "
+ "EXT: CERDcnProcH11.cpp, "
+ "EXT: CFDDcnProcH11.cpp, "
+ "EXT: CFSM.cpp, "
+ "EXT: CImageCapture.cpp, "
+ "EXT: CImageCaptureFlash.cpp, "
+ "EXT: CImageFlowH17.cpp, "
+ "EXT: CIspEngineCVDExeLoopH17.cpp, "
+ "EXT: CIspEngineCVDServerH17.cpp, "
+ "EXT: CIspEngineClientH17.cpp, "
+ "EXT: CIspEngineServerH17.cpp, "
+ "EXT: CPCEFlowManager.cpp, "
+ "EXT: CRTOSStat.cpp, "
+ "EXT: CScopedLock.cpp, "
+ "EXT: CStrobeRegulus.cpp, "
+ "EXT: CStrobeRigel.cpp, "
+ "EXT: CTaskProfiler.cpp, "
+ "EXT: H17TunableManager.cpp, "
+ "EXTSLAF received buffer from pin %zu chidx %zu"
+ "EXTSYNC Failed ch:%zu fc %d expFrmtime %f cfgFrmtime %f calFrmtime %f \n"
+ "EXTSYNC is Enable : %d, ignoring CISP_CMD_CH_AE_FRAME_RATE_MAX_SET"
+ "EXTSYNC is Enable : %d, ignoring ISP_CMD_CH_AE_FRAME_RATE_MIN_SET"
+ "EXTSYNC not supported for Depth Camera Ignoring the cmd"
+ "EXTSYNC sensor:%x failure %f %f %d"
+ "EXTSYNC sensor:%x pass %f %f %d"
+ "EXTSYNC setting Accurateframerate property to %d on channel %u"
+ "EXTSYNC status %d for IMX%x setting syncType to %d, and syncMode: %d"
+ "EXTSYNC status %d, ignoring CISP_CMD_CH_PRIMARY_FRAME_SKIPPING_RATIO \n"
+ "Effect = %d \n"
+ "En: %d vc_id %d dest %d"
+ "En: %d wrapAround: %d ln: %zu"
+ "Enable "
+ "Enable %d inputSelect %d"
+ "Enable STF Coefficient ch %zu"
+ "Enable STF DMA ch %zu"
+ "Enable ch %zu frame %u color 2d hist. x %u, y %u, width %u, height %u \n"
+ "Enable mth src dma ch %zu"
+ "Enable the BES Input: addrC %p strideInC %d width %d height %d\n"
+ "Enable the BES Input: addrY %p strideInY %d width %d height %d\n"
+ "Enable the BES Output:in (%d %d) (%d %d) out (%d %d) (%d %d)\n"
+ "Enable tripod detection: %d\n"
+ "EnableAdaptiveDR"
+ "EnableDMAFrame"
+ "EnableDPE"
+ "EnableInterrupt"
+ "EnableMultiCamSession"
+ "EnableScalerInterleave"
+ "EnableScalerInterleave(): Scaler interleave is not supported in H17's BES.\n"
+ "EnableScalerOutput"
+ "EnableScalerOutput(): Scaler outputEn is not supported in H17's BES.\n"
+ "EnableTileGDC"
+ "EnableTripodDetection"
+ "EnableVHDR"
+ "Enabled VC Pipeline:%hhu vcIds %d-> vcPipelines %d SIF %d"
+ "Enabling Interrupts as Stats is exclusive for ch:%zu"
+ "Enabling client task logging for Pool(%s[%p])\n"
+ "Encoding not supported: %d"
+ "Encrytion setting: %llu keyIndex %d\n"
+ "End: partitionWithThrhd  II bg = %d, fg =%d.."
+ "End: partitionWithThrhd I bg = %d, fg =%d.."
+ "EndPoint %d sends the Ping Message\n"
+ "EndPointUnset remap not by peer %d\n"
+ "EndpointCmdRemap"
+ "EndpointCmdSendBufMsg"
+ "EndpointCmdUnmap"
+ "Endstop Cal Method"
+ "EnqueueSensorOutputInfo"
+ "EnqueueUpdateRequest"
+ "EnterProtectionMode"
+ "Entered TASK = %lu %d\n"
+ "Entering TASK = %lu\n"
+ "Eph && HNonce && FWNonce && Hauth"
+ "ErIpcDownCb"
+ "Error Code (0x9B) 0x%02x%02x\n"
+ "Error: OD post-processing initialization failed!\n"
+ "Error: OD pre-processing initialization failed!\n"
+ "Error: Unsupported OD net pixel format!"
+ "Error: Ux feedback processing initialization failed"
+ "Estimate strobe CCT %uK"
+ "EstimateCurrentBrightness"
+ "EstimateFlashLux"
+ "EvMinusMax != 0"
+ "EvMinusMin != 0"
+ "EvenLoggerGP"
+ "Event logger dump complete @%llu us\n"
+ "Event logger dumped for frame drop.\n"
+ "Event logger paused for dump.\n"
+ "Event logger: %s, parent: %s\n"
+ "Event loggers reseted.\n"
+ "EventAllStatCollected"
+ "EventDelayProcessing"
+ "EventDump"
+ "EventFVInIdle"
+ "EventLogger %d: %s; parent: %s\n"
+ "EventLogger is not started yet!\n"
+ "EventLogger.cpp"
+ "EventLoggerDumpTask"
+ "EventLoggerStart"
+ "EventProcess"
+ "EventProcessDelayedBuffer"
+ "EventStart"
+ "EventStatSoftwareReset"
+ "EventStatSoftwareResetNext"
+ "EvtLog"
+ "Exceeding preset Max: 0x%x"
+ "ExclaveDistortionParamsUpdate"
+ "ExclaveRoutingConfig"
+ "ExecLoopEventLogger%d"
+ "Execute"
+ "Execute the request from the user now here (0x%x 0x%llx userId 0x%lx)\n"
+ "ExecuteContextSwitchForMultiUB"
+ "ExecuteDone"
+ "ExecuteDoneNormal"
+ "ExecuteDone_FirstPass"
+ "ExecuteDone_SecondPass"
+ "ExecuteDone_ThirdPass"
+ "Exp %u Act %u"
+ "Exp %u, Act %u"
+ "Exp %zu, Act %u"
+ "Exposure time requires FW patch"
+ "ExposureGainTableSet"
+ "ExposureGainTableSetForSlave"
+ "ExposureMatching"
+ "ExposureSanityCheck"
+ "ExposureTimeUpdate"
+ "ExposureUpdate"
+ "ExposureUpdateCheck"
+ "Extra: channel %lu frameCount %d inWidth %d inHeight %d bufIdx %d"
+ "FACE_FOUND"
+ "FATAL: Unsupported bracketing mode %d"
+ "FC:%llu ID:%d BufPtr:%p FCInC:%llu"
+ "FCF[%d], totGain=%f, ParamAchromaCbReg.Knee=%d, ParamAchromaCrReg.Knee=%d)"
+ "FCF[%d], totGain=%f, ParamMaxDiffReg(Knee=%d, Slope=%d, Shift=%d)"
+ "FCF[%d], totGain=%f, paramBrightReg(Knee=%d, Slope=%d, Shift=%d)"
+ "FCF[%d], totGain=%f, paramDeltaReg(Knee=%d, Slope=%d, Shift=%d)"
+ "FCF[%d], totGain=%f, paramGradReg(Knee=%d, Slope=%d, Shift=%d)"
+ "FCTRY: Ch%d AF compliance detected & no ESC offset applied: compliance count = %d\n"
+ "FCTRY: Ch%d Step %u: var: %.2f/%.2f (%.3f); s: %d/%d (tgt: %.3f); bz: %d; ntc/afCoil: %.1f/%.1f\n"
+ "FD %d faceWeight %d m_ledOffNumfaces %d m_PreflashNumfaces %d\n"
+ "FD After Process here using ts[0x%x] : %lld delta %lld"
+ "FD Buffer input %zu output %zu scratch %zu"
+ "FD Online customization disabled with version 0"
+ "FD Online customization forced off"
+ "FD Online customization set scale %.1f offset %.1f score %.1f"
+ "FD Replay using ts %lld delta %lld\n"
+ "FD Replay: Load AD Checkpoint"
+ "FD Replay: Load ts %llu UUID %llu AlgoCheckpoint"
+ "FD Set Fov: %.2f %.2f %.2f"
+ "FD Version: Code %s Model %s"
+ "FD Version: Model %s"
+ "FD avLedOff:%.2f fDiff:%.2f weightedAvFlashOffLux:%.2f weightedAveDiff:%.2f facWeight:%.2f\n"
+ "FD bypassed immediatly"
+ "FD fake output"
+ "FD fr %d ctx %zu IPC start"
+ "FD fr %d ctx %zu IPC started aneReqSend %d"
+ "FD frIn M(%u, %u, %p)\n"
+ "FD init. done."
+ "FD meta data: sMeta %zu hMeta %zu"
+ "FD net output %d"
+ "FD post processing failed"
+ "FD post-proc faile to start"
+ "FD: ER disabled\n"
+ "FD: ER enabled, bypass FD\n"
+ "FD: invalid input buffers (IR/Depth mismatch)"
+ "FD: set single frame mode %d"
+ "FDAE ch=%u  non filtered: avg=%d=(1-%d)*%d + %d*%d tgt=%d={scene:%d face:%d} faceExpR=%.2f"
+ "FDAE ch=%u fdCh=%u aeAverage=%d aeTarget=%d faceAverage=%d faceAtTgt=%d faceExpR=%.2f"
+ "FDAE_ATTENTION"
+ "FDAE_AUTO"
+ "FDAE_COLLECTED_ALL"
+ "FDAE_COLLECTED_ALL_SKIP"
+ "FDAE_ENROLLMENT"
+ "FDAE_PROJECTOR_OFF"
+ "FDAE_PROJECTOR_OFF_ATTENTION"
+ "FDAE_PROJECTOR_OFF_ENROLLMENT"
+ "FDAE_PROJECTOR_ON"
+ "FDAE_PROJECTOR_ON_ATTENTION"
+ "FDAE_PROJECTOR_ON_ENROLLMENT"
+ "FDAWB_VERSION %d invalid or not implemented!"
+ "FDBoxHeightGet()"
+ "FDConfig Eye %d Blink %d Smile %d nFace %d"
+ "FDDCN: %s RawFmt %d PixFmt %d packType %d, Bufs %zu %zu"
+ "FDDCN: model enabled %.3fms\n"
+ "FDDisable"
+ "FDDone"
+ "FDEnable"
+ "FDInfo"
+ "FDInputSizeConfig"
+ "FDR is available for ch %zu but distortion isn't populated %d"
+ "FDTO_INFO: Valid entries:Ch[%d]: Bracketing Queue: %d Normal Queue: %d"
+ "FDTO_WRN: Curr AESkip Ratio of MCh[%d]: %d and ch[%zu]: %d"
+ "FDTO_WRN: Mismatch SifrSkipRatio during slave start ch[%d]:%d  ch[%zu]: %d"
+ "FDTO_WRN: Mismatch in SifrSkipRatio ch[%zu]: %d and ch[%zu]: %d"
+ "FE freq=%d MHz, BE/MapFE freq=%d:%d MHz, HR freq=%d MHz, required freq=%d MHz"
+ "FEP %d clockDomain %d (3=16ppc, 2=8ppc)"
+ "FEPBufAlloc"
+ "FEPEnable"
+ "FEPThumbnailConfig"
+ "FES: [%d %d %d %d] -> %dx%d\n"
+ "FESTATS"
+ "FEStatProcess"
+ "FEStatSetup"
+ "FEStatThumbnailMaskConfigure"
+ "FEStatsDone"
+ "FEThumbDMA [%d %d] %llx ValidRect[0 0 %d %d]"
+ "FEThumbStatsProcess"
+ "FFC: BG MATRIX"
+ "FFC: totalpoints= %d, bgNumPts = %d, fgNumPts = %d, frameNum %d"
+ "FFOV: apsPFL=%f mm, thickPFL=%f mm, upperBoundPFL=%f mm\n"
+ "FFOV: apsPosition=%f mm, apsModelLinearM=%f, apsModelLinearB=%f\n"
+ "FFOV: thickLensEFL=%f mm, apsModelLinearM=%f\n"
+ "FFWMSG_PAYLOAD_GET(pMsg) <= sizeof(struct ffwMsgBuffRef)"
+ "FFWMSG_PAYLOAD_GET(pMsg) <= sizeof(struct ffwMsgCmd)"
+ "FFWMSG_PAYLOAD_GET(pMsg) <= sizeof(struct ffwMsgData)"
+ "FFWMSG_TYPE_GET(&currMsg) == FFWMSG_TYPE_CMD"
+ "FFWMSG_TYPE_GET(pMsg) == FFWMSG_TYPE_DATA"
+ "FFWMUTEX(0) != mutex"
+ "FFWMUTEX(0) != syncCmdMutex_"
+ "FFW_INTERPROC_BUFF_ACK_FLAG_CHECK(extra) != 0"
+ "FFW_INTERPROC_BUFF_EXCHANGE_FLAG_CHECK(param2)"
+ "FFW_OK == ffwrc"
+ "FFW_OK == rc"
+ "FFW_SUCCESS == err"
+ "FG Transformation"
+ "FG:  inliers %d  from RANSAC"
+ "FG: not enough inliers %d  from RANSAC"
+ "FG: not enough points after DesMatch: %d"
+ "FG: not enough points after NccMatching: %d"
+ "FHSBypass"
+ "FHSConfig"
+ "FHSConfig, DemCoeff(%d, %d) = %d"
+ "FHSSetup"
+ "FHSSetup, (rg, gr, bg, gb) = (%f, %f, %f, %f)"
+ "FHSSetup, GRBG Gains = (%d, %d, %d, %d)"
+ "FHSSetup,ch %d, config %d, Qbin %d, use rb binning %d"
+ "FID"
+ "FLDtracesema != (SEMA)0"
+ "FLOW: "
+ "FMAP_FATE0"
+ "FMAP_FATE_sum"
+ "FOCUS_EVENT_IDLE"
+ "FOCUS_EVENT_MOVE"
+ "FOCUS_EVENT_POS_REQ"
+ "FOCUS_EVENT_SIGNAL"
+ "FOCUS_EVENT_START"
+ "FOCUS_EVENT_STOP"
+ "FOCUS_STATE_DEINITIALIZE"
+ "FOCUS_STATE_IDLE"
+ "FOCUS_STATE_INITIALIZE"
+ "FOCUS_STATE_MOVING"
+ "FOCUS_STATE_PREP_MOVE"
+ "FOCUS_STATE_STOPPED"
+ "FORCE babystep=%.3f = 0.125*%.1f s/%.1f s"
+ "FPCIsGradientSchemeValid(*this)"
+ "FPDNotifySafety"
+ "FPDRun"
+ "FPNR Pixel Buffer is not 64 bytes aligned"
+ "FPNR: ch:%zu, fpnrDataStride:%d, fpnrDataAddr=%p"
+ "FPNRBypass"
+ "FPNRDmaPixFmt"
+ "FPNRFrameEn"
+ "FPNROffsetLUTEn"
+ "FPNRRBCEn"
+ "FPNRRBCSelect"
+ "FPNRSetup"
+ "FPNRTileEn"
+ "FRAME %d MOTION ESTIMATOR DONE!"
+ "FSCLSetup"
+ "FSM %d Software Reset Stats Bk:%d"
+ "FSM TOT = %d\n"
+ "FSMCalcParamsMainFlash"
+ "FSMChOutput"
+ "FSMChProcDone"
+ "FSMChProcess"
+ "FSMChStartOfPass"
+ "FSMChStartOfStep"
+ "FSMChStop"
+ "FSMCheckAEDone"
+ "FSMCheckAWBDone"
+ "FSMCheckQueue"
+ "FSMFlashAmbientFrameSettingApplied"
+ "FSMFlashChargeDone"
+ "FSMFlashDriveLow"
+ "FSMFlashInTransition"
+ "FSMFlashMainFlash1Done2AWB"
+ "FSMFlashMainFlash1FrameDone"
+ "FSMFlashMainFlash2Done"
+ "FSMFlashMainFlash2FrameDone"
+ "FSMFlashMainFlashSettingApplied"
+ "FSMFlashOffFrameDone"
+ "FSMFlashPreflash1AWBUpdate"
+ "FSMFlashPreflash1Start"
+ "FSMFlashPreflash2AWBUpdate"
+ "FSMFlashPreflash2Start"
+ "FSMFlashPreflashAEUpdate"
+ "FSMFlashPreflashAFUpdate"
+ "FSMFlashPreflashCommon"
+ "FSMInitForPreflash1"
+ "FSMInitForPreflash2"
+ "FSMMultiSyncCaptureFrame"
+ "FSMMultiSyncExit"
+ "FSMOutputMultiCap"
+ "FSMPMainflashDelayDone"
+ "FSMPreflashDone"
+ "FSMProcess"
+ "FSMProcessPreflash"
+ "FSMProcessReplayCmd"
+ "FSMReturnToNormal"
+ "FSMStart"
+ "FVDone"
+ "FVSYNC"
+ "FW controlled"
+ "FW didn't receive reg base addresses from CISP_CMD_SET_DSID_CLR_MULTI_BC_REG_BASE, it could be Single AMCC Platform\n"
+ "Face    %s %d: (%.4f %.4f %.4f %.4f) score: %.4f"
+ "Face %c(%.1f %.1f %.1f %.1f) Score: %.3f"
+ "Face %d, (%.2f, %.2f, %.2f, %.2f), score %.2f"
+ "Face %s%s %d: (%.3f %.3f %.3f %.3f) score: %.3f"
+ "Face %u: %f %f %f %f \n"
+ "Face detected(%.2f)=> slow sync=%d"
+ "Face numResults %d %d"
+ "FaceId usecase"
+ "FaceMaskDetection"
+ "FaceRef %s %d: (%.4f %.4f %.4f %.4f) score: %.4f"
+ "FaceSkinDetection"
+ "FaceSkinDetection skinRGBRatio = %6.2f %6.2f %6.2f %hu"
+ "Face[%d] %d %d %d %d %d"
+ "Faces not sorted!"
+ "FactoryHandleInput"
+ "FactoryHandleInputScale"
+ "Fail"
+ "Fail to chooseCurConfigTable - ch=%d, configTable=%d (>=tableNbr(%d)), standardFrameRate=%.2f"
+ "Failed to acquire m_calibMutex"
+ "Failed to acquire semaphore for %#x"
+ "Failed to add trace. status 0x%x traceId 0x%x\n"
+ "Failed to allocate memory"
+ "Failed to dequeue for fc:%d ch:%zu\n"
+ "Failed to get the Accel\n"
+ "Failed to map command buffer"
+ "Failed to register to the ISR manager"
+ "Failed to send msg to Sink"
+ "Failed to write host eph public key\n"
+ "FailureSimSet"
+ "Fairfield nonce %02x %02x %02x %02x...\n"
+ "Fake pDesGenFL2FeaturesOutHeader: %p"
+ "Fake timer, ignore doppler signal: %d\n"
+ "FakeSensorDiscover"
+ "Feed Gyro Data From the Motion Capture to VIS Core : %d \n"
+ "Fes_Output AWB Tile Stats Region: ch=%d fn=%d (x, y)=(%i, %i), (w,h)=(%i, %i)"
+ "Fetched from STRB key R/G=%f B/G=%f"
+ "File write busy..."
+ "FileInfo %s %s %zu"
+ "FileTask"
+ "Fileread to %s %s"
+ "Filewrite to %s %s"
+ "FillHwCfg"
+ "FillSplitPDMetadata"
+ "FillWeightMapForSTFDMA"
+ "FilterADRCNextSifrTargetEIT"
+ "FilterCvdDp: Action %d is local"
+ "FilterCvdDp: Action %d uses Global Op %d addr %p"
+ "FilterCvdDp: CVIOFilterCVDCombH17SourceDoneIRQMask=0x%x sourceGoReq=0x%x"
+ "FilterCvdDp: Create Global CVDComb Op  %d"
+ "FilterCvdDp: Create Local CVDComb Op  %d"
+ "FilterCvdDp: OP Finish"
+ "FilterCvdDp: Prepare DMA"
+ "FilterCvdDp: StarOp with metadata buffer: %p"
+ "FilterCvdDp: Update Global CVDComb Op  %d"
+ "FilterCvdDp: Update Local CVDComb Op  %d"
+ "FilterCvdDp: WaitOP"
+ "FilterCvdDp: dumpSize %d < image size %lu stride %lu"
+ "FilterCvdDp: dumpSize %d >= image size %lu stride %lu"
+ "FilterCvdDp: first frame, has no previous descriptor buffer yet, need special handling"
+ "FilterCvdDp: init %.3fms exec %.3fms (op %.3fms + sg %.3fms)  release %.3fms"
+ "FilterCvdDp: local descriptor buffer address %p descriptor buffer address %p"
+ "FilterCvdDp: memcpy previous descriptor buffer address %p"
+ "FilterCvdDp: primIOBufferValidMark=0x%x"
+ "FilterCvdDp: remember previous descriptor buffer address %p"
+ "FilterCvdDp: setup WMA%d for local descriptor buffer address %p"
+ "FilterCvdDp[%lu]: numOps %d numActs %d"
+ "Final Intermediate buf %zu"
+ "Find one buffer from other channel (%hu) and this channel is %zu"
+ "FindMatchingFlow"
+ "Finish DesGen operation"
+ "Finished One Buffer Processing in CVDExeLoop @ %llu\n"
+ "Finished One Buffer Processing in CVDServer @ %llu\n"
+ "Finished One Buffer Processing in Server %llu\n"
+ "Finisih sending the request to CIspHwResourceServiceH17 @ %llu\n"
+ "Finisih sending the request to CVDExe @ %llu\n"
+ "Finisih sending the request to EXEC %llu\n"
+ "Finisih write the registers in the hardware %llu\n"
+ "Finisih write the registers in the hardware @ %llu"
+ "First Gain Adj: main %llu %d, sifr %d %llu %d"
+ "FirstGridCol=%u, LastGridCol=%u, PixOffsetX=%u, GridOffsetX=%u\n"
+ "FirstGridRow=%u, LastGridRow=%u, PixOffsetY=%u, GridOffsetY=%u\n"
+ "FixES1ModeCfgBlanking"
+ "Flash param Skip %d delay %d multicam %d aux frame %d manual %d\n"
+ "Flash updated Center %d Corner %d Side %d mA\n"
+ "Flash updated: Center %d Corner %d Side %d mA\n"
+ "FlashOutPulseConfig"
+ "Flashlight (per driver): %f mA. Cool0: %f mA, Warm0: %f mA"
+ "Flicker frequency:%f, confidence:%d, status:%u, ch %zu"
+ "Flicker rounded LUT[%u] = {%.3f x %.3f}"
+ "Float buffer only!"
+ "Flow WRAP %s,%s AUTH %s,%s HPR %s,%s HOST_SIG %s,%s SENSOR_SIG %s,%s UNWRAP %s,%s\n"
+ "Flow2: NumPairs = %d, numInlier = %d"
+ "Flow3: NumPairs = %d, numInlier = %d"
+ "FlowDone"
+ "FlowFSM"
+ "FlowSink"
+ "FlowSinkFrm"
+ "Focus Enable/Disable Command not supported for this driver\n"
+ "FocusEnable"
+ "FocusEnable Command not supported\n"
+ "FocusMethodToStr"
+ "For ch=%ld, preview queue size=%ld, still queue size=%ld"
+ "Found %d pairs with ch:%d"
+ "Found matching table %d > 1 for %s\n"
+ "Frame No %d: %d body Detected"
+ "Frame [%d] Flow 2: YTP_GNA_DEBUG = %d %f %d %d %d\n"
+ "Frame [%d] Flow 2: YTP_GNA_DEBUG = nPairs:%d nIterations:%d tsGNA:%f\n"
+ "Frame [%d] Flow 3: YTP_GNA_DEBUG = %d %f %d %d %d\n"
+ "Frame [%d] Flow 3: YTP_GNA_DEBUG = nPairs:%d nIterations:%d tsGNA:%f\n"
+ "FrameDone for FC:%d done:%d %f"
+ "FrameInfoSet"
+ "FrameOffWidth[0] = %u, FrameOffWidth[1] = %u"
+ "FrameSize: FrameSize=%d"
+ "FrameSkipIntervalSet"
+ "FramesProcess"
+ "Free"
+ "Free ch %zu raw %zu buffers..."
+ "Free ch %zu sideband0 %zu buffers..."
+ "Free ch %zu sideband1 %zu buffers..."
+ "Free ch %zu still raw %zu buffers..."
+ "Free pool fep %zu buffers..."
+ "Free pool raw %zu buffers..."
+ "Free the Request CIspHwResourceServiceH17 @ %llu\n"
+ "Free the Request EXEC %llu\n"
+ "Free the Request for CVDExe @ %llu\n"
+ "FreeDPCBuffers"
+ "FreeNVMParser"
+ "FreePplResource"
+ "FreeSequenceEntry"
+ "FreeStaticDPCBuffers"
+ "Frm=%d t=%u dT=%f Errmv=%.4f,%.4f CTRL=%.4f,%.4f,%.4f state=%d settled=%d\n"
+ "FrmDropped"
+ "FrmEventLogger"
+ "FrmSkip=%d t=%u dT=%f state=%d settled=%d\n"
+ "Front Camera, overwriting lens coefficients! \n"
+ "FrontStereoGenerateColorEFLTempCompensationParams"
+ "FrontStereoGenerateRgbCalib"
+ "FrontStereoGenerateRgbCalibColorExtrinsics"
+ "FrontStereoGenerateRgbCalibDistortionParams"
+ "FrontStereoGenerateRgbCalibLogEffort"
+ "FrontStereoUpdateRgbCalibEFL"
+ "FrontStereoUpdateRgbCalibGDC"
+ "FrontStereoUpdateRgbCalibOpticalCenter"
+ "Full image Mesh Grid size: [%d, %d]\n"
+ "FuseDxBuffers"
+ "FuseProcess"
+ "FuseSetup"
+ "FwDetectorAdPreProc::generateCropResizeParam failed!\n"
+ "FwDetectorFdDecoder already started!"
+ "FwDetectorFdDecoder is not stopped!"
+ "GAMMABufIn"
+ "GD: Net INIT DONE!"
+ "GD: isGDEnabled=%d"
+ "GDC table entry %d, r = %.9f -> %.9f\n"
+ "GDC table validation falied"
+ "GDCTable"
+ "GENERAL_PROCESS_PIPE_DEPTH-2 = %d\n"
+ "GGD dumping framename %s, keypointCount %d, matched %d"
+ "GIC"
+ "GMC_CAPTURE_DONE"
+ "GMC_DONE"
+ "GMC_ENROLLMENT"
+ "GMS buffer pool provides buffers that are not big enough to store GMS output"
+ "GOC output bitperfect"
+ "GOCSetup"
+ "GP CMD posted at %.6f, %u"
+ "GP End %llu\n"
+ "GP timeout intr: %.2f mS, sema: %.2f mS"
+ "GPBesDone"
+ "GPBesIssueJob"
+ "GPBesStart"
+ "GPBesTimeout"
+ "GPBesTimeout %d, file radar & upload /var/mobile/Media/DCIM/data"
+ "GPDone"
+ "GPEnter"
+ "GPExit"
+ "GPFail"
+ "GPGP Command end @ %f ms\n"
+ "GPPostFail"
+ "GRP Pool Config, grpid %d [%x] Type %d, En %d"
+ "GYRO_OIS Starts "
+ "GYRO_OIS need update "
+ "GYRO_OIS valid "
+ "GenRegFlowGlobalLut"
+ "GenRegFlowVisPipeParam"
+ "GeneralGpioInit"
+ "GeneralProcessing"
+ "GenerateAFEProcModeForConfigIndex"
+ "GenerateMetaData"
+ "GenerateStatsModeForConfigIndex"
+ "Get"
+ "GetAETablesTuningPresetPerEntryType"
+ "GetAFEProcDst"
+ "GetAFEProcIndex"
+ "GetAFEProcMode"
+ "GetAFSensitivityUmPerFwDac"
+ "GetAbsColorCalBias"
+ "GetAdaptDREVMargin"
+ "GetAdaptDROriginalExposure"
+ "GetAdjustedPreISPCropInput"
+ "GetAfeProcDownScaleFactor"
+ "GetArmErrorInfo"
+ "GetBESCoeffs"
+ "GetBESCoeffs4Taps"
+ "GetBrightnessDiff"
+ "GetBufferFromPool"
+ "GetCAROffsetGridTable"
+ "GetCITLossForSifrFullBin"
+ "GetCPreMax"
+ "GetCStrMax"
+ "GetContextSwitchConfigBitMap"
+ "GetDataStartAddrDPCd"
+ "GetDefectCountDPCd"
+ "GetDepthData"
+ "GetDomainOutputSize"
+ "GetExpoSettingFromEmbeddedData"
+ "GetExposureTable"
+ "GetFDAWBMetaData"
+ "GetFEP2ndForPlatform"
+ "GetFEP2ndIndex"
+ "GetFEPDst"
+ "GetFEPIndex"
+ "GetFSCLCoeffs"
+ "GetFSCLCoeffs7Taps"
+ "GetFepThumbDownScaleFactor"
+ "GetFrRecovery"
+ "GetFrameDescBuffers"
+ "GetFreeSlot"
+ "GetFullResHostMetadataBuffer"
+ "GetGDCTable"
+ "GetHITHStatSize"
+ "GetHWPower"
+ "GetHostMetaData"
+ "GetHostMetadata"
+ "GetIndexByTs"
+ "GetIndexForExistingAEExpandedTableParamsPerProperty"
+ "GetIndexForNewAEExpandedTableParams"
+ "GetInternalAWBMetaData"
+ "GetLCData"
+ "GetLSConfigOffsetForContextSwitch"
+ "GetLSParamsFromProfile"
+ "GetLSParamsFromProfileColorShading"
+ "GetLastResistance"
+ "GetLatestIndex: %d nextMotionIndex %llu latestIndex %llu\n"
+ "GetLenXYIndexByTs"
+ "GetLensCalibrationInfo"
+ "GetM3GDCParamters"
+ "GetMLVNRDMASrcIndex"
+ "GetMetaDataBracketing"
+ "GetMetaDataRGBIRBracketing"
+ "GetMetadata"
+ "GetMotionDataRate"
+ "GetMotionDataRate() WriteMessage() return sts  = %d"
+ "GetMotionDataRate() calling WriteMessage()"
+ "GetMotionDataRate() response, Get motionDataValue = %d\n"
+ "GetMotionDataRate() used %f ms\n"
+ "GetMsBePYRCoeffs"
+ "GetNewAETablesTuningPreset"
+ "GetNextFrameCount(currFrameCount) == swFrmId"
+ "GetOPBAvgDataFromSB"
+ "GetOTPMap"
+ "GetOneFrameAWBMetaData"
+ "GetOutputFrameInfo"
+ "GetOutputInfoRequest"
+ "GetPWConfigForMonoWarping"
+ "GetPhotometerAWBMetaData"
+ "GetPowerOnTimeCode"
+ "GetPowerState"
+ "GetPowerStatus"
+ "GetProjectorErrors"
+ "GetProjectorSN"
+ "GetProjectorSpec"
+ "GetProjectorStatus"
+ "GetROIInfoNode"
+ "GetRTBWR"
+ "GetRTBWRbyDMA"
+ "GetRTDmaIDAfe"
+ "GetRange"
+ "GetRawDMASrcIndex"
+ "GetRecordRegisters"
+ "GetRegisteredSegment"
+ "GetRequiredFEPDMABWR"
+ "GetResourceCapability"
+ "GetResourcePPC"
+ "GetResult"
+ "GetRoutingTableSlot"
+ "GetSIFDMADst"
+ "GetSafetyState"
+ "GetScript"
+ "GetSensorInfo"
+ "GetSensorState"
+ "GetSeqNum(pPplInfoPrevStep->ispJobId) == seqNum"
+ "GetSifBinHeightWidth"
+ "GetSifDMARawBuffers"
+ "GetSlafSubsamplingFactor"
+ "GetSlaveFrame"
+ "GetSlowSyncParameters"
+ "GetSourceGoReq"
+ "GetSplitPDSize"
+ "GetSplitPdScaleMetaData"
+ "GetStatDefaultIndex"
+ "GetStaticTunableTable"
+ "GetStatsDMASrcIndex"
+ "GetStatsIndex"
+ "GetStatsMode"
+ "GetStatsTrigIrqTs"
+ "GetStdTableByID"
+ "GetSyncBuffer"
+ "GetSyncedChannels"
+ "GetTMPreviewMaster(ch) != MASTER_CH_UNKNOWN"
+ "GetTemporalStableMetaData"
+ "GetTemporarySharedBuffer"
+ "GetTotalNumOfCameras"
+ "GetTrigIrqTs"
+ "GetTunableTable"
+ "GetVsync2MidRoTime"
+ "GetWhitePointProjector"
+ "Getting Extrinsic Matrix for ch%zu src:%d dst:%d"
+ "Getting key/sig w/o sensor booted\n"
+ "Global CVDComb size %lu %d %lu\n"
+ "Global CvdDp size %lu %d %lu\n"
+ "Global DESGEN size %lu %d %lu\n"
+ "Global DesMatch size %lu %d %lu\n"
+ "Global pOpItem size %lu %lu offset %d offset_next %d\n"
+ "Global pOpItem size %lu %lu offset %d total %d\n"
+ "Got The Gyro From the Motion Capture Filter\n"
+ "Got a CVD request from the user sourceGoReq 0x%08x userId 0x%lx\n"
+ "Got a packet with Type 0x%x Len %d"
+ "Got a request from the user now here (0x%x 0x%llx userId 0x%lx)\n"
+ "Got a request from the user now here (0x%x 0x%x)\n"
+ "Got an update from the Exec Loop now here (0x%x) , %llu \n"
+ "Got ch %zu mth setting"
+ "Got ch %zu stf registers setting"
+ "Got ch %zu stf weightmap setting"
+ "Got cvdBufOut: %p"
+ "Got pCvdDpOutHeader: %p"
+ "Got pDesGenFL2FeaturesOutHeader: %p"
+ "GotReq"
+ "GotUsrReq"
+ "GpioForceSet"
+ "GpioIsrRegister"
+ "GpioRead"
+ "GpioRstDone"
+ "GpioRstStrt"
+ "GpioSetHiZ"
+ "GpioValid(gpio)"
+ "GrieSeqRead(%d) %02x %02x #bytes %d\n"
+ "GrieWriteByte(%d) %02x %02x\n"
+ "Grimaldi lux %f, estimated AE lux %f"
+ "Grp %d LED %d level %d currReg 0x%x\n"
+ "Guad BIST FSM: 0x%x"
+ "Guad BrickEEP: 0x%x"
+ "Guad FSM bricked"
+ "Guad Main FSM: 0x%x"
+ "Guad Power on\n"
+ "Guad Reset: %d"
+ "Guad Status 0x%x(%d), armed 0x%x Dev stat 0x%x(%d)\n"
+ "Guad enable %d\n"
+ "Guad hard bricked? 0x%x"
+ "Guad powerOn state %s, %d\n"
+ "GuadStateQuery"
+ "Guadalupe Resistance: %d\n"
+ "Guadalupe Temperature: %.2f C\n"
+ "Guadalupe(%x) Record Registers 0x%08X 0x%08X\n"
+ "Guadalupe(%x) last resistance %d"
+ "Guadalupe(%x) resistance %d"
+ "Guadalupe(%x) temp: %.2f C"
+ "Gyro Transformation"
+ "Gyro reading motion"
+ "GyroMotionAnalysis"
+ "H11 Load Programe, [%d] progId %d procId %d"
+ "H11 Prog Desc, numProcedure %d"
+ "H17 Load Programe, progId %d procId %d"
+ "H17 Prog Desc, numProcedure %d"
+ "H17Dma"
+ "H17ISPInterruptMapping[(size_t)aispSource]->platformIntSrc != PLATFORM_INT_INVALID"
+ "H17ISPInterruptMapping[aispSource]"
+ "H17ISPInterruptMapping[aispSource]->platformIntSrc == PLATFORM_INT_INVALID"
+ "H17Source"
+ "HARD BRICKED"
+ "HARSet"
+ "HAT ROI: %d, %d, %d, %d\n"
+ "HBin %d, sub (%d %d), src (%d %d), out (%d %d) crop (%d %d)"
+ "HDRCSetup"
+ "HDRDone"
+ "HDRRcvd"
+ "HITHStatProcess"
+ "HMACp"
+ "HPPOffloadingPrepare"
+ "HPR %s,%s HOST_SIG %s,%s SENSOR_SIG %s,%s UNWRAP %s,%s\n"
+ "HPR size %d\n"
+ "HPRp"
+ "HRBuf"
+ "HRDConfig"
+ "HRSetup"
+ "HWCopyRegFromDram"
+ "HWCopyRegFromDram(): hwRegAddr=%p, nbrReg=%d\n"
+ "HWCopyRegFromDramPIODMAList"
+ "HWCopyRegFromDramPIODMAList(): hwRegAddr=%p, nbrReg=%d\n"
+ "HWTriger"
+ "HW_OFF, power off\n"
+ "HW_RESET"
+ "Had switched from MLVNR mode, skip RAW2YUV PASS for previous frame=%d"
+ "Hair mask copy is done but failed to retrieve FD buffer out of the queue"
+ "Hair mask copy is done but failed to retrieve dst buffer out of the queue"
+ "Hair mask copy is done but failed to retrieve src buffer out of the queue"
+ "HallData nextLenXYServiceIndex %llu\n"
+ "HandleDesGenRequest"
+ "HandleFrameSkip"
+ "HandleInput"
+ "HandleIrLowPowerModeTiming"
+ "HandleMasterPendingStop"
+ "HandleMatchRequest"
+ "HandleOneSourceDone"
+ "HandleOneSourceTrigger"
+ "HandlePCEDone"
+ "HandlePendingTasks"
+ "HandleProjectorPause"
+ "HandleSecureModeRequest"
+ "Handling buffer posted when Stats was already using both Banks loop:%d"
+ "Hardcoded FCAM calibration values missing for this device type"
+ "Hardware Process Time is, %f, ms RO, %f %llu, SRC %d, BANK %u"
+ "Has motion data, no need to wait\n"
+ "HeapCheck"
+ "High Conf spots exceed limit of %d"
+ "High Res raw buffer not setup"
+ "HighRes AEAWBWindow[%d] Cannot be enabled because window is too small"
+ "HighRes AEAWBWindow[%d], startX %d startY %d endX %d endY %d"
+ "HighRes Capture Frame ch:%zu fc:%d not posting to AFEProc"
+ "HighResAE or HighResAWB %d is disabled"
+ "HighResAE or HighResAWB %d is enabled"
+ "HighResAWBAEWindowConfig"
+ "Hijack the raw with painting 0x%x for %u bytes (extraLine: %u)\n"
+ "Hires StillCaptureOnly bufferPool"
+ "Horiz scale ratio: %f, besInCrop Left/Right: %d, %d \n"
+ "HorzInt %u vertInt %u"
+ "HorzInt:%d [%d %d]"
+ "Host eph public key already set\n"
+ "Host eph public key not set\n"
+ "HostMetaDataConvert"
+ "HostMetadataOffsetTableAdjust"
+ "HueMap buffer is not available, use preview frame's hueMapBuffer !!!!"
+ "HueMapSetup"
+ "HueSatLUTSetup"
+ "I2C Read response cmdPacketLen(%d) payLoadSize(%d) Type(%d) Sequence(%d)"
+ "I2C Read response: copying data"
+ "I2C Read response: ctrlResSts  = 0x%x"
+ "I2C Read response: signal i2cReadResSignal"
+ "I2C Write response: ctrlResSts  = %d"
+ "I2C Write response: signal i2cWriteResSignal"
+ "I2C read WriteMessage() return sts  = %d"
+ "I2C read calling WriteMessage()"
+ "I2C write WriteMessage() return sts  = %d"
+ "I2C write calling WriteMessage()"
+ "I2C write response: sts  = %d"
+ "I2CEnable"
+ "I2CRead response: sts  = %d, payLoadSize = %d, requested size = %d"
+ "I2CRead sizeof(msg) = %lu\n"
+ "IC DBG: sensorBlkAvg %d %d %d %d %d"
+ "IC DBG: sensorBlkAvgFiltered %d %d %d %d"
+ "IC DBG: sensorBlkAvgInstantaneous %d %d %d %d"
+ "IC Wrapper Channel Started for Ch:%zu syncGrp:%d"
+ "IC channel %zu does not need to wait\n"
+ "IC channel %zu does not need to wait mICState:%d peridotTimeout:%d\n"
+ "IC channel %zu start to wait... @%.4f"
+ "IC wait total %.4fms"
+ "ICCORE:ch %zu:(%d, %u, %u, %u), req 0x%x, exp %llu, %u, 0x%x, (%d, %d, %llu, %u) preview %d\n"
+ "ICDone"
+ "ICFrmRecvd"
+ "ICRcvd"
+ "ICcoreFlash"
+ "ICcoreReplay"
+ "IDLE_DEFAULT"
+ "ID_GET_REGISTERED_INDEX(id) < ISR_CALLBACK_MAX_ENTRIES"
+ "ID_GET_SOURCE(id) < INTERRUPT_SRC_TOTAL"
+ "IMX%x: no table found for TableEntry %u sensorMode %u expType %u!"
+ "IMX575 %s: index: %x  enable:%d \n"
+ "IMX575: security state(0x1303) %02x, op mode(0x1307)=%02x, err code(0x130b)=%02x, syscfg %02x%02x%02x%02x\n"
+ "IMX591 %s: %x\n"
+ "IMX591 registers file source: %s"
+ "IMX591: %d\n"
+ "IMX591: DID %04x"
+ "IMX591_FW_Patch integrity: %s"
+ "IMX591_FW_Patch_ES1 integrity: %s"
+ "IMX591_Globals_LT integrity: %s"
+ "IMX591_Globals_RX integrity: %s"
+ "IMX703 %s: en: %x"
+ "IMX703 Frame Skip %d"
+ "IMX713 %s: en: %x\n"
+ "IMX713 Frame Skip %x"
+ "IMX714: UID %016llx%016llx\n"
+ "IMX714: security state %02x, op mode %02x, err code %02x, syscfg %02x %02x%02x%02x%02x\n"
+ "IMX803 %s: en: %x"
+ "IMX803 Frame Skip %d"
+ "IMX903 %s: en: %x"
+ "IMX903 Frame Skip %d"
+ "IMX913 Frame Skip %d"
+ "IMX913: UID %016llx%016llx\n"
+ "IMX913: security state %02x, op mode %02x, err code %02x, syscfg %02x %02x%02x%02x%02x\n"
+ "IMX972 %s: en: %x"
+ "IMX972 Frame Skip %d"
+ "INPUT"
+ "INPUT_NEXT"
+ "IOConfig"
+ "IOP nothing to read"
+ "IOP read done: rtPtr %d wtPtr %d readCount %d"
+ "IOP read init: rtPtr %d wtPtr %d msgLen %zu"
+ "IOP write done: rtPtr %d wtPtr %d writeCount %d"
+ "IOP write init: rtPtr %d wtPtr %d msgLen %zu (with header)"
+ "IOP write: Message length too big"
+ "IOP write: buffer overflow"
+ "IOP write: buffer wrapup"
+ "IOP write: pBuffer not initialized yet"
+ "IOP write: register 0x%zx 0x%x"
+ "IOUT0/1/2 %d %d %d Pulse %d CHSEL %d\n"
+ "IPC Alloc %zu use %.3fms"
+ "IPC address not mapped before!"
+ "IR HMAC ok timeout, ignore if not provisioning\n"
+ "IRQClearAll"
+ "IRSplit: [%d] = ae# %u, e %llu, p (%d, %llu), m (%d, %llu), v %d, g 0x%x\n"
+ "IRstrobe"
+ "ISP RANSAC"
+ "ISP frequency Control %s"
+ "ISP-biasScoreIn = %f tsBiasIn = %llu ns\n"
+ "ISP-biasScoreOut = %f, tsBiasOut = %llu ns\n"
+ "ISPCPU RANSAC 0x%x"
+ "ISPCPU RANSAC MATRIX"
+ "ISPCPU RANSAC_ESTIMATION_DONE"
+ "ISPCPU avgDiagonal %f with 4 weight"
+ "ISPCPU: [%d] biasIn %f, biasOut %f, numInliers %d, GNA %f"
+ "ISPEng agent ref0-3:%p, %p, %p, %p"
+ "ISPEng agent ref4-6:%p, %p, %p"
+ "ISPNonCh"
+ "ISP_PROPERTY_IC_EXCLAVE_FRAME_SKIP_SET ch %zu %u"
+ "ISP_PROPERTY_IC_REPLAY_ENABLE_GMSLOOP write: %d val: %u\n"
+ "ISP_PROPERTY_LC_APS_CONTROL_ARCH deprecated\n"
+ "ISP_PROPERTY_LC_APS_SET_FFWD_CONTROL deprecated, AFC Enabled by default for FCAM\n"
+ "ISP_PROPERTY_PRCDAEMON_KTRACE_FLUSH_TIME %d"
+ "ISP_PROPERTY_TIMEWARP_DEBUGFLAGS: no tw filter"
+ "ISP_PROPERTY_TIMEWARP_FORCEFPS: no tw filter"
+ "ISP_PROPERTY_TIMEWARP_LUMADESIREDCHGPERFRAME: no tw filter"
+ "ISP_PROPERTY_TIMEWARP_RECORDING_CHANNEL: no tw filter"
+ "ISR"
+ "ISRBesProcDone"
+ "ISRHandle != 0"
+ "ISR_ID_GET_BANK(id) < lines"
+ "ISR_ID_GET_INDEX(id) < ISR_CALLBACK_MAX"
+ "ISR_ID_GET_LINE(id) < ISR_REG_ENTRY"
+ "ISSUE"
+ "IS_EXCLAVE_VC_PIPELINE_VALID(exclaveVCPipelineID)"
+ "IVFM updated to 0x%x\n"
+ "IcCompTexBase == (IcCompTexBase >> 7 << 7)"
+ "Idication LED                0x%04X\n"
+ "Idication LED Float          %01d.%03d\n"
+ "IfSupportCompression()"
+ "IgnoreCalibAnchors"
+ "Image dimension must be > 0"
+ "Image too small!"
+ "ImageCaptureInit"
+ "ImageCaptureLocalRawOutDisable"
+ "ImageCaptureLocalRawOutEnable"
+ "ImageRegistrationDone"
+ "ImgCapRawBufAlloc"
+ "Implement this function in subclass!!!"
+ "InCfg[0]: Tex:W=%d,H=%d, Cmp:OS=0x%x,SD=%d,SZ=%d, Hdr:OS=0x%x,SZ=%d, mode=%d"
+ "InCfg[1]: Tex:W=%d,H=%d, Cmp:OS=0x%x,SD=%d,SZ=%d, Hdr:OS=0x%x,SZ=%d, mode=%d"
+ "InConfMap"
+ "InSel"
+ "InSel %p %p 0x%x"
+ "InTiledChroma: hdrC %p cmpC %p w %d h %d s %d\n"
+ "InTiledLuma: hdrY %p cmpY %p w %d h %d s %d\n"
+ "Inc: startInc=%d, midInc=%d, doneInc=%d"
+ "Incompatible matrix sizes!"
+ "Inconsistent 420/422: ClrBeOut=%d BesIn=%d DMA=%d"
+ "Incorrect OD post processing input pixel format!"
+ "Incorrect input buffer pixel format!"
+ "Incorrect input height!"
+ "Incorrect output buffer pixel format!"
+ "Incorrect output width!"
+ "Incorrect sifBin for Non-SIFR case:   Ch %zu, config %d, Qbin %d, fepBin(%d, %d), sifBin(%d, %d)\n "
+ "Incorrect sifBin for SIFR frame:   Ch %zu, config %d, Qbin %d, fepBin(%d, %d), sifBin(%d, %d)\n "
+ "Index out of range: index=%u, max-index=%u"
+ "InfoCVDCombConfig"
+ "InfoDesGenConfig"
+ "InfoDesMatchConfig"
+ "InfoGet"
+ "InfoModelVersions"
+ "InfoNccConfig"
+ "InfoPatchWarpConfig"
+ "InfoProgramDesc"
+ "Init"
+ "Init radial gain asymscale ch[%zu] asymScaleX %f asymScaleY %f"
+ "InitADRC"
+ "InitCacheByIndex"
+ "InitChannelInfoBase"
+ "InitPlatform"
+ "InitProcWindow"
+ "InitRegFlowVisPipeParam"
+ "InitSensorData"
+ "InitSensorDataInfo"
+ "InitSettingSet %d"
+ "InitSettingsSet"
+ "Init_Int_Masks"
+ "Initial file write failed! (%s)"
+ "InitialReset"
+ "Initialize #%u tile to sat for primSatThreshold=%u=%.2f:log=%.2f vs prev=%.2f diff=%.2f bins\n"
+ "InitializeTraceBuffer"
+ "Initializing sensor data info\n"
+ "Inject input from input dump"
+ "Injected Depth file found"
+ "Injected RGB file found"
+ "Input Found  %d sz %llu"
+ "Input buffer must not have paddings after each row!"
+ "InputProcess"
+ "InputProcess ch:%d fc:%d regOp:%d regBank:%d"
+ "InputProcessCommon"
+ "InputProcessForIR"
+ "InputProcessNext"
+ "InputProcessNxt ch:%d fc:%d regOp:%d regBank:%d"
+ "InputProcessRegFlowResize"
+ "InputSet"
+ "Inputpin is %zu"
+ "InqTaskArg"
+ "InstallFakeSensor"
+ "Intensity %d Angle %d\n"
+ "Internal Tracer Not Available\n"
+ "InterpCCMfromBases"
+ "Interrupts enable ch %zu pipe %d"
+ "InterruptsControl"
+ "InterruptsRegister"
+ "Interval  : FW Send To FW received %fms\n"
+ "InvCCM: %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f"
+ "Invalid AFEProc Id %d"
+ "Invalid DownScale Factor for fepThumb %f"
+ "Invalid FD score threshold!"
+ "Invalid FEP Id %d"
+ "Invalid Mem type"
+ "Invalid SIF Id %d"
+ "Invalid SIFDMA Id %d"
+ "Invalid VCId %d"
+ "Invalid arguments!"
+ "Invalid band"
+ "Invalid ch (%zu) total: %u"
+ "Invalid channel %zu"
+ "Invalid corners align flag"
+ "Invalid cost!"
+ "Invalid destination buffer pixel format!"
+ "Invalid detSelectionTempLen"
+ "Invalid eFocusingMethod value!\n"
+ "Invalid extrinsic matrix"
+ "Invalid faceIndex!"
+ "Invalid heat map buffer height!"
+ "Invalid heat map buffer width!"
+ "Invalid image size!"
+ "Invalid input category!"
+ "Invalid input range in FwDetectorAdPreProcConfig!"
+ "Invalid input stride!"
+ "Invalid mapped offset! phyOffset: 0x%x\n"
+ "Invalid matchedTrackIndicesLen"
+ "Invalid numTrkObjects!"
+ "Invalid numbers of columns!"
+ "Invalid object class"
+ "Invalid orientation!"
+ "Invalid output parameter!"
+ "Invalid pipe %d"
+ "Invalid reg Index! phyOffset: 0x%x\n"
+ "Invalid request"
+ "Invalid resId %d"
+ "Invalid section Index! phyOffset: 0x%x\n"
+ "Invalid sensitivity!"
+ "Invalid size(s)!"
+ "Invalid source buffer pixel format!"
+ "Invalid srcPyrInfo!"
+ "Invalid state!"
+ "Invalid subMode"
+ "Invalid temp buffer!"
+ "InverseBinningGainFactorSet"
+ "Invocation: %s():L%zu"
+ "Ipc allocation %p index %d"
+ "IpcDownCb"
+ "IrPowerSaveModeEnableSet"
+ "IrPowerSaveModeStop"
+ "IrSensorStandbyEnter"
+ "IrSensorStandbyExit"
+ "IrStrobeStandbyEnter"
+ "IrStrobeStandbyExit"
+ "IsAsymmetricCropSupported"
+ "IsBufferShared"
+ "IsFPCEnabled"
+ "IsFrameDoneCompletedForFrame"
+ "IsGMCPossible"
+ "IsInIntermediateState(m_channelState[ch])"
+ "IsInTerminalState(desired_state)"
+ "IsInTerminalState(m_channelState[ch])"
+ "IsInTerminalState(pR->desiredState)"
+ "IsLTCEnable(): %d, pLtmGridBuf!=NULL: %d, bLinearLTC: %d\n"
+ "IsMemConfigReg"
+ "IsOpticalCardConnected"
+ "IsPDPBypass"
+ "IsPMUValid"
+ "IsPMUValid(): add=%p\n"
+ "IsPipeDoneCompletedForFrame"
+ "IsPowerOn()"
+ "IsReadyToBracketingCapture"
+ "IsReadyToPrepare"
+ "IsSLAFFrame()"
+ "IsSLAFFrame() == true"
+ "IsSectionPowerOn(sectionId)"
+ "IsSectionReadyToPowerOn(sectionId)"
+ "IsSkipStatsArm"
+ "IsSlotReadyToRun"
+ "IsSlotReadyToRun decimation frameDropped=%d"
+ "IsSrcGoDoneForPipe"
+ "IsStatsSkipped"
+ "IsTMCaptureOrderedIdx"
+ "IsVcPipelineDone"
+ "IspConfg: BusyDestBE 0x%x"
+ "IspConfg: BusyDestFE 0x%x"
+ "IspConfg: BusySrcBE 0x%x"
+ "IspConfg: BusySrcFE 0x%x"
+ "IspEngEventLogger"
+ "IspEngineAgent: Warp [%llu, %llu] %.3f"
+ "IspEngineCallback"
+ "IspHPerfBlockInit"
+ "IspOutpuFormatGetFromRawBpp"
+ "IspOutputSetup"
+ "IssueCachedIspJob"
+ "IssueJob"
+ "J41y"
+ "J49x"
+ "J58p"
+ "J62x"
+ "J7x"
+ "J7xm"
+ "J8x"
+ "JobDone"
+ "Just Dumped before, Skip it!\n"
+ "KDF %d fc %d Status 0x%x\n"
+ "KDF req idx %d @ %.4f\n"
+ "KDFHostRequest"
+ "KDFSensorUpdate"
+ "Key 0x%x 0x%x Flow Status 0x%x%x unwrap 0x%x\n"
+ "KeyGen_Done"
+ "KeyGen_Start"
+ "LACC DATA DUMPING"
+ "LACC HFFver=%u"
+ "LACC Operate: %fms"
+ "LACC RANSAC MATRIX"
+ "LACC RANSAC_ESTIMATION_DONE"
+ "LACC Status: %d, numInliers %d, biasIn = %f, biasOut = %f"
+ "LACC-match program finished"
+ "LACC-match program is going to resume"
+ "LACC-match program loaded; going to de-assert SwReset"
+ "LACC:   [%d] biasIn %f, biasOut %f, numInliers %d, GNA %f"
+ "LACC:  start operation"
+ "LACCInputConfig: END"
+ "LACCInputConfig: START"
+ "LACC[%d],nPts[%d],nInliers[%d],inlierPct[%5.3f],biasIn[%5.3f],biasOut[%5.3f],ts[%5.3fms]\n"
+ "LACC[%d],nPts[%d],nInliers[%d],inlierPct[%5.3f],biasIn[%5.3f],biasOut[%5.3f]]\n"
+ "LCAF_FocusFSM"
+ "LCAUX Ch%zu Finished %s %f ms\n"
+ "LCDRV Ch%d Stop Z Position is not supported!\n"
+ "LCDRV Ch%u Using ESC Method %d\n"
+ "LCESetup"
+ "LED EN: 0x%x Reg: Center 0x%x Corner 0x%x Side 0x%x\n"
+ "LED EN: 0x%x Reg: Center 0x%x Corner 0x%x Side 0x%x, TotalCurr %dmA\n"
+ "LED Register values: 0x%x 0x%x"
+ "LED Register values: 0x%x 0x%x "
+ "LED ratio: %f"
+ "LEDConvertCurrentToStrobeRegister"
+ "LEDConvertStrobeRegisterToCurrents"
+ "LEDCurrToStrobeReg"
+ "LEDCurrToTorchReg"
+ "LEDIndicatorContrl"
+ "LEDIndividualFlashlightControl"
+ "LEDLumaParamsConfig"
+ "LEDPreFlashCurrentLimitSet"
+ "LEDSegTorchCurGet"
+ "LEDTorchCurrentsGet"
+ "LED_allch_Update"
+ "LED_allch_Update_PWM"
+ "LED_ch_Update"
+ "LED_ch_disable"
+ "LENSC: %s: %s: Invalid number of events - %d\n"
+ "LENSC: %s: %s: Out-of-bounds command %zu (total: %u)\n"
+ "LENSC: Skipping init for ch%zu\n"
+ "LENSC: This function (%s) doesn't behave as expected\n"
+ "LENSC: Unhandled request! ch%d; desiredState: %d"
+ "LFAFPosMonitoring"
+ "LM3566 %s(0x%04x), cool: 0x%x, warm: 0x%x\n"
+ "LM3566 %s(0x%04x), cool: 0x%x, warm: 0x%x, torLEDC[0]: %d, torLEDC[1]: %d \n"
+ "LM3566 %s: CpreNom=0x%04x coolreg: 0x%x, warmreg: 0x%x\n"
+ "LM3566 LEDIndicatorContrl\n"
+ "LM3566 Main Flash Override, cool: 0x%x, warm: 0x%x\n"
+ "LM3566 NTC Detection OFF\n"
+ "LM3566 PowerOff: 0x%x\n"
+ "LM3566 RESET2: Stat:0x%02x%02x\n"
+ "LM3566 RESET: Stat:0x%02x%02x\n"
+ "LM3566 RESET: isTorchOn:0x%x, ch:0x%x\n"
+ "LM3566 Standby, EN %d\n"
+ "LM3566 Torch Override (per driver), cool: %.1f mA, warm: %.1f mA\n"
+ "LM3566 Torch Override, coolreg: 0x%x, warmreg: 0x%x\n"
+ "LM3566 maxPreflashCurrent_mAmps: 0x%x = %d mA, maxPreflashCurrentRatio: 0x%x = %d%%\n"
+ "LM3566 maxTorchCurrent_mAmps: 0x%x = %d mA, maxTorchCurrentRatio: 0x%x = %d%%, torchTableMax: (per driver) %d mA\n"
+ "LM3566::%s ColorMode=%d (param=%d%% warm LED) CpreMan=0x%04x CstrMan=0x%04x\n"
+ "LM3566::%s ColorMode=%d (param=%d) CpreMan=0x%04x CstrMan=0x%04x\n"
+ "LM3566::%s ColorMode=%d (param=0x%04x) CpreMan=0x%04x CstrMan=0x%04x\n"
+ "LM3566::%s: ColorMode: %d, CpreNom: 0x%04x CstrNom: 0x%04x cct: %d ambientLux: %d \n"
+ "LM3566::%s: CpreNom: 0x%04X, CpreMan: 0x%04X\n"
+ "LM3566::%s: CstrNom: 0x%04X\n"
+ "LM3566::%s: mode: 0x%x, param: 0x%04X\n"
+ "LM3566::(auto): torchOn=%d => ignored cct=%d\n"
+ "LOCAL_ID, skipping Global\n"
+ "LPDP CHIP INFO NOT SUPPORTED\n"
+ "LRNZ+ %u Reset failed (dev %d)! Try %d..."
+ "LRNZ+ %u Time to power on reset: %.2f ms\n"
+ "LRNZ+ %u Wake2 failed (dev %d)! Try %d..."
+ "LRS flickerFreq %u"
+ "LS parameter memory size=%zu,p=%p cached=%p"
+ "LSC readout CFG #%d, window: [%d, %d, %d, %d]"
+ "LSCChromaCorrectionOutputGet"
+ "LSCReadoutWindowInit"
+ "LSM Buf for ch:%d frame:%d syncTag:%d"
+ "LTCGridCalcAlgoAccelerateVE"
+ "LTM LACC Prepare: %fms, Operate: %fms"
+ "LTM LACC:  start operation"
+ "LTM MultiCh: CLTMDrv::CLTMDrv"
+ "LTM MultiCh: CLTMDrv::Reset"
+ "LTM MultiCh: CLTMDrvLTM57::CLTMDrvLTM57 name=%s calling Reset"
+ "LTM MultiCh: CLTMDrvLTM57::Reset"
+ "LTM smooth: smpl=%.1fHz sensT=%.2fs=>strOut=%.1f , maxStp=%.4f"
+ "LTM total LACC Operate: %fms"
+ "LTMBuf"
+ "LTMBufferProcessor"
+ "LTMSetup"
+ "LTMStatsProcess"
+ "LTM_GLOBAL_HIST_NUM_CHANNELS * LTM_GLOBAL_HIST_NUM_BINS * sizeof(uint32_t) == pHITHStat->globalHist2StatSize"
+ "LTM_GLOBAL_HIST_NUM_CHANNELS * LTM_GLOBAL_HIST_NUM_BINS * sizeof(uint32_t) == pHITHStat->globalHistStatSize"
+ "LTM_LOCAL_HIST_NUM_BINS_HW == pHITHStat->localHistBinSize"
+ "LTM_LTC_CALC_TOT * LTM_LOCAL_HIST_NUM_BINS_HW * sizeof(uint16_t) == pHITHStat->localHistStatSize"
+ "LTM_LTC_GRID_CALC_HORIZONTAL_SIZE == pHITHStat->localHistNumHorBlocks"
+ "LTM_LTC_GRID_CALC_VERTICAL_SIZE == pHITHStat->localHistNumVerBlocks"
+ "LTM_LTC_MAX_MANUAL_SIZE >= ltcMemSize"
+ "LTM_SPATIAL_CCM_MAX_MANUAL_SIZE >= sccmMemSize"
+ "LTM_THUMBNAIL_WIDTH * LTM_THUMBNAIL_HEIGHT * pHITHStat->thumbnailTotal * sizeof(uint16_t) == pHITHStat->thumbnailStatSize"
+ "LTMspatialCCMROI->height >= MIN_LTM_HEIGHT"
+ "LTMspatialCCMROI->width >= MIN_LTM_WIDTH"
+ "LUT [idx=%u]={%.3f x %.3f}"
+ "LVT filter ch=%zu (prev ch=%zu) size=%.3f scale=%.3f"
+ "LaccDoorbellSet"
+ "LaccMakeLinearSystem4Weights"
+ "LaccMatchDoorbellSet: CVD_LACCMATCH_LACCMATCHCORE_DOORBELLSET(0x%lx)=0x%08x"
+ "LaccMatchDoorbellSet[%d]: CVD_LACCMATCH_LACCMATCHCORE_DOORBELLSET(0x%lx)=0x%08x"
+ "LaccMatchSwReset: CVD_LACCMATCH_LACCMATCHBOOT_SWRESET(0x%lx)=0x%08x"
+ "LaccMatchSwReset[%d]: CVD_LACCMATCH_LACCMATCHBOOT_SWRESET(0x%lx)=0x%08x"
+ "LaccSwReset"
+ "Landmarks"
+ "Lane %d not supported"
+ "LcDrv[%u]:\n"
+ "Legacy BKT master[%u] req 0x%x, vT %f, exp %f, gA 0x%x\n"
+ "Legacy BKT master[%u] req 0x%x, vT %f, exp %f, gL 0x%x\n"
+ "Legacy BKT slave %zu, BKT[%u] vT %f, exp %f, gA 0x%x\n"
+ "Legacy BKT slave %zu, BKT[%u] vT %f, exp %f, gL 0x%x\n"
+ "Lens Coefficeient[0] %f\n"
+ "Lens Coefficeient[1] %f\n"
+ "Lens Coefficeient[2] %f\n"
+ "Lens Coefficeient[3] %f\n"
+ "Lens Coefficeient[4] %f\n"
+ "Lens Service Success\n"
+ "Lens gravityFactor %f\n"
+ "Lens lensCoefficientsValid %d\n"
+ "Lens lensPositionScalingFactor %f\n"
+ "Lens sensorID %d\n"
+ "Limited Sensor TileWindow info for Full config [%d %d %d %d]\n"
+ "Limited Sensor offsets to full config [%d %d %d %d]\n"
+ "Limiting adrc2 ratio from %f to %f"
+ "Line up test 0x%x = 0x%x\n"
+ "LineConfig <= AISP_BESPROC_PIPE_BESPROCWARP_CONFIG_LINECONFIG_QUARTER"
+ "LinkTraingPrep"
+ "LnsCtrlBlkStop"
+ "Load %s done %zu bytes"
+ "Load %s failed"
+ "Load %s prepare"
+ "Load Programe, progId %d procId %d"
+ "LoadAEExpandedTablesDefaultFFC"
+ "LoadAEExpandedTablesDefaultSW"
+ "LoadAEExpandedTablesDefaultTele"
+ "LoadAEExpandedTablesDefaultWide"
+ "LoadHWRegCfgsDone"
+ "LoadLCDataFile"
+ "LoadOTPfromRegs"
+ "LoadStaticTunables"
+ "LoadTunables"
+ "Local CVDAll size %lu %d %lu\n"
+ "Local CvdDp size %lu %d %lu\n"
+ "Local DESGEN size %lu %d %lu\n"
+ "Local DesMatch size %lu %d %lu\n"
+ "Local Hist is enabled %d\n"
+ "Local pOpItem size %lu %lu offset %d offset_next %d\n"
+ "Local pOpItem size %lu %lu offset %d total %d\n"
+ "LocalHistBlockSize.X %u"
+ "LocalHistBlockSize.X %u LocalHistBlockSize.Y %u"
+ "LocalHistBlockSize.Y %u"
+ "Log"
+ "Log %s"
+ "Log %s configNum %d"
+ "Log (%u, %u): No name for event ID %u!\n"
+ "LogADResult"
+ "LogConfig"
+ "LogFDFrameProfile"
+ "LogFDResult"
+ "LogInputAndOutputConfig"
+ "LogLandmarkResult"
+ "LogPyramidLevel"
+ "LogStart"
+ "LoggingEvent"
+ "Logical Scaler0: cropW %f, cropH %d \n"
+ "Logical Scaler0: cropX %f, cropY %f \n"
+ "Logical Scaler0: outW %d, outH %d \n"
+ "Logical Scaler1: cropW %f, cropH %d \n"
+ "Logical Scaler1: cropX %f, cropY %f \n"
+ "Logical Scaler1: outW %d, outH %d \n"
+ "Look for /Replay/ac-%zu.anfm, expect %zu bytes"
+ "LookUpExposureParamsFromTable"
+ "LookUpLinearExpParamsFromTable"
+ "Lowest fld temp: %.2f, Avg: %.2f, sum: %.2f, %d, Exp sum %d, %d, Avg %d\n"
+ "LowlightSifrTurnoff"
+ "LtmCore"
+ "LvlSmthHFF"
+ "M%s:DD RV %f FV %f dma %f fc %d"
+ "M2M"
+ "M2MGDC Video without AuxScl output"
+ "M2S %hhu %u"
+ "M2S Lattice LogAWBGain %f %f %f"
+ "M2S Linear %f %f %f"
+ "M3 buffer generated!"
+ "MATCH PAIR EXTRACTION Done!"
+ "MATRIX_ABNORMAL\n"
+ "MATRIX_BIASED_KEYS\n"
+ "MBNR(ch:%ld,en:%d)-->totGainDown:%.3f,knobMBNR=%d,radScale=%d,stdScale:%.3f,totGain: %.3f"
+ "MBNRConfig"
+ "MBNREnable"
+ "MBNRSetup"
+ "MC_AOP_ENDPOINT_SET2"
+ "MC_AOP_ENDPOINT_SET2_DONE"
+ "MCacheDSID != DSID_INVALID"
+ "MDMetadataWrite"
+ "MFAWB: ch=%hhu F=%p D=%p "
+ "MFAWB:ch=%hhu fn=%u mS=%hhu mP=%hhu isDef=%hhu isConv=%hhu isMS=%hhu rn=%6.2f %6.2f meta=%6.2f %6.2f day=%6.2f "
+ "MFlash curr 0x%x, 100%%\n"
+ "MFlash pattern: LED_GROUPING_NTC_WIDE_MODE\n"
+ "MILCal"
+ "MIWB/STF command set received with enable=%u"
+ "MLAF FFC: dumping inputs..."
+ "MLAF FFC: dumping output..."
+ "MLAF FFC: host metadata dump rc= %u"
+ "MLAF FFC: input patches dump rc= %u"
+ "MLAF FFC: output disparity dump rc= %u"
+ "MLAF FFC: sensor raw dump rc= %u"
+ "MLAF Tele: dumping inputs..."
+ "MLAF Tele: dumping output..."
+ "MLAF Tele: input ANE dump rc= %u"
+ "MLAF Tele: input left dump rc= %u"
+ "MLAF Tele: input right dump rc= %u"
+ "MLAF Tele: output ANE confidence dump rc= %u"
+ "MLAF Tele: output ANE disparity dump rc= %u"
+ "MLAF net=%zu memtype[%ld] ch: %zu bufSize: %ld, p=%p"
+ "MLAF: networkIdx: 0x%zx version: 0x%x numProcedure: %d"
+ "MLAF: procedure[%ld] buf count: %d"
+ "MLAFROISetup"
+ "MLAF_SLAF_Int"
+ "MLAF_SLAF_Out"
+ "MLVNR MacOS Auto Mode ch=%zu,Threshold=%d:%d,FPS=%d:%d,RampDownCnt=%d"
+ "MLVNR NightMode Auto Mode ch=%zu,Threshold=%d:%d,RampDownCnt=%d"
+ "MLVNR TimeWarp Auto Mode ch=%zu,Threshold=%d:%d,RampDownCnt=%d"
+ "MLVNRSetup"
+ "MMS SW: count %d min %d max %d sum %llu sumSq %llu"
+ "MMS readBack: %d %d %d %llu %llu"
+ "MOTIONESTIMATOR_BufRcvd"
+ "MOTIONESTIMATOR_EV0_DONE"
+ "MOTIONESTIMATOR_EV0_START"
+ "MRCAMStrobeGpioGet"
+ "MSAWBMatch::TM ch=%d gain=%d %d combo=%d %d norm=%d %d %d "
+ "MSG is on but min/max framerate are 0"
+ "MSG: "
+ "MSNR %u %s() STINJ enabled, Using I2C patch; (v%u.%u.%u > v%u.%u.%u) (%s)\n"
+ "MSNR %u %s() Wr: addr: 0x%08X; len: 0x%04X\n"
+ "MSNR %u Reset failed! Try %d..."
+ "MSNR %u Time to software reset: %.2f ms\n"
+ "MSNR %u Wake2 failed! Try %d..."
+ "MSTFSetup"
+ "MTHOutputProcess"
+ "MTHSetup"
+ "MULTISYNC"
+ "MULTISYNC_HW_SYNC_TRIGGER"
+ "MULTISYNC_IDLE"
+ "MULTISYNC_LOCKED"
+ "MULTISYNC_SYNC_START"
+ "MULTISYNC_SYNC_STOP"
+ "Main & Sifr Multi Chs Capture"
+ "Main Flash Override (per driver), cool: %.3f A, warm: %.3f A"
+ "Main Flash Override, cool: 0x%x, warm: 0x%x"
+ "Main flash exposure setting delayed %d frame"
+ "Main/Pre Ratio: 0x%04X"
+ "Main/Pre ratio: 0x%04X"
+ "MainDestSetup"
+ "MainProcessingDestSetup"
+ "Make Temporal Decision: isLocked = %d, simiScr = %f, conf = %f"
+ "MakeAFEProcConnection"
+ "MakeFlowConnection"
+ "MakeLinearSystemNeon4Weights"
+ "MakeStatsConnection"
+ "Manual AE [EXP:%.0f, AG:%d ISP:%d]\n, Manual SIFR AE [EXP=%.0f, AG=%d, ISP=%d]\n"
+ "ManualWB mode %d not implemented!"
+ "MapAbsoluteRect"
+ "MapCCT"
+ "MapCurrentLTMGridToPreviousLTMGrid"
+ "MapFOVScale"
+ "MapNormalizedRect2FullSensorArray"
+ "MapNormalizedRectPerCfg"
+ "MapPerOutputZoomFactor"
+ "MapRawTileRect"
+ "MapZoomFactor"
+ "Master %zu done before slave %zu, slave to update"
+ "Master asking to release the remap while it is still being used by local user\n"
+ "Master unknown... TM will wait for pair"
+ "Master3AChannelSet"
+ "MasterSlaveProcess"
+ "MasterSlaveSynchronousUpdate"
+ "Match TS Meta ch=%hhu[M]/%hhu[S], WBGain=(%.2f,%.2f)/(%.2f,%.2f)"
+ "Match TS Meta ch=%hhu[M]/%hhu[S], WP=(%.2f, %.2f)/(%.2f,%.2f)"
+ "Matched tracker has kill flag"
+ "Matching: bufferId: %d, dmaId = %d"
+ "MatchingDataForMultiPass"
+ "Matrix must not have paddings!"
+ "Max %zu, Act %zu"
+ "Max Flashlight (per driver): %f mA. Cool0: %f mA, Warm0: %f mA,Cool1: %f mA, Warm1: %f mA\n"
+ "Max Flashlight: %f mA. Cool0: %f mA, Warm0: %f mA"
+ "Max current of %d mA per driver exceeded."
+ "Max preset number reached %d"
+ "Max table number reached %d"
+ "MaxInputTileLinesGet"
+ "MaxVoltageSet"
+ "Mem %p %d"
+ "Mesh Check Result: %s, ret=%d"
+ "Mesh Grid size: [%d, %d]\n"
+ "MessageGMSFilterToRun"
+ "Meta baseAddr: %p, offset: %d, overallBaseAddr: %p"
+ "MetaBufferGet"
+ "MetaBufferRelease"
+ "MetaData: BytesPerCredit=%d, BufferSizeInBytes=%d"
+ "MetaDataID = %d.%d.%d\n"
+ "MetaDataProcess"
+ "MetaDataProcessConfigSIFRFrame"
+ "MetaDataSizeGet"
+ "MetaLogCollectSet"
+ "Metadata version not matching, input(%d.%d.%d), current(%d.%d.%d)."
+ "Metadata version not matching, input(legacy ver %d), current(%d.%d.%d)."
+ "Mine: id %d attn %d g %d %.5f %.5f"
+ "MinimalReset"
+ "MipiErrCnt %d"
+ "MipiError"
+ "MiscDone"
+ "MiscEventUpdate"
+ "MiscSetup"
+ "Mode\n"
+ "Mode not supported %d for ch:%zu"
+ "Mode: 0x%02x Level: %d"
+ "Mode: 0x%02x Level: 0x%04x"
+ "Mode: 0x%02x Level: 0x%04x, CstrNom: 0x%x"
+ "Mode: 0x%02x Level: 0x%04x, Torch limit 0x%xmA"
+ "Mode: 0x%02x Level: 0x%04x, maxMFlash %dmA"
+ "Mode: 0x%02x Level: 0x%04x, maxPFlash 0x%xmA"
+ "ModifyColorHistogramProbApproach"
+ "Module SN: %s\n"
+ "More depth spots received (%d) than allowed for this device (%d)!\n"
+ "MotEstH17: PDE buffer or SLAF mask bufer Unavailable"
+ "MotEstH17: SLAF PDE buffer released!"
+ "MotEstH17: SLAF PDE buffer, SLAF mask buffer, SLAF obj ready!"
+ "MotEstH17: SLAF mask buffer allocated successfully, %p"
+ "MotEstH17: SLAF mask buffer unavailable"
+ "MotEstH17: SLAF mask copied, SLAF obj released!"
+ "MotEstH17: SLAF mask generated!"
+ "MotEstH17: SLAF mask meta copied to MotEstH17!"
+ "MotEstH17: SLAF mask posted to AlgoCtrl!"
+ "MotEstH17: SLAF mask setup took %f ms H=%d, W=%d, S=%d!!"
+ "MotEstH17: SLAF meta to pMeta at Fr %u!"
+ "MotEstH17: SLAF person pixel cnt = %d!"
+ "MotEstH17: SLAF pin, slafReadyToStart=%d, slafFrameSteady=%d"
+ "MotEstH17: buffer for SLAF mask released"
+ "MotEstH17: cannot post SLAF mask to AlgoCtrl via pipe %d"
+ "MotEstH17: frame not ready, released ref[0]"
+ "MotEstH17: frame steady, ready to start"
+ "MotEstH17: no output buffer pool for SLAF mask buffer, shifts=%d"
+ "MotEstH17: rawHeightDefault=%u, rawWidthDefault=%u!"
+ "MotEstH17: reset SLAF status at Fr %u!"
+ "MotEstH17: slafFrameSteady = %d!"
+ "Motion Capture Start Receiving %d\n"
+ "Motion data version %d \n"
+ "Motion: frameId %u, warpMatrixValidEV0 %u"
+ "MotionDetectProcess"
+ "MotionEstimator resource initialization starting..."
+ "MsBePYRSetup"
+ "MsFeProcSetup"
+ "MsFeProcWarpDmaSrcA should enable compression!"
+ "MsFeProcWarpDmaSrcB should enable compression!"
+ "MsFeProcWarpDmaSrcChromaB should enable compression!"
+ "MsMBNRConfigFC"
+ "Mth rect x %u, y %u w %u h %u"
+ "MultiAWBControl"
+ "MultiAeControl"
+ "MultiCam: enable %u, ch %zu, ChMask %x activeCnt %x\n"
+ "MultiCamSIFQueueFree"
+ "MultiCamSIFQueueReserve"
+ "MultiCamSet"
+ "MultiChStillCaptureFrameProcess"
+ "MultiChannelCommandCheck"
+ "MultiChannelContextSwitch"
+ "MultiDeviceSyncConfig"
+ "MultiPassInfoEnQueue"
+ "MultiPassInfoInit"
+ "MultiPassUpdateData"
+ "MultiStepInfoInit"
+ "MultiSyncCamsEventLogger"
+ "MultiUB: ch=%d flag=0x%X, flicker=%.3fms ev0=%.2fms,%.2f,%.2f sifr=%.2fms,%.2f(%d,%d) req=%X vFrm=%d, %d\n"
+ "MultiUB: init ch=%d clk=%u vSizeLB to %d (Max of %d and %d), cfg %d mfrt %d spd %d"
+ "Multiple ROIs matching {traceRoiType=%d, scale=%d}."
+ "NCC FILTERING Time = %f ms"
+ "NCC OPERATION Time = %f ms"
+ "NCC: %.3fms"
+ "NCC: config dma"
+ "NCC: start hardware"
+ "NCC: wait hardware"
+ "NCCMATCH_BG_PAIR_DUMP(Pruned&Partitioned): framename %d"
+ "NCCMATCH_FG_PAIR_DUMP(Pruned&Partitioned): framename %d"
+ "NCCMatch_Done"
+ "NCCMatch_Start"
+ "NCC_EVM_DONE"
+ "NCC_EVM_START"
+ "NCC_FRAME_DONE"
+ "NEG STATS: ch=%d CAlgoControlH12 sets negative stats M2M"
+ "NEG STATS: ch=%d fr=%d master=%d masterPrev=%d"
+ "NFCoeff != NULL && tapEn != NULL"
+ "NO Strobe driver loaded.\n"
+ "NO outputMetaData, outputMetaData.buffer = %llu\n"
+ "NORM"
+ "NOT_USED"
+ "NULL != *pTemp"
+ "NULL != CDMediaBusManager::Instance()"
+ "NULL != Src"
+ "NULL != bankState"
+ "NULL != baseAddr"
+ "NULL != callback"
+ "NULL != cmd.pDmaManager"
+ "NULL != cmdBuf"
+ "NULL != encode_handler[encodeScheme]"
+ "NULL != entry"
+ "NULL != fileBuffer"
+ "NULL != globalOp[opId]"
+ "NULL != hCVPipeDrv"
+ "NULL != hDetectedSensor"
+ "NULL != hDrvHueMap"
+ "NULL != hI2C"
+ "NULL != hProcDMA[besInput]"
+ "NULL != hProcPipe0ResDMA"
+ "NULL != hProcRes[id]"
+ "NULL != instance"
+ "NULL != lenXY"
+ "NULL != m3GdcTbl"
+ "NULL != meshMem"
+ "NULL != meta.pFd"
+ "NULL != meta.pHostMetaData"
+ "NULL != metaInfo"
+ "NULL != motion"
+ "NULL != node"
+ "NULL != outMask"
+ "NULL != pAFAssistOutput"
+ "NULL != pAPSOutput"
+ "NULL != pAPSReducedOutput"
+ "NULL != pAPSStatsOutput"
+ "NULL != pAction"
+ "NULL != pActionList"
+ "NULL != pActionListHdr"
+ "NULL != pActionListHdr[pCmd->ch]"
+ "NULL != pAopRingBufferWriterLoop[pCmd->endPointId]"
+ "NULL != pAttn"
+ "NULL != pBlurAFDebugOutput"
+ "NULL != pBundle"
+ "NULL != pCBAFDebugOutput"
+ "NULL != pCTMStatsOutput"
+ "NULL != pCfgIn"
+ "NULL != pChoosenOp"
+ "NULL != pChosenFifo"
+ "NULL != pChosenHW"
+ "NULL != pCmd"
+ "NULL != pCmd->pCb"
+ "NULL != pCmpnActionList"
+ "NULL != pCmpnConfigActionList"
+ "NULL != pCmpnDMACntxtID"
+ "NULL != pConfigDb"
+ "NULL != pContext"
+ "NULL != pData"
+ "NULL != pDbg"
+ "NULL != pDefaultHWRegValue"
+ "NULL != pDepth2PosMapOutput"
+ "NULL != pDestination"
+ "NULL != pDistOutput"
+ "NULL != pDma"
+ "NULL != pDmaManager"
+ "NULL != pDmaManagerIndexPool"
+ "NULL != pDmaManagerList"
+ "NULL != pDrv"
+ "NULL != pDumpBundle"
+ "NULL != pFLDDebugOutput"
+ "NULL != pFd"
+ "NULL != pFocusMapOutput"
+ "NULL != pFocusPixelOutput"
+ "NULL != pFrameInfo"
+ "NULL != pG"
+ "NULL != pGlobalInstance"
+ "NULL != pHostBuffer"
+ "NULL != pHostMetaAESectionOutput"
+ "NULL != pHostMetaCalSectionOutput"
+ "NULL != pHostMetaData"
+ "NULL != pHostMetaProjectorSectionOutput"
+ "NULL != pHostMetaSifrSectionOutput"
+ "NULL != pHostMetaSlaveSectionOutput"
+ "NULL != pIcCompConfigActionList"
+ "NULL != pInfo"
+ "NULL != pInput"
+ "NULL != pInstance"
+ "NULL != pInstance2"
+ "NULL != pIpcRingBufferIn[pCmd->endPointId]"
+ "NULL != pIpcRingBufferOut[pCmd->endPointId]"
+ "NULL != pItem"
+ "NULL != pLen"
+ "NULL != pLens"
+ "NULL != pMasterSlaveAFOutput"
+ "NULL != pMem"
+ "NULL != pMemoryTableSize"
+ "NULL != pMetaData"
+ "NULL != pMotionOutput"
+ "NULL != pMotionService"
+ "NULL != pMotionStatsOutput"
+ "NULL != pMsg"
+ "NULL != pNewBaseAddr"
+ "NULL != pNewTableBuf"
+ "NULL != pNode"
+ "NULL != pNodeBuf"
+ "NULL != pOISOutput"
+ "NULL != pOISStatsOutput"
+ "NULL != pOp"
+ "NULL != pOpListHdr"
+ "NULL != pOpListHdr[pCmd->ch]"
+ "NULL != pPC"
+ "NULL != pPartList"
+ "NULL != pPde"
+ "NULL != pPicIn"
+ "NULL != pPicInChroma"
+ "NULL != pPicInLuma"
+ "NULL != pPicOutChroma"
+ "NULL != pPicOutLRME"
+ "NULL != pPicOutLuma"
+ "NULL != pPicTileInfo"
+ "NULL != pPioDma"
+ "NULL != pQ"
+ "NULL != pROIService"
+ "NULL != pRegBuf"
+ "NULL != pReqFifo"
+ "NULL != pReqFifo[fifoNbr]"
+ "NULL != pReqIndexPool"
+ "NULL != pReqInfo"
+ "NULL != pReqInfo[i].pSectionList"
+ "NULL != pReqPool"
+ "NULL != pRequest->pCb"
+ "NULL != pResourceIndex[endPoint]"
+ "NULL != pResourceIndex[pCmd->endPointId]"
+ "NULL != pSectionId"
+ "NULL != pSectionList"
+ "NULL != pSegments"
+ "NULL != pServer"
+ "NULL != pService"
+ "NULL != pSharedMemory"
+ "NULL != pSharedMemoryCmpnRtrDesc"
+ "NULL != pSharedMemoryPIODMA"
+ "NULL != pSharedMemoryPackReg"
+ "NULL != pSharedMemoryReg"
+ "NULL != pSharedMemoryTable"
+ "NULL != pSysCfg"
+ "NULL != pSystemHostMeta"
+ "NULL != pTable->tableBuf"
+ "NULL != pTableList"
+ "NULL != pTaskHistoryHead"
+ "NULL != pTunableTableStatic_AISP"
+ "NULL != pUser"
+ "NULL != pValue"
+ "NULL != pWarpM3DmaBuffer"
+ "NULL != personMask"
+ "NULL != picIn"
+ "NULL != picOut"
+ "NULL != pio"
+ "NULL != ppAPSPosition"
+ "NULL != ppAPSPosition[ch]"
+ "NULL != ppDmaManagerList"
+ "NULL != ppFDReqList"
+ "NULL != ppMemroyTablePool"
+ "NULL != ppReqList"
+ "NULL != ppTablePool"
+ "NULL != ptempPadSharedMemory"
+ "NULL != ref"
+ "NULL != ref[0]"
+ "NULL != sectionPowerState"
+ "NULL != sectionState"
+ "NULL != semalist"
+ "NULL != semaphore"
+ "NULL != sharedMemory"
+ "NULL != tmpMask"
+ "NULL == instance"
+ "NULL == pDefaultHWRegValue"
+ "NULL == pErrorIsrCb || NULL == pErrorIsrHandler"
+ "NULL == pGlobalInstance"
+ "NULL == pHandler"
+ "NULL == pInstance"
+ "NULL == pInstance2"
+ "NULL == pIpcRingBufferIn[pCmd->endPointId]"
+ "NULL == pIpcRingBufferOut[pCmd->endPointId]"
+ "NULL == pMem"
+ "NULL == pMemoryTableSize"
+ "NULL == pMemroyPackRegPool"
+ "NULL == pMemroyRegPool"
+ "NULL == pPackRegPool"
+ "NULL == pRegPool"
+ "NULL == ppMemroyTablePool"
+ "NULL == ppTablePool"
+ "NURI Flood min PW 0.7ms\n"
+ "NVMDataLoadFromSensor BootSequence done"
+ "NVMDataLoadFromSensor done."
+ "NVMDataLoadFromSensor ready"
+ "NVMDataLoadFromSensor start"
+ "NVStorageDiscover"
+ "Need AE meta data"
+ "Need Prediction Here for Task %s\n"
+ "Need to enable meta replay"
+ "Needle=%d Ratio=%.2f\n"
+ "Negative entry found!"
+ "Neon already powered on, Stat:0x%x"
+ "Net init. done"
+ "Net output count out of bounds!"
+ "NetDone %d"
+ "NetInit"
+ "NetInput[CMLAF_MEM_TYPE_DEPTH_RAW_BUF]"
+ "NetInput[CMLAF_MEM_TYPE_RGB_RAW_BUF]"
+ "NetProcDone"
+ "NetProcess"
+ "NetProcessor"
+ "New Buffer Sent by IC when Stats was processing Old request"
+ "New cc    : %6hu %6hu %6hu %6hu "
+ "New nonce set\n"
+ "New sharedPool[%d][%d]= %p"
+ "NewFrameProcessing"
+ "No %d Buffer of Op is not set buffer id 0x%x"
+ "No %d Buffer of Op is set buffer id 0x%x addr %p stride 0x%zx"
+ "No AFEProc for ch %zu"
+ "No Callibration LED Data Avilable \n"
+ "No ClrBe buffer available"
+ "No DMAMgr available yet!"
+ "No MBNR buffer available"
+ "No Motion Service\n"
+ "No MsMBNR buffer available"
+ "No Pair is found"
+ "No RPC available!\n"
+ "No Tile Scale1 buffer available"
+ "No Tile Scale2To5 buffer available"
+ "No af for ch %zu\n"
+ "No available slot for a new signal"
+ "No body found, decent confidence(%u) => keep ANFD=%d"
+ "No buffer to send to server"
+ "No event is recorded yet!\n\n"
+ "No face\n"
+ "No fault report, ignore INT\n"
+ "No feature pts detected in personMask Area chId = %zu, perMsk Frm = %llu, actual Frm = %llu"
+ "No hAFEProc for ch %zu!"
+ "No input buf yet!"
+ "No metadata for ch %zu"
+ "No mth setting yet for ch %zu"
+ "No need to do CViSegDataService channel start for depth cam\n"
+ "No need to update frequency in zoom. streaming config %u, configIdx %u"
+ "No need to update frequency in zoom. streaming config %u, currConfig %u"
+ "No room for coredump!"
+ "No sMetaData"
+ "No separate AF Windows this call is Unexpected"
+ "No spots in ROI!"
+ "No stats master !statMasterCh %hhu previewCh %hhu"
+ "Non monotonic input ref[%i]=%f, ref[%i]=%f"
+ "Non monotonic query in[%i]=%f, in[%i]=%f"
+ "NonChEventLogger"
+ "Normalizied windowTile for CFG #%d [x, y, w, h] = [%d %d %d %d]"
+ "Not Init Lens for DistDriver Tuning:%p ch:%zu"
+ "Not enabling Color Hist 2D for channel %zu, frame count %u enable %u output %p"
+ "Not enabling RBGHist for frame %u ch %u"
+ "Not enabling mth src dma ch %zu"
+ "Not enough FEP available"
+ "Not enough ROIs (%zu)"
+ "Not enough pixels to update CoolGain"
+ "Not enqueue TM queue ch %zu, enqueue %u, master %u, rawNow %u"
+ "Not expecting channel stop in this state! (%d)"
+ "Not implemented yet!"
+ "Not implemented yet..."
+ "Not implemented!"
+ "Not ready to do capture. channelsInSync %u masterCh %u frameCount %u"
+ "Not resetting ROI"
+ "Not sending to AFEProc, ch %zu AFEProc %d outputPipe %p"
+ "Not supported"
+ "Not supported metadata version 0x%x, min 0x91C"
+ "Not try to put frame in TM on ch %zu: isQueueFrame %u processSensorRawNow %u"
+ "Not updating confindenceMap. ch %zu, frame %llu\n"
+ "Not valid channel ID!\n"
+ "NotReady"
+ "NotifyListener"
+ "NumHorPatch = %d, NumVerPatch = %d, NumValidPatch = %d\n"
+ "NumInliersFound = %d"
+ "Number of actions: %d"
+ "Number of actions[%lu]: %d"
+ "Number of attention results: %d\n"
+ "Number of channels from Group %s type %s is %d, chBitMaskGen 0x%02x"
+ "Number of faces:%d, largest face: [%d %d %d %d]"
+ "Number of keypoints = %d "
+ "Number of patches in PW exceed the allocation!\n"
+ "OD Results: %s score %.3f"
+ "OD fr %d ctx %zu IPC Start"
+ "OD fr %d ctx %zu IPC Started aneReqSend %d"
+ "OD score %f expected %f"
+ "OIS LSC is not enabled"
+ "OPB SB EV0 rFPN data: [0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X]\n"
+ "OPB SB EVM rFPN data: [0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X]\n"
+ "OPB buf size: %zu, SIFR support: %u, SIFR on: %u, SIFR skip ratio: %u\n"
+ "OPBCoeffValKa = %f, OPBCoeffValKb = %f"
+ "OPMODE_DUAL_BANK  Skip Disable DMA"
+ "OPMODE_DUAL_BANK  use case Trig"
+ "OPMODE_DUAL_BANK new raw pCap %p [%d]=%p retain %d, Active %p %d"
+ "OPMODE_DUAL_BANK pSifDmaFrame[%d]=%p"
+ "OPMODE_DUAL_BANK skip Disable DMA"
+ "OPMODE_DUAL_BANK use case FEP SIFR link"
+ "OPMODE_DUAL_BANK use case FV bHwBusy %d"
+ "OPMODE_DUAL_BANK use case RV"
+ "OPMODE_DUAL_BANK use case SKIP NFP"
+ "OPMODE_DUAL_BANK use case SensorGo"
+ "OPMODE_DUAL_BANK use case done bank %d"
+ "OPMODE_DUAL_BANK use case rawbuffer request"
+ "OPMODE_DUAL_BANK use case send %p, fep %p"
+ "OPMODE_DUAL_BANK use case srcDone %d"
+ "OPMODE_DUAL_BANK use case toggle Bk"
+ "OPMODE_DUAL_BANK use case toggle Bk %p %p"
+ "OPMODE_DUAL_BANK: pFepDmaBuf[%d]=%p %p"
+ "OPMODE_DUAL_BANK: pNonImageData[%d]=%p"
+ "OPMODE_DUAL_BANK: pSifDmaFrame[%d]=%p"
+ "OPMODE_DUAL_BANK: pSifrDmaFrame[%d]=%p"
+ "OPMODE_DUAL_BANK: pSifrFepDmaBuf[%d]=%p %p"
+ "OTF"
+ "OTF VNF %d %d\n"
+ "OTF yGOCGain = %d"
+ "OTF yGOCoffset1 = %d"
+ "OTPDataGet"
+ "OUTPUT_CONFIG_SET"
+ "OUTPUT_CONFIG_SET_DONE"
+ "Object[%d] <%d %d> %d %d %d %d %d"
+ "Objects not sorted correctly!"
+ "Obstruction detection pre-processing:"
+ "Occlusion"
+ "Occlusion threshold out of bounds!"
+ "OdFrameProcessor"
+ "OdPostProcessor"
+ "OdPreProcessor"
+ "Offset %d %d\n"
+ "OisMetaUpdate"
+ "Old rdout:%d cfg:%zu -> New rdout:%d"
+ "OneByteUpdateQueueUncached"
+ "OneFrameDone"
+ "OneReqProcess"
+ "Only preflash FD: ledOffFaceAve %d\n"
+ "Opaque pointer failed nullptr check (cmd ID: %zu)"
+ "Operate"
+ "Opmode 0x%x ErrCode 0x%x SysCfg 0x%llx\n"
+ "Optical center (%.1f, %.1f), prescale (%.1f, %.1f)\n"
+ "OptimizeFESPixelSquareness"
+ "OptimizePYRPixelSquareness"
+ "Original: %s, step( %d, %d), init (%d,%d), "
+ "Out of bounds!"
+ "Out2ERDcn"
+ "Out2FDDcn"
+ "Out2IC"
+ "Out2PDE"
+ "OutBuf"
+ "OutBufSalve"
+ "OutCfg[0]: Tex:W=%d,H=%d, Cmp:OS=0x%x,SD=%d,SZ=%d, Hdr:OS=0x%x,SZ=%d, mode=%d"
+ "OutCfg[1]: Tex:W=%d,H=%d, Cmp:OS=0x%x,SD=%d,SZ=%d, Hdr:OS=0x%x,SZ=%d, mode=%d"
+ "OutConfMap"
+ "OutFrm"
+ "OutFrmCap"
+ "OutFrmCh0"
+ "OutFrmCh1"
+ "OutFrmCh2"
+ "OutFrmCh3"
+ "OutFrmCh4"
+ "OutInfo AE_REQ_ANALGAIN %llu %llu : %u"
+ "OutInfo AE_REQ_DIGIGAIN %llu %llu : %u"
+ "OutInfo AE_REQ_EXPOSURE %llu %llu : %u %u"
+ "OutInfo AE_REQ_SNSRDIGIGAIN %llu %llu : %u"
+ "OutInfo AE_REQ_STROBE_CURRENT_PCENT %llu %llu : %.4f"
+ "OutInfo AE_REQ_STROBE_PULSE_WIDTH %llu %llu : %.4f"
+ "OutInfo AE_REQ_STROBE_TYPE %llu %llu : %.4f"
+ "OutInfo AE_REQ_VSIZE %llu %llu : %u %u"
+ "OutInfo requestId %llu %llu frameCount %llu %llu"
+ "OutInfo[%llu] (%llu, %llu)(%llu, %llu) (%llu %u) {%u %u %u %u}"
+ "OutNoneSyncFrm"
+ "OutSyncFrm"
+ "OutTiledChroma: hdrC %p cmpC %p w %d h %d s %d\n"
+ "OutTiledLuma: hdrY %p cmpY %p w %d h %d s %d\n"
+ "OutWidth >= 2 && OutHeight >= 8"
+ "Out[%u] 0x%x (%llu, %llu)(%u %u) {%u %u %u %u}"
+ "Output Found %d sz %llu"
+ "Output gain %d exposure %.3f flash %.3f isSlowSync %d\n"
+ "OutputAFEProc"
+ "OutputANST"
+ "OutputAlgData"
+ "OutputBufferToAlgoCtrl"
+ "OutputBufferToFlow"
+ "OutputBuffers2AlgoServer"
+ "OutputCFLD"
+ "OutputCfgSet"
+ "OutputFrame"
+ "OutputPDAF"
+ "OutputPipe exists, passing buffers onwards!\n"
+ "OutputPreviewFrame"
+ "OutputSizeSet"
+ "OutputSizeSet %d %d"
+ "OutputSize[%lu]: %d"
+ "Over Retry Count"
+ "OverWrite torch %d Strobe %d"
+ "Override ispClock to ispClockOverride for some special case"
+ "Overriding NW BuildInfo Revision to 0x1 \n"
+ "Overwrite"
+ "Overwrite chain/mcache mode to %d:%d:%d (%d)"
+ "PCE already in Secure mode according to SECMODESTAT"
+ "PCE input bigger than PDEDebug section in host metadata"
+ "PCE is in secure mode according to SECMODESTAT"
+ "PCENotifyFidExit"
+ "PCESignalDMADone"
+ "PCESignalFIDExit"
+ "PCESignalFrontStereoPFT"
+ "PCESignalGMCDone"
+ "PCESignalGMCTimeout"
+ "PCESignalRearStereoTWPFT"
+ "PCESignalRearStereoWSWPPFT"
+ "PCESignalTriggerFlowSchedule"
+ "PDAF CmdProceesor  start! total delta receiving %.2f previous %8f us id %zu"
+ "PDAF to CAF pipe full, dropping disparity map output frame %d"
+ "PDAF::Rect::WithSize(PDAF::Vector2{this->_sensor.pDescr->sizeX, this->_sensor.pDescr->sizeY}) .containsRect(clipRectMax)"
+ "PDAFToAFEDataProcess"
+ "PDAFToMLAFDataProcess"
+ "PDCBypass"
+ "PDCSetup"
+ "PDE Replay GMSLoop: %f %f %f cfg %u"
+ "PDE input src[%d %d]dst[%d %d]"
+ "PDE-FrontStereo-Rotated-IR-%08x.raw"
+ "PDE-IR-%08x-PCECalib-RGB_IR.raw"
+ "PDEDone"
+ "PDESetup"
+ "PDMHWConfig"
+ "PDPBypass"
+ "PDx_VSEL_TARGET"
+ "PE_ANST_END"
+ "PE_ANST_POSTPROCESS_END"
+ "PE_ANST_POSTPROCESS_START"
+ "PE_ANST_PREPROCESS_END"
+ "PE_ANST_PREPROCESS_START"
+ "PE_ANST_START"
+ "PE_ATTR_END"
+ "PE_ATTR_POSTPROCESS_END"
+ "PE_ATTR_POSTPROCESS_START"
+ "PE_ATTR_PREPROCESS_END"
+ "PE_ATTR_PREPROCESS_START"
+ "PE_ATTR_START"
+ "PE_FRAME_DONE"
+ "PFL_gdc_min=%f, apsModelLinearB=%f, thickLensEFL=%f"
+ "PFlash pattern: LED_GROUPING_NTC_WIDE_MODE\n"
+ "PFlash: CP_MAX_PFLASH_CH_MA\n"
+ "PFlash: YETI_MAX_PFLASH_CH_MA\n"
+ "PIODMAList_Index != 0"
+ "PIODMAList_Index < PIODMAList_maxCount"
+ "PIODMA_CMD_SIZE_MAX_VALUE >= packetSize"
+ "PIODMA_CMD_SIZE_MAX_VALUE >= size"
+ "PMP Bandwith Control %s"
+ "PMP Clock Control %s"
+ "PMPControlSet"
+ "PMPFrequencyRequestControlSet"
+ "POPACK"
+ "POST CONDITION: "
+ "POWEROFF"
+ "POWERON"
+ "PPSM: %s change IR power save mode to %u"
+ "PPSM: %s: at %llu\n"
+ "PPSM: %s: at %llu next pwr st %d, time till wakeup %d, frameTime %u\n"
+ "PPSM: %s: timer expired, IR_POWER_STATE_LONG_STANDBY at %llu, start timer to %u msec\n"
+ "PPSM: %s: timer expired, IR_POWER_STATE_SHORT_STANDBY at %llu, start timer to %u msec\n"
+ "PPSM: %s: timer expired, IR_POWER_STATE_WAKEUP \n"
+ "PPSM: irPowerSaveModeEnable %u irPowerMode %u nextIrPowerState %u"
+ "PPSM: rvSyncTime %llu irPowerMode %u framerate %u mICState %u"
+ "PPSM: schedule a wakeup now (%u msec)"
+ "PPSM: wakeup sensor %d strobe %d at %llu"
+ "PRE CONDITION: "
+ "PRE(ExStats): ch%d: spdNotActive                   : %d \n"
+ "PRJ_ON_LOCK_AE"
+ "PRJ_ON_TIMEOUT"
+ "PROCDONE"
+ "PROCESSING"
+ "PROCESSING_DROP"
+ "PROCESSING_NEXT_READY"
+ "PROCESS_NEXT"
+ "PROJECTOR_ON"
+ "PROJECTOR_ON_DONE"
+ "PVDD_OIS: 0x%x, PVDD_AF: 0x%x\n"
+ "PW: %.3fms"
+ "PW: Frame[%d] Failure in running PW!\n"
+ "PW: GP WarpingStat time = %f ms, Frame[%d]!\n"
+ "PW: PW debug -- noRpc available!\n"
+ "PW: PW setup & process time = %f ms!\n"
+ "PW: PatchWarp Operate: %fms"
+ "PW: PatchWarp:  start operation"
+ "PW: SumAbsDiff time = %f ms!\n"
+ "PW: SumAbsDiff_EstHomography Frame[%d] = %d!\n"
+ "PW: SumAbsDiff_GyroHomography Frame[%d] = %d!\n"
+ "PW: config dma"
+ "PW: fps = %d, ispDGGain = %d, Frame[%d]!\n"
+ "PW: nowGPStride = %d nowGPWidth = %d nowGPHeight = %d\n"
+ "PW: nowTx = %f %f %f %f %f %f %f %f %f\n"
+ "PW: numHor = %d, numVer = %d, oWH = %d %d, iWH = %d %d\n"
+ "PW: start hardware"
+ "PW: wait hardware"
+ "PYR: [%d %d %d %d] -> %dx%d\n"
+ "Pair is ready"
+ "ParamInit"
+ "ParseAndPrintEmbeddedData"
+ "ParseEmbeddedData"
+ "ParseExtBaseCalData"
+ "Patch update\n"
+ "PatchCoord.PatchConfig.Enable = %d"
+ "PatchCoord.PatchConfig.Height = %d"
+ "PatchCoord.PatchConfig.Width = %d"
+ "PatchCoord.PatchMemConfig.Offset = %d"
+ "PatchCoord.PatchNumConfig.NumPatch = %d"
+ "PatchWarper.PW_Config.Bypass = %d"
+ "PatchWarper.PW_Config.CompMode = %d"
+ "PatchWarper.PW_Config.GlobalMotionEn = %d"
+ "PatchWarper.PW_Config.InputPixType = %d"
+ "PatchWarper.PW_Config.NumPatch = %d"
+ "PatchWarper.PW_Config.RotationFlip = %d"
+ "PatchWarper.PW_Size.iHeight = %d"
+ "PatchWarper.PW_Size.iWidth = %d"
+ "PatchWarper.PW_Size.oHeight = %d"
+ "PatchWarper.PW_Size.oWidth = %d"
+ "PatchWarper.StitchConfig.En = %d"
+ "PatchWarper.StitchConfig.NumHorPatches = %d"
+ "Pattern array size Torch %d FLight %d MFlash %d PFlash %d\n"
+ "Pdaf CmdProceesor done: %.2f us id %zu"
+ "Pearl SUR: security status unwrap: %s\n"
+ "Pearl SUR: security status unwrap: 0x%x\n"
+ "Pearl notification calling WriteMessage()\n"
+ "PearlCntl Meta(%d): vld %d - %x, %x, %x, {%d, %d, %d, %d, %d}, %x, %d\n"
+ "PearlCtrlUpdate (%d): %d vs %d %d\n"
+ "PearlFPDNotifySafety failed"
+ "PearlGMCProcessResultsIrProjector"
+ "PearlGMCRPCDone"
+ "PearlGMCRPCDone didn't receive it's self object"
+ "PearlGetLastFace"
+ "PearlGetLsbConfig"
+ "PearlIrPrincipalPointTempAdjust"
+ "PearlSetSmartRef LZ4 Error=%d! (DT=%d IDX=%d %f Size=%d)"
+ "PearlSetSmartRef size too small (%d %lu)!"
+ "PearlSetSmartRef unknown sep header! (%llu)!"
+ "PearlState %x\n"
+ "PeekStatsModeBasedOnManualMode"
+ "People mask copy is done but failed to retrieve FD buffer out of the queue"
+ "People mask copy is done but failed to retrieve Src buffer out of the queue"
+ "People mask copy is done but failed to retrieve dst buffer out of the queue"
+ "PerModuleGICGet"
+ "Percent current update. maxMainflashCurrentRatio: 0x%08x"
+ "PerfMonitorTask"
+ "Performance"
+ "Peridot"
+ "Peridot failed to train link"
+ "Peridot retry is not supported for mode: %d"
+ "PeridotLockPLL"
+ "PeridotProcessNewFrame"
+ "PeridotSetInitVspad"
+ "PeridotSetTofCalData"
+ "Pic Input is %p stride %zu size %zu height %zu"
+ "PicWarpTileProcess"
+ "Pick ch %u Fr %u (ch#InSync %u s %llu)"
+ "Pick frame based exposureTime %u. ch %u Fr %u (ch#InSync %u s %llu)"
+ "PickBestTimeMachineFrame"
+ "PiningThreadsTotal: "
+ "PioDmaRstDone"
+ "PipeAuxToLc%zu"
+ "PipeDone for FC:%d done:%d %f"
+ "PipeLcToAux%zu"
+ "PipelineDutyCyclControlInit"
+ "PipelineFrequencySet"
+ "Platform ID: %u"
+ "Please add macro for the following buffersCount %lu"
+ "PoolID %zu cnt %d align %zu sz %zu rowAlign %zu"
+ "PoolID %zu cnt %d align %zu sz %zu rowAlign %zu cmp %d datablocks %d"
+ "PopSyncBufferQ"
+ "PopulateExposureValuesForConstraintsTestMode"
+ "PopulateIRSensorConfigParams"
+ "Position\n"
+ "PostAWBStatsHelper"
+ "PostAuxThreadPacket"
+ "PostBuffers"
+ "PostCallback"
+ "PostCmdSynchronous"
+ "PostExposureControlProcess"
+ "PostInit"
+ "PostProcess distance differs: %f ref %f\n"
+ "PostProcess status differs: %d ref %d\n"
+ "PostProcessor"
+ "PostedGP"
+ "Posting TM_MULTICAP_REQ fc %d %p frameType %d\n"
+ "Posting to AE virtualCh %zu"
+ "PowerControl2"
+ "PowerControlGet: Domain: %d status %s"
+ "PowerControlSet: Base %p index %d : 0x%x using %fms"
+ "PowerControlSet: Pre-set status: 0x%x, Target %s"
+ "PowerOff"
+ "PowerOffSection"
+ "PowerOn"
+ "PreGain %hu %hu %hu %hu"
+ "PreInputProcRegResz"
+ "PreOneFrmDone"
+ "PreProcessor"
+ "PreW %d PreH %d"
+ "PreX %d PreY %d"
+ "Preapre to Process %zu"
+ "Preboot"
+ "Preboot end"
+ "Preboot start"
+ "Preflash Override (per driver), cool: %.1f mA, warm: %.1f mA"
+ "Preflash Override, coolreg: 0x%x, warmreg: 0x%x"
+ "Preflash.fLux=%.1f >=? LEDOff.fLux=%.1f"
+ "Prepare"
+ "Prepare DesGen resource sharedMem size %d"
+ "Prepare to return"
+ "PrepareBuffers"
+ "PrepareCameraStart"
+ "PrepareCfg"
+ "PrepareConfig"
+ "PrepareDestinations"
+ "PrepareDmaAfeProc"
+ "PrepareDmaAuxPyrProc"
+ "PrepareDmaBayerProc"
+ "PrepareDmaBesProc"
+ "PrepareDmaCVPipe"
+ "PrepareDmaClrProc"
+ "PrepareDmaHueMap"
+ "PrepareDmaMsProc"
+ "PrepareDmaPyrOutProc0"
+ "PrepareDmaPyrOutProc1"
+ "PrepareDmaRaw2Yuv"
+ "PrepareDmaRsclProc"
+ "PrepareDmaSif2BesBitPerfect"
+ "PrepareDmaStats"
+ "PrepareDmaVisProc"
+ "PrepareDmaYuv2Yuv"
+ "PrepareDmaYuvReplay"
+ "PrepareForExecute"
+ "PrepareForExecuteFIDFD"
+ "PrepareForExecuteNormal"
+ "PrepareForExecute_FirstPass"
+ "PrepareForExecute_SecondPass"
+ "PrepareFrame"
+ "PrepareHW"
+ "PrepareHW_SecondPass"
+ "PrepareIspEngJob"
+ "PrepareStatPipe"
+ "PrepareStaticDPCBuffer"
+ "PrepareStop"
+ "PrepareZoomForFirstFrame"
+ "PreprocessFEPThumbnail"
+ "Preview channel: %hhu"
+ "Preview in still case, new input raw size w %u h %u"
+ "Pri adjusted exp %llu gA:%u gD:%u"
+ "Pri adjusted exp %llu gLin %d"
+ "Primary Frame Skipping Ratio only works in non-sync mode"
+ "PrintAllRTBWR"
+ "PrintDebugInfo"
+ "PrintInfo"
+ "PrintLatencyDB"
+ "PrintOTPStatus"
+ "PrintRoutingTable"
+ "PrintSensorData"
+ "PrintSensorDataInfo"
+ "Proc ch:%zu frameCnt:%u FSCL data\n"
+ "Proc ch:%zu frameCnt:%u HPP data\n"
+ "Proc ch:%zu frameCnt:%u MBNR data\n"
+ "Proc ch:%zu frameCnt:%u PDC data\n"
+ "ProcDone"
+ "ProcInputData"
+ "ProcInputStat"
+ "ProcPipeDone"
+ "ProcWinUpdate"
+ "Process Global Op %d"
+ "Process Stopped after Sensor is stopped"
+ "ProcessADRCHighlightsTemporalFilter"
+ "ProcessADRCShadowsTemporalFilter"
+ "ProcessAE"
+ "ProcessAEStrobeCommand"
+ "ProcessAWBFDInput"
+ "ProcessBuffer"
+ "ProcessBuffersFromAlgoServer"
+ "ProcessCompleted"
+ "ProcessCompletedToNext"
+ "ProcessControlData"
+ "ProcessDeferRawBufAllocation"
+ "ProcessDesiredFPS"
+ "ProcessEndpointCmd"
+ "ProcessFESSizeCommand"
+ "ProcessFVSync"
+ "ProcessFocusNow"
+ "ProcessIspEngJobDone"
+ "ProcessLTMFDInput"
+ "ProcessLTMFDInput:fn=%d ch=%d otf=%d"
+ "ProcessManualAE"
+ "ProcessMatchSlaveAWB"
+ "ProcessMatchingLegacyBracketing"
+ "ProcessMatchingSlaveCameraAWBParam"
+ "ProcessMetadata"
+ "ProcessMotionData"
+ "ProcessMulitCamZoomCommand"
+ "ProcessMultiSyncSlaveFrameDone"
+ "ProcessMultiSyncSrcDone"
+ "ProcessMultiUnifiedBracketingCommand"
+ "ProcessNVStorage"
+ "ProcessPearlData"
+ "ProcessPerFrameRequest"
+ "ProcessPreflash"
+ "ProcessReset"
+ "ProcessResults"
+ "ProcessSchemeManualWB"
+ "ProcessSemanticVideoServiceUpdate"
+ "ProcessSifr"
+ "ProcessSifrPipeDone"
+ "ProcessStart"
+ "ProcessStatFrame"
+ "ProcessStreamingMode"
+ "ProcessZoomCommand"
+ "Processing FD ch %zu, pipe %u w %u h %u\n"
+ "Processing Global Op %d offset %d\n"
+ "Processing Global Op %d primitiveId %d\n"
+ "Processing Local Op %d offset %d\n"
+ "Processing ch %zu\n"
+ "ProduceRegisters"
+ "ProfilingTask"
+ "Program BES to Streaming mode\n"
+ "Program BES to Tile mode\n"
+ "Program register section %d of HW Bank %d @ %llu\n"
+ "ProgramSifAndFepDMA"
+ "ProgramSifAndFepDMAForSplitSIFRFrame"
+ "Programmed registers using PIO DMA @  %llu"
+ "Programming Sensor for Ch:%zu (%s) with Init Settings Done @%f"
+ "ProjectFlashWP"
+ "ProjectorIsFiring"
+ "ProjectorTemperatureReadGet"
+ "PropertyRead"
+ "Provisioned, skip to boot done: %016llx\n"
+ "PublicKeyExchange end"
+ "PublicKeyExchange start"
+ "PublicKeyExg %d %d\n"
+ "PublicKeyExg %d %d %016llx\n"
+ "PublicKeyGet"
+ "PublicKeySet"
+ "PulseConfigured"
+ "PutFrameInTimeMachine"
+ "PwrCtrlSrvcDone"
+ "PwrSplyRstDone"
+ "PyrOutProcDmaDstA1 should enable compression!"
+ "PyrOutProcDmaDstB1 should enable compression!"
+ "PyrOutProcDmaDstChromaB1 should enable compression!"
+ "Pyr[%d] w:%d h:%d s (%d %d)"
+ "Pyramid height increases!"
+ "Pyramid offset invalid!"
+ "Pyramid width increases!"
+ "QJob"
+ "QUARK (Addr=0x%x%x) BOTTOM=0x%x%x"
+ "Q_ControllerBootstrap"
+ "QsumV2H2_temp_shared"
+ "Quark isn't ready for start %llu, %u"
+ "Quark ready after %u * 2 ms"
+ "Quark: Settimg VPOS to %f."
+ "QuarkDumpTxModeConfig"
+ "QuarkSetTxModeConfig"
+ "QueryBootStatus"
+ "QuickStandbyEnter"
+ "RANSAC_ESTIMATION_START"
+ "RAWCH0_CH1"
+ "RAWCH0_STANDBYCH1"
+ "RAWCH1_CH0"
+ "RAWCH1_STANDBYCH0"
+ "RAW_CH0"
+ "RAW_CH1"
+ "RAW_DUAL"
+ "RDOffset computed %d minRD %d sifrSkip %d sifrPrep %d"
+ "READY"
+ "REF attr result:"
+ "REGISTER_BANK_A"
+ "REGISTER_BANK_B"
+ "REPLAY_COMPLETED"
+ "REPLAY_EXIT"
+ "REPLAY_IDLE"
+ "REPLAY_IN_PROGRESS"
+ "REPLAY_PENDING"
+ "REPLAY_REQUEST"
+ "RFC: FINAL MATRIX:"
+ "RG -  CTX A : delay %duS, iout1 %duA, iout2 %duA, repeat %d\n\n"
+ "RG - SetContext %d %d %x %x\n"
+ "RGB"
+ "RGB file not found"
+ "RGB size is good (%zu)"
+ "RGBHistProcess"
+ "RIGEL -  CTX A : delay %duS, iout0 %duA, iout1 %duA, iout2 %duA, repeat %d\n\n"
+ "RIGEL - SetContext %d %d %x %x\n"
+ "RIGEL enabled.\n"
+ "RMASize >= splitPDMetadata->totalSize"
+ "RNFSetup"
+ "ROI Add ch %d index %d"
+ "ROI not found matching {traceRoiType=%d, scale=%d}."
+ "ROI/ANFD[%d]:%s:%d: masterCamCh=%zu, curCh=%d => fdCh=%zu\n"
+ "ROI: fr %d num %d <no frontal faces>"
+ "ROI: fr %d num %d Face[%d] (%.3f %.3f %.3f %.3f)"
+ "ROUND_DOWN(paddr, CMMU::CacheLineSize()) == paddr"
+ "ROUND_UP(pOutConfig->width, 8) <= texWidth && ROUND_UP(pOutConfig->height, 4) <= texHeight"
+ "ROUND_UP(width, 64) <= stride"
+ "RPC not ready"
+ "RSCLPreScaleOut:zero %u inWidth %u inHeight %u dmaFmt %u packType %u addr %p"
+ "RTK_ST_OK == ret"
+ "RTK_queue_count(queue) == tot"
+ "RUN_CH0"
+ "RUN_CH0_DMA"
+ "RUN_CH1"
+ "RUN_CH1_DMA"
+ "RUN_DUAL"
+ "RVC: XY %d %d"
+ "RVDone"
+ "RVSYNC"
+ "Raw buf done! total %.2f ms"
+ "RawBufferRequest"
+ "RawDMASrc not suppoted for ch %d"
+ "RawFmt %d PixFmt %d packType %d"
+ "RawImageProcess"
+ "RawReprocessConfigurationUpdate"
+ "RawReprocessEnable"
+ "RawScaleGet"
+ "RcvdPDE"
+ "Read from 0x%x : 0x%x, len %d ret: 0x%x\n"
+ "Read metadata from HW"
+ "ReadAllEmittersStatus"
+ "ReadAllResultFromHW"
+ "ReadCmpnRtrValue"
+ "ReadDvcTargetVoltage"
+ "ReadDvcVselTarget, gpio: %u, addr: 0x%04x, data: 0x%02x(mV: %f mV)\n"
+ "ReadMessage"
+ "ReadNoTableRegValue"
+ "ReadOutEndOffsetGet"
+ "ReadOutSizeSet"
+ "ReadRegValue"
+ "ReadResultFromHW"
+ "Reading Aries eph public key...\n"
+ "Reading rx dpcd at addr (0x%05x) 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n "
+ "RealChannelCreate"
+ "Reallot %d ch %d AFE %d Mode %d"
+ "RearStereoGenerateRearPceCalib"
+ "RearStereoUpdateCalibSummary"
+ "RearStereoUpdateRearPceCalib"
+ "RearStereoUpdateRearPceCalibWithGMSResults"
+ "RecAFBuf"
+ "RecMEBuf"
+ "RecVNRBuf"
+ "Recalculating TileInt [%d %d %d %d] [%d %d] newInt[%d %d] oldInt[%d %d]"
+ "Receive confidenceMap %p ch %zu SemanticCh %zu frameCnt %u"
+ "Received AWB Data for frame%d,syncTag%d,StatsSlaveCam%d,reflow%d,bUsingSingle%d\n"
+ "Received GPGP : operation 0x%llx %p paraBuf %p\n"
+ "Received GPGP command from Driver @ %d %p %p\n"
+ "Received GPGP command from Driver @ %f\n"
+ "Received MotionDataRate from AOP: %u / SeqNum: %u\n"
+ "Received Signal %p\n"
+ "Received SrcDone 0x%x, but pending for 0x%x"
+ "Received an interrupt source %d, irq 0x%x @ %llu"
+ "Received ch=%ld,frame=%d,still=%d,prevMs=%d,statMS=%d,syncTag=%d,chInSync=%d"
+ "Received more depth spots (%d) than allowed for this device (%d).\n"
+ "Receives frame %u from SemanticAWB"
+ "Receives frame %u from SemanticAWB ColorHist2D ch %zu"
+ "Receives frame %u from SemanticAWB ch=%zu "
+ "ReconfigurePCE"
+ "RecordAbortStatus"
+ "RecordArmErrorExpected"
+ "RecordFvSyncIsr"
+ "RecordRvSyncIsr"
+ "RecordSkipStats"
+ "RecordSrcDoneIsr"
+ "RecordSrcGo"
+ "RecordStandbyMode"
+ "RecordStatsTrigIrq"
+ "RectSetup"
+ "ReduceADRCBiasForSIFRTurnOff"
+ "Ref: id %d attn %d g %d %.5f %.5f"
+ "RegAccess"
+ "RegToCurrent"
+ "Register"
+ "RegisterBankSelect"
+ "RegisterByIndex"
+ "RegisterDeferRawBufAllocation"
+ "RegisterToCurrents"
+ "RegisterToNormalizedLuminance"
+ "Registration 3"
+ "Regulus %d\n"
+ "Regulus DevState I2C read failed.\n"
+ "Regulus INT masks 0x%x 0x%x 0x%x : 0x%x 0x%x 0x%x 0x%x 0x%x\n"
+ "Regulus PowerOff"
+ "Regulus PowerOn"
+ "Regulus RegRead %d bytes, 0x%x = 0x%x\n"
+ "Regulus RegWrite - %02x, %02x @%llu\n"
+ "Regulus Standby %d @ %llu\n"
+ "Regulus enabled.\n"
+ "Regulus ver VOTP 0x%x UOTP 0x%x\n"
+ "RelAFBuf"
+ "RelBuf"
+ "RelMLAFFFCBuf"
+ "RelMLAFTeleBuf"
+ "Release"
+ "Release MCache for streamid %u\n"
+ "Release MCache for streamid %u due to Request / Update failed\n"
+ "Release and reallocate FEP Buf pool %zu vhdr %d"
+ "ReleaseAllBuf"
+ "ReleaseAllPartialflows"
+ "ReleaseAndDropMainAndSifrBuffer"
+ "ReleaseAuxsclPYRBuffers"
+ "ReleaseBufForFEP"
+ "ReleaseBufForIR"
+ "ReleaseBufForSideBand0"
+ "ReleaseBufForSideBand1"
+ "ReleaseBufferInQueue"
+ "ReleaseBuffers2Algo"
+ "ReleaseDPCBuffers"
+ "ReleaseFlows"
+ "ReleaseFusionRegistrationBuffers"
+ "ReleaseInputSrcDma"
+ "ReleaseLSCBuffers"
+ "ReleaseMBNRBuffers"
+ "ReleaseOneFrame"
+ "ReleaseSemanticVideoBuffers"
+ "ReleaseSrcDMAIn"
+ "ReleaseTileBuffers"
+ "ReleaseVCPipeline"
+ "Releasing index %d resource"
+ "Remap :  handle 0x%x : base %p : len 0x%lx\n"
+ "Replace captured frames %u with new %u"
+ "ReplaceAWBwithOneFrame"
+ "Replay Frame Trigger for the first frame copy HostMetaData"
+ "Replay GMSLoop: PPXOffset=%f,PPYOffset=%f,PFLScale=%f,configID=%d"
+ "Replay process New Command loopback %u %zu count %zu"
+ "Replay: ch %zu Input DMA Src sifDMASrcIndex %d"
+ "ReplayFrameMetaInputSetup"
+ "ReplayFrameTrigger"
+ "ReplayGetDMAInputIndex"
+ "ReplayHostMetaDataConvert"
+ "ReplayInputDMASetup"
+ "ReplayStart"
+ "ReplayStop"
+ "ReportROI"
+ "Reported Adjusted ISP FE/BE freq: %s, %d MHz to PMP"
+ "ReqPool: Available %lu Outstanding %zu"
+ "Req[%d] is NULL pointer!"
+ "Req[%d]: %d, %d, %lu, %d, %d"
+ "Req[%d]: %d, %d, %lu, %d, %d, %d"
+ "Req[%u] 0x%x (%llu, %llu)(%u %u) {%u %u %u %u}"
+ "Request MCache size 0x%x for streamid %u\n"
+ "RequestAuxsclPYRBuffers"
+ "RequestClrBeTileBuffers"
+ "RequestDescriptorReset"
+ "RequestFusionRegistrationBuffers"
+ "RequestInputSrcDma"
+ "RequestM2mGdcTileBuffers"
+ "RequestMBNRBuffers"
+ "RequestMLAFBuffers"
+ "RequestOutputBuffer"
+ "RequestSemanticVideoBuffers"
+ "RequestTileBuffers"
+ "Requested %d MHz to PMP with dither period %d us"
+ "Requested %s (%dMHz) to PMP"
+ "ResOut"
+ "ReserveFEP2ndIndex"
+ "ReserveFEPIndex"
+ "ReserveSrcDMAIn"
+ "ReserveVCPipeline"
+ "ResetDMAEnableState"
+ "ResetSection"
+ "Resize2"
+ "ResizeTMDepthOnHiresStreaming"
+ "ResolveBufferRetainForArmErrorForSifr"
+ "ResolveRefCountAndReturnCorrectBuffer"
+ "Resort TS Meta from master. isLocked = %d, previous WP = (%f, %f)"
+ "Response"
+ "Restore 2: ch=%d bkt=%d, ev0=%.2fms,%.2f,%.2f sifr=%.2fms,%.2f(%d,%d) req=%X vFrm=%d, %d\n"
+ "Restore: ch=%d bkt=%d, ev0=%.2fms,%.2f,%.2f sifr=%.2fms,%.2f(%d,%d) req=%X vFrm=%d, %d\n"
+ "RestoreDefaultTripodParams"
+ "RestoreFusionOffConfig"
+ "RestoreSharedAWBParamsMF"
+ "RestoreTunables"
+ "Results meta data"
+ "Resume"
+ "ResumeDone"
+ "Retain Buffer Posting TM_MULTICAP_REQ fc %d\n"
+ "Retain primary face (ID=%u area=%f) even though it is smaller than (ID=%u area=%f)\n"
+ "Retaining Buf fc:%llu Type: %d "
+ "Return buffer from poolID %d grp %d, chMask %x, type %d"
+ "ReturnBufForFEP"
+ "ReturnHWSecBank"
+ "ReturnHWSections"
+ "RevdBuf"
+ "RevdBufSalve"
+ "RevdDepth"
+ "RevdIR"
+ "Rigel %d\n"
+ "Rigel DevState I2C read failed.\n"
+ "Rigel PowerOff"
+ "Rigel PowerOn"
+ "Rigel RegRead %d bytes, 0x%x = 0x%x\n"
+ "Rigel RegWrite - %02x, %02x @%llu\n"
+ "Rigel Standby %d\n"
+ "Rigle PCNT - %d %d %d\n"
+ "RodataAddr %p RodataSize %zu"
+ "RodataAddr %p RodataSize %zu\n"
+ "RoutingConfig"
+ "RsclProcSetup"
+ "RstParamsDone"
+ "RunDesMatchHomographyEst"
+ "RunGyroHomographyEst"
+ "RunLaccMatch"
+ "RunMotionEstimation"
+ "RunNccMatchHomographyEst"
+ "RunPatchWarp"
+ "RunVisPipe"
+ "S%s:DD RV %f FV %f dma %f fc %d"
+ "S2R_WAIT_HW"
+ "SBMSetup"
+ "SBMSetupDone"
+ "SBMSetupStart"
+ "SCBESWARPCMD_MAXIMUM_NBR >= (pPicTileInfo->tileCount & 0xFF)"
+ "SDI: Depth Version: %u\n"
+ "SDI: FrameArrival\n"
+ "SDI: FrameArrival idx: %u\n"
+ "SDI: FrameArrival[%u] frameId %u\n"
+ "SDI: FrameArrival[%u] frameMsgSkip %u\n"
+ "SDI: FrameArrival[%u] frameMsgTriggerId %llu\n"
+ "SDI: FrameArrival[%u] frameTimestamp %llu\n"
+ "SDI: FrameRate\n"
+ "SDI: InitSensorData\n"
+ "SDI: Peridot Data\n"
+ "SDI: PeridotFrame\n"
+ "SDI: PeridotFrame idx: %u\n"
+ "SDI: PeridotFrame sec idx: %u\n"
+ "SDI: PeridotStates\n"
+ "SDI: PeridotStates idx: %u\n"
+ "SDI: PeridotStates secidx: %u\n"
+ "SDI: PeridotStates thirdIdx: %u\n"
+ "SDI: PeridotVBD\n"
+ "SDI: PowerSave\n"
+ "SDI: PowerSave idx: %u\n"
+ "SDI: PowerSave powerSaveModeBm: %u\n"
+ "SDI: PowerSave sec idx: %u\n"
+ "SDI: PowerSave wakeupErrorCount: %u\n"
+ "SDI: PowerSave wakeupErrorTimestamp: %llu\n"
+ "SDI: PowerSave wakeupSuccessCount: %u\n"
+ "SDI: PowerSave[%u] powerSaveState %u\n"
+ "SDI: PowerSave[%u] powerSaveStateTimestamp %llu\n"
+ "SDI: PowerSave[%u] timeTillWakeup %u\n"
+ "SDI: PowerSave[%u] wakeUpCheckBm 0x%x\n"
+ "SDI: PowerSave[%u] wakeUpTimestamp %llu\n"
+ "SDI: ReceivedCommands\n"
+ "SDI: ReceivedCommands idx: %u\n"
+ "SDI: ReceivedCommands[%u] receivedCommandParam1 %u\n"
+ "SDI: ReceivedCommands[%u] receivedCommandParam2 %u\n"
+ "SDI: ReceivedCommands[%u] receivedCommandTimeStamp %llu\n"
+ "SDI: ReceivedCommands[%u] receivedCommandType %u\n"
+ "SDI: Streaming\n"
+ "SDI: Streaming idx: %u\n"
+ "SDI: Streaming[%u] isStreaming %u\n"
+ "SDI: Streaming[%u] isStreamingTimestamp %llu\n"
+ "SDI: TOF Data\n"
+ "SDI: TofFrame\n"
+ "SDI: TofMetadata\n"
+ "SDI: TofMetadata hwFaults: %u\n"
+ "SDI: TofMetadata idx: %u\n"
+ "SDI: TofMetadata laserIntensity: %u\n"
+ "SDI: TofMetadata metadataMismatchCount: %u\n"
+ "SDI: TofMetadata tbcnum: %u\n"
+ "SDI: TofMetadata vspad: %u\n"
+ "SDI: TofMetadata[%u] metadataMismatchTimestamp %llu\n"
+ "SDI: Version: %u\n"
+ "SDI: currFrameRateMsgActionId: %llu\n"
+ "SDI: currentFrameRate: %u\n"
+ "SDI: lastFrameRate: %u\n"
+ "SDI: lastFrameRateMsgActionId: %llu\n"
+ "SDI: nextFrameRate: %u\n"
+ "SDI: nextFrameRateMsgActionId: %llu\n"
+ "SDI: peridotFrame[%u] bnkcfgid %u \n"
+ "SDI: peridotFrame[%u] frameIdxSuperframe %u \n"
+ "SDI: peridotFrame[%u] frameIdxTbcSequence %u \n"
+ "SDI: peridotFrame[%u] framesInSuperframe %u \n"
+ "SDI: peridotFrame[%u] framesInTbcSequence %u \n"
+ "SDI: peridotFrame[%u] numOfTempReadings %u \n"
+ "SDI: peridotFrame[%u] pricfgid %u \n"
+ "SDI: peridotFrame[%u] txbankid %u \n"
+ "SDI: peridotStates cfgUpdateId %u \n"
+ "SDI: peridotStates fsyncMode %u \n"
+ "SDI: peridotStates tbclpm %u \n"
+ "SDI: peridotStates[%u] sensorControlState %u \n"
+ "SDI: peridotStates[%u] sensorControlStateTimestamps %llu \n"
+ "SDI: peridotStates[%u] tbcRecoveryState %u \n"
+ "SDI: peridotStates[%u] tbcRecoveryStateTimestamps %llu \n"
+ "SDI: peridotStates[%u] updateConfigState %u \n"
+ "SDI: peridotStates[%u] updateConfigStateTimestamps %llu \n"
+ "SDI: peridotVbd[%u] vbdCoeffs %f \n"
+ "SDI: sensorDataInfoPeridot.peridotFrame.bufferSize     = %u \n"
+ "SDI: sensorDataInfoPeridot.peridotFrame.idx            = %u \n"
+ "SDI: sensorDataInfoPeridot.peridotFrame.secBufferSize  = %u \n"
+ "SDI: sensorDataInfoPeridot.peridotFrame.secIdx         = %u \n"
+ "SDI: sensorDataInfoPeridot.peridotStates.bufferSize    = %u \n"
+ "SDI: sensorDataInfoPeridot.peridotStates.idx           = %u \n"
+ "SDI: sensorDataInfoPeridot.peridotStates.secBufferSize = %u \n"
+ "SDI: sensorDataInfoPeridot.peridotStates.secIdx        = %u \n"
+ "SDI: tofFrame actualFrameRate %f \n"
+ "SDI: tofFrame idx: %u\n"
+ "SDI: tofFrame[%u] dmaCompleteLowPTimestamp %llu (%llu)\n"
+ "SDI: tofFrame[%u] dmaCompleteTimestamp     %llu (%llu)\n"
+ "SDI: tofFrame[%u] dmaStartTimestamp        %llu (0)\n"
+ "SDI: tofFrame[%u] superFrameInTBC %u\n"
+ "SECRET"
+ "SECRET_CAPTURE_DONE"
+ "SECRET_PENDING"
+ "SECURITY STATUS: 0x%x\n"
+ "SENSOR_ORIENTATION_VALID(m_orientation)"
+ "SIF %d, numSifQ %d factor %u latency %f %f < %d"
+ "SIF DMA HW BWR bank: %s"
+ "SIF DMA compressed output: ch=%zu, framecount=%u, cmpSizeSif=0x%x\n"
+ "SIF DMA compressed output: framecount=%u, cmpSizeSif=0x%x\n"
+ "SIF DMA reg [%d %d %d %d] fep DMA reg [%d %d %d %d]"
+ "SIF use bank %s"
+ "SIFDMAModeDoubleBankingGo"
+ "SIFGO"
+ "SIFQueueConfig"
+ "SIFQueueConfig: ch=%d sifqs %d"
+ "SIFQueueConfig: ch=%d, sidebandQ[%d]= %d"
+ "SIFQueueGet"
+ "SIFQueueGet id%d: que %llx\n"
+ "SIFQueueObtain"
+ "SIFQueueObtain: id %u num %u sifQueueUsed %u\n"
+ "SIFQueueObtain: numSifQCh[%d] %d \n"
+ "SIFQueueReserve"
+ "SIFRBinFactorFullBinMode(%d) > 1 is not verified"
+ "SIGSEMA_ANST_PIODMA_DONE:mpFifoBufferQPeople entry:%zu"
+ "SIGSEMA_HAIR_MEMCPY_DONE:mpFifoBufferQHair entry:%zu"
+ "SIGSEMA_PEOPLE_MEMCPY_DONE:mpFifoBufferQPeople entry:%zu"
+ "SIGSEMA_SKIN_MEMCPY_DONE:mpFifoBufferQSkin entry:%zu"
+ "SIGSEMA_SKY_MEMCPY_DONE:mpFifoBufferQSky entry:%zu"
+ "SLAF FPS change request for %f denied, FPS override enabled."
+ "SLAF SUCCEEDED: slafMeta to pMeta at Fr %u!, slafFrameSteady = %d!"
+ "SLAF subsampling factor (%d) is less than 4!"
+ "SLAF: App requested both Depth and NormDx while SLAF is enabled"
+ "SLAF: Failed to send msg to SLAF Depth"
+ "SLAF: Failed to send msg to SLAF Mote"
+ "SLAF: previewMasterFOVInRaw.x is negative"
+ "SLAF: previewMasterFOVInRaw.y is negative"
+ "SLAF=%d, ANST=%d, |SLAF-ANST|=%d, 10pctANST=%d"
+ "SLAFBufferProcessorImp"
+ "SLAFNetProcess"
+ "SLinMemAccess"
+ "SMBRstDone"
+ "SMG Q Full!"
+ "SNGet Done TS %f\n"
+ "SNGet entering TS %f\n"
+ "SOFT BRICKED"
+ "SPD: CH%zu #%07d %s: extremeLowLightMode = %d, spdRunMode = %d, SPD_RUN_MODE_TOT=%d\n"
+ "SRCD"
+ "STANDBY"
+ "STANDBYCH0"
+ "STANDBYCH0_RUNCH1"
+ "STANDBYCH1"
+ "STANDBYCH1_RUNCH0"
+ "STANDBY_CH0"
+ "STANDBY_CH1"
+ "STANDBY_DUAL"
+ "START_ATTENTION"
+ "START_AUTHENTICATION"
+ "START_CH0"
+ "START_CH0_DMA"
+ "START_CH1"
+ "START_CH1_DMA"
+ "START_ENROLLMENT"
+ "START_RAW_CH0"
+ "START_RAW_CH1"
+ "STATE_AE_BRACKETING"
+ "STATE_AE_BRACKETING_OFF"
+ "STATE_AE_BRACKETING_RESTORE"
+ "STATE_AE_GOTO_STABLE"
+ "STATE_AE_IDLE"
+ "STATE_AE_MAINFLASH"
+ "STATE_AE_NORMAL"
+ "STATE_AE_PREFLASH1"
+ "STATE_AE_PREFLASH2"
+ "STATE_AE_REPEAT_SEQUENCE"
+ "STATE_AE_SUSPEND1"
+ "STATE_AE_SUSPEND2"
+ "STATE_AWB_BRACKETING"
+ "STATE_AWB_IDLE"
+ "STATE_AWB_MAINFLASH"
+ "STATE_AWB_NORMAL"
+ "STATE_AWB_PREFLASH1"
+ "STATE_AWB_PREFLASH2"
+ "STATE_AWB_SUSPEND1"
+ "STATE_AWB_SUSPEND2"
+ "STATE_IDLE"
+ "STATE_IDLE == CFSM::Instance()->Get(pChInfo->hFSM)"
+ "STATE_OFF"
+ "STATE_READY"
+ "STATE_RUN"
+ "STATE_STOPPING"
+ "STAT_COLLECTED"
+ "STAT_COLLECTED_AE"
+ "STAT_COLLECTED_AF"
+ "STAT_COLLECTED_AWB"
+ "STAT_COLLECTED_HR"
+ "STAT_COLLECTED_LTM"
+ "STAT_COMPLETED"
+ "STF LACC Prepare: %fms, Operate: %fms"
+ "STF LACC bVioOccupied = %u"
+ "STF LACC:  start operation"
+ "STF bootstrap: sending no-op STF coefficients."
+ "STF coeff for ch=%zu fr=%u: %.3f, %.3f, %.3f"
+ "STF descriptor buffer programming completed correctly."
+ "STF using ispcpu bLaccEnable %u bVioOccupied %u\n"
+ "STF-MTH: "
+ "STFSetup"
+ "STOPPED"
+ "STOPPING"
+ "STOPPING_NEXT"
+ "STOPPING_WAIT_NEXT"
+ "STOP_CH0"
+ "STOP_CH1"
+ "STOP_RAW_CH0"
+ "STOP_RAW_CH1"
+ "STRB key V3 data: %.2f, %.2f, %.2f, %.2f, %.2f, %.2f"
+ "STRB key calibration R/G=%f B/G=%f"
+ "STRB: CW=%5d %5d or %6.4f %6.4f WW=%5d %5d or %6.4f %6.4f"
+ "STRB: CW_RG = [%5d %5d], CW_BG=[%5d %5d], WW_RG=[%5d %5d] WW_BG=[%5d %5d]"
+ "STRB: RG range = [%5d %5d], BG range = [%5d %5d]"
+ "STRB: WIDE=%5d %5d or %6.4f %6.4f"
+ "STRB: WIDE=%5d %5d or %6.4f %6.4f SWIDE=%5d %5d or %6.4f %6.4f TELE=%5d %5d or %6.4f %6.4f"
+ "STRB: WIDE_MERCURY=%5d %5d, WIDE_VENUS=%5d %5d"
+ "STRB: version=%d programID=%d valid=%d specLimitCheck=%d checkSumValid=%d size=%d"
+ "STRB: version=%d valid=%d specLimitCheck=%d checkSumValid=%d size=%d"
+ "STRBkey version=%hhu, strb_rg=%.6f strb_bg=%.6f"
+ "STRBkey version=%hhu, ww_rg=%.6f ww_bg=%.6f cw_rg=%.6f cw_bg=%.6f"
+ "STREAM"
+ "STREAM_CMD_APPLY"
+ "STREAM_CMD_APPLY_NOW"
+ "STREAM_IDLE"
+ "STREAM_IDLE_DEFAULT"
+ "STREAM_INSTANDBY"
+ "STREAM_OFF"
+ "STREAM_PROCESSING"
+ "STREAM_RESET"
+ "STREAM_SETUP"
+ "STREAM_STANDBY"
+ "STREAM_START"
+ "STREAM_STOP"
+ "STREAM_TEARDOWN"
+ "STROBE_3A_SETTING_APPLIED"
+ "STROBE_AE_UPDATED"
+ "STROBE_AF_UPDATED"
+ "STROBE_AMBIENT_FRAME_DONE"
+ "STROBE_AWB_UPDATED"
+ "STROBE_CAPTURE_AMBIENT_FRAME"
+ "STROBE_CHARGING"
+ "STROBE_CONTEXT_SWITCH_DONE"
+ "STROBE_DELAY_DONE"
+ "STROBE_DO_PREFLASH2"
+ "STROBE_FRAMEDONE"
+ "STROBE_IDLE"
+ "STROBE_MAINFLASH_AE"
+ "STROBE_MAINFLASH_AE_DONE"
+ "STROBE_MAINFLASH_AWB"
+ "STROBE_MAINFLASH_DELAY"
+ "STROBE_MAINFLASH_W_AEUPDATE_SENT"
+ "STROBE_MAINFLASH_W_AE_DONE"
+ "STROBE_OFF"
+ "STROBE_OK2UPDATE"
+ "STROBE_PENDING_ON_CHARGING"
+ "STROBE_PREFLASH1"
+ "STROBE_PREFLASH2"
+ "STROBE_PREFLASH_DONE"
+ "STROBE_RESET"
+ "STROBE_RVSYNC"
+ "STROBE_START"
+ "STROBE_STOP"
+ "STROBE_W_3A_APPLED"
+ "STROBE_W_AMBIENT_FRAME"
+ "STROBE_W_CONTEXT_SWITCH_DONE"
+ "STROBE_W_FULLY_EXPOSED_FRAME_START"
+ "SUCC"
+ "SUCCESS"
+ "SUM"
+ "SUSPENDDone"
+ "SVC"
+ "SVCC1.0 CnvgCoef =%f, prevCoef=%f, AdjFactor=%f"
+ "SVCC1.0 Couldn't use the service CViSegDataService::Instance()"
+ "SVCC1.0 ResetButtonCounter=%d, CurrFrameResetButtonCounter=%d"
+ "SVCC1.0 UR =%f, UL=%f, LR=%f, LL=%f"
+ "SVCC1.0 backgroundSimilarityMeasure = %f"
+ "SVCC1.0 commonTileCounter = %d"
+ "SVCC1.0 corrCoefC1Hist = %f"
+ "SVCC1.0 corrCoefC2Hist = %f"
+ "SVCC1.0 corrCoefYHist = %f"
+ "SVCC1.0 curAvgSkinColorSampleNum = %f"
+ "SVCC1.0 curFrameRate = %f"
+ "SVCC1.0 localPersonBuf was empty"
+ "SVCC1.0 skinTileNumDiff = %f"
+ "SW FFOV GDC Sanity Check OK"
+ "SW OL GDC Sanity Check OK"
+ "SaliencyDisplay"
+ "Saliency[%d] <%d %d> %d %d %d %d %d"
+ "SamplingH == SamplingV"
+ "SaveBufferAsync"
+ "SaveBufferAsyncCb"
+ "SaveBufferToPathAsync"
+ "SaveBufferToPathAsyncOffset"
+ "SaveOutputFrame"
+ "SaveToFile"
+ "Saved reference ref/%s"
+ "Scaler %d (%d %d) --> (%d %d)"
+ "Scaler %d upscale more than 8x, (%d %d) -> (%d %d)"
+ "ScanWindowGetCurrent"
+ "ScanWindowSet"
+ "Schedule"
+ "Scratch buffer overrun!"
+ "SecureBootSeqSet"
+ "SecureModeEnter"
+ "SecureModeExit"
+ "SecureStreamingStart"
+ "Secured mode"
+ "SelectFrame is nullptr"
+ "SelectMIPIInterface"
+ "Selected knee[%d] ==> softGain %d"
+ "Selected knee[%d] ==> softGain (interp) %d"
+ "Selected knee[0] ==> softGain %d"
+ "Self"
+ "SemanticAWB: "
+ "SemanticAWB:  ch=%hhu fn=%d mS=%hhu mP=%hhu bSMAWB=%hhu FdV=%d cmdFdV=%d"
+ "SemanticAWB: ch=%d fn=%d semCh=%d semFn=%d fdAWBVer=%d "
+ "SemanticAWB: ch=%d fn=%d semCh=%zu semFn=%d fdAWBVer=%d "
+ "SemanticAWB: ch=%hhu fn=%u semCh=%zu semFn=%u fdAWBVer=%hhu"
+ "SemanticAWBColorHist2DProcess"
+ "SemanticMaskEnable"
+ "SemanticVideoSetup"
+ "Semantic_Tile = %hu, %f, %f, %f"
+ "SendBuf2Algo"
+ "SendBuf2Flow"
+ "SendBuf2SFlow"
+ "SendBufMsg"
+ "SendBuffersToDestination"
+ "SendCVDReq"
+ "SendDataToDestination"
+ "SendFrameBufferToStillFlow"
+ "SendHWReq"
+ "SendHith"
+ "SendI2CReadMsgToAOP"
+ "SendI2CWriteMsgToAOP"
+ "SendIspEngJobDoneAck"
+ "SendMLAFBuf"
+ "SendMLAFFFCBuf"
+ "SendMLAFTeleBuf"
+ "SendMTHSettingToAlgoCtrl"
+ "SendMsg : endPointId %d sapId 0x%x subPacket %p subPacketSize %d\n"
+ "SendOneFrInSyncGroup"
+ "SendOutput"
+ "SendPearlCmdToAOP"
+ "SendPearlCmdToAOP %d"
+ "SendPearlMsgToAOP"
+ "SendPearlMsgToAOP: %d, %d %d @%llu uS\n"
+ "SendPearlSignalToDoppler"
+ "SendPearlSignalToDoppler %d %d %d @ %llu\n"
+ "SendReq2FlowDone"
+ "SendReqToFlow"
+ "SendReqToStillFlow"
+ "SendSTFWeightMapToAlgoCtrl"
+ "SendToAF"
+ "SendToDestination"
+ "SendToDestinationCallback"
+ "SendToDestinationFD"
+ "SendToDestinationNormal"
+ "SendToDestinationSLAF"
+ "SendToMLAF"
+ "SendUserRequest"
+ "Sending afeproc ch %zu, pipe %d"
+ "Sending awb data to STF filter %zu"
+ "Sensor Distortion Calibration not avail for ch:%zu"
+ "Sensor Distortion Overlay Cal not avail ch:%zu"
+ "Sensor Powered off ch:%zu (%s)"
+ "Sensor TileWindow info for current config [%d %d %d %d]\n"
+ "Sensor not in SWStandby %d for ECDH\n"
+ "Sensor state: 0x%x\n"
+ "Sensor status: %d\n"
+ "SensorAnalogGainQuery"
+ "SensorCalBiasSet"
+ "SensorConfigUpdate"
+ "SensorDiscover"
+ "SensorHsOutputLevelSet"
+ "SensorID:0x%x GDC distortion available Pri:%d Sec:%d \n"
+ "SensorInterfaceGo"
+ "SensorInterfaceGo2"
+ "SensorInterfaceQChainSet"
+ "SensorInterfacesConfig"
+ "SensorMultipleBytesUpdateQueue"
+ "SensorNoiseModelGet"
+ "SensorPixelRegionGet"
+ "SensorSeqLoad"
+ "SensorTemperatureReadTrigger"
+ "SensorUpdateFps"
+ "Sent MotionDataRate to AOP. / SeqNum: %u\n"
+ "Sent2Ncc"
+ "SeqBytesRead"
+ "SeqRead"
+ "Sequence of %d\n \t0x%x 0x%x, 0x%x 0x%x, 0x%x 0x%x, 0x%x 0x%x, 0x%x 0x%x\n"
+ "Session Info- priorityCh= %d, currCh= %d, totalCh= %d"
+ "Session already active"
+ "SessionStatusGet"
+ "Set AMCC DSIS CLR REG BC PLANE: base=0x%llx, range=0x%x\n"
+ "Set AMCC DSIS CLR REG MULTI AMCC[%u] BC PLANE: numOfAMCC=%d, base=0x%llx, range=0x%x\n"
+ "Set AMCC DSIS CLR REG PLANE[%u]: base=0x%llx, range=0x%x\n"
+ "Set Ch:%zu EXTSYNC framerate in IC : %d"
+ "Set ISP Clock dither mode=0x%x, original mode=0x%x, freqInMHz=%d\n"
+ "Set RU Params failed. Maybe didn't set ruParams->inputFormat ?"
+ "Set ThumbMask DownScl [%d %d] Bbm:%d Gen:%d"
+ "Set confidenceMap %p ch SemanticCh %zu frameCnt %u"
+ "Set config type %d size %d addr %p\n"
+ "Set decimationVldLogCtrlis to %d (0: disable, 1: enable all, Other: check each bit)"
+ "Set endstop calibration method\n"
+ "Set new secure boot sequence\n"
+ "Set new secure boot sequence for Auth flow\n"
+ "Set paramters frameDecimation 0x%x responseThreshold %d dynamicThresholdCtrl %d\n"
+ "Set sensor test mode 0x%x"
+ "Set up input tiled Chroma\n"
+ "Set up input tiled Luma: dmaInFormat %d inPackType %d\n"
+ "Set up output LRME: dmaOutFormat %d outPackType %d\n"
+ "Set up output tiled Chroma\n"
+ "Set up output tiled Luma: dmaOutFormat %d outPackType %d\n"
+ "SetAESuspendState"
+ "SetAETuningPreset"
+ "SetAFSupported"
+ "SetAWBMetaData"
+ "SetBWROpMode"
+ "SetCARConfig"
+ "SetCCMDesatForSkinEnable"
+ "SetCalibPearl"
+ "SetComponentRegion"
+ "SetConfMap"
+ "SetConfig"
+ "SetConfigOverride"
+ "SetCurrentEITUpdateParam"
+ "SetData"
+ "SetDepthEntryData"
+ "SetDepthScaleCrop"
+ "SetDestBank"
+ "SetDvcPowerDeliveryIndex, gpio: %u, addr: 0x%x, data: 0x%08x\n"
+ "SetDvcTargetVoltage"
+ "SetExposureBias"
+ "SetExternalSync"
+ "SetFDAWBMetaData"
+ "SetFPNRConfig"
+ "SetFlashStateForHistAWB"
+ "SetFlickerDetectionResult"
+ "SetFov"
+ "SetFrameDestinationInfo fepDst %d"
+ "SetFrameInfoCBuffer"
+ "SetFrameOffWidth"
+ "SetFrameOffsetWeight"
+ "SetGDCCpuBuffer"
+ "SetGDCM3Buffer"
+ "SetGDCM3Buffer: out (%d %d)"
+ "SetGDCMeshBuffer"
+ "SetGainLUTMemValue"
+ "SetHWPower"
+ "SetInput"
+ "SetInternalAWBMetaData"
+ "SetLEDPerModuleCalibData"
+ "SetLEDType"
+ "SetLaccSTFResToCompute"
+ "SetMLAF1stFrame"
+ "SetMLVNR1stFrame"
+ "SetManualColorCalGain"
+ "SetMatchSecToPriExposure"
+ "SetMinMaxFrameRate"
+ "SetMotionDataRate"
+ "SetMsProcConfig"
+ "SetMultiCamBit"
+ "SetOffsetIn"
+ "SetOffsetLUTMemValue"
+ "SetOffsetOut"
+ "SetOperationMode"
+ "SetOutputConfig"
+ "SetOutputPictureSizeFormat"
+ "SetParameters"
+ "SetParams"
+ "SetParamsToMeetTargetEITPrimary"
+ "SetPartialFlowTimeout"
+ "SetPearlDepth"
+ "SetPearlReference"
+ "SetPeridotCalib"
+ "SetPhotometerAWBMetaData"
+ "SetPixSize"
+ "SetPreviewFrameRate"
+ "SetProjectorRepeatSequence"
+ "SetPropertyWrite"
+ "SetPropertyWriteBypassSPD"
+ "SetQuarkVersion"
+ "SetRBCBiasOffset"
+ "SetRBCBiasShift"
+ "SetRBCInterpOffset"
+ "SetRBCInterpSlope"
+ "SetRMAChannel"
+ "SetRMAStride"
+ "SetRateMode"
+ "SetScalerVertNumTap"
+ "SetScalerVertNumTap(): VertNumTap = %d, scalerSel = %d.\n"
+ "SetSemanticConfidenceMap"
+ "SetSingleFrameMode"
+ "SetSlafConf"
+ "SetSlaveCameraListColorMatchingLatticeModel"
+ "SetSlaveCameraListColorMatchingModel"
+ "SetSlaveCameraListColorMatchingModelScheme"
+ "SetSlaveExposure"
+ "SetSmartPearlRefRMA"
+ "SetSmoothingSamplingRate"
+ "SetSplitPDMode"
+ "SetSrcBank"
+ "SetSrcSize"
+ "SetStats"
+ "SetSyncOffset"
+ "SetTemporalStableMetaData"
+ "SetTileFPNMemValue"
+ "SetTileWeights"
+ "SetTimelapseConfig"
+ "SetTorchStateForHistAWB"
+ "SetTripodParams"
+ "SetVbddie"
+ "SetWMAChannelBuffer"
+ "SetWMAChannelBufferTiled"
+ "SetWarperGDCM3DmaBuffer"
+ "SetWarperM3DmaBuffer"
+ "Setting AF Supported change for Ch:%d from %d --> %d "
+ "Setting BES GP IC Compress Config from GP parameter\n"
+ "Setting CH[%d] focusPos =[%d]"
+ "Setting VIS + GDC M3 header\n"
+ "Setting VIS M3 header\n"
+ "Setting current level to 0x%x\n"
+ "Setting up patch for B1 \n"
+ "Setting up the AFEProcPipe\n"
+ "Setting up the PrepareDmaHueMap\n"
+ "Setting up the PrepareDmaStats\n"
+ "Settings applied through AE init for channel:%u"
+ "Setup"
+ "Setup axi2Dma @ 0x%x for id %d"
+ "Setup dma2Axi @ 0x%x for id %d"
+ "SetupAE"
+ "SetupAWB"
+ "SetupChannelUseCase(awbChannel, cawbUseCase)"
+ "SetupChannelUseCase(targetCh, caeUseCase)"
+ "SetupDmaChain"
+ "SetupExecute"
+ "SetupFlow"
+ "SetupHWConnectionsForFrame"
+ "SetupLSCForInputFrame"
+ "SetupRes"
+ "SetupSifrFEPBuffer"
+ "SetupSifrRawBuffer"
+ "SetupSignals"
+ "SetupWarpConfig"
+ "SetupWarpConfig(): AuxScl rSclConfig = 0x%x.\n"
+ "SetupWarpConfig(): Bes rSclConfig = 0x%x.\n"
+ "Shared gpio %d"
+ "SharedBufferPoolConfig"
+ "SharedBufferPoolReturn"
+ "SharedBufferPoolSet"
+ "SharedPool: %d chMask %x grp %d Enable %d"
+ "SharedPool: ch %d, bind to single ch pool %p"
+ "SharedPool:ch %d , replace pool %zu with shared pool %d %p"
+ "SharedPool:ch %d , type %d chMask %x %x grp %d Enable %d"
+ "SharedPool:ch %d Clear type %d chMask %x %x grp %d Enable %d"
+ "SharedRawBufferPoolInfoGet"
+ "SharedSemanticMaskBufferPoolInfoGet"
+ "ShiftAnchorsUpOnePixel"
+ "Shot-shot %dms\n"
+ "Should not change current dither mode=0x%x with mode=0x%x, freqInMHz=%d\n"
+ "ShouldEnableAFEDma"
+ "ShouldEnableSharedCTFPool"
+ "ShouldOutputPreivewStrm"
+ "ShowSifrAlgoOnOverlay"
+ "Shuffle points, number for shuffle %d,  fgNumPts to %d ..."
+ "SideBand0BufAlloc"
+ "SideBand1BufAlloc"
+ "SideBandConfigForFrame"
+ "Sif Dma Compression is not supported when have to use DATA_SOURCE_SENS_DMA_PLA"
+ "SifCompressedSizeProcess"
+ "SifDMA validation failed [%d %d %d %d] rawFrameBuffer%p"
+ "SifDMAModeGo"
+ "Sifr adjusted exp %llu gA:%u gD:%u"
+ "Sifr adjusted exp %llu gLin %d tmpGain %d"
+ "SifrBufAlloc"
+ "SifrSkipRatioSet"
+ "Signal IC to initialize Sensor channel:%d"
+ "SignalDone"
+ "SignalInitialization"
+ "SignalProcessor Enter ch:%zu %p %s ts:%f"
+ "SignalProcessor Exit ch:%zu %p %s ts:%f"
+ "SignalProcessor Handling unblocking algoctrl cmds first"
+ "SignalProcessor start"
+ "Simulate"
+ "Singular or near-singular CCM matrix."
+ "Size Meta %zu == %zu FE Stats"
+ "Size too small!"
+ "Size: PreCfg %zu, PostCfg %zu, PostState %zu, Meta %zu\n"
+ "Sizes: Hdr %lu Sec %lu Sha %lu Tot %lu Tot_64 %lu"
+ "Skin mask copy is done but failed to retrieve FD buffer out of the queue"
+ "Skin mask copy is done but failed to retrieve dst buffer out of the queue"
+ "Skin mask copy is done but failed to retrieve src buffer out of the queue"
+ "Skip OD net"
+ "Skip ROI for Skipped FD frames"
+ "Skip net processing"
+ "SkipConfig"
+ "Skipping"
+ "Skipping semantic correction: unstableWeight=%.4f"
+ "Sky global WP rgLogRatio=%.2f bgLogRatio=%.2f"
+ "Sky mask copy is done but failed to retrieve FD buffer out of the queue"
+ "Sky mask copy is done but failed to retrieve dst buffer out of the queue"
+ "Sky mask copy is done but failed to retrieve src buffer out of the queue"
+ "SlaveAWBGainUpdate"
+ "SlaveAWBProcess"
+ "SlotFilled"
+ "Smile threshold out of bounds!"
+ "SmoothAE"
+ "SmoothingActivate"
+ "SnsrRstDone"
+ "SoftGainAdjustWithADRC"
+ "Something went wrong, check stop ch (%zu)"
+ "Source Go : src %d section %d\n"
+ "SourceDoneHandler"
+ "SourceGo"
+ "SourceGo : src %d priority %d queue %d"
+ "SourceGo hardware @ %llu\n"
+ "SourceGo: +DESGEN"
+ "SourceGo: +DESMATCH"
+ "SourceGo: +DGDMJOINT"
+ "SourceGo: +LACC-match_PROGRAM"
+ "SourceGo: +LACC-match_RMA0"
+ "SourceGo: +LACC-match_RMA1"
+ "SourceGo: +LACC-match_RMA2"
+ "SourceGo: +LACC-match_RMA3"
+ "SourceGo: +LACC-match_WMA0"
+ "SourceGo: +LACC-match_WMA1"
+ "SourceGo: +LACC-match_WMA2"
+ "SourceGo: +LACC-match_WMA3"
+ "SourceGo: CVD_CVDCONFIG_PIPE_CVDCONFIG_SOURCEGO(0x%lx)=0x%08x"
+ "SourceGo[%d]: CVD_CVDCONFIG_PIPE_CVDCONFIG_SOURCEDESTBK(0x%lx)=0x%08x"
+ "SourceGo[%d]: CVD_CVDCONFIG_PIPE_CVDCONFIG_SOURCEGO(0x%lx)=0x%08x"
+ "Spawn"
+ "SplitPD RBC: ch:%zu, numRows:%zu, RBC DataAddr=%p"
+ "SplitPDCropSet"
+ "SplitPDEnable"
+ "SplitPDLineLenGet"
+ "SplitPDLineLenGetSecondary"
+ "SplitPDLumiOutEnable"
+ "SplitSoftGainFromTargetEIT"
+ "SpmiByteWrite"
+ "SpmiWordWrite"
+ "Src: isPack=%d, offset=0x%lx\n"
+ "SrcDMA regOffset=0x%x icCompOffset=%d cmpnOffset=%d cmpnWrapOffset=%d compOffset=%d\n"
+ "SrcDone"
+ "SrcDoneHandled"
+ "SrcFrameSizeSet"
+ "SrcGo"
+ "SrcTrig"
+ "Start CAWBSemanticProcess ch %lu...\n"
+ "Start CDeferBufAlloc ch %lu...\n"
+ "Start CallProc"
+ "Start DesGen operation"
+ "Start One Buffer Processing in CVDExeLoop @ %llu\n"
+ "Start One Buffer Processing in CVDServer @ %llu\n"
+ "Start One Buffer Processing in Server %llu\n"
+ "Start event logger dump @%llu us,auto %d\n"
+ "Start write the DMA in the hardware %llu\n"
+ "Start write the DMA in the hardware @ %llu"
+ "Start write the registers in the hardware %llu\n"
+ "Start: partitionWithThrhd I .."
+ "StartAnOperatoin"
+ "StartBandwidthTimer"
+ "StartCVDOperatoin"
+ "StartCVDOperatoin : src %d priority %d queue %d"
+ "StartChannel"
+ "StartEvent"
+ "StartFDT"
+ "StartFlow"
+ "StartHvLoop"
+ "StartHvLoop active\n"
+ "StartOfFrameInit"
+ "StartOfFrm"
+ "StartOp : src %d priority %d queue %d"
+ "StartPlayback"
+ "StartStreaming"
+ "StartStreaming(): ch %zu frameRate %d done\n"
+ "StartStreamingSlave"
+ "StartX is > EndX: %d, %d"
+ "StartY is > EndY: %d, %d"
+ "Started"
+ "Starting Sensor Program Signal Thread to start programming SBParam:%d"
+ "Starting the trigger the source: %d \n"
+ "Starting the trigger the source: %d semaProcDone: %zu\n"
+ "Stat Buffer is Null for FC:%d"
+ "StatAlgoControlEnable"
+ "StatDecimationProcess"
+ "StatFEThumbROI->height >= MIN_STATS_THUMB_HEIGHT"
+ "StatFEThumbROI->width >= MIN_STATS_THUMB_WIDTH"
+ "StatHdrBufferFill"
+ "StatPipe %d msicStatSize is %d miscStatRealSize is %d"
+ "StatProcEnd"
+ "StatProcStart"
+ "StatSetup"
+ "StaticDPCSetup"
+ "StaticDefectTableGet"
+ "StaticTunableTabVerify"
+ "Stats - %s %s, Tunable Mode %d "
+ "Stats aa ob offset from cal: %f.\n"
+ "Stats collected ch:%d fc:%d s:%d frmS:%d"
+ "StatsBufferConfig"
+ "StatsFE mapRaw[%d %d %d %d] pre[%d %d %d %d] reg[%d %d %d %d]"
+ "StatsFE statsThumb[%d %d %d %d]"
+ "Status:0x%x"
+ "StatusGet"
+ "StillCapture ch=%d,frame=%d has no AE update"
+ "StillDone"
+ "StlFlwChStop"
+ "Stop Receiving %d @ %llu\n"
+ "Stop continousSync %d camIndex %u clock master %u bPendingStop %d pendingStopChMask %#x"
+ "Stop continousSync %d camIndex %u clock master %u bPendingStop %d pendingStopChMask %#x @%f \n"
+ "StopChannel"
+ "StopOutputSync"
+ "StopPartialFlowTimeout"
+ "Stopped"
+ "StoreDataFromMthDma"
+ "StreamStopParamReset"
+ "StreamStopParamReset %zu"
+ "Streaming CONFIG_SELECT not supported, used CONTEXTSWITCH_SET"
+ "StreamingCommandProcessFrameRateUpdate"
+ "StreamingCommandProcessNewSequence"
+ "StreamingCommandProcessOnlineConfigUpdate"
+ "StreamingCommandProcessStopStreaming"
+ "StreamingModeSet"
+ "StreamingStop"
+ "Stride must be 64 bits aligned (8 bytes aligned)"
+ "StripGDCSetup"
+ "Strobe status: 0x%x, 0x%x, 0x%x\n"
+ "StrobeConfiguratorGet"
+ "StrobeCurrentGet"
+ "Successfully set maximum PVDD for channel %d\n"
+ "SumPD RBC: ch:%zu, numRows:%zu, RBC DataAddr=%p"
+ "Sumter booted in %d ms\n"
+ "Sumter nonce %02x %02x %02x %02x...\n"
+ "Supertile point (%d, %d) coordinates: output (%.2f, %.2f) -> input (%.2f, %.2f) -> raw (%.2f, %.2f)\n"
+ "SwitchDstBank"
+ "SwitchSrcBank"
+ "SyncGroup %u, mask %x\n"
+ "SyncGroup:%d, SyncChMask %x, ClockMaster %d"
+ "SyncGroupMask %u grpId %u strideSize %zu stride %zu"
+ "SysStatus 0x%x Mode 0x%x SBoot 0x%x Prov 0x%x ProvErr 0x%x BootErr 0x%x dbgErr 0x%x dbgEntitlement 0x%x\n"
+ "Sysmode: 0x%x\n"
+ "TEARDOWN"
+ "TF + vHDR, currFrame[%d] is EV0, RunMotionEstimation"
+ "TF + vHDR, currFrame[%d] is EVm, run NccRansac"
+ "TF FRAME %d DONE"
+ "TF only, currFrame[%d] is EV0, MotionEstimation"
+ "TFStillBufMalloc"
+ "TIMEWARP"
+ "TL: daylightScore= prev(%.3f)  vs cur(%.3f) samplingRatio=%.2f (1/%.1f) => step=%.3f"
+ "TL: daylightScore=%.4f at start so don't let it change => force 0"
+ "TL: too much changes: grayWstddev=%.3f || lux:%.2f!=avg%.2f"
+ "TL:chromaIIR:%.3f => repl norm rate: %.3f"
+ "TL:rate=%.1f Hz T=%.1f s vs fR=%hu sensT=%.3f s\n"
+ "TM %s Split PD meta data[%d]: %d %d, %d, %d, %x, {%d, %d, %d, %d} size %d @%llu\n"
+ "TM ref0-3:%p, %p, %p, %p"
+ "TM ref4-6:%p, %p, %p"
+ "TM still %s Split PD meta data[%d]: %d %d, %d, %d, %x, {%d, %d, %d, %d} size %d @%llu\n"
+ "TM to AlgoCtrl pipe full, dropping frame %d"
+ "TM to PCE pipe full, dropping spd frame %d"
+ "TM: Ch %zu Dropping last tuning params. TuningCnt %d BktCunt %d SymcBitMask 0x%x.Reset capture!!\n"
+ "TM: Cleanup Ch %zu tuning params. TuningCnt %d BktCunt %d\n"
+ "TM: General Process ch %zu started"
+ "TM: General Process ch %zu stopped"
+ "TM: Receiving buf raw done notify from ch %lu..."
+ "TM: channel %zu is not ready. bRawBufDone %u bFirstLTM %u frameCount %u"
+ "TM: receiving first LTM buffer on ch %zu"
+ "TM:[%f] ch %d(#%d,%f)ch#InSync %d tag 0x%x preB %d Bra %d (%d) flash %d %d prj %d"
+ "TMH9: Receiving first AE stable frame! channel %d frameCount %d\n"
+ "TMH9: Receiving first AWB stable frame! channel %d frameCount %d\n"
+ "TMH9: ch %zu in sync group"
+ "TMH9:ch %d (#%d, %f) ch#InSync %d, tag 0x%x, preB %d, Bra %d (%d), f %d %d prj %d, bCapNow %u"
+ "TMMultiCap"
+ "TMMultiPass"
+ "TM_MULTICAP_ABORT"
+ "TM_MULTICAP_DONE"
+ "TM_MULTICAP_IDLE"
+ "TM_MULTICAP_NO_PAIR"
+ "TM_MULTICAP_OUTPUT"
+ "TM_MULTICAP_PAIR_READY"
+ "TM_MULTICAP_PENDING"
+ "TM_MULTICAP_REQ"
+ "TM_MULTICAP_WAIT_PAIR"
+ "TM_MULTIPASS_DONE"
+ "TM_MULTIPASS_IDLE"
+ "TM_MULTIPASS_IN_PROGRESS"
+ "TM_MULTIPASS_NEXT"
+ "TM_MULTIPASS_OUTPUT"
+ "TM_MULTIPASS_REQ"
+ "TM_MULTIPASS_RUN"
+ "TMachChStop"
+ "TOF-AF FPS change request for %f denied, FPS override enabled."
+ "TORCH_ON"
+ "TORCH_ON_DONE"
+ "TRC: AlgoMisc.cpp, "
+ "TRC: CAEApple.cpp, "
+ "TRC: CAICamProcAnst.cpp, "
+ "TRC: CAWBApple.cpp, "
+ "TRC: CAWBAppleFSM.cpp, "
+ "TRC: CAlgoControlCmdANST.cpp, "
+ "TRC: CAlgoControlCmdColor.cpp, "
+ "TRC: CAlgoControlCmdNoise.cpp, "
+ "TRC: CAlgoControlCmdRaw.cpp, "
+ "TRC: CAlgoControlCmdScaler.cpp, "
+ "TRC: CAlgoControlServer.cpp, "
+ "TRC: CAlgoControlServerCmd.cpp, "
+ "TRC: CAlgoControlServerFSM.cpp, "
+ "TRC: CDSControllerBase.cpp, "
+ "TRC: CDSControllerBaseChannelCmd.cpp, "
+ "TRC: CDSControllerBaseFaceDetection.cpp, "
+ "TRC: CDSControllerH17.cpp, "
+ "TRC: CDSControllerH8.cpp, "
+ "TRC: CDSControllerH8CmdProcess.cpp, "
+ "TRC: CDSControllerH8FSM.cpp, "
+ "TRC: CDcnAttnH11.cpp, "
+ "TRC: CDebugUtility.cpp, "
+ "TRC: CERDcnProcH11.cpp, "
+ "TRC: CFDDcnProcH11.cpp, "
+ "TRC: CISPHueMapDrvH17.cpp, "
+ "TRC: CImageCapture.cpp, "
+ "TRC: CImageCaptureAE.cpp, "
+ "TRC: CImageCaptureCmd.cpp, "
+ "TRC: CImageCaptureDevices.cpp, "
+ "TRC: CImageCaptureDoubleBanking.cpp, "
+ "TRC: CImageCaptureFrameReqQueue.cpp, "
+ "TRC: CImageCaptureH17.cpp, "
+ "TRC: CImageCaptureMultiCamWrapper.cpp, "
+ "TRC: CImageCaptureMultiSyncCams.cpp, "
+ "TRC: CImageCaptureProcess.cpp, "
+ "TRC: CImageFlowH17.cpp, "
+ "TRC: CImageSensorIMX633.cpp, "
+ "TRC: CImageSensorIMX703.cpp, "
+ "TRC: CImageSensorIMX713.cpp, "
+ "TRC: CImageSensorIMX803.cpp, "
+ "TRC: CImageSensorIMX903.cpp, "
+ "TRC: CImageSensorIMX913.cpp, "
+ "TRC: CImageSensorIMX972.cpp, "
+ "TRC: CIspOperationCvPipeH17.cpp, "
+ "TRC: CIspOperationVisPipeH17.cpp, "
+ "TRC: CLTM.cpp, "
+ "TRC: CLTMDrvLTM57.cpp, "
+ "TRC: CLTMH17.cpp, "
+ "TRC: CMLAFProcImp.cpp, "
+ "TRC: CMotionEstimatorH17.cpp, "
+ "TRC: CPCECalibManager.cpp, "
+ "TRC: CPCEFlowFrontStereoFusion.cpp, "
+ "TRC: CPCEFlowPearl.cpp, "
+ "TRC: CPCEFlowPearlSinglePass.cpp, "
+ "TRC: CPCEFlowRearStereoSinglePass.cpp, "
+ "TRC: CPCEFlowRearStereoTriplePass.cpp, "
+ "TRC: CPCEFlowSplitPDDisparity.cpp, "
+ "TRC: CPCEFlowSplitPDScale.cpp, "
+ "TRC: CPDEDrvH17.cpp, "
+ "TRC: CPDEProcV2.cpp, "
+ "TRC: CProcWindowService.cpp, "
+ "TRC: CSMBusControllerAldaSTBridge.cpp, "
+ "TRC: CSMBusControllerISP.cpp, "
+ "TRC: CSyncSink.cpp, "
+ "TRC: CSystemConfigurator.cpp, "
+ "TRC: CTimeMachine.cpp, "
+ "TRC: CTimeMachineH9.cpp, "
+ "TRC: CTimeMachineMultiPass.cpp, "
+ "TRC: EventLogger.cpp, "
+ "TRC: H17TunableManager.cpp, "
+ "TRC: SysUtil.cpp, "
+ "TRC: TunableManager.cpp, "
+ "TRIPOD DETECTION: TURN OFF STABLE FLAG\n"
+ "TRIPOD DETECTION: TURN ON STABLE FLAG\n"
+ "TS1.0 TS restore [%d -> %d] isLocked = %d, isCamStable = %d, %.2f, %d"
+ "TS1.0: Decision: isLocked = %d (%d/%d), simiScr = %f, conf = %f, thd %f"
+ "TS1.0: HomoGraphy[%d] = [%.2f, %.2f, %.2f]"
+ "TS1.0: MakeTS FOVStable =[%.2f, %.2f, %.2f, %d]"
+ "TS1.0: MakeTS isStable = %d, isFOVWillUnlock = %d, contiFn = %d, mix=%f"
+ "TS1.0: TS restore [%d, %d, %d, %d] %d"
+ "TS1.0: TS restore [%d, %d]"
+ "TS1.0: TS restore [%d, %d] to channel %d"
+ "TS1.0: TileInRaw =[fn=%u, %d, %d, %d, %d] q=%d"
+ "TS1.0: TileInRawROI =[%d, %d, %d, %d] "
+ "TS1.0: WP: [ch=%d, fn=%u] wpIn=[%f, %f], wpOut=[%f, %f]"
+ "TS1.0: curFOVStableAdjustFacot = max(%f, %f)"
+ "TS1.0: iirMoition[%.2f, %.2f], stableFn %d %d %.2f"
+ "TS1.0: multiZoom [%d, %d]"
+ "TS1.0: multiZoom [%f, %f, %f, %f]"
+ "TS1.0: zoom [%d],[%.2f, %.2f, %.2f] -> [%.2f, %.2f, %.2f], de=(%2.f, %.2f)"
+ "TS1.0: zoom type = [%d, %d]"
+ "TS=%llu ch=%u extremeLowLightMode=%u Quadra %u lux=%d LumaBinningMode=%d msOverallZoomFactor0_1024=%u fps=%d\nInput: WHS %d,%d,%d RO ROI XYWH=%d,%d,%d,%d, OffsetToOrigin XY=%d,%d.\nOutput: startX %d, startY %d, endX %d, endY %d, sizeX %d, sizeY %d, offsetX %d, offsetY %d, byteStrideLuma %d\n"
+ "TURN OFF SIFR to test linesOffset rdo %d"
+ "TURN ON SIFR to test max exposure with SIFR config"
+ "TW/AE[%u]: ================== CONTROL CHANGED: %u -> %u ================"
+ "TW/AE[%u]: ================== RECORDING CHANGED: %u -> %u =================="
+ "TW/AE[%u]: ================== TRIPOD CHANGED: %u -> %u ================"
+ "TW/AE[%u]: AEAEAEAEAE ====> Mode changed: 0x%x -> 0x%x"
+ "TW/AE[%u]: AdjustExposureToBlank => vFrSz=%u"
+ "TW/AE[%u]: CONTROL CAMERA, tripod = %u"
+ "TW/AE[%u]: Ctrl+Handheld -> Load CISPCMD_AE_SET_TABLE_TIMEWARP_HANDHELD"
+ "TW/AE[%u]: Ctrl+Tripod -> Load CISPCMD_AE_SET_TABLE_TIMEWARP_CONTROL_TRIPOD"
+ "TW/AE[%u]: In: command => rec=%u des=%.4f fps mode=0x%x ctrl=%u smth=%.4f maxET=%.3f"
+ "TW/AE[%u]: Rec+Handheld -> Load CISPCMD_AE_SET_TABLE_TIMEWARP_HANDHELD"
+ "TW/AE[%u]: Rec+Tripod -> Load CISPCMD_AE_SET_TABLE_TIMEWARP_LONGEXPO"
+ "TW/AE[%u]: Report: desired:%.3f / actual:%.3f ratio=%.2f skip=%u "
+ "TW/AE[%u]: Report: desired:%.3f / unfilt:%.3f skip=%u"
+ "TW/AE[%u]: Use default maxExpTime=%u us"
+ "TW/AE[%u]: Use timewarp maxExpTime=%.4f s"
+ "TW/AE[%u]: control, controlfps=%.2f => setMin/MaxFPS: %.1f..30"
+ "TW/AE[%u]: rec=%d desired=%.2f fps => next sensor=%.2fps"
+ "TW/AE[%u]: samplingT=%.3fs / fr=%.3f dec=%.1f=> speedFrRtAdjFactr=%.3f"
+ "TableEntry != 0"
+ "TableEntry != CISPCMD_AE_SET_TABLE_USER_SUPPLY"
+ "Task"
+ "TaskArg not found"
+ "TbcSeqGetFrameExposureTime"
+ "TbcSequenceGetDuration"
+ "TearDown"
+ "TearDownExecute"
+ "TemperatureCal"
+ "Temporal decision is rejected: reason=%d"
+ "TemporalFilterStart"
+ "Temporary buffer too small!"
+ "Temporary make-up: FD3D output size does not match FID expectation"
+ "TemprlFltrStart"
+ "TestModeEnable"
+ "The AMCC[%u] base address is 0xFFFFFFFFFFFFFFFF, this AMCC is unavailable, just skip it!\n"
+ "The Peek one contains the request from the user now here (0x%x 0x%llx userId 0x%lx)\n"
+ "The free heap is less than 5%%"
+ "The request for enabling slow sync flash can not honored for this capture\n"
+ "The sensorCleanupSema is not present in Exclave mode"
+ "The sensorProgramStartSema is not present in Exclave mode"
+ "Thread time"
+ "ThumbnailBufferGet"
+ "ThumbnailDMAConfig"
+ "ThumbnailGet"
+ "TileCfg WRN Ch:%zu Window[%d %d %d %d]"
+ "TileCfg WRN: ch:%zu stX:%d endX:%d stY:%d endY:%d"
+ "TileCfg is out of Stats frame bound [%d %d %d %d] [%d %d]"
+ "TileGDCEnable"
+ "TileWindowInfoGet"
+ "TiledDone"
+ "TimeWCV'%s':%s:%d %s: ACTIVATE REGION GROWING\n"
+ "TimeWCV'%s':%s:%d %s: NEED REGION GROWING\n"
+ "TimeWDrv:    Fusion => Luma chg[%d]=%.4f = {%.3f %.3f %.3f %.3f} => %.4f fps"
+ "TimeWDrv:  %s}"
+ "TimeWDrv: .         samples: {W:%6u T:%6u SW:%6u FFC:%6u G:%6u}"
+ "TimeWDrv: . TAE: actRecFPS=%d.%03d unfilt:%d.%03d st:%u bitf:0x%x"
+ "TimeWDrv: . fusion: sens fps:{W:%2d.%03d T:%2d.%03d SW:%2d.%03d FFC:%2d.%03d G:%2d.%03d}"
+ "TimeWDrv: . gyro: %2.1f deg/s trip=%u shak=%u sameOri=%u orChg=%u deg"
+ "TimeWDrv: . luma:%d.%03d fps chg=%d.%03d"
+ "TimeWDrv: . smth:%d.%03d maxET=%d ms"
+ "TimeWDrv: Allocate CSSenseFusion"
+ "TimeWDrv: Allocate CSTemporalAestheticsEngine"
+ "TimeWDrv: Channel %d TimewarpHostMetadata:"
+ "TimeWDrv: Create CSSenseIMU=%p"
+ "TimeWDrv: DISABLED TIMEWARP -> RESET"
+ "TimeWDrv: Disabled timewarp"
+ "TimeWDrv: EnableRequest=%d (mEnabled=%d)"
+ "TimeWDrv: Force fused FPS=%u => %.3f fps"
+ "TimeWDrv: Force raw FPS=%u => %.3f fps"
+ "TimeWDrv: Forcing fused FPS = %.4f"
+ "TimeWDrv: Forcing luma raw FPS = %.4f"
+ "TimeWDrv: Global mode=0x%x -> 0x%x\n"
+ "TimeWDrv: Out for ch=%d: rec=%c recCh=%u des=%.04f skip=%u mode=0x%x=0x%x trpd=%d smth=%.4f"
+ "TimeWDrv: Output: skip=%u recFr=%u since %d s @ %d.%03d fps"
+ "TimeWDrv: PROCESSING REQUEST ch=%d rec=%d ========== (prev recCh=%d ) =========="
+ "TimeWDrv: RECEIVED REQUEST ch=%d rec=%d =================="
+ "TimeWDrv: Set recording[ch=%d]==%d\n"
+ "TimeWDrv: Set recording[ch=%u]==%u => RECORDED CHANNEL IS %u\n"
+ "TimeWDrv: TAE ch=%d => %.3f fps, skip=%u"
+ "TimeWDrv: ch=%d recCh=%d Fusion => desired_fps=%.4f fps"
+ "TimeWDrv: desired=%.3f fps => depth for motionInt=%d"
+ "TimeWDrv: desiredFPS=%.4f lastInterval=%.4f s=%.3f fps"
+ "TimeWDrv: global=0x%x Tr:%d shak:%d => internal=0x%x vs mMode=0x%x"
+ "TimeWDrv: internal mode changed: mode=0x%x => 0x%x"
+ "TimeWDrv: isOnTripod: %d->%d hasShaked=%d"
+ "TimeWDrv: mDebugFlags=0x%x"
+ "TimeWDrv: mpCSSenseByChannel[%d] = %p"
+ "TimeWDrv: setForceFPS(%u)"
+ "TimeWDrv: setMaxRecordingFPS(%u=%.4f fps)"
+ "TimeWDrv: setMaxSensorFPS(ch=%d, %u=%.4f fps)"
+ "TimeWDrv: setMinRecordingFPS(%u=%.4f fps)"
+ "TimeWDrv: setMinSensorFPS(ch=%d, %u=%.4f fps)"
+ "TimeWDrv: status=0x%x mode=0x%x rec=%u recCh=%u strm=0x%x started=%u"
+ "TimeWarp Done"
+ "Timed out waiting for focus resume after bracket capture\n"
+ "TnablReloadDone"
+ "TofCaptureDataStart"
+ "TofSetExternalNVM"
+ "ToneCurveSetup"
+ "Too many faces!"
+ "Torch"
+ "Torch Override (per driver), cool: %.1f mA, warm: %.1f mA"
+ "Torch Override, coolreg: 0x%x, warmreg: 0x%x"
+ "Torch updated: Center %d Corner %d Side %d mA\n"
+ "TorchDefault=0x%x ivfmRegPreset=0x%x LED1_TORCH_BR=0x%04x CPreDual=0x%04x"
+ "TorchDefault=0x%x ivfmRegPreset=0x%x LED1_TORCH_BR=0x%04x CpreDual=0x%04x"
+ "Total Event Count : %u\n"
+ "Total Used:%d Remaining:%d Total Available:%d"
+ "Trace data loss\n"
+ "TraceEventBuffer is NULL, bootArgsSize=%d\n"
+ "TracePost2Host"
+ "TransitionBegin"
+ "TransitionProcess"
+ "TransitionState"
+ "Tried to get T-W calib (%#x), but it is null"
+ "Tried to get W-SW calib (%#x), but it is null"
+ "Tried to get pearl calib (%#x), but it is null"
+ "Tried to init cache index out of range %zu"
+ "Trigger"
+ "TriggerGMSLoop"
+ "TriggerProjectorFaultHandling"
+ "TriggerRun"
+ "Try to process ch=%ld,frame=%d,still=%d,prevMs=%d,statMS=%d,syncTag=%d,chInSync=%d"
+ "Trying to setup CSTF on unsupported channel."
+ "TuneCoolWP"
+ "TuneCoolWPv2"
+ "TuningParamsUpdate"
+ "Turn off ISP module failed"
+ "Turn off ch %zu registration"
+ "Turn on ISP module failed"
+ "TurnOffAllRail"
+ "TurnOffDevicePower"
+ "TurnOffDevicePowerAsync"
+ "TurnOffPower"
+ "TurnOffPowerAsync"
+ "TurnOnAllRail"
+ "TurnOnDevicePower"
+ "TurnOnPower"
+ "U.height <= V.height"
+ "U.width == V.width"
+ "UNARMED"
+ "UPD"
+ "USRMOD NVM read %d bytes from 0x%x\n"
+ "UT or first frame (prevTS=%llu)\n"
+ "UnRemap :  handle 0x%x : base : %p len : 0x%lx\n"
+ "UnWrapKeysOps"
+ "Unavailable sync Sample ts is %f local Ts is %f\n"
+ "Unexpected channel (%zu) for command %u"
+ "Unexpected channel (%zu) for property write %#x"
+ "Unexpected channel for OUPUT_CONFIG %zu"
+ "Unexpected channel for SplitPDDisparity: %hhu"
+ "Unexpected pearl flow type %d"
+ "Unexpected pixel format!"
+ "Unexpected signal"
+ "Unexpected state in wait request. curr=%d, wait_old=%d, wait_new=%d\n"
+ "Unexpected trace type (%d)."
+ "Unexpected type for OUPUT_CONFIG (type=%#x)"
+ "Unexpected unknown orientation!"
+ "Unhandled flashFrameType %d"
+ "Unit Test Status:\n"
+ "Unknown LC data file type!\n"
+ "Unknown Property for Stats"
+ "Unknown optical card ID: %x"
+ "Unknown pipeId %d"
+ "Unknown pixel format!"
+ "Unknown pmLEDCalibData version."
+ "Unknown projector submode for incoming Pearl reference (%u)"
+ "Unlimited: minV %d -> vSize %d"
+ "Unordered TM capture request"
+ "UnsetMem : %p 0x%lx 0x%x\n"
+ "UnsetRemap : %p 0x%lx 0x%x\n"
+ "Unsupported camera setup"
+ "Unsupported extrinsic model number: %d\n"
+ "Unsupported mode\n"
+ "Unsupported project ver. 0x%x"
+ "Unsupported value for sensorQuadraBinFactor, should be either 0/1/2 but received %hhu"
+ "Update AFEBWR ch:%zu afeId:%d df:%f lw:%u lt:%f bpp:%d bwr:%u"
+ "Update MCache size 0x%x for streamid %u\n"
+ "Update SIFBWR for sifId:%d w:%u lineTm:%f bpp %d bwr %u"
+ "Update SidebandBWR for sbIndex:%d dataPline:%u lineTm:%f bwr %u"
+ "Update recorded frequency: %u."
+ "UpdateADRCRange"
+ "UpdateAEHistory"
+ "UpdateAFEBWR"
+ "UpdateAFWindowDMASize"
+ "UpdateAWBInitParameters"
+ "UpdateAWBSlaveChannelHostMetadata"
+ "UpdateAnLocalOp"
+ "UpdateAndCheckFeDestComplete"
+ "UpdateBufferAndCheckOpticalOffsetErrorLimits"
+ "UpdateCurrentBlkTime"
+ "UpdateCurrentSettingForFrame"
+ "UpdateDecimationConfig"
+ "UpdateDepthCircularBuffer"
+ "UpdateEoFPCycleCount"
+ "UpdateFEPBWR"
+ "UpdateFOV"
+ "UpdateGDCMetaInfo"
+ "UpdateGDCTable"
+ "UpdateGdcCfgInfo"
+ "UpdateHdrWB"
+ "UpdateHostMetaData"
+ "UpdateHostMetaDataForScalers"
+ "UpdateInitialFrameAEHistory"
+ "UpdateLEDCalibDataFromDevice"
+ "UpdateLocalMetaData"
+ "UpdateMTHCoolGains"
+ "UpdateMetaDataCrc"
+ "UpdateMetaDataPointers"
+ "UpdateMiscStatDMASize"
+ "UpdateMultiPassConfig"
+ "UpdateOneFrameTime"
+ "UpdateOpticalCenterAverage"
+ "UpdatePDAFCircularBuffer"
+ "UpdatePDAFDebugData"
+ "UpdatePearlSessionState"
+ "UpdatePearlSessionState: %x %x\n"
+ "UpdatePerFrameQFrameInfo"
+ "UpdatePriConfig"
+ "UpdateSIFBWR"
+ "UpdateSIFRTurnoffEIT"
+ "UpdateScript"
+ "UpdateSemanticTileProbTable"
+ "UpdateSensorParams"
+ "UpdateSeqEntriesListAgileParams"
+ "UpdateSeqEntriesListTbcfps"
+ "UpdateSetFileParams"
+ "UpdateSidebandBWR"
+ "UpdateSifBwrForCurrentConfig"
+ "UpdateSlafDepth"
+ "UpdateSlaveFlashSettings"
+ "UpdateSpConfig"
+ "UpdateSphbmConfig"
+ "UpdateTimeStamp"
+ "UpdateTimewarp"
+ "UpdateUserParams"
+ "UpdateZoomAndPrepareForFirstFrame"
+ "UpdateZoomParamForSif"
+ "Updated prevCoolRWP=%.3f prevCoolBWP=%.3f"
+ "Updating BkG"
+ "Updating ramp register..."
+ "Updating threshold[%d] %d\n"
+ "Useful propertywrites:\n"
+ "User %c%c%c%c %zu Release Section\n"
+ "User %c%c%c%c %zu Release Section Bank\n"
+ "UsrReqStats"
+ "V.height % U.height == 0"
+ "V159"
+ "V59"
+ "V5x"
+ "VBD D=%x RAW=%f TEMP=%f,%f V=%f\n"
+ "VBD SetVbddie=0x%x -> %f\n"
+ "VCRIrqHandle != 0"
+ "VCRouter: Exclave - Leftover idx %d hVCDest %x cleared from table"
+ "VCRouter: Exclave - idx %d: hVCDest 0x%x"
+ "VCRouter: Found empty Idx %d hVCDest 0x%x"
+ "VCRouter: Leftover idx %d hVCDest %x cleared from table"
+ "VCRouter: idx %d hVCDest %x cleared from table"
+ "VCRouter: idx %d: hVCDest 0x%x"
+ "VD56G0 Bagdemagus mnStatus = 0x%02x not Production Fused!"
+ "VD56G0 Bagdemagus rev:%04x\n"
+ "VD56G0 states: %04x\n"
+ "VD56G0Balan Boot"
+ "VD56G0Balan Boot done"
+ "VD56G0Balan KCV Status: %02x %02x %02x %02x\n"
+ "VD56G8 %s <%x> <cnt %d fsm %04x> flag 0x%x @ %.4f\n"
+ "VD56G8 %s boot up(%d). %x %d in %llu ms @ %.4f\n"
+ "VD56G8 Boot"
+ "VD56G8 Boot done"
+ "VD56G8 Cert failed! securityInfo:0x%4x\n"
+ "VD56G8 Done FW patch loading\n"
+ "VD56G8 Patch failed! securityInfo:0x%4x\n"
+ "VD56G8 Powered off at EOB, not booted.\n"
+ "VD56G8 UNWRAP: HPR cannot be loaded\n"
+ "VD56G8 UNWRAP: HPR failed! securityInfo:0x%4x\n"
+ "VD56G8 UNWRAP: HPR time out!\n"
+ "VD56G8 UNWRAP: Host signature: %s\n"
+ "VD56G8 VtPatch failed! securityInfo:0x%4x\n"
+ "VD56G8 driver loaded\n"
+ "VD56G8 states: %02x\n"
+ "VER: "
+ "VIODone"
+ "VIS is wholly disabled, algOn: %d\n"
+ "VIS strip processing case\n"
+ "VIS+GDC[%lu]: inW=%d, inH=%d, inCW=%d, inCH=%d, oW=%d, oH=%d"
+ "VIS+GDC[%lu]: warpM3BufSizeInWord %d"
+ "VIS+GDC[%lu]: warperM3Buf %p, size %lu"
+ "VISION processing case\n"
+ "VISIONRESIZE"
+ "VISPIPE: %.3fms"
+ "VISPIPEIN/OUT/HAT: framename %d"
+ "VIS[%lu]: inW=%d, inH=%d, inCW=%d, inCH=%d, oW=%d, oH=%d"
+ "VNF: XY %d %d"
+ "VRFlexSupportAV == BoardSupportAV"
+ "VSize rounded to %d"
+ "Validate"
+ "ValidateAFTileDMAEnable"
+ "ValidateAnchorPositions"
+ "ValidateFEP"
+ "ValidateFrameToDMAConfig"
+ "ValidateGeneralProcessInputParam"
+ "ValidateGenuineSMP"
+ "ValidateSifDMAConfig"
+ "Vector sizes mismatch!"
+ "VerifyPFL"
+ "VertInt:%d [%d %d]"
+ "VertNumTap <= AISP_BESPROC_PIPE_BESPROCWARP_CONFIG_VERTNUMTAPSCHROMA_TAPS9"
+ "VertNumTap=%d,LineConfig=%d,scalerSel=%d,warperMode=%d,gridOffset=%d,gridMode=%d\n"
+ "VidFlwChStop"
+ "Video Torch Current Center:Corner:Side %d %d %d mA\n"
+ "Video Torch LED EN: 0x%x Reg: Center 0x%x(%d) Corner 0x%x(%d) Side 0x%x(%d)\n"
+ "VisInW %d VisInH %d PreW %d PreH %d ResOutW %d ResOutH %d"
+ "VisPatch.SrcFrame.Height = %d"
+ "VisPatch.SrcFrame.Width = %d"
+ "VisPipe Config: %d %d %d, stepx %.3f stepy %.3f, xMode %d, yMode %d"
+ "VisPipe Dst set for ch %zu dst %d insel %u rtdma:%d bwr:%d"
+ "VisPipe dataDestination set for ch %zu fc:%d dest %d"
+ "VisPipe[%d]: enablePDP %d"
+ "VisPipe[%d]: pdp preset available for ch %d"
+ "VisPipe[%d]: pdp preset/sensor not available for ch %d, skip PDP"
+ "VisPipe[%d]: pdp sensor available for ch %d"
+ "VisPipesKey Operation DMA VisPipe 1 DST format %d w %d h %d"
+ "VisPipesKey Operation DMA VisPipe 1 SRC format %d w %d h %d"
+ "VisProcSetup"
+ "VisionRawResize"
+ "VisionRawResizePrescribed"
+ "VisionSetup"
+ "Visp. pio %d r %zu w %zu"
+ "VtPatch update\n"
+ "W.width == V.height"
+ "WARN: buf %p, total byte %zu\n"
+ "WARN: cannot peek %zu\n"
+ "WARN: disable interframe correlation for debugging\n"
+ "WARNING CSFus: Clear data"
+ "WARNING CSFus: Control is %d, unsupported recCh=%d => use full FoV"
+ "WARNING CSFus: Unknown desiredFPS=%.3f, use last sample only"
+ "WARNING CSFus: Unknown sensorFPS[%d]=%.3f, use last sample only"
+ "WARNING CSFus: ch=%c too old=%.1f ms => Disable sample"
+ "WARNING CSFus: ch=%d Not upd prv={type=%d:%.2f} @ T-%.0fms sensT=%.0fms"
+ "WARNING CSSense[%u]: NO MORE SPACE FOR id=%d, reached max=%d"
+ "WARNING CSTAE: CLAMP: des=%.3f ET=%.2fxA%.1fxD%.1f=>wSifr=%.2f minET=%.2fs maxfps=%.4f"
+ "WARNING TimeW+AE[%u]: not control, not recorded? command={mode=0x%x rec=%u trip=%u control=%u\n"
+ "WARNING TimeWDrv::%s:%d: Has shaked and back to tripod=>reset luma"
+ "WARNING TimeWDrv::%s:%d: Tripod status changed: isOnTripod: %d->%d hasShaked=%d"
+ "WARNING TimeWDrv::%s:%d: invalid ch=%d"
+ "WARNING TimeWDrv::%s:%d: not enabled"
+ "WARNING TimeWDrv::%s:%d: purging..."
+ "WARNING TimeWDrv::%s:%d: reset mpCSSenseByChannel[%d]..."
+ "WARNING TimeWDrv::%s:%d: reset mpCSSenseFusion..."
+ "WARNING TimeWDrv::%s:%d: reset mpCSSenseIMU..."
+ "WARNING TimeWDrv::%s:%d: reset mpCSTemporalAestheticsEngine..."
+ "WARNING TimeWDrv::%s:%d: reset..."
+ "WARNING twDet%s: New smallest to overwrite=%u tiles\n"
+ "WARNING twDet%s: no more space, erase smaller one (cursmall=%d)\n"
+ "WARNING!! ADRC[%u] %s: eitUpdataParams.softGain overflow, clipping from %d to %d."
+ "WARNING!! ADRC[%u] ADRCv2 UNREACHABLE unfilteredNextSifrEV(%.2f) > curSifrEV(%.2f) + v2marginEV(%.2f)"
+ "WBGSetup"
+ "WP = %.2f %.2f -> %.2f %.2f mix=%.2f Final WP = %.2f %.2f"
+ "WP=%6.4f %6.4f skinWP=%6.4f %6.4f ccmDesat=%6.4f "
+ "WRN: %d Events Dump takes too much time!!! %d uS\n"
+ "WRN: Invalid"
+ "WRN: No Pair found for Ch:%d id:%d"
+ "WSegMap current config size: %dx%d, maximum allowed size: %dx%d"
+ "Wait"
+ "Wait for all tickets timed out"
+ "Wait loop %d: GetLatestIndex: %d nextMotionIndex %llu latestIndex %llu\n"
+ "WaitForAllTickets"
+ "WaitForFullStop"
+ "WaitForStats"
+ "WaitHWReady"
+ "Waiting for EEP Idle...\n"
+ "Waiting for capture"
+ "Waiting.. clean up Sens for ch:%zu cp:%d init:%d sem:%d"
+ "WarpDGGPwithPW"
+ "WarpLUTAccess"
+ "WarpLUTAccess(): Memory access configuration is not supported in H17's BES.\n"
+ "WeightedRandomGenerator"
+ "Will skip RAW2YUV PASS for this frame=%d"
+ "Will stop and drop current frame=%d"
+ "Win %d: %f %f %f %f"
+ "Win %u: %f %f %f %f \n"
+ "With ColorCal R/G=%f B/G=%f"
+ "Wrap %d, Auth %d, Unwrap %d, [0 1 2][NOT_USED SUCCESS BYPASSED]"
+ "Wrap status: 0x%x, Auth status 0x%x Unwrap status: 0x%x\n"
+ "WrapKeysOps"
+ "Write  0x%x to 0x%x\n"
+ "Write to %s failed! "
+ "Write to Section %d of HW Bank %d ,%llu\n"
+ "Write to Section %d of HW Bank %d @ %llu\n"
+ "WriteByte"
+ "WriteBytesAsync"
+ "WriteCmpnRtrValue"
+ "WriteMessage"
+ "WriteNoTableRegValue"
+ "WriteRegisterFromGenericPIO"
+ "WriteReplayData"
+ "WriteResult"
+ "WriteSectionToHWPIODMAList"
+ "WriteSectionToHWPIODMAList(): sectionId = %d\n"
+ "WriteSectionToHWPIODMAList(): sectionId = %d, before trigger PIODMA\n"
+ "Writing Boot End\n"
+ "Writing bytes 0x%x <== 0x%x %x %x %x %x ...\n \t %x %x, %x %x, %x %x, %x %x, %x %x\n"
+ "Wrong Sample ts %f localTs %f (isp %f oscar %f motion %f)\n"
+ "Wrong tele/swide connections detected!\n"
+ "X1 <= origEndX"
+ "XXX Aries Setting dummy pub keys\n"
+ "YCC"
+ "YCC: [%d %d %d %d]\n"
+ "YGoc: Offsets 0x%x 0x%x Min 0x%x Max 0x%x"
+ "YGoc: XY %d %d Gain 0x%x GainShift 0x%x"
+ "YSHSetup"
+ "YUVReplayEnable"
+ "Yeti already powered on, Stat:0x%x"
+ "YledIdeal %lld"
+ "YogiSeqRead(%d) %02x %02x\n"
+ "YogiWriteByte(%d) %02x %02x\n"
+ "ZERO pulse width!"
+ "ZFDepth: %s CH%zu [OFFSET RAW supROI_startXY, endXY] = [%.2f,%.2f][%.2f,%.2f]\n"
+ "ZFDepth: %s CH%zu [PDE supROI_startXY, endXY] = [%.2f,%.2f][%.2f,%.2f], [PDE WH]=[%.2f,%.2f]\n"
+ "ZFDepth: %s CH%zu [SLAF RGB startXY, endXY] = [%d,%d][%d,%d]\n"
+ "ZFDepth: CH%zu Number of columns in PartitionAfRoiTargetDepth is greater than 3!"
+ "ZFDepth: CH%zu spotClass Counts near=[%d], occluded=[%d], specular=[%d]\n"
+ "ZFDepth: CH%zu spotCount=[%d] blocked=[%d]\n"
+ "ZFDepth: CH%zu totNumOfSpecularSpotsInRoi = %d, specularRoi=%d\n"
+ "[ \n %f, %f, %f \n %f, %f, %f \n %f, %f, %f \n ] \n"
+ "[%.3f]%s srcDone %.3f"
+ "[%.3f]S%s:FD RV %.3f FV %.3f ro %.3f fc %d m %d"
+ "[%.3f]S%s:FD RV %.3f FV %.3f ro %.3f fc %d m %d done"
+ "[%3d] %hu, ts %llu, c %llu, ch %u\n"
+ "[%3d]: [%3d] / [%3d] / [%3d]"
+ "[%d %d]"
+ "[%d %d] hasGlasses %d glassesScore %f"
+ "[%d ] After GVSGetPicIn() ***\n"
+ "[%d ] After ratio %f: Bes inW %d inH %d inCropW %d inCropH %d outW %d outH %d\n"
+ "[%d ] Before GVSGetPicIn() ***\n"
+ "[%d ] Before ratio %f: Bes inW %d inH %d inCropW %d inCropH %d outW %d outH %d\n"
+ "[%d ] Bes inW %d inH %d inCropW %d inCropH %d outW %d outH %d\n"
+ "[%d ] Fes inCropW %d inCropH %d outW %d outH %d\n"
+ "[%d ] Raw inW %d inH %d binW %d binH %d"
+ "[%d ] Raw inW %d inH %d binW %d binH %d\n"
+ "[%d ] SphereMode change from %d to %d\n"
+ "[%d ] lensPositionScalingFactor %f\n"
+ "[%d ] lensPositionScalingFactor %f cropRatio %f\n"
+ "[%d, %d] GDC enabled and validRect set, validRect: %d, %d, %d, %d\n"
+ "[%d, %d] GDC enabled but validRect Not set, validRect: %d, %d, %d, %d\n"
+ "[%d, %d] GDC enabled, adjusted validRect: %d, %d, %d, %d\n"
+ "[%d, %d] GDC not enabled, validRect: %d, %d, %d, %d\n"
+ "[%d, %d] initialize gvcCore"
+ "[%d] ch=%d can't get BayerProc output buf"
+ "[%d] ch=%d can't get ClrProc output buf"
+ "[%d] ch=%d can't get MsBeProc output buf"
+ "[%d] ch=%d can't get bufOutRsclPreScal output buf"
+ "[%d] ch=%d frame=%d, No MLAF buffer available"
+ "[%d] ch=%d, OK(%d, %d, %d, %d)!"
+ "[%d] ch=%ld,frame=%d,%d,latency=%d,%d us(%d,%d),bufOut=%p"
+ "[%d] cropHeight %d rawHeight %d\n"
+ "[%d] overscanWidth %d overscanHeight %d\n"
+ "[%d]: Correct ts %f rec %f (isp %f os %f mo %f)\n"
+ "[%d]: Unavailable sync Sample ts is %f local Ts is %f\n"
+ "[%d]: Wrong ts %f rec %f (isp %f os %f mo %f)\n"
+ "[%d]: currCapTs %f motionTs %f diff %f sample %d maxDiff %f\n"
+ "[%d]: frameTime = %f s executionTime = %f ms\n"
+ "[%f] ch %zu (%s) AE stream control request when IC not streaming"
+ "[%f] ch %zu (%s) Projector turned on"
+ "[%f] ch %zu FVSYNC fc %d - [%f] dc=%u %u"
+ "[%f] ch %zu GO fc %d %d - [%f]"
+ "[%f] ch %zu NEXT FRAME fc %d - [%f] state %d"
+ "[%f] ch %zu PipeDoneMainIrq fc %llu currFC:%d sifrEn:%d isICStop:%d pfD:%d %d"
+ "[%f] ch %zu PipeDoneSifrIrq fc %llu pfD:%d %d"
+ "[%f] ch %zu RVSYNC fc %d - [%f] dc:%u %u"
+ "[%f] ch %zu RVSYNC fc %d - [%f] prevFV [%f]"
+ "[%f] ch %zu SrcDone fc %d - [%f] state %d procesd %d busy %d active %d\n"
+ "[%f] ch %zu Stats TrigIrq fc %d - %llx StatsArmed %d, spt %d sifr %d"
+ "[%f] ch %zu Stats srcDone fc %d"
+ "[%f] ch %zu TrigIrq fc %d"
+ "[%f] ch %zu TrigIrq fc %d, activeBk %x - %x"
+ "[%f] ch %zu fc %u sifr %u RV After lpdp stop issued at @%f\n"
+ "[%f] ch:%zu fc:%d OFT:%llu Mode:%d Dlt:%d Fire:%llu"
+ "[%f]: ch %zu fc %d issueGo %d"
+ "[%f]: ch %zu fc %d issueGo %d state %d"
+ "[%f]: ch %zu fc %llu issueGo %d"
+ "[%f]M%s:FD RV %.3f FV %.3f ro %.3f fc %d Done"
+ "[%f]M%s:FD RV %f FV %f ro %f fc %d"
+ "[%llu.%06llu] ch %zu RVSYNC fc %d - [%llu.%06llu] ft %.2f fps %.2f avg %.2f"
+ "[%lu] visOn=%d,isRear=%d,stillIC=%d,streamMode=%d\n"
+ "[%lu]: Setting Action Config: size %d"
+ "[%lu]: Setting LACC-match input: size %d"
+ "[%lu]: Setting Operation Config: size %d"
+ "[%lu]Action Item %d opId %d"
+ "[%s] CH = %zu AFEProc STERAMING_MODE [0x%x]\n"
+ "[%s] CH = %zu Force Resource manager Static mode [%d]\n"
+ "[%s] CH = %zu Resource managerdbgLevel [%d]\n"
+ "[%s] CH = %zu Stats STERAMING_MODE [0x%x]\n"
+ "[%s] CH = %zu Unsupported property [0x%x]\n"
+ "[%s] CH = 0x%zu   HighRes AEAWB Window Set > cfg[%d] [#%d: %u, %u, %u, %u] %s\n"
+ "[%s] CH = 0x%zu   LTM Weight segmentation Map enable = %u, seg number: %u, width: %u, height: %u, sigma: %u, %s\n"
+ "[%s] CH = 0x%zu   Timewarp force FPS set=%.5f %s\n"
+ "[%s] CH = 0x%zu   Timewarp params set={en=%u mode=0x%x min/maxFps=%.4f/%.1f} %s\n"
+ "[%s] CH = 0x%zu   Timewarp params set={en=%u mode=0x%x min/maxFps=%.4f/%.1f}...\n"
+ "[%s] CH = 0x%zu   Timewarp recording set=%u %s\n"
+ "[%s] CH = 0x%zu  IGNORE TW force FPS set=%.5f %s\n"
+ "[%s] CH = 0x%zu  IGNORE TW recording set=%u %s\n"
+ "[%s] CH = 0x%zu  TSeg Thumbnail stride: %d, size: %d %s\n"
+ "[%s] CH = 0x%zu  TSeg WSeg stride: %d, size: %d %s\n"
+ "[%s] CH = 0x%zu MLVNR Mode Config ctrl=%d,Thres Enter:Exit=%d:%d,FPS Enter:Exit=%d:%d,RampDownFrames=%d\n"
+ "[%s] CH = 0x%zu SN %u %s\n"
+ "[%s] CH = 0x%zu TIMEWARP NOT ALLOCATED!!\n"
+ "[%s] CH%zu lux=%.2f isLuxValid=%d waveConf=%d chgain=%f dcRatioIR=%.4f %s"
+ "[%s] CH%zu status=%u dc=(%.4f, %.4f) irRatio=%.4f freqConf=%.4f dcRatio=%d"
+ "[%s] CH=%zu AE FlickerFreqSet dataStatus=%u, count=%d, freq[0]=%d confidence[0]=%d waveMatch[0]=%d %s \n"
+ "[%s] COverlayService->setDebugFlags(0x%x)\n"
+ "[%s] COverlayService->setOverlayDisplayShiftValue(0x%x)\n"
+ "[%s] COverlayService->setOverlayFlags(%zu, 0x%x)\n"
+ "[%s] COverlayService->setOverlayUpperFlags(%zu, 0x%x)\n"
+ "[%s] CROIService->DrawMaskSet(enBitMask=0x%x, pplMode=0x%x, facedraw=0x%x, scaleId=0x%x)\n"
+ "[%s] EPH key %x %x %x ... %x %x %x HostNonce %x %x %x ... %x %x %x \n FWNonce  %x %x %x ... %x %x %x Auth %x %x %x ... %x %x %x\n"
+ "[%s] L%d lens controller ALL ASYNC STOP dt: %.2f ms; ts: %llu ms\n"
+ "[%s] L%d lens controller ch%zu ASYNC START called; ts: %llu ms\n"
+ "[%s] L%d lens controller ch%zu ASYNC START dt: %.2f ms; ts: %llu ms\n"
+ "[%s] L%d lens controller ch%zu ASYNC STOP dt: %.2f ms; ts: %llu ms\n"
+ "[%s] L%d lens controller ch%zu BLOCK START called; ts: %llu ms\n"
+ "[%s] L%d lens controller ch%zu BLOCK START dt: %.2f ms; ts: %llu ms\n"
+ "[%s] L%d lens controller ch%zu BLOCK STOP called; ts: %llu ms\n"
+ "[%s] L%d lens controller ch%zu BLOCK STOP dt: %.2f ms; ts: %llu ms\n"
+ "[%s] PowerService is not available\n"
+ "[%s] Received FEThumbMask Enable: %d for Ch:%zu \n"
+ "[%s] Set timelapse capture %u\n"
+ "[%s] Set timelapse sampling rate %u=%.1f Hz to all\n"
+ "[%s] Set timelapse smoothing %u to all\n"
+ "[%s] ch %zu stop done! @%.4f"
+ "[%s] data[%zu] = 0x%02x\n"
+ "[%s] ispEngineServer is not available\n"
+ "[%s] line:%d\n"
+ "[%s] set PowerService EnablePSD to %d\n"
+ "[%s] set PowerService powerDomain %d to %d\n"
+ "[%s] set PowerService to %d\n"
+ "[%s] set retention validation to %d\n"
+ "[%s]: No AF filter for CH %zu"
+ "[%s]: No AWB filter for CH %zu"
+ "[%s]Disable ER...\n"
+ "[%s][CH%zu][ToFFlickerDetectAF] COUNT=[%d] [F0,C0]=[%d,%d] [F1,C1]=[%d,%d] EC[%s]"
+ "[%s][CH%zu][ToFFlickerDetectAF] status=[%u] dc2acRatioIR=[%f] dc2acRatioIRConf=[%f] EC[%s]"
+ "[%s]non-blocking cmd done! total %.2f ms Curtime %.2f\n"
+ "[0] do not use compression if isHwMapped\n"
+ "[0] len in PartInfo(0x%x) and PartMapping(start=0x%x, end=0x%x, len=0x%x) should be identical\n"
+ "[0] pPartInfo->actionNbr(%d) should be identical to pPartMapping->actionNbr(%d)\n"
+ "[0] start/end should be identical between PartInfo[0x%x:0x%x] and PartMapping[0x%x:0x%x]\n"
+ "[1] do not use compression if isHwMapped\n"
+ "[1] len in PartInfo(0x%x) and PartMapping(start=0x%x, end=0x%x, len=0x%x) should be identical\n"
+ "[1] pPartInfo->actionNbr(%d) should be identical to pPartMapping->actionNbr(%d)\n"
+ "[1] start/end should be identical between PartInfo[0x%x:0x%x] and PartMapping[0x%x:0x%x]\n"
+ "[2] do not use compression if isHwMapped\n"
+ "[ALSC] ALS reset after ALS_MAX_RESET_FRAME\n"
+ "[ALSC] daylightWeight=%d, alscTuningStrength=%.2f\n"
+ "[ALSC] daylightWeight=%d, lux level=%d, alscTuningStrength=%.2f\n"
+ "[ALSC] method=%d enable=%d\n"
+ "[ANST]"
+ "[AneIpc] total requestCallProc %zu receiveCallProc+ %zu"
+ "[AneIpc] total requestCallProc+ %zu receiveCallProc %zu"
+ "[BE] Got a source Done Handler for %d and irq 0x%x\n"
+ "[BE] No User is listening to this source %d\n"
+ "[COMP] tempPtr(%p) doesn't pointing to the end of the buffer(%p)\n"
+ "[COMP] used memory size(0x%lx) doesnt match with allocated memory size(0x%lx)\n"
+ "[CVD] Got a Source Done Handler for %d and irq 0x%x\n"
+ "[CVD] No User is listening to this source %d\n"
+ "[DEBUG] bank: 0x%02x\n"
+ "[DEBUG] irqEn: 0x%08x\n"
+ "[DEBUG] irqSts: 0x%08x\n"
+ "[DEBUG] mxwrapEn: 0x%08x\n"
+ "[DEBUG] mxwrapSta: 0x%08x\n"
+ "[DEBUG] spmi_irqen : 0x%08x\n"
+ "[DRAM to HW]Skipping Section:%d Action:%d\n"
+ "[DSI] %d usec passed since GMS loop was triggered - stopping"
+ "[DSI] %f, %f, %f"
+ "[DSI] %s"
+ "[DSI] %s %s sync %s"
+ "[DSI] %s CH:%d FC:%d SM,PM:%d,%d FMT:%d,%d,%zu FT:%d,%d B:%d,%d"
+ "[DSI] %s Done %duS. Counters:"
+ "[DSI] %s Done (%d uSec)!"
+ "[DSI] %s Done (%d uSec)! DX=0x%08x"
+ "[DSI] %s GMC trigger result: %d"
+ "[DSI] %s Got GMS Loop Results, curr ConfigID %u, new ConfigID %u, ST=%u"
+ "[DSI] %s HW power status =%s"
+ "[DSI] %s Running in OutOfBound mode"
+ "[DSI] %s Setting Tx Mode config (OpMode = %u)"
+ "[DSI] %s Setting new operation mode %u\n"
+ "[DSI] %s Setting new rate mode %u"
+ "[DSI] %s Setting pearl depth output to front stereo ST=%u"
+ "[DSI] %s Skipping PCE configuration for optimization"
+ "[DSI] %s Switch Mode W:%d, S: %d, pad: %d, H: %d, SizeP: %d, DiffLR: %d"
+ "[DSI] %s Switched Regs Config: NewRTe=%d f=%d RGB:%u,%u,%u,%u"
+ "[DSI] %s configuration done. Time (%d uSec)"
+ "[DSI] %s debug mode is ON. ch=%zu"
+ "[DSI] %s flow %s has finished running"
+ "[DSI] %s flow configs UC=%s FC=%d:"
+ "[DSI] %s registers config: %d"
+ "[DSI] %s scheduled %s to run"
+ "[DSI] %s scheduled %s to run immediate"
+ "[DSI] %s set HW power(%d, %s), rc =%s"
+ "[DSI] %s | runtime: %d us"
+ "[DSI] %s: Allocating buffers for scan 224 x 8"
+ "[DSI] %s: Caller=%p"
+ "[DSI] %s: Completed copy new Peridot Calib rc=%u\n"
+ "[DSI] %s: Completed to set new Peridot Calib rc=%u\n"
+ "[DSI] %s: Created! (this =%p)"
+ "[DSI] %s: DEBUG Override: ALPM disable"
+ "[DSI] %s: DEBUG Override: frequency (Hz): %llu"
+ "[DSI] %s: Dtor (this =%p)"
+ "[DSI] %s: Free configUpdate.currentCmd=%p"
+ "[DSI] %s: LoadTxModeCfg failed"
+ "[DSI] %s: Mode Config %u, sequenceDurationUs=%f"
+ "[DSI] %s: Peridot Calib is not set"
+ "[DSI] %s: Removing allocation for scan 224 x 8"
+ "[DSI] %s: Requested"
+ "[DSI] %s: Setting the ignore calib to %s\n"
+ "[DSI] %s: Update not supported for fsync mode (%u)"
+ "[DSI] %s: doInitialize =%s: m_state =%d, m_futureTriggering =%s"
+ "[DSI] %s: frameRate=%u, controlState=%u"
+ "[DSI] %s: framesInSuperframe=%u"
+ "[DSI] %s: hSensor->TriggerManualSync() failed"
+ "[DSI] %s: segment[%s] ptr =%p)"
+ "[DSI] %s: setting cal data, valid: %u"
+ "[DSI] %s: validating anchor positions"
+ "[DSI] %s:%d state = 0x%X"
+ "[DSI] %s:%d state = 0x%X QUARK_STATE_HV_STB=0x%X"
+ "[DSI] %s:%d state = 0x%X QUARK_STATE_IDLE=0x%X"
+ "[DSI] %s=0x%02X"
+ "[DSI] %s=0x%02X 0x%02X 0x%02X"
+ "[DSI] %s=0x%02X 0x%02X 0x%02X 0x%02X"
+ "[DSI] *** PDE Rear Stereo %s/%s Switched Regs Config: requested regType=%d, w %d h %d storeCache=%d"
+ "[DSI] ***** IMX591: Using AUX-LESS LPDP configuration *****"
+ "[DSI] --- PDE Pearl Reference TempActNTC:%.3f -> Idx:%d %.3f Diff:%.3f"
+ "[DSI] <<< PDE vertical RearStereo Done (%d uSec)! NormDX=%#08x DX=%#08x GC=%#08x"
+ "[DSI] >>> Depth Config EN:%d O:%dx%d REG:%d CIV:%d FP16:%d"
+ "[DSI] >>> Dx Config EN:%d O:%dx%d REG:%d CIV:%d FP16:%d"
+ "[DSI] >>> Dy Config EN:%d O:%dx%d REG:%d CIV:%d FP16:%d"
+ "[DSI] >>> NormDX Config EN:%d O:%dx%d REG:%d CIV:%d FP16:%d"
+ "[DSI] >>> Split PD Ch %u FC:0x%x Quadra: %u[%u]"
+ "[DSI] >>> Split PD En:%d PF:%d, SC:%d, Size:%d, W:%d, H:%d, S:%d BinW %d BinH %d MaxDS %u"
+ "[DSI] AddModeConfig from cfgManager: %u, opMode: %x"
+ "[DSI] Bad depth quality, gc %u, tag=%#x"
+ "[DSI] Bug in WeightedRandomGenerator algorithm implementation. Should have found an index i s.t sum(w_0..w_i-1) <= r * sum(weights) < sum(w_0..w_i)"
+ "[DSI] CImageSensorIMX591::ConfigSet %ld %d %d %d"
+ "[DSI] Camera Covered - force projector on"
+ "[DSI] ChangeEmitterStatus %u\n"
+ "[DSI] Copy online config sp anchors"
+ "[DSI] CopyToCache Done - RT:%d (%d uSec)"
+ "[DSI] CopyToRegs Done! cache=%d (%d uSec)"
+ "[DSI] CopyToRegsCrop Done! (%d uSec)"
+ "[DSI] Couldn't acquire pioDmaNotify"
+ "[DSI] Couldn't allocate pMem"
+ "[DSI] Couldn't allocate pSegments"
+ "[DSI] Couldn't allocate sharedMemory"
+ "[DSI] Couldn't get registers configuration from RegsUpdate"
+ "[DSI] CreateRegistersList Done! RT:%d Res:%dx%d C:%d %d,%d %d,%d Stat:%d (%d uSec)"
+ "[DSI] Creating Front RGB Calib"
+ "[DSI] Creating Rear Calib. ch=%zu, %s camera"
+ "[DSI] Depth=%u Shifts=%u"
+ "[DSI] DistDrv disCXY: %f %f"
+ "[DSI] Done updating algRearRGCalibCfg (required for GMS loop)"
+ "[DSI] Dx buf: sz=%zu, algo=%p, shmem=%p"
+ "[DSI] Dx=%u Dy=%u"
+ "[DSI] Dy buf: sz=%zu, algo=%p, shmem=%p"
+ "[DSI] Emitters idx is higher than %u"
+ "[DSI] Entry type not supported %u"
+ "[DSI] FPD: SubMode=%d, PSB=%d, Result=%d (FMax:%d PMin:%d)"
+ "[DSI] Face Found: x:%d y:%d width:%d height:%d depth:%d age:%d iscolor:%d"
+ "[DSI] Face is too small!"
+ "[DSI] Face too old! (%d > %d)"
+ "[DSI] Failed to acquire mutex projector"
+ "[DSI] Failed to acquire semaphore"
+ "[DSI] Failed to acquire signal pool"
+ "[DSI] Failed to allocate nvm data"
+ "[DSI] Failed to allocated mutex"
+ "[DSI] Failed to create peridot projector task"
+ "[DSI] Failed to create peridot sensor task"
+ "[DSI] Failed to get buffer"
+ "[DSI] Failed to load the mode cfg !!!"
+ "[DSI] Failed to read nvm data"
+ "[DSI] Failed to send GMS loop results to %s"
+ "[DSI] Fake Face Found: x:%d y:%d width:%d height:%d depth:%d isColor:%d"
+ "[DSI] Flow %s initialized. FC=%d"
+ "[DSI] Flow %s initialized. ST=%d"
+ "[DSI] Focus ST=%u: Master %u Slave %u"
+ "[DSI] Front Stereo %s/%s. ST=%u"
+ "[DSI] Full Serial Number: %s\n"
+ "[DSI] GMC Debug: Not updating PCE calib!"
+ "[DSI] GMC Debug: Running non-stop!"
+ "[DSI] GMC IR-PROJECTOR completed!. Running RGB-IR MI"
+ "[DSI] GMC IR-Projector Controller Status Failed!"
+ "[DSI] GMC RPC Failed... Retrying IR-Projector GMC! gmcRetry = %d/%d"
+ "[DSI] GMC RPC Failed... Retrying IR-RGB GMC! gmcRetry = %d/%d"
+ "[DSI] GMC RPC v%d Sent! Face=%d(V:%d,C:%d, x:%d, y:%d, w:%d, h:%d)"
+ "[DSI] GMC is using GMC preset! (%d)"
+ "[DSI] GMC state is not ready to execute (state=%d)"
+ "[DSI] GMS Loop req sent to PCEAlgo, ST=%u"
+ "[DSI] GMS Valids %d, %d %d %d"
+ "[DSI] GMS loop extra size (%zu) is not as expected (%zu)"
+ "[DSI] GMS results %d, %f %f %f"
+ "[DSI] GetFaceByIndex failed rc=%d(C:%d)!"
+ "[DSI] GetFaceIndexByTs failed rc=%d(C:%d)!"
+ "[DSI] Got GMC Results: RPCStatus=%d controllerStatus=%f (%d uSec)! T:%d"
+ "[DSI] Got a PCE reference! Type=%d Size=%d(%lu)"
+ "[DSI] Got a PDE calibration! Type=%d Size=%d(%lu)"
+ "[DSI] Granger register dump"
+ "[DSI] Granger register dump done"
+ "[DSI] Granger register dump failed"
+ "[DSI] IMX591 (%x): Stat 0x2C4=0x%x 0x2C6=0x%x 0x2C7=0x%x 0x110=0x%x"
+ "[DSI] IMX591 Fast Link Training Passed: 0x%x"
+ "[DSI] IMX591 Not streaming, Skipping state checks!"
+ "[DSI] IMX591 isn't powered on"
+ "[DSI] IMX591: %s %s %d %d %f %lld"
+ "[DSI] IMX591: DID %04x"
+ "[DSI] IR principal point 0: %lf -> %lf"
+ "[DSI] IR principal point 1: %lf -> %lf"
+ "[DSI] IR temp coeffs %d:%lf %lf"
+ "[DSI] IR temps: sensor %.2f asmb %.2lf Diff %.2f"
+ "[DSI] Ignoring RFC Lock, last Pearl referece is not valid!"
+ "[DSI] Illegal buf size"
+ "[DSI] Illegal config->dataLaneCnt (%u)"
+ "[DSI] Illegal laneCount (%u)"
+ "[DSI] Initial Color Extrinsics"
+ "[DSI] Invalid PCE stage"
+ "[DSI] Invalid SeqEntry type %u"
+ "[DSI] Invalid SeqEntry type (%u)"
+ "[DSI] Invalid Structure size allocated!"
+ "[DSI] Invalid rmaCh"
+ "[DSI] Invalid wmaCh"
+ "[DSI] LPDP output level == 0xFFFF: using default: %d mV."
+ "[DSI] LZ4 Status=%d DT=%d Time=%duS "
+ "[DSI] LensServices ApsPos.ddfPFL %f"
+ "[DSI] Link Training failed, power cycling and retrying"
+ "[DSI] Lpdp index out of range"
+ "[DSI] MD disCXY: %f %f"
+ "[DSI] Maximum number of allowed registrations exceeded"
+ "[DSI] Mode Config version is not supported, got:%u expected:%u"
+ "[DSI] Mode cfg is null ptr"
+ "[DSI] NVM allocation failed"
+ "[DSI] No CROIService!"
+ "[DSI] No DX Buffer! Using the internal DX Buffer..."
+ "[DSI] No DY Buffer! Using the internal DY Buffer..."
+ "[DSI] No GMS Buffer! Using the internal GMS Buffer..."
+ "[DSI] No face found! (C:%d)"
+ "[DSI] No valid FCAM calibration from driver, reading values from FCCL (using extrinsic driver)"
+ "[DSI] Not enough GMC points, building GMS buffer manually from DX/DY/RGSCR! (%d %d)"
+ "[DSI] Number of buffers is bigger than expected"
+ "[DSI] OffsetX=%f OffsetY=%f EFL=%f, ST=%u"
+ "[DSI] One of the camera is not in focus, exit"
+ "[DSI] Overriding 0 FPS"
+ "[DSI] Overriding Pearl use-case: %s[%d]"
+ "[DSI] PCE Crop from internal meta %d %d %d %d"
+ "[DSI] PCEAlgo ChannelStopped ch %zu."
+ "[DSI] PCEAlgo is still processing prev GMS loop (SentST %u, RcvST %u, delayCntr %u),exit"
+ "[DSI] PDE First Pass Done (TriplePass flow)"
+ "[DSI] PDE Front Stereo Switched Regs Config: Old=%d New=%d, w=%d h=%d storeCache=%d"
+ "[DSI] PDE RGB first pass Done (%d uSec)! NormDX2=%#08x, GMC:%d"
+ "[DSI] PDE RGB second pass Done (%d uSec)! NormDX2=%#08x, GC:%u"
+ "[DSI] PDE RMA%d: 0x%08lx %d"
+ "[DSI] PDE RMA%d: S: %d"
+ "[DSI] PDE Second Diagonal Pass for portrait Done, %d usec, GC=%#x"
+ "[DSI] PDE Third Pass Diagonal Done (%d uSec)"
+ "[DSI] PDE WMA%d 0x%08lx %d (%d %d %d) DMA:0x%x,0x%x"
+ "[DSI] PDE WMAT%d 0x%08lx %d (%d %d %d) S %d DMA:0x%x,0x%x"
+ "[DSI] PPD needs to run but no DX Buffer! Using the internal DX Buffer..."
+ "[DSI] PPD needs to run but no DY Buffer! Using the internal DY Buffer..."
+ "[DSI] PRI %u: ccprd=%3u, pllfreq_i=%4u, pllfreq_f=%3u"
+ "[DSI] PROJECTOR Standby."
+ "[DSI] Pearl RGB Reg (%dx%d) AR %f (RegColorRes %dx%d RegColorOutRes %.0fx%.0f)! "
+ "[DSI] Pearl flow type %d (use-case=%d)"
+ "[DSI] Peridot Config = C%04X\n"
+ "[DSI] Peridot Config = C%04X%c\n"
+ "[DSI] Peridot Config = C%hx%s\n"
+ "[DSI] Peridot SN: %s %d"
+ "[DSI] Proj Extrinsics:"
+ "[DSI] Projector is not powered on"
+ "[DSI] Property Attention retry: %d"
+ "[DSI] Property Enable All IR Types: %d"
+ "[DSI] Property Force Depth (FID Auth Coaching): %d"
+ "[DSI] Property Force SLAF: %d"
+ "[DSI] Property PPD Debug: %d"
+ "[DSI] Property Pearl Reference Debug: %d"
+ "[DSI] Property Pearl UseCase Debug: %d"
+ "[DSI] Property RegsUpdate Tweak: %d"
+ "[DSI] Property Set Bit Exact: %d"
+ "[DSI] QUARK NTC test - %04x,  %f.\n"
+ "[DSI] QUARK thermal (%llu) - NTC cool down  %f. Projector back ON.\n"
+ "[DSI] QUARK thermal (%llu) - NTC temp %f. Projector back ON.\n"
+ "[DSI] QUARK thermal (%llu) - NTC temp too low %f\n"
+ "[DSI] QUARK thermal - Temperature out of range. Projector is OFF!"
+ "[DSI] QUARK version %u (eQuarkVersion)"
+ "[DSI] QUARK_STATE_ACTIVE"
+ "[DSI] QUARK_STATE_BRICK_CHECK_AND_WRITE"
+ "[DSI] QUARK_STATE_HV_STB"
+ "[DSI] QUARK_STATE_HW_STB"
+ "[DSI] QUARK_STATE_IDLE"
+ "[DSI] QUARK_STATE_LV_STB"
+ "[DSI] QUARK_STATE_RESERVE1"
+ "[DSI] QUARK_STATE_RESERVE2"
+ "[DSI] QUARK_STATE_SLEEP"
+ "[DSI] QUARK_STATE_SOFT_DISCHARGE_AND_CHECK"
+ "[DSI] QUARK_STATE_SOFT_START_AND_BIST"
+ "[DSI] QUARK_STATE_SOFT_START_AND_BIST_SLEEP"
+ "[DSI] QUARK_STATE_SOFT_START_AND_BIST_SLEEP_MAN"
+ "[DSI] QUARK_STATE_WAKE_UP_NVM_LOAD"
+ "[DSI] Quark ADC Measurement: channel %llu, voltage: %f\n"
+ "[DSI] Quark bypassTemperatureRead=%u\n"
+ "[DSI] Quark off! level %d, state %d"
+ "[DSI] Quark register dump"
+ "[DSI] Quark register dump done"
+ "[DSI] Quark register dump failed"
+ "[DSI] Quark state: %s"
+ "[DSI] Quark:%s:%d"
+ "[DSI] RFC Lock is enabled! Using last Pearl reference..."
+ "[DSI] RFC Type=%d Size=%d Idx=%d Fmt=%d Tmp=%f Total=%zu"
+ "[DSI] RG buf: sz=%zu, algo=%p, shmem=%p"
+ "[DSI] RGBIR AR: %f O: %d %d, RegColorOutRes %f %f, RegColorRes %d %d cinvid %d"
+ "[DSI] RGSCR=%u GC=%u DR=%u"
+ "[DSI] Re-running GMC due to temperature diff! (%f %f %f %d)"
+ "[DSI] Rear Stereo %s/%s. MP:%d, ST=%u"
+ "[DSI] Rear Stereo: Ch %hhu : Y size %zu stride %zu"
+ "[DSI] Received lpdp ptr is null"
+ "[DSI] Reg dump addr %p size %u"
+ "[DSI] Regs Update Factory Override: Dense"
+ "[DSI] Regs Update Factory Override: Sparse"
+ "[DSI] SLAF Frame, Type=%s, O:%ux%u S:%u, %u usec since last slaf frame"
+ "[DSI] SLAF: %s enabled"
+ "[DSI] SLAF: FovInRaw %ux%u"
+ "[DSI] SLAF: NULL Depth buffer, app requested NormDx, O:%ux%u"
+ "[DSI] SLAF: NULL NormDX buffer, app requested Depth, O:%ux%u"
+ "[DSI] SLAF: clipping output width to %u"
+ "[DSI] SLAF: cnt close=%u far=%u valid=%u, XYWH %d,%d,%u,%u, O:%ux%u, S:%u"
+ "[DSI] SLAF: controlled by FW, AR:%f O:%ux%u"
+ "[DSI] SLAF: defaulting to Depth, O:%ux%u"
+ "[DSI] SLAF: enable %u, Exclusive %u, Preview %ux%u, O:%ux%u"
+ "[DSI] SLAF: sizeof pSlafData=%zu, extra size=%zu typeSize=%zu"
+ "[DSI] SPD CH%d: FC=%d GO2POS=%d LENS[X,Y,Z]=[%f,%f,%f] umPerDac=%f"
+ "[DSI] SPDScale isn't supported, build with PDE_SPD_SCALE_D9X=1 PCE_VERSION=1"
+ "[DSI] ST=%u %s_efl/%s_ps - %s_efl/%s_ps = %f"
+ "[DSI] ST=%u, A(offset)=%f B(multiplier)=%f"
+ "[DSI] Send to SLAF"
+ "[DSI] Sending GMS loop results to %s, ST %u, ConfigID %u"
+ "[DSI] Sensor powered off"
+ "[DSI] Set peridot calib failed, version mismatch: expected %u received %u\n"
+ "[DSI] SetDepthScaleCrop Doesn't Support Probe yet! Skipping..."
+ "[DSI] SetSplitPDMode WIn:%d, HIn:%d, S:%d, MaxDS:%d, SatL:%d, SatR:%d, IsBinning: %d"
+ "[DSI] SetSplitPDMode WIn:%d, HIn:%d, S:%d, MaxDS:%d, SatL:%d, SatR:%d, IsBinning: %d ==> Mode %u"
+ "[DSI] Skipping frame since %s is disabled (%d)"
+ "[DSI] SplitPd RO ROI XYWH: %d %d %d %d, FullROI Offset X: %d Y: %d"
+ "[DSI] Start GMS Loop Epipolar Constraint Fitting, ST=0x%x, D=0x%x, WT %u"
+ "[DSI] Strobe powered off"
+ "[DSI] TBC sequence is active, postponing command (cmd=%u, ctx=%u)"
+ "[DSI] Temp=%f P=%u (%d uSec), T:%d, TR:%d"
+ "[DSI] This pearl flow won't be processed in front stereo ST=%d"
+ "[DSI] Tx Config index: %u"
+ "[DSI] Unable to get CDebugUtility::Instance"
+ "[DSI] Unable to get chip state"
+ "[DSI] Unknown txcfg type %u"
+ "[DSI] Unkown sequence entry type"
+ "[DSI] Unsupported IR frame format"
+ "[DSI] Unsupported configUpdate.currentCmd->type (%u)"
+ "[DSI] Unsupported projectorUpdate.currentCmd->type (%u)"
+ "[DSI] UpdateCalib totalEFLScale %f totalPPOffsetX %f, totalPPOffsetY %f"
+ "[DSI] UpdateCalib totalEFLScale=%f totalPPOffsetX=%f, totalPPOffsetY=%f cfgID=%u"
+ "[DSI] UpdateCalib:"
+ "[DSI] UpdateRegistersForTargetCamera Done! RT:%d Res:%dx%d C:%d %d,%d %d,%d Stat:%d (%d uSec)"
+ "[DSI] Updating PRI cfg for factory mode config 0x%x %u"
+ "[DSI] Updating PRI cfg for mode config 0x%x pris: %u"
+ "[DSI] Updating Rear Calib. ch=%zu, %s camera"
+ "[DSI] Updating SP cfg for mode config 0x%x\n"
+ "[DSI] Updating SPHBM cfg for mode config %u\n"
+ "[DSI] Used output configuration =%d"
+ "[DSI] Using LZ4 Cache DT=%d!"
+ "[DSI] Using Regs Update Tweak: %d"
+ "[DSI] Using uncompressed ref!"
+ "[DSI] Using uncompressed signed V%llu ref! (Offset: %d)"
+ "[DSI] VSPAD init: tmp: %f, init val: %f"
+ "[DSI] Validtae anchor positions failed!!!"
+ "[DSI] [%f][%f][%f]"
+ "[DSI] alignment=0"
+ "[DSI] aux_mode (%u) != AUX_LESS"
+ "[DSI] bnkCfgIdx (%u) is out of bounds (%u)"
+ "[DSI] ch=%zu OL efl %d (%f), distCxyX %f distCxyY %f"
+ "[DSI] ch=%zu OL valid %u, OL efl_valid %u"
+ "[DSI] ch=%zu calib PS %lf, efl %lf"
+ "[DSI] ch=%zu calib principalPoint[0][1] %lf %lf"
+ "[DSI] ch=%zu meta Dist pfl %d, Host apsEfl %d, Host ddfPFL %d (%f)"
+ "[DSI] ch=%zu meta fes output Width, %d height %d"
+ "[DSI] ch=%zu meta fesCropRect %d %d %d %d"
+ "[DSI] ch=%zu meta opticalCenter distCxyX %f distCxyY %f"
+ "[DSI] ch=%zu meta sensorReadOutCropRect %d %d %d %d"
+ "[DSI] ch=%zu tag %d meta Dist ddfPFL %f"
+ "[DSI] ch=%zu update GDC table"
+ "[DSI] ch=%zu, Dist CropWindow %d %d %d %d \n"
+ "[DSI] color pixelSize=%f %f"
+ "[DSI] color pixelSize=0"
+ "[DSI] colorCamera.principalPoint: %f %f"
+ "[DSI] config overrides: forceIR=%d tweaks=%d forceSlaf=%d"
+ "[DSI] config overrides: gmc=%d gmcScan=%d registered=%d cinvid=%d rgbir=%d"
+ "[DSI] configHspbm (%u) || configAnchors (%u)\n"
+ "[DSI] configUpdate.currentCmd is not NULL (type=%u)"
+ "[DSI] configUpdate.currentCmd=%p"
+ "[DSI] cropPDEWidth %u scl %f, resX %u resY %u"
+ "[DSI] curr framesInSuperframe (%u) is different in new sequece (%u)"
+ "[DSI] currFactor=%.03f, currDetla=%d, newFactor=%.03f, newDetla=%d"
+ "[DSI] currOpMode isn't known enum value"
+ "[DSI] emBistSt %u 0x%x"
+ "[DSI] emUserSt %u 0x%x"
+ "[DSI] enough GMC points, (%d %d)"
+ "[DSI] flow type: pearl=%d isp=%d FID=%d submode=%d prio=%d"
+ "[DSI] frameIdx (%u) is larger than tbcnum (%u)"
+ "[DSI] hwUser is invalid"
+ "[DSI] init mode-config cache (index %zu)"
+ "[DSI] level is bigger than PROJ_CONTROL_END"
+ "[DSI] m_pearlCalib->colorExtrinsics.location: %f, %f, %f"
+ "[DSI] m_pearlCalib->colorExtrinsics.rotation:"
+ "[DSI] note sensor temp changed but calib didnt"
+ "[DSI] numOfVbdReadings >= %u"
+ "[DSI] online config request update id %u"
+ "[DSI] pDestination is NULL"
+ "[DSI] pErr = 0"
+ "[DSI] pGmsLoopInputs is NULL"
+ "[DSI] pMem already allocated"
+ "[DSI] pMem is NULL"
+ "[DSI] pMem wasn't released"
+ "[DSI] pPioDma is NULL"
+ "[DSI] pageId: %#x | %s | delta: %d us | timestamp: %llu"
+ "[DSI] pageId: %#x | %s | timestamp: %llu"
+ "[DSI] pixSize: %f pixEFL: %f ResX,Y: %u %u"
+ "[DSI] pixelSize %f"
+ "[DSI] property bypass PCE for splitPD: %d"
+ "[DSI] scaleXY %f %f, PSNVM %f, PS after scale %f"
+ "[DSI] segment #%02zu: &ptr =%p, size =%6zu, align =%3zu, totSize =%7zu, userTag =%s"
+ "[DSI] shifting all anchors one pixel up"
+ "[DSI] size=0"
+ "[DSI] slaf overrides: mode=%d depthType=%d stride=%d WxH=%dx%d TS=%llu"
+ "[DSI] syncTag %u, GmsPoint %u ResY %d tOffsetX %d upscale %f WT %u"
+ "[DSI] syncTag %u, GmsPoint %u ResY %d tOffsetX %d upscale %f isWT %u"
+ "[DSI] sysID and pGmsLoopInputs->isWT do not match"
+ "[DSI] tbcSeqParams.frameIdxTbcSequence != 0"
+ "[DSI] tmp is larger than (pMem + totSize)"
+ "[DSI] totalPPOffsetX=%f totalPPOffsetY=%f totalEFLScale=%f"
+ "[DSI] userParams cont: isPacked:%d, inputBits:%d, disableTargetCamDistort:%d, colorScale:%f"
+ "[DSI] userParams: fp16 %d, nan %u, BitExact:%d, stride:%d, LSB:%d, Packed:%d, inputBits:%d"
+ "[DSI] version (%llu) isn't equal to %u"
+ "[DSI] wrong configUpdate.state"
+ "[DSI]: Could not allocate mode config"
+ "[EN=%d] type is %d regOffset is 0x%x, baseAddr=0x%lx\n"
+ "[FE] Got a source Done Handler for %d and irq 0x%x\n"
+ "[FE] No User is listening to this source %d\n"
+ "[H17 ProRes RAW], set MSMLNRLumaKnobValue0 = 64\n"
+ "[H17 ProRes RAW], set MSMLNRLumaKnobValue1-5 = 32\n"
+ "[H17 ProRes RAW], set TFKnobValue=96\n"
+ "[HW to DRAM]Skipping Section:%d Action:%d\n"
+ "[J41y FFC (PA-IMX614)] MSTF(RAW) gainTotal = %.2f, stdScalePlusHigh = %.2f\n"
+ "[J41y FFC (PA-IMX614)] MSTF(RAW) gainTotal = %.2f, stdScalePlusLow  = %.2f\n"
+ "[J41y FFC (PA-IMX614)] RAW mode apply BCF LPF to reduce grainy noises.\n\tknobValueBcfLpfG=%d, knobValueBcfLpfRB=%d.\n"
+ "[J490 FFC (PA-IMX614)] MSTF(YUV), bTNRStrengthHighEn=%d, gainTotal = %f\n"
+ "[J8xp RFC (IN-IMX405)] MSTF(RAW) stdScale = [%.2f, %.2f, %.2f, %.2f, %.2f, %.2f]\n"
+ "[LACCMATCH] Received LACCMATCH_STATUS0 source %d, irq 0x%x\n"
+ "[LaccMatch] No User is listening to cvd_LACCMATCH_LaccMatchInterCnt_StatusInt0_Halt\n"
+ "[MB] - CAP CALC: g200=%d g800=%d gFreq=%f cStep=%f capRaw=%d capF=%f"
+ "[MB] - MB_REG_R_AFE_CSENSE_RX_TIA_GAIN_MEMADDR:  %02x%02x%02x%02x\n"
+ "[MB] - MB_REG_R_AFE_RX_GAIN_CAL_MEMADDR:  %x"
+ "[MB] - MB_REG_R_CSE_CAP_THRESH_1_2_MEMADDR:  %02x%02x%02x%02x\n"
+ "[MB] - MB_REG_R_CSE_CAP_THRESH_2_3_4_MEMADDR:  %02x%02x%02x%02x\n"
+ "[MB] - MB_REG_R_CSE_CAP_THRESH_4_MEMADDR:  %02x%02x%02x%02x\n"
+ "[MB] - MB_REG_R_CSE_SCAN_RATE_SEL_MEMADDR:  %02x%02x%02x%02x\n"
+ "[MB] - MB_REG_R_CSE_STATUS_MEMADDR:  %x"
+ "[MB] - MB_REG_R_CSE_WINDOW_SLOPE_MEMADDR:  %02x%02x%02x%02x\n"
+ "[MB] - MB_REG_R_MB_ASIC_REVID_MEMADDR:  %02x%02x%02x%02x\n"
+ "[MB] - scan status:  %x\n"
+ "[MLVNR] Enabled in current frame! ispDGan=%.2f, TotalGain=%.2f"
+ "[MotionDetection] MD already init\n"
+ "[MotionDetection] MD rcv disable CMD\n"
+ "[MotionDetection] MD rcv enable CMD\n"
+ "[MotionDetection] writing data to motionDensity[%zu] = %f\n"
+ "[MotionDetection]Threshold CMD (%d ->%d)\n"
+ "[MotionDetection]frame# %d,isFrameContinus = %d, interval = %llu ms\n"
+ "[REG] tempPtr(%p) doesn't pointing to the end of the buffer(%p)\n"
+ "[REG] used memory size(0x%lx) doesnt match with allocated memory size(0x%lx)\n"
+ "[ResMgr] AFEProc pipe %d Mode %s"
+ "[ResMgr] Reserved Ch %d Stats %d mode %d %s"
+ "[ResMgr] Reserved Ch %d pipe %u, bStaitc %d mode %s"
+ "[ResMgr] Stats pipe %d Mode %s"
+ "[ResMgr] ch %d AFEProc %d Mode %s"
+ "[ResMgr] ch %d AFEProc Manual streaming mode %d"
+ "[ResMgr] ch %d FEP %d"
+ "[ResMgr] ch %d FEP2nd %d"
+ "[ResMgr] ch %d Manual streaming mode %d"
+ "[ResMgr] ch %d VC PipeId %d"
+ "[ResMgr] ch %d, Invalid Raw MLVNR SrcDMAIn %d"
+ "[ResMgr] ch %d, Invalid Raw SrcDMAIn %d"
+ "[ResMgr] pipe %d, Invalid Stats SrcDMAIn %d"
+ "[ResMgr]Get Ch %d Stats %d"
+ "[ResMgr]Get Ch %d Stats default %d"
+ "[TABLE] tempPtr(%p) doesn't pointing to the end of the buffer(%p)\n"
+ "[TABLE] used memory size(0x%lx) doesnt match with allocated memory size(0x%lx)\n"
+ "[TRG] Got a source Done Handler for %d and irq 0x%x\n"
+ "[TRG] No User is listening to this source %d\n"
+ "[VisegDSVR]"
+ "[fkong] pixelSize: %f\n"
+ "[iPads FFC (PA-IMX614, EW-IMX814)] YSH totGain=%.2f, currShKnobLevel=%d, yshKnobScaleb=%.2f."
+ "[iPads RFC (IN-IMX405)] YSH totGain=%.2f, currShKnobLevel=%d, yshKnobScaleb=%.2f."
+ "[iPads RFC (IN-IMX405)] reduce YSH for sensor binned mode.\n"
+ "[ipc] Send %llu"
+ "[ipc] pCb %llu"
+ "[preview in still] send bkt frame to preview processing fr=%d"
+ "[preview in still] send bkt frame to preview processing fr=%d ch=%zu"
+ "[rdar://125999161] expand Qsub false color correction for all chroma alignments"
+ "[rdar://127012231] further making FCF desaturation more conservative."
+ "[rdar://129529304] additional tuning to reduce the desaturation artifact on human faces"
+ "[rdar://134580526] making FCF filt more conservative under rawMode."
+ "[rdar://93997956] D7x/D8x Wide IMX803, D9x Wide IMX903, D4y Wide IMX904 sensor-binned purple fringing regression: use very aggressive FCF[0] to mitigate it."
+ "[rdar://95047175] D7x Wide IMX803 Qsub false color regression: use aggressive FCF[0][1] filt."
+ "[rdar://96463553] D7x Wide IMX803 Qsum false color regression: use aggressive FCF[0][1] desat."
+ "[rdar://96463553] D7x Wide IMX803 Qsum false color regression: use aggressive FCF[0][1] filt."
+ "[s:%d][a:%d]len(0x%x-0x%x=0x%x)==mappedLen(0x%x-0x%x=0x%x)"
+ "_CurrOpMode < CISP_PERIDOT_NUM_OF_OP_MODES"
+ "_Done_ch_"
+ "_ModeCfgsArr[_CurrOpMode] != nullptr"
+ "__null == instance"
+ "_ch_"
+ "_data_storage != NULL"
+ "_maskCount"
+ "_maskUnmaskMutex != (FFWMUTEX)0"
+ "_rawWidth %u _rawHeight %u"
+ "a.numEntries == b.numEntries"
+ "aSharedGeomTransformCtx != 0"
+ "aa65f32bd5"
+ "abnormal motion"
+ "acAttrReduceBlink"
+ "acAttrReduceSmile"
+ "acAttrReduceYaw"
+ "acCropResizeGenerateConfig"
+ "acDetCategoryFromIsp"
+ "acDetCategoryToIsp"
+ "acNonMaxSuppression"
+ "acNonMaxSuppressionHandIntra"
+ "acRemoveHeadOverlapBoxes"
+ "acRemoveOverlapBoxes"
+ "acTentativeObjectSetUpMunkresCost"
+ "acTentativeTrkObjectAssocCore"
+ "acTrkFullBodyAssocTrkDet"
+ "acTrkFullBodyRemoveYoungOverlapObjects"
+ "acTrkGroupAssign"
+ "acTrkGroupAssignGetTempBuffers"
+ "acTrkGroupSetUpMunkresCost"
+ "acTrkHandAssocTrkDet"
+ "acTrkHandRemoveYoungOverlapObjects"
+ "acTrkLGroupIoUCore"
+ "acTrkLabelCenterSizeSmoothing"
+ "acTrkObjectAssocCenterDis"
+ "acTrkObjectAssocCore"
+ "acTrkObjectAssocTrkDet"
+ "acTrkObjectAssocTrkDetGetTempBuffers"
+ "acTrkObjectFeatureAssocCore"
+ "acTrkObjectPickDet"
+ "acTrkObjectPriority"
+ "acTrkObjectRemoveOldCrossClassOverlapObjects"
+ "acTrkObjectRemoveOldOverlapObjects"
+ "acTrkObjectRemoveYoungOverlapObjects"
+ "accVEsemanticScratch"
+ "acclerationZ %f count %d zSum %f\n"
+ "ack->err == FFW_SUCCESS"
+ "ackSem != (SEMA)0"
+ "acquire_mutex"
+ "acresult->numFaces<= CISP_AC_MAX_RESULT_FACES"
+ "acresult->numObjects <= (CISP_AC_MAX_RESULT_OBJECTS + CISP_AC_MAX_RESULT_HANDS)"
+ "acresult->numSaliencyObjects <= CISP_AC_MAX_RESULT_SALIENCY_OBJECTS"
+ "actBufSize > (sizeof(sCIspCmdChGeneralProcessListHeader) + pActionListHdr->tot * sizeof(sCIspCmdChGeneralProcessAction))"
+ "actBufSize > sizeof(sCIspCmdChGeneralProcessListHeader)"
+ "actBufSize[nChannelId] > (sizeof(sCIspCmdChGeneralProcessListHeader) + pActionListHdr[nChannelId]->tot * sizeof(sCIspCmdChGeneralProcessAction))"
+ "actBufSize[nChannelId] > sizeof(sCIspCmdChGeneralProcessListHeader)"
+ "action < LC_BACKGROUND_ACTION_COUNT"
+ "actionNbr should be non-zero since it's from NoRestrict table\n"
+ "activeChCnt >= actualActiveChCnt && activeChCnt > 0 && actualActiveChCnt > 0"
+ "activeRegionStart[%d][%d]XY=%d %d"
+ "activeTMSyncGroup[groupID].chStartedCount > 0"
+ "activeTMSyncGroup[i].chStartedCount == 0"
+ "activeWidth > 0"
+ "actualFESZoomX == ZOOM_FACTOR_FIXED_POINT_IDENTITY || actualPYRZoomX == ZOOM_FACTOR_FIXED_POINT_IDENTITY"
+ "actualFESZoomY == ZOOM_FACTOR_FIXED_POINT_IDENTITY || actualPYRZoomY == ZOOM_FACTOR_FIXED_POINT_IDENTITY"
+ "actualPTS %f rollingShutterSkewMs: %f exposureTime %f\n"
+ "actualScaleFactor > 0.5f && actualScaleFactor < 2.0f"
+ "actualSizeInWord = %d\n"
+ "actualSizeInWord = %d, NO DMA input to M3\n"
+ "actualSizeInWord = %d, enable DMA input to M3: %p\n"
+ "actualSizeInWord = %d, use GRIDMODE_CPU\n"
+ "actualSizeInWord = %d, use GRIDMODE_DDA\n"
+ "adLandscapePost != nullptr"
+ "adLandscapePostCfg != nullptr"
+ "adLandscapePre != nullptr"
+ "adLandscapePreCfg != nullptr"
+ "adPost"
+ "adPostInputBuf.bytes == adLandscapePostDcnOutput_bin1_len"
+ "adPostInputBuf.bytes == adPostDcnOutput_bin1_len"
+ "adPostInputBuf.data"
+ "adPre"
+ "adPreProcParams.adNetInputBufferDescs[i].channels == adLandscapePreProcParams.adNetInputBufferDescs[i].channels"
+ "adPreProcParams.adNetInputBufferDescs[i].height == adLandscapePreProcParams.adNetInputBufferDescs[i].height"
+ "adPreProcParams.adNetInputBufferDescs[i].pixelFormat == adLandscapePreProcParams.adNetInputBufferDescs[i].pixelFormat"
+ "adPreProcParams.adNetInputBufferDescs[i].width == adLandscapePreProcParams.adNetInputBufferDescs[i].width"
+ "adPreProcParams.numAdNetInputs == adLandscapePreProcParams.numAdNetInputs"
+ "adaptiveDR.originalEITUpdate.exposure > 0"
+ "adaptiveDRRange.maxExposureTradeoffGain > 0"
+ "add element: max exp=%.2f x gain=%.2f / end of table is %.2f x %.2f"
+ "addDescriptor"
+ "addr"
+ "addr != 0"
+ "addr != NULL"
+ "addr == (addr >> 6 << 6)"
+ "addr == (addr >> 7 << 7)"
+ "addr=%p"
+ "addrEnd >= addrStart"
+ "address != 0"
+ "address needs match: 0x%lx, 0x%lx"
+ "adjs %.3f %.3f %.3f %.3f\n"
+ "adjustGain=%d %d %d maxGain=%d maxGainCap=%d"
+ "adjusting bgNumPts to %d, fgNumPts is %d ..."
+ "adjusting fgNumPts to %d ..."
+ "adrcState.tiles_vector_sumWeight > 0"
+ "aeFullResSize.numTilesX <= FULL_SIZE_AE_TILES_X"
+ "aeFullResSize.numTilesY <= FULL_SIZE_AE_TILES_Y"
+ "aeInput"
+ "aeInput != NULL"
+ "aeInput->pCameraControlROI->height + aeInput->pCameraControlROI->y <= CISPCMD_WINDOW_NORMALIZATION_MAX"
+ "aeInput->pCameraControlROI->height > 0"
+ "aeInput->pCameraControlROI->width + aeInput->pCameraControlROI->x <= CISPCMD_WINDOW_NORMALIZATION_MAX"
+ "aeInput->pCameraControlROI->width > 0"
+ "aeInput->pCameraControlROI->x <= CISPCMD_WINDOW_NORMALIZATION_MAX"
+ "aeInput->pCameraControlROI->x >= 0"
+ "aeInput->pCameraControlROI->y <= CISPCMD_WINDOW_NORMALIZATION_MAX"
+ "aeInput->pCameraControlROI->y >= 0"
+ "aeInput->pMeta"
+ "aeInput->pMeta != NULL"
+ "aeParams.requestRejected == false"
+ "aeRequestType %u "
+ "aeStats != NULL"
+ "aeStats->aeTilesInRawHeight > 0"
+ "aeStats->aeTilesInRawWidth > 0"
+ "aeTableAllPresets.numPreset < MAX_AE_TABLE_PRESET"
+ "aeTableAllPresets.numPreset <= MAX_AE_TABLE_PRESET"
+ "aeUnit[CIC_UPDATE_UNIT_EXPOSURE]->payload.e.splitPDOn == false"
+ "afBayerYTile != 0"
+ "afBayerYTileOffset %d, size %d"
+ "afBayerYTileSecondary != 0"
+ "afCamYTile != 0"
+ "afCamYTileOffset %d, size %d"
+ "afCamYTileSecondary != 0"
+ "afDepthSrc.type == pData->type"
+ "afDepthSrcFrameRateDecimationFactor != 0"
+ "afMode <= CS40L62_MODE_COUNT"
+ "afMode <= LC_AF_ONCHIP_CONTROLLER_MODE_TOT"
+ "afPDAFFocusStable"
+ "afRawTile != 0"
+ "afRawTileOffset %d, size %d"
+ "afRawTileSecondary != 0"
+ "afStatsHdr != 0"
+ "afStatsWin != 0"
+ "afTileStartX %d Y %d width (%d x %d)\n"
+ "afTimerSema_end"
+ "afTimerSema_start"
+ "afWindowCnt <= AF_STATS_WINDOW_TOT"
+ "af_b3_code != nullptr"
+ "af_sz_to_pos_gain_f"
+ "af_z_um"
+ "afe != nullptr"
+ "afe2ModeOTF == true"
+ "afeDmaBuffer != nullptr"
+ "afeDmaEnable %u\n"
+ "afeGeom.cellCountY >= delayV + 1"
+ "afeGeom.cellStartY < afeGeom.cellCountY"
+ "afeGeom.initH == 0"
+ "afeGeom.initH == 0 || afeGeom.initH == 1"
+ "afeGeom.initV == -1"
+ "afeGeom.initV == 2"
+ "afeGeom.initV == 2 || afeGeom.initV == 3"
+ "afeIndex >= 0 && afeIndex < MAX_ISP_AFEPROC_RESOURCES"
+ "afeInfo.rects[k].isEmpty()"
+ "afeMax[k].isEmpty()"
+ "afeProc afeDmaEnabled %u enabled %u afeDmaToHost %u buffer %p"
+ "afeProc pipe %u, dma %u, enable %u, ch %zu"
+ "afeProcId < VFLOWH17_MAX_AFEPROC"
+ "afeProcPipe < AFEPROC_PIPE_TOT"
+ "afeRect.containsRect(crop)"
+ "afeTuning.sizeMaxX % this->focusGrid.spacingX == 0"
+ "afeTuning.sizeMaxY % this->focusGrid.spacingY == 0"
+ "afrawTileoffset %d afrawTileSize %d afbayeryTileStatSize %d afCamYTileStatSize %d total %d\n"
+ "afrawTileoffset %d size %d %d %d total %d\n"
+ "after matrix transfer:"
+ "ag %d preISPDGain %d"
+ "agileClocking.bParamsSet"
+ "aicam result size %zu"
+ "aispSource < INTERRUPT_SRC_H17_TOTAL"
+ "aispSource <= INTERRUPT_SRC_H17_TOTAL"
+ "aispSource >= INTERRUPT_SRC_H17_START"
+ "algo"
+ "alignment != 0"
+ "all prev=false => HDR Score = 0"
+ "alloc"
+ "alloc->startAddr()"
+ "allocAdaptiveDRDebug"
+ "allocAdaptiveDRMeta"
+ "allocDriver"
+ "allocFusionObjects"
+ "allocIMUObject"
+ "allocate"
+ "allocate FEP preview buffers %zu"
+ "allocateTone"
+ "allocated == 0"
+ "allocated == false"
+ "allocated size(%ld) needs larger than (%ld)"
+ "allocated size(%ld) needs larger than (%zu)"
+ "allocated: net%u type%u buf%u dep %u size %u addr %zx"
+ "alphaBetaPrecise < ( (double)(1 << alphaBetaWidth) - 1 ) / (double)(1 << alphaBetaPrecision) && \"Distortion scale is too big to fit register\""
+ "analyzeSpatialStats"
+ "anchorPoint < NUM_CCT_REFERENCE"
+ "aneClient"
+ "aneProgramTbl[i].memPtr"
+ "aneProgramTbl[i].sema != (SEMA)0"
+ "angle\n"
+ "anst ctxid %zu"
+ "anst frame decimation"
+ "anst netout name[%u]: %s"
+ "anst network input size %u %u"
+ "anst network inter size %u"
+ "anst network output size %u"
+ "anst procedureId=%u"
+ "anst result:"
+ "anst stride %zu size %zu"
+ "anstDebugDataParam[i].size > 0"
+ "anstDone != (SEMA)0"
+ "anstInput"
+ "anstNames[nameidx]"
+ "anstRun"
+ "anstTimeIndex %u"
+ "anstTime[%s] %llu"
+ "anstTotal[%s] total %llu avg %llu"
+ "anstout"
+ "any_invalid = %s"
+ "appendCornerFaces = %d\n"
+ "apply Stop continousSync %d camIndex %zu clock master %u bPendingStop %d pendingStopChMask %#x"
+ "apply2ReqId %llu, currReqId %llu curFC %llu reqM 0x%x"
+ "apsEFL=%f"
+ "apsEFL=%f vs %f"
+ "apsModelLinearB=%f"
+ "apsModelLinearB=%f vs %f"
+ "apsModelLinearM=%f"
+ "apsModelLinearM=%f vs %f"
+ "apsObjectDistance=%f"
+ "apsObjectDistance=%f vs %f"
+ "apsOpticalOffset=%f"
+ "apsOpticalOffset=%f vs %f"
+ "apsPFL=%.12f"
+ "apsPFL=%.12f vs %.12f"
+ "apsPosition=%f"
+ "apsPosition=%f vs %f"
+ "apsSample != NULL"
+ "aps_mode"
+ "arg1 < 6"
+ "arg2 < 16 && (arg3 == 0 || (arg3 >= 375 && arg3 <= 2000))"
+ "array != 0"
+ "arrayActive != 0"
+ "arrayEmptyBuffer != 0"
+ "array[index].ch != 0"
+ "array[index].ch == 0"
+ "array[index].inuse == false"
+ "associationPostProc"
+ "associationPreProc"
+ "attention"
+ "attnInput.rowBytes == 64"
+ "attnWriteResult"
+ "attr crop config size %u"
+ "attr netout name[%u]: %s"
+ "attr network input len %u"
+ "attr network output len %u"
+ "attr output size %u"
+ "attr procedure id %u"
+ "attr result:"
+ "attrNames[nameidx]"
+ "attrRun"
+ "attrTimeIndex %u"
+ "attrTime[%s] %llu"
+ "attrTotal[%s] total %llu avg %llu"
+ "attrout"
+ "autoSuspendMask != 0"
+ "aux < MaxNumPhyLanesGet()"
+ "auxPyrProcDmaEn & FLOWH17_DMA_ID_BIT_MASK(AuxPyrProcDmaDstLumaA)"
+ "aux_mode == AUX_LESS"
+ "availFepId < ISP_RESOURCE_FEP_TOT"
+ "available < buffers"
+ "available == tot"
+ "aveFlashOffLux %f aveDiff %f flatWeight %f\n"
+ "avgBrightnessSize.numTiles > 0"
+ "avgBrightnessSize.numTilesX <= AE_MATRIX_MAX_VER_COUNT"
+ "avgBrightnessSize.numTilesX <= AE_YMAP_TILES_X"
+ "avgBrightnessSize.numTilesX <= CISP_FE_NUM_MAX_TILES_X"
+ "avgBrightnessSize.numTilesY <= AE_MATRIX_MAX_HOR_COUNT"
+ "avgBrightnessSize.numTilesY <= AE_YMAP_TILES_Y"
+ "avgBrightnessSize.numTilesY <= CISP_FE_NUM_MAX_TILES_Y"
+ "avgSNR = %f, txWarpDiffRatioTh = %f\n"
+ "awb primary channel %zu is the skipped channel"
+ "awbFn=%hd skin=%6.2f %6.2f white=%6.2f %6.2f num=%hd "
+ "awbHiResWindowStats != nullptr"
+ "awbHistStats != nullptr"
+ "awbPrimary exist %zu(tag %d) ch %zu(tag %d)"
+ "awbPrimaryChannel %zu expected tag: %x actual: %x"
+ "awbPrimaryChannel == -1lu"
+ "awbSchemeRetVal"
+ "awbStable=%hu"
+ "awbStatsHdr != nullptr"
+ "awbTileStats != nullptr"
+ "awbWindowStats != nullptr"
+ "ax out of bounds!"
+ "axiErrorHandle != 0"
+ "axis < AXIS_COUNT"
+ "axis == AXIS_AF_Z"
+ "ay out of bounds!"
+ "b2"
+ "bCTFCircularEn"
+ "bCTFCircularEnStill"
+ "bCheck"
+ "bCurrMSTFScale0En is 0 but mstfScale0TFStrength is 255"
+ "bEnableMesh:%u, bEnableLTM:%u, bEnableLRME:%u"
+ "bFEPDualBankWrEn"
+ "bFound"
+ "bFoundFrame == false"
+ "bIRPendingRestart == false"
+ "bIRRGBStereoDepthEn %u"
+ "bLaccEnable %u bVioOccupied %u\n"
+ "bLaccEnable=%u bVioOccupied=%u\n"
+ "bLuxlevelDetection %u ch %zu"
+ "bMSGpass"
+ "bMatrixValid = %d, ISP-Estimation, tsRANSAC = %f ms\n"
+ "bMatrixValid=%d, mNumInliersFound=%d"
+ "bMultiCamSession %d enable %d"
+ "bMultiCamSession && msChMask"
+ "bMultiCamSession == true"
+ "bPendingStop %d pendingStopChMask %#x"
+ "bReflow? pMultiPassInfo->multiPassMode == MULTI_PASS_MODE_PRESERVE_PEDESTAL_CAPTURE : true"
+ "bSkipped == true"
+ "bSplitSIFRFrame"
+ "bStillCap"
+ "bStillCap ? !pDescr->paramNoiClr.bLastHithFromStill || !rc : true"
+ "bUseBESforPDEScaling"
+ "bVioOccupied = %u"
+ "babyStep=%.3f, %.3f stable=(dR=%.3f <? %.3f && dB=%.3f <? %.3f)"
+ "background luxExposure %f  gain %f combined %f\n"
+ "backgroundTarget %d raw ratio %f\n"
+ "backgroundTargetedEit %f exposure %f=%.4f\n"
+ "band >= 0 && band < 6"
+ "bank %d"
+ "bank %d  %p %zx index0 %d"
+ "bank %d address 0x%zx"
+ "bank < REGISTER_BANK_SELECTION_TOTAL"
+ "bank < REGISTER_BANK_TOTAL"
+ "bankId < 2"
+ "bankId < mBankTot"
+ "bankId < nbrOfBanks"
+ "bankId == 0"
+ "base=%p, offset=0x%lx, addrHi=0x%x"
+ "base=%p, offset=0x%x\n"
+ "baseAddr != nullptr"
+ "baseAddr 0x%p, regAddr 0x%llx, write 0x%x"
+ "baseAddr=%#zx"
+ "baseController != nullptr"
+ "baseForwardCoef[0]=%.12f"
+ "baseForwardCoef[0]=%.12f vs %.12f"
+ "baseForwardCoef[0]x1M=%.12f"
+ "baseForwardCoef[1]=%.12f"
+ "baseForwardCoef[1]=%.12f vs %.12f"
+ "baseForwardCoef[1]x1M=%.12f"
+ "baseForwardCoef[2]=%.12f"
+ "baseForwardCoef[2]=%.12f vs %.12f"
+ "baseForwardCoef[2]x1M=%.12f"
+ "baseForwardCoef[3]=%.12f"
+ "baseForwardCoef[3]=%.12f vs %.12f"
+ "baseForwardCoef[3]x1M=%.12f"
+ "baseForwardCoef[4]=%.12f"
+ "baseForwardCoef[4]=%.12f vs %.12f"
+ "baseForwardCoef[4]x1M=%.12f"
+ "baseForwardCoef[5]=%.12f"
+ "baseForwardCoef[5]=%.12f vs %.12f"
+ "baseForwardCoef[5]x1M=%.12f"
+ "baseForwardCoef[6]=%.12f"
+ "baseForwardCoef[6]=%.12f vs %.12f"
+ "baseForwardCoef[6]x1M=%.12f"
+ "baseForwardCoef[7]=%.12f"
+ "baseForwardCoef[7]=%.12f vs %.12f"
+ "baseForwardCoef[7]x1M=%.12f"
+ "baseOffset != 0"
+ "bayerProcDmaEn == bayerProcDmaEnabled"
+ "before matrix transfer:"
+ "below limit mainflashTargetDuration %.3f exposureTargetedDuration %.3f gain %.2f\n"
+ "bes enable for preview %d YCC %d"
+ "bes not enabled!"
+ "besCropInfo[channel].width > 0 && besCropInfo[channel].height > 0 && besCropInfo[channel].x >=0 && besCropInfo[channel].y >= 0"
+ "besInFOV cropX %d crop Y %d cropW %d cropH %d\n"
+ "besInFov:{%d %d %d %d} besInRect:{%d %d %d %d} out:{%d %d}"
+ "besInLogicalWidth Left/Right: %f, %f \n"
+ "besInRect cropX %d crop Y %d cropW %d cropH %d\n"
+ "besInStripWidth Left/Right: %d, %d \n"
+ "besInput < BES_PROC_DMA_TOTAL"
+ "besOutStripWidth Left/Right: %d, %d; outExtraCols: %d\n"
+ "besProcessedCnt = %d\n"
+ "besScalerId <= VFLOWH17_MAX_BES_SCALERS"
+ "bfrBase=0x%x bfrBlks=0x%x sttBase=0x%x sttPages=0x%x configTunable=0x%x\n"
+ "bgGainCoeff   = %6u %6u %6u \n"
+ "bgNum =%d\n"
+ "bgNum =%d fgNum =%d\n"
+ "bi-directional list %d"
+ "biDirMatchListBaseAddrHigh = 0x%x"
+ "biDirMatchListBaseAddrLow = 0x%x"
+ "bias != 0"
+ "bin == 0 || bin == 1 || bin == 2"
+ "binFactorIn != 0"
+ "binFactorOut != 0"
+ "binPMWidth = %d, binPMheight = %d"
+ "bindStatus == 0"
+ "binning factor W=%d H=%d, intrinsicsPPCurrentConfig :[%f %f]"
+ "binningModeSupported"
+ "binningX == 1"
+ "binningY == 1"
+ "bitDepth != 0"
+ "blinkThreshold <= 100"
+ "blockArray != 0"
+ "blockArray[0] = %p\n"
+ "blockArray[0] = %p, blockArray[1]=%p\n"
+ "blockArray[1]=%p\n"
+ "blockArray[dBlock] != NULL"
+ "blockSizeRemainder[%d][%d]value=%d"
+ "block[%d][%d]XY=%d %d"
+ "blocks <= CBuffer::idTot"
+ "blurMAvgScoresPerObjectPerFilter.blurConf != 0"
+ "blurMAvgScoresPerObjectPerFilter.blurExtent != 0"
+ "blurMAvgScoresPerObjectPerFilter.sharpness_L1 != 0"
+ "blurMAvgScoresPerObjectPerFilter.sharpness_L2 != 0"
+ "blurScore %f gyroHomography[2] %f gyroHomography[5] %f iirNumDetKeys %f ransacInlierRadiusPx %f UpdatedRansacInlierRadiusPx %f\n"
+ "bmBufferDequantizeInt8"
+ "bmBufferDequantizeUInt8"
+ "bmBufferPixelAtFloat"
+ "bmBufferPixelAtUInt16"
+ "bmBufferPixelAtUInt8"
+ "bmBufferPixelSize"
+ "bmBufferResizeCoordConvert"
+ "bmBufferResizeCoordConvertReversed"
+ "bmMunkres"
+ "bmMunkresGetTempBuffers"
+ "bmMunkresMaxAssignments"
+ "bmMunkresMaxAssignmentsGetTempBuffers"
+ "bmMunkresSubtractMinPerCol"
+ "bmMunkresSubtractMinPerRow"
+ "bmMunkresUpdateCost"
+ "bnCalcCoilRes.B1_CALC_COIL_RES_b.b1_coil_res_fault == CS40L62_MODE00_AOR_B1_CALC_COIL_RES_B1_COIL_RES_FAULT_NOT_FAULTED"
+ "bnCalcCoilRes.B2_CALC_COIL_RES_b.b2_coil_res_fault == CS40L62_MODE00_AOR_B2_CALC_COIL_RES_B2_COIL_RES_FAULT_NOT_FAULTED"
+ "bnCalcCoilRes.B3_CALC_COIL_RES_b.b3_coil_res_fault == CS40L62_MODE00_AOR_B3_CALC_COIL_RES_B3_COIL_RES_FAULT_NOT_FAULTED"
+ "bnkCfgIdx < CISP_PERIDOT_NUM_BNKCFG"
+ "body~=face + decent confidence(%u) => keep ANFD=%d"
+ "boot pc = 0x%x hffLaccVersion %u\n"
+ "bootArgs != 0"
+ "bootArgs[16]=%p\n"
+ "bootBootHalt = 0x%x"
+ "bootBootPC = 0x%x"
+ "bootSequence.mutexBoot != (FFWMUTEX)0"
+ "bootpc = 0x%x bLaccEnable %u version %u"
+ "bracketing mode is unified but tuning set is not present!!!"
+ "bracketingGammaTmpBuffer"
+ "bright ambient => aeMetaData->luxLevel = LEDOff.fLux=%.2f"
+ "buf != nullptr"
+ "buf && len"
+ "buf && num"
+ "buf && size"
+ "buf w %d h %d s %zu fm %d p %p active %d"
+ "bufAllocatedCount + realtimeBufCount + deferalBufCount == totalReqBufCount"
+ "bufIn"
+ "bufInFrame"
+ "bufInFrame->Size() >= (inWidth * inHeight * bpp)"
+ "bufInHueMap->DataPointer(0)"
+ "bufInHueMapSifr"
+ "bufInRaw->DataPointer(0)"
+ "bufList[i]->stride % 64 == 0"
+ "bufMsg->hdr.len <= sizeof(msg)"
+ "bufNbr <= maxAneIpcBufMsg"
+ "bufNbr=%d, maxAneIpcBufMsg=%d"
+ "bufOutAlgo"
+ "bufOutClrbeTile"
+ "bufOutFrame"
+ "bufOutFrame->DataPointer(0)"
+ "bufOutFrame->DataPointer(1)"
+ "bufOutFrame->Size(0) >= (pOutConfig->width * pOutConfig->height)"
+ "bufOutHM"
+ "bufOutHith"
+ "bufOutMth"
+ "bufOutPde"
+ "bufRefLast[i]->GetRetain() <= 1"
+ "bufSBSLow"
+ "bufSize %d Req size %lu"
+ "buf_fmt"
+ "buf_ptr"
+ "buff.buffers == 2"
+ "buff.buffers == 3"
+ "buff.ref[0] != nullptr"
+ "buff.ref[1] != nullptr"
+ "buff.size == sizeof(sFrameExtraInfo)"
+ "buffPointer"
+ "buffPool != 0"
+ "buffPool[BufferPoolPin(ch, CMOTIONESTIMATOR_OUTPUT_PORT_0, CMOTIONESTIMATOR_POOL_VISPIPE_HAT)]"
+ "buffPool[BufferPoolPin(chId, FLOWBASE_OUTPUT_PORT_0,FLOWBASE_BUFFER_POOL_OUTPUT_ALGO_BUF)]"
+ "buffPool[BufferPoolPin(pChInfo->chId, FLOWBASE_OUTPUT_PORT_0, VFLOWH17_BUFFER_POOL_HITH)]"
+ "buffPool[BufferPoolPin(pChInfo->chId, FLOWBASE_OUTPUT_PORT_0, VFLOWH17_BUFFER_POOL_PDE)]"
+ "buffPool[BufferPoolPin(pChInfo->chId, FLOWBASE_OUTPUT_PORT_0, VFLOWH17_BUFFER_POOL_RAW_RES)]"
+ "buffPool[BufferPoolPin(pChInfo->chId, FLOWBASE_OUTPUT_PORT_0,VFLOWH17_BUFFER_POOL_MTH_OUTPUT)]"
+ "buffPool[CIC_POOL_HIRES_RAW] != 0"
+ "buffPool[bufPoolPin]"
+ "buffPool[bufferPoolIndex]"
+ "buffPool[bufferPoolPin]"
+ "buffPool[outBufpoolPin]"
+ "buffPool[poolPinScale0]"
+ "buffPool[poolPinScale1]"
+ "buffPool[poolPinScale2to5]"
+ "buffPool[poolPin]"
+ "buffPools[H17BUFFPOOL_AUXSCL_PYR_SCALE0]"
+ "buffPools[H17BUFFPOOL_AUXSCL_PYR_UV]"
+ "buffPools[H17BUFFPOOL_AUXSCL_PYR_Y]"
+ "buffPools[H17BUFFPOOL_AUXSCL_PYR_Y] != 0"
+ "buffPools[H17BUFFPOOL_IR_PDE]"
+ "buffPools[H17BUFFPOOL_MLAF]"
+ "buffPools[H17BUFFPOOL_PYROUTPROC0_SCALE0]"
+ "buffPools[H17BUFFPOOL_PYROUTPROC0_SCALE1]"
+ "buffPools[H17BUFFPOOL_PYROUTPROC0_SCALE2TO5]"
+ "buffPools[H17BUFFPOOL_PYROUTPROC1_SCALE0]"
+ "buffPools[H17BUFFPOOL_PYROUTPROC1_SCALE0_STILL]"
+ "buffPools[H17BUFFPOOL_PYROUTPROC1_SCALE1]"
+ "buffPools[H17BUFFPOOL_PYROUTPROC1_SCALE1_STILL]"
+ "buffPools[H17BUFFPOOL_PYROUTPROC1_SCALE2TO5]"
+ "buffPools[H17BUFFPOOL_PYROUTPROC1_SCALE2TO5_STILL]"
+ "buffPools[H17BUFFPOOL_REGISTRATION]"
+ "buffPools[H17BUFFPOOL_SEMANTIC_VIDEO]"
+ "buffPools[H17MAX_BUFF_CNT_MLAF]"
+ "buffRef->id == ENTRY_BUFFREF"
+ "buffRef->ref[2]"
+ "buffStride = %lu\n"
+ "buffer"
+ "buffer != 0"
+ "buffer != NULL"
+ "buffer != nullptr"
+ "buffer %d has null pointer or zero size"
+ "buffer && (size == sizeof(uint64_t))"
+ "buffer && HMACp && ivp && hostTag && nonce"
+ "buffer && size"
+ "buffer shared with ch %hhu fc %d sifr %d"
+ "buffer size = %u"
+ "buffer size = %zu"
+ "bufferCount %zu bufferCountSlave %zu bufferCountSifr %zu bufferCountSlaveSifr %zu"
+ "bufferCountBase %zu TM depth %zu sifrSkipInterval(%zu)=%u"
+ "bufferInit"
+ "bufferLen == 0"
+ "bufferLen > sizeof(sIOPRingBuffer_t)"
+ "bufferNeededSize <= buffersSizeInGMSBufferPool"
+ "bufferSizeDPC=%zu MaxDPCDefectPixelCount=%d"
+ "bufferStart"
+ "bufferUncached[k] != bufferCached[k]"
+ "bufferWght <= 1.0f"
+ "bufferWght >= 0.0f"
+ "bufferedFrame->thumbnailHist[%i]=%f"
+ "bufferedFrame->thumbnailHist[j] <= (1.f + EPS)"
+ "bufferedFrame->thumbnailHist[j] >= (0.f - EPS)"
+ "bufferedFrame->thumbnailLumaHist[%i]=%f"
+ "bufferedFrame->thumbnailLumaHist[j] >= (0.f - EPS)"
+ "bufferedHistogram[%i]=%f"
+ "bufferedHistogram[j] <= (1.f + EPS)"
+ "bufferedHistogram[j] >= (0.f - EPS)"
+ "buffered[%i] >= buffered[%i], %f >= %f"
+ "buffered[i] >= (buffered[i-1] - FLT_EPSILON)"
+ "buffers != 0"
+ "buffers <= (10)"
+ "buffers <= 3"
+ "buffers <= 7 && \"Obsolete GP command no longer supported\""
+ "buffers <= FFWMSG_REF_MAX"
+ "buffers <= FFW_INTERPROC_BUFF_TOT"
+ "buffers <= FLOW_INPUT_REF_TOT"
+ "buffers <= PCE_ALGO_MAX_REF"
+ "buffers == 1"
+ "buffers == 1 && \"AgentCVDCombGP command only takes one buffer\""
+ "buffers == 1 && \"AgentDesGenGP command only takes one buffer\""
+ "buffers == 1 && \"AgentDesMatchGP command only takes one buffer\""
+ "buffers == 1 && ref[0] != 0"
+ "buffers == 2"
+ "buffers == 3"
+ "buffers == 7"
+ "buffers == ALGOCTRLSERVER_OUTBUF_TOT"
+ "buffers == CVIO_BUF_TOT && \"FilterCvdDp filter takes 2 buffers\""
+ "buffers == MLAF_TELE_BUF_INPUT_TOT"
+ "buffers == MLVNR_BUF_INOUT_TOT"
+ "buffers > 0"
+ "buffers >= (2)"
+ "buffers >= 2"
+ "buffers[k] && buffers[k]->DataPointer()"
+ "buffpool"
+ "buffpool %p"
+ "buffpool->BufferAvailable() == commonRawBufCnt[RAW_POOL_COMMON_FEP]"
+ "bundledBlocksIn <= CBuffer::idTot"
+ "bus < ISP_SMB_CONTROLLER_TOT"
+ "bus < ISP_SPMI_CONTROLLER_TOT"
+ "byPass = 0x%x"
+ "bytesInFifo < 256"
+ "c"
+ "c0 != 0"
+ "c1 != 0"
+ "c1CoolWP=%.2f, c2CoolWP=%.2f"
+ "c2 != 0"
+ "c3 != 0"
+ "cCool=0x%x, iCool=%d, cWarm=0x%x, iWarm=%d, cTorch=0x%x, iTorch=%d, Yled=%lld pctIntens10=%d"
+ "cCoredumpInstance"
+ "cEIT %llu, exposure %llu, gainAnal %d,  gainDigi %d, vFs %d rS%d"
+ "cWarpMat = [%6.2f %6.2f %6.2f]"
+ "cache Stop continousSync %d camIndex %u clock master %u @%f \n"
+ "cache ch %u pendingStopSlaveMask 0x%x\n"
+ "cacheHint != MCACHE_HINT_INVALID"
+ "cacheSetting != 0"
+ "cachedAEWinSet"
+ "cachedHighResAEAWBWinSet"
+ "cachedStatZoomUpdate"
+ "cachedZoomParam"
+ "caeDesc"
+ "caeRec"
+ "caeRec[ch]->aeOutputMetaBuffer == 0"
+ "caeRec[ch]->historyCount == 0"
+ "caeRec[master_id]->historyCount >= 1"
+ "caeRec[slaveCh]->chConfig.SPDMode == CAE_SPLIT_PD_NOT_SUPPORTED || caeRec[slaveCh]->chConfig.SPDMode == CAE_SPLIT_PD_ALWAYS_ON"
+ "caeRec[slaveCh]->chConfig.mainClk > 0"
+ "cafChannel < cafChannelTot"
+ "cafChannel < h->cafChannelTot"
+ "calHorizon"
+ "calculateAWBBackgroundTemporalStatistics"
+ "calculateCCMDesatFactorForSkin"
+ "calculateConfidence"
+ "calculateGrayIndexFromGrayworld"
+ "calculateSTRBkeyFromWideCameraNew"
+ "calculateSimilarityScore"
+ "calculateSkinOnlyWBGain"
+ "calculateSlaveCameraWBGainfromMatchingModel"
+ "calculateWBConvergenceSpeedCoef"
+ "calculated rdo shall match %d %d"
+ "calculated vframeSize shall match %d %d"
+ "calculatedRDO == rdo"
+ "calculatedRDO == sensorTestSIFRRDOffset"
+ "calculatedVFrameSize == sensorTestVFrameSize"
+ "calculatedVFrameSize == v"
+ "calibrationData"
+ "call UpdatePrincipalOffsetAndPFLScale, ST=0x%x"
+ "call getCropWindow, srcEfl %f, dstEfl %f, ST=0x%x, %d"
+ "callbackArray != 0"
+ "callbackList->Size() < CBUFFER_READY_CALLBACK_MAX"
+ "callbackListMutex != (FFWMUTEX)0"
+ "camControlROI.height > 0"
+ "camControlROI.height=%i"
+ "camControlROI.width > 0"
+ "camControlROI.width=%i"
+ "camIndex %d is more than totRFCCamDepth %d"
+ "camIndex <= totRFCCamDepth"
+ "camInterface[i].hDMAOut != 0"
+ "camParamBuffer != nullptr"
+ "cam[%zu] update fov delta %f %f %f %f"
+ "camera gravityXYZ[%d]= %f %f %f"
+ "cameraFocusState"
+ "cameraFocusState != 0"
+ "cameraFocusState[cafChannel].pCAF != 0"
+ "cant stop channel (%zu)"
+ "cap != 0"
+ "capturePrepTask != (TASK)0"
+ "case 0 sumOfWeights %f (no tile responded)\n"
+ "case 1 D2 %f => not slow sync\n"
+ "case 2 DR %f minDR %f rawDR %f luxweight %f\n"
+ "case 20 objects luxExposure %f gain %f target %d\n"
+ "case 200 max gain mainflashTargetDuration %f exposureTargetedDuration %f gain %f\n"
+ "case 201 min gain mainflashTargetDur %.3f exposureTargetedDur %.3f gain %.2f\n"
+ "case 21 exposureTargetedDuration %.3f mainflashTargetDuration %.3f  gF %.2f gA %.2f backgroundTargetedEit %f\n"
+ "case 21 exposureTargetedDuration %.3f mainflashTargetDuration %.3f  gF %.2f gL %.2f backgroundTargetedEit %f\n"
+ "case 211 luxExposure %.2f mainflashTargetDuration %.3f\n"
+ "case 3 exposure %f flash %f minCap %f\n"
+ "case D %f D1 D2 %f %f luxWeight %f dr %f\n"
+ "cat < CISP_AC_DET_CATEGORY_COUNT"
+ "cat < kAcDetCategoryMax"
+ "cawbDesc"
+ "cawbDesc[ch] && cawbRec[ch]"
+ "cawbRec"
+ "cb.pipeId == 1"
+ "cc"
+ "ccm %6d %6d %6d %6d %6d %6d %6d %6d %6d"
+ "cct=%u -> %u ccGain=%hu %hu -> %hu %hu"
+ "cctBounds        = %d, %d"
+ "cctHistScr = %.4f, tintHistScr = %.4f, fovScr = %.4f simiScr = %.4f"
+ "cctLoThresh=%.2f, cctHiThresh=%.2f"
+ "cctMax           = %d"
+ "cctMired=%.2f, correctionWeight=%.2f, skyMired=%.2f, skyCCT=%u"
+ "cctQuant         = %d"
+ "cctWeight=%.2f luxWeight=%.2f indoorWeight=%.2f indoorStrength=%.2f daylightConf=%.2f"
+ "cellInBuffer == 0"
+ "centerWeight >= 1"
+ "centerX=%f centerY=%f, maxNumIterations=%d, maxNumValidIterations=%d, newMinNumIteration=%d\n"
+ "cert syscfg %016llx\n"
+ "cfg %u exceed max %u"
+ "cfg %u, tot %zu"
+ "cfg %zu xStart %u, xEnd %u, yStart %u yEnd %u digScopeXStart %u digScopeYStart %u"
+ "cfg < configTot"
+ "cfg.byPass == 0"
+ "cfg.cropHeight % 2 == 0"
+ "cfg.cropWidth % 4 == 0"
+ "cfg.desMatch.desgen.byPass == 0"
+ "cfg.desgen.byPass == 0"
+ "cfg.featurePatch.numPatch <= kNccPatchLUTSize"
+ "cfg.gdctablescale: %d\n"
+ "cfg.inputWidth % 2 == 0"
+ "cfg.ncc.nccEn"
+ "cfg.nccPipe.dpeSrcFrame"
+ "cfg.patch.numPatch <= kNccPatchLUTSize"
+ "cfg.patch.numPatch == cfg.featurePatch.numPatch"
+ "cfg.res.xCropStart % 4 == 0"
+ "cfg.res.yCropStart % 2 == 0"
+ "cfg.rma0TransMode != 0"
+ "cfg.rma0TransMode == 0"
+ "cfg.rma1TransMode != 0"
+ "cfg.rma1TransMode == 0"
+ "cfg.rma2TransMode != 0"
+ "cfg.rma2TransMode == 0"
+ "cfg.rma3TransMode != 0"
+ "cfg.rma3TransMode == 0"
+ "cfg.usingDesGen == 1"
+ "cfg.usingRes == 0"
+ "cfg.usingVisPipe0 == 0"
+ "cfg.usingVisPipe1 == 1"
+ "cfg.wma0TransMode != 0"
+ "cfg.wma0TransMode == 0"
+ "cfg.wma1TransMode != 0"
+ "cfg.wma1TransMode == 0"
+ "cfg.wma2TransMode != 0"
+ "cfg.wma2TransMode == 0"
+ "cfg.wma3TransMode != 0"
+ "cfg.wma3TransMode == 0"
+ "cfgIdx < configTot"
+ "cfgNum %d, Streaming mode %d, Sifr %d, HR %d, FHS %d, SBS %d"
+ "cfgNum %zu, tot %zu"
+ "cfgSize < totalSizeInWord * 4"
+ "cfgsize * sizeof(uint16_t) * 2 + sizeof(lumiSettingsDisable) + sizeof(lumiSettingsROI) <= sizeof(lumiBuf)"
+ "cfgsize * sizeof(uint16_t) * 2 + sizeof(lumiSettingsDisablePri) + sizeof(lumiSettingsROI) <= sizeof(lumiBuf)"
+ "cfgsize * sizeof(uint16_t) * 2 + sizeof(lumiSettingsEnable) + sizeof(lumiSettingsROI) <= sizeof(lumiBuf)"
+ "cfgsize * sizeof(uint16_t) * 2 + sizeof(lumiSettingsEnablePri) + sizeof(lumiSettingsROI) <= sizeof(lumiBuf)"
+ "ch != 0"
+ "ch != masterCh"
+ "ch %d"
+ "ch %d / %d offset %d fc %lld frameskip %lld "
+ "ch %d CONFIG extra bank %d %d"
+ "ch %d DISABLE AFE afeIndex %d"
+ "ch %d FEP %d"
+ "ch %d ev0FrRegBank %d registerBank %d address %zu"
+ "ch %d ev0FrRegBank %d registerBank %d address 0x%zx"
+ "ch %d fc %d opMode %d %d vhdr %d tf %d"
+ "ch %d fr %d SBS %d config %d, bFESAllowed=%d, bMsBEPYRScalerAllowed=%d\n"
+ "ch %d in %d ms"
+ "ch %d isFrontCamera %d\n"
+ "ch %d not equal to pMeta ch %d"
+ "ch %d numPipe %d, VC pipeId %d"
+ "ch %d sensorID %d Max preset number reached %d"
+ "ch %d stats_bottom %f"
+ "ch %d stats_left %f TilesX %d"
+ "ch %d stats_right %f"
+ "ch %d stats_top %f TilesY %d"
+ "ch %d sync %d master %d %d config %d"
+ "ch %d, currentEIT %llu, exposure %llu, gainAnal %d,  gainDigi %d, vFrameSize %d\n"
+ "ch %d, gAnalSifr %d, gDigiSifr %d,  oDGain %d, splitPDOn %d, videoOn %d\n"
+ "ch %d, isSifrM %d, sifrSkipR %d,  sifrOffP %d, HRDampingR %f, rdod %d, esifr %llu\n"
+ "ch %d, request %d, ev0Ratio %d, expBias %d,  cDiscontinuity %d\n"
+ "ch %d, syncID %d, master ch %d\n"
+ "ch %d: latencyPerQ %d latency %f numSifQ %d"
+ "ch %d: sif %d, dr %lld lat %f QSz %.1f Phy %lld Enc %.1f Entries %.1f"
+ "ch %d: virtual Crop [%d,%d, %dx%d], purple %dx%d"
+ "ch %u"
+ "ch %u Old frame fc %u sifrthumbnail %p"
+ "ch %u Pool size totalAll %zu base %zu"
+ "ch %u awb setting is too old awbParamSyncTag %d cur %d"
+ "ch %u done"
+ "ch %u fc %d bPreviewRaw2HostEnable %d retain %d"
+ "ch %u fc %u Flush TM depth %zu -> %zu"
+ "ch %u fc %u streaming %u -> %u"
+ "ch %u frmcnt %llu get result %p"
+ "ch %u input sifr %d wd %u %u, ht %u %u inHt %d ssM %d sf:%d"
+ "ch %u isAWBPrimary prev %d new %d"
+ "ch %u mask %u"
+ "ch %u mask %u frmcnt %llu"
+ "ch %u mask %u frmcnt %llu requester %s:%d"
+ "ch %u mask %u retain %zu owner %s:%d"
+ "ch %u srcDMAIndex %d hDMAIn %p"
+ "ch %u tooDark=%.3f <%.3f, clipped=%.3f => vhdrOn %d"
+ "ch %u, Assign Stats pipe %d hDrv %p"
+ "ch %zd fc %d HIRESCAPTURE skip BWR downvote"
+ "ch %zu (%s) capturePrepareState %d Skip channel start"
+ "ch %zu (%s) fc %u IR Projector off done %f\n"
+ "ch %zu (%s) fc %u IR Projector off start %f streamingPauseReq %u %u %u\n"
+ "ch %zu AEMETA Adjusted DG %d AG %d SDG %d"
+ "ch %zu AEMETA Original DG %d AG %d SDG %d"
+ "ch %zu AFE M2M = %d"
+ "ch %zu AFEProc pipe %d, mode %s"
+ "ch %zu AWB update"
+ "ch %zu Aborted %u frameID %llu currFC %u @%f\n"
+ "ch %zu Adaptive Switch force StatsPipe to use preview scaler %u"
+ "ch %zu ChannelReset"
+ "ch %zu DMA_CHAIN: Force Disable FEP -> Stats"
+ "ch %zu DMA_CHAIN: Force FEP -> Stats fepStatsDmaChainIdx %d mStatsSrcDMAIndex %d"
+ "ch %zu DMA_CHAIN: No chaining in stats=M2M mode"
+ "ch %zu DMA_CHAIN: mStatsSrcDMAIndex %d FEP %d -> (stats)srcDMA  %d,  fepStatsDmaChainIdx %d"
+ "ch %zu Defer prepareStop to avoid racing with Projector On sequence"
+ "ch %zu Drop AFEProc CMD Queue Full"
+ "ch %zu EXTSYNC fail fps:%.2f,config: %d framecount: %d, RVSYNC [%llu.%06llu] RVSYNC_Prev [%llu.%06llu]"
+ "ch %zu EXTSYNC pass fps:%.2f,config: %d framecount: %d"
+ "ch %zu FEP dim %u x %u"
+ "ch %zu Flush TM depth %zu -> %zu"
+ "ch %zu InitLens called ret=%d"
+ "ch %zu M2M= %d"
+ "ch %zu New depth %d frameSlectionType %d \n"
+ "ch %zu ORIG WIDTH found orig cfg %d wd %d dataRate %f"
+ "ch %zu Prepare for First frame MSSyncMode:%d pendingMaster:%zu"
+ "ch %zu Prioritize registration reg %d scheme %d,bwRemain %d bwUsed %d"
+ "ch %zu Release HAT buffer bank=%d"
+ "ch %zu SENSOR GO bSplitSIFRFrame %d nextBank %d trigSifr:%d"
+ "ch %zu SPD %d %d %d %d %d"
+ "ch %zu Sifr skip ratio %d %d %d"
+ "ch %zu Skipping AdjustExposure for cfg %d pendingCfg %d AE cfg %d DLineTm"
+ "ch %zu Stats Mode Switch before channel start prevMode %u newMode %u statPipe %u"
+ "ch %zu Use special display width %u"
+ "ch %zu VMIN %d readOut %d sifr %d cfg %d"
+ "ch %zu afeProcSize %u"
+ "ch %zu bufs available %zu/ %zu i = %d"
+ "ch %zu cfg %d wd %d dataRate %f totalH %u"
+ "ch %zu config %d miniRDO(us) %d"
+ "ch %zu config %d, Stats pipe %d, mode %s"
+ "ch %zu contextSwitchActiveConfigsBitMap -> 0x%x"
+ "ch %zu contextSwitchStreamingBitMap -> 0x%x"
+ "ch %zu copy metadata done"
+ "ch %zu currentDisplayBrightness %f\n"
+ "ch %zu deliver captureFrameType %d id %zu size %zu"
+ "ch %zu enable=%d"
+ "ch %zu exclave meta data size: %zu"
+ "ch %zu fc %d"
+ "ch %zu fc %d DATA DEST mRegisterBank %d"
+ "ch %zu fc %d DMA done frame[%d]= %p"
+ "ch %zu fc %d Drop! Go %d"
+ "ch %zu fc %d FEP dataRate %d < bwr %d"
+ "ch %zu fc %d MAIN Src [%d %d] FEP src[%d %d] crp[%d %d %d %d]"
+ "ch %zu fc %d RELEASE pHostMetaDataBufBank %lx Bk[%d] %lx, %lx "
+ "ch %zu fc %d SIF %d x %d, config %d x %d addr %lx"
+ "ch %zu fc %d SIF dataRate %d < bwr %d"
+ "ch %zu fc %d SIFR Src [%d %d] FEP src[%d %d] crp[%d %d %d %d]"
+ "ch %zu fc %d bwr %d FEP %d Thumb %d "
+ "ch %zu fc %d can't get buffer to apply LSC chroma table"
+ "ch %zu fc %d defer processStopped at FV sync State %d"
+ "ch %zu fc %d go %d streaming mode %d downscale %d"
+ "ch %zu fc %d go %d! pCapturedFrame %p"
+ "ch %zu fc %d mode %d meta %p"
+ "ch %zu fc %d pHostMetaDataBuf %lx %lx, retain %d"
+ "ch %zu fc %d pMetaDataBuf %lx bDropFrame:%d"
+ "ch %zu fc %d pMetaDataBufPrev %lx pMetaDataBuf %lx %lx retain %d state %d"
+ "ch %zu fc %d pMetaDataBufPrev %lx pMetaDataBuf %lx %lx, %lx ret %d"
+ "ch %zu fc %d pipe %d THUMB DMA wdxht %d %d"
+ "ch %zu fc %d pipeId %d SIF dataRate %d < bwr %d"
+ "ch %zu fc %d pipeId %d bank %d SIF dataRate %d < bwr %d"
+ "ch %zu fc %d sendFepFrame %p pMetaDataBuf %lx bDropFrame:%d"
+ "ch %zu fc %d state %d"
+ "ch %zu fc %d streamingPauseReq %d dc= %u"
+ "ch %zu fc %d streamingPauseReq %d state %d dc=%u"
+ "ch %zu fc %d streamingPauseReq %d state %d dc=%u\n"
+ "ch %zu fc %d total time delta %f"
+ "ch %zu fc %d, 1st sif selecting register bank %d"
+ "ch %zu fc %d, config complete vcp %zx sifdma %zx fepdma %zx fep %zx"
+ "ch %zu fc %d, config supports SIFR but not enabled...Assuming double banking"
+ "ch %zu fc %d, defaulting to vcp %zx sifdma %zx fepdma %zx fep %zx"
+ "ch %zu fc %d, sif %zx dma %zx fep %zx"
+ "ch %zu fc %u Aborted srcDone @%f"
+ "ch %zu fc %u LPDP Stop_Complete @%f OpMode %u sifrCfg %u sifrFrame %u %u armed %u\n"
+ "ch %zu fc %u [%f] stopping at %s RV %f FV %f\n"
+ "ch %zu fc %u capturedFrame %p"
+ "ch %zu fc %u lpdp stop sifr frame RV\n"
+ "ch %zu fc %u pending sif abort"
+ "ch %zu fc %u skip fep thumbnail buffer for bracketing frame"
+ "ch %zu fc %u srcDon multisync aborted %u"
+ "ch %zu fc %u streaming stats M2M Mode but statsChaining enabled cfgIdx %u"
+ "ch %zu fc %u vcpipe %u Abort SIF Now!\n"
+ "ch %zu fc %u vcpipe %u Abort SIF Now! @%f\n"
+ "ch %zu fc %u vcpipe sifr Abort SIF Now! @%f\n"
+ "ch %zu fc:%d fTAb %llu FT %f vFrm %d H %d clk %d %llu"
+ "ch %zu fepRawOutputEnable %d cfg %d bin %d reg %d"
+ "ch %zu flowType %u"
+ "ch %zu frmTmAbs %llu FrmTm %f vFrm %d H %d clk %d %llu"
+ "ch %zu go %d skip interval %d curr %d skipwindow %d %d frameSkip %d switch %d"
+ "ch %zu highQualityRegionInRawX=%d, Y=%d, Width=%d, Height=%d"
+ "ch %zu in group isSifrMode %d hr %d vhdr %d sifrctrl %d"
+ "ch %zu isSifrMode %d hr %d vhdr %d sifrctrl %d"
+ "ch %zu issue capture stop @%f RVTS %f FVTS %f in %s\n"
+ "ch %zu maxFepWidth %zu maxFepHeight %zu"
+ "ch %zu mode %d streamingmode %d"
+ "ch %zu new frameSkip %d  curr_sensor %d\n"
+ "ch %zu on %d \n"
+ "ch %zu pending %d sensor %p"
+ "ch %zu pipe %d"
+ "ch %zu pipe %u enable %u"
+ "ch %zu rail: %d powerState: %d\n"
+ "ch %zu receive bkt restore from AE\n"
+ "ch %zu receives awb: %p"
+ "ch %zu runSifr %d sifrSkipInterval %d ok2run %d bForceSifrOn %d bkt %d %d step %f frameRate %d"
+ "ch %zu sensorQuadraBinFactor %d binFactor %d final %d"
+ "ch %zu sifDMASrcIndex %d"
+ "ch %zu sifr skip %d %d %d "
+ "ch %zu skip interval %d curr %d masterCam %d->%d skip %d"
+ "ch %zu skip interval %d curr %d masterCam %d->%d skip %d fvDone %u rvsync %u"
+ "ch %zu skip interval %d curr %d skipwindow %d %d frameSkip %d"
+ "ch %zu skipwindow %d %d masterCamPreview %d pending %d issueGo %d"
+ "ch %zu src w h (%d %d)\n"
+ "ch %zu starting capture data in EXTSYNC mode : %d"
+ "ch %zu stream hires mode retain depth to be %zu"
+ "ch %zu streamingStartRequested %d at %d\n"
+ "ch %zu, Act: %u Exp: %u"
+ "ch %zu, Use M2M mode, AFEProc pipe %d"
+ "ch %zu, Use M2M mode, Stats pipe %d"
+ "ch %zu, Use OTF mode, AFEProc pipe %d"
+ "ch %zu, Use OTF mode, Stats pipe %d"
+ "ch %zu, currSetting->ae.exposureSifr %llu"
+ "ch %zu, disable AFEProc pipe %d"
+ "ch %zu, enableManualMode = 0,  FlickerFreq %u"
+ "ch %zu, fc %d SIF [%d %d %d %d] SIFR %d"
+ "ch %zu, fc %d region %d x %d, config %d x %d"
+ "ch %zu, fc %d, %d, %d [ %d x %d ] bin[%d %d]"
+ "ch %zu, fc %d, %d, %d [ %d x %d ] preISPDownsizeRatio %u"
+ "ch %zu, init histCnt %d cntr %d m exp %llu v %d gA %d gO %d ev0 %d"
+ "ch %zu, init histCnt %d cntr %d m exp %llu v %d gL %d gS %d ev0 %d"
+ "ch %zu, pipe %u"
+ "ch %zu, prevw histCnt %d cntr %d cfg %d m exp %llu v %d gA %d gD %d gO %d ev0 %d"
+ "ch %zu, prevw histCnt %d cntr %d cfg %d m exp %llu v %d gL %d gS %d ev0 %d"
+ "ch %zu, size %zu, deferCount %zu, pool %p, curIdx %d"
+ "ch %zu,fc %d FEP DMA region[%d %d %d %d], p %d [%zx %zx]"
+ "ch %zu,fc %d FEP DMA region[%d %d %d %d], pipeId %d "
+ "ch %zu,fc %d SIF DMA region[%d %d %d %d], p %d [%zx %zx]"
+ "ch %zu,fc %d SIF DMA region[%d %d %d %d], pipeId %d "
+ "ch %zu:%u:\t\t exp=%llu (%dus),v %fus, vfrm: %u, rdo: %f, ag 0x%x, dg 0x%x, sdg 0x%x,pat %u %u %u\n"
+ "ch %zx activeChCnt %d activeChMask %x enable %d"
+ "ch < 32"
+ "ch < CAICAM_CAMERA_CHANNEL_TOT"
+ "ch < CAM_CH_TOT"
+ "ch < CDCNPROC_CHANNEL_TOT"
+ "ch < CERDCNPROC_CHANNEL_TOT"
+ "ch < CFDDCNPROC_CHANNEL_TOT"
+ "ch < CHANNEL_COUNT"
+ "ch < CICWRAPPER_CAM_MAX"
+ "ch < CICWRAPPER_RCAM_TOT_"
+ "ch < CISP_CH_TOT"
+ "ch < CKEYPOINT_CHANNEL_TOT"
+ "ch < CMLAFPROC_CHANNEL_TOT"
+ "ch < CPCE_CHANNEL_TOT"
+ "ch < CPDEPROC_CHANNEL_TOT"
+ "ch < CTIMEMACHINE_CHANNEL_TOT"
+ "ch < CVDDP_MAX_CH_NUMBER"
+ "ch < D9X_POWER_CHANNEL_NUM"
+ "ch < DISTDRV_CH_TOT"
+ "ch < ISP_CAMERA_CHANNEL_TOT"
+ "ch < ISP_SMB_CHANNEL_TOT"
+ "ch < LCMOTION_MAX_CHANNELS"
+ "ch < MAX_ISP_CHANNELS"
+ "ch < MOTIONESTIMATOR_MAX_CH_NUMBER"
+ "ch < cameraTot"
+ "ch < chTot"
+ "ch < inchannels"
+ "ch < maxChannel"
+ "ch < numChls"
+ "ch < this->maxChannel"
+ "ch < totVCs"
+ "ch <= CISP_CH_TOT"
+ "ch <= ISP_CAMERA_CHANNEL_TOT"
+ "ch <= LCMOTION_MAX_CHANNELS"
+ "ch <= MOTIONESTIMATOR_MAX_CH_NUMBER"
+ "ch <= totalCh"
+ "ch == 0 || ch == 1 || ch == 4"
+ "ch == MC2LC_FAKE_CHANNEL"
+ "ch == RGB_CAM_CH || ch == IR_CAM_CH"
+ "ch == channel"
+ "ch == pMetaData->channel"
+ "ch >= h->channelBaseNumber"
+ "ch >=0 && ch < _chTot"
+ "ch [%zu] fc %d unable to allocate buffer from pool %d"
+ "ch!=DEPTH_CAM_CH"
+ "ch%d %d avgSNR%.2f avgLuma%.2f ransacInlierRadiusPx%.2f"
+ "ch%d %d numMatchedPairs%d biasIn%.4f biasOut%.4f"
+ "ch%d, bTNRStrengthHighEn %d"
+ "ch%d: Front+Back sif %d, numOfQ %d datarate %lld, ltf_pe %zu, ltf %zu exact %f"
+ "ch%ld, from rect %d,%d:%dx%d"
+ "ch%ld,VirTotalCrop%d,%d:%dx%d"
+ "ch1 != MASTER_CH_UNKNOWN"
+ "ch2 != MASTER_CH_UNKNOWN"
+ "ch: %zu Bandwidth timer not available for depth sensor\n"
+ "ch: %zu NO KEYPOINTS DETECTED!!!"
+ "ch: %zu afe downScaleFactor: %f"
+ "ch:%d dma id:%zu rd:%d bwr:%d"
+ "ch:%d fc:%d Dumping Stats DMA Output in M2M"
+ "ch:%d fc:%d Dumping Stats DMA Output in OTF"
+ "ch:%d fc:%d SIFR Stat State[%d %d %d %d %d %d]"
+ "ch:%d fc:%d bk:%d Sifr:%d"
+ "ch:%d fc:%d rc:%d ReqPendingFlag:%d"
+ "ch:%d fep:%d Faster Sensor connected to Slower FEP"
+ "ch:%d fep:%d Slower Sensor connected to Faster FEP"
+ "ch:%u, fc:%d, FEThumbEn:%d, HostMetaAvailable:%d"
+ "ch:%zu Apply Cached FocusNow at channel start"
+ "ch:%zu Cache FocusNow Cmd before streaming"
+ "ch:%zu Copied buffers from %llu to %llu Retain[%d %d %d]"
+ "ch:%zu EXTSYNC config settings to %d Done"
+ "ch:%zu EXTSYNC framerate : %d/%d , disable EXTSYNC"
+ "ch:%zu EXTSYNC framerate:%d fraction:%d/%d , Enabling EXTSYNC \n"
+ "ch:%zu FEP:%d Slow Sensor connected to faster FEP"
+ "ch:%zu Property write value: %d not valid, (0 = bwr timer off, 1 = max frm rate, 2 = dynamic frm rate)"
+ "ch:%zu Req 0x%x, cQ %d, newUpd# %u,h %d,v %d,e %d,ir %d,g %d, m %d %d\n"
+ "ch:%zu Sensor Driver Handle is null!"
+ "ch:%zu Sensor Driver is null!"
+ "ch:%zu cfgNum:%d sensor crop[x:%d y:%d] dma vert crop[y:%d] SensorReadOutCropEnable:%d"
+ "ch:%zu config:%d total configs:%zu"
+ "ch:%zu fc:%d\n OneFrmTm calculated is 0"
+ "ch:%zu fc:%d EBD, number of lines received: %u\n"
+ "ch:%zu fc:%d Expected Sif Status Irq val:%#x, VcrIrq val:%#x Ignore in mICState:%d"
+ "ch:%zu fc:%d FEP src width:%d"
+ "ch:%zu fc:%d Not Allocating Sifr Buffer, [%d %d %d %d %d %d]"
+ "ch:%zu fc:%d Not firing timer, safe period > Max OFT"
+ "ch:%zu fc:%d Rdout with 1ms margin:%d"
+ "ch:%zu fc:%d Skipping Sifr Stats"
+ "ch:%zu fc:%d Skipping SrcGo for Arming Stats SrcDMA"
+ "ch:%zu fc:%d Ts=%lld"
+ "ch:%zu fc:%d Turn off bwr timer due to missed rvsync"
+ "ch:%zu fc:%d [%d %d %d %d %d %d]"
+ "ch:%zu fc:%d cfg:%d bitmap:0x%x"
+ "ch:%zu fc:%d ft:%llu rd:%d d:%d bk:%d sf:%llu"
+ "ch:%zu fc:%d isSafeToStop:%d sifrEn:%d mainPipeDone:%llu"
+ "ch:%zu fc:%d maxrdout:%d"
+ "ch:%zu fc:%d meta:%s sifr:%d bktcap:%d"
+ "ch:%zu fc:%d pipe:%d FDP:%d"
+ "ch:%zu fc:%d pipe:%d FDP:%d SR:%d arm:%d"
+ "ch:%zu fc:%d pipe:%d Skipping Frame with StandbyMode"
+ "ch:%zu fc:%d pipeId:%d dest:%d"
+ "ch:%zu fc:%llu at fc:%llu isSifrEn:%d isMainPipeArmed:%d"
+ "ch:%zu fc:%llu currentSifr:%d nextSifr:%d"
+ "ch:%zu new numsifQ:%d"
+ "ch:%zu old numsifQ:%d"
+ "ch:%zu sif:%d fep:%d fepppc:%f sifppc:%f downscale:%f"
+ "ch:%zu unable to set framerate resetting EXTSYNC settings"
+ "ch:%zu, fc:%d metaBuffer is NULL"
+ "ch:%zu,validBufRectW:%d,validBufRectH:%d,stride:%d"
+ "ch:%zu,validRectW:%d,validRectH:%d,stride:%d"
+ "ch=%d CCMCoef = %d %d %d; %d %d %d; %d %d %d "
+ "ch=%d CSCCoef = %d %d %d; %d %d %d; %d %d %d"
+ "ch=%d CSCSoffset = %d %d"
+ "ch=%d HistConfigOffset=%d %d HistConfigScale=%d %d"
+ "ch=%d ccmCoeff[][0]=%d %d %d %d %d %d"
+ "ch=%d enableSTF%u"
+ "ch=%d fn=%d mS=%d mP=%d isDefault=%d isMatched=%d HRon=%d"
+ "ch=%d fn=%d masterP=%d master= %d masterChPrev=%d isFirstFr=%d MSSync=%d bypass=%d"
+ "ch=%d fn=%d syncTag=%d prevSyncTag=%d master=%d masterPreview=%d masterCamChPrev=%d"
+ "ch=%d fn=%d wbRGain=%6.2f wbBgain=%6.2f ccm[0]=%6.2f ccm[4]=%6.2f ccm[8]=%6.2f"
+ "ch=%d frame=%d captureFrameCount=%d tag=%d bCaptureEn=%d dumpCtrl=%d"
+ "ch=%d lensPinholeum=%.2f pixelum=%.2f scal=%.2f lensPos=%.1f"
+ "ch=%d pCtxMem=%p CtxMemSize=%zu UpperBound=%p"
+ "ch=%d pmCC= %d %d %d %d dualCC=%d %d %d %d"
+ "ch=%d projPos[0]=%d %d projPos[29]=%d %d"
+ "ch=%d sensorCalBias=%d %d %d %d"
+ "ch=%d sensorCalIdeal=%d %d %d %d"
+ "ch=%d sensorColorReCalAbs=%d %d %d %d"
+ "ch=%d setFileMainVersion=0x%x setFileSubVersion=0x%x"
+ "ch=%d x=%d %d cct=%d %d"
+ "ch=%d, bufInRaw=%p, dataSource %u %u"
+ "ch=%d, enableInfo %u statsDmaEn %u "
+ "ch=%d, fn=%d isDefault=%d wbGain=%d %d %d statsPrimary=%d, init %d"
+ "ch=%d, frame=%d, scaleHeight[0]=%d, maxScaleHeight[0]=%d"
+ "ch=%d, seq=%d, no Semantic Video buf available"
+ "ch=%d, seq=%d, no pyramidY buf available. ANFD %d/%d"
+ "ch=%d,CT=%d,fCnt=%d,stdFR=%.2f,type=%d,runSltCfg=%d,sltStp=%.1f,period=%d,dcRate=%.1f,ok=%d"
+ "ch=%d,Src=%d,seq=%zu,procTime=%d us,(%d) jobId=%#zx"
+ "ch=%d,frame=%d, maxScaleHeight=[%d %d %d %d %d %d]"
+ "ch=%d,frame=%d, scaleHeight[0]=%d, maxScaleHeight[0]=%d"
+ "ch=%d,frame=%d,still=%d, Call StartOfFrameInit"
+ "ch=%d,seq=%d,scaler=%d,PDE Y:%p, size=%ld,W=%d,H=%d,stride=%ld,fmt=%d"
+ "ch=%hhu fn=%u awbFn=%hu defaultAE=%llu currentAE=%llu lux=%hu exLux=%f"
+ "ch=%i (cfg=%d) in syncGroup - CmdSyncTag=%d"
+ "ch=%ld"
+ "ch=%ld (%d),frame=%d, Call ProcInputStat"
+ "ch=%ld (%d),frame=%d, Call ProcInputStat - still"
+ "ch=%ld ChannelInit FFOV base:InverseCoef, ForwardCoef, Order, dyn:InverseCoef, ForwardCoef, Order"
+ "ch=%ld ChannelInit FFOV: PFL_gdc_max=%f, PFL_gdc_min=%f"
+ "ch=%ld ChannelInit FFOV: apsModelLinearM=%f, apsModelLinearB=%f, apsOpticalOffset=%f"
+ "ch=%ld ChannelInit FFOV: optCenter:%f %f, minPFL=%f, maxPFL=%f"
+ "ch=%ld ChannelInit FFOV: pixelSizeUm=%f, GdcScale=%f, apsPFL=%f mm, maxRadius=%f"
+ "ch=%ld ChannelInit FFOV: thickLensSlope=%f, ThickLensEFL=%f, upperBoundPFL=%f"
+ "ch=%ld ChannelInit FFOV:[%d]:%10f,%10f,%10d,%10f,%10f,%10d"
+ "ch=%ld fr=%d: EGH=%f, OGH=%f, LS=%f, DSLF=%.1f"
+ "ch=%ld fr=%d: FMin=%.1f, FMax=%f, SBLA=%.1f, EGL=%f, OGL=%f, T=%.1f, TF=%d"
+ "ch=%ld gdcConfig isOL=%s base:InverseCoef, ForwardCoef, Order, dyn:InverseCoef, ForwardCoef, Order"
+ "ch=%ld gdcConfig isOL=%s: PFL_gdc_max=%f, PFL_gdc_min=%f"
+ "ch=%ld gdcConfig isOL=%s: apsPFL=%f, apsEFL=%f"
+ "ch=%ld gdcConfig isOL=%s: apsPosition=%f, apsObjectDistance=%f"
+ "ch=%ld gdcConfig isOL=%s: optCenter:%f %f, minPFL=%f, maxPFL=%f"
+ "ch=%ld gdcConfig isOL=%s: pixelSizeUm=%f, GdcScale=%f, maxRadius=%f, apsEFL=%f"
+ "ch=%ld gdcConfig isOL=%s: recalculated upperBoundPFL = %f mm"
+ "ch=%ld gdcConfig isOL=%s: thickLensEFL=%f, thickLensSlope=%f, apsModelLinearM=%f, apsModelLinearB=%f"
+ "ch=%ld gdcConfig isOL=%s:[%d]:%10f,%10f,%10d,%10f,%10f,%10d"
+ "ch=%ld just switch from MLVNR mode, need hold this frame=%d to wait for last MLVNR frame finish to avoid frame disorder issue"
+ "ch=%ld mpInfoQ is full, need hold this frame=%d to wait for MLVNR frame finish to avoid resource allocation issue"
+ "ch=%ld realtime bufs: %ld defer bufs: %ld total: %ld"
+ "ch=%ld, BufferPool scale 0 - %ld/%ld"
+ "ch=%ld, BufferPool scale 1 - %ld/%ld"
+ "ch=%ld, BufferPool scale 2To5 - %ld/%ld"
+ "ch=%ld, CIC_CMD_MSBEPYR_SIZE_SET - PYR CROP -> [%d, %d, %d, %d] PYR output [%d, %d]"
+ "ch=%ld, CIC_CMD_SCALER_OUTPUT_PROPERTY_SET -> scaler %d, PaddingRows %d, refW %d, refH %d"
+ "ch=%ld, CIC_CMD_ZOOM1X_MSBEPYR_CROP_SET - CROP -> [%d, %d, %d, %d]"
+ "ch=%ld, CIC_CMD_ZOOM1X_SCALER_CROP_SET - AUX CROP -> [%d, %d, %d, %d]"
+ "ch=%ld, CIC_CMD_ZOOM1X_SCALER_CROP_SET - BES CROP -> [%d, %d, %d, %d]"
+ "ch=%ld, Directly set upperBoundPFL to -1 for non-AF camera. (Max radius = %f, thickLensSlope = %f)"
+ "ch=%ld, Directly set upperBoundPFL to -1 for non-SWide/Wide camera."
+ "ch=%ld, FD frame=%d, faces=%d, maxFrameLatency=%d, maxCadence=%dus, maxLatency=%dus"
+ "ch=%ld, FD frame=%d, frameLatency=%d, cadence=%dus, latency=%dus"
+ "ch=%ld, FES original output w=%d,h=%d"
+ "ch=%ld, PFL_gdc_min=%f, PFL_gdc_max=%f"
+ "ch=%ld, Set upperBoundPFL to %f mm for AF camera. (PFL_gdc_max = %f)"
+ "ch=%ld, ValidRect: %d %d %dx%d"
+ "ch=%ld, YCC crop: %d %d %d %d, outHeightInRaw: %d"
+ "ch=%ld, activeChCnt=%d, activeChMask=0x%x"
+ "ch=%ld, activeChCnt=%d, activeChMask=0x%x, contextSwitchConfigsBitMap=0x%x"
+ "ch=%ld, activeChCnt=%d, actualActiveChCnt=%d"
+ "ch=%ld, adjusted %s Crop=(%d, %d, %d, %d)"
+ "ch=%ld, bAuxSclCascadeEn=%d BES[0] Crop (%d, %d, %d, %d), BES[0] Ouput (%d, %d)"
+ "ch=%ld, bFESAllowed=%d, FES output w=%d,h=%d"
+ "ch=%ld, bFESAllowed=%d, bScalerCropUpdated=[%d, %d], bYccCropUpdated[0]=%d"
+ "ch=%ld, bFESEnabled=%d, bFESAllowed=%d, bFHSEnabled=%d, bAuxSclCascadeEn=%d, commonZoom=%0.2f"
+ "ch=%ld, bFHSEnabled=%d bFESAllowed=%d, bFESEnabled=%d, bPYRAllowed=%d, bAuxSclCascadeEn=%d"
+ "ch=%ld, bMsBePYRScalerAllowed=%d, PYR Scaler output w=%d,h=%d"
+ "ch=%ld, bRegistraionPrioritized=%d\n"
+ "ch=%ld, bScalerCropUpdated=[%d, %d], bYccCropUpdated[0]=%d"
+ "ch=%ld, bShared=%d, bTFStill=%d, ctfChEnMask=%#lx, bufCnt=%d, bCTFCrcEn=%d, bCTFCrcEnStill=%d"
+ "ch=%ld, bSpatialCCMEn=%d, ltmSccmStride=%d"
+ "ch=%ld, bStreamOutputChangePending=%d"
+ "ch=%ld, bUpdatePipeConfiguration=%d, chDescr->fesOutput=(%d, %d), pInput->fesOut=(%d, %d)"
+ "ch=%ld, cfg=%d, BitMap=0x%x, chId=%ld, cfgId=%d, BitMap=0x%x"
+ "ch=%ld, cfgNum %d, fusionType=%d, preSet fesEnable=%d, bFESAllowed=%d, bPYRAllowed=%d"
+ "ch=%ld, cfgNum %d->%d, sensorQuadraBinFactor %d->%d, bFESAllowed=%d"
+ "ch=%ld, cfgNum=%d, raw: %dx%d, binW=%d, binH=%d | max sensor raw: %dx%d"
+ "ch=%ld, cfgNum=%d, senisSifrMode=%d, sensWidth=%d, sensHeight=%d"
+ "ch=%ld, cfgNum=%d, sensorQuadraBinFactor=%d, rawWidth=%d, rawHeight=%d"
+ "ch=%ld, cfgNum=%d, sensorQuadraBinFactor=%d, rawWidth=%d, rawHeight=%d pre %d"
+ "ch=%ld, chDescr->bFESAllowed=%d, actualBESZoomX[%d]=%.2f, actualBESZoomY[%d]=%.2f"
+ "ch=%ld, chDescr->bFESAllowed=%d, actualFESZoomX=%.2f, actualFESZoomY=%.2f"
+ "ch=%ld, chDescr->bFESAllowed=%d, bAuxSclCascadeEn=%d"
+ "ch=%ld, chDescr->bFESAllowed=%d, bFESEnabled=%d, isSinglePipelineSwitch=%d"
+ "ch=%ld, chDescr->bPYRAllowed=%d, actualPYRZoomX=%.2f, actualPYRZoomY=%.2f"
+ "ch=%ld, config %d w=%d,h=%d,x=%d,y=%d"
+ "ch=%ld, config=%d, FES output w=%d,h=%d"
+ "ch=%ld, config=%d, fesInWidth=%d, fesInHeight=%d"
+ "ch=%ld, config=%d, maxWidth=%d, maxHeight=%d"
+ "ch=%ld, croppedRectFES (%d, %d, %d, %d), fesOutput (%d, %d)"
+ "ch=%ld, enable=%d(%d), PendingYCCTapEnable=%d,YCCTapEnable=%d,SizeUpdated=%d,syncTag=%d(%d)"
+ "ch=%ld, enableFHS=%d, enableDualRscl=%d"
+ "ch=%ld, fc=%i, CLUT=%d"
+ "ch=%ld, fc=%i, CLUT_CM=%d"
+ "ch=%ld, fesDownscaleRatioX=%.2f, fesDownscaleRatioY=%.2f"
+ "ch=%ld, fesDownscaleRatioX=%.3f, fesDownscaleRatioY=%.3f"
+ "ch=%ld, fesMaxOutputWidth=%d, fesMaxOutputHeight=%d"
+ "ch=%ld, fesOriginalCropRect (%d, %d, %d, %d), fesOriginalOutput (%d, %d)"
+ "ch=%ld, fesOriginalOutput (%d, %d), fesOriginalCropRect (%d, %d, %d, %d)"
+ "ch=%ld, flowSel=%d, clrProcCroppedRect [%d %d %d %d]"
+ "ch=%ld, fps = %d, fuseWidth = %d, fuseHeight = %d, frame=%d, status = %d"
+ "ch=%ld, frame=%d, (RBC)stride=%d,size=%d,addr=%p, (Rscl)w=%d,h=%d"
+ "ch=%ld, frame=%d, (fpnr)stride=%d,size=%d,addr=%p, (Rscl)w=%d,h=%d"
+ "ch=%ld, frame=%d, ALGOCTRL_STILL_FLOW"
+ "ch=%ld, frame=%d, ClrProcFE_input [%d %d], ClrProcBE_output [%d %d]"
+ "ch=%ld, frame=%d, MSTFInit=%d, MSTFRestart=(%d, %d, %d, %d, %d, %d, %d)=%d, RESTART_MSTF_ANYWAY=%d"
+ "ch=%ld, frame=%d, MsBePRY Scaler: [%d %d %d %d]->[%d %d]"
+ "ch=%ld, frame=%d, MsBePYR in [%d %d %d %d], out [%d %d]"
+ "ch=%ld, frame=%d, Scaler[%d]: [%d %d %d %d]->[%d %d]"
+ "ch=%ld, frame=%d, Still FES [%d %d %d %d] -> [%d %d]"
+ "ch=%ld, frame=%d, Still PYR [%d %d %d %d] -> [%d %d]"
+ "ch=%ld, frame=%d, anstInputTotalCrop: %d %d %d %d"
+ "ch=%ld, frame=%d, bCTFCircularEn=%d, bAdaptiveOverScanSwitch=%d, currCTFHeight=%d, inHeight=%d"
+ "ch=%ld, frame=%d, bCurrGenANSTEn=%d, bSMVGenerated=(%d | %d)"
+ "ch=%ld, frame=%d, bCurrMsBePYRScalerEn=%d"
+ "ch=%ld, frame=%d, bCurrSMVEn=%d, bCurrSMVAWBEn=%d, bCurrFDEn=%d"
+ "ch=%ld, frame=%d, bMSTFEn=%d, bCurrMSTF=%d, bMSTFEnInFlow=%d, currFusionType=%d, slaveProcM=%d, regMode=%d:%d"
+ "ch=%ld, frame=%d, bMultiPassMode=%d, bMultiStepMode=%d"
+ "ch=%ld, frame=%d, bSMVPeopleEn=%d, bSMVHairEn=%d, bSMVSkinEn=%d, bSMVSkyEn=%d"
+ "ch=%ld, frame=%d, capture metadata tag=%d, masterCh %d"
+ "ch=%ld, frame=%d, cfg=%d,qdrBinFctr=%d,Binning(%d,%d),splitPD=%d,FPNR(frame,tile,RBC):(%d,%d,%d)"
+ "ch=%ld, frame=%d, curr zoomFactor - scaler0=%d, scaler1=%d"
+ "ch=%ld, frame=%d, fesZoomXY (%d %d), pyrZoomXY (%d %d)"
+ "ch=%ld, frame=%d, mbnrIn: [%d, %d], RsmIn: [%d, %d], RsmOut: [%d, %d]"
+ "ch=%ld, frame=%d, outType=%d, BES in (%d, %d), (%d, %d), out (%d, %d)"
+ "ch=%ld, frame=%d, p=%d, s=%d,mpMode=%d,msMode=%d,gdcEn=%d,bStillCap=%d"
+ "ch=%ld, frame=%d, pDescr->bStillCap=%d, bMSTFEnInStillFlow=%d"
+ "ch=%ld, frame=%d, scaler0ZoomXY (%d %d), scaler1ZoomXY (%d %d)"
+ "ch=%ld, frame=%d, strModCtrl=%d,fps=%d,modFrmCnt=%d (%d),totGain=%d | [%d-%d]"
+ "ch=%ld, frame=%d, strModEn=%d, scale0en=%d, strength=%d"
+ "ch=%ld, frame=%d, zoomFactor - scaler0=%d, scaler1=%d"
+ "ch=%ld, frame=%d, zoomFactor - scaler0=%d, scaler1=%d,zoomUnmapMultiplier=%f"
+ "ch=%ld, i=%d, retain=%d"
+ "ch=%ld, imgW=%d, imgH=%d, Size(scale0)=%ld, bCompEn=%d"
+ "ch=%ld, imgW=%d, imgH=%d, Size(scale1)=%ld, bCompEn=%d"
+ "ch=%ld, imgW=%d, imgH=%d, Size(scale2To5)=%ld"
+ "ch=%ld, isStreaming=%d, TnrRunableChannels=(prev %d, curr %d), localTnrRunableChannels=%d"
+ "ch=%ld, ltmLtcStride=%d"
+ "ch=%ld, ltmLtcStride=%d, ltmLtcLutsSize=(%d %d)"
+ "ch=%ld, lux=%f, ratio=%f"
+ "ch=%ld, main=0x%08x sub=0x%08x"
+ "ch=%ld, maxBackEndRect (%d, %d, %d, %d)"
+ "ch=%ld, maxOutputHeightInRaw: %d, sensBinH=%d, oisMargin: %d"
+ "ch=%ld, maxZoom.maxBESZoomX[%d]=%d, maxZoom.maxBESZoomY[%d]=%d"
+ "ch=%ld, mode=%d No pMetaData for CbCr LUT"
+ "ch=%ld, okayMeshSize = %d, personMaskReady = %d, TxIsNormal = %d,warpMatrixValidEV0=%d, okayFrameGap = %d"
+ "ch=%ld, optimized FES crop = [%d %d %d %d] FES output = [%d %d]"
+ "ch=%ld, optimized PYR crop = [%d %d %d %d] PYR output = [%d %d]"
+ "ch=%ld, optimized croppedRectFES (%d, %d, %d, %d), fes Output (%d, %d)"
+ "ch=%ld, optimized croppedRectPYR (%d, %d, %d, %d), PYR Output (%d, %d)"
+ "ch=%ld, original %s Crop=(%d, %d, %d, %d)"
+ "ch=%ld, pConfig->apsEFL=%f, pConfig->apsPFL=%f\npConfig->thickLensEFL=%f, pConfig->thickLensSlope=%f\n"
+ "ch=%ld, pfl = %fmm, rd=%fmm, ru=%fmm, delta_pix=%fpix."
+ "ch=%ld, pfl=%f may cause HW hang."
+ "ch=%ld, put ispJob=%#zx to Q,pendingJobs=%d,%ld Src:%d"
+ "ch=%ld, pyrDownscaleRatioX=%.2f, pyrDownscaleRatioY=%.2f"
+ "ch=%ld, pyrOriginalCropRect (%d, %d, %d, %d), pyrOriginalOutput (%d, %d)"
+ "ch=%ld, rawDMASrcCropRect (%d, %d, %d, %d), rawOutput (%d, %d)"
+ "ch=%ld, scaler=%d, enable=%d, syncTag=%d, bOutputSizeUpdated=%d"
+ "ch=%ld, scaler=%d, remainFESZoomXY=[%d %d], remainPYRZoomXY==[%d %d]"
+ "ch=%ld, scaler=%d, zoomFactorPerBESPath=%d"
+ "ch=%ld, scaler_0 output: %dx%d, outputHeightInRaw: %d"
+ "ch=%ld, scaler_1 output: %dx%d, outputHeightInRaw: %d"
+ "ch=%ld, sensorID=%#x"
+ "ch=%ld, sensorReadOutCropRect (%d, %d, %d, %d), sensorRect (%d, %d, %d, %d)"
+ "ch=%ld, temp upperBoundPFL=%f, thickLensEFL=%f"
+ "ch=%ld, tempRect (%d %d %d %d)"
+ "ch=%ld, w=%d,h=%d,x=%d,y=%d"
+ "ch=%ld, width=%d, height=%d, bSharedPoolEn=%d, bScale0En=%d, totalMallocSize=%.2fMB"
+ "ch=%ld, width=%ld, height=%ld, bScale0En=%d, totalMallocSize=%.2fMB"
+ "ch=%ld, zoom1xSetting.fesCrop (%d, %d, %d, %d)"
+ "ch=%ld, zoom1xSetting.pyrCrop (%d, %d, %d, %d)"
+ "ch=%ld,AUX: [%d %d %d %d] -> %dx%d"
+ "ch=%ld,AUX: [%d %d %d %d] -> %dx%d  OutDMA [%d %d %d %d]"
+ "ch=%ld,BES: [%d %d %d %d] -> %dx%d"
+ "ch=%ld,BES: [%d %d %d %d] -> %dx%d  OutDMA [%d %d %d %d]"
+ "ch=%ld,Config=%d,standFrameRate=%.2f,bNoChSynced=%d,actChCnt=%d,maxFRate=%.2f,totFRate=%d"
+ "ch=%ld,DMA: [%d %d %d %d]"
+ "ch=%ld,FES: [%d %d %d %d] -> %dx%d"
+ "ch=%ld,PYR: [%d %d %d %d] -> %dx%d"
+ "ch=%ld,Sen: [%d %d %d %d]"
+ "ch=%ld,Stream En: BES %d AUX %d YCC %d"
+ "ch=%ld,Stream En: BES %d AUX %d YCC %d  AuxSclCascade %d"
+ "ch=%ld,VirtualCrop=[%d %d %dx%d],PrlWinDow[%dx%d]\n"
+ "ch=%ld,W=%ld,H=%ld,%s=%d,bSharedEn=%d,bScale0En=%d,actSlaveChs=%d,tnrChs=%d"
+ "ch=%ld,YCC: [%d %d %d %d]"
+ "ch=%ld,ZoomFactor: %f"
+ "ch=%ld,ZoomFactor: BES %f AUX %f YCC %f"
+ "ch=%ld,actual ISP zoom factor: %.2f"
+ "ch=%ld,besInCropRect:%d %d %dx%d, BesOut:%dx%d"
+ "ch=%ld,drop frame=%d (%d),mp=%d,p=%d,ms=%d,s=%d"
+ "ch=%ld,flowSel=%d,clrProcCropRect (%d %d %d %d)"
+ "ch=%ld,fr:%d, Buffer pool for ANSTThumbnail not available"
+ "ch=%ld,fr:%d,bANSTThumbnailEn:%d,bufOutCVPipe:%p"
+ "ch=%ld,frame=%d (Preview),validRectYuv[0]:%d %d %d %d"
+ "ch=%ld,frame=%d (Preview),validRectYuv[1]:%d %d %d %d"
+ "ch=%ld,frame=%d (Still),validRectYuvStill:%d %d %d %d"
+ "ch=%ld,frame=%d(t=%d),zoom Tag=(%d | %d, %d), bCropOutputSetInStreamPending=(%d %d)"
+ "ch=%ld,frame=%d(t=%d),zoom1xBes Tag=(%d | %d),QsumQsubPending=%d,(%d %d %d %d)"
+ "ch=%ld,frame=%d, colorProcValidRect: %d %d %d %d"
+ "ch=%ld,frame=%d, streamEnable - BES %d, AUX %d"
+ "ch=%ld,frame=%d, validBufferProResRaw [%d %d %d %d], InRaw [%d %d %d %d]"
+ "ch=%ld,frame=%d,HROn=%d,mpMode=%d,msMode=%d,still=%d"
+ "ch=%ld,frame=%d,MsMBNR=%d,currMSTF=%d,currFusionType=%d,scale0En=%d,isMaster=%d,currQuadra=%d,prevQuadra=%d"
+ "ch=%ld,frame=%d,bMSTF=%d,MLVNR=%d,currMLVNR=%d,bRampdown=%d,frameMLVNRRampDown=%d,frameRate=%d"
+ "ch=%ld,frame=%d,bMSTF=%d,MLVNR=%d,currMLVNR=%d,bRampdown=%d,frameRampDown=%d,frameRate=%d"
+ "ch=%ld,frame=%d,currGain Analog:Digital=%d:%d,totalGain=%d,Thres Enter:Exit=%d:%d"
+ "ch=%ld,frame=%d,currGain Analog:Digital=%d:%d,totalGain=%d,Thres Enter:Exit=%d:%d,FPS Enter:Exit=%d:%d"
+ "ch=%ld,frame=%d,mpMode=%d,msMode=%d"
+ "ch=%ld,frame=%d,p=%d,s=%d,mpMode=%d,msMode=%d,mainProcessingDest=%#x"
+ "ch=%ld,frame=%d,sMS=%d,pMS=%d,syncTag=%d,flash=%d,hrOn=%d,state=%d,mpOn=%d,msOn=%d,mp=%d,ms=%d,s=%d"
+ "ch=%ld,frame=%d,still=%d,strmEn:%d,%d,msMode=%d,s=%d\n"
+ "ch=%ld,frame=%d,tnrFrame=%d,bFESAllowed=%d,bCurrFsclEn=%d,bVHDR=%d,bMLVNRConfig=%d,meshDMA=%d,useCase=%d"
+ "ch=%ld,frame=%d,validBufRectInRawPrimary:%d %d %d %d"
+ "ch=%ld,frame=%d,validBufRectInRawSecondary:%d %d %d %d"
+ "ch=%ld,fusionTypeStill=%d"
+ "ch=%ld,imgW:H=%ld:%ld,fmt=%d,pack=%d,levels=%d,commBufCnt=%d,scale0=%d,msk=0x%zx"
+ "ch=%ld,m=%d,visionPipe[%d %d] pde[%d %d]"
+ "ch=%ld,mallocSize=%ld,count=%ld,poolSel=%d,bCmp=%d"
+ "ch=%ld,raw:W=%d,H=%d,besInFOV:%d %d %dx%d, GDCStrength=%.2f,Bin:%d %d"
+ "ch=%ld,raw:W=%d,H=%d,besInFOV:%d %d %dx%d, MaxStrength=%.2f,Bin:%d %d"
+ "ch=%ld,select=%d,outWidth=%d,outHeight=%d,padding=%d,bufWt=%d,bufHt=%d, bOutputSizeUpdated=%d"
+ "ch=%ld,select=%d,w=%d,h=%d,padding=%d,bufW=%d,bufH=%d, bOutputSizeUpdated=%d"
+ "ch=%ld,select=%d,w=%d,h=%d,padding=%d,bufW=%d,bufH=%d,bCropOutSetInStrm=%d,sycnTag=%d"
+ "ch=%ld,select=%d,zoom1xCrop (%d %d %d %d), bQsumQsubSwitch=%d,syncTag=%d"
+ "ch=%ld,select=%d,zoom1xCrop (%d %d %d %d), scalerCrop (%d %d %d %d)"
+ "ch=%ld,w=%ld,h=%ld,bShared=%d,bScale0En=%d,maxBufCnt=%ld(%u),bCompEn=%d,%s=%d"
+ "ch=%ld,zoom factor - Sen+FES: %.2f BES: %.2f AUX: %.2f"
+ "ch=%ld,zoom factor- Sen+FES: %.2f BES: %.2f AUX: %.2f"
+ "ch=%zu (%s) WRN: sensor already booted! %x\n"
+ "ch=%zu (%s),fc=%u: terminate CapturePrepTask @ t=%f\n"
+ "ch=%zu (%s): - semaArray[%d] = 0x%p \n"
+ "ch=%zu (%s): ACKing sensor secure boot/ECDH key cmd @ %llu\n"
+ "ch=%zu (%s): Exit temp monitoring loop @ %llu\n"
+ "ch=%zu (%s): No temp monitoring for module %d\n"
+ "ch=%zu (%s): Sema received to boot IR sensor, flag %d\n"
+ "ch=%zu (%s): Sema[4] not null %p"
+ "ch=%zu (%s): Start SensorBootTask @ t=%f\n"
+ "ch=%zu (%s): fc=%u terminate SensorBootTask @ t=%f\n"
+ "ch=%zu (%s): temp monitor start @ %llu \n"
+ "ch=%zu DPC buffers mallocSize=%zu"
+ "ch=%zu LSC buffers mallocSize=%zu"
+ "ch=%zu Skip zoom param update"
+ "ch=%zu Static DPC WaitUntilFull available:%zu/%d"
+ "ch=%zu WaitUntilFull buffers available:%zu/%d"
+ "ch=%zu WaitUntilFull buffers available:%zu/%zu"
+ "ch=%zu awbGain=%5d %5d skinWBGain=%5d %5d skyWBGain=%5d %5d"
+ "ch=%zu awbSemCh=%zu isPreviewCh=%hhu "
+ "ch=%zu bStillCap=%d enable=%d fusionType=%d bCTFCircularEn=%d bMSTFScale0En=%d cmdSyncTag=%d"
+ "ch=%zu config %d requiredFrequency=%d\n"
+ "ch=%zu config %zu requiredFrequency=%d\n"
+ "ch=%zu currCPPMode=%u"
+ "ch=%zu distCxyX=%f adjusted=%f, xOffset=%f"
+ "ch=%zu distCxyY=%f adjusted=%f, xOffset=%f"
+ "ch=%zu extSlafEnable=%d/curr=%d tag=%d width=%d %d"
+ "ch=%zu fc=%d bk=%d busy %x"
+ "ch=%zu fc=%d bk=%d hDMAOut=%p hThum=%p hFEPDma=%p"
+ "ch=%zu fc=%d bk=%d hSifDMAOut=%p hThum=%p hFEPDma=%p"
+ "ch=%zu id=0x%x fdAWB=%d sCCM=%d flickAWB=%d LLUnlock=%d ccmSkin=%d MaskD=%d stable=%d fdAWBV=%d fdTrack=%d AWBTS=%d purpleFl=%d"
+ "ch=%zu pfl=%f apsEFL=%f apsPFL=%f\n ps=%f PFL_gdc_min=%f PFL_gdc_max=%f"
+ "ch=%zu start=%u end=%u, oisUMX=%f oisUMY=%f"
+ "ch=%zu static DPC buffers mallocSize=%zu,MaxDPCDefect=%d"
+ "ch=%zu, C2_Calib=%u, C2_Calib_Pre=%u"
+ "ch=%zu, EnterFrameRate(%d) should be not larger than ExitFrameRate(%d)"
+ "ch=%zu, EnterThreshold(%d) should be not less than ExitThreshold(%d)"
+ "ch=%zu, FE freq=%d MHz, BE/MapFE freq=%d:%d MHz, HR freq=%d MHz\n"
+ "ch=%zu, ISP HueMap pipe freq: %d MHz"
+ "ch=%zu, WarmBrck=%u, CoolBrck=%u"
+ "ch=%zu, WhiteLevel[0]=%u, WhiteLevel[1]=%u, WhiteLevel[2]=%u"
+ "ch=%zu, bStillCap=%d, streamEnable0=%d, streamEnable1=%d\n"
+ "ch=%zu, cfg=%d, call ZoomUpdate(), zoomCmdSyncTag=%d"
+ "ch=%zu, coolKnee1=%hu, coolKnee2=%hu"
+ "ch=%zu, dpcType=%d"
+ "ch=%zu, enableThreshold(%d) should be larger than disableThreshold(%d)"
+ "ch=%zu, extSlafEnable=%d en=%d force=%d tag=%d dump=%d"
+ "ch=%zu, fc=%d Static DPC buffer unavailable"
+ "ch=%zu, fesScaleX=%d, pyrScaleX=%d, fesScaleY=%d, pyrScaleY=%d, sensorBinW=%d, sensorBinH=%d\n"
+ "ch=%zu, filename:%s"
+ "ch=%zu, sensorFEFrequency=%d\n"
+ "ch=%zu, timeStamp %u, start %u, end %u, oisOffset2:(%f, %f), frame=%d"
+ "ch=%zu, totalScaleX0=%d, totalScaleY0=%d, totalScaleX1=%d, totalScaleY1=%d\n"
+ "ch=%zu, uint32_t CCM: %u, %u, %u, %u, %u, %u, %u, %u, %u"
+ "ch=%zu, warmKnee1=%hu, warmKnee2=%hu"
+ "ch=%zu, warmStrength=%u, coolStrength=%u, WarmCoolMix=%u"
+ "ch=%zu,%d scalerOut[%d %d]<outWidth[%d %d].BES output larger than input"
+ "ch=%zu,Buf=%zx,UpperBound=%zx,oPatchWidth=%d,countHorPatch=%d,oPatchHeight=%d,countVerPatch=%d"
+ "ch=%zu,Buf=%zx,pPatchDma=%zx,stride=%d,height=%d,UpperBound=%zx"
+ "ch=%zu,Buf=%zx,pPatchDma=%zx,width=%d,height=%d,stride=%d,UpperBound=%zx"
+ "ch=%zu,Buf=%zx,srcY=%zx,stride=%d,height=%d,UpperBound=%zx,Offset=%d"
+ "ch=%zu,SourceGo[%d]:beDest=%#x,go=%#x,feDst=%#x,frameId=%#010x"
+ "ch=%zu,stride=%d,height=%d,Offset=%d"
+ "ch=%zu: %s start CapturePrepTask @ t=%f\n"
+ "ch>=0 && ch < CISP_CH_TOT"
+ "chAppleDescr->ltmInputSrc == LTM_INPUT_SOURCE_HITH"
+ "chCtx[chId].pCtxMem"
+ "chData != 0"
+ "chData[ch].confidenceMapInfo == nullptr"
+ "chData[slaveCh].confidenceMapInfo == nullptr"
+ "chDescr"
+ "chDescr != 0"
+ "chDescr != NULL"
+ "chDescr != nullptr"
+ "chDescr is null!"
+ "chDescr->afWeights != 0"
+ "chDescr->bVirtualOutputCropSet || besOutputHeight <= chDescr->fesMaxOutputHeight"
+ "chDescr->besOriginalOutputHeight[0] >= inRect->height"
+ "chDescr->besOriginalOutputWidth[0] >= inRect->width"
+ "chDescr->colorCalIdealParams.hiCCTbg != 0"
+ "chDescr->colorCalIdealParams.hiCCTrg != 0"
+ "chDescr->colorCalIdealParams.lowCCTbg != 0"
+ "chDescr->colorCalIdealParams.lowCCTrg != 0"
+ "chDescr->configNum != CIMAGESENSOR_CONFIG_INVALID"
+ "chDescr->croppedRectFES.height == chDescr->fesOutputHeight"
+ "chDescr->croppedRectFES.height==chDescr->fesOutputHeight"
+ "chDescr->croppedRectFES.width == chDescr->fesOutputWidth"
+ "chDescr->croppedRectFES.width==chDescr->fesOutputWidth"
+ "chDescr->croppedRectFES.x == 0"
+ "chDescr->croppedRectFES.x==0"
+ "chDescr->croppedRectFES.y == 0"
+ "chDescr->croppedRectFES.y==0"
+ "chDescr->dynPool != 0"
+ "chDescr->dynPool[CIMAGEFLOW_POOL_ID_HIRES_RAW]"
+ "chDescr->fusionType == RAW_FUSION_TYPE"
+ "chDescr->hAWB"
+ "chDescr->hGeneralProcessPipe != 0"
+ "chDescr->hIC != NULL"
+ "chDescr->hIC != nullptr"
+ "chDescr->hIC is null!"
+ "chDescr->hSTF"
+ "chDescr->highResWindowAEAWB != 0"
+ "chDescr->id < ISP_CAMERA_CHANNEL_TOT"
+ "chDescr->isStreaming"
+ "chDescr->maxFrameRate != 0 || chDescr->minFrameRate != 0"
+ "chDescr->sensorConfigs != nullptr"
+ "chDescr->sensorConfigs[cfg].sensorOutputFormatEnum == PIXEL_FORMAT_RAW8 || chDescr->sensorConfigs[cfg].sensorOutputFormatEnum == PIXEL_FORMAT_RAW10 || chDescr->sensorConfigs[cfg].sensorOutputFormatEnum == PIXEL_FORMAT_RAW12 || chDescr->sensorConfigs[cfg].sensorOutputFormatEnum == PIXEL_FORMAT_RAW14 || chDescr->sensorConfigs[cfg].sensorOutputFormatEnum == PIXEL_FORMAT_RAW16"
+ "chDescr->sensorConfigs[chDescr->configNum].sensHeight == rawHeight"
+ "chDescr->sensorConfigs[chDescr->configNum].sensWidth == rawWidth"
+ "chDescr->sensorModel != 0"
+ "chDescr->standby == false"
+ "chDescr->stopICSema != (SEMA)0"
+ "chDescr->windowAE != 0"
+ "chDescr->windowAF != 0"
+ "chDescr->windowAWB != 0"
+ "chDescrH17[ch].pCfgDb"
+ "chDescrH9 != 0"
+ "chDescrH9[ch].msSyncQueue->Size() == 0"
+ "chDescrInput != 0"
+ "chDescr[ch].bChannelInitialized"
+ "chDescr[ch].cachedAEWinSet"
+ "chDescr[ch].cachedAFWindowsSet"
+ "chDescr[ch].cachedHighResAEAWBWinSet"
+ "chDescr[ch].cachedStatZoomUpdate"
+ "chDescr[ch].captureFESCropSize"
+ "chDescr[ch].hAF != 0"
+ "chDescr[ch].hBLC != 0"
+ "chDescr[ch].hFSM != 0"
+ "chDescr[ch].hIC != 0"
+ "chDescr[ch].hLSC != 0"
+ "chDescr[ch].hLTM != 0"
+ "chDescr[ch].hRScl != 0"
+ "chDescr[ch].hWBG != 0"
+ "chDescr[ch].lsMemFull != nullptr"
+ "chDescr[ch].lsMemFullSushiRaw != nullptr"
+ "chDescr[ch].pFlow != 0"
+ "chDescr[ch].pIspEngClient != 0"
+ "chDescr[ch].paramNoiClr.flashOffLTMLuts != 0"
+ "chDescr[ch].paramNoiClr.gamma4Bracketing"
+ "chDescr[ch].paramNoiClr.motionLUT != 0"
+ "chDescr[ch].paramRaw.dpcMem != 0"
+ "chDescr[ch].paramRaw.fpnrRBCCalDataAddr[0]"
+ "chDescr[ch].paramRaw.fpnrRBCCalDataAddr[1]"
+ "chDescr[ch].paramRaw.stLSCroppedPerConfig"
+ "chDescr[ch].paramStat[pipe].pStatHdr != 0"
+ "chDescr[i].fsm != 0"
+ "chDescr[i].notificationExclaveSema != (SEMA)0"
+ "chDescr[i].notificationSema != (SEMA)0"
+ "chDescr[masterCh].awbData.syncTag == pMetaData->syncTag.tag"
+ "chDescr[previewMasterCh].cachedRefBufArray[idx]"
+ "chDescr[secChNumber].hAWB && chEntry->hAWB"
+ "chDst < DISTDRV_CH_TOT"
+ "chEntry"
+ "chEntry->dpcBufferMem"
+ "chEntry->hAE != 0"
+ "chEntry->hAWB"
+ "chEntry->pipe[FILTER_AE] != 0"
+ "chEntry->pipe[FILTER_AF] != 0"
+ "chEntry->pipe[FILTER_AWB] != 0"
+ "chEntry->pipe[FILTER_DHP] != 0"
+ "chEntry->pipe[FILTER_DPC] != 0"
+ "chEntry->pipe[FILTER_ICEXCLAVE] != 0"
+ "chEntry->pipe[FILTER_IC] != 0"
+ "chEntry->pipe[FILTER_LC] != 0"
+ "chEntry->pipe[FILTER_LSC] != 0"
+ "chEntry->pipe[FILTER_LTM] != 0"
+ "chEntry->pipe[FILTER_PDAF] != 0"
+ "chEntry->pipe[FILTER_SEMANTICAWB] != 0"
+ "chEntry->pipe[FILTER_STF] != 0"
+ "chEntry->pipe[FILTER_TIMEMACHINE] != 0"
+ "chEntry->pipe[FILTER_TIMEWARP] != 0"
+ "chEntry->pipe[FILTER_TONECURVE] != 0"
+ "chEntry->pool[FILTER_AE] != 0"
+ "chEntry->pool[FILTER_AF] != 0"
+ "chEntry->pool[FILTER_ALGOCONTROLSERVER][CALGOCONTROLSERVER_POOL_SERVER2ALGO] != 0"
+ "chEntry->pool[FILTER_ALGOCONTROL][CALGOCONTROL_POOL_ALGO2SERVER] != 0"
+ "chEntry->pool[FILTER_ALGOCONTROL][CALGOCONTROL_POOL_CAR] != 0"
+ "chEntry->pool[FILTER_ALGOCONTROL][CALGOCONTROL_POOL_COLORHIST2D] != 0"
+ "chEntry->pool[FILTER_ALGOCONTROL][CALGOCONTROL_POOL_DPC_STAT] != 0"
+ "chEntry->pool[FILTER_ALGOCONTROL][CALGOCONTROL_POOL_HPP] != 0"
+ "chEntry->pool[FILTER_ALGOCONTROL][CALGOCONTROL_POOL_LOCAL_CLIPPING] != 0"
+ "chEntry->pool[FILTER_ALGOCONTROL][CALGOCONTROL_POOL_MESH] != 0"
+ "chEntry->pool[FILTER_ALGOCONTROL][CALGOCONTROL_POOL_RGBHIST] != 0"
+ "chEntry->pool[FILTER_AWB] != 0"
+ "chEntry->pool[FILTER_DHP] != 0"
+ "chEntry->pool[FILTER_DPC] != 0"
+ "chEntry->pool[FILTER_ICEXCLAVE] != 0"
+ "chEntry->pool[FILTER_IC] != 0"
+ "chEntry->pool[FILTER_IC][CIC_POOL_SIDEBAND_LOCAL_0]"
+ "chEntry->pool[FILTER_IC][CIC_POOL_SIDEBAND_LOCAL_1]"
+ "chEntry->pool[FILTER_LC] != 0"
+ "chEntry->pool[FILTER_LSC] != 0"
+ "chEntry->pool[FILTER_LTM] != 0"
+ "chEntry->pool[FILTER_MOTIONEST][CMOTIONESTIMATOR_POOL_0] != 0"
+ "chEntry->pool[FILTER_MOTIONEST][CMOTIONESTIMATOR_POOL_VISPIPE_HAT] != 0"
+ "chEntry->pool[FILTER_MOTIONEST][CMOTIONESTIMATOR_SLAF_MASK] != 0"
+ "chEntry->pool[FILTER_PDAF] != 0"
+ "chEntry->pool[FILTER_PDEPROC][CPDEPROC_POOL_DEPTH_SLAF] != 0"
+ "chEntry->pool[FILTER_PDEPROC][CPDEPROC_POOL_GMS_INTERNAL] != 0"
+ "chEntry->pool[FILTER_PDEPROC][CPDEPROC_POOL_GMS_LOOP_IN] != 0"
+ "chEntry->pool[FILTER_PDEPROC][CPDEPROC_POOL_SPLIT_PD_DX] != 0"
+ "chEntry->pool[FILTER_PDEPROC][CPDEPROC_POOL_SPLIT_PD_SCORE] != 0"
+ "chEntry->pool[FILTER_SEMANTICAWB][CAWBSEMANTIC_CONFIDENCE_MAP_POOL_OUTPUT] != 0"
+ "chEntry->pool[FILTER_SEMANTICAWB][CAWBSEMANTIC_HIRES_POOL_OUTPUT] != 0"
+ "chEntry->pool[FILTER_STF][CSTF_MTH_SETTING_POOL] != 0"
+ "chEntry->pool[FILTER_STF][CSTF_STF_COEFFICIENTS_SETTING_POOL] != 0"
+ "chEntry->pool[FILTER_STF][CSTF_STF_WEIGHTMAP_SETTING_POOL] != 0"
+ "chEntry->pool[FILTER_STILLFLOW][FLOWBASE_BUFFER_POOL_OUTPUT_ALGO_BUF]"
+ "chEntry->pool[FILTER_STILLFLOW][VFLOWH17_BUFFER_POOL_AUXPYR_UV]"
+ "chEntry->pool[FILTER_STILLFLOW][VFLOWH17_BUFFER_POOL_AUXPYR_Y]"
+ "chEntry->pool[FILTER_STILLFLOW][VFLOWH17_BUFFER_POOL_CLRBE_TILE] != 0"
+ "chEntry->pool[FILTER_STILLFLOW][VFLOWH17_BUFFER_POOL_PDE] != 0"
+ "chEntry->pool[FILTER_STILLFLOW][VFLOWH17_BUFFER_POOL_PYROUTPROC0_SCALE0] != 0"
+ "chEntry->pool[FILTER_STILLFLOW][VFLOWH17_BUFFER_POOL_PYROUTPROC0_SCALE1] != 0"
+ "chEntry->pool[FILTER_STILLFLOW][VFLOWH17_BUFFER_POOL_PYROUTPROC0_SCALE2TO5] != 0"
+ "chEntry->pool[FILTER_STILLFLOW][VFLOWH17_BUFFER_POOL_VISSDET_KEY] != 0"
+ "chEntry->pool[FILTER_TIMEMACHINE] != 0"
+ "chEntry->pool[FILTER_TIMEMACHINE][CTIMEMACHINE_POOL_META] != 0"
+ "chEntry->pool[FILTER_TIMEWARP] != 0"
+ "chEntry->pool[FILTER_TONECURVE] != 0"
+ "chEntry->pool[FILTER_VIDEOFLOW][FLOWBASE_BUFFER_POOL_OUTPUT_ALGO_BUF]"
+ "chEntry->pool[FILTER_VIDEOFLOW][VFLOWH17_BUFFER_POOL_AUXPYR_SCALE0]"
+ "chEntry->pool[FILTER_VIDEOFLOW][VFLOWH17_BUFFER_POOL_AUXPYR_UV]"
+ "chEntry->pool[FILTER_VIDEOFLOW][VFLOWH17_BUFFER_POOL_AUXPYR_Y]"
+ "chEntry->pool[FILTER_VIDEOFLOW][VFLOWH17_BUFFER_POOL_CLRBE_TILE] != 0"
+ "chEntry->pool[FILTER_VIDEOFLOW][VFLOWH17_BUFFER_POOL_M2MGDC_TILE] != 0"
+ "chEntry->pool[FILTER_VIDEOFLOW][VFLOWH17_BUFFER_POOL_MLAF] != 0"
+ "chEntry->pool[FILTER_VIDEOFLOW][VFLOWH17_BUFFER_POOL_MTH_OUTPUT] != 0"
+ "chEntry->pool[FILTER_VIDEOFLOW][VFLOWH17_BUFFER_POOL_PDE] != 0"
+ "chEntry->pool[FILTER_VIDEOFLOW][VFLOWH17_BUFFER_POOL_PYROUTPROC0_SCALE0] != 0"
+ "chEntry->pool[FILTER_VIDEOFLOW][VFLOWH17_BUFFER_POOL_PYROUTPROC0_SCALE1] != 0"
+ "chEntry->pool[FILTER_VIDEOFLOW][VFLOWH17_BUFFER_POOL_PYROUTPROC0_SCALE2TO5] != 0"
+ "chEntry->pool[FILTER_VIDEOFLOW][VFLOWH17_BUFFER_POOL_RAW_RES] != 0"
+ "chEntry->pool[FILTER_VIDEOFLOW][VFLOWH17_BUFFER_POOL_SEMANTIC_VIDEO] != 0"
+ "chEntry->pool[FILTER_VIDEOFLOW][VFLOWH17_BUFFER_POOL_VISSDET_KEY] != 0"
+ "chEntry->pool[FILTER_VISRESIZE][CVISIONRESIZEH17_POOL_OUTPUT_REGISTRATION] != 0"
+ "chEntry->pool[FILTER_VISRESIZE][CVISIONRESIZE_POOL_OUTPUT_INTERNAL_0] != 0"
+ "chEntry->pool[FILTER_VISRESIZE][CVISIONRESIZE_POOL_OUTPUT_INTERNAL_2] != 0"
+ "chEntryApple->bUseDualStatPipe"
+ "chEntryApple->staticDpcBuffer"
+ "chId %d mask %x %x"
+ "chId %lu pipeId %lu\n"
+ "chId < ISP_CAMERA_CHANNEL_TOT"
+ "chId < inchannels"
+ "chId < size_t(totalCh)"
+ "chId = %zu, curBufStrid = %zu, strideVis = %d, stride = %d"
+ "chId == WIDE_CAM_CH"
+ "chId == pChInfo->chId"
+ "chId=%d is not in run state (%d)"
+ "chId=%ld"
+ "chInfo != 0"
+ "chInfo.channel < ISP_CAMERA_CHANNEL_TOT"
+ "chLeader<CISP_CH_TOT"
+ "chLocks[ch] != (FFWMUTEX) 0"
+ "chMan != 0"
+ "chManH2T != 0"
+ "chParam != 0"
+ "chParam[i] != 0"
+ "chProcStart"
+ "chSrc < DISTDRV_CH_TOT"
+ "chT2H != 0"
+ "chTmp == pMetaDataOutgoing->channel"
+ "chTot %u deepth %u masks %u"
+ "chTot %zu mask %x ch %d"
+ "chTot <= MAX_CHANNELS"
+ "chTot > 0"
+ "ch[%d]\n"
+ "ch[%zu] enable DGDM Joint prevVisSDetNumKeyDesc = %d"
+ "chain %d source %d statSrc %d mStatId %d srcDMAIndex %d, SENS0DMA %d"
+ "channel %d changed from shared to Exclusive"
+ "channel %u %u streaming %d %d bNeedMap %d"
+ "channel %u not started!"
+ "channel < CISP_CH_TOT"
+ "channel < EXTCAL_MAX_CHANNELS"
+ "channel < MAX_ISP_CHANNELS"
+ "channel < inchannels"
+ "channel < outchannels"
+ "channel = %d"
+ "channel >= channelBaseNumber"
+ "channel not starting!. Change to blocking AlgoCtrl Cmd %zu\n"
+ "channel=%zu,flowType=%d"
+ "channelBaseNumber == 2"
+ "channelBaseNumber == 5"
+ "channelDst < EXTCAL_MAX_CHANNELS"
+ "channelDst < EXTCAL_MAX_CHANNELS || channelDst == EXTCAL_WORLD"
+ "channelInfo"
+ "channelInfo != 0"
+ "channelInfoH8 != 0"
+ "channelInfo[aeCh].lastMultiCamZoomCmd.numCh <= MAX_CHANNELS"
+ "channelInfo[chIdx].cropOptions"
+ "channelInfo[chIdx].sensorConfigs"
+ "channelInfo[chIdx].zoomCenterOffset"
+ "channelMask > 0"
+ "channelMid != channelDst"
+ "channelMid < EXTCAL_MAX_CHANNELS"
+ "channelPhys != 0"
+ "channelSrc != EXTCAL_WORLD || channelDst != EXTCAL_WORLD"
+ "channelSrc != channelDst"
+ "channelSrc != channelMid"
+ "channelSrc < EXTCAL_MAX_CHANNELS"
+ "channelSrc < EXTCAL_MAX_CHANNELS || channelSrc == EXTCAL_WORLD"
+ "channelStarted[ch]"
+ "channel_mem != NULL"
+ "channels == CISP_CH_TOT"
+ "checkCamStable"
+ "checking ch %zu firstFrame %d"
+ "checking quark readiness... %llu %u"
+ "chroma"
+ "cicDist != NULL"
+ "clear_faults"
+ "clipMin: %d, clipMax: %d"
+ "clipRectMax.containsRect(clipRect)"
+ "clipRectMax.containsRect(clipRectRequest)"
+ "clippedX=%i unclippedX=%i"
+ "clippedY=%i unclippedY=%i"
+ "clk applied. %016llx\n"
+ "clk syscfg %016llx\n"
+ "clk syscfg update\n"
+ "clkBoostTimeoutSema != (SEMA)0"
+ "clrProcDmaEn & FLOWH17_DMA_ID_BIT_MASK(ClrProcDmaDstChroma)"
+ "clrProcDmaEn == clrProcDmaEnabled"
+ "clrProcViewRect (%d %d %d %d)"
+ "clrproc"
+ "clrproc preview size %u %u"
+ "clrproc rect %u %u %u, %u"
+ "cmd %x TS: %f \n"
+ "cmd <= M3COMMANDID_SENSOR_CMD_ID_SENSOR_ENABLESTREAMING_SET"
+ "cmd >= M3COMMANDID_SENSOR_CMD_ID_SENSOR_ACK"
+ "cmd->warpSliceCount <= MAX_BES_WARP_SLICES"
+ "cmd.pConfig != NULL"
+ "cmd.pConfig != nullptr"
+ "cmd.pDmaManager != nullptr"
+ "cmdAckSema[i] != (SEMA)0"
+ "cmdBuf->Size() >= sizeof(*pMsg) + subPacketSize"
+ "cmdBuffer"
+ "cmdCached.length == 0"
+ "cmdCached.length == sizeof(FwDetectorOcStorage)"
+ "cmdDelayedQueue->Size() == 0"
+ "cmdInternalSema != (SEMA)0"
+ "cmdLog != 0"
+ "cmdMbox != (MBOX)0"
+ "cmdMboxSema != (SEMA)0"
+ "cmdPacketLen == sizeof(AOPTlPacketHeader) + sizeof(AOPSubPacketHeader) + pAppHeader->payloadSize"
+ "cmdPacketLen > sizeof(AOPTlPacketHeader) + sizeof(AOPSubPacketHeader)"
+ "cmdPacketLen > sizeof(OscarPacketTail2) + sizeof(OscarPacketHeader2)"
+ "cmdPacketLen >= sizeof(AOPTlPacketHeader) + sizeof(AOPSubPacketHeader)"
+ "cmdPacketLen >= sizeof(AOPTlPacketHeader) + sizeof(AOPSubPacketHeader) + pAppHeader->payloadSize"
+ "cmdQueue != 0"
+ "cmdQueue->Size() == 0"
+ "cmdSema != (SEMA)0"
+ "cmdSemaT2H != (SEMA)0"
+ "cmdSyncSema != (SEMA)0"
+ "cmdSynchronizationSema != (SEMA)0"
+ "cmdTimeoutSema != (SEMA)0"
+ "cmdTimeoutTimer != NULL"
+ "cmpCfg: strideInY=%d, strideInC=%d, picIn: strideInY=%lu, strideInC=%lu\n"
+ "cmpCfg: strideOutY=%d, strideOutC=%d, picOut: strideOutY=%lu, strideOutC=%lu\n"
+ "cmpnCheckRslt.f.isFrameCmpn"
+ "cmpnDmaAttr[%d]: dmaId=%4d, cmpnDmaIdxNext=%4d, offsetCmpn=0x%8x\n"
+ "cmpnDmaAttr[i].cmpnDmaIdxNext == ISPHWH17CMPNDMAIDX_INVALID"
+ "cmpnDmaDsidReset"
+ "cmpnDmaIdx != ISPHWH17CMPNDMAIDX_INVALID"
+ "cmpnRtrIndex < MAX_CRMGR_CNT"
+ "cmpnRtrMgrDescCnt[%d]=(%d) should be equal or less than %d"
+ "cnt <= totalSizeInWord"
+ "colLineFlags != nullptr"
+ "colLineFlags is null!"
+ "colMin >= 0"
+ "color == FESTATS_COLOR_YC1C2 || color == FESTATS_COLOR_camYC1C2"
+ "colorTable[%2d]  = %4d, 0x%04X, 0x%04X"
+ "colorcal bgGain (0x%hx or %4.2f): Not between [0.80 1.20]; reset to 1.0."
+ "colorcal rgGain (0x%hx or %4.2f): Not between [0.80 1.20]; reset to 1.0."
+ "colorcalBias= [%hu %hu %hu %hu]"
+ "colorspace < AWB_COLORSPACE_TOTAL"
+ "comMain:%x controlMain:%x comSifr:%x controlSifr:%x WaitFor2ndSource:%d"
+ "comMain:%x controlMain:%x comSifr:%x controlSifr:%x WaitFor2ndSource:%d FSM:%d newReq:%d"
+ "comboWBGain %u %u %u"
+ "commandedChannelsTot <= sizeof(commandedChannel)/sizeof(commandedChannel[0])"
+ "commonArea = %f, fovSimScr = %f"
+ "commonRect.height <= pDescr->paramBES.outHeight[IMAGE_BE_OUTPUT_PREVIEW]"
+ "commonRect.height <= pDescr->paramBES.outHeight[IMAGE_BE_OUTPUT_SECONDARY]"
+ "commonRect.width <= pDescr->paramBES.outWidth[IMAGE_BE_OUTPUT_PREVIEW]"
+ "commonRect.width <= pDescr->paramBES.outWidth[IMAGE_BE_OUTPUT_SECONDARY]"
+ "commonRectStill.x >= pDescr->stillOutStrmRect.x && (uint32_t)commonRectStill.width + commonRectStill.x <= (uint32_t)pDescr->stillOutStrmRect.width + pDescr->stillOutStrmRect.x"
+ "commonRectStill.y >= pDescr->stillOutStrmRect.y && (uint32_t)commonRectStill.height + commonRectStill.y <= (uint32_t)pDescr->stillOutStrmRect.height + pDescr->stillOutStrmRect.y"
+ "comp < 3"
+ "comp16_10 == 0"
+ "compHist0BEnabled was not enabled"
+ "compIndex <= pTableInfo->compNbr"
+ "compandEn == 0"
+ "companionSanityCheck"
+ "companionSanityCheck(): DMAId=%d, DMAIdx=%d, isFrame=%d, withCompSrc=%d, withCompDst=%d\n"
+ "compare ANST netout %p with ref %p"
+ "compare ATTR netout %p with ref %p"
+ "compare netout[%u] offset %u size %u to ref offset %u"
+ "compareADResult"
+ "compareFDResult"
+ "compareODResult"
+ "compareResultAnst"
+ "compareResultAttr"
+ "comparisonDump"
+ "computeAttnGlassesEyesClosedScores"
+ "computeDepthDistance"
+ "computeFaceWeight"
+ "computeFaceWeightForToneHFF"
+ "computeLinear"
+ "computeMotionMetric"
+ "computeOdScore"
+ "computeThumbHistBlendingWeight"
+ "concatDesiredFPSPerChannel"
+ "config"
+ "config < configTot"
+ "config < m_sensorConfigsTot"
+ "config x %u y %u rectIn %u %u %u %u rectOut %u %u %u %u"
+ "config->numHorThumbnailBlocks <= MAX_HITH_THUMBNAIL_WIDTH"
+ "config->numHorThumbnailBlocks == LTM_THUMBNAIL_WIDTH"
+ "config->numHorThumbnailBlocks >= config->thumbnailScaleFactor * LTM_THUMBNAIL_WIDTH"
+ "config->numVerThumbnailBlocks == LTM_THUMBNAIL_HEIGHT"
+ "config->numVerThumbnailBlocks >= config->thumbnailScaleFactor * LTM_THUMBNAIL_HEIGHT"
+ "config->thumbnailDownsampleX % 2 == 0"
+ "config->thumbnailDownsampleX * config->thumbnailDownsampleY <= MAX_HITH_THUMBNAIL_BLOCK_PIXELS"
+ "config->thumbnailDownsampleX >= MIN_HITH_THUMBNAIL_BLOCK_WIDTH"
+ "config->thumbnailDownsampleY % 2 == 0"
+ "config->thumbnailRect.end_x <= HITHStatROI->x + HITHStatROI->width"
+ "config->thumbnailRect.end_y <= HITHStatROI->y + HITHStatROI->height"
+ "config.NumberOfLevels=%d"
+ "config.f.HorzInt <= 1024"
+ "config.f.HorzInt >= 8"
+ "config.f.VertInt <= 1024"
+ "config.f.VertInt >= 8"
+ "config.field.comp <= pTableInfo->compNbr"
+ "config.imgWidth && config.imgHeight"
+ "config.output.MsBePYROutputHeight"
+ "config.output.MsBePYROutputWidth"
+ "config.output.sensorCropAtSifForSifr.y != 0"
+ "config.output.sensorReadOutCropRect.height == config.output.sensorReadOutCropSifrRect.height"
+ "config.output.sensorReadOutCropRect.width == config.output.sensorReadOutCropSifrRect.width"
+ "config.output.sensorReadOutCropRect.x == config.output.sensorReadOutCropSifrRect.x"
+ "config.output.sensorReadOutCropRect.y == config.output.sensorReadOutCropSifrRect.y"
+ "config.priorLambda == 0.1f"
+ "config.tikLambda == 1e-5f"
+ "config2BaseFOVRatioH <= 1"
+ "config2BaseFOVRatioV <= 1"
+ "config=%u (while smooth=%u samplingRate=%.3f Hz)"
+ "configDMA"
+ "configIdx < m_sensorConfigsTot"
+ "configIndex != CIMAGESENSOR_CONFIG_INVALID"
+ "configMatch == true"
+ "configMode < CISP_CAMERA_CONFIG_MODE_TOTAL"
+ "configNum < NUM_ELEMENTS(IMX575_Configs)"
+ "configNum < hSensor->TotalConfigsGet()"
+ "configNum < sizeof(IMX714_Readout_Position) / sizeof(struct sSensorReadoutInfoAligned)"
+ "configNumIn < configTot"
+ "configNumOut < configTot"
+ "configNumber != (int16_t)CIMAGESENSOR_CONFIG_INVALID"
+ "configNumber != -1"
+ "configNumber != -1 && configNumber < (int16_t)configTot"
+ "configNumber < numSplitPDConfigs(true)"
+ "configNumber < sizeof(sSplitPDEnableCfgIMX633_Ptrs)/sizeof(sSplitPDEnableCfgIMX633_Ptrs[0])"
+ "configNumber < sizeof(sSplitPDEnableCfgIMX703_Ptrs)/sizeof(sSplitPDEnableCfgIMX703_Ptrs[0])"
+ "configQuery.sensWidth > 0 && configQuery.sensHeight > 0"
+ "configRes"
+ "configShim!=NULL"
+ "configTable < (int32_t)tableNbr"
+ "configUpdate.currentCmd"
+ "configUpdate.currentCmd == __null"
+ "configUpdate.state != PERIDOT_UPDATE_CONFIG_STATE_UPDATE_DONE_DURING_TBC_SEQ"
+ "configUpdate.updatesHead"
+ "configUpdate.updatesHead->type == PERIDOT_STREAMING_COMMAND_NEW_SEQUENCE"
+ "config[%u] type %u size %u"
+ "configsTot != 0"
+ "configsTot <= CDS_CONTROLLER_MAX_SENSOR_CONFIGS"
+ "construction < LC_MODULE_CONSTRUCTION_COUNT"
+ "context"
+ "context != NULL"
+ "context != nullptr"
+ "contextSwitchSensorConfigReq != AE_SENSOR_CONFIG_INVALID"
+ "contextSwitchSensorConfigReq == AE_SENSOR_CONFIG_INVALID"
+ "contributionration (flash/ambient) %f\n"
+ "controlLUT != 0"
+ "convertCascadeChangeToFPS"
+ "coolClip=%.2f, warmClip=%.2f"
+ "coolRatioCurr=%.4f coolRatioPrev=%.4f"
+ "copy offset %u size %u to %u"
+ "coreErrClean = 0x%x"
+ "coreGRF[%d] = 0x%x"
+ "coreSRF[%d] = 0x%x"
+ "coreVRF[%d][%d] = 0x%x"
+ "coredumpContext >= BSP_DATA_end"
+ "corrGeometry.chunkCount * corrGeometry.profileCount <= PDAF::PixelEngine::CORR_NCHUNKS"
+ "costBuf too small!"
+ "costBufLen >= costMatSize * costMatSize"
+ "count"
+ "count != 0"
+ "count < EXP_GAIN_LUT_MAX_COUNT"
+ "count < maxSegments"
+ "count <= AE_BRACKETING_CAPTURE_MAX"
+ "count <= CIMAGESENSOR_MAX_CUSTOM_REG_SETTING"
+ "count <= CImageFlow::rawBuffers"
+ "count <= CImageFlow::rawBuffers * MAX_CH_PER_COMMON_RAW_POOL"
+ "count <= EXP_GAIN_LUT_MAX_COUNT"
+ "count <= period"
+ "count > 0"
+ "count > idxNew"
+ "count >= 0"
+ "count >= 1"
+ "count<=CAE_PHOTOMETER_FLICKER_FREQ_MAX_COUNT"
+ "countX <= AE_YMAP_TILES_X"
+ "countY <= AE_YMAP_TILES_Y"
+ "counter+thumbnailXSize < thumbnailTotalSize"
+ "counter-thumbnailXSize >= 0"
+ "create vcpipe %p %p"
+ "create writeRingBufferLen %d with writeRingBufferAddr at 0x%lx %d\n"
+ "criticalReqBufCount <= totalReqBufCount"
+ "crop start x %u y %u"
+ "cropEndX >= cropStartX"
+ "cropEndY >= cropStartY"
+ "cropFromYuvPyramid"
+ "cropHeightScaler is %d\n"
+ "cropRect != 0 && validDataRect != 0 && sensorOutRect != 0"
+ "cropRect->height >= 0"
+ "cropRect->width >= 0"
+ "cropResize.dstInitX == 0 && cropResize.dstInitY == 0"
+ "cropResize.dstWidth == dst.info.width && cropResize.dstHeight == dst.info.height"
+ "cropcfgLen >= acc->attrNetInputCropControls.numNetControls"
+ "crops[0] == crop"
+ "crops[0].size.x <= crop.size.x"
+ "crops[0].size.y == crop.size.y"
+ "crops[0].start == crop.start"
+ "crops[0].unifyWithRect(crops[1]) == crop"
+ "crops[1] == crop"
+ "csCh < chTot"
+ "csConfigs != nullptr"
+ "csConfigs[i].fesEnable"
+ "csNumCh < CAE_MAX_CAM_TOT"
+ "csNumCh == numRgbCam"
+ "cstm_QuarkTxGlobal != nullptr"
+ "ctl"
+ "ctrlData && ctrlData->payload"
+ "ctrlNew"
+ "ctrlPearl != nullptr"
+ "ctrlPearl->IsPearlStopPending() == false"
+ "ctx != 0"
+ "ctx->mTransform != 0"
+ "ctx.channId < CDCNPROC_CHANNEL_TOT"
+ "ctx.channId < CERDCNPROC_CHANNEL_TOT"
+ "ctx.channId < CFDDCNPROC_CHANNEL_TOT"
+ "ctx.frameId == frameId"
+ "ctx.frameId == pMsg->frameId"
+ "ctx.ipcParam.bufNbr <= maxAneIpcBufMsg"
+ "ctx.ipcParam.progCallPacket.builtinProgramId == 0"
+ "ctx.ipcParam.progCallPacket.builtinProgramId == ANE_NET_T287_ER"
+ "ctx.isDepth == 0"
+ "ctx.modelId == 0"
+ "ctx.netDone[ANE_NET_T287_AD] && ctx.netDone[ANE_NET_T287_LO] && ctx.netDone[ANE_NET_T287_GD]"
+ "ctx.netDone[ANE_NET_T287_AD] == 0 && ctx.netDone[ANE_NET_T287_LO] == 0"
+ "ctx.netDone[ANE_NET_T287_AD_LANDSCAPE] && ctx.netDone[ANE_NET_T287_LO] && ctx.netDone[ANE_NET_T287_GD]"
+ "ctx.netDone[ANE_NET_T287_AD_LANDSCAPE] == 0 && ctx.netDone[ANE_NET_T287_LO] == 0"
+ "ctx.netIds[i] < ANE_NET_TOT"
+ "ctx.numOfNetworks <= maxNumDcnPerRequest"
+ "ctx.pBufs[(uint32_t)BufferIndex::RAW]->Size(0) >= kRawPackedHeight * ctx.pBufs[(uint32_t)BufferIndex::RAW]->Stride(0)"
+ "ctx.pBufs[(uint32_t)BufferIndex::SMETA]"
+ "ctx.pBufs[i]"
+ "ctx.pMeta"
+ "ctxAllocated"
+ "ctxAllocated == (ctxIdx != CIndexPool::invalidIndex)"
+ "ctxIdx < kAICamQueueSize"
+ "ctxIdx < kERQueueSize && ctxIdx >= 0"
+ "ctxIdx < kFDQueueSize && ctxIdx >= 0"
+ "ctxIdx == 0"
+ "ctxIdx >= 0 && ctxIdx < kAICamQueueSize"
+ "ctxIdx >= 0 && ctxIdx < kAttnQueueSize"
+ "ctxIdx >=0 && ctxIdx < kERQueueSize"
+ "ctxIdx >=0 && ctxIdx < kFDQueueSize"
+ "ctxIdx >=0 && ctxIdx < kQueueSize"
+ "ctxIdx>=0 && ctxIdx < kERQueueSize"
+ "ctxIdx>=0 && ctxIdx < kFDQueueSize"
+ "ctxidx %zu %p %p"
+ "ctxs[i].results"
+ "cumPerc[i] >= cumPerc[i-1]"
+ "cur=%zu irR=%6.4f freqConf=%u dcR=%u lux=%.2f valid=%hhu"
+ "curCmpnConfigActionIndex < maxCmpnActionListDepth"
+ "curEntry"
+ "curFileOffset + maxFileSize <= maxTotBundleSize"
+ "curLsState.pLSChromaConfig && curLsState.pLSChromaConfig->H6.base"
+ "curLsState.strideEntryNumChroma == strideEntryNumChroma"
+ "curSIFROperationMode != SIFR_MODE_OFF"
+ "curSIFROperationMode == SIFR_MODE_OFF"
+ "curScanPositionIndex >= 0"
+ "curr"
+ "curr->type == CISP_PERIDOT_SEQ_ENTRY_TYPE_MODE_CONFIG"
+ "currContextRegs != 0"
+ "currDescBuffBaseAddrHigh = 0x%x"
+ "currDescBuffBaseAddrLow = 0x%x"
+ "currDescBuffHAMVOffset = 0x%x"
+ "currDescBuffSetHAMVSize = 0x%x"
+ "currDescBuffSetSize = 0x%x"
+ "currDescBuffTIDOffset = 0x%x"
+ "currDisplayRange >= rangeSeg2"
+ "currEntry->type == CISP_PERIDOT_SEQ_ENTRY_TYPE_MODE_CONFIG"
+ "currFSMMasterCh == masterCh"
+ "currFrameSkipInterval %d busy %d go %d"
+ "currMatchBuffBaseAddrHigh = 0x%x"
+ "currMatchBuffBaseAddrLow = 0x%x"
+ "currReplayFileIndex %zu"
+ "currReqIdx < totReq"
+ "currSetting"
+ "currSetting != 0"
+ "currSetting->isSifrOn %d\n"
+ "currSetting->zoom.MsBePYRCropRect.height"
+ "currSetting->zoom.MsBePYRCropRect.width"
+ "currState != NULL"
+ "current < 256"
+ "current descriptor %d, matched %d"
+ "current warpMarix"
+ "current(16.16):0x%x %.4f max(16.16)=0x%x %.4f, currRatio:0x%x %.4f"
+ "current= %d mA reg= 0x%02x"
+ "current= %d uA reg= 0x%x"
+ "current= 0x%x or %7.2f mA reg= 0x%02x"
+ "currentCH=%hhu calibCamSetFile=0x%x slaveCamID=%2hhu"
+ "currentCaptureTime %f motionDataTs %f\n"
+ "currentFocusPosition %d exposureTime %f\n"
+ "currentFrameInput.darkEit > 0.0f"
+ "currentFrameInput.eit > 0.0f"
+ "currentFrameInput.exposureBias > 0.0f"
+ "currentFrameInput.exposureRatio > 0.0f"
+ "current[%i] >= current[%i], %f >= %f"
+ "current[i] >= (current[i-1] - FLT_EPSILON)"
+ "currents"
+ "currents[0]=%d currents[1]=%d"
+ "currnet framename %s, width = %d, stride = %d, height = %d"
+ "custom tx config is null"
+ "cvPipe Init %d %d %d %d"
+ "cvPipe Step %d %d %d %d"
+ "cvdBufOut->DataPointer(0) != nullptr"
+ "cvpipeDstConfig->outWidth * cvpipeDstConfig->outHeight * 4 <= buf->Size()"
+ "cw_rg=%f cw_bg=%f ww_rg=%f ww_bg=%f"
+ "dDac != 0"
+ "dPrio != 0"
+ "dPrio % 2 == 0"
+ "dPrio <= 124"
+ "dPrio <= RTK_THREAD_PRIORITY_MAX"
+ "dPrio >= RTK_THREAD_PRIORITY_MIN"
+ "dR=%6.4f dG=%6.4f dB=%6.4f maskProb=%6.4f, faceAngleUnitVector=%6.4f, %6.4f"
+ "darkEIT=%.3f"
+ "darkPixelNumPerRow[i] <= numX_half"
+ "data"
+ "data != 0"
+ "data != nullptr"
+ "data/besDmaMeshIn_%d.bin"
+ "data/ch%d-%s-w%d-h%d-t%d-%s.cmp.bin"
+ "data/ch%d-%s-w%d-h%d-t%d-%s.hdr.bin"
+ "dataAddrLen > 0"
+ "dataBufSize == pBuf->_header._size"
+ "dataFileInfo.dataFileAddr != 0"
+ "dataIdx < CISP_AE_BRACKETING_CHANNEL_COUNT_MAX"
+ "dataIdx < pMultiChUBKTParams->channelCount"
+ "dataIdx > 0"
+ "dataLen < SMB_RECEIVE_FIFO_MAX_SIZE"
+ "dataLen <= BYTE_COUNT_MAX"
+ "dataLen <= readFifoSize"
+ "dataLen > 0"
+ "dataSize <= 0x1000"
+ "dataSize == sizeof(sPCERgbIrPearlDepth)"
+ "dataSource=%d,mpMode=%d,msMode=%d"
+ "data_addr_len_total <= sizeof(i2c_write_block.field0.data.p_data)"
+ "datapointer %p size %zu\n"
+ "daylightScore: %.2f"
+ "daylightWeight=%.3f, pMTH->coolStrength=%.3f"
+ "ddfPFL is out of range. %f"
+ "deallocate"
+ "debugCount == 0"
+ "debugCountBreakPoint = 0x%x"
+ "debugCountBreakPointEn = 0x%x"
+ "debugDataAddrBreakpointBaseAddress[%d] = 0x%x"
+ "debugDataAddrBreakpointEn[%d] = 0x%x"
+ "debugDataAddrBreakpointEndOffset[%d] = 0x%x"
+ "debugEnable = 0x%x"
+ "debugFatalErrMask = 0x%x"
+ "debugM3Mutex != (FFWMUTEX)0"
+ "debugM3Sema != 0"
+ "debugPCBreakpointEn[%d] = 0x%x"
+ "debugPCBreakpoint[%d] = 0x%x"
+ "debugPacketCountClr = 0x%x"
+ "debugPyr0"
+ "debugPyr1"
+ "debugPyr2"
+ "debugResume = 0x%x"
+ "debugStatusBreakpointMask[0] = 0x%x"
+ "debugStatusBreakpointMask[1] = 0x%x"
+ "debugStatusBreakpointMask[2] = 0x%x"
+ "decideLumaToMotionIntelligenceDepth"
+ "decimationService != 0"
+ "decoder < CLPDP_MAX_SST_DECODER"
+ "default HWRegConfig cant be compressed"
+ "default crop %d %d"
+ "defectCntNVM < IMX633_STATIC_DPC_SIZE"
+ "defectCntNVM < IMX703_STATIC_DPC_SIZE"
+ "defectCntNVM < IMX713_STATIC_DPC_SIZE"
+ "defectCntNVM <= IMX633_HERMIT_DPC_DARK_MAX"
+ "defectCntNVM <= IMX633_HERMIT_DPC_LIGHT_MAX"
+ "defectCntNVM <= IMX703_HERMIT_DPC_DARK_MAX"
+ "defectCntNVM <= IMX703_HERMIT_DPC_LIGHT_MAX"
+ "defectCntNVM <= IMX713_HERMIT_DPC_DARK_MAX"
+ "defectCntNVM <= IMX713_HERMIT_DPC_LIGHT_MAX"
+ "defectCntNVM <= IMX714_HERMIT_DPC_MAX"
+ "defectCntNVM <= IMX714_STATIC_DPC_SIZE"
+ "defectCntNVM <= IMX803_HERMIT_DPC_DARK_MAX"
+ "defectCntNVM <= IMX803_HERMIT_DPC_LIGHT_MAX"
+ "defectCntNVM <= IMX903_HERMIT_DPC_DARK_MAX"
+ "defectCntNVM <= IMX903_HERMIT_DPC_LIGHT_MAX"
+ "defectCntNVM <= IMX913_HERMIT_DPC_DARK_MAX"
+ "defectCntNVM <= IMX913_HERMIT_DPC_LIGHT_MAX"
+ "defectTable != nullptr || numDefect == 0"
+ "defectTableMem != 0"
+ "defectTableMemQsub != 0"
+ "defectTableMemQsum != 0"
+ "defectTableMemQsumV2H2 != 0"
+ "defectTableMemV2H2 != 0"
+ "deferBufAllocSemaReqNotify[ch]"
+ "deferBufAllocSemaReqNotify[ch] != NULLSEMA"
+ "deferredCmdAck == false"
+ "delayCountEXP > 2"
+ "delegated_c_client.c"
+ "deltaC2"
+ "deltaGW = %f, dwgConf = %f"
+ "deltaSelect == 0 || deltaSelect == 1"
+ "denom != 0"
+ "depth %u"
+ "depth=%d AuxScl=%d tileGDC=%d when TileGDC and depth both enabled, the AuxScl cannot be configured as output"
+ "depthDataBuf != nullptr"
+ "depthDataType == latestDepthData.dataType"
+ "depthDownscaledInput.bin"
+ "depthHistParamsAF->totNumOfSpotsInRoi != 0"
+ "depthHistParamsAF->totNumOfSpotsInRoiWithHighConf < DEPTHPROC_MAX_DEPTH_ENTRIES"
+ "depthInput.data"
+ "depthMax <= TIMEMACHINE_MAX_DEPTH"
+ "depthProcOutputBuffer->Size() >= sizeof(sInternalDepthDebug)"
+ "depthServiceEntry != nullptr"
+ "desMatch.biDirMatchListBaseAddrHigh = 0x%x"
+ "desMatch.biDirMatchListBaseAddrLow = 0x%x"
+ "desMatch.byPass = 0x%x"
+ "desMatch.currDescBuffBaseAddrHigh = 0x%x"
+ "desMatch.currDescBuffBaseAddrLow = 0x%x"
+ "desMatch.currDescBuffHAMVOffset = 0x%x"
+ "desMatch.currDescBuffSetHAMVSize = 0x%x"
+ "desMatch.currDescBuffSetSize = 0x%x"
+ "desMatch.currDescBuffTIDOffset = 0x%x"
+ "desMatch.currMatchBuffBaseAddrHigh = 0x%x"
+ "desMatch.currMatchBuffBaseAddrLow = 0x%x"
+ "desMatch.hamvDistThresh = 0x%x"
+ "desMatch.hamvSize = 0x%x"
+ "desMatch.homographyBoundaryMax_x = 0x%x"
+ "desMatch.homographyBoundaryMax_y = 0x%x"
+ "desMatch.homographyBoundaryMin_x = 0x%x"
+ "desMatch.homographyBoundaryMin_y = 0x%x"
+ "desMatch.homographyMatFrac[%d] = 0x%x"
+ "desMatch.homographyMatInt[%d] = 0x%x"
+ "desMatch.inputFormat = %d"
+ "desMatch.inputHeight = %d"
+ "desMatch.inputWidth = %d"
+ "desMatch.matchAlltoAll = 0x%x"
+ "desMatch.maxElements = 0x%x"
+ "desMatch.maxNumSets = 0x%x"
+ "desMatch.oriDistThresh = 0x%x"
+ "desMatch.prevMatchBuffBaseAddrHigh = 0x%x"
+ "desMatch.prevMatchBuffBaseAddrLow = 0x%x"
+ "desMatch.setPointerBuffBaseAddrHigh = 0x%x"
+ "desMatch.setPointerBuffBaseAddrLow = 0x%x"
+ "desMatch.setPointerMaxNum = 0x%x"
+ "desMatch.sigmaDistThresh = 0x%x"
+ "desMatch.sqDistThresh = 0x%x"
+ "desMatch.tidCounterInitValue = 0x%x"
+ "desMatch.usingDgdmJoint = %d"
+ "desMatch.zeroExtentionSize = 0x%x"
+ "descIdx(%d) should be less than %d"
+ "descr->hMultiPassFSM != 0"
+ "descr->msgQueue->Size() == 0"
+ "descr.indexList != 0"
+ "descr.list != 0"
+ "descr.lock != (FFWMUTEX)0"
+ "descrCommon"
+ "descrCommon->dpcStatBuffer"
+ "descriptorByteOffset = %d"
+ "descriptorCount = %d"
+ "descriptorVersion = %d"
+ "desgen.activeRegionStart[%d][%d].X = 0x%x"
+ "desgen.activeRegionStart[%d][%d].Y = 0x%x"
+ "desgen.antiAliasFilterCoefficients[%d][%d] = 0x%x"
+ "desgen.antiAliasFilterEn = 0x%x"
+ "desgen.blockSizeRemainderX[%d][%d].Value = 0x%x"
+ "desgen.blockSize[%d][%d].X = 0x%x"
+ "desgen.blockSize[%d][%d].Y = 0x%x"
+ "desgen.blurFilterCoefficients[%d][%d] = 0x%x"
+ "desgen.blurFilterEn = 0x%x"
+ "desgen.blurOutputEn = 0x%x"
+ "desgen.brightnessThreshold[%d] = 0x%x"
+ "desgen.byPass = %d"
+ "desgen.bypassGlobLUT = %d"
+ "desgen.currDescBuffBaseAddrHigh = 0x%x"
+ "desgen.currDescBuffBaseAddrLow = 0x%x"
+ "desgen.debugForceKP = 0x%x"
+ "desgen.debugForceValidKP = 0x%x"
+ "desgen.descriptorExtention = 0x%x"
+ "desgen.dst0PatchCoord.patchConfig.Enable = %d"
+ "desgen.dst0PatchCoord.patchConfig.Height = %d"
+ "desgen.dst0PatchCoord.patchConfig.Width = %d"
+ "desgen.dst0PatchCoord.patchCropEndXYMemValue[%d] = 0x%x"
+ "desgen.dst0PatchCoord.patchCropStartXYMemValue[%d] = 0x%x"
+ "desgen.dst0PatchCoord.patchMemValue[%d] = 0x%x"
+ "desgen.dst0PatchCoord.patchNumConfig = %d"
+ "desgen.dst1PatchCoord.patchConfig.Enable = %d"
+ "desgen.dst1PatchCoord.patchConfig.Height = %d"
+ "desgen.dst1PatchCoord.patchConfig.Width = %d"
+ "desgen.dst1PatchCoord.patchCropEndXYMemValue[%d] = 0x%x"
+ "desgen.dst1PatchCoord.patchCropStartXYMemValue[%d] = 0x%x"
+ "desgen.dst1PatchCoord.patchMemValue[%d] = 0x%x"
+ "desgen.dst1PatchCoord.patchNumConfig = %d"
+ "desgen.dst2PatchCoord.patchConfig.Enable = %d"
+ "desgen.dst2PatchCoord.patchConfig.Height = %d"
+ "desgen.dst2PatchCoord.patchConfig.Width = %d"
+ "desgen.dst2PatchCoord.patchCropEndXYMemValue[%d] = 0x%x"
+ "desgen.dst2PatchCoord.patchCropStartXYMemValue[%d] = 0x%x"
+ "desgen.dst2PatchCoord.patchMemValue[%d] = 0x%x"
+ "desgen.dst2PatchCoord.patchNumConfig = %d"
+ "desgen.dst3PatchCoord.patchConfig.Enable = %d"
+ "desgen.dst3PatchCoord.patchConfig.Height = %d"
+ "desgen.dst3PatchCoord.patchConfig.Width = %d"
+ "desgen.dst3PatchCoord.patchCropEndXYMemValue[%d] = 0x%x"
+ "desgen.dst3PatchCoord.patchCropStartXYMemValue[%d] = 0x%x"
+ "desgen.dst3PatchCoord.patchMemValue[%d] = 0x%x"
+ "desgen.dst3PatchCoord.patchNumConfig = %d"
+ "desgen.dst4PatchCoord.patchConfig.Enable = %d"
+ "desgen.dst4PatchCoord.patchConfig.Height = %d"
+ "desgen.dst4PatchCoord.patchConfig.Width = %d"
+ "desgen.dst4PatchCoord.patchCropEndXYMemValue[%d] = 0x%x"
+ "desgen.dst4PatchCoord.patchCropStartXYMemValue[%d] = 0x%x"
+ "desgen.dst4PatchCoord.patchMemValue[%d] = 0x%x"
+ "desgen.dst4PatchCoord.patchNumConfig = %d"
+ "desgen.flow0.mode = %d"
+ "desgen.flow0.nonMaxSuppress = %d"
+ "desgen.flow1.bitWidth = %d"
+ "desgen.flow1.blurKernel2 = %d"
+ "desgen.flow1.crossNMS = %d"
+ "desgen.flow1.nextGPOutputEn = %d"
+ "desgen.flow2.antiAliasFilterCoefficients[%d][%d] = 0x%x"
+ "desgen.flow2.antiAliasFilterEn = 0x%x"
+ "desgen.flow2.currDescBuffBaseAddrHigh = 0x%x"
+ "desgen.flow2.currDescBuffBaseAddrLow = 0x%x"
+ "desgen.flow2.debugForceKP = 0x%x"
+ "desgen.flow2.debugForceValidKP = 0x%x"
+ "desgen.flow2.descSubScaleMode = %d"
+ "desgen.flow2.descriptorExtention = 0x%x"
+ "desgen.flow2.dmaDescriptorSel = %d"
+ "desgen.flow2.hamvSize = 0x%x"
+ "desgen.flow2.hwMatchConfigEnable = 0x%x"
+ "desgen.flow2.keyScaleMax[%d] = 0x%x"
+ "desgen.flow2.kpCSchedulingMode = %d"
+ "desgen.flow2.kpFifoAlmostFullThreshold = %d"
+ "desgen.flow2.kpHighThresh[%d] = 0x%x"
+ "desgen.flow2.kpLimiterNumLines[%d] = 0x%x"
+ "desgen.flow2.kpLimiterNum[%d] = 0x%x"
+ "desgen.flow2.kpNumHigh[%d] = 0x%x"
+ "desgen.flow2.kpNumLow[%d] = 0x%x"
+ "desgen.flow2.kpSchedulingMode = %d"
+ "desgen.flow2.kpSubPixelUpdateMode = %d"
+ "desgen.flow2.kpThresh[%d] = 0x%x"
+ "desgen.flow2.kpcLimiterNumLines[%d] = 0x%x"
+ "desgen.flow2.kpcLimiterNum[%d] = 0x%x"
+ "desgen.flow2.kpcOutputEn = %d"
+ "desgen.flow2.kpcOutputScaleMax[%d] = 0x%x"
+ "desgen.flow2.maxNumSets = 0x%x"
+ "desgen.flow2.maxSubPixelUpdateDist = %d"
+ "desgen.flow2.orientationOffset = %d"
+ "desgen.flow2.progressIntrThreshold = 0x%x"
+ "desgen.flow2.s3BackPressureThreshold = 0x%x"
+ "desgen.flow2.s4BackPressureThreshold = 0x%x"
+ "desgen.flow2.setPointerBuffBaseAddrHigh = 0x%x"
+ "desgen.flow2.setPointerBuffBaseAddrLow = 0x%x"
+ "desgen.flow2.setPointerMaxNum = 0x%x"
+ "desgen.flow2.sigmaCalcBypass = 0x%x"
+ "desgen.globLUTMemConfig = 0x%x"
+ "desgen.hamvSize = 0x%x"
+ "desgen.hwMatchConfigEnable = 0x%x"
+ "desgen.keyFlow = %d"
+ "desgen.keyFrameMax = 0x%x"
+ "desgen.keyLineMax[%d] = 0x%x"
+ "desgen.keyOutShift = 0x%x"
+ "desgen.keyScaleMax[%d] = 0x%x"
+ "desgen.kpEn = 0x%x"
+ "desgen.kpHighThresh[%d] = 0x%x"
+ "desgen.kpLimiterNumLines[%d] = 0x%x"
+ "desgen.kpLimiterNum[%d] = 0x%x"
+ "desgen.kpNumHigh[%d] = 0x%x"
+ "desgen.kpNumLow[%d] = 0x%x"
+ "desgen.kpOffset[%d].X = 0x%x"
+ "desgen.kpOffset[%d].Y = 0x%x"
+ "desgen.kpOutputEn = 0x%x"
+ "desgen.kpThresh[%d] = 0x%x"
+ "desgen.kpcLimiterNumLines[%d] = 0x%x"
+ "desgen.kpcLimiterNum[%d] = 0x%x"
+ "desgen.kpcOutputScaleMax[%d] = 0x%x"
+ "desgen.maxNumSets = 0x%x"
+ "desgen.norm[%d] = 0x%x"
+ "desgen.numOfStripes = %d"
+ "desgen.paredBlockSize[%d].X = 0x%x"
+ "desgen.paredBlockSize[%d].Y = 0x%x"
+ "desgen.paredGridEn = 0x%x"
+ "desgen.paredGridNumOut[%d].Value = 0x%x"
+ "desgen.paredGridStart[%d][%d].X = 0x%x"
+ "desgen.paredGridStart[%d][%d].Y = 0x%x"
+ "desgen.paredNumBlocks[%d].X = 0x%x"
+ "desgen.paredNumBlocks[%d].Y = 0x%x"
+ "desgen.pointCriteria[%d].detTestEn = 0x%x"
+ "desgen.pointCriteria[%d].detTestThresh = 0x%x"
+ "desgen.pointFoundEnable = %d"
+ "desgen.progressIntrThreshold = 0x%x"
+ "desgen.res.bypass = %d"
+ "desgen.res.config.rsModeHorz = %d"
+ "desgen.res.config.rsModeVert = %d"
+ "desgen.res.outsize.height = %d"
+ "desgen.res.outsize.width = %d"
+ "desgen.res.resizeInitX = %d"
+ "desgen.res.resizeInitY = %d"
+ "desgen.res.resizeNormRSX = 0x%x"
+ "desgen.res.resizeNormRSY = 0x%x"
+ "desgen.res.resizeStepX = 0x%x"
+ "desgen.res.resizeStepY = 0x%x"
+ "desgen.resOutput.En = %d"
+ "desgen.respOutputEn = 0x%x"
+ "desgen.respShift[%d] = 0x%x"
+ "desgen.respThresh[%d][%d] = 0x%x"
+ "desgen.s3BackPressureThreshold = 0x%x"
+ "desgen.s4BackPressureThreshold = 0x%x"
+ "desgen.setPointerBuffBaseAddrHigh = 0x%x"
+ "desgen.setPointerBuffBaseAddrLow = 0x%x"
+ "desgen.setPointerMaxNum = 0x%x"
+ "desgen.sigmaCalcBypass = 0x%x"
+ "desgen.srcPatchCoord.patchConfig.Enable = 0x%x"
+ "desgen.srcPatchCoord.patchConfig.Height = %d"
+ "desgen.srcPatchCoord.patchConfig.Width = %d"
+ "desgen.srcPatchCoord.patchMemValue[%d] = 0x%x"
+ "desgen.srcPatchCoord.patchNumConfig = %d"
+ "desgen.subSampX = %d"
+ "desgen.subSampY = %d"
+ "dest %u exceeds max non exclave pipes"
+ "dest <= ISP_RESOURCE_VC_PIPELINE_9"
+ "dest VC pipeline ID shoule be either 10 or 11 for secure streaming"
+ "determinant_b"
+ "dev < CS40L61_DEVICE_COUNT"
+ "device < CIC_DEVICE_TOT && size"
+ "deviceConfig != nullptr"
+ "deviceID"
+ "deviceID[0] == (uint16_t)CS40L61_DEVICE_ID0"
+ "deviceID[0] == (uint16_t)CS40L62_DEVICE_ID0"
+ "deviceID[0] == CS40L61_DEVICE_ID0"
+ "deviceID[0] == CS40L62_DEVICE_ID0"
+ "deviceID[1] == (uint16_t)CS40L61_DEVICE_ID1"
+ "deviceID[1] == (uint16_t)CS40L62_DEVICE_ID1"
+ "deviceID[1] == CS40L61_DEVICE_ID1"
+ "deviceID_primary[0] == deviceID_secondary[0]"
+ "deviceID_primary[1] == deviceID_secondary[1]"
+ "dft"
+ "dieRequest != (SEMA)0"
+ "dieRequest != 0"
+ "dieSN"
+ "dieSema != (SEMA)0"
+ "diffAmbientLux %.2f diffPreCaptureLux %.2f percentage %.2f  %.2f\n"
+ "dig scope set to %u %u"
+ "digScopeXSta == IMX633_Readout_Position[configNumber].digScopeXStart"
+ "digScopeXSta == IMX703_Readout_Position[configNumber].digScopeXStart"
+ "digScopeXSta == IMX713_Readout_Position[configNumber].digScopeXStart"
+ "digScopeXSta == IMX714_Readout_Position[configNumber].digScopeXStart"
+ "digScopeXSta == IMX803_Readout_Position[configNumber].digScopeXStart"
+ "digScopeXSta == IMX903_Readout_Position[configNumber].digScopeXStart"
+ "digScopeXSta == IMX972_Readout_Position[configNumber].digScopeXStart"
+ "digScopeXSta == pReadoutWindow[configNumber].digScopeXStart"
+ "digScopeYSize % yConstraint == 0"
+ "digScopeYSta == IMX633_Readout_Position[configNumber].digScopeYStart"
+ "digScopeYSta == IMX703_Readout_Position[configNumber].digScopeYStart"
+ "digScopeYSta == IMX713_Readout_Position[configNumber].digScopeYStart"
+ "digScopeYSta == IMX714_Readout_Position[configNumber].digScopeYStart"
+ "digScopeYSta == IMX803_Readout_Position[configNumber].digScopeYStart"
+ "digScopeYSta == IMX903_Readout_Position[configNumber].digScopeYStart"
+ "digScopeYSta == IMX972_Readout_Position[configNumber].digScopeYStart"
+ "digScopeYSta == pReadoutWindow[configNumber].digScopeYStart"
+ "digitalZoomFactor is %f\n"
+ "dirId != CBundle::INVALID_ID"
+ "dis_em_r[0].r=0x%08X"
+ "dis_em_r[10].r=0x%08X"
+ "dis_em_r[11].r=0x%08X"
+ "dis_em_r[12].r=0x%08X"
+ "dis_em_r[13].r=0x%08X"
+ "dis_em_r[1].r=0x%08X"
+ "dis_em_r[2].r=0x%08X"
+ "dis_em_r[3].r=0x%08X"
+ "dis_em_r[4].r=0x%08X"
+ "dis_em_r[5].r=0x%08X"
+ "dis_em_r[6].r=0x%08X"
+ "dis_em_r[7].r=0x%08X"
+ "dis_em_r[8].r=0x%08X"
+ "dis_em_r[9].r=0x%08X"
+ "disable"
+ "disable ALGOCTRL_DST_PYROUTPROC "
+ "disgard setting window id %u disCardCount %u"
+ "dispRange >= 0.0f"
+ "displayRange=%f rangeSeg2=%f"
+ "displayWidth != 0"
+ "distCalData != 0"
+ "distCalData->H2V1.basePolynomialOrder[0/2] == 0"
+ "distCalData->H2V1.basePolynomialOrder[10/2] == 10"
+ "distCalData->H2V1.basePolynomialOrder[12/2] == 12"
+ "distCalData->H2V1.basePolynomialOrder[14/2] == 14"
+ "distCalData->H2V1.basePolynomialOrder[2/2] == 2"
+ "distCalData->H2V1.basePolynomialOrder[4/2] == 4"
+ "distCalData->H2V1.basePolynomialOrder[6/2] == 6"
+ "distCalData->H2V1.basePolynomialOrder[8/2] == 8"
+ "distCalData->H2V1.dynPolynomialOrder[0/2] == 0"
+ "distCalData->H2V1.dynPolynomialOrder[10/2] == 10"
+ "distCalData->H2V1.dynPolynomialOrder[12/2] == 12"
+ "distCalData->H2V1.dynPolynomialOrder[14/2] == 14"
+ "distCalData->H2V1.dynPolynomialOrder[2/2] == 2"
+ "distCalData->H2V1.dynPolynomialOrder[4/2] == 4"
+ "distCalData->H2V1.dynPolynomialOrder[6/2] == 6"
+ "distCalData->H2V1.dynPolynomialOrder[8/2] == 8"
+ "distStaticRgb->extrinsicMatrixValid == true"
+ "distStaticRgb->intrinsicDistortionCalData.version == 0xC306"
+ "distortion calibration check failed for ch=%ld @ pfl = %fmm."
+ "distortion curve check failed @ rd[%d] = %fmm, ru[%d]= %fmm."
+ "distortion curve check failed @ ru[%d-1] = %fmm, ru[%d] = %fmm."
+ "distributionArea = %hu, histConf = %f"
+ "div > 0"
+ "divisor >= FLT_EPSILON"
+ "dmaByteSize / 4 < +(1 << 26)"
+ "dmaChainErrHandle != 0"
+ "dmaConfigInfoMutex[ch] != (FFWMUTEX)0"
+ "dmaEnabled && (aftileOutSel != 0x0)"
+ "dmaEndX <= input.startX + input.sizeX"
+ "dmaEndY <= input.startY + input.sizeY"
+ "dmaFmt == DMA_PIXEL_FORMAT_RAW8"
+ "dmaId < ISPHWH17DMAId_MaxNbr"
+ "dmaId < nbrOfDmaManager"
+ "dmaId=%d, addr=0x%lx"
+ "dmaId=%d, stride=%d"
+ "dmaMask[pBufs[i]->info.bufferId] == 0"
+ "dmaMgrId != pClient->invalid_id"
+ "dmaStartX >= input.startX"
+ "dmaStartY >= input.startY"
+ "dmaStatEnable %d"
+ "domain %u"
+ "domainUserCounts_[powerDomain] > 0"
+ "done"
+ "doneSema != 0"
+ "dotProduct [cct, tint]=[%f, %f] "
+ "doubleRestoreNeeded == true"
+ "downSampleCount != 0"
+ "downSampleCount <= MOTION_SAMPLE_MAX"
+ "downScaleFactor > 0"
+ "downscaleX >= 2 && downscaleX <= 64"
+ "downscaleY >= 2 && downscaleY <= 64"
+ "dpcBufferSize=%zu MaxDPCDefectPixelCount=%d"
+ "dpcParserQuitSema != (SEMA)0"
+ "dpcParserStartSema != (SEMA)0"
+ "dpcParserTaskId != 0"
+ "dpcSettings: %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u"
+ "dpcStatBuf[i]"
+ "dpcdData"
+ "dpcmData"
+ "dpmNode.ispTimeStamp == dpmTimeStamp"
+ "drop sync bufs: frame=%d, ch=%d, orderId=%d"
+ "drv <= 3"
+ "drvStrength <= 3"
+ "dryrun %d"
+ "dst % 4 == 0"
+ "dst == DATA_DST_NONE"
+ "dst >= DATA_DST_START && dst <= DATA_DST_END"
+ "dst.pixelFormat == kFwDetectorBufferPixelFormatTypeFloat"
+ "dstHeight <= 8190 && dstHeight >= 64"
+ "dstSIFDMA <= DATA_DST_SIFDMA4"
+ "dstSizeInDW >= sizeInDW"
+ "dstWidth <= 4608 && dstWidth >= 128"
+ "dstWidth <= 4608 && dstWidth >= 64"
+ "dump"
+ "dump %s done"
+ "dump SemanticMap"
+ "dump input %u"
+ "dump netout offset %u size %u"
+ "dump sAEMetaData"
+ "dump sAEMetaData done"
+ "dump sFEStatCSCConfig "
+ "dump sFEStatCSCConfig done"
+ "dump sFEStatColorHistConfig"
+ "dump sFEStatColorHistConfig done"
+ "dump sFlashMetaData"
+ "dump sFlashMetaData done"
+ "duty : %u %\n"
+ "dynListNumDefects <= CSystemConfigurator::GetDPCDefectPixelCount(ch)"
+ "dynRD: maxExpPrimary %d prevRD %d maxSInF %d"
+ "dynRD: maxFrame %u maxSifr %u blk %u vW %u"
+ "dynRDOff: maxExpSifr %u primary exposure %llu"
+ "dynamicForwardCoef[0]=%.12f"
+ "dynamicForwardCoef[0]=%.12f vs %.12f"
+ "dynamicForwardCoef[0]x1M=%.12f"
+ "dynamicForwardCoef[1]=%.12f"
+ "dynamicForwardCoef[1]=%.12f vs %.12f"
+ "dynamicForwardCoef[1]x1M=%.12f"
+ "dynamicForwardCoef[2]=%.12f"
+ "dynamicForwardCoef[2]=%.12f vs %.12f"
+ "dynamicForwardCoef[2]x1M=%.12f"
+ "dynamicForwardCoef[3]=%.12f"
+ "dynamicForwardCoef[3]=%.12f vs %.12f"
+ "dynamicForwardCoef[3]x1M=%.12f"
+ "dynamicForwardCoef[4]=%.12f"
+ "dynamicForwardCoef[4]=%.12f vs %.12f"
+ "dynamicForwardCoef[4]x1M=%.12f"
+ "dynamicForwardCoef[5]=%.12f"
+ "dynamicForwardCoef[5]=%.12f vs %.12f"
+ "dynamicForwardCoef[5]x1M=%.12f"
+ "dynamicForwardCoef[6]=%.12f"
+ "dynamicForwardCoef[6]=%.12f vs %.12f"
+ "dynamicForwardCoef[6]x1M=%.12f"
+ "dynamicForwardCoef[7]=%.12f"
+ "dynamicForwardCoef[7]=%.12f vs %.12f"
+ "dynamicForwardCoef[7]x1M=%.12f"
+ "dzWidth %f, dzHeight %f, digitalZoomFactor %f\n"
+ "dzWidth %f, dzHeight %f, zoomFactor %f\n"
+ "eStart=%#zx len=%#x"
+ "eVal=%#zx idx=%d tblId=%d addr=%#x"
+ "eitParams != nullptr"
+ "eitParams[configIndex].aeSplitPDOpMode <= 3"
+ "eitParams[nSensorConfig].isSifrMode == eitParams[sensorConfig].isSifrMode"
+ "eitParams[nSensorConfig].sifrBinSensitivityFactor >= 1"
+ "eitParams[sensorConfig].uBinInverseGainFactor > 0"
+ "eitParams[sensorConfig].uSensorClock == eitParams[nSensorConfig].uSensorClock"
+ "eitRatio = %f"
+ "eitRatio > 0.f"
+ "eitToApply %llu, eitToApplySifr %llu"
+ "eitTrack %f %f %f %f\n"
+ "eitUpdateParams.request != 0"
+ "em_ba[0].e=0x%08X"
+ "em_ba[0].o=0x%08X"
+ "em_ba[10].e=0x%08X"
+ "em_ba[10].o=0x%08X"
+ "em_ba[11].e=0x%08X"
+ "em_ba[11].o=0x%08X"
+ "em_ba[12].e=0x%08X"
+ "em_ba[12].o=0x%08X"
+ "em_ba[13].e=0x%08X"
+ "em_ba[13].o=0x%08X"
+ "em_ba[14].e=0x%08X"
+ "em_ba[14].o=0x%08X"
+ "em_ba[15].e=0x%08X"
+ "em_ba[15].o=0x%08X"
+ "em_ba[16].e=0x%08X"
+ "em_ba[16].o=0x%08X"
+ "em_ba[17].e=0x%08X"
+ "em_ba[17].o=0x%08X"
+ "em_ba[18].e=0x%08X"
+ "em_ba[18].o=0x%08X"
+ "em_ba[19].e=0x%08X"
+ "em_ba[19].o=0x%08X"
+ "em_ba[1].e=0x%08X"
+ "em_ba[1].o=0x%08X"
+ "em_ba[20].e=0x%08X"
+ "em_ba[20].o=0x%08X"
+ "em_ba[21].e=0x%08X"
+ "em_ba[21].o=0x%08X"
+ "em_ba[22].e=0x%08X"
+ "em_ba[22].o=0x%08X"
+ "em_ba[23].e=0x%08X"
+ "em_ba[23].o=0x%08X"
+ "em_ba[24].e=0x%08X"
+ "em_ba[24].o=0x%08X"
+ "em_ba[25].e=0x%08X"
+ "em_ba[25].o=0x%08X"
+ "em_ba[26].e=0x%08X"
+ "em_ba[26].o=0x%08X"
+ "em_ba[27].e=0x%08X"
+ "em_ba[27].o=0x%08X"
+ "em_ba[28].e=0x%08X"
+ "em_ba[28].o=0x%08X"
+ "em_ba[29].e=0x%08X"
+ "em_ba[29].o=0x%08X"
+ "em_ba[2].e=0x%08X"
+ "em_ba[2].o=0x%08X"
+ "em_ba[30].e=0x%08X"
+ "em_ba[30].o=0x%08X"
+ "em_ba[31].e=0x%08X"
+ "em_ba[31].o=0x%08X"
+ "em_ba[32].e=0x%08X"
+ "em_ba[32].o=0x%08X"
+ "em_ba[33].e=0x%08X"
+ "em_ba[33].o=0x%08X"
+ "em_ba[34].e=0x%08X"
+ "em_ba[34].o=0x%08X"
+ "em_ba[35].e=0x%08X"
+ "em_ba[35].o=0x%08X"
+ "em_ba[36].e=0x%08X"
+ "em_ba[36].o=0x%08X"
+ "em_ba[37].e=0x%08X"
+ "em_ba[37].o=0x%08X"
+ "em_ba[38].e=0x%08X"
+ "em_ba[38].o=0x%08X"
+ "em_ba[39].e=0x%08X"
+ "em_ba[39].o=0x%08X"
+ "em_ba[3].e=0x%08X"
+ "em_ba[3].o=0x%08X"
+ "em_ba[40].e=0x%08X"
+ "em_ba[40].o=0x%08X"
+ "em_ba[41].e=0x%08X"
+ "em_ba[41].o=0x%08X"
+ "em_ba[42].e=0x%08X"
+ "em_ba[42].o=0x%08X"
+ "em_ba[43].e=0x%08X"
+ "em_ba[43].o=0x%08X"
+ "em_ba[44].e=0x%08X"
+ "em_ba[44].o=0x%08X"
+ "em_ba[45].e=0x%08X"
+ "em_ba[45].o=0x%08X"
+ "em_ba[46].e=0x%08X"
+ "em_ba[46].o=0x%08X"
+ "em_ba[47].e=0x%08X"
+ "em_ba[47].o=0x%08X"
+ "em_ba[48].e=0x%08X"
+ "em_ba[48].o=0x%08X"
+ "em_ba[49].e=0x%08X"
+ "em_ba[49].o=0x%08X"
+ "em_ba[4].e=0x%08X"
+ "em_ba[4].o=0x%08X"
+ "em_ba[50].e=0x%08X"
+ "em_ba[50].o=0x%08X"
+ "em_ba[51].e=0x%08X"
+ "em_ba[51].o=0x%08X"
+ "em_ba[52].e=0x%08X"
+ "em_ba[52].o=0x%08X"
+ "em_ba[53].e=0x%08X"
+ "em_ba[53].o=0x%08X"
+ "em_ba[54].e=0x%08X"
+ "em_ba[54].o=0x%08X"
+ "em_ba[55].e=0x%08X"
+ "em_ba[55].o=0x%08X"
+ "em_ba[5].e=0x%08X"
+ "em_ba[5].o=0x%08X"
+ "em_ba[6].e=0x%08X"
+ "em_ba[6].o=0x%08X"
+ "em_ba[7].e=0x%08X"
+ "em_ba[7].o=0x%08X"
+ "em_ba[8].e=0x%08X"
+ "em_ba[8].o=0x%08X"
+ "em_ba[9].e=0x%08X"
+ "em_ba[9].o=0x%08X"
+ "em_roi_r[0].r=0x%08X"
+ "em_roi_r[100].r=0x%08X"
+ "em_roi_r[101].r=0x%08X"
+ "em_roi_r[102].r=0x%08X"
+ "em_roi_r[103].r=0x%08X"
+ "em_roi_r[104].r=0x%08X"
+ "em_roi_r[105].r=0x%08X"
+ "em_roi_r[106].r=0x%08X"
+ "em_roi_r[107].r=0x%08X"
+ "em_roi_r[108].r=0x%08X"
+ "em_roi_r[109].r=0x%08X"
+ "em_roi_r[10].r=0x%08X"
+ "em_roi_r[110].r=0x%08X"
+ "em_roi_r[111].r=0x%08X"
+ "em_roi_r[112].r=0x%08X"
+ "em_roi_r[113].r=0x%08X"
+ "em_roi_r[114].r=0x%08X"
+ "em_roi_r[115].r=0x%08X"
+ "em_roi_r[116].r=0x%08X"
+ "em_roi_r[117].r=0x%08X"
+ "em_roi_r[118].r=0x%08X"
+ "em_roi_r[119].r=0x%08X"
+ "em_roi_r[11].r=0x%08X"
+ "em_roi_r[120].r=0x%08X"
+ "em_roi_r[121].r=0x%08X"
+ "em_roi_r[122].r=0x%08X"
+ "em_roi_r[123].r=0x%08X"
+ "em_roi_r[124].r=0x%08X"
+ "em_roi_r[125].r=0x%08X"
+ "em_roi_r[126].r=0x%08X"
+ "em_roi_r[127].r=0x%08X"
+ "em_roi_r[128].r=0x%08X"
+ "em_roi_r[129].r=0x%08X"
+ "em_roi_r[12].r=0x%08X"
+ "em_roi_r[130].r=0x%08X"
+ "em_roi_r[131].r=0x%08X"
+ "em_roi_r[132].r=0x%08X"
+ "em_roi_r[133].r=0x%08X"
+ "em_roi_r[134].r=0x%08X"
+ "em_roi_r[135].r=0x%08X"
+ "em_roi_r[136].r=0x%08X"
+ "em_roi_r[137].r=0x%08X"
+ "em_roi_r[138].r=0x%08X"
+ "em_roi_r[139].r=0x%08X"
+ "em_roi_r[13].r=0x%08X"
+ "em_roi_r[14].r=0x%08X"
+ "em_roi_r[15].r=0x%08X"
+ "em_roi_r[16].r=0x%08X"
+ "em_roi_r[17].r=0x%08X"
+ "em_roi_r[18].r=0x%08X"
+ "em_roi_r[19].r=0x%08X"
+ "em_roi_r[1].r=0x%08X"
+ "em_roi_r[20].r=0x%08X"
+ "em_roi_r[21].r=0x%08X"
+ "em_roi_r[22].r=0x%08X"
+ "em_roi_r[23].r=0x%08X"
+ "em_roi_r[24].r=0x%08X"
+ "em_roi_r[25].r=0x%08X"
+ "em_roi_r[26].r=0x%08X"
+ "em_roi_r[27].r=0x%08X"
+ "em_roi_r[28].r=0x%08X"
+ "em_roi_r[29].r=0x%08X"
+ "em_roi_r[2].r=0x%08X"
+ "em_roi_r[30].r=0x%08X"
+ "em_roi_r[31].r=0x%08X"
+ "em_roi_r[32].r=0x%08X"
+ "em_roi_r[33].r=0x%08X"
+ "em_roi_r[34].r=0x%08X"
+ "em_roi_r[35].r=0x%08X"
+ "em_roi_r[36].r=0x%08X"
+ "em_roi_r[37].r=0x%08X"
+ "em_roi_r[38].r=0x%08X"
+ "em_roi_r[39].r=0x%08X"
+ "em_roi_r[3].r=0x%08X"
+ "em_roi_r[40].r=0x%08X"
+ "em_roi_r[41].r=0x%08X"
+ "em_roi_r[42].r=0x%08X"
+ "em_roi_r[43].r=0x%08X"
+ "em_roi_r[44].r=0x%08X"
+ "em_roi_r[45].r=0x%08X"
+ "em_roi_r[46].r=0x%08X"
+ "em_roi_r[47].r=0x%08X"
+ "em_roi_r[48].r=0x%08X"
+ "em_roi_r[49].r=0x%08X"
+ "em_roi_r[4].r=0x%08X"
+ "em_roi_r[50].r=0x%08X"
+ "em_roi_r[51].r=0x%08X"
+ "em_roi_r[52].r=0x%08X"
+ "em_roi_r[53].r=0x%08X"
+ "em_roi_r[54].r=0x%08X"
+ "em_roi_r[55].r=0x%08X"
+ "em_roi_r[56].r=0x%08X"
+ "em_roi_r[57].r=0x%08X"
+ "em_roi_r[58].r=0x%08X"
+ "em_roi_r[59].r=0x%08X"
+ "em_roi_r[5].r=0x%08X"
+ "em_roi_r[60].r=0x%08X"
+ "em_roi_r[61].r=0x%08X"
+ "em_roi_r[62].r=0x%08X"
+ "em_roi_r[63].r=0x%08X"
+ "em_roi_r[64].r=0x%08X"
+ "em_roi_r[65].r=0x%08X"
+ "em_roi_r[66].r=0x%08X"
+ "em_roi_r[67].r=0x%08X"
+ "em_roi_r[68].r=0x%08X"
+ "em_roi_r[69].r=0x%08X"
+ "em_roi_r[6].r=0x%08X"
+ "em_roi_r[70].r=0x%08X"
+ "em_roi_r[71].r=0x%08X"
+ "em_roi_r[72].r=0x%08X"
+ "em_roi_r[73].r=0x%08X"
+ "em_roi_r[74].r=0x%08X"
+ "em_roi_r[75].r=0x%08X"
+ "em_roi_r[76].r=0x%08X"
+ "em_roi_r[77].r=0x%08X"
+ "em_roi_r[78].r=0x%08X"
+ "em_roi_r[79].r=0x%08X"
+ "em_roi_r[7].r=0x%08X"
+ "em_roi_r[80].r=0x%08X"
+ "em_roi_r[81].r=0x%08X"
+ "em_roi_r[82].r=0x%08X"
+ "em_roi_r[83].r=0x%08X"
+ "em_roi_r[84].r=0x%08X"
+ "em_roi_r[85].r=0x%08X"
+ "em_roi_r[86].r=0x%08X"
+ "em_roi_r[87].r=0x%08X"
+ "em_roi_r[88].r=0x%08X"
+ "em_roi_r[89].r=0x%08X"
+ "em_roi_r[8].r=0x%08X"
+ "em_roi_r[90].r=0x%08X"
+ "em_roi_r[91].r=0x%08X"
+ "em_roi_r[92].r=0x%08X"
+ "em_roi_r[93].r=0x%08X"
+ "em_roi_r[94].r=0x%08X"
+ "em_roi_r[95].r=0x%08X"
+ "em_roi_r[96].r=0x%08X"
+ "em_roi_r[97].r=0x%08X"
+ "em_roi_r[98].r=0x%08X"
+ "em_roi_r[99].r=0x%08X"
+ "em_roi_r[9].r=0x%08X"
+ "embBuf && size && listRegData"
+ "embBuf && size && stride"
+ "emitter < CISP_PERIDOT_NUM_OF_EMITTERS"
+ "en %d idx %d"
+ "enable"
+ "enable %d secEnable %d lumiEnabled %d"
+ "enable %d, bCurrAFEProcEnable %d"
+ "enable %d, bCurrStatsEnable %d"
+ "enableCCMDesatForSkinColors=%hhu maxCCMDesatForSkinPercent=%6.4f"
+ "enableFDTracker=%hhu, prevColorHistMixWeight=%f"
+ "enableRFPNBlkAvgRead"
+ "enableTemporalStable = %X"
+ "enableThreshold should be larger than disableThreshold"
+ "enableTimingProfile = %d\n"
+ "encodedData"
+ "endOffsetX"
+ "endOffsetY"
+ "endPointCb[endPoint].shareMem.nbrOfRemapItem < sCDMediaBusManagerShareMemInfo::maxSharedMemInfo"
+ "endPointCb[i].curState < ECDMEDIABUSMANGER_ENDPOINT_CB_STATE_MAX"
+ "endPointCb[pCmd->endPointId].curState != ECDMEDIABUSMANGER_ENDPOINT_CB_STATE_IDLE"
+ "endPointCb[pCmd->endPointId].curState < ECDMEDIABUSMANGER_ENDPOINT_CB_STATE_MAX"
+ "endPointCb[pCmd->endPointId].shareMem.nbrOfItem"
+ "endPointCb[pCmd->endPointId].shareMem.nbrOfItem < sCDMediaBusManagerShareMemInfo::maxSharedMemInfo"
+ "endPointCb[pCmd->endPointId].shareMem.nbrOfItem == 0"
+ "endPointCb[pCmd->endPointId].shareMem.nbrOfRemapItem"
+ "endPointCb[pCmd->endPointId].shareMem.nbrOfRemapItem == 0"
+ "endPointCb[pCmd->endPointId].shareMem.remap[i].refCount==0"
+ "endX % 2 == 0"
+ "endX <= (pDescr->paramStat[pipe].inputWidth >> pDescr->paramStat[pipe].binH)"
+ "endX <= (pStatParam->inputWidth >> pStatParam->binH)"
+ "endX <= (statInputWidth >> binH)"
+ "endX <= (statInputWidth >> h->binH)"
+ "endX <= input.sizeX - borderX"
+ "endXY.f.EndX > startXY.f.StartX"
+ "endXY.f.EndY > startXY.f.StartY"
+ "endY <= input.sizeY - borderY"
+ "end_x=%i, start_x=%i"
+ "endpoint attach"
+ "enque hdrR 0x%x, exp %llu, v %u, gA 0x%x, gDS 0x%x, gD 0x%x"
+ "enque hdrR 0x%x, exp %llu, v %u, gA 0x%x, gDS 0x%x, gD 0x%x\n"
+ "enque invBG 0x%x, ev0R %u, biasTag %u, maetag %u, AECounter %u, request 0x%x"
+ "entries != 0"
+ "entries > 0"
+ "entry"
+ "entry != 0"
+ "entry != NULL"
+ "entry <= 131071"
+ "entry >= -131072"
+ "entry wasn't activated, refIdx=%hu"
+ "entry->callback || entry->callback_with_source"
+ "entry->len == len"
+ "entry->pData"
+ "entry->stack != 0"
+ "entry->used == true"
+ "entry->va"
+ "entryList != 0"
+ "ep enable all"
+ "err == FFW_SUCCESS"
+ "errCode == CISP_CMDBACKCHANNEL_GPRPC_EXE_STATUS_OK"
+ "errSema != 0"
+ "errType: %d"
+ "erro_tlr_multiplier=%f, band_scaling=%f, laccGNA_maxIterations=%d, costTolerance=%f, minMatchRequired=%d, ENABLE_MULTI_SEEDING=%d, GNA_FALLBACK_TH=%f\n"
+ "estimate.flags.valid"
+ "euclDist=%.2f, distWeight=%.2f"
+ "event != NULL"
+ "event < EVT_AFEPROC_EVENT_MAX"
+ "event < EVT_VISRES_MAX"
+ "eventDesc != nullptr"
+ "eventDesc->baseDescFmt != nullptr"
+ "evtBuffer != 0"
+ "evtBuffer->mutex != (FFWMUTEX)0"
+ "evtFDTOLog != 0"
+ "evtLog"
+ "evt_id < m_maxEvents"
+ "exclave::Unknown command - ch %zu id %zu\n"
+ "exe_interval(%)"
+ "execGPCommand"
+ "execution(us)"
+ "exit!"
+ "exp != 0"
+ "expBias=%.3f"
+ "expRatio=%.3f"
+ "expandL % sensor.pDescr->focusGrid.spacingX == 0"
+ "expandR % sensor.pDescr->focusGrid.spacingX == 0"
+ "expected data frame=%d pin=%ld may be dropped!!"
+ "expectedFlashWeightedAve %f\n"
+ "exposure %d readOut %d currSetting %d\n"
+ "exposure %llu < fineInt %d"
+ "exposure & flash %f\n"
+ "exposure & flash %f %f\n"
+ "exposure >= fineInt"
+ "exposureSifr %llu < fineInt %d"
+ "exposureSifr > 0"
+ "exposureSifr >= fineInt"
+ "extra"
+ "extra != nullptr"
+ "extra_heap_virt != NULL"
+ "extractKeyLoc_2"
+ "extractKeyLoc_2 NumKeyExtracted %d\n"
+ "extremeLowLightMode unsupported value"
+ "extremeLowLightMode=%d but splitPDScale isn't supported"
+ "extslaf_in_depth_%u_%u.raw"
+ "extslaf_in_rgb_%u_%u.raw"
+ "fToRect == NULL"
+ "fab 0x%x"
+ "fabsf(currentEIT) > FLT_EPSILON"
+ "fabsf(currentFrame->eit) > FLT_EPSILON"
+ "fabsf(dampedBias) > FLT_EPSILON"
+ "fabsf(defaultHistWeight) > FLT_EPSILON"
+ "fabsf(gainDown) > FLT_EPSILON"
+ "fabsf(highlightModel[nvec]) > FLT_EPSILON"
+ "fabsf(input->darkEit) > FLT_EPSILON"
+ "fabsf(input->darkExposureRatio) > FLT_EPSILON"
+ "fabsf(input->exposureRatio) > FLT_EPSILON"
+ "fabsf(input->faceExposureRatio) > FLT_EPSILON"
+ "fabsf(ltmBuffer->meta.curveExposureRatio) > FLT_EPSILON"
+ "fabsf(ltmGains->yScale) > FLT_EPSILON"
+ "fabsf(ltmGains.ltmOutScale * ltmGains.gocOutScale) > FLT_EPSILON"
+ "fabsf(lumaBg + lumaDark) > FLT_EPSILON"
+ "fabsf(mappedZ) > FLT_EPSILON"
+ "fabsf(nMinusRange) > FLT_EPSILON"
+ "fabsf(newInScale) > FLT_EPSILON"
+ "fabsf(nthumb) > FLT_EPSILON"
+ "fabsf(nthumbEV0 + nthumb) > FLT_EPSILON"
+ "fabsf(pComputeInput->exposureRatio) > FLT_EPSILON"
+ "fabsf(pDisplayParams->displayRange) > FLT_EPSILON"
+ "fabsf(pFrameParams->exposureRatioUp) > FLT_EPSILON"
+ "fabsf(pFrameParams->sceneLum + 10.5537f) > FLT_EPSILON"
+ "fabsf(pFrameParams->sceneLum + 12.1314f) > FLT_EPSILON"
+ "fabsf(pMetaData->hardIspDGain) > FLT_EPSILON"
+ "fabsf(pTuningParams->sceneModelSmoothing) > FLT_EPSILON"
+ "fabsf(rangeSeg2) > FLT_EPSILON"
+ "fabsf(sceneHistMax2[0]) > FLT_EPSILON"
+ "fabsf(softGain) > FLT_EPSILON"
+ "fabsf(this->displayParams.displayRange) > FLT_EPSILON"
+ "fabsf(this->frameParams.nGray) > FLT_EPSILON"
+ "fabsf(this->frameParams.shadowSuppress) > FLT_EPSILON"
+ "fabsf(this->tuningParams->darkSceneLux) > FLT_EPSILON"
+ "fabsf(this->tuningParams->maxDampingLux - this->tuningParams->minDampingLux) > FLT_EPSILON"
+ "fabsf(this->tuningParams->maxDampingLux) > FLT_EPSILON"
+ "fabsf(totalScaleDown) > FLT_EPSILON"
+ "fabsf(x + lumaDark + k * dluma) > FLT_EPSILON"
+ "face.boundingBox.isFaceDetected && 0 < adResults.numResults || !face.boundingBox.isFaceDetected && 0 == adResults.numResults"
+ "faceBBoxRegress"
+ "faceID=%d dpmNode=%.3f %.3f %.3f %.3f fdFaces=%d %d %d %d"
+ "faceId < CISP_FWDETECTOR_FD_MAX_RESULTS"
+ "faceId < pFd->numDetectedFaces"
+ "faceIndex != -1"
+ "faceMoveDis =%f, faceMotionLocalWeight=%f, faceMotionGlobalWeight=%f, faceAreaWeight=%f"
+ "facePreFlashLux %.2f, faceFlashOffLux %.2f\n"
+ "face[%u] yaw %d roll %d smile %d refined yaw %d refined roll %d refined pitch %d"
+ "factor <= 16"
+ "factor == 1 || factor == 2 || factor == 4 || factor == 8 || factor == 16"
+ "factory != nullptr"
+ "factory_flow_status_dump"
+ "failCnt == 0"
+ "failed to get file size %s!, read next"
+ "failed to load test vector!"
+ "failed to read file %s!"
+ "fakeSifErrorTimer != 0"
+ "false == pMetaData->cLUTEnable"
+ "false == users[index].isUsed"
+ "false ==pRes->chCtx[chId].prevIsEV0"
+ "fault_en"
+ "fault_en_abist"
+ "fault_en_mbist"
+ "fault_mstr_en_abist"
+ "fault_stp"
+ "fault_stp=0x%08X"
+ "fault_stp_abist=0x%08X"
+ "fc %d Received LUT from NCC %d :: %x %x %x %x"
+ "fc:%d pipe:%d bBusySrc:%d"
+ "fc:%llu type:%d"
+ "fcData"
+ "fcData->infWindCount <= FIELD_CURVE_WINDOW_COUNT_15"
+ "fcData->macroWindCount <= FIELD_CURVE_WINDOW_COUNT_15"
+ "fcLevelDataInp"
+ "fcLevelDataPtr"
+ "fd\n"
+ "fd-AWB: faces=%u raw=%hu %hu stats=%u %u statsBin=%hhu %hhu "
+ "fd-AWB: fdRect= %d %d %u %u, tile= %hu %hu %hu %hu "
+ "fdAE"
+ "fdAEMeta != nullptr"
+ "fdAWBMeta != nullptr"
+ "fdAWBMeta != nullptr && awbTileStats != nullptr"
+ "fdAWBMeta != nullptr && pMetaData != nullptr && awbStatsHdr != nullptr"
+ "fdAWBMeta != nullptr && pMetaData != nullptr && spatialCCMMap != nullptr"
+ "fdActiveCnt == 0"
+ "fdCropRect x y w h (%d %d %d %d) fdInputSel %d\n"
+ "fdMeta"
+ "fdMeta == nullptr"
+ "fdMeta acquire %p size %zu"
+ "fdMeta release %p"
+ "fdMeta->Size() >= (pAICamMeta->dbgDataOffset + pAICamDebug->totSize)"
+ "fdMeta->Size() >= (pAICamMeta->dbgDataOffset + sizeof(sCIspAnfdDebugData))"
+ "fdMeta->Size() >= (pAnstMeta->dbgDataOffset + pAICamDebug->totSize)"
+ "fdMeta->Size() >= (sizeof(sCIspAnfdResults))"
+ "fdrDataV1->moduleDataOffset[mIdx] < m_calData[blockIdx].size"
+ "feThumbOutput"
+ "featurePatch.enable = %d"
+ "featurePatch.height = %d"
+ "featurePatch.numPatch = %d"
+ "featurePatch.offset = %d"
+ "featurePatch.width = %d"
+ "fepBuffer"
+ "fepId[fepOutType] < MAX_ISP_FEP_RESOURCES"
+ "fepIsrHandle != 0"
+ "fepIsrHandle2"
+ "fepMap[0].bValid"
+ "fepMap[fepOutType].bValid"
+ "fepOutType %d"
+ "fepOutType < FEP_OUT_TOT"
+ "fepProxyPool"
+ "fepResBitmap %#x"
+ "fepStatsDmaChainIdx >= 0"
+ "feproc_id < getMaxFEProc()"
+ "fesCrop->x >= 0"
+ "fesCrop->y >= 0"
+ "fesCropRect.y %d rawDMASrcCropRect.y %d yCropOffset %d\n"
+ "fesOutputWidth %d exceeds %d hardware limitation"
+ "fesWidthRDown[%d %d %d %d] adjustWidth=%f fesRatio=%f"
+ "fesWidthRUp[%d %d %d %d] adjustWidth=%f fesRatio=%f"
+ "fesZoomX == ZOOM_FACTOR_FIXED_POINT_IDENTITY && pyrZoomX == ZOOM_FACTOR_FIXED_POINT_IDENTITY"
+ "fesZoomY == ZOOM_FACTOR_FIXED_POINT_IDENTITY && pyrZoomY == ZOOM_FACTOR_FIXED_POINT_IDENTITY"
+ "ffwInThreadContext()"
+ "ffwQueueCount (queue) == 0"
+ "ffwrc == FFW_OK"
+ "fgNumPts = %d, framename %d"
+ "fifo"
+ "fifo->Size() != 0"
+ "fifo->Size() == 0"
+ "fifo->Size() == 1"
+ "fifo->Size() > 1"
+ "fifoId < maxFifoNbr"
+ "fifoNbr < maxFifoNbr"
+ "file name %s"
+ "fileDescs[0].size >= (pOpHdr->offset[0] + sizeof(sCIspCmdChGeneralProcessOperation) + pOpItem->sizeOfConfig)"
+ "fileDescs[1].size >= (pActHdr->offset[0] + sizeof(sCIspCmdChGeneralProcessAction) + pActItem->nbrOfBuffer * sizeof(sCIspCmdChGeneralProcessActionBufferList))"
+ "fileDescs[fileId].pData != nullptr"
+ "fileDescs[i].pData != nullptr"
+ "fileDescs[i].pRef != nullptr"
+ "fileDescs[i].size"
+ "fileId != CBundle::INVALID_ID"
+ "fileInfo"
+ "fileName"
+ "fileRead"
+ "fileWrite"
+ "filter == (class CObject *)0"
+ "find dup sifr frame ch %hhu fc %d sifr %d"
+ "findDetector"
+ "findUniqueRoi"
+ "fiq(us)"
+ "firstOutIdx < int(ii)"
+ "firstOutIdx >= 0"
+ "firstPix %u frameWidth %u frameHeight %u"
+ "firstPixelColor == FPC::Color::B"
+ "firstPixelColor == FPC::Color::R"
+ "flare.intensity <= Params::Flare::NINTENSITIES"
+ "flarehist1d"
+ "flash %f exposure %f flashGain %f gain %d isSlowSync %d flip %d mode %d\n"
+ "flash capture ch %d count %d type %d \n"
+ "floodHighTempCnt increased to %d\n"
+ "floodHighTempCntLimit set to %d\n"
+ "floodHighTempCntLimit set: %d\n"
+ "flow != nullptr"
+ "flow == nullptr"
+ "flow->GetPriority() == CPCEFLOW_PRIORITY_0_REGULAR"
+ "flow=%d, ch=%d queued too many frames (%d,%d), drop frame=%d (%d) %d"
+ "flow=%d, ch=%ld, cmdId=%ld, seq=%d"
+ "flow=%d,ch=%ld,frame=%d,qFullness=%ld,w=%d,h=%d,pass=%d,s=%d,mp=%d,ms=%d,msMbnr=%d,bWait=%d"
+ "flow=%d,ch=%ld,pplMode=%d,mpMode=%d,maxP=%d,outStrms=%d,enStat0=%d,enStat1=%d,outSel=%d,dstEn=%#x"
+ "flowState == CPCEFLOW_STATE_DATA_SET"
+ "flowState == CPCEFLOW_STATE_DONE_ALL || flowState == CPCEFLOW_STATE_DONE_INTERMITTENT"
+ "flowState == CPCEFLOW_STATE_DONE_INTERMITTENT || flowState == CPCEFLOW_STATE_DONE_ALL"
+ "flowState == CPCEFLOW_STATE_EXECUTING"
+ "flowState == CPCEFLOW_STATE_INITIALIZED"
+ "flowState == CPCEFLOW_STATE_READY_FOR_EXECUTE"
+ "flush cached AWB synctag %d"
+ "flush done"
+ "fmap_valid"
+ "fmt == CISP_INPUT_FORMAT_RAW8 || fmt == CISP_INPUT_FORMAT_RAW16"
+ "fn=%d ch=%d dpm.faces=%d dpm.maxId=%d faces=%d maxId=%d anodFm=%d, numObj=%d"
+ "fn=%d ch=%d fdCh=%zu m=%d mP=%d input=%.3f %.3f %.3f %.3f fdAWBRect=%d %d %d %d"
+ "fn=%d ch=%d otf=%d dpmNode=%.3f %.3f %.3f %.3f fdFaces=%d %d %d %d faceArea=%.3f %.3f"
+ "fn=%d ch=%d otf=%d dpmNode=[%.3f %.3f %.3f %.3f] fdFaces=[%d %d %d %d]"
+ "fn=%d ch=%d otf=%d rectSize=%d %d faceSize=%.0f roll=%d froll=%d"
+ "fn=%d gain=%d %d %d ccm=%d %d %d"
+ "fn=%d, faceSizeInPixels=%9.0f, faceSizeInPixelsThresh=%7.0f;"
+ "focusGrid.spacingX % PDAF::ISP::AFE_TOTAL_CROP_ALIGN_X == 0"
+ "focusGrid.startX % PDAF::ISP::AFE_TOTAL_CROP_ALIGN_X == 0"
+ "focusGrid.startY % PDAF::ISP::AFE_TOTAL_CROP_ALIGN_Y == 0"
+ "focusHint: focusPixelsEnable = %d  lock = %d  strictness = %d  secFocus = %d  intent = %d\n"
+ "focusNowH8: focusPixelsEnable = %d  lock = %d  strictness = %d  secFocus = %d  intent = %d  time = %d\n"
+ "folVal == 0"
+ "forCvd"
+ "forceViseg %d"
+ "foregroundMainFlashLux %.2f foregroundTarget %.2f\n"
+ "foregroundTargetedEit %f\n"
+ "format : %d"
+ "found"
+ "found 64bits addr entry pa %llx va %p len %zu"
+ "found == true"
+ "found diff at buf %u %zu, skip to next!"
+ "fovInRaw x %d y %d w %u h %u"
+ "fps"
+ "fps %d, SkipRatio %d, FE freq=%d:%d MHz, BE freq=%d:%d MHz"
+ "fps = %d, ISPDG = %f "
+ "fps > 0"
+ "fpsHist"
+ "fr %d AD %d LO %d OD %d"
+ "fr %d LANDSCAPE %d LO %d OD %d"
+ "fr %d facep (%.3f %.3f %.3f %.3f)"
+ "fr %d objects (%.3f %.3f %.3f %.3f)"
+ "fr %d saliency (%.3f %.3f %.3f %.3f)"
+ "fr %d valid %d ver %d [crc] ad %x"
+ "frDone %d faces"
+ "frNbr=%u, objTracked=%u, numObj=%u, numWin=%u"
+ "frame %d bInPreFlash %d bInMainFlash %d ltmFaceAdjustRatio %f\n"
+ "frame Id info: 0x%#06x"
+ "frame time updated to %f\n"
+ "frame=%d ch=%ld(%zu)retain %d repLTMBuf %d tag 0x%x %x HM %d LSM %d"
+ "frame=%d passId=%d mpMode=%d dataPin=%u"
+ "frame=%d, pin=%ld matched!"
+ "frame=%d,ch=%ld,flash=%d,%d,hrOn=%d,brM=%d,PB=%d,BC=%d,SIFR=%d,genHue=%d:%d,bNightMode=%d,bGenPyramid=%d"
+ "frame=%d,ch=%ld,mp=%d,ms=%d,still=%d,prevMS=%d,statMS=%d,syncTag=%d,chInSync=%d"
+ "frame=%d,ch=%ld,mp=%d,ms=%d,still=%d,prevMS=%d,statMS=%d,syncTag=%d,chInSync=%d,gdc=%d,skipDepth=%d"
+ "frameAESetting != nullptr"
+ "frameCount %u, ch %u(%zu) not release! receivedChCount %u channelsInSync %u"
+ "frameCount %u, ch %u(%zu) not release. receivedChCount %u channelsInSync %u"
+ "frameCount %u, ch %u(%zu) receivedChMask 0x%x "
+ "frameCount == _sFrameInfoList[index].frameCount"
+ "frameCount == pMetaData->frameCount"
+ "frameCount > 0"
+ "frameCounter = %d"
+ "frameDecimation = %d\n"
+ "frameDescCurr != 0"
+ "frameDescCurr->pSifrStatMetaBuf"
+ "frameDescCurr->pStatMetaBuf"
+ "frameDescCurr->pStatMetaBuf != 0"
+ "frameDescNext != 0"
+ "frameDurationUs <= MAX_EXPOSURE_WITHOUT_FW_PATCH"
+ "frameId %u, channel %zu"
+ "frameIdx <= modeCfg->regs.tbcnum"
+ "frameInQueue = %d\n"
+ "frameInfo"
+ "frameInfo != nullptr"
+ "frameInfo->GetFrameInfoCBuffer(frameCount, CImageFrameInfo::IMAGE_PER_FRAME_INFO_RAW_SIFR_BUFFER)"
+ "frameNum=%u iirFilterMultiplier=%f"
+ "framePeriod != 0"
+ "frameRate: %d\n"
+ "frameRateRatio set to %.3f"
+ "frameStatus 0x%0llx, Ctx %d, Completed %d"
+ "frameTime %f, vblank %d, count %d\n"
+ "frameTimer != 0"
+ "framename %s, GPwidth = %d, GPheight =%d"
+ "framename %s, numDesGenKPs = %d"
+ "framename %s, strideVis = %d, width = %d, height =%d"
+ "framesInSuperframe > 0"
+ "free sentHostMetaBuff %p HMetadata pFrame %p\n"
+ "free sentHueMapBuff %p sentHueMapBuff pFrame %p\n"
+ "freq=1/%dms, winSize=%dms\n"
+ "frmCmpnDma.pFrmCmpnDmaCmpn"
+ "frmCmpnDma.pFrmCmpnDmaCmpnOverrides"
+ "front stereo factory depends on pearl factory"
+ "front stereo partial-flow timeout semaphore is NULL!"
+ "fsm != 0"
+ "fsm %d status line %d\n"
+ "fsm %d status line %s\n"
+ "fstrobe"
+ "fullResConfig != nullptr"
+ "fullResPixelArrayWidth > 0 && configPixelArrayWidth > 0"
+ "fullResW  %d  fullResH %d  xCrop %d  yCrop %d\n"
+ "fusionType"
+ "fusionTypeStill"
+ "futureEIT > 0"
+ "futureExpRatio > 0"
+ "futureTotalGain > 0.0f"
+ "futureTotalIspDGain > 0.0f"
+ "fwDetectorBufferHalfToFloat"
+ "fwDetectorBufferInt8ToFloatCHWToHWC"
+ "fwDetectorBufferPixelAtFloat"
+ "fwDetectorBufferPixelAtInt8"
+ "fwDetectorBufferPixelAtUInt16"
+ "fwDetectorBufferPixelAtUInt8"
+ "fwDetectorBufferPixelFormatFromBmBuffer"
+ "fwDetectorBufferSubBuffer"
+ "fwDetectorBufferUInt8ToFloatCHWToHWC"
+ "fwDetectorDilateBox3x3"
+ "fwDetectorErodeBox3x3"
+ "fwDetectorInterp2d"
+ "fwDetectorMatrixGemmA1B1"
+ "fwDetectorMatrixNCols(A) == fwDetectorMatrixNRows(B)"
+ "fwDetectorMatrixNCols(B) == fwDetectorMatrixNCols(C)"
+ "fwDetectorMatrixNRows(A) == fwDetectorMatrixNRows(C)"
+ "fwDetectorVectorAdd"
+ "fwDetectorVectorDot"
+ "fwDetectorVectorDotBatch"
+ "g.pGroup"
+ "gAnalSifr %d, gDigiSifr %d,  oDGain %d, splitPDOn %d, videoOn %d"
+ "gStrLookupArrayLED"
+ "gain != 0"
+ "gain: %d"
+ "gainAnal != nullptr"
+ "gainDown=%.3f"
+ "gainHardDigi.v16=%d, nextAE.gainHardDigi=%d\n"
+ "gdcCfg->apsPFL = %f"
+ "gdcCfg->partialGdcScale <= 1"
+ "gdcCfg->partialGdcScale = %f"
+ "gdcCfg->partialGdcScale >= 0"
+ "gdcCfg->pixelSizeUm != 0"
+ "gdcCfg->radius > 0"
+ "gdcEn == true"
+ "gdcMapInfo->horzBin <= 1"
+ "gdcMapInfo->vertBin <= 1"
+ "gdcMinPFL <= gdcCfg->upperBoundPFL"
+ "gdcStrength >= 0.0f && gdcStrength <= 1.0f"
+ "gdcStrengthStill >= 0.0f && gdcStrengthStill <= 1.0f"
+ "gen Background mask: time = %f ms!\n"
+ "gen map : time = %f ms!\n"
+ "genBinBGMask"
+ "genCopyItem"
+ "genMode < FESTATS_THUMBNAIL_GEN_TOTAL"
+ "genMode < HITH_THUMBNAIL_GEN_TOTAL"
+ "genProcSession[%d].processType = %d\n"
+ "generateGocParam"
+ "generateSpatialLTC"
+ "get result ch=%zu %llu %llu"
+ "get result ch=%zu %llu %u"
+ "get tempMetaBuff %p"
+ "getBuffer"
+ "getCmpnWrapDMAOffset(id)"
+ "getCompressionDMAOffset(id) || getIcCompressionDMAOffset(id)"
+ "getCompressionDMAOffset(idIn) || getIcCompressionDMAOffset(idIn)"
+ "getDebugServiceStreamType"
+ "getInitAWBUpdate"
+ "getLumaMapByDepth"
+ "getOutput"
+ "getPyrdBox"
+ "getSlafMaskBuffer"
+ "ggdBufOut->Size() >= GetOutputSize(chId)"
+ "glass"
+ "globalOp[opId] != nullptr"
+ "globalWP: %hu, %hu, %hu"
+ "gmsBuffer != nullptr"
+ "gmsBufferForAlgo != nullptr"
+ "gmsType != CALIB_MNGR_CALIB_TYPE_TOT"
+ "goc2Gains[0] <= GOC_GAIN_MAX_H8"
+ "gocOutput"
+ "gpTimerArray != 0"
+ "gpio %d is shared with other rails, thus not off yet."
+ "gpio < CConnectivityTable::Instance()->GpioLUTSizeGet()"
+ "gpio < gpioCfg.sizeLUT"
+ "gpio <= ALDAST_CLK3"
+ "gpio(%d) %s %d\n"
+ "gpioCfg.mRCAMStrobeGpio != GPIO_NOT_SET"
+ "gpioCfg.refCnts"
+ "gpioDrv"
+ "gpioResetTaskSema != (SEMA)0"
+ "grayIndex = %.2f %.2f dist=%.2f weight=%.2f"
+ "greenImbLR_lut_full_uncached"
+ "greenImbLR_lut_ori_uncached"
+ "greenImbLR_lut_small_uncached"
+ "gridH <= GDC_MAX_GRID_HEIGHT"
+ "gridMode <= AISP_BESPROC_PIPE_BESPROCMESH_CONFIG_GRIDMODE_CPU"
+ "gridSizeBytes"
+ "gridSizeX"
+ "gridSizeY"
+ "gridW <= GDC_MAX_GRID_WIDTH"
+ "groupConfig[wrapperCh].numCamsInGroup <= MAX_CH_PER_SYNCGROUP"
+ "groupID != INVALID_SYNC_GROUP_ID"
+ "groupID %d mask %x chBitMask %x cmdId %x"
+ "groupID < MAX_GROUPS"
+ "groupSrc == groupDst"
+ "grp %u chMask %u Shared Pool type %u pool Id %u No allocation"
+ "grps %d"
+ "gvsCore cameraData center %f %f"
+ "gvsCore.derivedTransformCount <= CISP_VIS_INFO_MAX_SLICE_NBR"
+ "gw: [%.2f %.2f] -> [%.2f %.2f] idx= %.2f -> %.2f totalPxlCnt= %u"
+ "gw= %.2f %.2f -> %.2f %.2f rg2=%.2f bg2=%.2f dist=%.2f w=%.2f "
+ "gyro_init_model:"
+ "gyrohomography, setting up DesMatch"
+ "h"
+ "h != 0"
+ "h != nullptr"
+ "h->afDepthSrcExclusiveFrameRateCache != 0"
+ "h->caeRec[ch]"
+ "h->caeRec[pDesc->ch]->pSetting->request == 0"
+ "h->cawbDesc[ch]->pCAWB"
+ "h->ch != 0"
+ "h->chH2T != 0"
+ "h->chT2H != 0"
+ "h->cmdQueue->Size() == 0"
+ "h->cmdQueue->Size() == 1"
+ "h->contextBuff != nullptr"
+ "h->contextBuff == nullptr"
+ "h->curr.afeDmaBuffer != nullptr"
+ "h->curr.pMetaData->afeProc.enabled"
+ "h->curr.pMetaDataBuffer != nullptr"
+ "h->curr.pMetaDataBuffer == nullptr"
+ "h->currFSMMasterCh < h->inchannels"
+ "h->flashStatus.totalAmbientFrames > 0"
+ "h->frameDescCurr != h->frameDescNext"
+ "h->frameDescCurr->pBuff != 0"
+ "h->frameDescCurr->pBuff == 0"
+ "h->frameDescNext->pBuff != 0"
+ "h->frameDescNext->pBuff->entry.buffRef.ref[0] != 0"
+ "h->hCtrl != 0"
+ "h->hSensor"
+ "h->hSensor && h->hStrobe"
+ "h->hSensor->ExposureUpdateDelayGet() == 1"
+ "h->inited"
+ "h->mStatId >= 0"
+ "h->m_dataBuffFifo"
+ "h->m_dataReadySema != NULLSEMA"
+ "h->m_isAFMoving"
+ "h->m_isAFStopping == false"
+ "h->m_pFSMStateHistoryRing"
+ "h->m_pKnob2SettingsTable != 0"
+ "h->m_pLux2KnobTable != 0"
+ "h->m_pReqCurr"
+ "h->m_pReqCurr == nullptr"
+ "h->m_stLSCropped->configIndex != CIMAGESENSOR_CONFIG_INVALID"
+ "h->m_stLSCroppedPerConfig[pCmd->configIndex].configIndex == pCmd->configIndex"
+ "h->managed == 0"
+ "h->mcacheRequestCmd->numofdsids > 0 && h->mcacheRequestCmd->numofdsids <= CISP_MAX_MCACHE_DSIDS"
+ "h->next.pMetaDataBuffer != nullptr"
+ "h->next.pMetaDataBuffer == nullptr"
+ "h->pRes"
+ "h->pStatHdr->thumbnailTotal > 0"
+ "h->pTMStillMetaDataCBufArray[ch]"
+ "h->pTMStillMetaDataCBufArray[h->currFSMMasterCh]"
+ "h->peridotConfigDone[type] == false"
+ "h->pstLSFull != 0"
+ "h->replay.numFrames == 1"
+ "h->signature == CFSM_SIGNATURE"
+ "h->task.bufContext != nullptr"
+ "h->task.bufContext == nullptr"
+ "h->task.bufMetadata == nullptr"
+ "h->task.bufPyramidY == nullptr"
+ "h->task.bufSpd == nullptr"
+ "h->task.pContextUncached != nullptr"
+ "h->task.pMetaData != nullptr"
+ "h2tchIOMan != 0"
+ "hAICamProc->ChannelStop"
+ "hAWBSemanticProc"
+ "hBLC != 0"
+ "hCtrl != 0"
+ "hCtrl != NULL"
+ "hDMAIn != 0"
+ "hDMAIn == 0"
+ "hDeviceConfig != nullptr"
+ "hDistMulti"
+ "hDriver"
+ "hDrv != NULL"
+ "hDrv != nullptr"
+ "hFEPDMAOut2nd != 0"
+ "hFEPDMAOut[CIC_VC_PIPELINE_MAIN] != 0"
+ "hFSM != 0"
+ "hFSMFID != 0"
+ "hFSMFlash != 0"
+ "hFSMMultiSync != 0"
+ "hFSMReplay != 0"
+ "hFlood"
+ "hFlow->ReleaseAllBuf"
+ "hGOC"
+ "hI2C != 0"
+ "hI2C && status"
+ "hIBLC != 0"
+ "hIC"
+ "hIC->WaitForFullStop"
+ "hICCore[camIndex]->cachedAEUpdate.request & AE_USEMAP_VSIZE"
+ "hICCore[i]"
+ "hICCore[slave->index]->hSensor->IsStreaming() == true"
+ "hICExclave[i]"
+ "hICMultiSyncCams != 0"
+ "hICMultiSyncDepth != 0"
+ "hICMultiSyncFront != 0"
+ "hIO != 0"
+ "hInputDMA != nullptr"
+ "hLPDP"
+ "hLSC != 0"
+ "hLTMStopDone"
+ "hManager != 0"
+ "hManagerIdIn != 0"
+ "hMemoryAllocator != nullptr"
+ "hMipiDrv"
+ "hMotionStopCap"
+ "hMsProcDrv"
+ "hMultiCapFSM != 0"
+ "hOutputDMA != nullptr"
+ "hOutputDMA == nullptr"
+ "hPCEDriver != nullptr"
+ "hPDAF != nullptr"
+ "hPDEProc"
+ "hPDP"
+ "hPDP != 0"
+ "hPool != 0"
+ "hPoolMan != 0"
+ "hPoolMan->InFlight(chDescr->dynPool[CIMAGEFLOW_POOL_ID_CAPTURE_FULL_RES_YCC]->IDGet()) == 0"
+ "hPoolMan->InFlight(chDescr->dynPool[CIMAGEFLOW_POOL_ID_CAPTURE_PDC_RAW]->IDGet()) == 0"
+ "hPoolMan->InFlight(chDescr->dynPool[CIMAGEFLOW_POOL_ID_RAW]->IDGet()) == 0"
+ "hPoolMan->InFlight(chDescr->dynPool[CIMAGEFLOW_POOL_ID_RAW_AUX]->IDGet()) == 0"
+ "hPoolMan->InFlight(chDescr->dynPool[CIMAGEFLOW_POOL_ID_RAW_SIFR]->IDGet()) == 0"
+ "hPoolMan->InFlight(chDescr->dynPool[CIMAGEFLOW_POOL_ID_RENDERED_RAW]->IDGet()) == 0"
+ "hPoolMan->InFlight(chDescr->dynPool[CIMAGEFLOW_POOL_ID_STAT_PIXELOUTPUT]->IDGet()) == 0"
+ "hPoolMan->InFlight(chDescr->dynPool[CIMAGEFLOW_POOL_ID_VISION_RESIZE_RAW]->IDGet()) == 0"
+ "hPoolMan->InFlight(chDescr->dynPool[CIMAGEFLOW_POOL_ID_YCC]->IDGet()) == 0"
+ "hPoolMan->InFlight(chDescr->dynPool[i]->IDGet()) == 0"
+ "hPoolMan->InFlight(chDescr->dynPool[info->type]->IDGet()) == 0"
+ "hPoolMan->InFlight(pool->IDGet()) == 0"
+ "hPowerSupplyDrv"
+ "hRPC"
+ "hRPC is NULL"
+ "hScale >= 0x10000"
+ "hScale >= 0x2000 && vScale >= 0x2000"
+ "hScale >= 0x4000"
+ "hSecureM3Mgr"
+ "hSecureM3drv"
+ "hSensor"
+ "hSensor != 0"
+ "hSensor != nullptr"
+ "hSensor!= 0"
+ "hSensor->IsSifrOnGet(%d) %d\n"
+ "hSensor->IsStreaming()"
+ "hSifDMAOut[pipeId] != 0"
+ "hSysConfig"
+ "hThumbDMAOut[CIC_VC_PIPELINE_MAIN] != 0"
+ "hVCPipeline[pipeId] != 0"
+ "hVCPipeline[pipeId] != nullptr"
+ "hamvDistThresh = 0x%x"
+ "hamvSize = 0x%x"
+ "handle != 0"
+ "handle != NULL"
+ "handler == memHandler"
+ "handshake_info != NULL"
+ "handshake_sema"
+ "hardware is busy"
+ "hardware should idle when resume"
+ "hardware should idle when suspend"
+ "head == 0"
+ "header"
+ "header->data"
+ "header->data->GetRetain()==1"
+ "header->data->Size() >= (size_t)maskSize"
+ "headerSize: %d, ptSize: %d \n"
+ "headerSize: %d, ptSize: %d cfgSize: %d tSizeInW %d\n"
+ "headerSize: %u, ptSize: %u, totalSize (words): %u \n"
+ "heap_resource != (FFWMUTEX)0"
+ "heap_resource != 0"
+ "heatMap.height == size"
+ "heatMap.width == size * nChannels"
+ "height"
+ "height <= 1024 && height >= 16"
+ "height <= 8190 && height >= 64"
+ "height = %d, outHeight = %d, height/outHeight = %f is greater than 1.0/lower = %f\n"
+ "height = %d, outHeight = %d, height/outHeight = %f is less than 1.0/lower = %f\n"
+ "height >= 32 && height <= 8190"
+ "height >= 64 && height <= 8190"
+ "height >= kNccProcRawHeightMin"
+ "heightUs && (offsetUs + heightUs <= frameTimeUs)"
+ "hist != NULL"
+ "hist0Window x %u y %u w %u h %u"
+ "histAlloc != NULL"
+ "histAllocSeg2[i] >= 0.0f"
+ "histAlloc[%i] = %f"
+ "histAlloc[i] >= 0.0f"
+ "histAllocated != NULL"
+ "histCeil != NULL"
+ "histPerc[%i] = %f"
+ "histPerc[i] >= 0.0f"
+ "histSimScr [cct, tint]=[%f, %f] "
+ "hithStatBuf"
+ "hithStatROI.height <= (pDescr->paramNoiClr.ltmRect.end_y - pDescr->paramNoiClr.ltmRect.start_y)"
+ "hithStatROI.width <= (pDescr->paramNoiClr.ltmRect.end_x - pDescr->paramNoiClr.ltmRect.start_x)"
+ "hithStatROI.x + (int)hithStatROI.width <= (int)pDescr->paramNoiClr.ltmRect.end_x"
+ "hithStatROI.x >= (int)pDescr->paramNoiClr.ltmRect.start_x"
+ "hithStatROI.y + (int)hithStatROI.height <= (int)pDescr->paramNoiClr.ltmRect.end_y"
+ "hithStatROI.y >= (int)pDescr->paramNoiClr.ltmRect.start_y"
+ "homographyBoundaryMax_x = 0x%x"
+ "homographyBoundaryMax_y = 0x%x"
+ "homographyBoundaryMin_x = 0x%x"
+ "homographyBoundaryMin_y = 0x%x"
+ "homographyMatFrac[%d] = 0x%x"
+ "homographyMatInt[%d] = 0x%x"
+ "horizonCoeff[%d]= %f %f %f"
+ "host warpMatrixTF copied:"
+ "hostMeta->flashMixMatrix [0]:%d [2]:%d [253]:%d [255]:%d"
+ "hostMetaBuf"
+ "hostMetaBuf != 0"
+ "hostMetaData != nullptr"
+ "hostMetaLocalHistWithClipping=%lu localHistStatSize=%i"
+ "hostpubkeys aries 0x%x %x .. %x %x %x\n"
+ "hostsig %x %x %x pubkey %x %x %x tag %x %x %x payload %x %x %xiv %x %x %x hmac %x %x %x\n"
+ "hsize %d vsize %d"
+ "hwUser != CIspHwResourceServiceH17::InvalidUserHandler"
+ "hwbusy %d state %d bProcessedFrameDone %d"
+ "i != IC_CONTROLLER_TOTAL"
+ "i != TOF_DEPTH_API_TOFAF_FPS_COUNT"
+ "i %d rawSampleNbrVISIn %d rawSampleNbrWr %d maxGyroSampleInPerFrame %d\n"
+ "i %d rect %d %d %d %d en %d"
+ "i %d, sysMode %d\n"
+ "i %zu minOfMaxFrameRateInGroup %d maxFrameRate %d"
+ "i < (pModulationTable->numEntries-1)"
+ "i < 4"
+ "i < kAttnQueueSize"
+ "i < kERQueueSize"
+ "i < kFDQueueSize"
+ "i < maxOpNbrPerRequest"
+ "i < pOpListHdr->tot"
+ "i <= 1000"
+ "i = %d, lx = %f, ly = %f, lw = %f\n"
+ "i = %d, lx = 0x%x, ly = 0x%x, lw = 0x%x\n"
+ "i = %d, rx = %f, ry = %f, rw = %f\n"
+ "i = %d, rx = 0x%x, ry = 0x%x, rw = 0x%x\n"
+ "i == 0"
+ "i == 0 || face.boundingBox.score <= faces[i - 1].boundingBox.score"
+ "i == 0 || trkObjects[ti].age <= trkObjects[killTemp[i - 1].index].age"
+ "i%u, pOpBufs[i] %p\n"
+ "i2cDrv != NULL"
+ "i2cReadResSignal != (SEMA)0"
+ "i2cWriteResSignal != (SEMA)0"
+ "i2c_write.field0.header.data_len <= sizeof(i2c_write.field0.data.p_data)"
+ "i<CPOWERSUPPLY_CMD_DEPTH"
+ "i=%d,TMode=%d,HMode=%d,Hdr:Stride=%d,Size=%d,Offset=%d,Data:Size=%d,Offset=%d,P=%d"
+ "i=%d,compMode=%d,TexW=%d,TexH=%d,Tex:Offset=%d,Stride=%d,Size=%d,Meta:Offset=%d,Size=%d"
+ "i_aeInput->pMeta->inverseBinningGainFactor > 0"
+ "i_aeStats != 0"
+ "i_aeStats->numTilesX <= FULL_SIZE_AE_TILES_X"
+ "i_aeStats->numTilesY <= FULL_SIZE_AE_TILES_Y"
+ "icCompressCfg.inputCompressEn"
+ "icCompressCfg.inputCompressEn && icCompressCfg.outputCompressEn && \"TODO\""
+ "icCompressCfg.outputCompressEn"
+ "icCompressCfg: inCompEn %d outCompEn %d\n"
+ "icCompressCfg: inCompEn %d outCompEn %d inputTot %d outputTot %d\n"
+ "icCompressCfg: inputTot %d outputTot %d\n"
+ "icThreadSemaArray[i] != (SEMA)0"
+ "id != (size_t)CBufferPool::noID"
+ "id %d align %u size %u rowAlign %u"
+ "id %d cnt %u align %u sz %u rowAlign %u dim %d x %d fmt %d cmpnd %d pk %d"
+ "id %d width %u height %u baseAddr %zx stride %zu format 0x%x max %zx"
+ "id %zu, takes total %.4fms"
+ "id < FE_NUM_AF_WINDOWS"
+ "id < FE_NUM_AWBAE_WINDOWS"
+ "id < FE_NUM_HIGH_RES_AWBAE_WINDOWS"
+ "id < ISPHWH17DMAId_MaxNbr"
+ "id < MAX_SIFQ_USERS"
+ "id < PE_TOT"
+ "id < ePacketID::NumIDs"
+ "id < mMaxEventLoggers"
+ "id < max"
+ "id < maxFileNbr"
+ "id < nbrOfObject"
+ "id >= 0 && id < CDMEDIABUSMANAGER_CMD_COMMON_TOT"
+ "id >= 0 && id < kAttnQueueSize"
+ "id >= FLOWBASE_CMD_TOT"
+ "idac_max_limit=0x%08X"
+ "idealPct set %d"
+ "idolController != nullptr"
+ "idx != (size_t)-1"
+ "idx != 0"
+ "idx != idxNew"
+ "idx != idxOld"
+ "idx %u addr %zx"
+ "idx %u type %u memtype %u size %u"
+ "idx < FLASH_SHARED_CHANNELS"
+ "idx < MAX_DMA_CHAIN_CONFIG"
+ "idx < MAX_GPIO_DRIVERS"
+ "idx < N"
+ "idx < NUM_ELEMENTS(gpioCfg.expDrv)"
+ "idx >= 1 && idx <= 4"
+ "idx(%d) should < (%d)"
+ "idx=%d fdRect:%d %d %d %d ltm:%.4f %.4f %.4f %.4f"
+ "idxMaxStrobe     = %d"
+ "idxMaxTorch      = %d"
+ "idxMinStrobe     = %d"
+ "idxMinTorch      = %d"
+ "idxMin[mode] < idxMax[mode]"
+ "idxOld <= idxNew"
+ "idxToUse < CISP_AE_BRACKETING_CHANNEL_COUNT_MAX"
+ "if iTorch > Ytarg: 0x%x, pctIntens10: 0x%x"
+ "iirFilterMultiplier=%f"
+ "illegal case"
+ "imageInfo.dataImageSize <= imageInfo.dMemSize"
+ "imageInfo.textImageSize <= imageInfo.iMemSize"
+ "imageWidth %d  imageHeight %d  profileWidth %d  profileHeight %d\n"
+ "imgCapBufCfg"
+ "imgHeight"
+ "imgHeight <= CSystemConfigurator::Instance()->GetMaxMBNRHeight()"
+ "imgHeight <= mbnrMaxImageHeight"
+ "imgHeight=%zu, mbnrMaxImageHeight=%zu"
+ "imgSize = [%u, %u]"
+ "imgWidth <= CSystemConfigurator::Instance()->GetMaxMBNRWidth()"
+ "imgWidth <= mbnrMaxImageWidth"
+ "imgWidth, imgHeight = [%d, %d]"
+ "imgWidth=%zu, mbnrMaxImageWidth=%zu"
+ "imon_chrg=0x%08X"
+ "inBayerHeight <= 8190 && inBayerHeight >= 64"
+ "inBayerWidth <= 5120 && inBayerWidth >= 128"
+ "inCompEn: %d, forcing isTileMode=%d\n"
+ "inHeight != 0"
+ "inSel %u"
+ "inSelBes == (AISP_ISPCONFIG_PIPE_ISPCONFIG_BESPROC_INSEL_INSEL_BESPROCDMA)"
+ "inSizeX >= outSizeX"
+ "inSizeY >= outSizeY"
+ "inSrcDmaId <= ISPHWH17DMAId_AISPDMA_PIPE_IspPipeSIfDmaSrc2"
+ "inSyncMode == false"
+ "inTrigIrqHandle != 0"
+ "inUseList == 0"
+ "inW = %d, inH = %d, outW = %d, outH = %d\n"
+ "inWidth != 0"
+ "inWidth %u inHeight %u, weightMapWidth %u, weightMapHeight %u"
+ "inchannels <= ISP_CAMERA_CHANNEL_TOT"
+ "incoming BKT mode %u, oisType %u, [%u, %u, %u, %u, %u] capEV %u"
+ "index %zu "
+ "index * sizeof(uint32_t) <= bufSize"
+ "index < (28)"
+ "index < (size_t)freqTot"
+ "index < 15"
+ "index < FESTATS_THUMBNAIL_INPUT_TOTAL"
+ "index < HITH_MAX_THUMBNAIL_COUNT"
+ "index < MAX_GROUP_ID_IDX"
+ "index < SB_DATA_DST_DMA_TOTAL"
+ "index < VCPIPELINE_SB_PACKET_TYPE_TOT"
+ "index < VD56G0BALAN_TEST_PATTERN_TOT"
+ "index < VD56G8_TEST_PATTERN_TOT"
+ "index < chDescrTarget->bracketingTuningInfo.bracketCount"
+ "index < configTot"
+ "index < entries"
+ "index < maxUserNbr"
+ "index < numTestPatterns"
+ "index < tot"
+ "index <= (DATA_DST_AFE_PROC2 - DATA_DST_AFE_PROC0)"
+ "index <= (DATA_DST_FEP3 - DATA_DST_FEP0)"
+ "index <= CS40L61_MODE01_R_MAX_SIZE"
+ "index <= MAX_SRC_INPUT_DMA"
+ "index <= SENSORIMX703_TEST_PATTERN_MAX"
+ "index <= SENSORIMX803_TEST_PATTERN_MAX"
+ "index <= SENSORIMX903_TEST_PATTERN_MAX"
+ "index <= SENSORIMX972_TEST_PATTERN_MAX"
+ "index == 0"
+ "index == pEntry->parent"
+ "index >= 0"
+ "index >= 0 & index < (int)(GetNbrOfAxiDma())"
+ "index >= 0 & index < (int)(GetNbrOfPatchDma())"
+ "index >= 0 && index < MAX_SRC_INPUT_DMA"
+ "indexH >= 0"
+ "indx >= 0 && indx < AF_TOF_GD_NUM_HIST"
+ "indx must be in range [0, AF_TOF_GD_NUM_HIST-1]"
+ "info->count > 0"
+ "info->type < CISP_POOL_TOT"
+ "info[%u][%u]:"
+ "init"
+ "init vSizeLB to %d (Max of %d and %d), cfg %d mfrt %d spd %d"
+ "initXin < RES_SIZE_MAXIMUM"
+ "initYin < RES_SIZE_MAXIMUM"
+ "inited %d"
+ "inited %d, ipc_was_down %d"
+ "inited[endPointId]"
+ "initial sky rgLogRatio = %.2f bgLogRatio = %.2f"
+ "initialize"
+ "inlierPct = %f"
+ "input FORMAT 420, called dummyPool->BufferLink(), pGenProcessInput2Buffer = %p\n"
+ "input FORMAT 420, called dummyPool->BufferLink(), pGenProcessInputBuffer = %p\n"
+ "input FORMAT 422, called dummyPool->BufferLink(), pGenProcessInput2Buffer = %p\n"
+ "input FORMAT Raw, called dummyPool->BufferLink(), pGenProcessInput2Buffer = %p\n"
+ "input FORMAT Raw, called dummyPool->BufferLink(), pGenProcessInputBuffer = %p\n"
+ "input buffer should have contained enough space for raw-frame + Dx outputs + sMetaSplitPD"
+ "input->anstBGRASize <= CISP_AICAM_ANST_VID_MAX_BYTES"
+ "input->faceFraction >= 0"
+ "input.afeStride > 0"
+ "input.binningX == 1"
+ "input.binningX == 2"
+ "input.binningY == 1"
+ "input.binningY == 2"
+ "input.height == h * c"
+ "input.height == output.height"
+ "input.pixelFormat == fwDetectorBufferPixelFormatFromBmBuffer(m_config.netOutputBufferDesc.pixelFormat)"
+ "input.pixelFormat == kBmBufferPixelFormatType_Int8"
+ "input.pixelFormat == kBmBufferPixelFormatType_UInt8"
+ "input.pixelFormat == kFwDetectorBufferPixelFormatTypeHalf"
+ "input.pixelFormat == kFwDetectorBufferPixelFormatTypeInt8"
+ "input.pixelFormat == kFwDetectorBufferPixelFormatTypeUInt8"
+ "input.rowBytes == (uint32_t)sizeof(float) * numInputChannels * iw"
+ "input.sizeX % AFE_TOTAL_CROP_ALIGN_X == 0"
+ "input.sizeY % AFE_TOTAL_CROP_ALIGN_Y == 0"
+ "input.startX % AFE_TOTAL_CROP_ALIGN_X == 0"
+ "input.startY % AFE_TOTAL_CROP_ALIGN_Y == 0"
+ "input.subX >= 1"
+ "input.subY >= 1"
+ "input.width == output.width"
+ "input: i = %d, matB[0] = %f, matB[1] = %f, matB[2] = %f\n"
+ "input: inputStride=%d\n"
+ "input: strideInY=%d, strideInC=%d\n"
+ "inputBufIdx < EXTSLAF_IPC_INPUT_END - EXTSLAF_IPC_INPUT_START + 1"
+ "inputBufIdx < ipcInEnd - ipcInStart + 1"
+ "inputBufLen %u"
+ "inputBuffersCount >= (3)"
+ "inputBuffersCount >= 2"
+ "inputBuffers[(0)] != nullptr && inputBuffers[(0)]->DataPointer() != nullptr"
+ "inputBuffers[(1)] != nullptr && inputBuffers[(1)]->DataPointer() != nullptr"
+ "inputBuffers[(2)] != nullptr && inputBuffers[(2)]->DataPointer() != nullptr"
+ "inputChannel == (3)"
+ "inputData->isInitialized == false"
+ "inputDataLength + 2 <= MAX_LENGTH"
+ "inputEIT=%.3f"
+ "inputFormat = %d"
+ "inputFormat = %d, outputFormat = %d\n"
+ "inputFound == 1"
+ "inputFrame->Size() <= sizeof(pdeDebugHostMetadata->data)"
+ "inputHeight = %d"
+ "inputHistogram[i] <= expectedLocalHistPixelCount"
+ "inputHistogram[j] <= expectedGlobalHistPixelCount"
+ "inputMixWeight > 0.0f"
+ "inputNumPoints < kLengthRansacInlierIndices"
+ "inputParamBuf != 0"
+ "inputPipe != 0"
+ "inputPipeEnable != nullptr"
+ "inputPipeSema != (SEMA)0"
+ "inputPipe[pin]"
+ "inputSel < FESTATS_THUMBNAIL_INPUT_TOTAL"
+ "inputSel < HITH_THUMBNAIL_INPUT_TOTAL"
+ "inputTileLines"
+ "inputType == InputType::IR"
+ "inputType == eERInputType::ER_IR"
+ "inputW=%d, inputH=%d, inputStartX=%d, inputStartY=%d\n"
+ "inputWidth = %d"
+ "inputs[k].cellCountY == (signed)geometry.roi.cellCountY"
+ "inputselect %d incorrect"
+ "inputselect <= INTERFACE_ACI"
+ "insize != CCONTROLLER_INVALID_SHARED_INSIZE"
+ "insize == sizeof(sCPDEProcV2CmdPropertyWrite)"
+ "insize == sizeof(sPDEProcV2CmdOutputConfig)"
+ "insize == sizeof(struct sCIspCmdChReset)"
+ "insize == sizeof(struct sCIspCmdChStandBy)"
+ "insize == sizeof(struct sCIspCmdChStart)"
+ "insize == sizeof(struct sCIspCmdChStop)"
+ "insize == sizeof(struct sCIspCmdConfigGet)"
+ "insize == sizeof(struct sCIspCmdConfigGetExt)"
+ "insize == sizeof(struct sCIspCmdFIDEnter)"
+ "insize == sizeof(struct sCIspCmdFIDExit)"
+ "insize == sizeof(struct sCIspCmdFlickerSensorSet)"
+ "insize == sizeof(struct sCIspCmdGetBesParam)"
+ "insize == sizeof(struct sCIspCmdPlatformInfo)"
+ "insize == sizeof(struct sCIspCmdPowerDown)"
+ "insize == sizeof(struct sCIspCmdPowerSupplyControl)"
+ "insize == sizeof(struct sCIspCmdPrintEnable)"
+ "insize == sizeof(struct sCIspCmdReset)"
+ "insize == sizeof(struct sCIspCmdSuspend)"
+ "insize == sizeof(struct sCIspCmdTimeProfileShow)"
+ "insize == sizeof(struct sCIspCmdTimeProfileStart)"
+ "insize == sizeof(struct sCIspCmdTimeProfileStop)"
+ "insize == sizeof(struct sCIspCmdTraceEnable)"
+ "insize > 0"
+ "insize>=sizeof(sCIspCmdChPeridotModeCfgSet)+sizeof(sCIspPeridotModeCfg)-1"
+ "instance"
+ "instance != 0"
+ "instance != NULL"
+ "instance == 0"
+ "instance == NULL"
+ "instance == nullptr"
+ "instance->ch != 0"
+ "instance->chT2H != 0"
+ "insufficient frequency request %d < %d"
+ "intSrcLine >=0 && intSrcLine <= 31"
+ "intX %d intY %d IntYRecip %d, IntYRecip %d offset x %d (%d) y %d (%d)"
+ "interCntStatIntMask0 = 0x%x"
+ "interCntStatIntMask1 = 0x%x"
+ "interCntStatIntMask2 = 0x%x"
+ "internal metadata buffer is null, but should always exist"
+ "internalCmdListMutex_ != (FFWMUTEX)0"
+ "internalSetMaxIntegrationTime"
+ "internalTraceBuffer != NULL"
+ "interpWeight <= 1.f"
+ "interpolate"
+ "interrupt(us)"
+ "interruptTimer != 0"
+ "interruptTimer != NULL"
+ "interruptTimerSignal != 0"
+ "inv_sx inv_sy: [%.4f, %.4f]"
+ "invalid ch %zu"
+ "invalid flickerDetectionStatus"
+ "invalid frame count %llu %llu"
+ "invalid gmcType"
+ "invalid stage number %zu for flow %s"
+ "invalid stage number for flow %s"
+ "invalid struct size"
+ "invalid tmp shared buffer %d"
+ "ioBufers[%d]=%#zx stride=%u %d x %d"
+ "ioCtrl"
+ "ioCtrl != 0"
+ "ioDescrBuf != 0"
+ "ipa/LC_internal_tracer.bin"
+ "ipa/LC_internal_tracer_ch.bin"
+ "ipcCfg.bufNbr <= maxAneIpcBufMsg"
+ "ipcCfg.bufSize[%u]=%u"
+ "ipcCfg.bufSize[i] <= pRes->inputBufLen(AC_NET_UID_ANST, procedureId, inputBufIdx)"
+ "ipcCfg.bufSize[i] <= pRes->inputBufLen(AC_NET_UID_ATTR, procedureId, 0)"
+ "ipcCfg.bufSize[i] <= pRes->interbufLen(AC_NET_UID_ANST, procedureId, 0)"
+ "ipcCfg.bufSize[i] <= pRes->interbufLen(AC_NET_UID_ATTR, procedureId, 0)"
+ "ipcCfg.bufSize[i] <= pRes->outputBufLen(AC_NET_UID_ANST, procedureId, 0)"
+ "ipcCfg.bufSize[i] <= pRes->outputBufLen(AC_NET_UID_ATTR, procedureId, 0)"
+ "ipcCfg.buf[%u] %p %zu ipcIndex %u "
+ "ipcCfg: cmd %d userId %d size %d builtinProgramId %d frmCtxId %d frameNbr %d\n"
+ "ipcCfg: cmd %d userId 0x%x size %d builtinProgramId %d frmCtxId %d frameNbr %d\n"
+ "ipcMapEntries"
+ "ipcMem %p %zu"
+ "ipcm.data != NULL"
+ "ipcm.data %p ipcMem %zu"
+ "ipcm.size != 0"
+ "irBuffer != nullptr"
+ "irMetadata != nullptr"
+ "irqLine != 0"
+ "isArmError"
+ "isCameraObstructed %d expected %d"
+ "isDetRunningThisFrame || !numDetObjects"
+ "isDummyMove"
+ "isEVm == false"
+ "isEngaged %d EngageSts 0x%x"
+ "isExclaveOnlyMode"
+ "isExclaveOutputEnabled"
+ "isExtLuxValid && detectScheme"
+ "isExternalLx=%d photometerDetectionScheme=%d"
+ "isFDEnabled() == 0"
+ "isHWBusy"
+ "isHwMapped"
+ "isHwMapped == true"
+ "isHwMapped=%d"
+ "isHwMapped=%d isPack=%d"
+ "isLuma"
+ "isMaskavailable"
+ "isPowerDomainPowerOn == IsSectionPowerOn(sectionId)"
+ "isPowerOn"
+ "isQuadra || ((input.subX == 1) && (input.subY == 1))"
+ "isQuadra || ((subX == 1) && (subY == 1))"
+ "isSafe"
+ "isSafe: armed_reg %d stat_reg %d, is_armed %d\n"
+ "isSifrConfig"
+ "isSifrM %d, sifrSkipR %d,  sifrOffP %d, HRDampingR %f, rdod %d, esifr %llu"
+ "isSifrOn"
+ "isSm3FwProgrammed"
+ "isTorchOn=%x"
+ "isTorchOn=%x, CtorchNom 0x%x"
+ "isTorchOn=%x, curr %dmA"
+ "isTorchOn=%x, curr (0 1 4)[%d %d %d] mA"
+ "isTorchOn=%x, torchRegister=0x%x"
+ "isVHDR == false"
+ "ispConfigId=%d,p=%d,s=%d"
+ "ispDump/ispEventDump.bin"
+ "ispDump/ispEventDump_"
+ "isp_tb_client"
+ "isp_tb_server"
+ "isrHandle"
+ "isrHandleDMADone != 0"
+ "isrHandleHATDMADone != 0"
+ "isrHandlePipIRQ != 0"
+ "isrHandleStat[0] != 0"
+ "isrHandleStat[1] != 0"
+ "isrHandleStat[2] != 0"
+ "isrHandleStat[3] != 0"
+ "isrHandleStat[4] != 0"
+ "isrHandleStat[5] != 0"
+ "isrHandleStat[6] != 0"
+ "isrHandleStat[7] != 0"
+ "isrHandle[cfgIndex]"
+ "isrHandle_"
+ "isrNonSecureModeSwitchHandle != 0"
+ "isrSecureModeSwitchHandle != 0"
+ "isrSource <= PLATFORM_INT_AISP_LAST"
+ "isrSource >= PLATFORM_INT_CVD_FIRST"
+ "isrhandle != 0"
+ "itcmSize > 0x1000"
+ "ivp"
+ "ix out of bounds!"
+ "iy out of bounds!"
+ "j == 0"
+ "j == Decimation_Config_regular"
+ "jamSema != 0"
+ "jitterPosAFTileScorePerObjectPerFilter.bayerY_15x3_bpf_f0 != 0"
+ "jitterPosAFTileScorePerObjectPerFilter.bayerY_15x3_bpf_f1 != 0"
+ "jitterPosAFTileScorePerObjectPerFilter.bayerY_3x3_f0 != 0"
+ "jitterPosAFTileScorePerObjectPerFilter.bayerY_3x3_f1 != 0"
+ "jitterPosAFTileScorePerObjectPerFilter.bayerY_hiir_f0 != 0"
+ "jitterPosAFTileScorePerObjectPerFilter.bayerY_viir_f0 != 0"
+ "jitterPosAFTileScorePerObjectPerFilter.rawB_7x1_hfir != 0"
+ "jitterPosAFTileScorePerObjectPerFilter.rawGb_7x1_hfir != 0"
+ "jitterPosAFTileScorePerObjectPerFilter.rawGr_7x1_hfir != 0"
+ "jitterPosAFTileScorePerObjectPerFilter.rawR_7x1_hfir != 0"
+ "jitterPosBlurMAvgScorePerObjectPerFilter.blurConf != 0"
+ "jitterPosBlurMAvgScorePerObjectPerFilter.blurExtent != 0"
+ "jitterPosBlurMAvgScorePerObjectPerFilter.sharpness_L1 != 0"
+ "jitterPosBlurMAvgScorePerObjectPerFilter.sharpness_L2 != 0"
+ "jitterPosBlurMTileScorePerObjectPerFilter.blurConf != 0"
+ "jitterPosBlurMTileScorePerObjectPerFilter.blurExtent != 0"
+ "jitterPosBlurMTileScorePerObjectPerFilter.sharpness_L1 != 0"
+ "jitterPosBlurMTileScorePerObjectPerFilter.sharpness_L2 != 0"
+ "jitterPositionAFScorePerWindow != 0"
+ "jitterPositionAFScorePerWindowPerFilter.bayerY_15x3_bpf_f0 != 0"
+ "jitterPositionAFScorePerWindowPerFilter.bayerY_15x3_bpf_f1 != 0"
+ "jitterPositionAFScorePerWindowPerFilter.bayerY_3x3_f0 != 0"
+ "jitterPositionAFScorePerWindowPerFilter.bayerY_3x3_f1 != 0"
+ "jitterPositionAFScorePerWindowPerFilter.bayerY_hiir_f0 != 0"
+ "jitterPositionAFScorePerWindowPerFilter.bayerY_viir_f0 != 0"
+ "jitterPositionAFScorePerWindowPerFilter.rawB_7x1_hfir != 0"
+ "jitterPositionAFScorePerWindowPerFilter.rawGb_7x1_hfir != 0"
+ "jitterPositionAFScorePerWindowPerFilter.rawGr_7x1_hfir != 0"
+ "jitterPositionAFScorePerWindowPerFilter.rawR_7x1_hfir != 0"
+ "jobPendingCnt=%d, jobQSize=%ld"
+ "k < FocusLayout::PATTERN_COUNT_MAX"
+ "k < PDAF::FocusLayout::PATTERN_COUNT_MAX"
+ "kDepthBufferSize >= bufs[DCN_BUF_PEARL]->Size(0)"
+ "kDepthBufferStride == bufs[DCN_BUF_PEARL]->Stride(0)"
+ "kImageArea > 0.0f"
+ "kMaxPairsToSolver <= kNccProcKeySizeMax"
+ "kMinNumSupportPointsMostComplexModel=%d, kRansacMinMatchingScoreAccepted=%f\n"
+ "kPP_HiBinIndex >= pX"
+ "kSelect == 0 || kSelect == 1"
+ "kdebug"
+ "kernel[0 * 5 + 0] == kernel[4 * 5 + 4]"
+ "kernel[0 * 5 + 1] == kernel[4 * 5 + 3]"
+ "kernel[0 * 5 + 2] == kernel[4 * 5 + 2]"
+ "kernel[0 * 5 + 3] == kernel[0 * 5 + 1]"
+ "kernel[0 * 5 + 3] == kernel[4 * 5 + 1]"
+ "kernel[0 * 5 + 3] == kernel[4 * 5 + 3]"
+ "kernel[0 * 5 + 4] == kernel[4 * 5 + 0]"
+ "kernel[1 * 5 + 0] == kernel[1 * 5 + 4]"
+ "kernel[1 * 5 + 0] == kernel[3 * 5 + 0]"
+ "kernel[1 * 5 + 0] == kernel[3 * 5 + 4]"
+ "kernel[1 * 5 + 1] == 0"
+ "kernel[1 * 5 + 1] == kernel[3 * 5 + 3]"
+ "kernel[1 * 5 + 2] == kernel[3 * 5 + 2]"
+ "kernel[1 * 5 + 3] == 0"
+ "kernel[1 * 5 + 3] == kernel[3 * 5 + 1]"
+ "kernel[1 * 5 + 4] == kernel[3 * 5 + 0]"
+ "kernel[2 * 5 + 0] == kernel[2 * 5 + 4]"
+ "kernel[2 * 5 + 1] == kernel[2 * 5 + 3]"
+ "kernel[2 * 5 + 2] == 0"
+ "kernel[3 * 5 + 1] == 0"
+ "kernel[3 * 5 + 3] == 0"
+ "key == 0xF"
+ "keyExchange syscfg %016llx\n"
+ "keypoint header %d"
+ "keypointByteOffset = %d"
+ "keypointCount = %d"
+ "keypointState"
+ "keypointVersion = %d"
+ "keys %x %x %x\n"
+ "kmaxScl=%f, kmaxRot=%f, kmaxCtrTranslation=%f, kPixelSize=%f, kMinNumSupportPointsMostComplexModel=%d, kRansacMinMatchingScoreAccepted=%f\n"
+ "knee %d count %d: %.2f x %.2f"
+ "knee %d count %d: %.2f x %.2f exp:[%.2f..%.2f]"
+ "knee %d count %d: %.2f x %.2f exp[%.2f..%.2f]=> %.2f x %.2f freq %llu"
+ "knee %d count %d: %.2f x %.2f max[%.2fx%.u] => %.2f x %.2f freq %llu"
+ "knee[%d] = %.3f %d %d, knee[%d] = %.3f %d %d, not monotonic!"
+ "knee[%d] = (%.3f x %d x %d) => (%.3f x %d), SG = %d"
+ "knee[%d] = (extension) (%.3f x %d), SG = %d"
+ "kpOffset[%d] = %d"
+ "kpixSize = %f, cx = %f, cy = %f, inWidth = %f, inHeight = %f"
+ "l 0: %d %f %d\n"
+ "lacc rma0 addr 0x%llx Size %u\n"
+ "lacc rma1 addr 0x%llx Size %u\n"
+ "lacc rma2 addr 0x%llx Size %u\n"
+ "lacc rma3 addr 0x%llx Size %u\n"
+ "lacc wma0 addr 0x%llx Size %u\n"
+ "lacc wma1 addr 0x%llx Size %u\n"
+ "laccData_dumping"
+ "laccImgAddr %p laccImgSize %zu"
+ "laccImgAddr %p laccImgSize %zu\n"
+ "laccIndiceAndScores=%p size=%lu"
+ "laccItcmBuf != nullptr"
+ "laccLevelSmoothHFFWithFaceMapCBv2"
+ "laccLevelSmoothHFFWithFaceMapCBv3"
+ "laccMatchDMA[5]=%d wma1StartAddrHi=0x%x wma1Size=%d"
+ "laccMatchDMA[6]=%d wma2StartAddrHi=0x%x wma2Size=%d"
+ "laccMatchDMA[7]=%d wma3StartAddrHi=0x%x wma3Size=%d"
+ "laccMatchInputBuf[nChannelId].inputBuf != nullptr"
+ "laccMatchInputBuf[nChannelId].inputBufSize >= (pBufferExtra->offset + bufSize)"
+ "laccMatchInputBuf[nChannelId].preDescritporBuf != nullptr"
+ "laccMatchInputBuf[pCmd->ch].inputBuf != nullptr"
+ "laccMatchRMA0StartAddrLow 0x%08x laccMatchRMA0StartAddrHigh 0x%08x"
+ "laccMatchRMA1StartAddrLow 0x%08x laccMatchRMA1StartAddrHigh 0x%08x"
+ "laccMatchWMA2StartAddrLow 0x%08x laccMatchWMA2StartAddrHigh 0x%08x"
+ "laccMode = 0x%x"
+ "laccRoDataBuf != nullptr"
+ "landmark\n"
+ "landmarksFromHeatMap"
+ "laneCount == 1"
+ "laneCount == 2"
+ "laneCount == 3"
+ "laneCount == 4"
+ "laneCount > 0 && laneCount <= CLPDP_MAX_FE_LANE"
+ "laneManagement.fld != 0"
+ "lastAcceptableBin2 == lastAcceptableBin"
+ "lastLaccProgramId = 0x%zx pReq->itcmId 0x%x SwReset for new LACC-match"
+ "lastLaccProgramId = 0x%zx pReq->itcmId 0x%x resume with adjusted SourceGo 0x%08x"
+ "latestFrame != 0"
+ "layer %u stride %u w %u h %u"
+ "leaved TASK = %lu\n"
+ "leaving TASK = %lu %d\n"
+ "ledOffFaceAve %d preflashFaceAve %d uLEDOffLuxFace %.2f uPreflashLuxFace %.2f\n"
+ "ledType          = %d"
+ "ledoff ave %d eit %.3f lux %.2f preflash ave %d eit %f lux %.2f mainFlashLux %.2f\n"
+ "leftBound %u rightBound %u"
+ "leftShift >= 0"
+ "len < sizeof(string)"
+ "length < MAX_WRITE_LENGTH"
+ "length <= MAX_numberOfCorrespondences"
+ "length > 0"
+ "lensPositionCount <= MAX_LENS_COUNT"
+ "level <= PROJ_CONTROL_END"
+ "level == 0"
+ "level > 0"
+ "level=0x%x"
+ "levels 0x%x\n"
+ "levels: 0x%08x. maxFlashlightCurrent: %d mA"
+ "lightSrcMaskBuffer"
+ "lightSrcMaskBuffer->Size() >= ((ROUND_UP(OutWidth, 64)) * OutHeight)"
+ "linLTC=%i, softGainGlobLUT=%i CB=%i\n"
+ "lineLengthIn != 0.0f"
+ "lineLengthOut != 0.0f"
+ "linear %d soft %d"
+ "linearEIT %.3f (%llu) should be smaller than %.3f x %.2f!"
+ "linearEIT <= (uint64_t)(EITKneeLuts[2*numEntries-1] * 1.01f)"
+ "linearGain <= UINT16_MAX"
+ "list == 0"
+ "listenerCnt < VISEG_LISTENER_MAX"
+ "listenerWorker"
+ "lists[j].dataShared"
+ "lists[j].startAddr"
+ "loPostInputBuf.data"
+ "load file failed"
+ "load projector controller failed.\n"
+ "loadBitPerfectData"
+ "loadExternalArgb = %d\n"
+ "loadInputAndRunNN"
+ "loadReplayInput"
+ "loadReplayMeta"
+ "localHist:Area=%ld, size=%d"
+ "localHistBlockSizeX.X %u"
+ "localHistStrideX.X %u"
+ "localSkyMaskDebug"
+ "localTnrRunableChannels < 3"
+ "local_x %.2f local_y %.2f"
+ "lock"
+ "lock != (FFWMUTEX) 0"
+ "lock != (FFWMUTEX)0"
+ "lock != nullptr"
+ "locked"
+ "log != 0"
+ "log2Max >= 0 && log2Max <= 7"
+ "logEntry"
+ "logRec!=0"
+ "logTot <= logDepth"
+ "longGain > 0"
+ "lossyLevel < MAX_LOSSY_LEVEL"
+ "lpMutex != (FFWMUTEX)0"
+ "lpQueueMutex != (FFWMUTEX)0"
+ "lpTriggerQueue != 0"
+ "lpXenSema != 0"
+ "lpdp"
+ "lsChImbalanceCorrConfig->channelR1.gridCountX == lsProfile->params.gridCountXFull"
+ "lsChImbalanceCorrConfig->channelR1.gridCountY == lsProfile->params.gridCountYFull"
+ "lsDataExpectedEntries == lsDataEntries"
+ "lsDataMaxEntries >= lsDataExpectedEntries"
+ "lsMem=%p lscTableFES=%p flashlscTableFES=%p cicChannelBayer=%p"
+ "lsMemSize=%zu lscTableFESSize=%zu flashlscTableFESSize=%zu mallocSize=%zu"
+ "lsc != 0"
+ "lscBuffer is null, bypass LSC in stats pipe\n"
+ "ltc1"
+ "ltc2"
+ "ltcEntries <= LTM_LTC_NUM_NODES"
+ "ltm hff lacc enable %u bVioOccupied %u"
+ "ltmBuffer->meta.totalEIT>0"
+ "ltmCore != 0"
+ "ltmDriverMetaData.curFATENumFaces <= 1"
+ "ltmDriverMetaData.isTileStatsRegionUpdated"
+ "ltmFlashAdjust %f\n"
+ "ltmSc = %.3f. gocSc = %.3f"
+ "lumShift <= 15"
+ "luma"
+ "luma = %f, SNR= %f, ransacInlierRadiusPx = %f"
+ "luma=%f, SNR=%f, ransacInlierRadiusPx=%f remainingScaleToRawSize=%f\n"
+ "lumaMap"
+ "luma[i] >= luma[i-1]"
+ "lumiBuf[i + 10] == 0x025D"
+ "lumiBuf[i + 12] == 0x025E"
+ "lumiBuf[i + 14] == 0x025F"
+ "lumiBuf[i + 2] == 0x0259"
+ "lumiBuf[i + 2] == 0x02A5"
+ "lumiBuf[i + 2] == 0x02C9"
+ "lumiBuf[i + 2] == 0x02CB"
+ "lumiBuf[i + 2] == 0x05B3"
+ "lumiBuf[i + 4] == 0x025A"
+ "lumiBuf[i + 6] == 0x025B"
+ "lumiBuf[i + 8] == 0x025C"
+ "lumiOutEnableDelayInFrames > 0"
+ "luminanceRatio   = %d"
+ "luminanceTable[%2d] = %4d %4d %4d"
+ "lutIn.tblSize == kLutMemSize"
+ "lutX:%d iWidth=%d i=%d patch.value=%x"
+ "lutX:%d widthDma=%d i=%d patch.value=%x"
+ "lutY:%d heightDma=%d i=%d patch.value=%x"
+ "lutY:%d iHeight=%d i=%d patch.value=%x"
+ "lutsBuffer != nullptr"
+ "lux %f, gain %f\n"
+ "lux = %hu -> %.0f w=%.2f gray(gw|awb)= %.2f %.2f nonIR=%.2f %.2f "
+ "lux=%.2f %.2f luxRatio=%.2f weight=%.2f"
+ "lux=%.2f luxFactor=%.2f ccm=%.2f %.2f %.2f"
+ "lux=%5hu dist=%5.2f mix=%6.4f fdTimes=%hu skinWP=%5.2f %5.2f mixedWP=%5.2f %5.2f \n"
+ "lux=%6hu => %6.4f wpDist=%6.4f => %6.4f fdMixWeight=%6.4f => %6.4f"
+ "lux=%hu -> %.0f param->lux=%hu %hu weight=%.2f "
+ "lux=%hu weight=%.2f dayScore=%.2f, dayWeight=%.2f coef=%d %.2f"
+ "luxExposure %f gain %f\n"
+ "luxLevel %f, low %d, high %d"
+ "lvds_correction=0x%08X"
+ "m3CmdDoneSema != 0"
+ "m3CmdDoneSemaI2C != 0"
+ "m3CmdDoneSemaLPDP != 0"
+ "m3CmdDoneSemaMIPI != 0"
+ "m3CmdDoneSemaSPMI != 0"
+ "m3CmdDoneSemaSensor != 0"
+ "m3CmdDoneSemaSys != 0"
+ "m3CmdDoneSemaVCRouter != 0"
+ "m3GdcHdr != nullptr"
+ "m3GdcHdr->radscale != 0"
+ "m3GdcHdrArray != NULL"
+ "m3GdcTbl != NULL"
+ "m3GdcTbl != nullptr"
+ "mAbortSema != (SEMA)0"
+ "mActiveBank %x NextBk %x missedarm %d mAsrc:%d fep:%d"
+ "mBufCnt <= SYNCED_BUF_TOT"
+ "mBufCnt == SYNCED_BUF_TOT"
+ "mBuffRef.buffers <= FFWMSG_REF_MAX"
+ "mCmdMutex != (FFWMUTEX)0"
+ "mCrtTransform != 0"
+ "mCurTaskTime !=0"
+ "mEventLoggerBase != 0"
+ "mEventLoggerCnt < mMaxEventLoggers"
+ "mEventLoggerList"
+ "mEventLoggerList[i]"
+ "mEventLoggerList[userId] != NULL"
+ "mEventLoggerMemOffset<(EVENT_LOGGER_MEM_SIZE-EVENT_LOGGER_DUMP_BUF_LEN)"
+ "mEventLoggerMemOffset<EVENT_LOGGER_MEM_SIZE"
+ "mExpoChange >= 0"
+ "mFlowAckSema != (SEMA)0"
+ "mICState == IC_STOPPING"
+ "mInfo.ctx.processId >= 0"
+ "mInfo.ctx.programId >= 0"
+ "mInfo[%d].inSize %lu mInfo[%d].outSize %lu"
+ "mInfo[0].desc.procedures[0].numIoBuffers < maxAneIpcBufMsg"
+ "mInfo[4].desc.procedures[0].numIoBuffers < maxAneIpcBufMsg"
+ "mInlierIndices != 0"
+ "mIsInitialized"
+ "mLastDoneChId < inchannels"
+ "mMax <= 1.f"
+ "mMax >= 0.f"
+ "mMax=%.f"
+ "mMin <= 1.f"
+ "mMin >= 0.f"
+ "mMin=%.f"
+ "mMutex != (FFWMUTEX)0"
+ "mNumBlobs <= cMaxBlobs"
+ "mParam->mainClk > 0"
+ "mPeakTaskTime !=0"
+ "mPointVecX != 0"
+ "mRandIndices != 0"
+ "mResidualVec != 0"
+ "mSd >= 0.f"
+ "mSd=%.f"
+ "mSortedIndices != 0"
+ "mStartStopRequest.channel < cMaxChannel"
+ "mStatId %d Release srcDMAIndex %d"
+ "mStatId = %d bank %d"
+ "mStatId >= 0"
+ "mState == EVENT_LOGGER_STATE_INIT"
+ "mSyncEventSema != (SEMA)0"
+ "mTmpInlierIndices != 0"
+ "mTmpTransform != 0"
+ "mUpdate->splitPDOn == false"
+ "mUpdateSource->splitPDOn == false"
+ "m_CCTMinLimit < m_CCTMaxLimit"
+ "m_M3mutex != (FFWMUTEX)0"
+ "m_SensorTuningMutex != (FFWMUTEX)0"
+ "m_afMultiStepTimer"
+ "m_afaDrv != nullptr"
+ "m_apCmd.AP_CMD_b.app_patch_ind == CS40L62_MODE00_MSM_AP_CMD_APP_PATCH_IND_INCOMING_PATCH"
+ "m_apCmd.AP_CMD_b.os_patch_ind == CS40L62_MODE00_MSM_AP_CMD_OS_PATCH_IND_INCOMING_PATCH"
+ "m_apsCalData.APS_Lin_C1"
+ "m_apsCalData.oisz.delta_z_c1"
+ "m_apsCalData.useHyrbidZForFeedback"
+ "m_apsCalData.vcm_sensitivity != 0"
+ "m_apsEndStopCal_OL.stepDirection != 0"
+ "m_bgContext.actionType != LC_BACKGROUND_ACTION_IDLE"
+ "m_calibManager != nullptr"
+ "m_calibMutex != (FFWMUTEX)0"
+ "m_calibType != CALIB_MNGR_CALIB_TYPE_TOT"
+ "m_cfg.netInputMinValue < m_cfg.netInputMaxValue"
+ "m_channelClient[ch] == eLCChannelClient::None"
+ "m_channelState[ch] != eLCChannelState::Stopped && m_channelState[ch] != eLCChannelState::Started && m_channelState[ch] != eLCChannelState::Stopping"
+ "m_channelState[pCmd->ch] == eLCChannelState::Stopped"
+ "m_cmdMutex != (FFWMUTEX)0"
+ "m_currSetting"
+ "m_currentMode.dsp_ctrl != CS40L61_DSP_CTRL_OL_MODE"
+ "m_currentMode.dsp_ctrl != CS40L62_DSP_CTRL_OL_MODE"
+ "m_currentMode.dsp_ctrl != m_nextMode.dsp_ctrl"
+ "m_dataBuffFifoMutex != (FFWMUTEX) nullptr"
+ "m_dataReadySema != (SEMA)0"
+ "m_dataReadySema != NULLSEMA"
+ "m_depthBufferMutex != (FFWMUTEX)0"
+ "m_distData[chDst]"
+ "m_distData[chSrc]"
+ "m_distData[tmpCh]"
+ "m_enableTimerUpdate          = %u\n"
+ "m_errSema != 0"
+ "m_events_per_slot[i] != 0"
+ "m_executingFlow != nullptr"
+ "m_executingFlow == nullptr"
+ "m_expectedCountMax           = %u\n"
+ "m_fNumber != 0.0"
+ "m_faultSema != 0"
+ "m_fidFlowType == FID_AUTHENTICATION || m_fidFlowType == FID_AUTHENTICATION_W_COACHING"
+ "m_fieldCurvatureCalDistanceInf_mm != 0.0f"
+ "m_fieldCurvatureCalDistanceMacro_mm != 0.0f"
+ "m_firstMotionSampleProcessed = %u\n"
+ "m_flowPools[PDE_FLOW_SPD_SCALE] != nullptr"
+ "m_flowPools[flowType]->Size() == 0"
+ "m_flowsCapacity != 0"
+ "m_focusDev != nullptr"
+ "m_gmcRPCRunResults != nullptr"
+ "m_gmcTimeoutTimer != __null"
+ "m_gravityOptRecenter == nullptr"
+ "m_gravityOptRecenter->IsGravityOptimizationValid()"
+ "m_hFSMFocus"
+ "m_i2cPeriodicSyncSema"
+ "m_i2cState.nackCount < LC_NACK_COUNT_MAX"
+ "m_i2cState.readPeriod_us != 0"
+ "m_inputData0.inputExtra == nullptr"
+ "m_inputData0.inputsBuffers[i] == nullptr"
+ "m_inputData1.inputExtra == nullptr"
+ "m_inputData1.inputsBuffers[i] == nullptr"
+ "m_inputFrame->inputsBuffers[(1)] != nullptr"
+ "m_instabiltyType == LC_FLT_UNSTABLE_DETECT_TYPE_AF"
+ "m_instabiltyType == LC_FLT_UNSTABLE_DETECT_TYPE_OIS"
+ "m_internalGMSBuffer == nullptr"
+ "m_irMetadata"
+ "m_irMetadata != nullptr"
+ "m_irMetadata->previewMasterFOVInRaw.x >= 0"
+ "m_irMetadata->previewMasterFOVInRaw.y >= 0"
+ "m_isActive == true"
+ "m_isDualDevice ? true : (pGroupParams->dev == CS40L61_DEVICE_PRIMARY)"
+ "m_isFakeMotionDataGenerated  = %u\n"
+ "m_isrHandleId != 0"
+ "m_lastMotionSample_clk       = %llu\n"
+ "m_lensControllerTimer"
+ "m_lensControllerTimer != nullptr"
+ "m_lensDst"
+ "m_lensDst->GetPixelSize_mm() != 0.0f"
+ "m_lensSrc"
+ "m_lensSrc->GetPixelSize_mm() != 0.0f"
+ "m_listMutex != (FFWMUTEX)0"
+ "m_lpdpSema[ch] != 0"
+ "m_memAllocator->IsAllocated() == false"
+ "m_micronsPerPixel != 0.0"
+ "m_mode01WriteBufferSize <= CS40L61_MODE01_W_MAX_SIZE"
+ "m_mode01WriteBufferSize <= CS40L62_MODE01_W_MAX_SIZE"
+ "m_mode01WriteData.af_gain_data_active_t.af_sz_to_pos_gain != 0"
+ "m_motionDataLogRate < AOP_MOTION_RATE_COUNT"
+ "m_motionSampleLatency_clk    = %llu\n"
+ "m_mutex != (FFWMUTEX)0"
+ "m_mutexStatic != (FFWMUTEX)0"
+ "m_nRegisteredPairs < DISDRV_MAX_PAIRS"
+ "m_nackSema != 0"
+ "m_nextChunkOffset <= m_totalBytes"
+ "m_nextMode.DSP_CTRL_b.all_mode_math_en == CS40L61_MODE00_MSM_DSP_CTRL_ALL_MODE_MATH_EN_ENABLED"
+ "m_nextMode.DSP_CTRL_b.all_mode_math_en == CS40L62_MODE00_MSM_DSP_CTRL_ALL_MODE_MATH_EN_ENABLED"
+ "m_nextMode.dsp_ctrl == (m_nextMode_AF.dsp_ctrl | m_nextMode_OIS.dsp_ctrl)"
+ "m_outputConfigs.configs[CPCE_OUTPUT_BUFFER_TYPE_DEPTH].enabled"
+ "m_outputConfigs.configs[CPCE_OUTPUT_BUFFER_TYPE_DEPTH].enabled == true"
+ "m_outputConfigs.configs[CPCE_OUTPUT_BUFFER_TYPE_DX].enabled == true"
+ "m_outputConfigs.configs[CPCE_OUTPUT_BUFFER_TYPE_DY].enabled == true"
+ "m_outputConfigs.configs[CPCE_OUTPUT_BUFFER_TYPE_NORMDX].enabled"
+ "m_outputConfigs.configs[CPCE_OUTPUT_BUFFER_TYPE_NORMDX].enabled == true"
+ "m_outputDepthBuffer == nullptr"
+ "m_outputDxBuffer == nullptr"
+ "m_outputDyBuffer == nullptr"
+ "m_outputGMSBuffer == nullptr"
+ "m_outputNormDx2Buffer == nullptr"
+ "m_outputNormDxBuffer == nullptr"
+ "m_outputResources.outputPipes[CPCE_OUTPUT_DEST_DEPTH_PROC_SLAF] != nullptr"
+ "m_outputResources.outputPipes[CPCE_OUTPUT_DEST_FRAME] != nullptr"
+ "m_outputResources.outputPipes[CPCE_OUTPUT_DEST_IMAGE_CAPTURE] != nullptr"
+ "m_outputResources.outputPipes[CPCE_OUTPUT_DEST_MLAF] != nullptr"
+ "m_outputResources.outputPipes[CPCE_OUTPUT_DEST_MOTION_ESTIMATOR_SLAF] != nullptr"
+ "m_outputResources.outputPipes[CPCE_OUTPUT_DEST_PDAF] != nullptr"
+ "m_outputResources.outputPools[CPCE_OUTPUT_BUFFER_TYPE_DEPTH] != nullptr"
+ "m_outputResources.outputPools[CPCE_OUTPUT_BUFFER_TYPE_DX] != nullptr"
+ "m_outputResources.outputPools[CPCE_OUTPUT_BUFFER_TYPE_DY] != nullptr"
+ "m_outputResources.outputPools[CPCE_OUTPUT_BUFFER_TYPE_GC] != nullptr"
+ "m_outputResources.outputPools[CPCE_OUTPUT_BUFFER_TYPE_GMS_INTERNAL] != nullptr"
+ "m_outputResources.outputPools[CPCE_OUTPUT_BUFFER_TYPE_NORMDX2] != nullptr"
+ "m_outputResources.outputPools[CPCE_OUTPUT_BUFFER_TYPE_NORMDX] != nullptr"
+ "m_outputResources.outputPools[CPCE_OUTPUT_BUFFER_TYPE_OUT_OF_BOUNDS_META] != nullptr"
+ "m_outputResources.outputPools[CPCE_OUTPUT_BUFFER_TYPE_SLAF_DEPTH] != nullptr"
+ "m_outputResources.outputPools[CPCE_OUTPUT_BUFFER_TYPE_SPLITPD_DX] != nullptr"
+ "m_outputResources.outputPools[CPCE_OUTPUT_BUFFER_TYPE_SPLITPD_SCALED_LUMA] != nullptr"
+ "m_outputResources.outputPools[CPCE_OUTPUT_BUFFER_TYPE_SPLITPD_SCORE] != nullptr"
+ "m_outputScaledLeftBuffer == nullptr"
+ "m_outputScaledRightBuffer == nullptr"
+ "m_outputScoreBuffer == nullptr"
+ "m_outputSlafBuffer == nullptr"
+ "m_pAopRingBuffer == nullptr"
+ "m_pAuxToLcPipe"
+ "m_pExtrinsicNodes[channelDst] != nullptr"
+ "m_pExtrinsicNodes[channelDst][channelSrc] == nullptr"
+ "m_pExtrinsicNodes[channelMid] != nullptr"
+ "m_pExtrinsicNodes[channelMid][channelDst] != nullptr"
+ "m_pExtrinsicNodes[channelSrc] != nullptr"
+ "m_pExtrinsicNodes[channelSrc][channelDst] == nullptr"
+ "m_pExtrinsicNodes[channelSrc][channelMid] != nullptr"
+ "m_pFakeDrv[pCmd->ch] == nullptr"
+ "m_pFaultManager"
+ "m_pLCDrv[pCmd->ch] == nullptr"
+ "m_pLcToAuxPipe"
+ "m_pLux2KnobTable != 0"
+ "m_pLux2KnobTable->entry.kNumEntries > 0"
+ "m_pMotion"
+ "m_pMotion != nullptr"
+ "m_pMotionDataRing"
+ "m_pMotionDataRing->GetSize() != 0"
+ "m_pNVM"
+ "m_pQPool"
+ "m_pSampleCh[ch]"
+ "m_pSampleCh[i]"
+ "m_pSettings"
+ "m_pTempSensor[CS40L62_SENSOR_1]"
+ "m_pTempSensor[CS40L62_SENSOR_2]"
+ "m_partialFlowLists[flowType]->Size() == 0"
+ "m_partialFlowTimeoutTimer != NULL"
+ "m_partialFlowTimeoutTimer != __null"
+ "m_partialFlowTimerSetCount > 0"
+ "m_pearlCalib != nullptr"
+ "m_pixelSize_mm != 0.0f"
+ "m_pixelSize_um != 0"
+ "m_pnaProcessedBrightness != 0"
+ "m_posReqPool"
+ "m_puaPrevBrightness != 0"
+ "m_queueMutex != (FFWMUTEX)0"
+ "m_quitSema != 0"
+ "m_radialModelWorkshop != 0"
+ "m_radialPositionPixels"
+ "m_readyFlowQueue->Size() == 0"
+ "m_rearCalibTW != nullptr"
+ "m_rearCalibWSW != nullptr"
+ "m_rearStereoFlowType == PDE_FLOW_REAR_STEREO_1_PASS || m_rearStereoFlowType == PDE_FLOW_REAR_STEREO_3_PASS"
+ "m_recorder.cachedSamples"
+ "m_recorder.cachedSamples == nullptr"
+ "m_ref != nullptr"
+ "m_registeredBuffPool == nullptr"
+ "m_reqSema != 0"
+ "m_requestListMutex != (FFWMUTEX)0"
+ "m_respSema != 0"
+ "m_semaphoreChannel[i][j] != NULLSEMA"
+ "m_semaphoreShared[i] != NULLSEMA"
+ "m_sensorFabID == IMX_FAB_ID_NGK || m_sensorFabID == IMX_FAB_ID_YGT"
+ "m_sharedMemAllocator->IsAllocated()"
+ "m_signHx[0] != 0 && m_signHx[1] != 0"
+ "m_smbTaskId != 0"
+ "m_spmi"
+ "m_spmiTaskId != 0"
+ "m_stFlickerWindowData->naNumFlickerWin != 0"
+ "m_stLSCropped != nullptr"
+ "m_stLSCropped && m_stLSCropped->configIndex != CIMAGESENSOR_CONFIG_INVALID"
+ "m_stLSCropped->configIndex == pMetaData->configIndex"
+ "m_stReceivedMsg[CAF_INPUT_0].ref[0] != 0"
+ "m_stReceivedMsg[CAF_INPUT_0].ref[1] != 0"
+ "m_state != CPCEFLOW_STATE_EXECUTING"
+ "m_state != CPCEFLOW_STATE_UNINITIALIZED"
+ "m_state != CPCEFLOW_STATE_UNINITIALIZED && m_state != CPCEFLOW_STATE_DATA_SET_PARTIAL && m_state != CPCEFLOW_STATE_DATA_SET"
+ "m_state == CPCEFLOW_STATE_DATA_SET"
+ "m_state == CPCEFLOW_STATE_EXECUTING"
+ "m_state == CPCEFLOW_STATE_INITIALIZED || m_state == CPCEFLOW_STATE_DONE_INTERMITTENT"
+ "m_state == CPCEFLOW_STATE_READY_FOR_EXECUTE"
+ "m_state.channelsState[i] == CPCEFLOWMANAGER_CHANNEL_STATE_STOPPED"
+ "m_state.pendingTasks[CPCEFLOWMANAGER_TASK_NON_SECURE_MODE_REQ] == false"
+ "m_state.pendingTasks[CPCEFLOWMANAGER_TASK_SECURE_MODE_REQ] == false"
+ "m_state.pendingTasks[CPCEFLOWMANAGER_TASK_WAIT_FOR_FID_GMC] == false"
+ "m_state.pendingTasks[CPCEFLOWMANAGER_TASK_WAIT_FOR_FID_GMC] == true"
+ "m_state.pendingTasks[i] == false"
+ "m_state.state != CPCEFLOWMANAGER_STATE_SECURE_MODE"
+ "m_state.state != CPCEFLOWMANAGER_STATE_SUSPENDED && m_state.state != CPCEFLOWMANAGER_STATE_SUSPENDED_PARTIAL"
+ "m_state.state != CPCEFLOWMANAGER_STATE_SUSPENDED_PARTIAL && m_state.state != CPCEFLOWMANAGER_STATE_SECURE_MODE"
+ "m_state.state == CPCEFLOWMANAGER_STATE_FLOW_EXECUTING"
+ "m_state.state == CPCEFLOWMANAGER_STATE_READY || m_state.state == CPCEFLOWMANAGER_STATE_SUSPENDED_PARTIAL"
+ "m_state.state == CPCEFLOWMANAGER_STATE_SECURE_MODE"
+ "m_state.state == CPCEFLOWMANAGER_STATE_SUSPENDED"
+ "m_staticDefectsTable"
+ "m_supportedChannels & ((1 << inputChannel))"
+ "m_supportedFlows[PDE_FLOW_FRONT_STEREO] == true"
+ "m_supportedFlows[PDE_FLOW_PEARL] == true"
+ "m_supportedFlows[PDE_FLOW_SPD_DISPARITY] == true"
+ "m_supportedFlows[PDE_FLOW_SPD_SCALE] == true"
+ "m_supportedFlows[flowType] == true"
+ "m_syncReqWaitSema != 0"
+ "m_taskSema != 0"
+ "m_transitionPool"
+ "m_txModeConfig.version == CISP_PERIDOT_JSON_SCHEMA_VERSION"
+ "m_uTargetBrMainFlash old %d new %d m_uMainFlashLux old %f new %f\n"
+ "m_useCaseFactories[PDE_USE_CASE_PEARL] != nullptr"
+ "m_useCaseFactories[i] != nullptr"
+ "m_useCaseFactories[useCase] != nullptr"
+ "m_vcmCalCoeffs.focus_dac_per_ma != 0"
+ "m_waitSema != 0"
+ "m_warnSema != 0"
+ "m_xenSema != 0"
+ "m_xyToB1B2Denom != 0"
+ "makeTemporalDecision"
+ "manualContextSettings.pulseWidth <= (hFlood->GetCalPulseWidth() + PW_TOLERANCE)"
+ "map 32bits address!"
+ "map1Width height, ResMapW, ResMapH (%d %d %d %d)\n"
+ "mapIPCBuffer"
+ "mapRawTileRect"
+ "mapped IPC buf address read %p write %p"
+ "mappedLen(%d) == len(%d)\n"
+ "mapping tables share the max actionNbr: actionNbr=%d, resultId=%d"
+ "mapping->SDPOut[type] != SB_DATA_DST_NONE"
+ "mapping->SDPOut[type] != SB_DATA_DST_NONE && pList && num"
+ "mark %u %u vs %u"
+ "mask != 0"
+ "mask %u disabled"
+ "mask %u disabled!"
+ "maskConfigs[mask].type == mask"
+ "maskCount[aispSource] > 0"
+ "maskCount[i] == 0"
+ "maskCount[source] > 0"
+ "maskOffset %d maskSize %d"
+ "mask_xtalkHist"
+ "master FV signal takes %f s"
+ "master ch=%d::fdAWB        : fdAWBOutput=%d "
+ "master ch=%d::interMeta    : lux=%d rgLogRatio=%.2f bgLogRatio=%.2f "
+ "master ch=%d::photometerAWB: daylight=%.2f lightstable=%.2f suddenchange=%.2f"
+ "masterCh %u firstWBGain %u %u %u cct %u rgG %u bgG %u"
+ "masterCh %zu waitForSlave %d chSlaveWaitMask 0x%x multi %d chBitMask 0x%x"
+ "masterHostMetaBuffer"
+ "masterScanTime > slaveScanTime"
+ "matchAlltoAll = 0x%x"
+ "matchedKeypointByteOffset = %d"
+ "matchedKeypointCount = %d"
+ "matchedKeypointVersion = %d"
+ "matchedTrackIndicesLen >= numDetObjects"
+ "matches buffer too small!"
+ "matching pairs = %d"
+ "matchingFlow->CalculateInitializationState() == CPCEFLOW_STATE_DATA_SET"
+ "matrixAFScores != 0"
+ "matrixAFScoresPerFilter.bayerY_15x3_bpf_f0 != 0"
+ "matrixAFScoresPerFilter.bayerY_15x3_bpf_f0_maxloc != 0"
+ "matrixAFScoresPerFilter.bayerY_15x3_bpf_f0_maxval != 0"
+ "matrixAFScoresPerFilter.bayerY_15x3_bpf_f1 != 0"
+ "matrixAFScoresPerFilter.bayerY_15x3_bpf_f1_maxloc != 0"
+ "matrixAFScoresPerFilter.bayerY_15x3_bpf_f1_maxval != 0"
+ "matrixAFScoresPerFilter.bayerY_3x3_f0 != 0"
+ "matrixAFScoresPerFilter.bayerY_3x3_f1 != 0"
+ "matrixAFScoresPerFilter.bayerY_hiir_f0 != 0"
+ "matrixAFScoresPerFilter.bayerY_viir_f0 != 0"
+ "matrixAFScoresPerFilter.rawB_7x1_hfir != 0"
+ "matrixAFScoresPerFilter.rawGb_7x1_hfir != 0"
+ "matrixAFScoresPerFilter.rawGr_7x1_hfir != 0"
+ "matrixAFScoresPerFilter.rawR_7x1_hfir != 0"
+ "max != 0"
+ "max sensor crop %d %d"
+ "maxAGC <= maxHighAGC"
+ "maxCeil != NULL"
+ "maxChartPFL=%f"
+ "maxChartPFL=%f vs %f"
+ "maxCmdBufSize >= sizeof(*pMsg) + pCmdHdr->size"
+ "maxData > limitData + 1 + 10"
+ "maxDataDepth > limitData + 1 + 10"
+ "maxDmaAddr=%zx the DMA address is exceeding max address"
+ "maxElements = 0x%x"
+ "maxExp adjusted by cit loss %d to %d"
+ "maxExpForADRC2 %llu, adrc2 ratio reduced to %f"
+ "maxExpPrimary adjusted by flicker %u resRatio %f res %u ExpTol %f"
+ "maxExpSifr %u citLossfullbin[cfg=%u]=%u"
+ "maxExposurePrimary > contextSwitchCITLossComputed"
+ "maxExposureSifr > eitParams[nSensorConfig].citLossSifrFullBin"
+ "maxExposureSifr=%u > citLossSifrFullBin=%u (maxExpBlank=%u virtFrmWidth=%u)"
+ "maxExposureSlave > citReduction"
+ "maxFlashOffLux %f minFlashOffLux  %f flatWeight %f\n"
+ "maxFlight %dmA, current %dmA, ledReg 0x%x\n"
+ "maxFrameTime > 0"
+ "maxLantencyF > 0"
+ "maxLinearGain = MIN((%d / %d), %d) ==> %d"
+ "maxLinearGain >= AE_GAIN_IDENTITY"
+ "maxMainFlashDur %.3f maxExposureDur %.3f ms %.3f minGap %.2f"
+ "maxMatches >= size"
+ "maxNumActiveSlaveCams < totalChInGroup"
+ "maxNumActiveTimeMachine > 0"
+ "maxNumSets = 0x%x"
+ "maxPreflashCurrent_mAmps: 0x%x = %d mA, maxPreflashCurrentRatio: 0x%x = %d%%"
+ "maxR final value: %f"
+ "maxR initial value: %f"
+ "maxRadius > 0"
+ "maxRadius=%f"
+ "maxRadius=%f vs %f"
+ "maxRadiusDiff > minRadiusDiff"
+ "maxSifrCIT %d, minRD %d, vWSec %d ==> maxExpSifr %d"
+ "maxSifrCIT(noConvert) %d, maxHeight %d, primaryUnadj %llu"
+ "maxSifrExposureSlave > contextSwitchCITLossComputed"
+ "maxSifrExposureSlave > eitParams[nSensorConfig].citLossSifrFullBin"
+ "maxSizeCfg != CIMAGESENSOR_CONFIG_INVALID"
+ "maxSize_ == 0 || totSize_ <= maxSize_"
+ "maxSoftDGain >= AE_GAIN_IDENTITY"
+ "maxStrobeCurrent=%d mainStrobeCurrent=%d cStr=0x%04x"
+ "maxTorchCurrent_mAmps: 0x%x = %d mA, maxTorchCurrentRatio: 0x%x = %d%%"
+ "maxTorchCurrent_mAmps: 0x%x = %d mA, maxTorchCurrentRatio: 0x%x = %d%%, torchTableMax: (per driver) %d mA"
+ "maxV %d vW %d citLoss %d sifrRatio %f"
+ "maxVirtFrmHeight > 0"
+ "maxZoom->maxFESZoomX == ZOOM_FACTOR_FIXED_POINT_IDENTITY || maxZoom->maxPYRZoomX == ZOOM_FACTOR_FIXED_POINT_IDENTITY"
+ "maxZoom->maxFESZoomY == ZOOM_FACTOR_FIXED_POINT_IDENTITY || maxZoom->maxPYRZoomY == ZOOM_FACTOR_FIXED_POINT_IDENTITY"
+ "max[i] < 65536"
+ "max_cBFcc != 0"
+ "max_cBFy != 0"
+ "maxchannels != 0"
+ "maxmbox > 0"
+ "maxqueue > 1"
+ "maxres > 0"
+ "maxsema > 0"
+ "maxsig > 0"
+ "maxtask > 1"
+ "maxtimers > 0"
+ "mbSyncOutputEnabled"
+ "mboxPool != 0"
+ "mboxPool == 0"
+ "meanRGB[%i]=%f"
+ "meanRGB[i] >= 0.f"
+ "meanRef"
+ "memory != 0"
+ "memory access done, memory returned."
+ "memory access start"
+ "mesh size, gridSizeX = %d, gridSizeY = %d"
+ "mesh tFormNormal: %d"
+ "message != 0"
+ "message != NULL"
+ "messagePhys < 1UL << 36"
+ "messages > 0"
+ "meta data size too large"
+ "meta data size too small"
+ "meta.frmNo != INVALID_FRAME_COUNT"
+ "meta.hRef == ctx.pBufs[2]"
+ "meta.pEr"
+ "meta.pFd"
+ "meta.pInput"
+ "meta.pMetaData"
+ "meta.pMetaData->ae.strobePattern != STROBE_REGULAR"
+ "meta.sRef == ctx.pBufs[1]"
+ "metaBuf"
+ "metaData.binH == 0"
+ "metaData.binW == 0"
+ "metaDataParam != 0"
+ "metaDataParam[CISP_META_DATA_INPUT].enabled"
+ "metaDataParam[CISP_META_DATA_OUTPUT].enabled"
+ "metaDataParam[i].size > 0"
+ "metaDataSectEn=%d isReprocessing=%d ctrlModeLTMLTC=%d ctrlModeLTMDynamicLTC=%d ctrlModeLTMSCCM=%d ctrlModeLTMGTC=%d"
+ "metaIn camera center %f %f"
+ "metaIn.digitalZoomFactor is %f\n"
+ "metaInfo->besOutValidRect.height % 2 == 0"
+ "metaInfo->besOutValidRect.width % 2 == 0"
+ "metaInfo->besOutValidRect.x % 2 == 0"
+ "metaInfo->besOutValidRect.y % 2 == 0"
+ "metaInfo->horzBin <= 1"
+ "metaInfo->numPass == 1"
+ "metaInfo->vertBin <= 1"
+ "metaInfo: besIn W %d H %d besOut W %d H %d\n"
+ "metaInfo: besInRect cropX %d crop Y %d cropW %d cropH %d\n"
+ "metaSize >= panstMeta->dbgDataOffset + panstDebug->totSize"
+ "metadata != nullptr"
+ "metadata->SIFRBinFactorFullBinMode != 0"
+ "metadata->distParams.gdcLutRd[i] >= 0"
+ "metadata->distParams.gdcLutRu[i] >= 0"
+ "metadata->distParams.partialGdcScale <= 1.0f"
+ "mgrIdx(%d) should be less than %d"
+ "mh st_sizex: %d, st_sizey: %d\n"
+ "micronsPerPixel != 0"
+ "microsecondPerHLine != 0"
+ "midInc should be 1: dmaId=%d"
+ "min < max"
+ "min <= max"
+ "minChartPFL=%f"
+ "minChartPFL=%f vs %f"
+ "minCol < costBuf.height"
+ "minDR %f minMainFlashDuration %f maxExposureDuration %f\n"
+ "minEIT > fineInt"
+ "minRow < costBuf.width"
+ "min_af_z_um <= max_af_z_um"
+ "misc offset=0x%x size=0x%x "
+ "mismatch %d vs. %d (Ref) at (%d %d)"
+ "ml.tiles[rId].tileCount.x <= (int32_t)(PDAF::MLAF_NTILES_PER_ROW)"
+ "ml.tiles[rId].tileCount.y == 1"
+ "ml.tiles[rId].tileSize.x == MLAF_PATCH_PIXEL_SIZE"
+ "ml.tiles[rId].tileSize.y == MLAF_PATCH_PIXEL_SIZE"
+ "mlaf: netId: %zu [%ld]: adr: %p sz: %zu ind: %u"
+ "mmu"
+ "mmuLoggerOn == true"
+ "mnStatus == 0x0A"
+ "modFaceDown"
+ "modFaceUp"
+ "mode != ISP_STAT_USAGE_MODE_INVALID"
+ "mode < LC_APS_MODE_TOT"
+ "mode < LC_OIS_MODE_TOT"
+ "mode < PDAF::PixelEngine::AFE_VERTICAL_MODE_COUNT"
+ "mode == LC_OIS_MODE_MOTION_STABILIZATION || mode == LC_OIS_MODE_DEGRADED_MOTION_STABILIZATION"
+ "mode->metadataCfg.version == CISP_PERIDOT_MODE_CONFIG_VERSION"
+ "mode: %d, cct: %d, reg: 0x%x, tot: %6.2f cool:%d warm: %d"
+ "mode: %d, reg: 0x%x"
+ "mode: 0x%x, param: 0x%04X"
+ "modeCfgOverride != NULL"
+ "modeConfigCacheIndex <= configTot"
+ "model %d en %d"
+ "model[%d] bufsize [%zu %zu %zu]"
+ "model[%u] procedure num %u"
+ "model[%u] procedure[%u] buf cnt %u"
+ "modulated ramping table: idx%zu = ramV %06x"
+ "modulationTable->numEntries <= LSC_MAX_MODULATION_TABLE_ENTRIES"
+ "modulationTable->numEntries >= 2"
+ "moduleInfo"
+ "motBlurDetect"
+ "motion exceed limit"
+ "motionCount %d rawSampleNbrVISIn %d\n"
+ "motionCount %d rawSampleNbrWr %d rawSampleNbrRd %d\n"
+ "motionDataGetResSignal != (SEMA )0"
+ "motionDataRateWrite != NULL"
+ "motionDataSetResSignal != (SEMA )0"
+ "motionDetection"
+ "motionDetectionEnable"
+ "motionGlobalDampeningStrength=%f"
+ "motionHostMeta != nullptr"
+ "motionLocalDampeningStrength=%f"
+ "motionLocalDampeningStrength=%f, skinWBGainBlendingFactor=%f"
+ "motionOffset %f\n"
+ "motionRateRead != NULL"
+ "mpAllIncomingList - preview frames=%ld, still frames=%ld"
+ "mpCSSenseFusion"
+ "mpInstance"
+ "mpInstance == __null"
+ "mpOriginalHwTunables != 0"
+ "mpOriginalHwTunables[bankId].count < mMaxTunableCnt"
+ "mpSREventLogger"
+ "mpSignalSemas"
+ "mpSignalSemas[i] != (SEMA)0"
+ "mp_pceStageCamParamBuffer != nullptr"
+ "mp_pceStageLutsBuffer != nullptr"
+ "mppChInfo"
+ "msModeCurr == pMsInfo->msMode"
+ "msg.payload.buff.tot == GENERAL_PROCESS_OUTPUT_TOTAL + 3"
+ "msgLen > 0"
+ "msgPhys != 0"
+ "msgType < DOPPLER_MESSAGE_TYPE_TOT"
+ "msicStatSize is %zu"
+ "mth: ch %zu idx %d CSC2_OffsetIn %d CSC2_OffsetOut %d"
+ "mth: ch %zu idx %d csc1 %d invcsc1 %d, CCMCoef %d"
+ "mth: ch %zu idx %d csc2 %d CSCCoef %d"
+ "mth: ch %zu idx %d invCSC2_OffsetIn %d invCSC2_OffsetOut %d"
+ "mth: ch %zu idx %d invcsc2 %d"
+ "mth: ch %zu idx %d mthCsc2_Offset %d"
+ "mth: ch %zu idx %d mthInvCsc2_Offset %d"
+ "mth: ch %zu mthCscCCScaleCr=%d mthCscCCScaleCb=%d"
+ "mth: ch=%zu mthMiredLutIn[%d]= %.2f xToCCTLutEntry[%d].x = %d"
+ "mth: ch=%zu mthMiredLutIn[%d]= %u xToCCTLutEntry[%d].x = %d"
+ "mth: ch=%zu mthMiredLutOut[%d]= %.2f xToCCTLutEntry[%d].cct = %d"
+ "mth: ch=%zu mthMiredLutOut[%d]= %d xToCCTLutEntry[%d].cct = %d"
+ "mthDmaOutputAddr"
+ "mthOutputBuf"
+ "mthOutputCBuff"
+ "mthSceneMapStepX <= (576 << 8)"
+ "mthSceneMapStepX >= (1 << 8)"
+ "mthSceneMapStepY <= (512 << 8)"
+ "mthSceneMapStepY >= (1 << 8)"
+ "mthThumbStepX <= (576 << 8)"
+ "mthThumbStepX >= (8 << 8)"
+ "mthThumbStepY <= (576 << 8)"
+ "mthThumbStepY >= (8 << 8)"
+ "multiCamsSyncBitMask == 0"
+ "multiCamsSyncBitMask should be 0 but acutual value: 0x%x\n"
+ "multiStepStart"
+ "multipass pMpInfo->mpMode %u\n"
+ "mutex != (FFWMUTEX) 0"
+ "mutex != (FFWMUTEX) NULL"
+ "mutex != (FFWMUTEX)0"
+ "mutexCmpnDma != (FFWMUTEX)0"
+ "mutexCntl != (FFWMUTEX)0"
+ "mutexI2CEndPoint != (FFWMUTEX)0"
+ "mutexI2CRead != (FFWMUTEX)0"
+ "mutexI2CWrite != (FFWMUTEX)0"
+ "mutexIntSource != (FFWMUTEX)0"
+ "mutexMotionDataGet != (FFWMUTEX )0"
+ "mutexMotionDataSet != (FFWMUTEX)0"
+ "mutexMotionEndPoint != (FFWMUTEX)0"
+ "mutexPearlCmd != (FFWMUTEX)0"
+ "mutexPearlEndpoint != (FFWMUTEX)0"
+ "mutexPearlNotify != (FFWMUTEX)0"
+ "mutexPeridotSeq != (FFWMUTEX)0"
+ "mutexPoolBuf != (FFWMUTEX)0"
+ "mutexProjector != (FFWMUTEX)0"
+ "mutexResourceAlloc != (FFWMUTEX)0"
+ "mutexSifQ != (FFWMUTEX)0"
+ "mutexSrcDma != (FFWMUTEX)0"
+ "mutex[ch] != (FFWMUTEX)0"
+ "mutex[i] != (FFWMUTEX)0"
+ "mutex_ != (FFWMUTEX)0"
+ "mySMVmemcpy"
+ "mySemaArray[semaIndex] != (SEMA)0"
+ "n != 0"
+ "n <= maxLen"
+ "nChannelId %lu pipeId %lu\n"
+ "nChannelId < CVDDP_MAX_CH_NUMBER"
+ "nChannelId < chTot"
+ "nChannelId < numChls"
+ "nChannelId <= ISP_CAMERA_CHANNEL_TOT"
+ "nChannelId == 3"
+ "nChannelId == kERChlNumber"
+ "nChannelId == kFIDChlNumber"
+ "nChars <= overlayMsgSize"
+ "nChars=%d"
+ "nColorPoints     = %d"
+ "nLeft == 0"
+ "nLuminancePoints = %d"
+ "nPoints <= CP_MAX_LED_LUMA_POINTS"
+ "nPoints <= LM3566_MAX_LED_COLOR_POINTS"
+ "nPoints <= LM3566_MAX_LED_LUMA_POINTS"
+ "nPoints <= LM3567_MAX_LED_COLOR_POINTS"
+ "nPoints <= LM3567_MAX_LED_LUMA_POINTS"
+ "nSensorConfig != AE_SENSOR_CONFIG_INVALID"
+ "nSensorConfig < m_sensorConfigsTot"
+ "nackSema != 0"
+ "name != 0"
+ "name %s baseAddr 0x%p, irqSource_ %d"
+ "name %s frameDoneCount_[%d] %lld"
+ "name %s frameRequestCount_[%d] %lld"
+ "name %s isrHandle_ %d"
+ "nameLen <= maxNameLen"
+ "napCount == 0"
+ "nbrOfBuffer %d"
+ "nbrOfBuffer == GPISP_GC_PRIMITIVE_NCC_IO_BUFFER_ID_TOT"
+ "nbrOfBuffer == GPISP_GC_PRIMITIVE_PATCHWARP_IO_BUFFER_ID_TOT"
+ "nbrOfBuffer == GPISP_GC_PRIMITIVE_TAHITI_CVDALL_IO_BUFFER_ID_TOT"
+ "nbrOfBuffer == GPISP_GC_PRIMITIVE_TAHITI_DESGEN_IO_BUFFER_ID_TOT"
+ "nbrOfBuffer == GPISP_GC_PRIMITIVE_TAHITI_DESMATCH_IO_BUFFER_ID_TOT"
+ "nbrOfCmpn < ISPHWH17CMPNDMAIDX_TOT"
+ "nbrOfFDSection < CIspFDRegConfig::AHFD_MAX_ITEM"
+ "nbrOfRemapLeft == endPointCb[pCmd->endPointId].shareMem.nbrOfRemapItem"
+ "nbrOfSection"
+ "nbrOfSection > 0"
+ "nbrOfSetFileSet < MAXSETFILENBRFORLENSCHARACTER"
+ "nbrOfTotalCtxSwitch < MAX_CTXSWITCH_CONFIGS"
+ "ncc.accMode = %d"
+ "ncc.convOffsetIn = %d"
+ "ncc.convOffsetOut = %d"
+ "ncc.convOutScaleShift = 0x%x"
+ "ncc.filterEn = %d"
+ "ncc.hH = %d"
+ "ncc.hW = %d"
+ "ncc.hvarScaleShift = 0x%x"
+ "ncc.initX = %d"
+ "ncc.initY = %d"
+ "ncc.inputBitSelect = %d"
+ "ncc.inputDmaFmt = %d"
+ "ncc.isKernelSigned = %d"
+ "ncc.kernelDmaFmt = %d"
+ "ncc.kernelPatchModeEn = %d"
+ "ncc.nccEn = %d"
+ "ncc.normBypassBitShift = %d"
+ "ncc.normProcEn = %d"
+ "ncc.outHeight = %d"
+ "ncc.outWidth = %d"
+ "ncc.patchOutSize = %d"
+ "ncc.patchSize = %d"
+ "ncc.peakFinderMode = %d"
+ "ncc.procMode = %d"
+ "ncc.stepX = %d"
+ "ncc.stepY = %d"
+ "ncc.subBitShift = %d"
+ "ncc.subpixelEn = %d"
+ "ncc.varOffset = 0x%x"
+ "nccGoc.bypass = %d"
+ "nccGoc.height = %d"
+ "nccGoc.inputDmaFmt = %d"
+ "nccGoc.numComp = %d"
+ "nccGoc.width = %d"
+ "nccPipe.cacConfig = 0x%x"
+ "nccPipe.crcEn = %d"
+ "nccPipe.dpeMode = %d"
+ "nccPipe.dpeSrcFrame = 0x%x"
+ "nccPipe.height = %d"
+ "nccPipe.startEndCountEn = %d"
+ "nccPipe.width = %d"
+ "net %d type %d bufIdx %u current %d"
+ "net%u type%u buf%u dep %u"
+ "netBufsConfig[i].configs[j].bufCnt == tmpConfig.configs[j].bufCnt"
+ "netId < ANE_NET_TOT"
+ "netoutDiff"
+ "network"
+ "network=%zu, i=%zu"
+ "networkIdx < m_netCnt"
+ "new AgentCVDCombGP command starts"
+ "new AgentDesGenGP command starts"
+ "new AgentDesMatchGP command starts"
+ "new flags: 0x%x\n"
+ "new voltage for IRCAM DVDD: %d\n"
+ "new: awbGain = %u %u ccGain=%hu %hu combo=%u %u "
+ "new: ccm=%d %d %d; %d %d %d; %d %d %d"
+ "new: rgLogRatio=%f bgLogRatio=%f cct=%u "
+ "new: slaveCh%hhu masterCh=%hhu"
+ "new: slaveCh%hhu useSpatialCCM =%hhu isLEDMainFlashforAWB=%hhu"
+ "newCool=%7.1f mA, newWarm=%7.1f mA, coolTorchVal= 0x%04x, warmTorchVal= 0x%04x"
+ "newCool=%d mA, newWarm=%d mA, coolStrobeVal= 0x%02x, warmStrobeVal= 0x%02x"
+ "newCool=%d mA, newWarm=%d mA, coolTorchVal= 0x%02x, warmTorchVal= 0x%02x"
+ "newCount >= 1"
+ "newFESCropRect.height >= newFESOutHeight"
+ "newFESCropRect.width >= newFESOutWidth"
+ "newFESCropRect.x >= 0"
+ "newFESCropRect.y >= 0"
+ "newGrid.x == newGridUnclipped.x"
+ "newGrid.y == newGridUnclipped.y"
+ "newIn[i] >= newIn[i-1] - FLT_EPSILON"
+ "newNumTrkObjects < maxTrkObjects"
+ "newPYRCropRect.height >= newPYROutHeight"
+ "newPYRCropRect.width >= newPYROutWidth"
+ "newPYRCropRect.x >= 0"
+ "newPYRCropRect.y >= 0"
+ "newPreflashLEDC: 0x%x 0x%x"
+ "newPreflashLEDC: 0x%x 0x%x\n"
+ "newRoi"
+ "newSensorConfig != AE_SENSOR_CONFIG_INVALID"
+ "newSensorConfig != nSensorConfig"
+ "newTask != RTK_THREAD_NONE"
+ "newTorLEDC: %7.3f %7.3f mA"
+ "newTorLEDC: 0x%x 0x%x\n"
+ "newUpdateNum <= IC_UPDATEUNIT_MAX_AECOUNT"
+ "new_end > new_start"
+ "newrdptr <= pBuf->_header._size"
+ "next strobe PW: %d\n"
+ "nextChunk"
+ "nextEITUpdate.request != 0"
+ "nextLenXYServiceIndex + (maxHallDataSampleInPerFrame - 1) < latestIndex: Too much time past from previous Frame\n"
+ "nextMotionIndex %llu latestIndex %llu rawSampleNbrWr %d rawSampleNbrRd %d\n"
+ "nextTbcSequenceEntry != nullptr"
+ "nextTbcSequenceEntry->type == CISP_PERIDOT_SEQ_ENTRY_TYPE_MODE_CONFIG"
+ "no TM metadata found"
+ "no factory for usecase %s"
+ "no free ipc map entry!"
+ "no prev Buf, currFrame[%d] is EV0, skipping NccRansac"
+ "no prev Buf, currFrame[%d] is EVm, skipping NccRansac"
+ "no property read supported yet."
+ "no property write supported yet."
+ "node"
+ "node %.3f %.3f %.3f %.3f"
+ "node->channelDst == channelDst"
+ "node->channelSrc == channelSrc"
+ "node->id < LCDRV_Q_ID_COUNT"
+ "nodes_[id].active == 1"
+ "nominalRegs      = 0x%04X, 0x%04X"
+ "nominalRegs[mode]"
+ "non slow sync=>luxLevel=80%%* luxLevelTmp(%.1f) + LEDOff.fLux(%.1f) = %u"
+ "nonce %x %x ... %x %x\n"
+ "nonce -1\n"
+ "nonce 0x%llx\n"
+ "nonce not updated.\n"
+ "nonce: %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x\n"
+ "normDx != nullptr"
+ "normHistSum = %f, scConf = %f"
+ "normRect x: %.3f y %.3f w %.3f h %.3f"
+ "normRect.x <= 1 && normRect.y <= 1"
+ "normal raw processing case\n"
+ "normalizeRectROI"
+ "not implemented"
+ "not supported"
+ "not supported SplitPD mode %d"
+ "not supported request id %d mask 0x%x 0x%x"
+ "notiSema != (SEMA)0"
+ "notiSema != (SEMA)nullptr"
+ "notiSema == nullptr"
+ "notiSemaNack == nullptr"
+ "notificationSema"
+ "notify ch %u frm %llu to %u users"
+ "notifyBase"
+ "notifyQ != (FFWQUEUE)0"
+ "nullptr != instance"
+ "nullptr != powerService"
+ "num %d\n"
+ "num && num <= (numSifQueue - sifQueueUsed)"
+ "num < configTot"
+ "num == configTot && pList"
+ "numBins <= 10"
+ "numBins == 256"
+ "numBitsFractional != nullptr"
+ "numBitsTot != nullptr"
+ "numBitsTot && numBitsFractional"
+ "numBufs <= GPISP_GC_PRIMITIVE_TAHITI_DESGEN_IO_BUFFER_ID_TOT"
+ "numBytes != 0"
+ "numCCTs <= NUM_CCT_REFERENCE"
+ "numCamera <= CISP_AWB_MAX_SLAVE_CAMERA_ENTRIES"
+ "numChannels == numCh"
+ "numConfig(%d) should be >= numDBConfig(%d)\n"
+ "numConfigs != 0"
+ "numDefect < IMX703_STATIC_DPC_SIZE"
+ "numDefect <= IMX633_STATIC_DPC_SIZE"
+ "numDefect <= IMX713_STATIC_DPC_SIZE"
+ "numDefect <= IMX714_STATIC_DPC_SIZE"
+ "numDefectQsub < IMX903_STATIC_DPC_SIZE"
+ "numDefectQsub <= IMX803_STATIC_DPC_SIZE"
+ "numDefectQsub <= IMX972_STATIC_DPC_SIZE"
+ "numDefectQsum < IMX903_STATIC_DPC_SIZE"
+ "numDefectQsum <= IMX803_STATIC_DPC_SIZE"
+ "numDefectQsum <= IMX903_STATIC_DPC_SIZE"
+ "numDefectQsum <= IMX972_STATIC_DPC_SIZE"
+ "numDefectQsumV2H2 <= IMX972_STATIC_DPC_SIZE"
+ "numDefect_temp <= IMX913_STATIC_DPC_SIZE"
+ "numDefects <= CSystemConfigurator::GetDPCDefectPixelCount(ch)"
+ "numDetObjects <= detSelectionTempLen"
+ "numDetObjects <= matchedTrackIndicesLen"
+ "numDetObjects must be 0 when detector is not running!"
+ "numElements <= STF_MAXTABLEENTRIES"
+ "numEntries != 0"
+ "numEntries < EXP_GAIN_LUT_MAX_COUNT"
+ "numEntries <= GAIN_ADAPTATION_TABLE_ENTRIES"
+ "numEntries <= MAX_SKIN_TO_WHITE_LUT_ENTRIES"
+ "numEntries <= MAX_TUNING_TABLE_ENTRIES"
+ "numEntries <= MAX_WEIGHT_MASK_LUXNODES"
+ "numFaceTracked=%hu, numBodyTracked=%hu, "
+ "numFaces %d numObjects %d numSaliencyObjects %d"
+ "numFaces %u"
+ "numFaces <= 10"
+ "numFramesPriGroup[0] || numFramesPriGroup[1] || numFramesPriGroup[2]"
+ "numGroupsTM <= MAX_GROUPS"
+ "numHFF %d"
+ "numIoBuffers %u"
+ "numKeyPerScale %d %d %d %d %d\n"
+ "numLEDs"
+ "numOfCameras=%d, chBitMask=%u"
+ "numOfCmpnRtrMgr <= MAX_CRMGR_CNT"
+ "numOfCriticalRawBufAllocSet = %u ch = %zu"
+ "numOfStrms > 0"
+ "numOfTuningValues <= MAX_NUM_OF_SYSCONFIG_TUNING_VALUES"
+ "numOfVbdReadings < VBD_NUM_SAMPLES"
+ "numOutputs == (cb.usingMMS ? 2 : 1)"
+ "numPIOPackets %d"
+ "numPIOPackets <= kMaxPIOPackets"
+ "numPass: %d ocx: %d, %d; ocy: %d, %d \n"
+ "numPass: %d ocx: %d; ocy: %d \n"
+ "numPoints <= GMS_LS_MAX_NUM_POINTS"
+ "numPoints <= MAX_HISTOGRAM_X_TO_CCT_LUT_ENTRIES"
+ "numPoints <= MAX_PROJECTION_POINTS"
+ "numPoints=%d, width=%f, height=%f, kAdaptiveRansacThresFactor=%f"
+ "numPolynomials <= ALS_DEGREE_POLYNOMIALS"
+ "numPreset = %d => skip LoadAEExpandedTablesDefaultFFC function."
+ "numPreset = %d => skip LoadAEExpandedTablesDefaultSW function."
+ "numPreset = %d => skip LoadAEExpandedTablesDefaultTele function."
+ "numPreset = %d => skip LoadAEExpandedTablesDefaultWide function."
+ "numProcessedFrames=%u, AWB frameCount=%u, iirStrength=%.4f"
+ "numRects <= tempBytes"
+ "numResults %d"
+ "numRows == 3024"
+ "numRows == fpnMgr->GetCorrectionImageHeight(ch)"
+ "numSplitPDConfigs(false) == configTot"
+ "numTempBytes >= bs.totalBytes()"
+ "numTilesX <= CISP_FULL_SIZE_AE_TILES_X"
+ "numTilesY <= CISP_FULL_SIZE_AE_TILES_Y"
+ "numTrkObjects <= maxTrkObjects"
+ "numValidTrackers <= maxTrkObjects"
+ "numX != nullptr"
+ "numXGrid != 0"
+ "numXGrid && numYGrid"
+ "numY != nullptr"
+ "numYGrid != 0"
+ "number < NUM_ELEMENTS(IMX575_Configs)"
+ "number < SENSORIMX575_CONFIG_TOT"
+ "number < SENSORIMX633_MAX"
+ "number < SENSORIMX703_MAX"
+ "number < SENSORIMX713_MAX"
+ "number < SENSORIMX714_MAX"
+ "number < SENSORIMX803_MAX"
+ "number < SENSORIMX903_MAX"
+ "number < SENSORIMX913_MAX"
+ "number < SENSORIMX972_MAX"
+ "number < configTot"
+ "number < sizeof(Dummy_Configs)/sizeof(Dummy_Configs[0])"
+ "number < sizeof(IMX633_Configs)/sizeof(IMX633_Configs[0])"
+ "number of bg pairs %d\n"
+ "number of faces %d"
+ "number of fg pairs %d\n"
+ "number of fullBodyObjects"
+ "number of objects updated %d for frame %u, current tot objects = %u"
+ "number of total %d\n"
+ "numberOfAEupdate <= AE_BRACKETING_CAPTURE_MAX"
+ "numberOfLevels"
+ "numberOfScene == MTH_MAX_SEMANTICS || numberOfScene == 0"
+ "nvmData"
+ "nvmData != 0"
+ "nvmNotiSema != 0"
+ "object != 0"
+ "object != NULL"
+ "object.category < CISP_AC_DET_CATEGORY_COUNT"
+ "object[%u] normalized: %f %f %f %f"
+ "object[%u] original: %f %f %f %f"
+ "object[%u] pixel: %f %f %f %f"
+ "occludedThreshold <= 100"
+ "occlusion\n"
+ "occlusionAt"
+ "occlusionFromHeatMap"
+ "ocp_max=0x%08X"
+ "odPre"
+ "offlineEvalMode = %d\n"
+ "offset"
+ "offset != NULL"
+ "offset + size <= pFile->maxSize"
+ "offset < 257"
+ "offset < 4096"
+ "offset < 768"
+ "offset < ISPHWH17REG_BANK_SIZE"
+ "offset < VISIONDRVH17_RVC_RADGAINMEM_SIZE"
+ "offset < VISIONDRVH17_VNF_DOTDETECTLUT_SIZE"
+ "offset < VISIONDRVH17_VNF_STDYLUT_SIZE"
+ "offset < VISIONDRVH17_VNF_YCOEFF_SIZE"
+ "offset < VISIONDRV_MAX_LUT_VALUES"
+ "offset < memSize"
+ "offset <= 16912"
+ "offset <= 64"
+ "offset <= sizeof(pContext->mem)"
+ "offset == 0"
+ "offset >= interval"
+ "offset=0x%x"
+ "offsetCntxt=0x%8x, isFrameCmpn=%d, isDst=%d, withCompSrc=%d, withCompDst=%d\n"
+ "offsetIn != NULL"
+ "offsetIn: %d, offsetOut: %d"
+ "offsetIn:%d offsetOut:%d offsetSingle:%d [%x %x %x] g:%d"
+ "offsetLUT != nullptr"
+ "offsetX <= 65535 && offsetX >= -2097152"
+ "offsetX = %f, offsetY = %f, inv_sx, sy = [%f, %f]"
+ "offsetX = %f, offsetY = %f, sx = %f, sy = %f"
+ "offsetX == 0"
+ "offsetX >= 0"
+ "offsetX, Y = [%f, %f]"
+ "offsetY <= 65535 && offsetY >= -2097152"
+ "offsetY == 0"
+ "offsetY >= 0"
+ "oisMode <= CS40L62_MODE_COUNT"
+ "oisMode <= LC_OIS_ONCHIP_CONTROLLER_MODE_TOT"
+ "oisModeSwitchSema_end"
+ "oisModeSwitchSema_start"
+ "oisSample"
+ "oisZdata"
+ "ois_b1_code == nullptr"
+ "ois_b2_code == nullptr"
+ "ois_x_um"
+ "ois_y_um"
+ "ok == true"
+ "ok2run=%d"
+ "oldFramesInTbcSeq % CISP_PERIDOT_NUM_BANK_PAIRS == 0"
+ "oldMeta"
+ "oneConfig->curLocalPntInt <= oneConfig->period"
+ "oneConfig->type == type"
+ "oneFrameTime < (pAE->vFrameSize *hICSlave->hSensor->OneHLineTimeGet())"
+ "oneFrameTime > (pAE->vFrameSize *hICSlave->hSensor->OneHLineTimeGet())"
+ "oneFrmTm != 0"
+ "onefrmtm:%llu[us]"
+ "only use PIODMA from dram to HW for now. isHwMapped(src=%d, dst=%d)"
+ "only use it from dram to HW for now. isHwMapped(src=%d, dst=%d)"
+ "ooEst_um*ooEst_um"
+ "opBlock %u"
+ "opBufSize > sizeof(sCIspCmdChGeneralProcessListHeader)"
+ "opBufSize[nChannelId] > sizeof(sCIspCmdChGeneralProcessListHeader)"
+ "opId %d szCfg %d pId %d"
+ "opId < maxGlobalOpNbr"
+ "opbufs[bufIdx].info.format == CISP_INPUT_FORMAT_RAW8 || opbufs[bufIdx].info.format == CISP_INPUT_FORMAT_RAW16"
+ "opbufs[i].data"
+ "openedflashoff"
+ "operator()"
+ "optical center=(%f, %f)"
+ "optical center=(%f, %f) vs (%f, %f)"
+ "opticalCenter on BES Output\t: [%f, %f]\n"
+ "opticalCenter on Fscl Output\t: [%f, %f]\n"
+ "opticalCenter on Raw\t\t: [%f, %f]\n"
+ "opticalCenter: [%f, %f]\n"
+ "option.outHeight <= option.derivedTransformStep * CISP_VIS_INFO_MAX_SLICE_NBR"
+ "order <= 20"
+ "orderSyncTag"
+ "oriDistThresh = 0x%x"
+ "orientation != CISP_FW_DETECTOR_FACE_ORIENTATION_UNKNOWN"
+ "orientation %u"
+ "orig %.3f %.3f %.3f %.3f\n"
+ "original %.2f %.2f %.2f %.2f adjust %.2f %.2f %.2f %.2f"
+ "original %.3f %.3f %.3f, %.3f"
+ "original eyes[%u]: (%u %u %u %u), (%u %u %u %u)"
+ "original face[%u]: %u %u %u %u"
+ "original isTileMode=%d\n"
+ "original width %u height %u, bescrop(%.3f %.3f %.3f %.3f)"
+ "originalSize"
+ "otpControlStatus == 0x02"
+ "out (%d %d)"
+ "out of memory!"
+ "out2PDEPROC"
+ "outBuff != 0"
+ "outBuffer is NULL %p"
+ "outGridSize[0] <= LTM_LTC_GRID_APPLY_HORIZONTAL_SIZE_MAX"
+ "outGridSize[1] <= LTM_LTC_GRID_APPLY_VERTICAL_SIZE_MAX"
+ "outHeight % 2 == 0"
+ "outHeight >= 64"
+ "outStrmSel < FLOW_OUT_STRM_SELECT_TOT"
+ "outWidth"
+ "outWidth % 2 == 0"
+ "outWidth % 4 == 0"
+ "outWidth <= texWidth && outHeight <= texHeight"
+ "outWidth >= 128"
+ "outWidthUv <= texWidthUv && outHeightUv <= texHeightUv"
+ "out_conf_%u_%u_%u.raw"
+ "out_depth_%u_%u_%u.raw"
+ "out_ratio %f in_ratio %f ratio %f\n"
+ "output"
+ "output FORMAT 420, called dummyPool->BufferLink(), pGenProcessOutputBuffer = %p\n"
+ "output FORMAT 422 1 plane, called dummyPool->BufferLink(), pGenProcessOutputBuffer = %p\n"
+ "output FORMAT 422 2 planes, called dummyPool->BufferLink(), pGenProcessOutputBuffer = %p\n"
+ "output FORMAT FD_DATA, called dummyPool->BufferLink(), pGenProcessOutputBuffer = %p\n"
+ "output FORMAT Y 8Bit, called dummyPool->BufferLink(), pGenProcessOutputBuffer = %p\n"
+ "output FORMAT raw, called dummyPool->BufferLink(), pGenProcessOutputBuffer = %p\n"
+ "output buffer for Dx in splitPD should not be null! (when not in debug mode)"
+ "output buffer for Norm Dx should not be null!"
+ "output buffer for Scores in splitPD should not be null!"
+ "output buffer for left scaled luma in splitPDScaled should not be null"
+ "output buffer for right scaled luma in splitPDScaled should not be null"
+ "output frame to driver : channel %lu frameCount %d @ %llu"
+ "output frame to driver : channel %lu frameId %d @ %llu"
+ "output offset X %d = refWt %d - imgWt %d"
+ "output offset Y %d = refHt %d - imgHt %d"
+ "output pProcessCmd->outputData[%d].format = %d\n"
+ "output.pixelFormat == kBmBufferPixelFormatType_Float"
+ "output.pixelFormat == kFwDetectorBufferPixelFormatTypeFloat"
+ "output.width == c * w"
+ "output1 slowSyncMainflashDuration %f slowSyncExposureDuration %f\n"
+ "output: strideOutY=%d, strideOutC=%d\n"
+ "outputBufIdx < EXTSLAF_IPC_OUTPUT_END - EXTSLAF_IPC_OUTPUT_START + 1"
+ "outputBufIdx < ipcOutEnd - ipcOutStart + 1"
+ "outputBufferPoolIndex < buffPools"
+ "outputConfigs.configs[CPCE_OUTPUT_BUFFER_TYPE_NORMDX2].enabled == true"
+ "outputConfigs.configs[CPCE_OUTPUT_BUFFER_TYPE_NORMDX].enabled == true"
+ "outputFound == 1"
+ "outputNormDxBuffer != nullptr"
+ "outputPipe != 0"
+ "outputPipeIndex < outputs"
+ "outputPipe[CIC_OUTPUT_AF]"
+ "outputPipe[outputPin]"
+ "outputPipe[outputPipeIndex]"
+ "outputPipe[outputPipeIndex] != 0"
+ "outputPipe[pin]"
+ "outputResources.outputPipes[i] != nullptr"
+ "outputResources.outputPools[CPCE_OUTPUT_BUFFER_TYPE_OUT_OF_BOUNDS_META] != nullptr"
+ "outputResources.outputPools[i] != nullptr"
+ "outputResources.temporaryBuffers[i] != nullptr"
+ "outputSemanticAWBCondienceMap"
+ "outputSize[nChannelId] > (pCvdDpOutHeader->sections[CVIO_SECTION_SHARED].size + pCvdDpOutHeader->sections[CVIO_SECTION_OUTPUT].size + pCvdDpOutHeader->sections[CVIO_SECTION_INPUTDUMP].size)"
+ "outputW=%d, outputH=%d, outputStartX=%d, outputStartY=%d\n"
+ "outputWidth*outputHeight== AE_YMAP_TILES_X * AE_YMAP_TILES_Y"
+ "output[%i] >= output[%i], %f >= %f"
+ "output[i] >= output[i-1] - FLT_EPSILON"
+ "outsize != 0"
+ "outstanding"
+ "outstanding <= entries"
+ "outstanding == 0"
+ "overScanPercetageControl is manually Set %f\n"
+ "overallBinF %u fpPresrvEn %d fpEx %u fepQbinEn %u fepDMAOutBinH %u"
+ "overallBinF %u fpPresrvEn %d fpEx %u fepQbinEn %u fepDMAOutBinH %u sifBinH %d %d"
+ "overallBinFactor %u fpPreserveEn %d fpExclude %u fepQbinEnable %u fepDMAOutputBinH %u"
+ "overflow % input.alignMultipleX == 0"
+ "override preview FEP setting"
+ "override step: %.3f EV => %.3f\n"
+ "overwrite boot sequence on non-provisioned ARIES!\n"
+ "p && cfgsize"
+ "p0.nX != p1.nX"
+ "p2DHist != 0"
+ "p=%p, pLscMem=%p, mallocSize=%zu"
+ "pAE"
+ "pAEMetaData->contextSwitchConfig != AE_SENSOR_CONFIG_INVALID"
+ "pAEMetaDataHost != 0"
+ "pAESettingExt != NULL"
+ "pAF"
+ "pAF != NULL"
+ "pAFEProcBufInfo->afeProcSize"
+ "pAFEProcParam"
+ "pAFEProcParam->configSensor.pUnit != nullptr"
+ "pAFEProcParam->params.afe.DMAByteSize %u\n"
+ "pAICamDebug->totSize == AICamDebugDataSize()"
+ "pAICamDebugPyr0"
+ "pAICamDebugPyr0->pyrC0.height * pAICamDebugPyr0->pyrC0.stride <= CISP_AICAM_PYR_C0_MAX_BYTES"
+ "pAICamDebugPyr0->pyrY0.height * pAICamDebugPyr0->pyrY0.stride <= CISP_AICAM_PYR_Y0_MAX_BYTES"
+ "pAICamDebugPyr1"
+ "pAICamDebugPyr1->pyrC1.height * pAICamDebugPyr1->pyrC1.stride <= CISP_AICAM_PYR_C1_MAX_BYTES"
+ "pAICamDebugPyr1->pyrY1.height * pAICamDebugPyr1->pyrY1.stride <= CISP_AICAM_PYR_Y1_MAX_BYTES"
+ "pAICamDebugPyr2"
+ "pAICamDebugPyr2->pyrC2.height * pAICamDebugPyr2->pyrC2.stride <= CISP_AICAM_PYR_C2_MAX_BYTES"
+ "pAICamDebugPyr2->pyrY2.height * pAICamDebugPyr2->pyrY2.stride <= CISP_AICAM_PYR_Y2_MAX_BYTES"
+ "pAICamMeta"
+ "pAICamMeta->dbgDataOffset == ADDR_ALIGN_UP(sizeof(sCIspAnfdResults), 64)"
+ "pAICamMeta->faces %u"
+ "pANFDTracker"
+ "pAPEDefaultSettings"
+ "pAPSCommonCal"
+ "pAPSSingleCal"
+ "pAWB"
+ "pAWBMetadata != nullptr"
+ "pAWBMetadata->slaveCameraAWBParam[ch].valid"
+ "pAWBSettingCached != nullptr"
+ "pActHdr"
+ "pActItem->bufferList[i].bufferId <= 2"
+ "pActItem->nbrOfBuffer == GPISP_GC_PRIMITIVE_TAHITI_DESGEN_IO_BUFFER_ID_TOT"
+ "pAction != nullptr"
+ "pActionItem->actionId == CISP_GENERAL_PROCESS_ACTION_LOCAL_ID"
+ "pActionItem->bufferList[j].bufferId == SCISPCMDCHGPGP_BUFFER_INVALID_ID"
+ "pActionItem->nbrOfBuffer <= GPISP_GC_PRIMITIVE_TAHITI_CVDALL_IO_BUFFER_ID_TOT"
+ "pActionItem->nbrOfBuffer <= GPISP_GC_PRIMITIVE_TAHITI_DESGEN_IO_BUFFER_ID_TOT"
+ "pActionItem->nbrOfBuffer <= GPISP_GC_PRIMITIVE_TAHITI_DESMATCH_IO_BUFFER_ID_TOT"
+ "pActionListHdr != nullptr"
+ "pActionListHdr[nChannelId] != nullptr"
+ "pAfAssistHostMeta"
+ "pAfMoveItem"
+ "pAfPositionItem"
+ "pAfStatsConfigParams != 0"
+ "pAiCam"
+ "pAiCam->ipc_was_down %d"
+ "pAiCam->pRes"
+ "pAispState"
+ "pAlgBuf->cafCASBuf"
+ "pAlgBuf->lceCASBuf"
+ "pAlgBuf->yshCASBuf"
+ "pAnstInput"
+ "pAnstMeta"
+ "pAnstMeta->dbgDataOffset == ADDR_ALIGN_UP(sizeof(sCIspAnfdResults), 64)"
+ "pAppHeader->payloadSize == (sizeof(sDopplerState) + sizeof(uint32_t))"
+ "pAppHeader->payloadSize >= sizeof(sDopplerState)"
+ "pApsCalData"
+ "pApsCalData->sfr_inf_ChartDistance != 0.0f"
+ "pApsCalData->sfr_macro_ChartDistance != 0.0f"
+ "pApsHostMeta"
+ "pApsReducedHostMeta"
+ "pApsStatsHostMeta"
+ "pAttn"
+ "pAuxSclPyrConfig->numberOfLevels"
+ "pAwb"
+ "pAwb->awbReflow.bGenerateReflowAWB"
+ "pAwb->awbReflow.bGenerateReflowAWB ? mode == MULTI_PASS_MODE_PRESERVE_PEDESTAL_CAPTURE : mode == MULTI_PASS_MODE_FLASH_CAPTURE"
+ "pAwb->frameCount == pCurrMpInfo->frameCount || pAwb->syncTag == pCurrMpInfo->syncTag"
+ "pAwb->frameCount >= pCurrMpInfo->frameCount || pCurrMpInfo->frameCount == INVALID_FRAME_COUNT"
+ "pBKTParams->UB[0].BktParam[bkCount].captureFrameType == CISP_CAPTURE_MAIN_FRAME"
+ "pBKTParams->mode == AE_BRACKETING_FLASH_AMBIENT_FRAME"
+ "pBWRTimer != 0"
+ "pBin->value[n] > 0.0f"
+ "pBlurM != nullptr"
+ "pBodyCount"
+ "pBracketingTuningSet->bracketCount <= CISP_BRACKETING_CAPTURE_MAX"
+ "pBuf"
+ "pBuf->_header._rdptr + sizeof(sIOPRingBufferMsgHeaderV2_t) < pBuf->_header._wrptr"
+ "pBuf->_header._rdptr + sizeof(sIOPRingBufferMsgHeader_t) < pBuf->_header._wrptr"
+ "pBuf=%p can not be found"
+ "pBufAddr && pBufSize && pBufIndex"
+ "pBufAddr[i] && pBufSize[i]"
+ "pBufConf"
+ "pBufDisparity"
+ "pBufFrame"
+ "pBufFrame->DataPointer(0)"
+ "pBufFrame->DataPointer(1)"
+ "pBufInfo"
+ "pBufPoolDiscrete"
+ "pBuff != 0"
+ "pBuff->entry.buffRef.ref[5] != 0"
+ "pBuff->entry.buffRef.size >= 3"
+ "pBuffMsg->buffers <= FFW_INTERPROC_BUFF_TOT"
+ "pBuffRef->buffers == 4"
+ "pBuffRef->tot == 1"
+ "pBuffer"
+ "pBuffpool->IsCompressBufferPool()"
+ "pBuffpool->IsIcCompressBufferPool()"
+ "pBufs"
+ "pBufs[SYNCED_BUF_PDE]"
+ "pBufs[i] != NULL"
+ "pBufs[i]->info.bufferId < GPISP_GC_PRIMITIVE_TAHITI_CVDALL_IO_BUFFER_ID_TOT"
+ "pBufs[i]->info.bufferId < GPISP_GC_PRIMITIVE_TAHITI_DESGEN_IO_BUFFER_ID_TOT"
+ "pBuildInfo"
+ "pCAWB"
+ "pCToneCurveDrv != 0"
+ "pCachedMeta = %p\n"
+ "pCallPara"
+ "pCapturedFrame %p\n"
+ "pCapturedFrame %p sifArmed %d bHwBusy %d fc %d currFS %u issueGo %u"
+ "pCapturedFrame == 0"
+ "pCapturedFrame->Owner()->IsCompressBufferPool()"
+ "pCb"
+ "pCb->fakeinput"
+ "pCb->fakeinput == 0"
+ "pCb->fakepyrd[i]"
+ "pCb->fakeresult"
+ "pCb->metaEnableReplay"
+ "pCert already loaded!"
+ "pCfg"
+ "pCfg != NULL"
+ "pCfg->totalH && pCfg->totalVMin"
+ "pCfg->totalH && pCfg->totalVMin && pCfg->mainClk"
+ "pChDescr[ch]"
+ "pChDescr[ch]->tmpSpatialWeightBuf"
+ "pChDescr[nChannelId]"
+ "pChFEThumbnailMaskConfig->downScaleX <= 64 && pChFEThumbnailMaskConfig->downScaleY <= 64"
+ "pChHdr && timeMachineCapture"
+ "pChHdr->dest.channel < chTot"
+ "pChHdr->dest.multi == 1"
+ "pChInfo"
+ "pChInfo && pPplInfo"
+ "pChInfo->currMultiPassInfo.mpMode == MULTI_PASS_MODE_FLASH_CAPTURE"
+ "pChInfo->currMultiPassInfo.mpMode == MULTI_PASS_MODE_MLVNR"
+ "pChInfo->dataSource == DATA_SOURCE_BES_PROC_DMA"
+ "pChInfo->dataSource >= DATA_SOURCE_SENS0_DMA && pChInfo->dataSource <= DATA_SOURCE_SENS4_DMA"
+ "pChInfo->hFSM != 0"
+ "pChInfo->inputFrameBufQ"
+ "pChInfo->lastReceivedSyncTag <= pMetaData->syncTag.tag"
+ "pChInfo->mpMode == MULTI_PASS_MODE_NONE || pSetupInfo->pplMode != FLOW_PPL_MODE_BYPASS_ALL"
+ "pChInfo->mpMode || !pFrameExtra->passId"
+ "pChInfo->numOfOutputStreams <= VFLOWH17_SCL_TOT"
+ "pChInfo->numOfOutputStreams == 1"
+ "pChInfo->pCurrHWRegConfig == 0"
+ "pChInfo->pCurrMpBuffPreview"
+ "pChInfo->pMSTFRefOutScale1 != NULL"
+ "pChInfo->pMSTFRefOutScale2To5 != NULL"
+ "pChInfo->paramNoiClr.hairSMVmaskSize != 0"
+ "pChInfo->paramNoiClr.peopleSMVmaskSize != 0"
+ "pChInfo->paramNoiClr.skinSMVmaskSize != 0"
+ "pChInfo->paramNoiClr.skySMVmaskSize != 0"
+ "pChInfo->pplInfoQ"
+ "pChInfo->semanticAWBHiResData.frameCount != INVALID_FRAME_COUNT"
+ "pChInfo->stripConfig.stripCnt <= FLOWBASE_MAX_STRIPS"
+ "pChInfo->sushiRawBufOut"
+ "pChMeta"
+ "pChoosenOp != nullptr"
+ "pClient"
+ "pClkBoostTimer != 0"
+ "pClrProcLTMwMixLut"
+ "pCmd"
+ "pCmd != NULL"
+ "pCmd != nullptr"
+ "pCmd->addr != 0"
+ "pCmd->addressLen <= addressSize"
+ "pCmd->bufNbr <= maxAneIpcBufMsg"
+ "pCmd->ch < CISP_CH_TOT"
+ "pCmd->ch < CVDDP_MAX_CH_NUMBER"
+ "pCmd->ch < ISP_CAMERA_CHANNEL_TOT"
+ "pCmd->ch < h->numChls"
+ "pCmd->ch <= MOTIONESTIMATOR_MAX_CH_NUMBER"
+ "pCmd->ch >= h->channelBaseNumber"
+ "pCmd->config.base != 0"
+ "pCmd->config.index < HITH_MAX_THUMBNAIL_COUNT"
+ "pCmd->config.index < MAX_THUMBNAIL_COUNT"
+ "pCmd->config.stride > 0"
+ "pCmd->configIndex < h->m_sensorConfigsTot"
+ "pCmd->configIndex < pDescr->paramRaw.sensorConfigsTot"
+ "pCmd->configsTot <= h->m_sensorConfigsTot"
+ "pCmd->configsTot <= pDescr->paramRaw.sensorConfigsTot"
+ "pCmd->connId >= 0"
+ "pCmd->control >= MSTF_BAND0_STRMOD_DISABLE && pCmd->control <= MSTF_BAND0_STRMOD_ENABLEMAX60FPS"
+ "pCmd->dataLen <= dataSize"
+ "pCmd->dmaGroupId < FLOWH17_DMA_GROUP_TOT"
+ "pCmd->enableThreshold > pCmd->disableThreshold"
+ "pCmd->groupId < FLOWBASE_MS_DMA_GROUP_TOT"
+ "pCmd->idealPct <= 100 && pCmd->idealPct >= 0"
+ "pCmd->immediate == true"
+ "pCmd->index < CISP_CAMERA_CONFIG_MODE_TOTAL"
+ "pCmd->index < h->hSensor->TotalConfigsGet()"
+ "pCmd->index < hSensor->TotalConfigsGet()"
+ "pCmd->ispConfigId != INVALID_ISPCONFIG_ID"
+ "pCmd->ltmLtcLutsMem"
+ "pCmd->ltmLtcStride >= ltcDataLineSize"
+ "pCmd->ltmSccmLutsMem"
+ "pCmd->ltmSccmStride >= sccmDataLineSize"
+ "pCmd->masterParams.previewMasterCh < MAX_CHANNELS"
+ "pCmd->mode < CISP_CAM_PROCESSING_MODE_TOT"
+ "pCmd->mode < SLAVE_PROCESSING_MODE_TOT"
+ "pCmd->mode <= 1"
+ "pCmd->numBuses <= (sizeof(pCmd->busBase)/sizeof(pCmd->busBase[0]))"
+ "pCmd->numEntries != 0"
+ "pCmd->numEntries <= GAIN_ADAPTATION_TABLE_ENTRIES"
+ "pCmd->numOfAMCC == CSystemConfigurator::Instance()->DsIdClrMultiAMCCNumGet()"
+ "pCmd->numOfStrms"
+ "pCmd->numPoints == 8"
+ "pCmd->num_buf * sizeof(uint32_t) >= sizeof(prjErr.buf)"
+ "pCmd->outStrmSelect == FLOW_OUT_STRM_BESPROC ? pCmd->numOfStrms <= VFLOWH17_MAX_OUTPUT_STREAMS : pCmd->numOfStrms == 1"
+ "pCmd->output < IMAGE_BE_OUTPUT_TOT"
+ "pCmd->pFlow != 0"
+ "pCmd->pHwInfo->sensorHeight"
+ "pCmd->pHwInfo->sensorWidth"
+ "pCmd->pIspEngClient != 0"
+ "pCmd->pMaps != nullptr"
+ "pCmd->pSpeedTable != 0"
+ "pCmd->pSubPacket"
+ "pCmd->param.segLEDsPreflash != nullptr"
+ "pCmd->paramReset && (CFSM::Get(pDescr->hFSM) == ALGOCTRL_IDLE)"
+ "pCmd->passId < MAX_PASSES"
+ "pCmd->passes <= MAX_PASSES"
+ "pCmd->previewStrmBufferPoolId == CISP_POOL_YCC || pCmd->previewStrmBufferPoolId == CISP_POOL_RENDERED_SCL1"
+ "pCmd->priorityId < maxPriorityNbr"
+ "pCmd->queueId < maxFifoNbr"
+ "pCmd->regBase != 0"
+ "pCmd->regBase[amcc] != 0"
+ "pCmd->regBase[plane] != 0"
+ "pCmd->regRange >= CSystemConfigurator::Instance()->DsIdClrRegMaxRangeGet()"
+ "pCmd->regRange[plane] >= CSystemConfigurator::Instance()->DsIdClrRegMaxRangeGet()"
+ "pCmd->resID < VISION_RES_TOT"
+ "pCmd->selector < IMAGE_BE_OUTPUT_TOT"
+ "pCmd->setting < DPC_COEFF_SETTING_TOT"
+ "pCmd->sharedMemIndex < sCDMediaBusManagerShareMemInfo::maxSharedMemInfo"
+ "pCmd->sharpness <= MAX_SCALER_SHARPNESS_KNOB_LEVEL"
+ "pCmd->slaveConfig[i].chID < MAX_CHANNELS"
+ "pCmd->slaveConfig[i].procMode < CISP_SLAVE_PROCESSING_MODE_TOT"
+ "pCmd->srcPipe < FLOW_SRC_PIPE_TOT"
+ "pCmd->tableID < LA_TABLE_ID_TOT"
+ "pCmd->totalSlaves <= CICWRAPPER_RCAM_TOT_"
+ "pCmd->useCase < CISP_META_DATA_USE_CASE_TOT"
+ "pCmd->value < (uint32_t)InputSource::TOT"
+ "pCmd->value < (uint32_t)InputType::TOT"
+ "pCmd->value < VHDR_OUTPUT_SCHEME_TOT"
+ "pCmd->value > 0"
+ "pCmd->value >= MSTF_BAND0_STRMOD_DISABLE && pCmd->value <= MSTF_BAND0_STRMOD_ENABLEMAX30FPS"
+ "pCmd->winID >= 0 && pCmd->winID < FE_NUM_AF_WINDOWS"
+ "pCmd->winID >= 0 && pCmd->winID < FE_NUM_AWBAE_WINDOWS"
+ "pCmd->winID >= 0 && pCmd->winID < FE_NUM_HIGH_RES_AWBAE_WINDOWS"
+ "pCmd->zoomUpdate.configIndex < pDescr->paramRaw.sensorConfigsTot"
+ "pCmdNew == pCmdCache"
+ "pCmdRawBufInit->bSyncCmd"
+ "pCmdRawBufInit->network < m_netCnt"
+ "pCmdRawBufRelease->bSyncCmd"
+ "pCmdTimeOutTimer != 0"
+ "pCmdcontainer"
+ "pCmpn"
+ "pCmpnConfigAction->streamId != CISP_MCACHE_STREAM_ID_INVALID"
+ "pCmpnConfigAction->streamId < CISP_MCACHE_STREAM_ID_TOT"
+ "pCmpnRtrDescBuf"
+ "pColorAFCal"
+ "pColorHistogramConfig"
+ "pColorShading"
+ "pConfig"
+ "pConfig != 0"
+ "pConfig != NULL"
+ "pConfig->count <= CISP_CMD_CH_SENSOR_CUSTOM_SETTING_CONFIG_SET_REG_MAX"
+ "pConfig[i] != NULL"
+ "pContext"
+ "pContext != 0"
+ "pContext != nullptr"
+ "pContext->geometry.roi.cellCountX == geometryCorr.profileSize"
+ "pContext->geometry.roi.cellCountY == geometryCorr.profileSize"
+ "pContext->geometry.tile.countX * pContext->geometry.tile.countY <= NTILES"
+ "pContext->isStarted[chIdx]"
+ "pContext->params.flow.levels[0] == 1"
+ "pContextSwitch->numCh <= MAX_CHANNELS"
+ "pContextUncached != pContext"
+ "pContexts[MLAF_NETWORK_SLAF]->isStarted[chIdx]"
+ "pContexts[nidx]->aneClient || !enabled[nidx]"
+ "pContxtIn == NULL"
+ "pContxtIn == nullptr"
+ "pCoolLEDCurrent=%d pWarmLEDCurrent=%d "
+ "pCrc"
+ "pCrc->crcInfo[CISP_META_DATA_INPUT].numBytes <= CISP_META_CRC_MAX_NUM_BYTES"
+ "pCrop->x >= 0"
+ "pCrop->y >= 0"
+ "pCropSet->virtualGDCOutputSize.height >= pCropSet->rect.height + pCropSet->rect.y"
+ "pCropSet->virtualGDCOutputSize.width >= pCropSet->rect.width + pCropSet->rect.x"
+ "pCtx"
+ "pCtxMemPtr < chCtx[chId].CtxMemUpperBound"
+ "pCtxMemPtr <= chCtx[chId].CtxMemUpperBound"
+ "pCurReq"
+ "pCurReq->cmdId == *xenProcCmd"
+ "pCurReq->cmdId == CONVERT_CMD_ID_PURE(*xenProcCmd)"
+ "pCurrSetting != 0"
+ "pCurrSettingLSC != 0"
+ "pCurrentDisplayBrightness->displayBrightness>=0"
+ "pCurrentResp != nullptr"
+ "pCvPipeMem"
+ "pCvd != nullptr"
+ "pCvd == nullptr"
+ "pCvdDpOutHeader != nullptr"
+ "pDMBus == CDMediaBusManager::Instance()"
+ "pData"
+ "pData != 0"
+ "pData != nullptr"
+ "pData->totalNumberOfSpotsInPointCloud <= TOF_DEPTH_POINT_CLOUD_MAX_SPOTS"
+ "pData1"
+ "pData2"
+ "pData3"
+ "pDataAddr != 0"
+ "pDataFile"
+ "pDataFile != __null"
+ "pDataFile->dataFileAddr != 0"
+ "pDataSample"
+ "pData[i]"
+ "pDatabase->crop.rect[BES_PREVIEW_CROP].height != 0"
+ "pDatabase->crop.rect[BES_PREVIEW_CROP].width != 0"
+ "pDatabase->crop.rect[DPM_CROP].height != 0"
+ "pDatabase->crop.rect[DPM_CROP].width != 0"
+ "pDatabase->crop.rect[KEYPOINT_CROP].height != 0"
+ "pDatabase->crop.rect[KEYPOINT_CROP].width != 0"
+ "pDatabase->crop.rect[PDE_CROP].height != 0"
+ "pDatabase->crop.rect[PDE_CROP].width != 0"
+ "pDatabase->crop.rect[VISPIPE0RES_CROP].height != 0"
+ "pDatabase->crop.rect[VISPIPE0RES_CROP].width != 0"
+ "pDatabase->crop.rect[besCropIdx].height != 0"
+ "pDatabase->crop.rect[besCropIdx].width != 0"
+ "pDatabase->crop.rect[besCropSelect].height != 0"
+ "pDatabase->crop.rect[besCropSelect].width != 0"
+ "pDatabase->crop.rect[fdCropIdx].height != 0"
+ "pDatabase->crop.rect[fdCropIdx].width != 0"
+ "pDatabase->crop.rect[isStill ? FES_CAPTURE_CROP : FES_CROP].height != 0"
+ "pDatabase->crop.rect[isStill ? FES_CAPTURE_CROP : FES_CROP].width != 0"
+ "pDatabase->crop.rect[isStill ? MSBEPYR_CAPTURE_CROP : MSBEPYR_CROP].height != 0"
+ "pDatabase->crop.rect[isStill ? MSBEPYR_CAPTURE_CROP : MSBEPYR_CROP].width != 0"
+ "pDbg"
+ "pDcnAttn"
+ "pDebug"
+ "pDebug != NULL"
+ "pDebugAcResult"
+ "pDecoder != nullptr"
+ "pDefaultSettings"
+ "pDefectList"
+ "pDefectList != 0"
+ "pDefectListQsub"
+ "pDefectListQsub != 0"
+ "pDefectListQsubHermit_temp != 0"
+ "pDefectListQsubLagMI_temp != 0"
+ "pDefectListQsubLagSensor_temp != 0"
+ "pDefectListQsubLongCITLowMI_temp != 0"
+ "pDefectListQsubLongCITLowSensor_temp != 0"
+ "pDefectListQsubLongCITLow_temp"
+ "pDefectListQsubRegSensor_temp != 0"
+ "pDefectListQsubReg_temp"
+ "pDefectListQsubReg_temp != 0"
+ "pDefectListQsub_lag"
+ "pDefectListQsub_reg"
+ "pDefectListQsum"
+ "pDefectListQsum != 0"
+ "pDefectListQsumHermit_temp != 0"
+ "pDefectListQsumLongCITLow_temp"
+ "pDefectListQsumLongCITLow_temp != 0"
+ "pDefectListQsumReg_temp"
+ "pDefectListQsumReg_temp != 0"
+ "pDefectListQsumV2H2"
+ "pDefectListQsumV2H2 != 0"
+ "pDefectListQsumV2H2Reg_temp"
+ "pDefectListQsumV2H2Reg_temp != 0"
+ "pDefectListQsumV2H2_lag != 0"
+ "pDefectListQsum_lag != 0"
+ "pDefectListQsum_reg"
+ "pDefectListV2H2"
+ "pDefectListV2H2 != 0"
+ "pDeferRawBufRequestInfo->bDeferRawBufReq"
+ "pDeferRawBufRequestInfo->curRequestIdx < CIMAGEFLOW_MAX_DEFER_REQUEST"
+ "pDeferRawBufRequestInfo->notifyTMRawBufAllocDone"
+ "pDeferRequest->rawBuf[bufIdx]"
+ "pDefocusDispCalDAC"
+ "pDefocusDispCalUm"
+ "pDepthRawBuf"
+ "pDepthServiceAEData != nullptr"
+ "pDesGenFL2FeaturesOutHeader != nullptr"
+ "pDescr"
+ "pDescr != nullptr"
+ "pDescr->aeTMBracketTag.aeBracketing == false"
+ "pDescr->aeTMBracketTag.tmBracketing == false"
+ "pDescr->bCurrFrameSBSEnabled"
+ "pDescr->bPreservePedestal"
+ "pDescr->bStillCap"
+ "pDescr->bStillCap || ch == TELE_CAM_CH || ch == SWIDE_CAM_CH"
+ "pDescr->cachedRefBufArray[idx]"
+ "pDescr->configNum != CIMAGESENSOR_CONFIG_INVALID"
+ "pDescr->currHWConfigId != ((class CIspEngineClientH17 *)chDescr[ch].pIspEngClient)->invalid_id"
+ "pDescr->currMultiPassInfo.passId < ALGOCTRL_MAX_MULTI_PASSES"
+ "pDescr->currMultiPassInfo.passId < h->maxPasses[pDescr->currMultiPassInfo.mpMode]"
+ "pDescr->hBESDrv"
+ "pDescr->metaBuffer"
+ "pDescr->msMbnrM$Config.numOfScales != 1"
+ "pDescr->msMbnrM$Config.numOfScales >= 2 && pDescr->msMbnrM$Config.numOfScales <= 6"
+ "pDescr->msgQueue->Size() == 1"
+ "pDescr->msgQueue->Size() >= (size_t) numOfReqFrames"
+ "pDescr->pCurrBuff"
+ "pDescr->pCurrBuff == 0"
+ "pDescr->pCurrHWRegConfig != 0"
+ "pDescr->pCurrHWRegConfig == 0"
+ "pDescr->paramBES.gdcMeshBuf"
+ "pDescr->paramBES.inHeight >= (crop.y + crop.height)"
+ "pDescr->paramBES.inHeight >= height"
+ "pDescr->paramBES.inHeight >= pDescr->paramBES.outHeight[outType]"
+ "pDescr->paramBES.inHeight >= scalerOutHeight"
+ "pDescr->paramBES.inWidth >= (crop.x + crop.width)"
+ "pDescr->paramBES.inWidth >= (width)"
+ "pDescr->paramBES.inWidth >= pDescr->paramBES.outWidth[outType]"
+ "pDescr->paramBES.inWidth >= scalerOutWidth"
+ "pDescr->paramBES.inWidth >= width"
+ "pDescr->paramBES.refHeight[IMAGE_BE_OUTPUT_CAPTURE] >= pDescr->paramBES.outHeight[IMAGE_BE_OUTPUT_CAPTURE]"
+ "pDescr->paramBES.refHeight[i] >= (pMetaData->zoom.bUseOutputDMACropToZoom ? pMetaData->zoom.besOutputDMACropRect[i].height : pDescr->paramBES.outHeight[i])"
+ "pDescr->paramBES.refWidth[IMAGE_BE_OUTPUT_CAPTURE] >= pDescr->paramBES.outWidth[IMAGE_BE_OUTPUT_CAPTURE]"
+ "pDescr->paramBES.refWidth[i] >= (pMetaData->zoom.bUseOutputDMACropToZoom ? pMetaData->zoom.besOutputDMACropRect[i].width : pDescr->paramBES.outWidth[i])"
+ "pDescr->paramBES.warperM3Buf != 0"
+ "pDescr->paramBES.xShiftOffset[outType] == 0"
+ "pDescr->paramBES.yShiftOffset[outType] == 0"
+ "pDescr->paramFuse.warperM3Buf != 0"
+ "pDescr->paramManual.ltmLtcMemMallocSize >= ltcSize"
+ "pDescr->paramManual.ltmSccmMemMallocSize >= sccmSize"
+ "pDescr->paramNoiClr.LTMandHITHSizeConfig.localHistBlockSizeX % 2 == 0"
+ "pDescr->paramNoiClr.LTMandHITHSizeConfig.localHistBlockSizeX * pDescr->paramNoiClr.LTMandHITHSizeConfig.localHistBlockSizeY <= (1 << 22)"
+ "pDescr->paramNoiClr.LTMandHITHSizeConfig.localHistBlockSizeX >= 32 && pDescr->paramNoiClr.LTMandHITHSizeConfig.localHistBlockSizeX <= 2304"
+ "pDescr->paramNoiClr.LTMandHITHSizeConfig.localHistBlockSizeY >= 2 && pDescr->paramNoiClr.LTMandHITHSizeConfig.localHistBlockSizeY <= 4096"
+ "pDescr->paramNoiClr.LTMandHITHSizeConfig.localHistRect.start_x % 2 == 0"
+ "pDescr->paramNoiClr.LTMandHITHSizeConfig.localHistRect.start_y % 2 == 0"
+ "pDescr->paramNoiClr.LTMandHITHSizeConfig.localHistStrideX % 2 == 0"
+ "pDescr->paramNoiClr.LTMandHITHSizeConfig.localHistStrideX >= MAX(34, pDescr->paramNoiClr.LTMandHITHSizeConfig.localHistBlockSizeX/2)"
+ "pDescr->paramNoiClr.LTMandHITHSizeConfig.localHistStrideY >= pDescr->paramNoiClr.LTMandHITHSizeConfig.localHistBlockSizeY/2"
+ "pDescr->paramNoiClr.LTMandHITHSizeConfig.thumbnailDownsampleX < 256"
+ "pDescr->paramNoiClr.LTMandHITHSizeConfig.thumbnailDownsampleY < 256"
+ "pDescr->paramNoiClr.MsBePYRCroppedRect.height <= (uint32_t)(pDescr->paramNoiClr.MsBePYROutHeight << 1)"
+ "pDescr->paramNoiClr.MsBePYRCroppedRect.width <= (uint32_t)(pDescr->paramNoiClr.MsBePYROutWidth << 1)"
+ "pDescr->paramNoiClr.STFInputSrcDmaBuffer"
+ "pDescr->paramNoiClr.bCurrQuadraEnabled == isQuadraEnable"
+ "pDescr->paramNoiClr.bHistRect.end_x >= pDescr->paramNoiClr.bHistRect.start_x"
+ "pDescr->paramNoiClr.currFusionType == RAW_FUSION_TYPE"
+ "pDescr->paramNoiClr.gocGain < 4096"
+ "pDescr->paramNoiClr.hdrcHistRect.end_x >= pDescr->paramNoiClr.hdrcHistRect.start_x"
+ "pDescr->paramNoiClr.histRect.end_x >= pDescr->paramNoiClr.histRect.start_x"
+ "pDescr->paramNoiClr.hithThumbnailScaleFactor > 0"
+ "pDescr->paramNoiClr.ltmAuxBuffer != 0"
+ "pDescr->paramNoiClr.outHeight >= pDescr->paramNoiClr.clrProcCroppedRectCurr.y + pDescr->paramNoiClr.clrProcCroppedRectCurr.height"
+ "pDescr->paramNoiClr.outWidth >= pDescr->paramNoiClr.clrProcCroppedRectCurr.x + pDescr->paramNoiClr.clrProcCroppedRectCurr.width"
+ "pDescr->paramNoiClr.streamYCCTapEnable || !pMetaData->masterCamPreview"
+ "pDescr->paramNoiClr.thumbnailTotal > 0"
+ "pDescr->paramRaw.carDmaBuf != 0"
+ "pDescr->paramRaw.dpcType < DPC_TYPE_TOT"
+ "pDescr->paramRaw.fpnrDataAddr != nullptr"
+ "pDescr->paramRaw.fpnrDataAddr && (((uint64_t)pDescr->paramRaw.fpnrDataAddr % 64) == 0)"
+ "pDescr->paramRaw.fpnrDataSize != 0"
+ "pDescr->paramRaw.fpnrDataStride == (sizeof(DualLeftRightCorrectionPair) * 8)"
+ "pDescr->paramRaw.fsclOutHeight == pDescr->paramRaw.outRsmHeight"
+ "pDescr->paramRaw.fsclOutWidth == pDescr->paramRaw.outRsmWidth"
+ "pDescr->paramRaw.inRsmHeight >= pDescr->paramRaw.sushiRawRect.y + pDescr->paramRaw.sushiRawRect.height"
+ "pDescr->paramRaw.inRsmWidth >= pDescr->paramRaw.sushiRawRect.x + pDescr->paramRaw.sushiRawRect.width"
+ "pDescr->paramRaw.rawDMASrcCropRect.height <= pDescr->paramRaw.inHeight"
+ "pDescr->paramRaw.rawDMASrcCropRect.width <= pDescr->paramRaw.inWidth"
+ "pDescr->paramRaw.stLSCropped->configIndex != CIMAGESENSOR_CONFIG_INVALID"
+ "pDescr->paramRaw.stLSCropped->configIndex == pMetaData->configIndex"
+ "pDescr->paramRaw.stLSCroppedPerConfig[pCmd->configIndex].configIndex == pCmd->configIndex"
+ "pDescr->paramRaw.staticDPCBuf[j]"
+ "pDescr->paramRaw.totGainMSTFBand0StrModEnableThreshold > pDescr->paramRaw.totGainMSTFBand0StrModDisableThreshold"
+ "pDescr->paramStat[pipe].pStatHdr->thumbnailTotal > 0"
+ "pDescr->paramVision.outputHeightRawResize == kVisIRResizedH"
+ "pDescr->paramVision.outputWidthRawResize == kVisIRResizedW"
+ "pDescr->paramVision.visPipeProfileId == 1"
+ "pDescr->statDataSource != DATA_SOURCE_NONE"
+ "pDescrMaster->ch == GetTMPreviewMaster(pDescrMaster->ch)"
+ "pDescrMaster->msgQueue->Size() >= (size_t) numOfReqFrames"
+ "pDirList[i].id == INVALID_ID"
+ "pDiscardedFrame"
+ "pDistCal"
+ "pDistCalData"
+ "pDmaList[dmaId] !=NULL"
+ "pDmaManager"
+ "pDmaManager != nullptr"
+ "pDmaManagerList != nullptr"
+ "pDmaMgrInfo"
+ "pDrv != nullptr"
+ "pDrvPearlCalib != nullptr"
+ "pDst"
+ "pDstHist:%s pHist0B:%s"
+ "pDualColorReCal"
+ "pDualColorReCalData"
+ "pEGlut->count <= (sizeof(pEGlut->lut) / sizeof(pEGlut->lut[0]))"
+ "pEGlut->tableType != CISPCMD_CAE_TABLE_D3X_UBK_FFC"
+ "pEGlut->tableType != CISPCMD_CAE_TABLE_D3X_UBK_TELE"
+ "pEGlut->tableType != CISPCMD_CAE_TABLE_OISBRACKETING_TELE_LONG"
+ "pEGlut->tableType != CISPCMD_CAE_TABLE_OISBRACKETING_TELE_SHORT"
+ "pEGlut->tableType <= CISPCMD_CAE_TABLE_LAST"
+ "pERDcn"
+ "pElem != 0"
+ "pElem->notiSema != (SEMA)nullptr"
+ "pEntry"
+ "pEntry != 0"
+ "pEntry != nullptr"
+ "pEntry->id == ENTRY_BUFFREF"
+ "pEntry->id == ENTRY_CMD"
+ "pEntry->parent != index"
+ "pEntry->parent < logDepth"
+ "pEntry->parent == index"
+ "pEntry->refCount"
+ "pEntry->virtualAddr"
+ "pErr"
+ "pErrorIsrCb == NULL"
+ "pErrorIsrHandler == NULL"
+ "pEventLogger != 0"
+ "pExchange->buffers > 0"
+ "pExtCal"
+ "pExtCalData"
+ "pExtra"
+ "pExtra->bSifrStats == pcaeDesc->sifrStatsExpected"
+ "pExtra->rc == 0"
+ "pExtrinsicMatrix"
+ "pFDDcn"
+ "pFDInputCmd->height <= 480"
+ "pFDInputCmd->width <= 640"
+ "pFDProcDescrBuffer != 0"
+ "pFEMetaDataHost != nullptr"
+ "pFPDCInfo"
+ "pFace->eyeCoveringConfidence <= 1000"
+ "pFace->faceMaskConfidence <= 1000"
+ "pFaceCount"
+ "pFd"
+ "pFd->fdExtraInfo[faceId].withLandmarkRegressor == 0"
+ "pFd->fdInfo[faceId].chosenForFID == 1"
+ "pFd->numDetectedFaces <= CISP_FWDETECTOR_FD_MAX_RESULTS"
+ "pFd->numDetectedFaces >= pFd->numResults"
+ "pFd->withValidData"
+ "pFdMetaReplay"
+ "pFeStatCSCConfig"
+ "pFieldCurve"
+ "pFile->id != INVALID_ID"
+ "pFileList[i].id == INVALID_ID"
+ "pFlickerFreq->count<=CISP_PHOTOMETER_FLICKER_FREQ_MAX_COUNT"
+ "pFlow afeProc pipe %u, dma %u, enable %u ch %zu"
+ "pFocus"
+ "pFocusState"
+ "pFocusState->pCAF != 0"
+ "pFocusState->totalStatInputCount == 1"
+ "pFrame"
+ "pFrame != 0"
+ "pFrame %p, ch %zu"
+ "pFrame->entry.buffRef.ref[0]"
+ "pFrame->entry.buffRef.ref[6]"
+ "pFrameDesc->outBuff->Size() >= pFrameDesc->outBuff->Stride() * outputHeight"
+ "pFrameDesc->outBuff1->Size() >= pFrameDesc->outBuff1->Stride() * pMetaData->sensorHeight"
+ "pFrameDesc->outBuffEV0->Size() >= pFrameDesc->outBuffEV0->Stride() * outHeight"
+ "pFrameDesc->outBuffEVm->Size() >= pFrameDesc->outBuffEVm->Stride() * outHeight"
+ "pFrameDesc->pBuff->entry.buffRef.ref[2] != 0"
+ "pFrameDesc->sifrStatsBuffer"
+ "pFrameDesc->sifrStatsBuffer->Size() >= pStatHdr->statBufferSizeTotal"
+ "pFrameDesc->statsBuffer"
+ "pFrameDesc->statsBuffer->Size() >= pStatHdr->statBufferSizeTotal"
+ "pFrameDoneTimer != 0"
+ "pFrameExtra->passId < MAX_PASSES || pFrameExtra->stillImageCaptureNow == IMAGE_TYPE_GENERAL_PROCESS_SMG"
+ "pFrameInfo"
+ "pFrameInfo inWidth %d inCropWidth %d after ratio %f"
+ "pFrameInfo inWidth %d inCropWidth %d before ratio %f"
+ "pFrameInfo->tStart_clk < pFrameInfo->tEnd_clk"
+ "pFrameInfo: inW %d inH %d cropW %d cropH %d outW %d outH %d\n"
+ "pFrame[0] != 0"
+ "pFsmStatePrev"
+ "pGMS"
+ "pGMS is null. type: %d"
+ "pGNUMode2Settings->EnergyWeightLUT[i] < (1 << 11)"
+ "pGdcConfig != NULL"
+ "pGenProcessInput2Buffer = %p\n"
+ "pGenProcessInputBuffer = %p\n"
+ "pGenProcessInputParamBuffer = %p\n"
+ "pGenProcessInputParamBuffer=%#zx %zu\n"
+ "pGenProcessOutputBuffer[0]=%#zx %zu\n"
+ "pGenProcessOutputBuffer[1]=%#zx %zu\n"
+ "pGenProcessOutputBuffer[2]=%#zx %zu\n"
+ "pGenProcessOutputBuffer[3]=%#zx %zu\n"
+ "pGenProcessOutputMetaDataBuffer = %p\n"
+ "pGeneralProcessIcCfg = %p\n"
+ "pGeneralProcessParam->offsets[CISP_GENERAL_PROCESS_PARAM_DEPTH_CAL_DATA] = %d\n"
+ "pGeneralProcessParam->offsets[CISP_GENERAL_PROCESS_PARAM_DEPTH_CONFIG] = %d\n"
+ "pGeneralProcessParam->offsets[CISP_GENERAL_PROCESS_PARAM_IMAGE] = %d\n"
+ "pGeneralProcessParam->offsets[CISP_GENERAL_PROCESS_PARAM_SENSOR] = %d\n"
+ "pGeneralProcessParam->offsets[CISP_GENERAL_PROCESS_PARAM_STABILIZATION] = %d\n"
+ "pGeneralProcessParam->offsets[CISP_GENERAL_PROCESS_PARAM_VISION] = %d\n"
+ "pGeneralProcessVIS = %p\n"
+ "pGeneralProcessVIS->inputFormat = %d\n"
+ "pGeneralProcessVIS->outputFormat = %d\n"
+ "pGeneralProcessVIS->tileCount = %d\n"
+ "pGeometry->tile.cellCountX * 2 >= 15"
+ "pGeometry->tile.cellCountX >= 15"
+ "pGmsLoopInputs != NULL"
+ "pGravity"
+ "pGroupConfig"
+ "pGroupConfig->sz == sizeof(CS40L61_MODE00_AOR_G3b_Type) / CS40L61_REG16_LEN_BYTE"
+ "pGroupConfig->sz == sizeof(CS40L61_MODE00_AOR_G4a_Type) / CS40L61_REG16_LEN_BYTE"
+ "pGroupConfig->sz == sizeof(CS40L61_MODE00_AOR_G4b_Type) / CS40L61_REG16_LEN_BYTE"
+ "pGroupConfig->sz == sizeof(CS40L61_MODE00_AOR_G5a_Type) / CS40L61_REG16_LEN_BYTE"
+ "pGroupConfig->sz == sizeof(CS40L61_MODE00_AOR_G5b_Type) / CS40L61_REG16_LEN_BYTE"
+ "pGroupConfig->sz == sizeof(CS40L62_MODE00_AOR_G4_Type) / CS40L62_REG16_LEN_BYTE"
+ "pGroupConfig->sz == sizeof(CS40L62_MODE00_AOR_G5_Type) / CS40L62_REG16_LEN_BYTE"
+ "pGroupConfigArr"
+ "pGroupParams"
+ "pGroupParams->addrStart <= pGroupParams->addrEnd"
+ "pGroupParams->dev < CS40L61_DEVICE_COUNT"
+ "pHITHStat->thumbnailDownsampleX > 0"
+ "pHITHStat->thumbnailDownsampleY > 0"
+ "pHROnOff->useCase < CISP_TUNING_KNOB_CASE_TOT"
+ "pHWRegConfig0"
+ "pHWRegConfig1"
+ "pHWTimeoutTimer != 0"
+ "pHdr"
+ "pHdr != 0"
+ "pHighResFCData[iLevel]"
+ "pHistoryLTMGrid->height > 0"
+ "pHistoryLTMGrid->width > 0"
+ "pHistoryLTMGrid->width > 0 && pHistoryLTMGrid->height > 0"
+ "pHostAE"
+ "pHostMetaAESection"
+ "pHostMetaData"
+ "pHostMetaData != 0"
+ "pHostMetaData != 0 && ((size_t)pHostMetaData == (size_t)(pReprocessFrame->metaData.buffer))"
+ "pHostMetaData != NULL"
+ "pHostMetaData != nullptr"
+ "pHostMetaData->metaDataID.id.newVerIndicator || ((pHostMetaData->metaDataID.id.newVerIndicator == 0) && (pHostMetaData->metaDataID.legacyVer.version >= 0x91C))"
+ "pHostMetaData->offsets[CISP_META_DATA_INPUT] != 0"
+ "pHostMetaData->offsets[CISP_META_DATA_RAWPROC] != 0"
+ "pHostMetaData->offsets[CISP_META_DATA_RGBPROC] != 0"
+ "pHostMetaDataBuf != 0"
+ "pHostMetaDataBuf != NULL"
+ "pHostMetaDataBuf == 0"
+ "pHostMetaDataDest != NULL"
+ "pHostMetaDataInput"
+ "pHostMetaDataOutput"
+ "pHostMetaDataOutput != NULL"
+ "pHostMetaDataSrc != NULL"
+ "pHostMetaInputSection"
+ "pHostMetaSifrSection->isSifrOn || pHostMetaSifrSection->isSifrFrameDecimated"
+ "pHostPubKey"
+ "pHostSIFR->sensorSifrBayerBinFactor >= 1"
+ "pHwInfo != 0"
+ "pI2CRead->dataLen <= CIC_I2C_DATA_MAX"
+ "pI2CRead->subaddressLen <= CIC_I2C_SUBADDR_MAX"
+ "pI2CWrite->dataLen <= CIC_I2C_DATA_MAX"
+ "pI2CWrite->subaddressLen <= CIC_I2C_SUBADDR_MAX"
+ "pIODescrBuffer = %p\n"
+ "pIODescrBuffer=%#zx %zu\n"
+ "pIOInfo = %p\n"
+ "pIcCompConfigAction->streamId != CISP_MCACHE_STREAM_ID_INVALID"
+ "pInSyncBufRef"
+ "pInfo != 0"
+ "pInfo != NULL"
+ "pInfo != nullptr"
+ "pInfo->nameLen <= maxNameLen"
+ "pInfoBuffer->Size(0) >= sizeof(sGeneralProcessGPInfo)"
+ "pInitData"
+ "pInput"
+ "pInput != 0"
+ "pInput != NULL"
+ "pInput != nullptr"
+ "pInput->sensorArrayOutputRectWidth != 0"
+ "pInput2Buffer->Stride() = %lu\n"
+ "pInputBufRef"
+ "pInputBuffer != 0"
+ "pInputHostMeta"
+ "pInputSifr != 0"
+ "pInputSifr != 0 && pInputSifr->sifrBinWidth==1 && pInputSifr->sifrBinHeight==1"
+ "pInputSifr->sifrBinWidth==0 && pInputSifr->sifrBinHeight==0"
+ "pInputs"
+ "pInternalCmdArray_"
+ "pInternalCmdFreeList_"
+ "pInternalCmdList_"
+ "pInternalMeta = %p\n"
+ "pIspClient->invalid_id != dmaId"
+ "pIspClient->invalid_id != reqId"
+ "pIspEngine"
+ "pItem"
+ "pItem != nullptr"
+ "pItem->bufferRefCount"
+ "pItem->loaded"
+ "pItem->memPtr"
+ "pItem->memSize"
+ "pItem->pBase == pCmd->sharedMemPtr"
+ "pItem->used"
+ "pItem->valid"
+ "pJobInfo"
+ "pKey"
+ "pLCData"
+ "pLCData->version == LC_DATA_VERSION_V1"
+ "pLCData->version == LC_DATA_VERSION_V2"
+ "pLSCTableSet->offsetB != 0"
+ "pLSCTableSet->offsetGB != 0"
+ "pLSCTableSet->offsetGR != 0"
+ "pLSCTableSet->offsetR != 0"
+ "pLSCTableSet->sizeB == sizeof(int16_t)*pLSCTableSet->rows*pLSCTableSet->cols"
+ "pLSCTableSet->sizeGB == sizeof(int16_t)*pLSCTableSet->rows*pLSCTableSet->cols"
+ "pLSCTableSet->sizeGR == sizeof(int16_t)*pLSCTableSet->rows*pLSCTableSet->cols"
+ "pLSCTableSet->sizeR == sizeof(int16_t)*pLSCTableSet->rows*pLSCTableSet->cols"
+ "pLSColorConfig->lsMemSizeBytes >= (16 * OIS_LENS_SHADING_MAX_GRID_POINTS_X * OIS_LENS_SHADING_MAX_GRID_POINTS_Y * 2)"
+ "pLSColorConfig->lsMemSizeBytes >= (4 * OIS_LENS_SHADING_MAX_GRID_POINTS_X * OIS_LENS_SHADING_MAX_GRID_POINTS_Y * 2)"
+ "pLTMChInfo != 0"
+ "pLTMLuts"
+ "pLTMLuts->meta.lutsCountX <= CISP_LTM_LUTS_MAX_WIDTH"
+ "pLTMLuts->meta.lutsCountY <= CISP_LTM_LUTS_MAX_HEIGHT"
+ "pLTMLuts->meta.spatialCCMCountX <= CISP_LTM_SPATIAL_CCM_MAX_WIDTH"
+ "pLTMLuts->meta.spatialCCMCountY <= CISP_LTM_SPATIAL_CCM_MAX_HEIGHT"
+ "pLTMLuts->valid"
+ "pLTMLutsHostMeta->lutEntries == LTM_LTC_NUM_NODES"
+ "pLTMLutsHostMeta->spatialCCMEntries == LTM_SPATIAL_CCM_SIZE"
+ "pLTMOutput->averageCurve[i] >= pLTMOutput->averageCurve[i-1]"
+ "pLTMOutput->ltmGlobalLUT[i] >= pLTMOutput->ltmGlobalLUT[i-1]"
+ "pLTMOutput->rgbToneCurve[i] >= pLTMOutput->rgbToneCurve[i-1]"
+ "pLaccOpMem"
+ "pLaccOpMem=%p sharedMemSize=%u pOpMemUpperBound=%p"
+ "pLensCharacter"
+ "pLocalHistHostMetaOutput"
+ "pLut != 0"
+ "pLuxCalcParams != 0"
+ "pMLVNRModeConfigSet->autoModeEnterFrameRate <= pMLVNRModeConfigSet->autoModeExitFrameRate"
+ "pMLVNRModeConfigSet->autoModeEnterThreshold >= pMLVNRModeConfigSet->autoModeExitThreshold"
+ "pMLVNRNightModeConfigSet->autoModeEnterThreshold >= pMLVNRNightModeConfigSet->autoModeExitThreshold"
+ "pMLVNRTimeWarpConfigSet->autoModeEnterThreshold >= pMLVNRTimeWarpConfigSet->autoModeExitThreshold"
+ "pMMULogger != NULL"
+ "pMMULogger == NULL"
+ "pMSparams->totalSlaves < MAX_CH_PER_SYNCGROUP"
+ "pMTHSetting"
+ "pMainFlashParam->uMaxRunCntPreflash1 >= pMainFlashParam->uMinRunCntPreflash1"
+ "pMainFlashParam->uMaxRunCntPreflash2 >= pMainFlashParam->uMinRunCntPreflash2"
+ "pManualExposure != 0"
+ "pMaps != nullptr"
+ "pMasterFocusState"
+ "pMasterHostMeta"
+ "pMasterHostMetaInput"
+ "pMasterMetaData->channel == h->currFSMMasterCh"
+ "pMasterMetaData->pceInputHeight != 0"
+ "pMasterMetaData->pceInputWidth != 0"
+ "pMasterMetaDataBuf"
+ "pMasterMetaDataBuf == h->pTMStillMetaDataCBufArray[h->currFSMMasterCh]"
+ "pMemoryNewM2MGlobal != nullptr"
+ "pMemoryNewM2MLocal != nullptr"
+ "pMeta"
+ "pMeta != nullptr"
+ "pMeta %p"
+ "pMeta && pMotionEstimatorInput"
+ "pMeta->spd.pceMeta.endX >= pMeta->spd.pceMeta.startX"
+ "pMeta->spd.pceMeta.endY >= pMeta->spd.pceMeta.startY"
+ "pMeta->spd.pceMlafMeta.endX >= pMeta->spd.pceMlafMeta.startX"
+ "pMeta->spd.pceMlafMeta.endY >= pMeta->spd.pceMlafMeta.startY"
+ "pMetaBuff != 0"
+ "pMetaData"
+ "pMetaData != 0"
+ "pMetaData != NULL"
+ "pMetaData != nullptr"
+ "pMetaData && pFEThumbConfigMeta"
+ "pMetaData && ptr"
+ "pMetaData->HROn ? (pMetaData->hr.hrGainDownRatio > 0) : true"
+ "pMetaData->ae.AEMisc.nextAE.exposureTimeSifr > 0"
+ "pMetaData->ae.AEMisc.nextAE.gainAnalSifr > 0"
+ "pMetaData->ae.UBMisc.awbReflow.bGenerateReflowAWB"
+ "pMetaData->ae.UBMisc.awbReflow.bGenerateReflowAWB && !pDescr->bAWBSuspend ? pDescr->bPreservePedestal : true"
+ "pMetaData->ae.aeMatrixHorCount <= CISP_FE_NUM_MAX_TILES_X"
+ "pMetaData->ae.aeMatrixVerCount <= CISP_FE_NUM_MAX_TILES_Y"
+ "pMetaData->ae.bracketingCapture"
+ "pMetaData->ae.bracketingExpRatio > 0"
+ "pMetaData->ae.ev0Ratio < (6 << AE_GAIN_FRACTIONAL_BITS)"
+ "pMetaData->ae.ev0Ratio > 0"
+ "pMetaData->ae.ev0Ratio >= (1 << AE_GAIN_FRACTIONAL_BITS)"
+ "pMetaData->ae.exposureTime > 0"
+ "pMetaData->ae.exposureTimeSifr > 0"
+ "pMetaData->ae.gainAnal.v16 > 0"
+ "pMetaData->ae.gainAnalSifr.v16 > 0"
+ "pMetaData->ae.gainDigi.v16 > 0"
+ "pMetaData->ae.gainDigiSensor.v16 > 0"
+ "pMetaData->ae.hdrRatio > 0"
+ "pMetaData->ae.overflowDGain > 0"
+ "pMetaData->ae.pixelRate > 0"
+ "pMetaData->bLTMSingleFrameMode == false"
+ "pMetaData->binH < 2"
+ "pMetaData->binW"
+ "pMetaData->captureFrameType %u frameType %u\n"
+ "pMetaData->captureFrameType == CISP_CAPTURE_MAIN_FRAME"
+ "pMetaData->channel == inputCh"
+ "pMetaData->configIndex < m_sensorConfigsTot"
+ "pMetaData->configIndex < pDescr->paramRaw.sensorConfigsTot"
+ "pMetaData->fusion.registrationMode == REGISTRATION_M2M_MODE"
+ "pMetaData->hr.hrGainDownRatio > 0"
+ "pMetaData->imageFormat.fpType == pMeta->configurationAdjustedQuadraHocl.H6.fpType"
+ "pMetaData->multiStep.mode != MULTI_STEP_MODE_NONE"
+ "pMetaData->pPDPPreset != NULL"
+ "pMetaData->pceInputHeight != 0"
+ "pMetaData->pceInputWidth != 0"
+ "pMetaData->syncGroupConfig.camsProcMode[i].ch < MAX_CHANNELS"
+ "pMetaData->syncTag.channelsInSync <= 3"
+ "pMetaData->syncTag.channelsInSync > 0 || !pMetaData->syncTag.msEnabled"
+ "pMetaData->syncTag.tag == chDescr[masterCh].awbData.syncTag"
+ "pMetaData->uBracketingCount < CISP_BRACKETING_CAPTURE_MAX"
+ "pMetaData->uBracketingCount < pChInfo->bracketingTuningInfo.bracketCount"
+ "pMetaData->uBracketingCount < pDescr->bracketingTuningInfo.bracketCount"
+ "pMetaData->validDataRegion.y == 2"
+ "pMetaData->zoom.preISPDownsizeRatio == 1"
+ "pMetaData->zoom.rawDMASrcCropRect.width < CSystemConfigurator::MaxRaw2YuvInputWidthGet()"
+ "pMetaDataAEBracketing->ae.bracketingMode != AE_BRACKETING_NONE || pMetaDataAEBracketing->ae.preBracketing || pMetaDataAEBracketing->flash.flashCapture || pMetaDataAEBracketing->flash.flashFrameType"
+ "pMetaDataBuf"
+ "pMetaDataBufPrev != 0"
+ "pMetaDataBuffer != 0"
+ "pMetaDataCurr"
+ "pMetaDataDisgardFrame"
+ "pMetaDataHostFullResHdr != 0"
+ "pMetaDataHostHdr != 0"
+ "pMetaDataHostHdr != nullptr"
+ "pMetaDataHostHdr_FULLRES != 0"
+ "pMetaDataHostInput != 0"
+ "pMetaDataHostOutput != 0"
+ "pMetaDataMaster"
+ "pMetaDataNext"
+ "pMetaDataNext != 0"
+ "pMetaDataPrev"
+ "pMetaDataStill"
+ "pMetaMultiSlaveSection->numSlaves < MAX_NUM_SLAVES"
+ "pMetaMultiSlaveSection->numSlaves <= 1"
+ "pMflashLEDparam->modeSig == SEGLED_MODE_SIG"
+ "pMipiCfg[currentFreqConfig].div == 2"
+ "pMmsResult"
+ "pMode"
+ "pMode && pSubMode"
+ "pMode->mode < CISP_CAM_PROCESSING_MODE_TOT"
+ "pMode->mode < CISP_SLAVE_PROCESSING_MODE_TOT"
+ "pMotionBufferMem != NULL"
+ "pMotionDataRing"
+ "pMotionRing"
+ "pMotionService"
+ "pMotionStats || pMotionArray || pAbwcDebugArray"
+ "pMotionStatsHostMeta"
+ "pMsDmaConfig->bCompressionEn"
+ "pMsDmaConfig->scaleHeight[0] <= maxScaleHeight[0]"
+ "pMsInfo->msMode == MULTI_STEP_MODE_STRIP_GDC"
+ "pMsg != 0"
+ "pMsg != NULL"
+ "pMsg->ctxIdx == ctxIdx"
+ "pMthOutput->mthOutputEnable"
+ "pMultiCamROISet->numCh <= MAX_CHANNELS"
+ "pMultiCamWinSet->numCh <= MAX_CHANNELS"
+ "pMultiCaptureFrame[ch]"
+ "pMultiCaptureFrame[ch] == NULL"
+ "pMultiCaptureFrame[ch]->entry.buffRef.ref[1]"
+ "pMultiDPCTagging"
+ "pMultiPassMetaData->ae.UBMisc.awbReflow.bGenerateReflowAWB"
+ "pMultiPassMetaData->masterCam && pMultiPassMetaData->masterCamPreview"
+ "pMultiPassMetaData->masterCamPreview"
+ "pMutliCamZoom->numCh <= MAX_CHANNELS"
+ "pMyMsg->id == FFW_INTERPROC_MSG_EXCHANGE"
+ "pNVM"
+ "pNVMCrosstalk != nullptr"
+ "pNVMGain != nullptr"
+ "pNVMParserV2"
+ "pNVMParserV2 != nullptr"
+ "pNccOpMem=%p sharedMemSize=%u pOpMemUpperBound=%p"
+ "pNextMotion != 0"
+ "pNextSettingLSC != 0"
+ "pNode != NULL"
+ "pNode != nullptr"
+ "pNode->msgType < DOPPLER_MESSAGE_TYPE_TOT"
+ "pNode->msgType == msgType"
+ "pNodeDstToSrc"
+ "pNodeMidToDst"
+ "pNodeSrcToDst"
+ "pNodeSrcToMid"
+ "pNodeSrcToSrc"
+ "pNodeSrcToWorld"
+ "pNodeWorldToSrc"
+ "pNotificationMsg->id < NOTIFICATION_TOT"
+ "pOfflineFD->yuvData.yuvBuffer.buffer != 0"
+ "pOfflineFD->yuvData.yuvBuffer.size > 0"
+ "pOfflineFD->yuvData.yuvBuffer.stride > 0"
+ "pOfflineFD->yuvData.yuvBuffer.stride >= (size_t)(pOfflineFD->imageWidth << 1)"
+ "pOfflineFD->yuvData.yuvBuffer.stride >= (size_t)pOfflineFD->imageWidth"
+ "pOis"
+ "pOis != NULL"
+ "pOis == nullptr || pOis == pAF"
+ "pOisCalData"
+ "pOisHostMeta"
+ "pOisModeSwitchTimer != 0"
+ "pOisStatsHostMeta"
+ "pOisZCal"
+ "pOldestRaw == 0"
+ "pOp != nullptr"
+ "pOpItem->opId < maxGlobalOpNbr"
+ "pOpItem->opId == CISP_GENERAL_PROCESS_OPERATION_LOCAL_ID"
+ "pOpItem->sizeOfConfig == sizeof(CIspOperationDesGenH17::Config)"
+ "pOpItem->sizeOfConfig >= sizeof(sCIspGeneralProcessGCPrimConf_TahitiCVDAll)"
+ "pOpItem->sizeOfConfig >= sizeof(sCIspGeneralProcessGCPrimConf_TahitiDesGen)"
+ "pOpItem->sizeOfConfig >= sizeof(sCIspGeneralProcessGCPrimConf_TahitiDesMatch)"
+ "pOpListHdr != nullptr"
+ "pOpListHdr->tot <= maxOpNbrPerRequest"
+ "pOpListHdr[nChannelId] != nullptr"
+ "pOpListHdr[nChannelId]->tot <= maxOpNbrPerRequest"
+ "pOpMem"
+ "pOpMem=%p pNccOpMem=%p pPatchWarpOpMem=%p"
+ "pOutCheck[xx*LTM_LTC_NUM_NODES+(LTM_LTC_NUM_NODES-1)] >= FLT_EPSILON"
+ "pOutCheck[xx*LTM_LTC_NUM_NODES+i] >= pOutCheck[xx*LTM_LTC_NUM_NODES+i-1]"
+ "pOutCheck[xx*LTM_LTC_NUM_NODES] == 0"
+ "pOutStrmConfig"
+ "pOutput"
+ "pOutput != nullptr"
+ "pOutputBuffer != 0"
+ "pOutputEnable->outputSel < CISP_OUTPUT_TOT"
+ "pOutputLSConfig != 0"
+ "pOutputs"
+ "pOverride"
+ "pPC != NULL"
+ "pPDAFCal != nullptr"
+ "pPDAFDescr != nullptr"
+ "pPDAFDisparityCal"
+ "pPDAFSensor != 0"
+ "pPDAFSensor != nullptr"
+ "pPDAFSensorCalData"
+ "pPDAFUnit != nullptr"
+ "pPMUAddress != NULL"
+ "pPackRegPool->BufferAvailable() != 0"
+ "pPacket->size >= sizeof(OscarFilterPacketWithAccelBiasAndRotation)"
+ "pPage->eventCnt < mMaxEvents"
+ "pPage->eventInfoBuf[0].isValid"
+ "pParaMemCached == ((uint8_t *)BSP_SHARED_CACHED_VIRTUAL(pParaMem) + memSize)"
+ "pParam->ch < CVDDP_MAX_CH_NUMBER"
+ "pParam->section <= CISP_META_DATA_TOT"
+ "pParams != 0"
+ "pParams != nullptr"
+ "pParams->levels[0] == 1"
+ "pParams->mode < CISP_CAMERA_CONFIG_MODE_TOTAL"
+ "pPatch"
+ "pPatchWarpCoordBuf=%p size=%lu"
+ "pPatchWarpDstBuf=%p size=%lu"
+ "pPatchWarpLutBuf=%p size=%lu"
+ "pPatchWarpOpMem=%p sharedMemSize=%u pOpMemUpperBound=%p"
+ "pPayload != 0"
+ "pPersistFile->file.size <= sizeof(pPersistFile->file.data)"
+ "pPicOutLRME:%p, strideOut:%u, outputWidth:%u, outputHeight:%u"
+ "pPicTileInfo->warpArray=%p, &pPicTileInfo->warpArray[%d]=%p\n"
+ "pPioDma"
+ "pPool != nullptr"
+ "pPoolMan"
+ "pPplInfo != NULL"
+ "pPplInfo->algBufInfo.bufferMsFuseWarperM3->DataPointer() != NULL"
+ "pPplInfo->algBufInfo.bufferWarperM3->DataPointer() != NULL"
+ "pPplInfo->bTileGDCEn ? inSelBes == AISP_ISPCONFIG_PIPE_ISPCONFIG_BESPROC_INSEL_INSEL_BESPROCDMA : inSelBes != AISP_ISPCONFIG_PIPE_ISPCONFIG_BESPROC_INSEL_INSEL_BESPROCDMA"
+ "pPplInfo->bufMLAFIn"
+ "pPplInfo->bufOutAfeProc0->Size() >= pAFEProcBufInfo->afeProcSize"
+ "pPplInfo->bufOutFrame || pPplInfo->bufOutFrameClrProc"
+ "pPplInfo->bufOutRastScale0"
+ "pPplInfo->bufOutRastScale1"
+ "pPplInfo->bufOutRastScale2To5"
+ "pPplInfo->dataSource == DATA_SOURCE_AUX_SCL_PROC_DMA"
+ "pPplInfo->dataSource == DATA_SOURCE_BES_PROC_DMA || pPplInfo->dataSource == DATA_SOURCE_BES_PROC_RASTER_DMA || pPplInfo->dataSource == DATA_SOURCE_AUX_SCL_PROC_DMA || pPplInfo->msMode == MULTI_STEP_MODE_NONE"
+ "pPplInfo->dataSource == DATA_SOURCE_HUE_MAP_PIPE_DMA"
+ "pPplInfo->isLastPass || pPplInfo->mpMode == MULTI_PASS_MODE_HDR_CAPTURE || pPplInfo->msMode == MULTI_STEP_MODE_PYRAMID || pPplInfo->msMode == MULTI_STEP_MODE_STRIP_GDC || pPplInfo->msMode == MULTI_STEP_MODE_VHDR || pPplInfo->msMode == MULTI_STEP_MODE_M2M_GDC"
+ "pPplInfo->mpMode != MULTI_PASS_MODE_NONE || pPplInfo->msMode != MULTI_STEP_MODE_NONE"
+ "pPplInfo->msMode == MULTI_STEP_MODE_PYRAMID"
+ "pPplInfo->outStrmConfig[FLOW_OUT_STRM_BESPROC][VFLOWH17_AUX_SCL].scalerId == VFLOWH17_AUX_SCL"
+ "pPplInfo->pDmaMgrInfoList[pPplInfo->jobDoneCntExp]"
+ "pPplInfo->pMSTFRefInScale1"
+ "pPplInfo->pMSTFRefInScale2To5"
+ "pPplInfo->passId > 0"
+ "pPplInfo->pplMode != FLOW_PPL_MODE_STILL_CAPTURE"
+ "pPplInfo->pyramidConfig.bChromaPyrEn"
+ "pPplInfo->pyramidConfig.bPyramidEn"
+ "pPplInfo->pyramidConfig.inWidth * pPplInfo->pyramidConfig.inHeight <= pPplInfo->bufOutPyrScale0->Size()"
+ "pPplInfo->pyramidConfig.numberOfPyrLevels"
+ "pPplInfo->pyramidConfig.numberOfPyrLevels <= buffPool[bufferPoolPin]->BundledBlocksGet()"
+ "pPplInfo->stepId == PYRAMID_GENERATION_STEP"
+ "pPplInfoPass0"
+ "pPplInfoPass0->seqNum == pPplInfo->seqNum"
+ "pPplInfoPrevStep->seqNum == pPplInfo->seqNum"
+ "pPreflashLEDparam->modeSig == SEGLED_MODE_SIG"
+ "pPreflashLEDparam->type_grp == pMflashLEDparam->type_grp"
+ "pPreviewMasterAWBHostMeta"
+ "pPreviousLTMLuts"
+ "pPreviousLTMLuts->valid"
+ "pProcessBuffersCmd->bufferTot <= MAX_GENERAL_PROCESS_OUTPUTS"
+ "pProcessBuffersCmd->inputParameter.buffer = 0x%llx\n"
+ "pProcessBuffersCmd->inputParameter.metaDataSize = %llu\n"
+ "pProcessCmd->bufferTot < CIspEngineAgent::max_gp_buffer_nbr"
+ "pProcessCmd->bufferTot <= SCISPCMDCHGPGP_MAX_BUFFER_NBR"
+ "pProcessCmd->inputImage.format = %d\n"
+ "pProcessCmd->inputImage2.buffer.yuvBuffer.size = %d\n"
+ "pProcessCmd->inputImage2.buffer.yuvBuffer.stride = %d\n"
+ "pProcessCmd->inputImage2.format = %d\n"
+ "pProcessCmd->inputParameter.buffer = 0x%llx\n"
+ "pProcessCmd->inputParameter.metaDataSize = %llu\n"
+ "pProcessCmd->outputTot <= MAX_GENERAL_PROCESS_OUTPUTS"
+ "pProcessParam != 0"
+ "pProcessParam = %p\n"
+ "pProcessParamImage = %p\n"
+ "pProcessParamSensor = %p\n"
+ "pProcessedFrameExtra->frameCount == pFlowExtra->frameNum"
+ "pProcessedFrameExtra->passId == pFlowExtra->passId"
+ "pProcessedFrameExtra->stepId == pFlowExtra->stepId"
+ "pProfileSet"
+ "pProgDesc"
+ "pProgDescSubPacket->hdr.size == sizeof(sAneIpcProgDescSubPacket)"
+ "pProgramItem"
+ "pQCHShading"
+ "pQuadraShading->size >= SENSOR_PERMODULE_LSC_QUADRA_CH_SHADING_SIZE_MAX_BYTES"
+ "pQueue->Size()"
+ "pR"
+ "pR->ch < CISP_CH_TOT"
+ "pRGBHistStat != 0"
+ "pROIService != nullptr"
+ "pROISet->numCh <= MAX_CHANNELS"
+ "pRange"
+ "pRawBufAlocDoneNotifyTMSema"
+ "pRawBufAlocDoneNotifyTMSema[ch] != NULLSEMA"
+ "pRawBuff != 0"
+ "pRawBuffer->Owner()->IsCompressBufferPool()"
+ "pRawFrame != 0"
+ "pRawProcMetaDataHost"
+ "pRawProcMetaIn"
+ "pRdLut[ii] >= 0"
+ "pReadCfg != 0"
+ "pReadoutWindow != nullptr"
+ "pRearCalib != nullptr"
+ "pRegDump"
+ "pRegPool->BufferAvailable() != 0"
+ "pRegSpec && pRegSpec->len > 0 && pRegSpec->len <= sizeof(uint32_t)"
+ "pRemoteMetaDataHeader != nullptr"
+ "pReprocessFrame->metaData.buffer != 0"
+ "pReprocessFrame->rawData.buffer != 0"
+ "pReprocessFrame->rawData.size > 0"
+ "pReprocessFrame->rawData.stride > 0"
+ "pReq"
+ "pReq != nullptr"
+ "pReq == nullptr"
+ "pReq == pReqCache"
+ "pReq->sourceGoPending != 0"
+ "pReqFifo != nullptr"
+ "pReqFifo[%d]: entries %u"
+ "pReqFifo[fifoNbr] != nullptr"
+ "pReqPool != nullptr"
+ "pReqTmp"
+ "pRequest->nbrOfSecUsed == 0"
+ "pRes"
+ "pRes->alloc[i]->startAddr()"
+ "pRes->alloc[pCmdRawBufInit->memType]->startAddr()"
+ "pRes->chCtx[chId].curBuf->Size() >= (pMeta->fusion.visionResizeWidth * pMeta->fusion.visionResizeHeight)"
+ "pRes->chCtx[chId].historyMat"
+ "pRes->chCtx[chId].numMatchedPoints * sizeof(sBiDirectionalMatchList) <= MATCHLISTSIZE"
+ "pRes->chCtx[chId].pGGDDumpping != nullptr"
+ "pRes->chCtx[chId].pVisSDetNumKey <= kVisSDetMaxNumOfKeyPointsTotal"
+ "pRes->chCtx[chId].runHomographyEval = %d"
+ "pRes->chCtx[ch].hatBuf"
+ "pRes->ctxs[i].active == false"
+ "pRes->ctxs[i].active == true"
+ "pRes->ipcm[CMLAF_MEM_TYPE_RAW_BUF].size >= (ref[MLAF_TELE_BUF_INPUT_LEFT]->Size() + ref[MLAF_TELE_BUF_INPUT_RIGHT]->Size())"
+ "pRes->lastProcessedBuffer != NULL"
+ "pRes->mInfo.ctx.processId >= 0"
+ "pRes->mInfo.ctx.programId >= 0"
+ "pRes->mInfo.desc.procedures[procedureId].numIoBuffers == EXTSLAF_IPC_TOT"
+ "pRes->mInfo.desc.procedures[procedureId].numIoBuffers == ipcTot"
+ "pRes->pMemToPDAF"
+ "pRes->pMotionBufferPool != NULL"
+ "pRes->pRansacEngine"
+ "pRes->processedBuffer != NULL"
+ "pRes->uxCachedDepth.fpdStatus != kFwDetectorFpdStatusUnknown"
+ "pRes->uxCachedDepth.fpdStatus == kFwDetectorFpdStatusUnknown"
+ "pRes->workBuffer != NULL"
+ "pRes->workBuffer2 != NULL"
+ "pResInfo->actionNbr(%d) == pResMapping->actionNbr(%d)\n"
+ "pResource != nullptr"
+ "pResource->containsDesGen"
+ "pResource->containsDesMatch"
+ "pResource->laccMatchDMA[0] != 0"
+ "pResource->laccMatchDMA[1] != 0"
+ "pResource->laccMatchDMA[2] != 0"
+ "pResource->laccMatchDMA[3] != 0"
+ "pResource->laccMatchDMA[4] != 0"
+ "pResource->laccMatchDMA[5] != 0"
+ "pResource->laccMatchDMA[6] != 0"
+ "pResource->laccMatchDMA[7] != 0"
+ "pResource->rma0Size != 0"
+ "pResource->rma0Size == size"
+ "pResource->rma0StartAddrHi == (CVD_LACCMATCH_BASE_ADDR(GBI_CVD_LACCMATCH) >> 32)"
+ "pResource->rma1Size != 0"
+ "pResource->rma1Size == size"
+ "pResource->rma1StartAddrHi == (CVD_LACCMATCH_BASE_ADDR(GBI_CVD_LACCMATCH) >> 32)"
+ "pResource->rma2Size != 0"
+ "pResource->rma2Size == size"
+ "pResource->rma2StartAddrHi == (CVD_LACCMATCH_BASE_ADDR(GBI_CVD_LACCMATCH) >> 32)"
+ "pResource->rma3Size != 0"
+ "pResource->rma3Size == size"
+ "pResource->rma3StartAddrHi == (CVD_LACCMATCH_BASE_ADDR(GBI_CVD_LACCMATCH) >> 32)"
+ "pResource->wma0Size != 0"
+ "pResource->wma0Size == size"
+ "pResource->wma0StartAddrHi == (CVD_LACCMATCH_BASE_ADDR(GBI_CVD_LACCMATCH) >> 32)"
+ "pResource->wma1Size != 0"
+ "pResource->wma1Size == size"
+ "pResource->wma1StartAddrHi == (CVD_LACCMATCH_BASE_ADDR(GBI_CVD_LACCMATCH) >> 32)"
+ "pResource->wma2Size != 0"
+ "pResource->wma2Size == size"
+ "pResource->wma2StartAddrHi == (CVD_LACCMATCH_BASE_ADDR(GBI_CVD_LACCMATCH) >> 32)"
+ "pResource->wma3Size != 0"
+ "pResource->wma3Size == size"
+ "pResource->wma3StartAddrHi == (CVD_LACCMATCH_BASE_ADDR(GBI_CVD_LACCMATCH) >> 32)"
+ "pRess[nidx]->pMemToPDAF"
+ "pResult"
+ "pRgbhRawBuf"
+ "pRingBuffer != 0"
+ "pRotate"
+ "pRotation != nullptr"
+ "pRpc"
+ "pRpc != NULL"
+ "pRpc->rpcList[0].bufferList[0].addr == (size_t)pBuffer"
+ "pRpc->rpcList[0].bufferList[0].isRO == 0"
+ "pRpc->rpcList[0].bufferList[0].size == 1024"
+ "pRpc->rpcList[0].bufferList[i].addr == (uint64_t)BSP_TARGET_TO_HW(pRequest->buf[i].addr)"
+ "pRpc->rpcList[0].bufferList[i].isRO == pRequest->buf[i].isRO"
+ "pRpc->rpcList[0].bufferList[i].size == pRequest->buf[i].size"
+ "pRpc->rpcList[0].nbfOfBuf <= CRPCClient::maxBufNbr"
+ "pRpcFileWrite"
+ "pRuLut[ii] >= 0"
+ "pSLAFbufferNcc2AlgoCtrl is not released"
+ "pSN"
+ "pSN != NULL && size != 0"
+ "pSN != NULL && size != NULL"
+ "pSTFInputBuf"
+ "pSTFMeta"
+ "pSTFRegisterMeta"
+ "pSTFSetting"
+ "pSTFWeightMapMeta"
+ "pSafe && pEventCnt && pMisc && (numMisc > 8)"
+ "pSample"
+ "pSample->ts_clk >= tStart_clk && pSample->ts_clk < pFrameInfo->tEnd_clk"
+ "pSampleNew->period_clk"
+ "pSampleNew->ts_clk < tEnd_clk"
+ "pSampleOld->period_clk"
+ "pSampleOld->ts_clk <= pSampleNew->ts_clk"
+ "pSeg->isDma"
+ "pSegMapping->actionNbr"
+ "pSensor"
+ "pSensorConfig"
+ "pSensorConfig != NULL"
+ "pSensorConfig != nullptr"
+ "pSensorConfig->features.secondaryBinW == pSensorConfig->features.secondaryBinH"
+ "pSensorConfigs"
+ "pSensorConfigs && configTot && cfgList && num"
+ "pSensorConfigs && number < configTot"
+ "pSensorConfigs[0].width"
+ "pSensorConstraints"
+ "pSensorMiscParams != nullptr"
+ "pSensorNoiseModel->mode < CISP_CAMERA_CONFIG_MODE_TOTAL"
+ "pSeq"
+ "pSessionInfo"
+ "pSessionInfo != nullptr"
+ "pSessionInfo->chMask != 0"
+ "pSessionInfo->numCh <= MAX_ISP_CHANNELS"
+ "pSessionStatus->numCh < MAX_CHANNELS"
+ "pSetCamBesAuxSclCropOutputConfig->inSel == CISP_SECONDARY_SCALER_SOURCE_BES"
+ "pSetCamBesAuxSclCropOutputConfig->scaler_output[scaler].width >= 128"
+ "pSetCamCropOutputConfig->output.width >= 128"
+ "pSetCamOutConfig->bufferHeight >= pSetCamOutConfig->height"
+ "pSetCamOutConfig->width >= 128"
+ "pSetCamYccSclCropOutputConfig->output.width >= 128"
+ "pSetFileList"
+ "pSetting != 0"
+ "pSetting->bracketingCapture == 1"
+ "pSetting->bracketingMode == AE_BRACKETING_FLASH"
+ "pSetting->frameOffWidthVal"
+ "pSetupInfo->numOfOutputStreams <= VFLOWH17_MAX_OUTPUT_STREAMS"
+ "pSetupInfo->outStrmConfig[i].scalerId < VFLOWH17_MAX_BES_SCALERS"
+ "pSetupInfo->outStrmSelect == FLOW_OUT_STRM_BESPROC"
+ "pSharedData"
+ "pSharedMem"
+ "pSharedMemory"
+ "pSharedMemoryBuffer"
+ "pSharedMemoryCmn"
+ "pSharedMemoryHPPO"
+ "pSharedMemoryHPPR"
+ "pSharedMemoryPDCO"
+ "pSharedMemoryPDCR"
+ "pSideBandBufActiveFrame[SB_DMA_GROUP_0]"
+ "pSifrCapturedFrame"
+ "pSifrCapturedFrame == nullptr"
+ "pSifrFEPDmaFrame"
+ "pSize != 0"
+ "pSkinToWhiteLutSet->numPoints <= CISP_AWB_MAX_SKIN_TO_WHITE_LUT_ENTRIES_TOTAL"
+ "pSlave"
+ "pSlaveFocusState"
+ "pSlaveMetaDataBuf"
+ "pSlaveParams->slaveProperty.maxNumActiveSlaveCams < MAX_CH_PER_SYNCGROUP"
+ "pSlaveParams->slaveProperty.maxNumActiveSlaveCams < totalChInGroup"
+ "pSlaveParams->slaveProperty.maxNumProcessEnabledSlaveCams < MAX_CH_PER_SYNCGROUP"
+ "pSlaveParams->slaveProperty.maxNumProcessEnabledSlaveCams < totalChInGroup"
+ "pSlaveState"
+ "pSpatialMapsSums[j] >= FLT_EPSILON"
+ "pSpec"
+ "pSphereCal"
+ "pSphereReCal"
+ "pSrc"
+ "pSrcPipeDmaConfig->dataSource == DATA_SOURCE_HUE_MAP_PIPE_DMA"
+ "pSrc[%d]: actionNbr(%d) < ISPHWSECTIONCOPY_MAX_ITEM(%d)\n"
+ "pSrc[%d]: should have exact one block. blockNbr=%d\n"
+ "pStatBuff->localHistStat"
+ "pStatBuff->thumbnailScaleFactor * LTM_THUMBNAIL_HEIGHT * pProcessedFrameExtra->hithThumbnailDownsampleY <= pProcessedFrameExtra->hithThumbnailWindowHeight"
+ "pStatBuff->thumbnailScaleFactor * LTM_THUMBNAIL_WIDTH * pProcessedFrameExtra->hithThumbnailDownsampleX <= pProcessedFrameExtra->hithThumbnailWindowWidth"
+ "pStatHdr != 0"
+ "pStatHdr->numTilesX > 0 && pStatHdr->numTilesY > 0"
+ "pStatMasterMeta"
+ "pStatParam->pStatHdr->lrsHeight > 0"
+ "pStatParam->pStatHdr->numTilesX > 0 && pStatParam->pStatHdr->numTilesY > 0"
+ "pStats"
+ "pStats != NULL"
+ "pStats->compHist != NULL"
+ "pStats->pThumbnail != NULL"
+ "pStats->tileStats != NULL"
+ "pStatsFEThumbMetadataHost"
+ "pStatsHdr != NULL"
+ "pStatsHdr != nullptr"
+ "pStatsHdrSecondary != 0"
+ "pStatsMasterAEHostMeta"
+ "pStatsMasterAWBHostMeta"
+ "pStatus != NULL"
+ "pStillMetaDataCBufSec"
+ "pStillMetaDataCBufSifr"
+ "pStride != 0"
+ "pSubPacket != NULL"
+ "pSyncBuf"
+ "pSysCfg->size == sizeof(struct sSysCfgKeyRosaline)"
+ "pTData"
+ "pTMParams->timeMachineParams.maxNumActiveTimeMachine <= totalChInGroup"
+ "pTMStillMetaDataCBufArray[ch]"
+ "pTMStillMetaDataCBufArray[ch] == NULL"
+ "pTMStillMetaDataCBufArray[pDescr->ch]"
+ "pTMStillMetaDataCBufArray[pDescrMaster->ch]"
+ "pTableConfig[i] != NULL"
+ "pTableInfo->sectionId < ISPHWH17SectionId_MaxNbr"
+ "pTableList[i].tableCurIndex < pTableInfo->compSize"
+ "pTargetSensorParam != NULL"
+ "pTask != nullptr"
+ "pTask == nullptr"
+ "pTask->bufContext != nullptr"
+ "pTask->bufMetadata != nullptr"
+ "pTask->bufPyramidY != nullptr"
+ "pTask->bufSpd != nullptr"
+ "pTask->pMetaData->spd.extremeLowLightMode < SPD_RUN_MODE_TOT"
+ "pTaskHistoryHead != 0"
+ "pTemp"
+ "pTemp + pCmd->pBufSize[i] <= (size_t)pItem->pBase + pItem->memSize"
+ "pTemp == pReqCache"
+ "pTemp >= (size_t)pItem->pBase && pTemp <= (size_t)pItem->pBase + pItem->memSize"
+ "pTemp->m_PF0_Component0_Sum < MAX_PF_SUM"
+ "pTempDst + sizeInDW == pDst"
+ "pThis"
+ "pThis->irqSource_ == source"
+ "pTimeProfiler != 0"
+ "pTimer != 0"
+ "pTimer->timer != 0"
+ "pTimewarpDrv"
+ "pTofHistMetaData->version == CISP_TOF_HIST_METADATA_VERSION"
+ "pToneCurveOut[i] >= pToneCurveOut[i-1]"
+ "pTotalEITsPerKnee[idx] >= pTotalEITsPerKnee[idx-1]"
+ "pTrace"
+ "pTraceUncached"
+ "pTransformData"
+ "pUpdate != nullptr"
+ "pUserStr != 0"
+ "pValue"
+ "pVisDetResBuf=%zx pVisDetResBuf2=%zx gpBufSize=%d"
+ "pVisPipeOpMem=%p pVisSDetOpMem=%p pLaccOpMem=%p"
+ "pVisPipeOpMem=%p sharedMemSize=%u pOpMemUpperBound=%p"
+ "pVisSDetKey && keyLoc_x && keyLoc_y"
+ "pVisSDetOpMem=%p sharedMemSize=%u pOpMemUpperBound=%p"
+ "pWarpM3DmaBuffer != nullptr"
+ "pWarpM3DmaBuffer addr = %p\n"
+ "pWarpM3DmaBuffer[0] = %x, pWarpM3DmaBuffer[1] = %x\n"
+ "pWeights != nullptr"
+ "pWinService != nullptr"
+ "pWinSet->winID <= CISP_APPLE_AE_WIN_3"
+ "pWinSet->winID >= CISP_APPLE_AE_WIN_0"
+ "pZPosOut != nullptr"
+ "packetSize * sizeof(uint32_t) > sizeof(PIODMA_PacketHeader_u)"
+ "packetSize * sizeof(uint32_t) >= sizeof(PIODMA_Generic_PacketHeader_u)"
+ "pageCnt > 0"
+ "pageId=%#x %s @%llu us procTime=%llu us, inFrmDelta=%llu us, outFrmDelta=%llu us\n"
+ "pageId=%#x %s @%llu us, inFrmDelta=%llu us\n"
+ "panstDebug"
+ "param"
+ "param != nullptr"
+ "param->configIndex < hSensor->TotalConfigsGet()"
+ "param1 >= sizeof(struct ffwInterProcMsg)"
+ "paramUnit"
+ "params != NULL"
+ "params->rawHeight <= CAR_MAX_OUT_HEIGHT"
+ "params->rawWidth <= CAR_MAX_OUT_WIDTH"
+ "params.afe.AFERegionEnd.X == 0"
+ "params.afe.AFERegionEnd.Y == 0"
+ "params.afe.AFERegionStart.X == 0"
+ "params.afe.AFERegionStart.Y == 0"
+ "params.afe.DMAByteSize == 0"
+ "params.shiftMax > 0"
+ "params.shiftMin < 0"
+ "paredBlockSize[%d]XY=%d %d"
+ "paredNumBlocks[%d]XY=%d %d"
+ "parent"
+ "parent < logDepth"
+ "parent == logDepth"
+ "parent == pEntry->parent"
+ "parentEntry->child"
+ "parentEntry->virtualAddr"
+ "parse_angle"
+ "parse_attention"
+ "parse_fd"
+ "parse_glass"
+ "parse_landmark"
+ "parse_occlusion"
+ "parser"
+ "partial flow timer is not initialized"
+ "partial flow timer was stopped too many times"
+ "partialFlow != nullptr"
+ "partialFlow->CalculateInitializationState() == CPCEFLOW_STATE_UNINITIALIZED"
+ "partialFlow->GetInitializedChannelsBM() & ((1 << (3)))"
+ "partialFlowTimeoutSema != nullptr"
+ "partialGdcScale is larger than 1"
+ "partialGdcScale=%f"
+ "partialGdcScale=%f vs %f"
+ "partitionWithThrhd"
+ "passId < MAX_PASSES"
+ "patch applied. %016llx\n"
+ "patch syscfg %016llx\n"
+ "patch.addr >= CS40L61_PATCH_BASE_ADDRESS"
+ "patch.addr >= base_addr[i]"
+ "patch.enable = %d"
+ "patch.height = %d"
+ "patch.isValid"
+ "patch.isValid == true"
+ "patch.numPatch = %d"
+ "patch.offset = %d"
+ "patch.pArr && patch.size > 0"
+ "patch.size < CS40L62_AO_RAM_SIZE"
+ "patch.width = %d"
+ "path %s"
+ "path: %s"
+ "pattern.grid.countX > 0"
+ "pattern.grid.countY > 0"
+ "pattern.grid.spacingX > 0"
+ "pattern.grid.spacingY > 0"
+ "pattern.grid.startX + pattern.grid.spacingX * (pattern.grid.countX - 1) < this->sizeX"
+ "pattern.grid.startX < this->sizeX"
+ "pattern.grid.startX >= 0"
+ "pattern.grid.startY + pattern.grid.spacingY * (pattern.grid.countY - 1) < this->sizeY"
+ "pattern.grid.startY < this->sizeY"
+ "pattern.grid.startY <= vEndY"
+ "pattern.grid.startY >= 0"
+ "pattern.grid.startY >= vStartY"
+ "payloadSize=%d MaxDPCDefectPixelCount=%d"
+ "pcTWDesc->pTimeWarp != nullptr"
+ "pcaeDesc->m_stReceivedMsg.ref[0]"
+ "pcaeDesc->m_stReceivedMsg.ref[0] != 0"
+ "pcaeDesc->m_stReceivedMsg.ref[1] != 0"
+ "pcaeDesc->masterCam"
+ "pcaeRec->aeOutputMetaBuffer"
+ "pcaeRec->chConfig.SPDMode == CAE_SPLIT_PD_NOT_SUPPORTED || pcaeRec->chConfig.SPDMode == CAE_SPLIT_PD_ALWAYS_ON"
+ "pcaeRec->chConfig.citLossSPD > 0"
+ "pcaeRec->chConfig.mainClk > 0"
+ "pcaeRec->hFSM != 0"
+ "pcaeRec->historyCount > 0"
+ "pcaeRec->pSetting != 0"
+ "pcaeRec->pSetting->contextSwitchConfig != AE_SENSOR_CONFIG_INVALID"
+ "pcawbDesc"
+ "pcawbDesc && pcawbRec"
+ "pcawbDesc->confidenceMapInfo == nullptr"
+ "pcawbDesc->hFSM != nullptr"
+ "pcawbDesc->m_stReceivedMsg[CAWB_STATS_PIPE_INPUT_0].ref[0] != 0"
+ "pcawbDesc->m_stReceivedMsg[CAWB_STATS_PIPE_INPUT_0].ref[1] != 0"
+ "pcawbDesc->motionDataInfoPool->Available() > 0"
+ "pcawbDesc->pAWBMetaDataHostPreflash != 0"
+ "pcawbDesc->totalStatInputCount == 1"
+ "pcawbRec && pcawbDesc"
+ "pcawbRec->pSetting != 0"
+ "pceAlgoForGMC.addr != nullptr"
+ "pceAlgoForGMCDx.addr != __null"
+ "pceAlgoForGMCDy.addr != __null"
+ "pceAlgoForGMCRGOutput.addr != __null"
+ "pceInputResX == ResX"
+ "pceInputResY == ResY"
+ "pceUseCase != PDE_USE_CASE_TYPE_MAX"
+ "pdMode == SPLITPD_MODE_1_TO_8 || pdMode == SPLITPD_MODE_BINNED_1_TO_8"
+ "pdaf cmd total inqueue %d, bFoundDuplicated %u"
+ "pdafData"
+ "pdafSensorCal"
+ "pdeHostMetaData != nullptr"
+ "pdpBypassed || pdpSetup"
+ "pdpCfg.regSize <= CISP_GENERAL_PROCESS_PDP_MAX_REG_SIZE"
+ "pdpCfg.tblSize <= CISP_GENERAL_PROCESS_PDP_MAX_TBL_SIZE"
+ "pdpCfg.tblSize == kPdpMemSize"
+ "pdpPreset != 0"
+ "pdpcSettings->config.Bypass == 0"
+ "pearlFlow != nullptr"
+ "pearlMsg"
+ "pearlResponseSignal != (SEMA)0"
+ "pending req[%d]: section[%d]=%d"
+ "pending req[%d]: source=%d"
+ "perConfigOffsetX + config.output.sensorReadOutCropRect.x >= digitalCropOffsetX"
+ "perConfigOffsetY + config.output.sensorReadOutCropRect.y >= digitalCropOffsetY"
+ "peridotCalib->version == CISP_PERIDOT_CALIB_VERSION"
+ "peridotProjectorCommandSema != (SEMA)0"
+ "peridotProjectorLowPrioDoneSema != (SEMA)0"
+ "peridotProjectorLowPrioQuitSema != (SEMA)0"
+ "peridotProjectorLowPrioTask != (TASK)0"
+ "peridotSensorApplyNextSema != (SEMA)0"
+ "peridotSensorLowPrioDoneSema != (SEMA)0"
+ "peridotSensorLowPrioQuitSema != (SEMA)0"
+ "peridotSensorLowPrioTask != (TASK)0"
+ "peridotSensorStreamingCommandSema != (SEMA)0"
+ "period >= 1"
+ "personMask FFCFOV: [%.4f, %.4f, %.4f, %.4f]"
+ "pfl >= pConfig->PFL_gdc_min"
+ "pfl >= pConfig->apsEFL"
+ "pfpnrRbcData != 0"
+ "phdr->size == cmdPacketLen"
+ "photometerAWBMetadata != nullptr"
+ "phyOffsetToMappedOffset"
+ "picIn->Stride() == 448"
+ "picLut.GetNumOfPoints() == (sizeof(mp_regs->ab.Dsc.r.DuLutPic) / sizeof(mp_regs->ab.Dsc.r.DuLutPic[0]))"
+ "pin < buffPools"
+ "pin < inputs"
+ "pin < outputs"
+ "pin < portBuffPools"
+ "pin < portInputs"
+ "pin < portOutputs"
+ "pioDmaNotify != (SEMA)0"
+ "pioIntId != 0"
+ "pioMem != nullptr"
+ "pioPacketBufSizeIn ==0 || (NULL != pPioPacketBufIn && (((size_t)pPioPacketBufIn % (1<<2)) == 0) )"
+ "pioPacketBufSizeInDW > pioPacketBufContentSizeInDW"
+ "pioSize <= cfgSize"
+ "pioSizeInDW >= segSizeInDW"
+ "piodmanotify != (SEMA)0"
+ "piodmanotify2 != (SEMA)0"
+ "pipe %d / %d, hSif[pipeId] %p"
+ "pipe %d SetFrameDestinationInfo sifDmaDst %d bank %d"
+ "pipe %s  sifDmaDst %d fepDst %d pCap %p pSifrCap %p"
+ "pipe %s  sifDmaDst %d pCap %p pSifrCap %p"
+ "pipe < MAX_ISP_STATS_RESOURCES"
+ "pipe >= 0 && pipe < MAX_ISP_STATS_RESOURCES"
+ "pipe:%d fc:%llu rv:%f fv%f unexpected!!"
+ "pipeId %d sifDmaDstId %d bank %d"
+ "pipeId %d sifDmaDstId %d bank %d hSifDMAOut %p regBankOpMode:%d"
+ "pipeId < ISP_RESOURCE_STATS_TOT"
+ "pipeId == CIC_VC_PIPELINE_MAIN"
+ "pipeId >= 0 && pipeId < MAX_ISP_VISPIPE_RESOURCES"
+ "pipeIndex < pipeNbr"
+ "pipeType < CIC_VC_PIPELINE_TOT"
+ "pipeType:%u"
+ "pipe[0].nbrOfSection > 0"
+ "pipelineCnt > 0 && pipelineCnt <= MAX_VC_PIPELINE_PER_CHANNEL"
+ "pixelInBuffer == 0"
+ "pixelInBuffer > 0"
+ "pixelInCol != 0"
+ "pixelInRow != 0"
+ "pixelSizeUm=%f"
+ "pixelSizeUm=%f vs %f"
+ "pixelSize_mm != 0.0f"
+ "platform %d %s"
+ "pls defaults write com.apple.coremedia EnableMetadataSections -array 72"
+ "pointCloud"
+ "pointCloudData != nullptr"
+ "pointCloudData->totalNumberOfSpotsInPointCloud <= TOF_DEPTH_POINT_CLOUD_MAX_SPOTS"
+ "pointCloudData->totalNumberOfSpotsInPointCloud > 0"
+ "pointer"
+ "pointer != 0"
+ "pointer != NULL"
+ "pointer == VP(messagePhys)"
+ "points"
+ "points: [%d][%d]: %d, %d, %d\n"
+ "polling syscfg %016llx\n"
+ "pool != (void *)0"
+ "pool != 0"
+ "pool == ALIGN_DOWN(pool, CMMU::CacheLineSize())"
+ "pool->BufferSizeGet() >= sizeof(sMetaData)"
+ "poolArray != 0"
+ "poolArray[container->attach.id] == 0"
+ "poolArray[id] != 0"
+ "poolBase[ch]"
+ "poolBufferReceived != 0"
+ "poolBufferReturned != 0"
+ "poolConfig->eSharedPoolType < CISP_SHARED_POOL_TOT"
+ "poolConfig->grpDest.grpId < MAX_GROUPS"
+ "poolEntry != nullptr"
+ "poolInfo->eSharedPoolType < CISP_SHARED_POOL_TOT"
+ "poolInfo->grpDest.grpId < MAX_GROUPS"
+ "poolPinScale0 %zu poolPinScale1 %zu"
+ "poolReturn->grpDest.grpId < MAX_GROUPS"
+ "poolReturn->poolID < ((chTot * CIMAGEFLOW_POOL_ID_TOT)+(CISP_SHARED_POOL_TOT*MAX_GROUPS))"
+ "poolStartBase=%zu"
+ "poolsize >= CBufferPoolStatic::PoolSizeGet(buffers, bundledBlocks, CBufferPoolStatic::size, CBufferPoolStatic::alignment)"
+ "poolsizeIn >= CBufferPoolStatic::PoolSizeGet(buffers, newbundledBlocks, newsize, newalignment)"
+ "port < CLPDP_MAX_SIDEBAND_OUTPUT"
+ "port < inports"
+ "port < outports"
+ "pos < 512"
+ "pos < mSize"
+ "pos >= 0 && pos < mSize"
+ "pos2->ispTimeStamp >= pos1->ispTimeStamp"
+ "post-process"
+ "postOutputToCAF"
+ "postProcessLO"
+ "postrc == FFW_OK"
+ "power != NULL"
+ "powerDomain >= PowerDomain_Id_H17_START && powerDomain < PowerDomain_Id_H17_END"
+ "powerIOUTA0 <= maxCurrentOTP[0]"
+ "powerIOUTB0 <= maxCurrentOTP[1]"
+ "powerIOUTB1 * 1000 <= hFlood->GetCalCurrent() + 1000"
+ "powerIOUTB1 <= maxCurrentOTP[2]"
+ "powerOffSectionSupported == 1"
+ "powerOnSectionSupported == 1"
+ "powerRailMap"
+ "powerSequenceMap"
+ "ppAPSPosition"
+ "ppTablePool[tableId]->BufferAvailable()"
+ "pre-process"
+ "preBESCrop.x >= 0"
+ "preBESCrop.y >= 0"
+ "preDescritporBuf != nullptr"
+ "preDescritporBufSize <= MAX_DESCRIPTOR_BUF_SIZE"
+ "preFlashEIT %f mainFlashEIT %f ratio %f\n"
+ "preISPDownsizeRatio <= 2"
+ "preISPRect:x=%d,y=%d %dx%d"
+ "preIn.x < (1 << preIn.subFactPowH)"
+ "preIn.y < (1 << preIn.subFactPowV)"
+ "preProcess"
+ "preRgLogRatio=%.2f, preBgLogRatio=%.2f"
+ "preScaleHFactor <= 3"
+ "preScaleOutputWidth <= 2048"
+ "preScaleOutputWidth >= 16 && preScaleOutputHeight >= 16"
+ "predictedAve obj %d scene %d face %d\n"
+ "predictedFaceAve %f ltmAdjustmentRatio %f\n"
+ "predictedSceneAve %f ltmAdjustmentRatio %f\n"
+ "preivewCrop.height <= pZoomParam->rawDMASrcCropRect.height"
+ "preivewCrop.height <= zoomParam.rawDMASrcCropRect.height"
+ "preivewCrop.width <= pZoomParam->rawDMASrcCropRect.width"
+ "preivewCrop.width <= zoomParam.rawDMASrcCropRect.width"
+ "preprocessMetadata"
+ "preset != nullptr"
+ "preset->allTables[i]->mainTbl != nullptr"
+ "preset->allTables[i]->numEntriesMain != 0"
+ "preset->allTables[i]->tableName != nullptr"
+ "preset->numTable < MAX_LINEAR_SOFT_GAIN_ENTRY_PER_PRESET"
+ "preset->numTable <= MAX_LINEAR_SOFT_GAIN_ENTRY_PER_PRESET"
+ "prev"
+ "prev != nullptr"
+ "prev %.3f %.3f %.3f %.3f\n"
+ "prev Rect[%d %d %d %d] validBufRect[%d %d %d %d]"
+ "prev framename %s, width = %d, stride = %d, height = %d "
+ "prevCoolRWP=%.3f prevCoolBWP=%.3f"
+ "prevMatchBuffBaseAddrHigh = 0x%x"
+ "prevMatchBuffBaseAddrLow = 0x%x"
+ "prevRect[%d %d %d %d] validBufRect[%d %d %d %d]"
+ "prevSifrRDOffset != nullptr"
+ "prevUpdate != NULL"
+ "prevUpdate != nullptr"
+ "prevUpdate == NULL"
+ "prevUpdate->sifrSkipRatio == 0"
+ "prevUpdate->splitPDOn == true"
+ "prev_count > 0"
+ "previewCh < CAM_CH_TOT"
+ "previewCh set to %hhu"
+ "previewOutWidth: %u previewOutHeight %u"
+ "previewScaler ch %zu [%u] x %u y %u w %u h %u"
+ "previous keypointCount %d"
+ "previousAddr < currentAddr"
+ "prevmetadata %p\n"
+ "pri: ch %zu outBufX=%d, outBufY=%d, XInPreview=%d, YInPreview=%d\n"
+ "priParams.priCfgIdx2PriGroupNum[currPriCfgIdx] != PERIDOT_PRI_GROUP_INVALID"
+ "priParams.priCfgIdx2PriGroupNum[currPriCfgIdx] == CISP_PERIDOT_PRIS_IN_BANK_CONFIG_1"
+ "primary time delta %f"
+ "primaryFaceID != (uint32_t) -1"
+ "printAcANSTControl"
+ "printDBGModes"
+ "printLaccInputConfig"
+ "printMatrix"
+ "printTimewarpHostMetadata"
+ "prio <= RTK_THREAD_PRIORITY_MAX"
+ "priority != 0"
+ "priority <= RTK_THREAD_PRIORITY_MAX"
+ "procedureId=%d, numIoBuffers=%d"
+ "process"
+ "processCmdOnly == true"
+ "processDiff"
+ "processFFC key done bgNumPts = %d, fgNumPts = %d"
+ "processSpeedRamping"
+ "processStartStopRequest"
+ "processTemporalStableMetaDataMatchSlave"
+ "processed ch%zu, received %zu buffers\n"
+ "processedCmdCounter == 0"
+ "processingFFCKeys"
+ "processingFFCMatches"
+ "profilingCntClr = 0x%x"
+ "profilingCntEn = 0x%x"
+ "profilingHaltCnt = 0x%08x profilingPacketCnt = 0x%08x"
+ "progDesc.modelVer == kAneModelContracts::versions[mInfo.programId]"
+ "progDesc.numProcedures <= maxAneIpcProgProcedure"
+ "progDesc.procedures[i].iobufs[j].type < eCSneBufferDescriptorType_Max"
+ "progDesc.procedures[i].numIoBuffers < maxAneIpcProgCallBufNbr"
+ "program input size: %ld"
+ "program[%d] procedure [%d]: count[%d, %d, %d]\n"
+ "program[%d]: size [%lu, %lu, %lu]\n"
+ "projector control sequence:\n"
+ "projectorUpdate.currentCmd"
+ "ps"
+ "pstEITParams->uBinInverseGainFactor > 0"
+ "pstEITParams->uMinEIT >= pstEITParams->uVirtFrmWidth"
+ "pstEITParams->uVirtFrmWidth > 0"
+ "pstEITParams->uVirtFrmWidthSPD > 0"
+ "pstEITParams->uVirtFrmWidthSPD >= pstEITParams->uVirtFrmWidth"
+ "pstEITParams->uVirtFrmWidthSec > 0"
+ "pstEITParams->uVirtFrmWidthSecSPD > 0"
+ "pstLSParamsFull != 0"
+ "pstLSParamsFull->channelGR.gridCountX <= LENS_SHADING_MAX_GRID_POINTS_X"
+ "pstLSParamsFull->channelGR.gridCountX <= OIS_LENS_SHADING_MAX_GRID_POINTS_X"
+ "pstLSParamsFull->channelGR.gridCountY <= LENS_SHADING_MAX_GRID_POINTS_Y"
+ "pstLSParamsFull->channelGR.gridCountY <= OIS_LENS_SHADING_MAX_GRID_POINTS_Y"
+ "pstLSParamsFull->channelR.gridOffsetX == pstLSParamsFull->channelGR.gridOffsetX == pstLSParamsFull->channelGB.gridOffsetX == pstLSParamsFull->channelB.gridOffsetX"
+ "pstLSParamsFull->channelR.gridOffsetY == pstLSParamsFull->channelGR.gridOffsetY == pstLSParamsFull->channelGB.gridOffsetY == pstLSParamsFull->channelB.gridOffsetY"
+ "pstStatsHdr != 0"
+ "ptSizeInWord = %d vs. pointSize = %d\n"
+ "ptSpeedTable != 0"
+ "ptr"
+ "ptr && numRegs"
+ "ptrToSharedMemIndex"
+ "ptsAdjustment %f currentStartCaptureTime: %f currentCaptureTime %f\n"
+ "publish: visegMask %u anstMask %u"
+ "purge"
+ "purpleWindowWidth >= pDescr->paramRaw.fsclOutWidth && purpleWindowHeight >= pDescr->paramRaw.fsclOutHeight"
+ "put callback to callbackFreeList fail\n"
+ "put callback to list fail\n"
+ "pwrRailDescr"
+ "pwrRails"
+ "pwthresh_t10=0x%08X"
+ "pwthresh_t2=0x%08X"
+ "pwthresh_t3=0x%08X"
+ "pwthresh_t4=0x%08X"
+ "pwthresh_t5=0x%08X"
+ "pwthresh_t6=0x%08X"
+ "pwthresh_t8=0x%08X"
+ "pyrBitDepth %u"
+ "pyrCrop->x >= 0"
+ "pyrCrop->y >= 0"
+ "pyrInd == 0 || srcPyrInfo.heights[pyrInd] <= srcPyrInfo.heights[pyrInd - 1]"
+ "pyrInd == 0 || srcPyrInfo.widths[pyrInd] <= srcPyrInfo.widths[pyrInd - 1]"
+ "pyrInputFrameHeight > 0"
+ "pyrInputFrameWidth > 0"
+ "pyrPackType %u input w %u h %u"
+ "pyrWidthRDown[%d %d %d %d] adjustWidth=%f pyrRatio=%f"
+ "pyrWidthRUp[%d %d %d %d] adjustWidth=%f pyrRatio=%f"
+ "pyrWidth[bufId] * pyrHeight[bufId] <= pPplInfo->bufOutPyrUv->Size(bufId)"
+ "pyrWidth[bufId] * pyrHeight[bufId] <= pPplInfo->bufOutPyrY->Size(bufId)"
+ "pyr[%d](%d %d %u) offset(%d %d) in (%d %d) out (%d %d)"
+ "pyrd preview size %u %u"
+ "pyrd rect %u %u %u, %u"
+ "pyrdbbox %.3f %.3f %.3f, %.3f"
+ "qIdx < maxAlgoCtrlDupCmdQSize"
+ "qIdx < maxQSize"
+ "qSize == chDescr[ch].msgQueue->Size() + 1"
+ "qch"
+ "qch != nullptr"
+ "quadraPattern mismatch %d(m) vs %d(s)"
+ "queue != (FFWQUEUE)0"
+ "queue != (QUEUE)0"
+ "queue != 0"
+ "queueDepth %zu > 1"
+ "queueDepth > 1"
+ "queueEmptyBuffer != (FFWQUEUE)0"
+ "queueEmptyBuffer != (QUEUE)0"
+ "queueMutex != (FFWMUTEX)0"
+ "queuePool != 0"
+ "queuePool == 0"
+ "queues <= MAX_AVAILABLE_SIFQ"
+ "queues:%llu max avl queues:%d"
+ "quitSema != 0"
+ "r"
+ "r == 0"
+ "rId < PDAF::MLAF_NREGIONS"
+ "radScale <= 5"
+ "radialPositionsPixel"
+ "rail < NUM_ELEMENTS(powerOnTimeCode)"
+ "rail < POWER_RAIL_ALL"
+ "rail <= POWER_RAIL_ALL"
+ "range != 0"
+ "range2"
+ "rangeAllocated >= 0.0f"
+ "rate < AOP_MOTION_RATE_COUNT"
+ "rateOfChange=%.4f"
+ "ratio > 0"
+ "raw input size %u %u pyrd %u %u"
+ "rawBuf"
+ "rawBuffer != NULL"
+ "rawBuffer->Size() >= pRes->mdInfo.kINPUT_ROW_STRIDE * pRes->mdInfo.kHEIGHT"
+ "rawBuffer->Stride() >= pRes->mdInfo.kINPUT_ROW_STRIDE"
+ "rawDMASrcCropRect %d %d"
+ "rawHeight %d > CAR_MAX_OUT_HEIGHT %d"
+ "rawHexData"
+ "rawMLVNRSrcIndex >= 0 && rawMLVNRSrcIndex < MAX_SRC_INPUT_DMA"
+ "rawRect (%d %d %d %d)"
+ "rawSrcIndex >= 0"
+ "rawStreamingHeight > 0"
+ "rawStreamingWidth > 0"
+ "rawWidth %d > CAR_MAX_OUT_WIDTH %d"
+ "rawWidth=%u, rawHeight=%u, FullGridSizeX=%lu, FullGridSizeY=%lu\n"
+ "rawoffset %d Size %d %d %d total %d\n"
+ "rc"
+ "rc != FFW_WAIT_CONFLICT"
+ "rc == 0"
+ "rc == 0 && sz <= pRes->inputBufLen(AC_NET_UID_ANST, procedureId, 0)"
+ "rc == 1"
+ "rc == CPCEFLOW_STATE_DATA_SET"
+ "rc == CPCEFLOW_STATE_DATA_SET_PARTIAL"
+ "rc == CPCEFLOW_STATE_INITIALIZED"
+ "rc == FFW_OK"
+ "rc == FFW_SUCCESS"
+ "rc == FLOW_RC_OK"
+ "rc == RTK_ST_OK"
+ "rc == true"
+ "rc >= -63"
+ "rc >= 0"
+ "rc1 == FFW_SUCCESS"
+ "rc2 == 0"
+ "rc=%i expected=%i"
+ "rc==0"
+ "rcLocal == 0"
+ "rc_get == FFW_OK"
+ "rc_post == 0"
+ "rcam Frame Skip %d"
+ "rdptr + sizeof(sIOPRingBufferMsgHeaderV2_t) < localCopyWrPtr"
+ "rdptr + sizeof(sIOPRingBufferMsgHeaderV2_t) < pBuf->_header._size"
+ "rdptr + sizeof(sIOPRingBufferMsgHeader_t) < localCopyWrPtr"
+ "rdptr + sizeof(sIOPRingBufferMsgHeader_t) < pBuf->_header._size"
+ "reSizeStepX < RES_STEP_MAXIMUM"
+ "reSizeStepY < RES_STEP_MAXIMUM"
+ "read file %s to %p size %zu"
+ "readData != 0"
+ "readData != NULL"
+ "readFakeInput"
+ "read_offset : %d , bank_size : %zu"
+ "read_result"
+ "readback 0x%x"
+ "readbuf"
+ "reader"
+ "readout"
+ "readoutTime is %d\n"
+ "readySema != (SEMA)0"
+ "realOffset <= PIODMA_OFFSET_MAX_VALUE"
+ "realOffset <= endOffset"
+ "rear stereo (%d) partial-flow timeout semaphore is NULL!"
+ "recCh < cMaxChannel"
+ "received HPP buffer from Algo server."
+ "received PDC buffer from Algo server."
+ "received buffer from algo server ch=%ld, buffers=%ld"
+ "received buffer from algo, ch%zu, frameCnt=%u"
+ "received compress config: inCompressEn %d outCompressEn %d\n"
+ "received input from un-supported channel %zu (instead of %zu or %zu)"
+ "recipX <= 268435456 && recipX >= 7456540"
+ "recipY <= 1073741824 && recipY >= 4198404"
+ "record"
+ "rect != 0"
+ "rectIn %u %u %u %u rectOut %u %u %u %u"
+ "rectOut.height == rectIn.height"
+ "rectOut.width == rectIn.width"
+ "rectOut.x == rectIn.x"
+ "rectOut.y == rectIn.y"
+ "recvAddr == sendAddr"
+ "recycleArray != 0"
+ "ref != NULL"
+ "ref != nullptr"
+ "ref %d out %d"
+ "ref && (buffers == 1) && ref[0]"
+ "ref->size >= sizeof(LZ4SEPPearlRefFrameHeaderV0)"
+ "ref0 != nullptr && ref1 != nullptr"
+ "ref0->active == true"
+ "ref0->data != __null"
+ "refB[EXTSLAF_BUF_OUTPUT_CONFIDENCE]"
+ "refB[EXTSLAF_BUF_OUTPUT_DISPARITY]"
+ "refBinFactor > 0"
+ "refBuf"
+ "refIn[j] >= refIn[j-1]"
+ "refLut.GetNumOfPoints() == (sizeof(mp_regs->ab.Dsc.r.DuLutRef) / sizeof(mp_regs->ab.Dsc.r.DuLutRef[0]))"
+ "refSensorConfigForManualAE != AE_SENSOR_CONFIG_INVALID"
+ "ref[(0)] != nullptr"
+ "ref[(0)]->DataPointer() != nullptr"
+ "ref[(1)] != nullptr"
+ "ref[(1)]->DataPointer() != nullptr"
+ "ref[0]"
+ "ref[0] != 0"
+ "ref[0] != NULL"
+ "ref[0] != nullptr"
+ "ref[0] && ref[1]"
+ "ref[0]->PayloadGet() == sizeof(sAFMetaData)"
+ "ref[0]->Size() == maxCmdBufSize"
+ "ref[1]"
+ "ref[1] != 0"
+ "ref[2]"
+ "ref[2] != 0"
+ "ref[3]"
+ "ref[3] != 0"
+ "ref[6] == 0"
+ "ref[ANST_BUF_ANST_VID]"
+ "ref[ANST_BUF_PYRUV]"
+ "ref[ANST_BUF_PYRY]"
+ "ref[ANST_BUF_SMETA]"
+ "ref[CMLAF_MEM_TYPE_DEPTH_RAW_BUF]->Size() >= pRes->mInfo.desc.procedures[procedureId].iobufs[0].size"
+ "ref[CMLAF_MEM_TYPE_RGB_RAW_BUF]->Size() >= pRes->mInfo.desc.procedures[procedureId].iobufs[1].size"
+ "ref[CVIO_BUF_INPUT] != nullptr"
+ "ref[MLAF_BUF_INPUT_HOST_META]"
+ "ref[MLAF_BUF_INPUT_PATCH]->Size() >= pRes->mInfo.desc.procedures[procedureId].iobufs[0].size"
+ "ref[MLAF_BUF_INPUT_SENSOR_RAW]"
+ "ref[i]"
+ "reference result:"
+ "regCmnSetting->pRegVals &&regCmnSetting->sSize"
+ "regDoneSema != 0"
+ "regSpec[REG_FRAME_COUNT].len <= sizeof(regV.bytes)"
+ "regSpec[REG_FRAME_HEIGHT].len >= 2 && *(pData + 2) == (regSpec[REG_FRAME_HEIGHT].addr + 1)"
+ "regSpec[REG_FRAME_LENGTH].len >= 2 && *(pData + 2) == (regSpec[REG_FRAME_LENGTH].addr + 1)"
+ "regSpec[REG_FRAME_WIDTH].len >= 2 && *(pData + 2) == (regSpec[REG_FRAME_WIDTH].addr + 1)"
+ "regSpec[REG_H_START_OFFSET].len >= 2 && *(pData + 2) == (regSpec[REG_H_START_OFFSET].addr + 1)"
+ "regSpec[REG_LINE_LENGTH].len >= 2 && *(pData + 2) == (regSpec[REG_LINE_LENGTH].addr + 1)"
+ "regSpec[REG_V_START_OFFSET].len >= 2 && *(pData + 2) == (regSpec[REG_V_START_OFFSET].addr + 1)"
+ "regStatus=%d, mNumInliersFound=%d"
+ "region %d %d %d %d\n"
+ "registerBankOpMode == OPMODE_SINGLE_BANK"
+ "registersDumpBuffer != nullptr"
+ "rejectDecision"
+ "release DPC buffers ch=%zu"
+ "release LSC buffers ch=%zu"
+ "release i=%d SLAFSyncBufs[i]=%p"
+ "release masterHostMetaBuf %p"
+ "release previous %p frameCount %u, ch %u(%zu)"
+ "release slaveHostMetaBuf %p"
+ "releaseSlafMaskBuffer"
+ "release_mutex"
+ "releasing pSLAFbufferNcc2AlgoCtrl"
+ "remaining <= check"
+ "remaining >= 0"
+ "repeats != NULL"
+ "replayResolution %u"
+ "replicateEn == 1"
+ "report face %.2f %.2f %.2f %.2f"
+ "report face rawbox %.2f %.2f %.2f %.2f"
+ "req"
+ "req != nullptr"
+ "req 0x%x sifr %d exp %llu gA %d gD %d rdo %d hr %.2f spd %d vhdr %d"
+ "req 0x%x sifr %d exp %llu gL %d rdo %d hr %.2f spd %d vhdr %d"
+ "req->IspDmaMemDumpSizeTot <= index * sizeof(uint32_t)"
+ "req022-macro_mode_base.json"
+ "reqEntry != nullptr"
+ "reqEntryList != nullptr"
+ "reqEntryMatch != nullptr"
+ "reqID %d mallocSize %zu, deferCount %zu, buffpool %p, requests %d"
+ "reqId < nbrOfReq"
+ "reqMatch != nullptr"
+ "reqPoolEntry != nullptr"
+ "reqRunningReq.sourceGoPending != 0"
+ "request %d, ev0Ratio %d, expBias %d,  cDiscontinuity %d"
+ "requestCnt < CAllocatorLinear::kMaxRequests"
+ "requestQueueIndex < AISP_ISPCONFIG_PIPE_EXCLAVECONFIGOPEN_REQUESTQUEUEDEQUEUE_DIM0"
+ "requestQueueIndex < AISP_ISPCONFIG_PIPE_EXCLAVECONFIGOPEN_REQUESTQUEUEIRQ_DIM0"
+ "requestUpdate.requestId >= currRequestId"
+ "required stride %d size %d configured stride %zu size %zu"
+ "res == 0"
+ "resId < MAX_ISP_FEP_RESOURCES"
+ "resPool != 0"
+ "resPool == 0"
+ "resStepX < NCCPROC_RES_STEP_MAXIMUM"
+ "resStepY < NCCPROC_RES_STEP_MAXIMUM"
+ "reset"
+ "reset DSID: cmpnDamIdx=%d, offset=0x%x, newVal=0x%x"
+ "reset cached sifr fep thumbnail output 2 host"
+ "resetMultiScaleDetectors"
+ "resetOnTripodDetectors"
+ "resistance"
+ "resources.buffers[i] == nullptr"
+ "resources.destPipe != nullptr"
+ "resources.extraSize <= sizeof((&((&(msg))->payload.buff))->extra)"
+ "responsesMem[i].respSema != 0"
+ "restart"
+ "result"
+ "result == 0"
+ "resultQues[%u][%u]=%p"
+ "results.isUserEngaged == false"
+ "results.numResults <= sizeof(results.faces)/sizeof(results.faces[0])"
+ "results.numResults == 1"
+ "results.numResultsInFov <= results.numResults"
+ "ret != 0xffffffff"
+ "ret %u ref %u"
+ "ret < ISPHWH17CMPNDMAIDX_TOT"
+ "ret == FFW_OK"
+ "ret == FFW_SUCCESS"
+ "ret == true"
+ "ret >= 0"
+ "ret.faces[i].category == ref.faces[i].category"
+ "ret.faces[i].objectId == ref.faces[i].objectId"
+ "retCode == kAcReturn_NoError"
+ "retain == CBuffer::suspended"
+ "retain latest pCacheHostMetaBuffer=%p idx %d\n"
+ "retain masterHostMetaBuf %p frameCount %u, ch %u(%zu)"
+ "retain ref[2] %p RetCnt %d\n"
+ "retain slaveHostMetaBuf %p frameCount %u, ch %u(%zu)"
+ "return %02x%02x\n"
+ "return & delete shared pool %p"
+ "rfpnHeight"
+ "rfpnWidth"
+ "rgGainCoeff   = %6u %6u %6u \n"
+ "rgbDownscaledInput.bin"
+ "rgbHistograms[numBins*i + j] <= expectedCount"
+ "rgbMetadata != nullptr"
+ "rma0Mode = 0x%x, rma1Mode = 0x%x, rma2Mode = 0x%x, rma3Mode = 0x%x"
+ "rma0Size = %d"
+ "rma0StartAddrHi = 0x%x"
+ "rma0StartAddrLow = 0x%x"
+ "rma1Size = %d"
+ "rma1StartAddrHi = 0x%x"
+ "rma1StartAddrLow = 0x%x"
+ "rma2Size = %d"
+ "rma2StartAddrHi = 0x%x"
+ "rma2StartAddrLow = 0x%x"
+ "rma3Size = %d"
+ "rma3StartAddrHi = 0x%x"
+ "rma3StartAddrLow = 0x%x"
+ "roiAdd"
+ "roiAdd service failed"
+ "roiType != PDAF::RoiType::NOTSET"
+ "rotateUpright"
+ "rotation=%.4f dt=%.1f tripod=%.1f ms stable=%d"
+ "rotationAxis < ROTATION_AXIS_COUNT"
+ "rotation_deg"
+ "rowLineFlags != nullptr"
+ "rowLineFlags is null!"
+ "rowMin >= 0"
+ "rowStart[i] >= rowStart[i-1]"
+ "rpcWaitSem != (SEMA)0"
+ "rpcWaitSema != (SEMA)0"
+ "rscl RBC fpnrDMAOffsetX=%d, fpnrDMAOffsetY=%d, fpnrDMASrcWidth=%d, fpnrDMASrcHeight=%d"
+ "rsclId=%d"
+ "rsclProcDmaEn == rsclProcDmaEnabled"
+ "rsmProcDmaEn == rsmProcDmaEnabled"
+ "rtDmaId < H17RTDMA_ID_TOT"
+ "rtkitSystemTaskList != 0"
+ "rtosISRHandle != 0"
+ "run count %u"
+ "run: scp h10isp/filters/AICam/anst/vecotr/* root@device:/var/mobile/Media/DCIM/anst/"
+ "runAnstOnOneExtFrame res %u"
+ "runKeyGeneration"
+ "runKeyGeneration_2"
+ "runLaccRansac = %d, LACC_RANSAC = %d, ISP_RANSAC=%d, CMP_RANSAC=%d"
+ "runNCCproc: fpWidth = %d, fpHeight = %d, spWidth = %d, spHeight=%d"
+ "runNCCproc: img width = %d, height = %d"
+ "runNCCproc: in BAND 2//"
+ "runNCCproc: in BAND 3"
+ "runNccMatching"
+ "runSlotConfig != 0"
+ "running req[%d]: section[%d]=%d"
+ "running req[%d]: source=%d"
+ "rv:%f fv:%f srcDone:%f pipeDone:%f ret:%d"
+ "rval != 0"
+ "rvcIn.tblSize == kRvcMemSize"
+ "rwa_f_thr=0x%08X"
+ "rwa_me=0x%08X"
+ "rwa_num_samples=0x%08X"
+ "rwa_smpl_time=0x%08X"
+ "s0(w):w=%d,h=%d,size=%ld,stride=%d,cirOffsetY=%d,offsetY=%d"
+ "s0:w=%d,h=%d,size=%ld,stride=%d,cirOffsetY=%d,offsetY=%d"
+ "s1(c):w=%d,h=%d,size=%ld,stride=%d,cirOffsetY=%d,offsetY=%d"
+ "s1(cw):w=%d,h=%d,size=%ld,stride=%d,cirOffsetY=%d,offsetY=%d"
+ "s1(l):w=%d,h=%d,size=%ld,stride=%d,cirOffsetY=%d,offsetY=%d"
+ "s1(lw):w=%d,h=%d,size=%ld,stride=%d,cirOffsetY=%d,offsetY=%d"
+ "s1_lsb"
+ "s2rSema"
+ "sCIspGeneralProcessParamHeader totDescriptors: %d\n"
+ "sDefectTable"
+ "sMetaBuffer"
+ "sSensorPixelRect != 0"
+ "sUpdate->sifrSkipRatio == prevUpdate->sifrSkipRatio"
+ "saliency %d saliencyOD %d viseg %d anstProcedureId=%u"
+ "sampleStep != 0"
+ "sapId 0x%x with nbrOfBuf %d subPacketSize %d send %zu post+ %zu receive %zu"
+ "saveANSTInput %d"
+ "saveDataFile"
+ "saveDebugData %u"
+ "saveInputCount = %d\n"
+ "saveIntermediateOutput = %d\n"
+ "saveNetOut %d"
+ "scale == 0"
+ "scale > 0"
+ "scale clrproc preview %.3f %.3f %.3f"
+ "scale pyrd preview %.3f %.3f %.3f"
+ "scale%d(warp):w=%d,h=%d,dmaFmt=%d,size=%ld,stride=%d,base=%p"
+ "scale%d:w=%d,h=%d,dmaFmt=%d,size=%ld,stride=%d,base=%p"
+ "scale0(warp):cmpBase=%p,size(hdr:cmp)=(%ld:%ld),offset=(%d,%d)"
+ "scale0(warp):w=%d,h=%d,size=%ld,stride=%d,base=%p,bCompEn=%d"
+ "scale0:ForceUncompEn=%d, cmpStrideEn=%d, scaleWidth=%d, strideOfTileRowInBytes=%d"
+ "scale0:cmpBase=%p,size(hdr:cmp)=(%ld:%ld),off=(%d,%d)"
+ "scale0:w=%d,h=%d,size=%ld,stride=%d,base=%p,bCompEn=%d"
+ "scale1(chroma warp):cmpBase=%p,size(hdr:cmp)=(%ld:%ld),off=(%d,%d)"
+ "scale1(chroma warp):size=%ld,stride=%d,base=%p"
+ "scale1(chroma):ForceUncompEn=%d, cmpStrideEn=%d, scaleWidth=%d, strideOfTileRowInBytes=%d"
+ "scale1(chroma):cmpBase=%p,size(hdr:cmp)=(%ld:%ld),off=(%d,%d)"
+ "scale1(chroma):size=%ld,stride=%d,base=%p"
+ "scale1(luma warp):cmpBase=%p,size(hdr:cmp)=(%ld:%ld),off=(%d,%d)"
+ "scale1(luma warp):w=%d,h=%d,size=%ld,stride=%d,base=%p,bCompEn=%d"
+ "scale1(luma):cmpBase=%p,size(hdr:cmp)=(%ld:%ld),off=(%d,%d)"
+ "scale1(luma):w=%d,h=%d,size=%ld,stride=%d,base=%p,bCompEn=%d"
+ "scale1:ForceUncompEn=%d, cmpStrideEn=%d, scaleWidth=%d, strideOfTileRowInBytes=%d"
+ "scalerCroppedRect.y == 0"
+ "scalerCroppedRect=[x=%d y=%d w=%d h=%d]"
+ "scalerId == VFLOWH17_AUX_SCL"
+ "scalerSel == 0"
+ "scalex %.3f scaley %.3f"
+ "scan window update sta %d size %u"
+ "scanStartY"
+ "scanY %u rowTime %f vsync2MidRo %f"
+ "scheme != AWB_SCHEME_PIXEL_FILTER && scheme != AWB_SCHEME_TAP_TO_WB"
+ "scl=%d,in:(%d,%d),inFormat=%d,gdcEnable=%d,out:(%d,%d),outFormat=%d,paddingRows=%d,gridOffset:(%d,%d)\n"
+ "scratchData - (uint8_t*)scratchBuffer.data <= (int)minScratchBufferBytes(m_imgHeight, m_imgWidth, m_numInputChannels, oc)"
+ "sec: ch %zu outBufX=%d, outBufY=%d, distortionCenterXInSecondary=%d, distortionCenterYInSecondary=%d\n"
+ "secState == ARIES_STS_SECURITY_STATE_DEV_FUSED || secState == ARIES_STS_SECURITY_STATE_PROD_FUSED || secState == ARIES_STS_SECURITY_STATE_WAFERTEST"
+ "secondaray time delta %f"
+ "secondary"
+ "section:%zu enabled but sz is 0 for ch:%zu"
+ "sectionBufSize=%d, eachBufSize=%d, bufOffset=%d\n"
+ "sectionId < ISPHWH17SectionId_MaxNbr"
+ "sectionId < nbrOfSections"
+ "sectionId <= nbrOfSections"
+ "sectionId: %d, dmaId: %d\n"
+ "sectionIdIn < ISPHWH17SectionId_MaxNbr"
+ "sectionList[i] < ISPHWH17SectionId_MaxNbr"
+ "secureM3QueueMutex != (FFWMUTEX)0"
+ "segmentId < ISPHWH17SegmentId_MaxNbr"
+ "selIndex < ISPHWH17PipeSel_MaxNbr"
+ "sel_hs_res=0x%08X"
+ "selectFace"
+ "selected != -1"
+ "self != nullptr"
+ "sema != 0"
+ "sema != NULL"
+ "sema == 0"
+ "semaAEDone != (SEMA)0"
+ "semaAFDone != (SEMA)0"
+ "semaAWBDone != (SEMA)0"
+ "semaAfMetaDone != (SEMA)0"
+ "semaAllStatsDone != (SEMA)0"
+ "semaArray != (SEMA *)0"
+ "semaArray[ICPrepareStopSema] != (SEMA)0"
+ "semaArray[IRRestartStreamingSema] != (SEMA)0"
+ "semaArray[armSema] != (SEMA)0"
+ "semaArray[axiErrorSema] != (SEMA)0"
+ "semaArray[bandwidthTimerSema] != (SEMA)0"
+ "semaArray[cilDataBlockedSema] != (SEMA)0"
+ "semaArray[cilErrorSema] != (SEMA)0"
+ "semaArray[dmaChainOverflowSema] != (SEMA)0"
+ "semaArray[dmaDoneSema] != (SEMA)0"
+ "semaArray[flashDelaySema] != (SEMA)0"
+ "semaArray[frameDoneSema] != (SEMA)0"
+ "semaArray[frameDoneTimerSema] != (SEMA)0"
+ "semaArray[i2cSema] != (SEMA)0"
+ "semaArray[i] != (SEMA)0"
+ "semaArray[i] != NULL"
+ "semaArray[irTimerExpiredSema] != (SEMA)0"
+ "semaArray[lpdpCaptureStopComplete] != (SEMA)0"
+ "semaArray[mipiErrorSema] != (SEMA)0"
+ "semaArray[peridotConfigSema] != (SEMA)0"
+ "semaArray[pipeDoneMainSema] != (SEMA)0"
+ "semaArray[pipeDoneSifrSema] != (SEMA)0"
+ "semaArray[projectorErrorSema] != (SEMA)0"
+ "semaArray[projectorTimerSema] != (SEMA)0"
+ "semaArray[replayAETimeoutSema] != (SEMA)0"
+ "semaArray[replaySIFRSplitTriggerSema] != (SEMA)0"
+ "semaArray[risingVSynch] != (SEMA)0"
+ "semaArray[semaAckDrop] != (SEMA)0"
+ "semaArray[semaAckReady] != (SEMA)0"
+ "semaArray[semaSensorBootDone] != (SEMA)0"
+ "semaArray[sensTriggeredSema] != (SEMA)0"
+ "semaArray[sensorNonImageDoneSema] != (SEMA)0"
+ "semaArray[sifErrorSema] != (SEMA)0"
+ "semaArray[sifSrcTrigIrqSema] != (SEMA)0"
+ "semaArray[srcDoneSema] != (SEMA)0"
+ "semaArray[statsSrcDoneSema] != (SEMA)0"
+ "semaArray[streamingStartSema] != (SEMA)0"
+ "semaArray[strobeErrorSema] != (SEMA)0"
+ "semaArray[subband0ErrSema] != (SEMA)0"
+ "semaArray[thumbDmaDoneSema] != (SEMA)0"
+ "semaCapturePrepareDone != (SEMA)0"
+ "semaChannelStarted[i] != (SEMA)0"
+ "semaCleanupAck != (SEMA)0"
+ "semaCoolDownDone != (SEMA)0"
+ "semaDMADone != (SEMA)0"
+ "semaHATDMADone != (SEMA)0"
+ "semaHRDone != (SEMA)0"
+ "semaHWTimeout != (SEMA)0"
+ "semaHwTriger != (SEMA)0"
+ "semaIndex<CPOWERSUPPLY_CMD_DEPTH"
+ "semaLTMDone != (SEMA)0"
+ "semaMiscDMADone != (SEMA)0"
+ "semaPool != 0"
+ "semaPool == 0"
+ "semaProcDone != (SEMA)0"
+ "semaProcDone[i] != (SEMA)0"
+ "semaProcDone_ != (SEMA)0"
+ "semaQueueMutex != (FFWMUTEX)0"
+ "semaSecureModeSwitch[i] != (SEMA)0"
+ "semaTiledDone != (SEMA)0"
+ "semanticChannel=%zu slaveChannel=%d semanticFn=%u"
+ "semanticVideoUpdateSema %p"
+ "semanticVideoUpdateSema[ch] != NULLSEMA"
+ "semaphore == (SEMA)0"
+ "semaphore == h->signalT2H"
+ "semaphore for %#x was already returned, but it shouldn't"
+ "semas.afTimer != NULLSEMA"
+ "semas.nack != NULLSEMA"
+ "semas.notify != NULLSEMA"
+ "semas.oisModeSwitch != NULLSEMA"
+ "semas.periodicSync != NULLSEMA"
+ "semas.stimulusInjectionTest != NULLSEMA"
+ "sendReqStart"
+ "sendScript"
+ "send_mutex"
+ "send_mutexI2C"
+ "send_mutexLPDP"
+ "send_mutexMIPI"
+ "send_mutexSPMI"
+ "send_mutexSensor"
+ "send_mutexSys"
+ "send_mutexVCRouter"
+ "sending afe data to pins[%d] %u"
+ "sending semantic awb confidencemap %p to pin %u ch=%zu"
+ "sensQuadBinF %d ispQuadBinF %d binH %d binW %d lensPositionF %f\n"
+ "sensitivity == CISP_FW_DETECTOR_FD_SENSITIVITY_DEFAULT || sensitivity == CISP_FW_DETECTOR_FD_SENSITIVITY_HIGH"
+ "sensor is not streaming, ignore INT\n"
+ "sensor.pDescr && sensor.pUnit"
+ "sensor.pDescr->illuminantModel.cct0 > sensor.pDescr->illuminantModel.cct1"
+ "sensor.pDescr->illuminantModel.cct1 > 0"
+ "sensorArrayOutputRect %d %d"
+ "sensorBoot sema is NULL so we cannot boot in a separate thread"
+ "sensorBootExecuteSema != (SEMA)0"
+ "sensorBootQuitSema != (SEMA)0"
+ "sensorBootTask != (TASK)0"
+ "sensorCharacterizationParams != 0"
+ "sensorConfig < m_sensorConfigsTot"
+ "sensorConfig == pstEITParams->nSensorConfig"
+ "sensorID 0x%x entry %d has no Preset!"
+ "sensorID 0x%x okToRun %u\n"
+ "sensorInitmutex != (FFWMUTEX)0"
+ "sensorInterface < MAX_ISP_SIF_RESOURCES"
+ "sensorLineTime > 0"
+ "sensorOutputInfoArray != nullptr"
+ "sensorReadOutCrop->x >= 0"
+ "sensorReadOutCrop->y >= 0"
+ "sensorReadOutCrop.x >= 0 && sensorReadOutCrop.y >= 0"
+ "sensorRect x %u y %u w %u h %u"
+ "sensorRequest.requestId == requestId"
+ "sensorRequestUpdateArray != nullptr"
+ "sensorSecureBootSema != (SEMA)0"
+ "sensorSequence.mutexBoot != (FFWMUTEX)0"
+ "sensorStatus = %d"
+ "sensorTestSIFRRDOffset == 0"
+ "sensorTestSIFRRDOffset > exposureSifr"
+ "sentMetaBuff"
+ "sentMetaBuff != pMetaDataCBuf"
+ "sepHeader->version == 0"
+ "seqEntry != NULL"
+ "serialPollTimer != 0"
+ "serialPollTimer[i] != 0"
+ "serialPortPoolTimeOut != (SEMA)0"
+ "serialPortPoolTimeOut[i] != (SEMA)0"
+ "serialPortSignal[i] != (SEMA)0"
+ "set MULTIFOCUS_SLAVE_ROI_VALID to false"
+ "set OC offset config %d offset %d %d"
+ "set gDSnsr 0x%x"
+ "set invBGain 0x%x"
+ "set meta biasTag %u, manuExpTag %u"
+ "set meta invBinGain 0x%x"
+ "set output buffer[%zu]"
+ "set vFrameSize %d offset %d rounded %d calculated %d"
+ "setAEChange"
+ "setAEStats"
+ "setCCROI"
+ "setCSSenseForChannel"
+ "setCSSenseIMUOutput"
+ "setConfidenceMap"
+ "setConfig"
+ "setDebugFlags"
+ "setDesiredTilesChangePerFrame"
+ "setEnabled"
+ "setEngagementStatus"
+ "setFOVScales"
+ "setFloatMap"
+ "setForceFPS"
+ "setForceFusedFPS"
+ "setForceRawFPS"
+ "setGlobalMode"
+ "setGrowRegions"
+ "setIMUData"
+ "setLaccHFFImg"
+ "setMaxRecordingFPS"
+ "setMaxSensorFrameRate"
+ "setMemForOutputTileWma"
+ "setMetadata"
+ "setMinRecordingFPS"
+ "setMinSensorFrameRate"
+ "setMode"
+ "setMotionDataRate() WriteMessage() return sts  = %d"
+ "setMotionDataRate() calling WriteMessage()"
+ "setMotionDataRate() response: Set motionDataRate Value = %d"
+ "setMotionDataRate() used %f ms\n"
+ "setOutputMask"
+ "setPointerBuffBaseAddrHigh = 0x%x"
+ "setPointerBuffBaseAddrLow = 0x%x"
+ "setPointerMaxNum = 0x%x"
+ "setRecordedChannel"
+ "setRecordingChannel"
+ "setSVStatus"
+ "setSize"
+ "setSlaveCameraCSensorCalGain"
+ "setTimewarpCommand"
+ "setting CCT TS %f\n"
+ "sfr_inf_ChartDistance_mm != 0.0f"
+ "shAddr != NULL"
+ "shading != nullptr"
+ "shareMemorySizePackReg == 0"
+ "shareMemorySizeReg == 0"
+ "shareMemorySizeTable == 0"
+ "shared=%zu VisPipeO=%d VisSDet=%d Lacc=%d Ncc=%d patch=%d"
+ "sharedBufferPoolChMask[poolConfig->grpDest.grpId][poolConfig->eSharedPoolType] == 0"
+ "sharedCS: ch=%d CSCConfig=0x%x CSCChromaScale=%d %d Offset=%d %d"
+ "sharedCS: ch=%d ColorHistConfig Offset=%d %d Scale=%d %d"
+ "sharedCS: ch=%zu CS=%d Offset=%d %d Scale=%d %d"
+ "sharedCS: ch=%zu ColorHistConfig Offset=%d %d Scale=%d %d"
+ "sharedMem != 0"
+ "sharedMemorySize == sizeof(SharedMemObject)"
+ "sharpnessKnob <= MAX_SCALER_SHARPNESS_KNOB_LEVEL"
+ "shiftClose<shiftFarStart && shiftFarStart<shiftFarEnd"
+ "shiftMapInfo.byteOffset == 0"
+ "shift_px"
+ "shiftsBufferSize <= pceAlgoForGMC.size"
+ "shutterValue != 0"
+ "shwdStatus == 0"
+ "sibCmdHdrCnt <= headerLen"
+ "sifArmed == 1"
+ "sifBinH >= 1 && sifBinV >= 1"
+ "sifId %d [SIFR] sifDmaDst %d bank %d"
+ "sifId %d: %s: sifOutCropRect %d %d %d %d"
+ "sifId <= MAX_ISP_SIF_RESOURCES"
+ "sifIsrHandle[0] != 0"
+ "sifIsrHandle[5] != 0"
+ "sifIsrHandle[pipeId] != 0"
+ "sifr %d exp %llu gA %d rdo %d hr %.2f spd %d vhdr %d"
+ "sifr %d exp %llu gL %d rdo %d hr %.2f spd %d vhdr %d"
+ "sifr is off, use the previous thumbnail buffer"
+ "sifrBinFactor == 1"
+ "sifrBinningExponent >= configQuery.sensBinW && configQuery.sensBinW == configQuery.sensBinH"
+ "sifrCtrl == (enum eCICSIFRCtrl)value"
+ "sifrRDOffset > 0"
+ "sifrRawFrame == nullptr"
+ "sifrSkipInterval > 1 || bAttachPBSIFRThToFirstBracketFrame"
+ "sifrSkipRatioFromAE || bAttachPBSIFRThToFirstBracketFrame"
+ "sifroverallBF %u sifrFpPresrvEn %d sifrFpEx %u sifrFepQbinEn %u sifrFepDMAOutBinH %u"
+ "sig %x %x %x ... keys %x %x %x\n"
+ "sigPool == 0"
+ "sigmaDistThresh = 0x%x"
+ "sigmoidFloatToFloat"
+ "signal != (SEMA)0"
+ "signal != 0"
+ "signalArray != 0"
+ "signalAvail"
+ "signalAvail == true"
+ "signalAvailable"
+ "signalAvailable == true"
+ "signalCount >= this->_taskCount"
+ "signalH2T != 0"
+ "signalT2H != 0"
+ "signed"
+ "simTaskId != 0"
+ "simTaskSema != (SEMA)0"
+ "single ch%d: Max available SIFQs=%d \n"
+ "size"
+ "size != 0"
+ "size != nullptr"
+ "size % 4 == 0"
+ "size %4 == 0"
+ "size %d < %d\n"
+ "size %d x %d max R = %.4f -> R limit %d -> RadScale = %d\n"
+ "size %zu"
+ "size && num && helper_fn"
+ "size && nvm"
+ "size < 258"
+ "size <= 128"
+ "size <= 257"
+ "size <= 4096"
+ "size <= 4913"
+ "size <= 65"
+ "size <= 768"
+ "size <= 8"
+ "size <= FFWMSG_REF_EXTRA_SIZE"
+ "size <= VISIONDRVH17_RVC_RADGAINMEM_SIZE"
+ "size <= VISIONDRVH17_VNF_DOTDETECTLUT_SIZE"
+ "size <= VISIONDRVH17_VNF_STDYLUT_SIZE"
+ "size <= VISIONDRVH17_VNF_YCOEFF_SIZE"
+ "size <= VISIONDRV_MAX_LUT_VALUES"
+ "size <= logSpaceLetf"
+ "size <= sizeof(pBuffMsg->extra)"
+ "size == sizeof(*pCmd)"
+ "size == sizeof(*pRequest)"
+ "size == sizeof(LCAuxThread::sAck)"
+ "size == sizeof(sAFEProcInputPDAF)"
+ "size == sizeof(sCAF2DEPTHIC)"
+ "size == sizeof(sCAF2PDAF)"
+ "size == sizeof(sCPCEAlgoProcessorGMSLoopExtraInfo)"
+ "size == sizeof(sLCAFPositionResponse)"
+ "size == sizeof(sLCDataFrameInfo)"
+ "size == sizeof(sLCDataOisRecenter)"
+ "size == sizeof(sPDAFSpotDefocusResults)"
+ "size == sizeof(sPDAFToMLAFCommand)"
+ "size == sizeof(sSemanticAWBProcColorHist2D)"
+ "size > 0"
+ "size > 0 && (size > sizeof(struct sCIspSetFileHdr))"
+ "size >= metadataOffsetTableMax"
+ "size of awbStatsHdr = %u"
+ "size=%u DMAConfig=0x%x DMABfrConfig=0x%x DMASTTConfig=0x%x DMABaseAddr=0x%x DMALinSize=0x%x\n"
+ "sizeAEWindows[0] = 0x%x"
+ "sizeInByte % 4 == 0"
+ "sizeIntlvLumiBytes == (uint64_t)lumiWidthPad * 2 * lumiHeight"
+ "sizeKeys <= sizeof(KDFHMACKeys)"
+ "sizeMaxX % focusGrid.spacingX == 0"
+ "sizeMaxY % focusGrid.spacingY == 0"
+ "sizeStatus == 8"
+ "sizeX <= 144 && sizeX >= 4"
+ "sizeY"
+ "sizeY != 0"
+ "sizeY <= 512 && sizeY >= 4"
+ "size[j]"
+ "sizeof(*pOpItem) + sizeof(sCIspGeneralProcessGCPrimConf_TahitiCVDAll) + pOpListHdr->offset[i] <= pOpListHdr->offset[i + 1]"
+ "sizeof(*pOpItem) + sizeof(sCIspGeneralProcessGCPrimConf_TahitiCVDAll) + pOpListHdr->offset[i] <= pOpListHdr->offset[i+1]"
+ "sizeof(*pOpItem) + sizeof(sCIspGeneralProcessGCPrimConf_TahitiCVDAll) + pOpListHdr->offset[i] <= totalSize"
+ "sizeof(*pOpItem) + sizeof(sCIspGeneralProcessGCPrimConf_TahitiDesGen) + pOpListHdr->offset[i] <= pOpListHdr->offset[i + 1]"
+ "sizeof(*pOpItem) + sizeof(sCIspGeneralProcessGCPrimConf_TahitiDesGen) + pOpListHdr->offset[i] <= totalSize"
+ "sizeof(*pOpItem) + sizeof(sCIspGeneralProcessGCPrimConf_TahitiDesMatch) + pOpListHdr->offset[i] <= pOpListHdr->offset[i + 1]"
+ "sizeof(*pOpItem) + sizeof(sCIspGeneralProcessGCPrimConf_TahitiDesMatch) + pOpListHdr->offset[i] <= totalSize"
+ "sizeof(EventLogger)=%ld\n"
+ "sizeof(IMX714_BkGKey) / (sizeof(IMX714_BkGKey[0]) * 2) == sizeof(hostBkGKeys)"
+ "sizeof(IMX913_BkGKey) / (sizeof(IMX913_BkGKey[0]) * 2) == sizeof(hostBkGKeys)"
+ "sizeof(aeParams.proj.BktIR) == sizeof(pParams->prjMode)"
+ "sizeof(overlay.roiType) > strlen(roiType)"
+ "sizeof(overlay.status) > strlen(status)"
+ "sizeof(pHostMetaHITH->thumbnailData) >= pStatBuff->thumbnailStatSize"
+ "sizeof(pHostMetaLocalHist->localHistData) + sizeof(sCIspMetaDataSharedLocalClipping::localClippingData) >= pStatBuff->localHistStatSize"
+ "sizeof(pLTMLutsHostMeta->lutsMem) >= ltcSize"
+ "sizeof(pLTMLutsHostMeta->lutsMem) >= ltmSize"
+ "sizeof(pLTMLutsHostMeta->lutsMem) >= memSize"
+ "sizeof(pLTMLutsHostMeta->spatialCCMMem) >= ccmSize"
+ "sizeof(pLTMLutsHostMeta->spatialCCMMem) >= memSize"
+ "sizeof(pLTMLutsHostMeta->spatialCCMMem) >= sccmSize"
+ "sizeof(pMetaQuadraHocl->lsMemAdjustedQuadraHocl)/gainTableStride >= pMeta->configurationAdjustedQuadraHocl.H6.gridCountY * 2"
+ "sizeof(pdpCfg.gainMem) >= pdpCfg.tblSize * sizeof(uint32_t)"
+ "skin nSample = %hu, nFrame = %hu, skinConf = %f"
+ "skinConf = %f, histConf = %f, final Conf = %f"
+ "skinRGBRatio = %6.2f %6.2f %6.2f %hu maskRGBN= %6.2f %6.2f %6.2f %hu"
+ "skinWBGainBlendingFactor=%f"
+ "skip copy %s %d: awbParamSyncTag=%d, awb.syncTag=%d fc %d\n"
+ "skip this face due to invalid x!"
+ "skip this face due to invalid y!"
+ "skipFrame"
+ "skipRatio <= 1"
+ "skyCCT=%6u skyCctShift=%.2f skyRgLogRatioTarget = %.2f"
+ "skyRgLogRatio=%.2f, preBgLogRatio=%.2f, skyWBGain rGain=%.2f, bGain=%.2f"
+ "slafData"
+ "slafSubsampleFactor >= 4"
+ "slave ch=%d::AWB_TS       : isLocked=%d, wpOut=[%.2f, %.2f]"
+ "slave ch=%d::fdAWB        : fdAWBOutput=%d "
+ "slave ch=%d::interMeta    : lux=%d rgLogRatio=%.2f bgLogRatio=%.2f "
+ "slave ch=%d::photometerAWB: daylight=%.2f lightstable=%.2f suddenchange=%.2f"
+ "slaveAEUpdate.exposureSifr %llu rdoffset %d sifr %d\n"
+ "slaveCameraID = %08x (%02zu / %02u)"
+ "slaveCameraID = %zu, scheme %d, %d"
+ "slaveCameraID = %zu, table %.4f %.4f"
+ "slaveCh != -1"
+ "slaveCh == -1"
+ "slaveIdx %u slaveCh %zu wbGain %u %u %u cct %u rgCal %u bgCal %u"
+ "slaveIdx %u statMasterCh %u wbGain %u %u %u cct %u rgCal %u bgCal %u"
+ "slaveWBGain RGWBGain = %6f BGWBGain=%6f "
+ "slaveid < AE_SLAVE_MAX"
+ "slewrate_uS >= 4"
+ "slices[0].end().x > slices[1].start.x"
+ "slices[0].size.y == slices[1].size.y"
+ "slices[0].start.y == slices[1].start.y"
+ "slowSyncEnabled %d, slowSyncEnabledByPRW %d, slowSyncEnabledCombined %d\n"
+ "slowSyncGain %d isSlowSync %d slowSyncEnabled %d, slowSyncEnabledByPRW %d, slowSyncIsSlowSync %d\n"
+ "slowSyncIsSlowSync == 0"
+ "slwSy %d fr %d fOn %dus expT %dus rdoutT %dus offLat %dus\n"
+ "sm3CoredumpReady"
+ "sm3_coredump_data"
+ "smbTaskId != 0"
+ "smb[bus] != 0"
+ "smb[ch] != 0"
+ "smileThreshold <= 100"
+ "smode %d af %d pre %d m %d i %d a %d d %d sbl %d strM %d skpP %d auxt %d"
+ "sn"
+ "snStr"
+ "snStr != NULL"
+ "source < CIspEngineExeLoopH17Sema_TOT"
+ "source < INT_NROF_VECTORS"
+ "source < ISR_REG_ENTRY"
+ "source < LC_TEMPERATURE_COUNT"
+ "source < lines * ISR_REG_ENTRY"
+ "source >= 0"
+ "source >= CIspEngineExeLoopH17SemaFe_S0 && source <= CIspEngineExeLoopH17SemaBe_S36"
+ "source >= DATA_SOURCE_START && source < DATA_SOURCE_TOTAL"
+ "sourceGoReq != 0"
+ "sphBzH1Corr"
+ "sphBzH2Corr"
+ "sphereControl %d \n"
+ "sphereControl is manually Set: %d\n"
+ "sphereMode: %d sphereControl %d\n"
+ "split"
+ "splitPD totalSize=%u is greater then RMASize=%u (not enough space for output buffer)"
+ "splitPDMetadata->extremeLowLightMode == SPD_RUN_MODE_MLAF"
+ "splitPDMetadata->extremeLowLightMode == SPD_RUN_MODE_REGULAR || splitPDMetadata->extremeLowLightMode == SPD_RUN_MODE_LOW_LIGHT"
+ "splitPDMetadata->pceMeta.byteStrideScore * splitPDMetadata->pceMeta.sizeY <= m_outputScoreBuffer->Size()"
+ "splitPDOn == false"
+ "splitPDToggleControl"
+ "spmi"
+ "spmiWrite.field0.header.data_len <= sizeof(spmiWrite.field0.data.p_data)"
+ "spmi_interface"
+ "sqDistThresh = 0x%x"
+ "sr.f.Halt == 1"
+ "src != nullptr"
+ "src % 4 == 0"
+ "src && nBytes"
+ "src && width > 0 && height > 1 && stride >= width"
+ "src == ALL"
+ "src >= DATA_SOURCE_START && src < DATA_SOURCE_TOTAL"
+ "src f %u fr %u ch %u \n"
+ "src.height == dst.height"
+ "src.pixelFormat == kFwDetectorBufferPixelFormatTypeFloat"
+ "src.r.Size.f.Height == height"
+ "src.r.Size.f.Width == width"
+ "src.width == dst.width"
+ "src.width == dst.width && src.height == dst.height"
+ "src.width > 2 && src.height > 2"
+ "srcCh = %u frameCount=%d ,dstCh=%u frameCount=%d"
+ "srcDMAIndex < 0"
+ "srcHeight <= 4095 && srcHeight >= 64"
+ "srcId < FLOW_SRC_NAME_TOT"
+ "srcIndex <= (DATA_SOURCE_SENS4DMA - DATA_SOURCE_SENS0DMA)"
+ "srcIndex >= 0 && srcIndex < MAX_SRC_INPUT_DMA"
+ "srcLut.GetNumOfPoints() == sizeof(m_rgsBlockBaseAddr.r.Ulut)/sizeof(m_rgsBlockBaseAddr.r.Ulut[0])"
+ "srcMetaCBuf"
+ "srcPyrInfo.numLevels <= 4"
+ "srcSif %d [%s] sifDmaDst %d inSel %d"
+ "srcUserPending[src - DATA_SOURCE_START] == InvalidUserHandler"
+ "srcUserPending[user_idx] == InvalidUserHandler"
+ "srcW && srcH && dstW && dstH"
+ "srcWidth <= 2304 && srcWidth >= 64"
+ "srcWidth <= 4608 && srcWidth >= 128"
+ "st == RTK_ST_OK"
+ "st_count = %d, st_step = %d tile_width %d tile_height %d\n"
+ "start"
+ "start < end"
+ "start ANST Thumbnail PIODMA Memcpy szie:%zu"
+ "start PIODMA Hair:mpFifoBufferQHair entry:%zu"
+ "start PIODMA Skin:mpFifoBufferQSkin entry:%zu"
+ "start PIODMA Sky:mpFifoBufferQSky entry:%zu"
+ "start PIODMA people:mpFifoBufferQPeople entry:%zu"
+ "start blocking algocontrl cmd"
+ "start blocking pCmdcontainer ch %zu, inputPipe %p\n"
+ "start non-blocking cmd ch %zu"
+ "startAddr_ != nullptr"
+ "startAddr_ == nullptr"
+ "startHistAddr %p, expectedCount %u, numB %u bAntiAlias %u"
+ "startInc=%d, midInc=%d, doneInc=%d, bufHeight=%d, imgHeight=%d"
+ "startX % 2 == 0"
+ "startX %u"
+ "startX + sizeX <= input.startX + input.sizeX"
+ "startX < endX && startY < endY"
+ "startX <= endX"
+ "startX >= 0 + borderX"
+ "startX >= input.startX"
+ "startY %u"
+ "startY + sizeY <= input.startY + input.sizeY"
+ "startY <= endY"
+ "startY >= 0 + borderY"
+ "startY >= input.startY"
+ "started == false"
+ "startup_stats\n"
+ "stat(%llx) tile(%llx %d), misc(%llx %d)\n"
+ "stat.numDiff == 0"
+ "statBuffer != nullptr"
+ "statBufferSizeTotal = 0x%x %u "
+ "statHdrBuff[i] != 0"
+ "statPipe < STAT_PIPE_TOT"
+ "statSrcIndex[pipe] >= 0 && statSrcIndex[pipe] < MAX_SRC_INPUT_DMA"
+ "statSrcIndex[statResMap[i]] >= 0"
+ "state %d continuousSync %d master %d"
+ "state == ALGOCTRL_READY || state == ALGOCTRL_RESOURCE_WAITING || state == ALGOCTRL_GO_WAITING"
+ "state == CPCEFLOW_STATE_DATA_SET || state == CPCEFLOW_STATE_DATA_SET_PARTIAL"
+ "state == STATE_READY"
+ "state.fullBodyObjects[i].numHistoryBox <= 1"
+ "state.numFullBodyObjects <= m_config.maxResultCount"
+ "state.numTrkHands <= m_config.maxResultCount"
+ "state.numTrkObjects <= m_config.maxResultCount"
+ "state: %d, volt: %d, level: %d\n"
+ "staticInit"
+ "staticListNumDefects <= CSystemConfigurator::GetDPCDefectPixelCount(ch)"
+ "static_cast<bool>(mapping->sensorQuadraPatternSupported) == sensorInfo.quadraPatternSupported"
+ "stats"
+ "stats & preview master+ tele(%d) || ffc(%d) => boost face weight * %.1f (inst of %.1f)\n"
+ "stats ch %zu is not same as masterCh %u. Update awb hostmetdata on masterCh"
+ "stats previewCrop x %u y %u w %u h %u"
+ "statsBuffer"
+ "statsDmaEn == statsDmaEnabled || bSkipOutStats0 || bSkipOutStats1"
+ "statsId < VFLOWH17_MAX_STATS"
+ "statsMS=%d,IR-RGB=%d,rBWR=%d,wBWR=%d MBs,PMPClkCtrlEn=%d,PMPBwCtrlEn=%d\n"
+ "statsWindowEndX > statsWindowStartX"
+ "statsWindowEndY > statsWindowStartY"
+ "stats_bottom > 0"
+ "stats_left < aeStats->numTilesX"
+ "stats_right > 0"
+ "stats_top < aeStats->numTilesY"
+ "status < static_cast<uint8_t>(FLICKER_DETECITON_STATUS_TOTAL)"
+ "status == FFW_OK"
+ "status == RTK_ST_OK"
+ "status == ViewingDistance::VDStatus::Success"
+ "status.f.Free"
+ "std != NULL"
+ "stdScaleFscl <= 1"
+ "stdScaleFscl >= 0"
+ "stdScaleNum == FUSION_SCALE_COEF_SIZE"
+ "step: %f"
+ "step: ev0Ratio=%d"
+ "stepDirection < 0"
+ "stepDirection > 0"
+ "stepIDX < IC_UPDATEUNIT_MAX_AECOUNT"
+ "stf RodataAddr %p RodataSize %zu\n"
+ "stf boot pc = 0x%x\n"
+ "stf laccImgAddr %p laccImgSize %zu\n"
+ "stfRodataAddr %p stfRodataSize %zu"
+ "stfbootpc = 0x%x stfbLaccEnable %u"
+ "stflaccImgAddr %p stflaccImgSize %zu"
+ "still buffers outside while channelStopped ch %u mask %u %zu %u"
+ "still: ch %zu outBufX=%d, outBufY=%d, XInCapture=%d, YInCapture=%d\n"
+ "stillCaptureInQueue"
+ "stillOutStrmRect=[x=%d y=%d w=%d h=%d], ShiftOffset=[x=%d y=%d], bUseWorkaround=%d\n"
+ "stillScalerCrop.height != 0"
+ "stillScalerCrop.width != 0"
+ "stop during capture"
+ "str"
+ "strLEDC[0]=0x%x strLEDC[1]=0x%x, csv:0x%x, wsv: 0x%x"
+ "stream"
+ "streamEn: BES %d AUX %d YCC %d\n"
+ "streamId != CISP_MCACHE_STREAM_ID_INVALID"
+ "streamId != CISP_MCACHE_STREAM_ID_WARPER_GDC || mcacheInfo->numofDsIds == CISP_MAX_MCACHE_DSIDS"
+ "streamId < CISP_MCACHE_STREAM_ID_TOT"
+ "streamInfo"
+ "streamInfo == NULL || streamInfo[DATA_IMAGE].available"
+ "stride"
+ "stride % 2 == 0"
+ "stride * (height - 1) + widthExtended <= size"
+ "stride * (pLSConfig->H6.gridCountY) * blockY <= pLSColorConfig->lsMemSizeBytes"
+ "stride <= bufOutFrame->Stride() && size <= bufOutFrame->Size()"
+ "stride == (stride >> 6 << 6)"
+ "stride > 0"
+ "stride x Y =%u is greater then SplitPd buff size =%zu"
+ "strideCh && strideCh <= pBuffpool->BufferTileTexDataStrideGet(1)"
+ "strideCh && strideCh <= tileBufStrideChroma"
+ "strideLu && strideLu <= pBuffpool->BufferTileTexDataStrideGet(0)"
+ "strideLu && strideLu <= tileBufStrideLuma"
+ "strideX %u blockX %u"
+ "strideX >= LTM_LOCAL_HIST_MIN_STRIDE_X"
+ "strideX >= STATS_LOCAL_THUMB_MIN_STRIDE_X"
+ "strideY %u blockY %u"
+ "strideY >= LTM_LOCAL_HIST_MIN_STRIDE_Y"
+ "strideY >= STATS_LOCAL_THUMB_MIN_STRIDE_Y"
+ "stride[0] = %lu, size[0]=%lu\n"
+ "stride[1] = %lu, size[1]=%lu\n"
+ "stride[i]"
+ "stride[isUV] > 0"
+ "stripProcessingFrameCnt = %d\n"
+ "strobe_config_modulated"
+ "strobe_config_normal"
+ "strobestart est %llu last %llu EXP curr %d nexp %d frm %d\n"
+ "sts != CLCPlayback::eStatus::INVALID_CRC"
+ "sts = %d"
+ "sts == 0"
+ "sts == CLCPlayback::eStatus::SUCCESS"
+ "subAddrLen < BYTE_COUNT_MAX"
+ "subAddrLen < SMB_BATCH_REQUEST_MAX_SIZE"
+ "subAddrLen <= BYTE_COUNT_MAX"
+ "subAddrLen <= m_SMB_SUBADDR_LEN_MAX"
+ "subCh"
+ "subFactPowH <= 3"
+ "subFactPowH >= 1"
+ "subFactPowV <= 3"
+ "subMode < CISP_PROJECTOR_SUBMODE_LIGHTCODING_MAX"
+ "sub_addr_len_total <= sizeof(i2c_write_block.field0.data.p_sub_addr)"
+ "succ"
+ "success # %u\n"
+ "sum  "
+ "sum curr %d uA > requested %d uA\n"
+ "sum updated to %d uA\n"
+ "sumRow[j] > 0.0f"
+ "summary"
+ "super::Available() == (int)super::Managed()"
+ "superframeSize <= bufSize"
+ "supportedChannels == (((1 << primaryCamCh)) | ((1 << secondaryCamCh)))"
+ "supportedFlows[m_rearStereoFlowType] == true"
+ "svResultMeta.frmNo= %llu"
+ "swap curr setting old %p f %u fr %u new %p f %u fr %u\n"
+ "switch to masterCamPreview to %d from %d"
+ "switchedConfigIndex == currConfigIndex"
+ "sx, sy = [%f, %f], FG Threshold = %hhu"
+ "syncCmdMutex_ != (FFWMUTEX)0"
+ "syncGroupID[%d] = %d syncGroupChMask[%d] = 0x%x"
+ "syncGroupMask != 0"
+ "syncMode == MULTI_SYNC_REGTRIG"
+ "syncResp != 0"
+ "syncTag overwrite in TM old%x, new=%x"
+ "syncedCam %u ch %zu flash %u issueGo %u, icfr %u \n"
+ "syncedCams<=3"
+ "synchronization != (SEMA)0"
+ "synchronize != (SEMA)0"
+ "sz < metaSize + metaPadSize"
+ "sz == adGocOutput_bin_len"
+ "sz > 0"
+ "sz > 1"
+ "sz >= metaSize"
+ "t2hchIOMan != 0"
+ "tStart_clk < tEnd_clk"
+ "tStart_clk <= pFrameInfo->tStart_clk"
+ "tStart_clk <= pSampleOld->ts_clk"
+ "table != 0"
+ "table != nullptr"
+ "table->numEntries > 0"
+ "tableCount <= 1"
+ "tableId < ISPHWH17SegmentId_MaxNbr"
+ "tableId < ISPHWH17TableId_MaxNbr"
+ "tableId=%d addr=%#zx comps=%d entries=%d"
+ "tableLen <= pTableInfo->compSize"
+ "tableSize == 325"
+ "tableStorage < CAE_TABLE_STORAGE_TOT"
+ "tableType < CAE_TABLE_TOT"
+ "tableType == CAE_TABLE_CUSTOM_AE"
+ "tagTmp == pMetaData->syncTag.tag"
+ "target %d %d flip %d"
+ "target %d bounds %f\n"
+ "target %d mastercam %d preview Master %d\n"
+ "targetEIT %llu, sifrTargetEIT %llu"
+ "targetEIT >= minEIT"
+ "targetFactor %.1f reflective_factor %.2f, weightedAveDiff %.2f, target %d %d face %d\n"
+ "targetSettingIdx < pMultiChUBKTParams->channelCount"
+ "targetedFDMap  w h (%d %d)\n"
+ "targets obj %d scene %d\n"
+ "task != (TASK)0"
+ "task != 0"
+ "taskAborted"
+ "taskId < mMaxTasks"
+ "taskId == self"
+ "taskPool == 0"
+ "taskSema != 0"
+ "taskStartedSema != (SEMA)0"
+ "taskTime != 0"
+ "tbcSeqParams.frameIdxTbcSequence == 0"
+ "tbcSeqParams.framesInSuperframe == cmd->f.newSeq.framesInSuperframe"
+ "temp"
+ "temp != 0"
+ "temp == NULL"
+ "tempBuf too small!"
+ "tempBufBytes >= acTrkGroupAssignTempBytes(numFaceObjects + numBodyObjects)"
+ "tempBufBytes >= acTrkObjectAssocTrkDetTempBytes(kMaxObjects)"
+ "tempBuffers"
+ "tempBytes should be >= numRects!"
+ "temperature_c"
+ "testIpcAllocate"
+ "testPostProcessing"
+ "thickLensEFL=%f"
+ "thickLensEFL=%f vs %f"
+ "thickLensSlope=%f"
+ "thickLensSlope=%f vs %f"
+ "this->_bufUpdate != nullptr"
+ "this->_bufUpdate == nullptr"
+ "this->_pChannels[ch] == nullptr"
+ "this->_pPool != nullptr"
+ "this->_semaWait != (SEMA)0"
+ "this->_sensor.pDescr != nullptr"
+ "this->_signal != (SEMA)0"
+ "this->_signalCount <= signalCountMax"
+ "this->_signals[k] != (SEMA)0"
+ "this->_state != Task::State::DISABLED"
+ "this->_state == PDAF::Region::State::INITIALIZED"
+ "this->_state == PDAF::Region::State::UNINITIALIZED"
+ "this->_state == Task::State::DISABLED"
+ "this->_state == Task::State::DONE"
+ "this->_state == Task::State::FINALIZED"
+ "this->_state == Task::State::IDLE"
+ "this->_state == Task::State::RUNNING"
+ "this->_state == TaskPool::State::INITIALIZED"
+ "this->_state == TaskPool::State::UNINITIALIZED"
+ "this->_supported"
+ "this->_taskCount <= TaskPool::MAX_TASK_COUNT"
+ "this->_taskCount > 0"
+ "this->_updateMem != nullptr"
+ "this->buffers >= buffers"
+ "this->configSensor.pUnit != nullptr"
+ "this->contextMem != nullptr"
+ "this->crop.PipeHeight.Height <= +8190"
+ "this->crop.PipeHeight.Height >= +64"
+ "this->crop.PipeWidth.Width >= +128"
+ "this->crop.SrcOffsetY.OffsetY <= +8126"
+ "this->ctxs(ctxIdx).active == true"
+ "this->focusGrid.countX > 1"
+ "this->focusGrid.countY > 1"
+ "this->focusGrid.spacingX == 8"
+ "this->focusGrid.spacingX > 0"
+ "this->focusGrid.spacingY == 4"
+ "this->focusGrid.spacingY == 8"
+ "this->focusGrid.spacingY > 0"
+ "this->focusGrid.startX + this->focusGrid.spacingX * (this->focusGrid.countX - 1) <= this->sizeX"
+ "this->focusGrid.startX < this->sizeX"
+ "this->focusGrid.startX >= 0"
+ "this->focusGrid.startY + this->focusGrid.spacingY * (this->focusGrid.countY - 1) <= this->sizeY"
+ "this->focusGrid.startY < this->sizeY"
+ "this->focusGrid.startY >= 0"
+ "this->frameParams.darkScale <= 1.0f"
+ "this->hFSM != 0"
+ "this->isHoldingBuffers()"
+ "this->isrHandleAfePipeIRQ != 0"
+ "this->isrHandleAfePipeIRQ == 0"
+ "this->m_trace[ch].cached"
+ "this->m_trace[ch].uncached"
+ "this->outputMem != nullptr"
+ "this->pdafSensor.pDescr && this->pdafSensor.pUnit"
+ "this->proc.SrcFrame.Height <= +12096"
+ "this->proc.SrcFrame.Height >= +64"
+ "this->proc.SrcFrame.Width <= +8704"
+ "this->proc.SrcFrame.Width >= +128"
+ "this->rpcSemaDone != (SEMA)0"
+ "this->rpcSemaWait != (SEMA)0"
+ "this->semaAFEProcDone != (SEMA)0"
+ "this->semanticAWBHiResData.frameCount != INVALID_FRAME_COUNT"
+ "thisKernelSum <= LTM_LOCAL_HIST_AA_KERNEL_MAX_TOT"
+ "thisp"
+ "thisp->debugM3Queue->Size()>0"
+ "thisp->m_spmiIsrHandle != 0"
+ "thisp->smbIsrHandle != 0"
+ "threadHistoryLock != (FFWMUTEX) 0"
+ "thres != NULL"
+ "thumbWin.height % 2 == 0"
+ "thumbWin.width % 2 == 0"
+ "thumbmailWindow x %u y %u w %u h %u"
+ "thumbnail size %zu, %d x %d, %d x %d, stride %zu"
+ "thumbnailBuffer->DataPointer()"
+ "thumbnailBuffer->Size() >= thumbnailSize"
+ "thumbnailDownsample x %u y %u"
+ "thumbnailHeight == LTM_THUMBNAIL_HEIGHT"
+ "thumbnailHiResExtHeight >= thumbnailHeight * scaler"
+ "thumbnailHiResExtWidth >= thumbnailWidth * scaler"
+ "thumbnailTotal is %d aread %zu window 0x%x D %d %d %zu"
+ "thumbnailWidth == LTM_THUMBNAIL_WIDTH"
+ "ti < numFBody"
+ "ti < numTrkObjects"
+ "ticket < cmdDepth"
+ "tidCounterInitValue = 0x%x"
+ "tile h vs stats h: %d %d"
+ "tile offset=0x%x size=0x%x "
+ "tile w vs stats w: %d %d"
+ "tileAFScoresPerObjectPerFilter.bayerY_15x3_bpf_f0 != 0"
+ "tileAFScoresPerObjectPerFilter.bayerY_15x3_bpf_f1 != 0"
+ "tileAFScoresPerObjectPerFilter.bayerY_3x3_f0 != 0"
+ "tileAFScoresPerObjectPerFilter.bayerY_3x3_f1 != 0"
+ "tileAFScoresPerObjectPerFilter.bayerY_hiir_f0 != 0"
+ "tileAFScoresPerObjectPerFilter.bayerY_viir_f0 != 0"
+ "tileAFScoresPerObjectPerFilter.rawB_7x1_hfir != 0"
+ "tileAFScoresPerObjectPerFilter.rawGb_7x1_hfir != 0"
+ "tileAFScoresPerObjectPerFilter.rawGr_7x1_hfir != 0"
+ "tileAFScoresPerObjectPerFilter.rawR_7x1_hfir != 0"
+ "tileBlurMScoresPerObjectPerFilter.blurConf != 0"
+ "tileBlurMScoresPerObjectPerFilter.blurExtent != 0"
+ "tileBlurMScoresPerObjectPerFilter.sharpness_L1 != 0"
+ "tileBlurMScoresPerObjectPerFilter.sharpness_L2 != 0"
+ "tileCount.product() <= tileCountMax"
+ "tileHeight <= statWindowHeight"
+ "tileInfo: tCount %d compEn[%d %d] inW[0] %d inH[0] %d outW[0] %d outH[0] %d\n"
+ "tileWidth <= statWindowWidth"
+ "tileWindow x %u y %u w %u h %u"
+ "tile_width = %d, tile_height = %d, st_sizex = %d, st_sizey = %d\n"
+ "time != 0"
+ "timeStamp = %lld"
+ "timeStampFlashCapture(in sec) %d firstFlashCapture %d size %d\n"
+ "timelapse rate=%.1f Hz T=%.1f s vs fR=%hu sensorT=%.3f s\n"
+ "timeout %d\n"
+ "timeout >= 0"
+ "timeoutAssert %u ms"
+ "timeoutProcessor"
+ "timerHandle != NULL"
+ "timestamp : FW Send %fms FW Received %fms\n"
+ "timestamp : Host received %fms Host Send %fms\n"
+ "tm && evt && (size <= evtBuffer->blk_size - sizeof(struct sEventEntry))"
+ "tmQueueSize <= (size_t)CTimeMachine::depthMax"
+ "tmpDistPair"
+ "tmpExtDriver"
+ "tmpGain >= AE_GAIN_IDENTITY"
+ "tmpLens"
+ "tmpLensToReset"
+ "tmpLensToSet"
+ "tmpRegPairs[i]"
+ "tnrChCnt <= tnrRunableChannels"
+ "toRect.height != 0"
+ "toRect.width != 0"
+ "toReturn"
+ "token != 0"
+ "too fast: %.3f ms / %.3f\n"
+ "torch=0x%04x strobe=0x%04x->0x%04x ratio=%.4f lumaTorch=%d lumaStrobe=%d"
+ "torchOnUpdate"
+ "tot %d offset0 %d"
+ "tot == 0"
+ "totActiveCh <= (int32_t)cafChannelTot"
+ "totActiveCh >= 0"
+ "totBytes=%d index=%d"
+ "totCh <= MAX_CH_PER_SYNCGROUP"
+ "totGainMSTFBand0StrModEnableThreshold = %d, DisableThreshold = %d"
+ "totRFCCamDepth <= 1"
+ "totRFCCams %d chBitMask 0x%x"
+ "totReq_ < kMaxRequests"
+ "totSize == AICamDebugDataSize()"
+ "totVCs > 0"
+ "totVCsAvailable > 0"
+ "totVCsInMulti <= totVCs"
+ "total < size"
+ "total ambient %d remaining ambient frames %d\n"
+ "totalBlueCurr=%.4f totalBluePrev=%.4f"
+ "totalChInGroup %d activeTimeMachine %d activeSlaveCams %d mask 0x%x minSkip %d"
+ "totalChInGroup <= MAX_CH_PER_SYNCGROUP"
+ "totalChInGroup >= maxNumActiveSlaveCams"
+ "totalCurr <= CP_MAX_MFLASH_CH * 2"
+ "totalCurr <= CP_TORCH_TOTAL"
+ "totalCurr <= YETI_MAX_MFLASH_CH * 2"
+ "totalCurr <= YETI_TORCH_TOTAL"
+ "totalElapsed %lld or totalElapsedInterval %lld is invalid value\n"
+ "totalElapsed(from tracekit) %lld, totalElapsedDuringCheckpoint %lld\n"
+ "totalElapsedInterval(from tracekit) %lld, totalElapsedIntervalDuringCheckpoint %lld\n"
+ "totalNumOfPixels != 0"
+ "totalScaleDown > 0"
+ "totalScaleDown=%.3f"
+ "totalSizeInWord %d\n"
+ "totalSizeInWord >= (vCount + 1) * 6 + 2"
+ "total_chDescr_preview_frames == all_preview_frames"
+ "total_chDescr_still_frames == all_still_frames"
+ "totalscale: %f"
+ "trace ch %zu type %d  %d %d %d %d"
+ "traceBufferLock != (FFWMUTEX) 0"
+ "traceBufferMutex != (FFWMUTEX)0"
+ "traceBufferShare"
+ "traceBuffer[TRACE_BUFFER_PING]"
+ "traceBuffer[TRACE_BUFFER_PONG]"
+ "traceFlushSema != (SEMA)0"
+ "traceFlushTimer != NULL"
+ "traceRoiType != DAFTrace::DAF_TRACE_ROI_TYPE_UNSET"
+ "transport_ptr"
+ "tree_resource != (FFWMUTEX)0"
+ "tree_resource != 0"
+ "trgtLut.GetNumOfPoints() == sizeof(m_rgsBlockBaseAddr.r.Dlut)/sizeof(m_rgsBlockBaseAddr.r.Dlut[0])"
+ "trigger %s, ch %zu: currSetting %p\n"
+ "trkObjects[justSelected].age <= trkObjects[check].age"
+ "trkObjects[justSelected].age >= trkObjects[check].age"
+ "trkObjects[ti].killFlag == kAcTrkObjectKillFlag_Maybe"
+ "trkObjects[ti].killFlag == kAcTrkObjectKillFlag_None"
+ "true == axiDmaSupported"
+ "true == patchDmaSupported"
+ "true == signalAvail"
+ "true ==pRes->chCtx[chId].prevIsEV0"
+ "trying to spawn a profiling task where there is one already!!."
+ "tsNext_clk >= ts_clk"
+ "tsTuning.confidenceFilterSize <= decisionHistoryNum"
+ "tsTuning.similarityFilterSize <= decisionHistoryNum"
+ "tsTuning.skinStableFrameCount > 0"
+ "tunableManager != nullptr"
+ "tuning.levelCount >= 2"
+ "tuning.sumHisto_use_threshold || tuning.model_use_threshold || tuning.contrast_use_threshold"
+ "tuningMixRatio = %f, SimThd = %f, dayS = %f"
+ "tuningParams != NULL"
+ "tuningTable.tb != nullptr"
+ "tuningTable.tbSize <= EXP_GAIN_LUT_MAX_COUNT"
+ "tuningTable.tbSize_Sifr <= EXP_GAIN_LUT_MAX_COUNT"
+ "turned on strobe TS %f\n"
+ "txcfg[0].anode_ldo_en=0x%08X"
+ "txcfg[0].drvcurrent_e=0x%08X"
+ "txcfg[0].drvcurrent_w=0x%08X"
+ "txcfg[0].pw=0x%08X"
+ "txcfg[0].tfasst_en=0x%08X"
+ "txcfg[0].tfasst_pw=0x%08X"
+ "txcfg[1].anode_ldo_en=0x%08X"
+ "txcfg[1].drvcurrent_e=0x%08X"
+ "txcfg[1].drvcurrent_w=0x%08X"
+ "txcfg[1].pw=0x%08X"
+ "txcfg[1].tfasst_en=0x%08X"
+ "txcfg[1].tfasst_pw=0x%08X"
+ "txcfg[2].anode_ldo_en=0x%08X"
+ "txcfg[2].drvcurrent_e=0x%08X"
+ "txcfg[2].drvcurrent_w=0x%08X"
+ "txcfg[2].pw=0x%08X"
+ "txcfg[2].tfasst_en=0x%08X"
+ "txcfg[2].tfasst_pw=0x%08X"
+ "txcfg[3].anode_ldo_en=0x%08X"
+ "txcfg[3].drvcurrent_e=0x%08X"
+ "txcfg[3].drvcurrent_w=0x%08X"
+ "txcfg[3].pw=0x%08X"
+ "txcfg[3].tfasst_en=0x%08X"
+ "txcfg[3].tfasst_pw=0x%08X"
+ "txcfg[4].anode_ldo_en=0x%08X"
+ "txcfg[4].drvcurrent_e=0x%08X"
+ "txcfg[4].drvcurrent_w=0x%08X"
+ "txcfg[4].pw=0x%08X"
+ "txcfg[4].tfasst_en=0x%08X"
+ "txcfg[4].tfasst_pw=0x%08X"
+ "txcfg[5].anode_ldo_en=0x%08X"
+ "txcfg[5].drvcurrent_e=0x%08X"
+ "txcfg[5].drvcurrent_w=0x%08X"
+ "txcfg[5].pw=0x%08X"
+ "txcfg[5].tfasst_en=0x%08X"
+ "txcfg[5].tfasst_pw=0x%08X"
+ "txcfg[6].anode_ldo_en=0x%08X"
+ "txcfg[6].drvcurrent_e=0x%08X"
+ "txcfg[6].drvcurrent_w=0x%08X"
+ "txcfg[6].pw=0x%08X"
+ "txcfg[6].tfasst_en=0x%08X"
+ "txcfg[6].tfasst_pw=0x%08X"
+ "txcfg[7].anode_ldo_en=0x%08X"
+ "txcfg[7].drvcurrent_e=0x%08X"
+ "txcfg[7].drvcurrent_w=0x%08X"
+ "txcfg[7].pw=0x%08X"
+ "txcfg[7].tfasst_en=0x%08X"
+ "txcfg[7].tfasst_pw=0x%08X"
+ "type != SIDEBAND_NONE"
+ "type != SIDEBAND_NONE && addr && dataSize"
+ "type %u"
+ "type < CIC_VC_PIPELINE_TOT"
+ "type < CISP_PROJECTOR_SUBMODE_LIGHTCODING_MAX"
+ "type < configNbrPerTable"
+ "type=%u,dutyCycle=%.2u,period=%u"
+ "uBrightness != 0"
+ "uMainFlashLuxScene after FD %.2f uMainFlashLuxFaceUpperBound %.2f uMainFlashLuxFacelowerBound %.2f\n"
+ "uMainFlashLuxScene before FD %.2f w %d\n"
+ "uMinFrameRate <= uMaxFrameRate"
+ "uMinFrameRate > 0"
+ "unexpected buffer count: actual: %ld, expected: %zu"
+ "unexpected calib type %u"
+ "unexpected channel idx: actual: %ld, range: %d"
+ "unexpected input port %zu"
+ "unexpected portPin %zu"
+ "uniqueCnt > 1"
+ "unit"
+ "unit->payload.ctxSwitch.step[ctxStepIdx] < unit->payload.ctxSwitch.step[ctxStepIdx-1]"
+ "unitTestInput = %d\n"
+ "unit[i] != 0"
+ "unknown"
+ "unknown channel"
+ "unknown command id %zu"
+ "unlock"
+ "unlocked"
+ "unmap 32bits address!"
+ "unmapIPCBuffer"
+ "unmatchedDetObjectCount < unmatchedDetObjectsLen"
+ "unmatchedDetObjectCount <= maxTrkObjects"
+ "unmatchedDetObjectCount too big"
+ "unmatchedDetObjects buffer too small!"
+ "unstableWeight=%.4f, fallbackStrength=%.4f"
+ "unsteady motion"
+ "unsupported calib type %#x"
+ "unsupported calib type %d"
+ "unsupported camProcMode"
+ "unsupported property  = %#x."
+ "unsupported type %d"
+ "unusedTileCount >= 0"
+ "update viseg for ch %zu mask %u frm %u size %u done"
+ "update.frameInfo.crop.containsRect(update.subsetSensorRect)"
+ "update.id >= 0"
+ "updateBESCropInfo"
+ "updateDualControl"
+ "updateFrameCount >= 0"
+ "updateGenMaxScale"
+ "updateGenScale"
+ "updateIMUStats"
+ "updateInternalMode"
+ "updateLuxLevelFromSceneChangeDetection"
+ "updateParams->softGain > 0"
+ "updateReferenceQuaternionForTripodDirection"
+ "updateRequestId %u updateFrameCount %u"
+ "updateRequestId >= 0"
+ "updateScaleFactor"
+ "updateSema"
+ "updateStatusFromMetaData"
+ "updateTrackedObjects"
+ "updateTripodStatus"
+ "updateWindowSize"
+ "updatedMotionGlobalDampeningStrength=%f"
+ "updatedMotionLocalDampeningStrength=%f"
+ "updatediirNumDetKeys %f iirNumDetKeys %f weight %f numPoints %d\n"
+ "upperBoundPFL=%f"
+ "upperBoundPFL=%f vs %f"
+ "use %s table, maxExp %llu (%.2f), maxGain %d"
+ "use default bin ch %zu cfg %d actualwBWR=%d, requiredBWR=%d\n"
+ "use fake input"
+ "use gdc %d"
+ "use prev sifr thumbnail"
+ "useCase != PDE_USE_CASE_TYPE_MAX"
+ "useCase < CISP_TUNING_KNOB_CASE_TOT"
+ "useMonoBLC == true"
+ "useSLIN == false"
+ "user < maxUserNbr"
+ "userId = 0x%x sapId = 0x%x"
+ "users[i].sema != (SEMA)0"
+ "usingDesGen = %d"
+ "usingDgdmJoint = %d"
+ "usingDgdmJoint=%d laccMatchDMA[4]=%d wma0StartAddrHi=0x%x wma0Size=%d"
+ "usingRes = %d"
+ "uxFeedback 0x%x depthDist %.8f"
+ "v16@?0r^{lpdpcommands_lpdp_m3_to_isp_msg_s={lpdpcommands_lpdp_msg_hdr_s=CCCC}{lpdpcommands_lpdp_m3_to_isp_payload_types__opt=B{lpdpcommands_lpdp_m3_to_isp_payload_types=Q(?={?={lpdpcommands_lpdp_error_check_s=cC[6c]I}}{?={lpdpcommands_lpdp_send_eq_s=SSSSSSSS}}{?={lpdpcommands_lpdp_send_ad_eq_s=CBSSSSSSSS}}{?={lpdpcommands_lpdp_be_rx_info_s=cII}}{?={lpdpcommands_lpdp_send_dprxc_status_s=IIIIIIIIIIIII}}{?={lpdpcommands_lpdp_send_rc_params_s=CC}})}}}8"
+ "v16@?0r^{sensorcommands_sensor_m3_to_isp_msg_s={sensorcommands_sensor_msg_hdr_s=CC}{sensorcommands_sensor_m3_to_isp_payload_types__opt=B{sensorcommands_sensor_m3_to_isp_payload_types=Q(?={?={sensorcommands_sensor_send_configs_tot_s=I}}{?={sensorcommands_sensor_send_config_s={sensorcommands_sensor_config_s=ISSCCSIISSIIISISSII}}}{?={sensorcommands_sensor_send_readout_s={sensorcommands_sensor_readout_position_s=SSSSSSSS}}}{?={sensorcommands_sensor_send_fine_int_s={sensorcommands_sensor_fine_int_s=I}}})}}}8"
+ "vEndX < input.sizeX - 1"
+ "vEndY < input.sizeY"
+ "vFromExp %u vPrimary %d vSifr %d prevRDOffset %d"
+ "vHDR only, currFrame[%d] is EV0, skipping NccRansac"
+ "vHDR only, currFrame[%d] is EVm, run NccRansac"
+ "vHDRAdaptiveControl"
+ "vHDRStillBufferFree"
+ "vHDRStillBufferMalloc"
+ "vIntX == pattern.grid.spacingX"
+ "vIntX > 0"
+ "vPrintLock != (SEMA)0"
+ "vPrintLock == (SEMA)NULL"
+ "vScale >= 0x10000"
+ "vScale >= 0x4000"
+ "vSize clamped to %d, vH %d maxVH %d"
+ "vStartX == pattern.grid.startX"
+ "vStartX >= 1"
+ "vStartY < pattern.grid.startY"
+ "vStartY >= 0"
+ "vStep1 = %d, vStep = %d, vCount = %d\n"
+ "val"
+ "val == 0"
+ "valid != 0"
+ "valid != nullptr"
+ "validRectPri {%d %d %d %d} besOut {%d %d}"
+ "validRectSec {%d %d %d %d} auxScl {%d %d}"
+ "validRectStill {%d %d %d %d} out {%d %d %d %d}"
+ "validSensorRawRect.x >= 0"
+ "validSensorRawRect.y >= 0"
+ "valid_cc = %s"
+ "valid_cil = %s"
+ "valid_dpc = %s"
+ "valid_lsc = %s"
+ "valid_mil = %s"
+ "valid_sn = %s"
+ "validateForFDTO"
+ "validatingTestModeConstraintsData"
+ "value"
+ "value != 0"
+ "value <= 100000 && value >= 100"
+ "value <= 128"
+ "value == 0 || value == 1"
+ "value == ISP_FREQ_DITHER_DISABLED || value == ISP_FREQ_DITHER_4MS || value == ISP_FREQ_DITHER_8MS || value == ISP_FREQ_DITHER_16MS"
+ "value == PDE_PEARL_USECASE_NORM || value == PDE_PEARL_USECASE_FID"
+ "value == PDE_REGUPDATE_TWEAK_NONE || value == PDE_REGUPDATE_GMC_FACTORY_1 || value == PDE_REGUPDATE_GMC_FACTORY_2"
+ "value == true || value == false"
+ "value >= 0"
+ "vb"
+ "vc != -1"
+ "vc %zu csRaw %p\n"
+ "vc %zu dmamode %d @ %llu %p csRaw %p dma %llu intCollectedDMA 0x%x 0x%x\n"
+ "vc %zu fc %d [%u] e=%u et=%u ag=%u dg=%u idg=%u vfs=%u vft=%u aec=%llu\n"
+ "vc %zu fc %d [%u] scp=%.0f spw=%.0f st=%u nss=%u sb=%u ll=%u\n"
+ "vc %zu fc %d enq %llu %llu %llu 0x%0x %u %u %u %u %u %.4f %.4f %d\n"
+ "vc %zu fc %d exclave UpdateDopplerWindow fc: %d\n"
+ "vc %zu fc %d exclave fvSyncSema mICState %d\n"
+ "vc %zu fc %d exclave popAckIrqSema\n"
+ "vc %zu fc %d exclave rvSyncSema skip=%u ok2dequeue=%u dequeueDone=%u\n"
+ "vc %zu fc %d oc=[%u %u] fl=[%u %u]\n"
+ "vc %zu fc %d ts %llu\n"
+ "vc %zu thumbWidth %u thumbHeight %u maintag %llx sifrtag %llx\n"
+ "vc >= 0 && vc < ISP_CAMERA_CHANNEL_TOT"
+ "vcId < 2"
+ "vcPipelineIndex != ISP_RESOURCE_VC_PIPELINE_NONE"
+ "vcPipelineToChannel[vcPipelineIndex].channel != (uint32_t)~0"
+ "vcPipelineToChannel[vcPipelineIndex].channel == (uint32_t)~0"
+ "vcPipelines[CIC_VC_PIPELINE_MAIN] >=0"
+ "veModel != nullptr"
+ "verifyNetOutput"
+ "verifySignalStrengthFromTileStats"
+ "version != 0x06"
+ "version = %d"
+ "version=%hhu slaveCh=%hhu, set-file=0x%x masterGain=%u %u slaveGain=%6.2f %6.2f"
+ "versionInfo = %d"
+ "verticalPixelCountInCellRow > 0"
+ "virtualAddr != NULL"
+ "virtualCh < CAM_CH_TOT"
+ "virtualCh < ISP_CAMERA_CHANNEL_TOT"
+ "virtualCh == DEPTH_CAM_CH"
+ "virtualCh == IR_CAM_CH"
+ "virtualCh=%zu, blk=%llu, oneFrameTimeUs=%llu, totalReadOutTimeUs=%llu\n"
+ "virtualCh=%zu, pipeId=%d, isSifrOn=%d\n"
+ "virtualCh=%zu, total fepwBWR=%d\n"
+ "virtualCh=%zu, vcPipeID=%d\n"
+ "visAdjustRangePercentage is Set %f\n"
+ "visOption width %d height %d"
+ "visOption width %d height %d ratio %f"
+ "visPipeResizeCrop"
+ "visProcDmaEn == visProcDmaEnabled"
+ "visegMask < ViSegTaskOutputTot"
+ "visionPipe0InputHeight >= (crop.y + crop.height) || (pDescr->paramBES.streamEnable[IMAGE_BE_OUTPUT_SECONDARY] && (ch == SWIDE_CAM_CH))"
+ "visionPipe0InputWidth >= (crop.x + crop.width) || (pDescr->paramBES.streamEnable[IMAGE_BE_OUTPUT_SECONDARY] && (ch == SWIDE_CAM_CH))"
+ "visionPipeSrcHeight >= inputCrop.y + inputCrop.height"
+ "visionPipeSrcWidth >= inputCrop.x + inputCrop.width"
+ "vispipe FFCFOV: [%.4f, %.4f, %.4f, %.4f]"
+ "vispipe inWidth=%d|inHeight=%d|instride=%d|outWidth=%d|outHeight=%d|outStride=%d"
+ "vnfIn.tblSizeDotDetectLUT == VISPIPEH17_VNF_DOTDETECTLUT_SIZE"
+ "vnfIn.tblSizeStdYLUT == VISPIPEH17_VNF_STDYLUT_SIZE"
+ "vnfIn.tblSizeYCoeff == VISPIPEH17_VNF_YCOEFF_SIZE"
+ "vposwait=0x%08X"
+ "vsync to mid RO is not implemented"
+ "vsync2MidRoTime_m >= vsync2MidRoTime_s"
+ "w %d h %d\n"
+ "w%d s%d h%d"
+ "w=%d, h=%d, stride=%d, size=%d"
+ "wBWR > 0"
+ "waitSema != 0"
+ "waitTime_ms++ < 100"
+ "waited out the trigger the source"
+ "waited out the trigger the source: %d \n"
+ "warn CIC_CMD_DISTORTION_DATA_GET ch %zu %d %d"
+ "warpM3InSize < pPplInfo->algBufInfo.bufferMsFuseWarperM3->Size()"
+ "warpM3InSize < pPplInfo->algBufInfo.bufferWarperM3->Size()"
+ "warpMat is NOT valid, missed count = %d < %d"
+ "warpMat is NOT valid, missed count = %d == %d"
+ "warpMat is valid"
+ "warpSliceCount=%d, warpSliceHeight=%d\n"
+ "warperMode <= AISP_BESPROC_PIPE_BESPROCWARP_CONFIG_MODE_STREAM"
+ "wbGain      = %hu %hu %hu %hu -> %hu %hu %hu %hu"
+ "wbGain: %hu, %hu, %hu"
+ "wbGainCombo = %hu %hu %hu %hu -> %hu %hu %hu %hu"
+ "wbGainNorm  = %hu %hu %hu %hu -> %hu %hu %hu %hu"
+ "wbgGain[0] > 0 && wbgGain[1] > 0 && wbgGain[2] > 0"
+ "weightArray != 0"
+ "weightBottom <= 1"
+ "weightBottom >= 0"
+ "weightRight <= 1"
+ "weightRight >= 0"
+ "width"
+ "width != 0"
+ "width <= 1536 && width >= 32"
+ "width <= 8704 && width >= 192"
+ "width = %d, heigth = %d, remainingScaleToRawSize=%f"
+ "width = %d, heigth = %d, remainingScaleToRawSize=%f\n"
+ "width = %d, outWidth = %d, width/outWidth = %f is greater than 1.0/lower = %f, and\n"
+ "width = %d, outWidth = %d, width/outWidth = %f is less than 1.0/lower = %f, or\n"
+ "width >= 64 && width <= 4608"
+ "width >= kNccProcRawWidthMin"
+ "width full %u curr %u"
+ "win + (AF_MAX_HILL_POS-1) * m_numValidAFWindows < FE_NUM_AF_WINDOWS * AF_MAX_NUM_SEARCH_POSITIONS"
+ "win + (i+1) * m_numValidAFWindows < FE_NUM_AF_WINDOWS * AF_MAX_NUM_SEARCH_POSITIONS"
+ "win + i * m_numValidAFWindows < FE_NUM_AF_WINDOWS * AF_MAX_NUM_SEARCH_POSITIONS"
+ "win + numHillTrackPos * m_numValidAFWindows < FE_NUM_AF_WINDOWS * AF_MAX_NUM_SEARCH_POSITIONS"
+ "win + posIdx * m_numValidAFWindows < FE_NUM_AF_WINDOWS * AF_MAX_NUM_SEARCH_POSITIONS"
+ "winNumber < FE_NUM_AF_WINDOWS"
+ "winNumber < FE_NUM_AWBAE_WINDOWS"
+ "winSize=%llums\n"
+ "window + i * m_numValidAFWindows < FE_NUM_AF_WINDOWS * AF_MAX_NUM_SEARCH_POSITIONS"
+ "window < PROC_WINDOW_SIZE_TOT"
+ "windowCount <= MAX_WIN_COUNT"
+ "windowCount == 15"
+ "wma0Mode = 0x%x, wma1Mode = 0x%x, wma2Mode = 0x%x, wma3Mode = 0x%x"
+ "wma0Size = %d"
+ "wma0StartAddrHi = 0x%x"
+ "wma0StartAddrLow = 0x%x"
+ "wma1Size = %d"
+ "wma1StartAddrHi = 0x%x"
+ "wma1StartAddrLow = 0x%x"
+ "wma2Size = %d"
+ "wma2StartAddrHi = 0x%x"
+ "wma2StartAddrLow = 0x%x"
+ "wma3Size = %d"
+ "wma3StartAddrHi = 0x%x"
+ "wma3StartAddrLow = 0x%x"
+ "workers != nullptr"
+ "workers->pitch_worker"
+ "workers->roll_worker"
+ "workers->yaw_worker"
+ "workloop add"
+ "world gravityXYZ[%d]= %f %f %f"
+ "wp= %.2f %.2f -> %.2f %.2f ccGain = %.2f %.2f -> %.2f %.2f wbGain= %.2f %.2f -> %.2f %.2f"
+ "wpIn=[%f, %f], wpOut=[%f, %f]"
+ "wpWeight = %f, wpConf = %f"
+ "wrapperId < CICWRAPPER_RCAM_TOT_"
+ "write ATTR procedure %u result size %u to attr_proc%u_out.bin"
+ "writeData != NULL"
+ "writebuf"
+ "wrong bufcnt net %d buftype %d cnt %u %u"
+ "x %d y %d"
+ "x < buf.width && y < buf.height"
+ "x <= slices[0].end().x"
+ "x == 0"
+ "x == 2"
+ "x >= 16"
+ "x >= 64"
+ "x >= LTM_LOCAL_HIST_MIN_STRIDE_X"
+ "x >= MIN_HITH_THUMBNAIL_BLOCK_WIDTH"
+ "x >= slices[1].start.x"
+ "x=%d lux=%d strength=%d"
+ "xAddEnd == IMX633_Readout_Position[configNumber].xEnd"
+ "xAddEnd == IMX703_Readout_Position[configNumber].xEnd"
+ "xAddEnd == IMX713_Readout_Position[configNumber].xEnd"
+ "xAddEnd == IMX714_Readout_Position[configNumber].xEnd"
+ "xAddEnd == IMX803_Readout_Position[configNumber].xEnd"
+ "xAddEnd == IMX903_Readout_Position[configNumber].xEnd"
+ "xAddEnd == IMX972_Readout_Position[configNumber].xEnd"
+ "xAddEnd == pReadoutWindow[configNumber].xEnd"
+ "xAddSta == IMX633_Readout_Position[configNumber].xStart"
+ "xAddSta == IMX703_Readout_Position[configNumber].xStart"
+ "xAddSta == IMX713_Readout_Position[configNumber].xStart"
+ "xAddSta == IMX714_Readout_Position[configNumber].xStart"
+ "xAddSta == IMX803_Readout_Position[configNumber].xStart"
+ "xAddSta == IMX903_Readout_Position[configNumber].xStart"
+ "xAddSta == IMX972_Readout_Position[configNumber].xStart"
+ "xAddSta == pReadoutWindow[configNumber].xStart"
+ "xGridPos && yGridPos"
+ "xInt %d  yInt %d  offsetX %d  offsetY %d\n"
+ "xInt >= xIntHocl && yInt >= yIntHocl"
+ "xOffsetInGrid >= 0 && yOffsetInGrid >= 0 && dmaGridEndX <= pLSConfig->H6.gridCountX && dmaGridEndY <= pLSConfig->H6.gridCountY"
+ "xPts <= CISP_MAX_CIC_GRID_X"
+ "xPts <= CISP_MAX_LSC_GRID_X"
+ "xRatio > 0"
+ "xShiftOffset == 0"
+ "xStartY < srcPyrInfo.widths[crop.pyrIndex]"
+ "xenSema != 0"
+ "xtalk_norm"
+ "y == 0"
+ "y == 3"
+ "y >= 2"
+ "y >= LTM_LOCAL_HIST_MIN_STRIDE_Y"
+ "y >= MIN_HITH_THUMBNAIL_BLOCK_HEIGHT"
+ "y scan limit y min %d yMax %d round %u y size %d"
+ "y=%d x=%d RGBRatio=%6.2f %6.2f %6.2f skinColor=%6.2f %6.2f %6.2f maskTile=%6.4f "
+ "yAddEnd == IMX633_Readout_Position[configNumber].yEnd"
+ "yAddEnd == IMX703_Readout_Position[configNumber].yEnd"
+ "yAddEnd == IMX713_Readout_Position[configNumber].yEnd"
+ "yAddEnd == IMX714_Readout_Position[configNumber].yEnd"
+ "yAddEnd == IMX803_Readout_Position[configNumber].yEnd"
+ "yAddEnd == IMX903_Readout_Position[configNumber].yEnd"
+ "yAddEnd == IMX972_Readout_Position[configNumber].yEnd"
+ "yAddEnd == pReadoutWindow[configNumber].yEnd"
+ "yAddSta == IMX633_Readout_Position[configNumber].yStart"
+ "yAddSta == IMX703_Readout_Position[configNumber].yStart"
+ "yAddSta == IMX713_Readout_Position[configNumber].yStart"
+ "yAddSta == IMX714_Readout_Position[configNumber].yStart"
+ "yAddSta == IMX803_Readout_Position[configNumber].yStart"
+ "yAddSta == IMX903_Readout_Position[configNumber].yStart"
+ "yAddSta == IMX972_Readout_Position[configNumber].yStart"
+ "yAddSta == pReadoutWindow[configNumber].yStart"
+ "yEnd %d ySta %d"
+ "yEnd > ySta"
+ "yEnd > yStart"
+ "yPts <= CISP_MAX_CIC_GRID_Y"
+ "yPts <= CISP_MAX_LSC_GRID_Y"
+ "yRatio > 0"
+ "yScal=%.3f"
+ "ySta % yConstraint == 0"
+ "ySta >= yMin && ySta <= yMax"
+ "yStaRound"
+ "yStartY < srcPyrInfo.heights[crop.pyrIndex]"
+ "ycc: ch %zu, distortionCenterXInColorProc=%d, distortionCenterYInColorProc=%d\n"
+ "yuvBufY != nullptr"
+ "yuvstride != 0"
+ "zDelta > 0 && cocBlurThreshold > 0 && defocusCocScaling > 0"
+ "zeroExtentionSize = 0x%x"
+ "zoom fesCrop H %d Y %d dmaSrcCrop Y %d\n"
+ "zoom offset %d %d configNum %d"
+ "zoom1xSetting FES x %d y %d width %d height %d rawWidth %d rawHeight %d"
+ "zoomUnmapMultiplier:%f"
+ "{\"name\": \"%4.4s-%5.5s:%u:%zu\", \"ph\": \"%c\", \"pid\": \"FW\", \"tid\": \"%s\", \"ts\": %llu},\n"
+ "~AggregatedSharedMemoryAllocator"
+ "~CAWBAFE"
+ "~CAWBAFEH16"
+ "~CAWBApple"
+ "~CCvdDpProcH17"
+ "~CDotEFuse"
+ "~CFloodEFuse"
+ "~CImageFlowH17"
+ "~CLCPlayback"
+ "~CLensControllerHx"
+ "~CLensService"
+ "~CMamaBear"
+ "~CPDEProc"
+ "~CRTOSStat"
+ "~CScopedLock"
+ "~CStrobeRegulus"
+ "~CStrobeRigel"
+ "~CTaskProfiler"
+ "~CViSegDataService"
+ "~CVideoFlowH17"
+ "~FwDetectorFdDecoder"
- "     channel=%hhu CCT=%u iir=%u unstable=%u fallback=%u daylight=%u"
- "     globalWP R=%u B=%u targetCool R=%u B=%u prevCool R=%u B=%u"
- "     mthCoolGainOut R=%u B=%u fNo=%u itnFNo=%u lvtFlt=%u"
- "   rbn=%d %d rbn_gw=%d %d gray=%d gray_gw=%d"
- "  Arch: arm64\n"
- "  Semaphores %#04x [%s]\n"
- "  flows:\n"
- " Bracketing [#%d, ExpTime %d, Gain 0x%x, Proj (%u, %u, %u)]\n"
- " aps_gravity_vector_deg"
- " unable to set framerate resetting MSG settings"
- "!a64e"
- "%s %s Cannot change secure mode if task stopped"
- "%s %s Channel (%lu) and usecase (%u) mismatch"
- "%s %s CmdPCENonSecureToSecurePost failed"
- "%s %s CmdPCESecureToNonSecurePost failed"
- "%s %s Failed to acquire semaphore for %#x"
- "%s %s Failed to register to the ISR manager"
- "%s %s GMS buffer pool provides buffers that are not big enough to store GMS output"
- "%s %s Invalid request"
- "%s %s No available slot for a new signal"
- "%s %s Not implemented yet..."
- "%s %s Please add macro for the following buffersCount %lu"
- "%s %s Unexpected channel (%zu) for command %u"
- "%s %s Unexpected channel for OUPUT_CONFIG %zu"
- "%s %s Unexpected signal"
- "%s %s Unexpected type for OUPUT_CONFIG (type=%#x)"
- "%s %s cant stop channel (%zu)"
- "%s %s invalid tmp shared buffer %d"
- "%s %s semaphore for %#x was already returned, but it shouldn't"
- "%s %s unexpected input port %zu"
- "%s %s unexpected portPin %zu"
- "%s %s unknown command id %zu"
- "%s .Sanity check failure!\n"
- "%s Aries %s: 6.25GHz\n"
- "%s HYPERFOCAL LOCK\n"
- "%s WRN: sensor already booted! %x\n"
- "%s ch %d lastDepthValid %d index %llu err %d \n"
- "%s ch %d: APE Persistent corr %f delta %f, restricted scan range %f\n"
- "%s ch %d: Cant use this for updating FC estimator \n"
- "%s ch %d: Cant use this for updating PFL estimator \n"
- "%s ch %d: Depth VALID %d *****\n"
- "%s ch %d: Jasper Latency: %f (lim %f) \n"
- "%s ch %d: Received JasperDepth: %f %f, ispTimeStamp= %llu \n"
- "%s ch %d: Received PDE Depth: %f %f, ispTimeStamp=%llu \n"
- "%s ch %d: SLAF Latency: %f (lim %f) \n"
- "%s ch %d: afTargetDepthMSP_mm %.2f \n"
- "%s ch %d: currentPos: %d deFocus %f (PDAF %d, %d) %d \n"
- "%s ch %d: defocusChange %f pdafPos change %f \n"
- "%s ch %d: depthChange during deFocus %f (%f) , %f (%f)  hist %d %d (%d) \n"
- "%s ch %d: extended spot depth std %f z(%f <-> %f), delta = %f (%d)\n"
- "%s ch %d: ispTime: %llu, LargeCamMotion: %d, largeShiftSinceLastDepth: %d (%.2f)\n"
- "%s ch %d: largeMotion %d (skip %d), pbafConfNG %d, chngDepth %d, spot %d halt %d\n"
- "%s ch %d: nom vs extend spot depth z(%f <-> %f), delta = %f (%d)\n"
- "%s ch %d: pdafTgtPos[%d] %d (%f, %f) \n"
- "%s ch %d: spot depth std %f z(%f <-> %f), delta = %f (%d)\n"
- "%s ch %d: zMSP_RelPkOfstINF %.2f zMSP_RelPkOfstfMAC %.2f\n"
- "%s ch %d: zMSP_RelPkOfstINF %.2f zMSP_RelPkOfstfMAC %.2f zMSP_FieldCurveOfst %.2f \n"
- "%s ch %d: zMSP_TOL %.2f zMSP_POS_M %d zMSP_POS_T %d zMSP_POS_P %d \n"
- "%s sensor status: %d\n"
- "%s(%p) Couldn't find builtinProgramId %d !!!\n"
- "%s() Failed to start channel %zu early"
- "%s, %d: IC wait total %.4fms\n"
- "%s, %d: [%s] ch %zu stop done! @%.4f\n"
- "%s: %s: Callback register failed, pool %p"
- "%s: %s: Callback unregister failed, pool %p"
- "%s: %s: Get latest entry index failed"
- "%s: %s: Pool bind failed, pin %zu pool %p"
- "%s: %s: Proc fail, Buf %p DP %p"
- "%s: Aries not in secure boot: %d\n"
- "%s: pub key not ready\n"
- "%s: zero gain values in meta data (%d, %d, %d, %d)!"
- "22:04:36"
- "7608938"
- "AETable_LLV_Regular"
- "AETable_Photo_Flash"
- "AETable_Photo_Long"
- "AETable_Photo_Long_Qsub"
- "AETable_Photo_Regular"
- "AETable_Photo_Regular_Qsub"
- "AETable_VFR_Regular"
- "AETable_default_Regular"
- "AICAM enable failed"
- "APE(ExStats): ch%d: spdNotActive.                  : %d \n"
- "Aries in BOOT state! Expect SECURE_BOOT\n"
- "B0_mode000_1312x1108_full_gs_lcg_1ms_60fps_1x6p25g_raw12"
- "B0_mode001_1312x1108_full_mod_lcg_7ms_60fps_1x6p25g_raw12"
- "B0_mode002_1312x1108_full_mod_lcg_7ms_60fps_1x6p25g_raw12"
- "BG_HapticsCoexMitigation_Init"
- "BG_HapticsCoexMitigation_Iteration"
- "BG_HapticsCoexMitigation_Stop"
- "BackgroundActionIterateNonBlocking"
- "CFEStatH17.cpp"
- "CH[%1d] F[%1d][%1d]%3d [%2d] D[%5d][%5d] P[%5d]%2d PFPS[%2d] APE[%s] [T %2d] [MFD %3d]%1d"
- "CH[%1d][%s]  [%s][%s]  [%s][%s]  BLB[%s][%s][%s][%s] [CR %2d][T %2d]"
- "CLensCtrlAFAssist.cpp"
- "CRNT[T %2d] [CR %2d] D[%5d] DMSP[%5d] Z[%3d] PFL[%4d] DFPS[%3d] Lux[%s]"
- "CRT: CPCEFlowManager.cpp:%d [DSI] Entering suspend mode (power = %d)\n"
- "CRT: CPCEFlowManager.cpp:%d [DSI] PCE - Entering Secure Mode (power = %d)\n"
- "CRT: CPCEFlowManager.cpp:%d [DSI] PCE - Exiting Secure Mode (power = %d)\n"
- "CS40L62_GROUP_4_V21_C6_0"
- "CS40L62_GROUP_5_V21_C6_0"
- "Cannot find the matching model for camera %06X. Skip matching process."
- "CmdLSParamsFullImageSet"
- "ConfidneceMap Buffer not avialble now. ch %zu, frCnt %u"
- "Couldn't find ShareMemInfoItem to free !!!\n"
- "Currently MLVNR is disabled on J714/J716, J700, J427/J527, will be enabled when MLVNR FW/AFPP support ready"
- "DumpSemanticMap_%u.data"
- "ECDH key read failed\n"
- "ECDH sensor status: %d\n"
- "ECDH size %d < %d\n"
- "ECDH: Failed to write keys\n"
- "ECDHE boot not cleared\n"
- "ER frSkip: invalid input buffers (IR mismatch)"
- "Encrytion setting: %llu\n"
- "Error, no messages, dropping this command id=%zd \n"
- "EventLogger is not enabled!\n"
- "FCTRY: Ch%d Step %u: var: %.2f/%.2f (%.3f); s: %d/%d (tgt: %.3f)\n"
- "FD frSkip: invalid input buffers (IR/Depth mismatch)"
- "FDTO_WRN: ch %zu, prevRDO %d + curEIT %d > new vFrmSz %d"
- "FMAP_FATE"
- "Failed to allocate totSize=%zu"
- "Failed to load HPR keys\n"
- "FilterCvdDp: Move operation into the right pool"
- "GPBes Output frame=%d Failed!"
- "GPBesTimeout %d"
- "GetLatestDepthFocusEntry"
- "GetProgramDescription Model %d, waiting for 3ms"
- "GetSLAFDepthData"
- "GetTOFDepthData"
- "H9ISP-14.63.03"
- "H9ISP-14.64.00"
- "HPR boot not cleared\n"
- "HPR_UPLOADED not set \n"
- "Haptics Coex Mitigation"
- "Here we setup the PatchDma for id %d\n"
- "IPC Endpoint cmd failed %d"
- "IPC Endpoint cmd failure"
- "Incorrect Initialization Of Secure M3 LPDP Wrapper\n"
- "Int:(%d, %d), Offset:(%d, %d), Count:(%d, %d), stride=%d\n"
- "Invalid Index"
- "Key Exchange not ready!\n"
- "LC2LCAux"
- "LCAUX Ch%zu Finished %s\n"
- "LCAux"
- "LCAux2LC"
- "LCBGA %d Haptics coex mitigation not supported\n"
- "LCBGA %s: Ch%d Focus Power Rail is off, Aborting\n"
- "LCBGA %s: Ch%d GCOL target %f um\n"
- "LCBGA %s: Ch%d Stopping\n"
- "LCDRV %s L%d Ch%d pAF is NULL during Suspend\n"
- "LCDRV %s: Done\n"
- "LCDRV [DEBUG] CH%d pAF is NULL while resuming\n"
- "LCDRV ch%u Invalid mode: %d"
- "LCDRV ch%u Invalid mode: %d\n"
- "LENSC: %s ch%zu L%d: Focus Power Rail already on!\n"
- "LENSC: %s ch%zu L%d: Sensor Power Rail already on!\n"
- "LENSC: %s ch%zu L%d: post (ack) failed - rc = %d"
- "LENSC: Ch%zu Blocking State Change Request Completed\n"
- "LENSC: Ch%zu in state %d, can't start background action (%d)!\n"
- "LENSC: Channel already started (only STOP accepted, ignoring request %d)"
- "LENSC: Skipping early init for ch%zu\n"
- "LENSC: Unhandled request! ch%d; desiredState: %d; ack: %c"
- "LENSC: ch %zu, Curr state STOPPED, ignoring INITIALIZED request"
- "LENSC: ch %zu, Curr state STOPPED, ignoring STARTED request"
- "LFAFPosStdMonitoring"
- "LRNZ+ %u Device reset failed! err: %d"
- "LRNZ+ %u I2C Base Address Change Failed!\n"
- "LRNZ+ %u Time to reset (p1-p2): %.2f ms (%u patches loaded)\n"
- "LRNZ+ %u Time to reset (p2): %.2f ms\n"
- "LRNZ+ Ch%u Time to %s (p1): %.2f ms\n"
- "MLAF BufferProcessor Finish pin: %zu, pinIdx: %zu, nidx: %zu.\n"
- "MLAF BufferProcessor pin: %zu, pinIdx: %zu, nidx: %zu.\n"
- "MLAF Channel Start NetInit %zu.\n"
- "MLAF Channel Start NetInit Finish %zu.\n"
- "MLAF Channel Start bufferInit %zu.\n"
- "MLAF Channel Start bufferInit Finish %zu.\n"
- "MSNR %u Device reset failed! err: %d\n"
- "MSNR Ch%u Time to %s (p1): %.2f ms\n"
- "MSNR Ch%u Time to %s (p1-p2): %.2f ms (%u patches loaded)\n"
- "MSNR Ch%u Time to %s (p2): %.2f ms\n"
- "Metadata version not matching, input(%d), current(%d)."
- "No stats master metadata!!! statMasterCh %hhu previewCh %hhu"
- "No temp monitoring for module %d\n"
- "PRE(ExStats): ch%d: spdNotActive.                  : %d \n"
- "PearlCntl Meta(%d): vld %d - %d, %d, %d, {%d, %d, %d, %d, %d}, %x, %d\n"
- "Platform uses PLA src DMA for RsclPipe hence disabling SIF compression"
- "Program %d not loaded yet"
- "PublicKeyGet: Not Available. size %d < 64\n"
- "Run out of CSharedMemory !!!\n"
- "RunAPETraining"
- "SPMI bus %u base %zu\n"
- "STOP "
- "Sema[3] not null %p"
- "SourceGo.bin"
- "Start1"
- "Start2"
- "Still in secure mode - continue with suspend; force irq clear/disable\n"
- "TF only, currFrame[%d] is EVm, something wrong!"
- "TM: Ch %zu Dropping last tuning params. TuningCnt %d BktCunt %d SymcBitMask 0x%x. Force to reset capture!!\n"
- "TS=%llu ch=%u extremeLowLightMode=%u Quadra %u lux=%d LumaBinningMode=%d msOverallZoomFactor0_1024=%u fps=%d\nInput: WHS %d,%d,%d RO ROI XYWH=%d,%d,%d,%d, OffsetToOrigin XY=%d,%d.\nOutput: startX %d, startY %d, endX %d, endY %d, sizeX %d, sizeY %d, byteStrideLuma %d\n"
- "Tightbeam IPC send msg failed. status %x\n"
- "Tile Reg:[%d %d %d %d] [%d %d %d %d]"
- "TransitionComplete"
- "TransitionRequest"
- "VD56G8 %s <%x> <cnt %d fsm %04x> flag 0x%x @ %llu\n"
- "VD56G8 %s boot up(%d). %x %d\n"
- "ZFDepth: %s CH%zu [PDE supROI_startXY, endXY] = [%.2f,%.2f][%.2f,%.2f]\n"
- "[%f] ch %zu AE stream control request when IC not streaming"
- "[%lu] unknown FW_platformID: %d\n"
- "[%s] CH = 0x%zu   LTM Weight segmentation Map enable = %u, seg number: %u, width: %u, height: %u, %s\n"
- "[%s] CH = 0x%zu  AE-Projector Manual Bracketing Set [#%d], %s\n"
- "[%s] CMD = %#04x mappedWriteNogtifierRegiterAddr 0x%x value %x\n"
- "[%s] CMD = %#04x readRingBuffer Addr 0x%x len 0x%x\n"
- "[%s] CMD = %#04x writeRingBuffer Addr 0x%x len 0x%x\n"
- "[%s] L%d lens controller ALL ASYNC %s dt: %.2f ms; ts: %llu ms\n"
- "[%s] L%d lens controller ch%zu ASYNC %s dt: %.2f ms; ts: %llu ms\n"
- "[%s] L%d lens controller ch%zu BLOCK %s called; ts: %llu ms\n"
- "[%s] L%d lens controller ch%zu BLOCK %s dt: %.2f ms; ts: %llu ms\n"
- "[%s] L%d lens controller ch%zu BLOCK PREWARM dt: %.2f ms; ts: %llu ms\n"
- "[ALSC] ALS reset after ALS_MAX_RESET_FRAME"
- "[ALSC] daylightWeight=%d, alscTuningStrength=%.2f"
- "[ALSC] method=%d enable=%d"
- "[CnR] %s ch%zu[%d] cnrFDist = [%d][cm] (cnrFocusPos = %d) maxFocusPos = %d, intent=%d\n"
- "[DEBUG] %s L%d Ch%zu Current State = %d\n"
- "[DEBUG] Ch%zu %s L%d State Req = %d -> %d\n"
- "[DEBUG] Ch%zu %s L%d pAF is NULL\n"
- "[DSI] %s (subMode=%d, flowType=%d)"
- "[DSI] %s Failed to send buffer to sink"
- "[DSI] %s Invalid subMode (subMode=%d, flowType=%d)"
- "[DSI] %s No ST for uninit flow (state=%u)"
- "[DSI] %s No high confidence points"
- "[DSI] %s ResetAllPartialFlows didn't release all flows as needed"
- "[DSI] %s Self Destruction"
- "[DSI] %s condition not satisfied: %s"
- "[DSI] %s failed set property=%d value=%d"
- "[DSI] %s failed to alloc buffer from %s"
- "[DSI] %s flow could not contain pearl flow and also fusion flow at same time"
- "[DSI] %s flow state after set primary data should be %u, but it's %u"
- "[DSI] %s flow with this input already exists (ch=%zu, ST=%d)"
- "[DSI] %s outOfBound is %u but failed to alloc buffer"
- "[DSI] %s pearl depth depending on IR inputs..."
- "[DSI] %s property %d not handled"
- "[DSI] %s resolutions should have been the same! %d != %d"
- "[DSI] %s unable to allocate gmsMetadataInputBuf"
- "[DSI] %s unexpected calib type %u"
- "[DSI] %s unsupported control type provided (%d)"
- "[DSI] %s unsupported inputChannel %zu"
- "[DSI] %s: AllocSequenceEntry() failed"
- "[DSI] Anchor validation falied"
- "[DSI] Core analytics percentage totalNumOfPixels %u, PSBDepthBin0 %u"
- "[DSI] Could not get latest front RGB APS Pos from CLensService, err %d"
- "[DSI] Couldn't get distortion parameters"
- "[DSI] Data is NULL, refIdx=%hu"
- "[DSI] DistDrv RGB calibration intrinsics version changed!"
- "[DSI] Driver did not set any output config, skipping frame"
- "[DSI] Drop frame upon fail precond for %s (%#x)"
- "[DSI] Exit 3, GMS LOOP did not run for %u consecutive frames"
- "[DSI] Failed to acquire m_calibMutex"
- "[DSI] Failed to send msg to Sink"
- "[DSI] Front RGB APS Pos not available"
- "[DSI] GDC table validation falied"
- "[DSI] GMC during FID has timed-out!! Stop waiting for GMC (%s)"
- "[DSI] GMS LOOP did not run for %u consecutive frames"
- "[DSI] GMS is missing required buffer"
- "[DSI] GMS is missing required pipe"
- "[DSI] GMS is missing required pool"
- "[DSI] GMS not triggered due to unmet preconditions"
- "[DSI] Hardcoded FCAM calibration values missing for this device type"
- "[DSI] Ignoring GMS LOOP results"
- "[DSI] Index out of range: index=%u, max-index=%u"
- "[DSI] Invalid subMode"
- "[DSI] No RGB calib! Using nominal intrsics no extrisics, no rgb reg!"
- "[DSI] No sMetaData"
- "[DSI] No valid FCAM calibration from FCCL, using nominal hardcoded values"
- "[DSI] Not expecting channel stop in this state! (%d)"
- "[DSI] PCE Calibration loading failed! (%x, %d != %lu)"
- "[DSI] PCE already in Secure mode according to SECMODESTAT"
- "[DSI] PCE input bigger than PDEDebug section in host metadata"
- "[DSI] PCE is in secure mode according to SECMODESTAT"
- "[DSI] PDE2FDDcn full, ic %llx now %llx %.3fms!"
- "[DSI] PDE2MLAF full, ic %llx now %llx %.3fms!"
- "[DSI] PDE2PCEAlgo full"
- "[DSI] PDE2PDAF full, ic %llx now %llx %.3fms!"
- "[DSI] PearlFPDNotifySafety failed"
- "[DSI] PearlGMCRPCDone didn't receive it's self object"
- "[DSI] PearlSetSmartRef LZ4 Error=%d! (DT=%d IDX=%d %f Size=%d)"
- "[DSI] PearlSetSmartRef size too small (%d %lu)!"
- "[DSI] PearlSetSmartRef unknown sep header! (%llu)!"
- "[DSI] Pinhole focal length is 0!, ST=0x%x using static value"
- "[DSI] SLAF: App requested both Depth and NormDx while SLAF is enabled"
- "[DSI] SLAF: Could not get SlafDepthBuffer and SLAF controlled by APP, we need to generate depth for app."
- "[DSI] SLAF: Could not get SlafDepthBuffer and SLAF controlled by FW so no need to process this frame."
- "[DSI] SLAF: Failed to send msg to SLAF Depth"
- "[DSI] SLAF: Failed to send msg to SLAF Mote"
- "[DSI] SLAF: buffer unavailable for Pearl Depth SLAF"
- "[DSI] SLAF: clipped depth res %ux%u"
- "[DSI] SLAF: depth res %ux%u, SLAF depth may not be registered properly"
- "[DSI] SLAF: previewMasterFOVInRaw.x is negative"
- "[DSI] SLAF: previewMasterFOVInRaw.y is negative"
- "[DSI] Set RU Params failed. Maybe didn't set ruParams->inputFormat ?"
- "[DSI] Something went wrong, check stop ch (%zu)"
- "[DSI] Stride must be 64 bits aligned (8 bytes aligned)"
- "[DSI] Superwide overlap intrinsics not valid, using fullFov intrinsics"
- "[DSI] Tried to get T-W calib (%#x), but it is null"
- "[DSI] Tried to get W-SW calib (%#x), but it is null"
- "[DSI] Tried to get pearl calib (%#x), but it is null"
- "[DSI] Tried to release a null flow"
- "[DSI] Unexpected channel (%zu) for property write %#x"
- "[DSI] Unexpected pearl flow type %d"
- "[DSI] Unknown projector submode for incoming Pearl reference (%u)"
- "[DSI] Unsupported camera setup"
- "[DSI] Unsupported value for sensorQuadraBinFactor, should be either 0/1/2 but received %hhu"
- "[DSI] Wide overlap intrinsics not valid, using fullFov intrinsics"
- "[DSI] calib algo %d result arrived while in mode %d. Skipping results processing"
- "[DSI] drop frame. ch=%#zX, syncTag=%d flowID=%d"
- "[DSI] drop input frame. ch=%zu syncTag=%u"
- "[DSI] drop stale frame. chBM=%#zx syncTag=%d flowID=%d"
- "[DSI] entry wasn't activated, refIdx=%hu"
- "[DSI] extremeLowLightMode unsupported value"
- "[DSI] extremeLowLightMode=%d but splitPDScale isn't supported"
- "[DSI] frame dump ratio set to %d which is undefined, overriding to 1"
- "[DSI] front stereo factory depends on pearl factory"
- "[DSI] gmsAlso is null. calib type: %u"
- "[DSI] hRPC is NULL"
- "[DSI] input buffer should have contained enough space for raw-frame + Dx outputs + sMetaSplitPD"
- "[DSI] internal metadata buffer is null, but should always exist"
- "[DSI] invalid flows pool size. size=%zu, max=%zu"
- "[DSI] invalid gmcType"
- "[DSI] invalid partial flows count. partials=%zu, max=%zu"
- "[DSI] invalid stage number %zu for flow %s"
- "[DSI] invalid stage number for flow %s"
- "[DSI] invalid struct size"
- "[DSI] no factory for usecase %s"
- "[DSI] num of points outputted from PCE is non positive. Maybe forgot to fill it?"
- "[DSI] output buffer for Dx in splitPD should not be null! (when not in debug mode)"
- "[DSI] output buffer for Norm Dx should not be null!"
- "[DSI] output buffer for Scores in splitPD should not be null!"
- "[DSI] output buffer for left scaled luma in splitPDScaled should not be null"
- "[DSI] output buffer for right scaled luma in splitPDScaled should not be null"
- "[DSI] pGMS is null. type: %d"
- "[DSI] partialGdcScale is larger than 1"
- "[DSI] partials list is full, dropping oldest frame"
- "[DSI] received input from un-supported channel %zu (instead of %zu or %zu)"
- "[DSI] splitPD totalSize=%u is greater then RMASize=%u (not enough space for output buffer)"
- "[DSI] stride x Y =%u is greater then SplitPd buff size =%zu"
- "[DSI] unexpected calib type %u"
- "[DSI] unknown channel"
- "[DSI] unsupported calib type %#x"
- "[DSI] unsupported calib type %d"
- "[DSI] unsupported channel %zu for out-of-bound depth"
- "[DSI] unsupported type %d"
- "besDmaMeshIn_%d.bin"
- "can not get mesh buffer"
- "cannot service the request as apply2RequestId is %llu currFrameCount is %llu"
- "ch %d: restricted scan range (OOB) %f (%f, DAC/um %.2f)\n"
- "ch %zu capturePrepareState %d Skip channel start"
- "ch %zu fc %u IR Projector off done %f"
- "ch %zu fc %u IR Projector off start %f streamingPauseReq %u %u %u"
- "ch:%zu algo buf full"
- "ch:%zu fc:%d Skipping Frame with StandbyMode"
- "ch:%zu post algo buf error"
- "chEntry->pipe[FILTER_ADDCN][CDCNPROC_OUTPUT_0] != 0"
- "chEntry->pipe[FILTER_ADDCN][CDCNPROC_OUTPUT_1] != 0"
- "chEntry->pipe[FILTER_AFEPROC][CAFEPROC_OUTPUT_PDAF] != 0"
- "chEntry->pipe[FILTER_ALGOCONTROLSERVER][CALGOCONTROLSERVER_OUTPUT_ALGOCONTROL] != 0"
- "chEntry->pipe[FILTER_ALGOCONTROL][CALGOCONTROL_OUTPUT_AE] != 0"
- "chEntry->pipe[FILTER_ALGOCONTROL][CALGOCONTROL_OUTPUT_AF_STAT0] != 0"
- "chEntry->pipe[FILTER_ALGOCONTROL][CALGOCONTROL_OUTPUT_AWB] != 0"
- "chEntry->pipe[FILTER_ALGOCONTROL][CALGOCONTROL_OUTPUT_DPC_STAT] != 0"
- "chEntry->pipe[FILTER_ALGOCONTROL][CALGOCONTROL_OUTPUT_DPM] != 0"
- "chEntry->pipe[FILTER_ALGOCONTROL][CALGOCONTROL_OUTPUT_FD_SINK] != 0"
- "chEntry->pipe[FILTER_ALGOCONTROL][CALGOCONTROL_OUTPUT_FLOW] != 0"
- "chEntry->pipe[FILTER_ALGOCONTROL][CALGOCONTROL_OUTPUT_FLOW_STILL] != 0"
- "chEntry->pipe[FILTER_ALGOCONTROL][CALGOCONTROL_OUTPUT_FOD] != 0"
- "chEntry->pipe[FILTER_ALGOCONTROL][CALGOCONTROL_OUTPUT_KEY] != 0"
- "chEntry->pipe[FILTER_ALGOCONTROL][CALGOCONTROL_OUTPUT_LSC] != 0"
- "chEntry->pipe[FILTER_ALGOCONTROL][CALGOCONTROL_OUTPUT_LTM] != 0"
- "chEntry->pipe[FILTER_ALGOCONTROL][CALGOCONTROL_OUTPUT_MTH] != 0"
- "chEntry->pipe[FILTER_ALGOCONTROL][CALGOCONTROL_OUTPUT_PDAF] != 0"
- "chEntry->pipe[FILTER_ALGOCONTROL][CALGOCONTROL_OUTPUT_PDE] != 0"
- "chEntry->pipe[FILTER_ALGOCONTROL][CALGOCONTROL_OUTPUT_RGBHIST] != 0"
- "chEntry->pipe[FILTER_ALGOCONTROL][CALGOCONTROL_OUTPUT_SERVER] != 0"
- "chEntry->pipe[FILTER_ALGOCONTROL][CALGOCONTROL_OUTPUT_TME] != 0"
- "chEntry->pipe[FILTER_ALGOCONTROL][CALGOCONTROL_OUTPUT_VISION_RESIZE] != 0"
- "chEntry->pipe[FILTER_BEFDPROC][CBEFDPROCESSORH17_OUTPUT_0] != 0"
- "chEntry->pipe[FILTER_BLURM][BLURM_OUTPUT_PIN_CAF] != 0"
- "chEntry->pipe[FILTER_FDDCN][CFDDCNPROC_OUTPUT_FRAME] != 0"
- "chEntry->pipe[FILTER_FDDCN][CFDDCNPROC_OUTPUT_FRAME_D] != 0"
- "chEntry->pipe[FILTER_FESTAT][CFESTAT_OUTPUT_AE] != 0"
- "chEntry->pipe[FILTER_FESTAT][CFESTAT_OUTPUT_AF] != 0"
- "chEntry->pipe[FILTER_FESTAT][CFESTAT_OUTPUT_AWB] != 0"
- "chEntry->pipe[FILTER_FESTAT][CFESTAT_OUTPUT_FOD] != 0"
- "chEntry->pipe[FILTER_FESTAT][CFESTAT_OUTPUT_HDR] != 0"
- "chEntry->pipe[FILTER_FESTAT][CFESTAT_OUTPUT_LSC] != 0"
- "chEntry->pipe[FILTER_FIDDCN][CFIDDCNPROC_OUTPUT_FRAME] != 0"
- "chEntry->pipe[FILTER_FOD][FOD_OUTPUT_RESULT] != 0"
- "chEntry->pipe[FILTER_IC][CIC_OUTPUT_AFEPROC] != 0"
- "chEntry->pipe[FILTER_IC][CIC_OUTPUT_FRAME_INFO] != 0"
- "chEntry->pipe[FILTER_IC][CIC_OUTPUT_LC] != 0"
- "chEntry->pipe[FILTER_IC][CIC_OUTPUT_LTM] != 0"
- "chEntry->pipe[FILTER_IC][CIC_OUTPUT_OIS_RECENTER] != 0"
- "chEntry->pipe[FILTER_IC][CIC_OUTPUT_PDE] != 0"
- "chEntry->pipe[FILTER_IC][CIC_OUTPUT_STAT0] != 0"
- "chEntry->pipe[FILTER_IC][CIC_OUTPUT_STAT1] != 0"
- "chEntry->pipe[FILTER_IC][CIC_OUTPUT_VISIONRES] != 0"
- "chEntry->pipe[FILTER_ISPENGINE][0] != 0"
- "chEntry->pipe[FILTER_ISPENGINE][1] != 0"
- "chEntry->pipe[FILTER_KEY][CKEYPOINT_OUTPUT] != 0"
- "chEntry->pipe[FILTER_LC][LC_OUTPUT_AUX_THREAD] != 0"
- "chEntry->pipe[FILTER_LC][LC_OUTPUT_CAF] != 0"
- "chEntry->pipe[FILTER_MOTIONEST][CMOTIONESTIMATOR_OUTPUT_PIN_0] != 0"
- "chEntry->pipe[FILTER_MOTIONEST][CMOTIONESTIMATOR_OUTPUT_PIN_1] != 0"
- "chEntry->pipe[FILTER_MOTIONEST][CMOTIONESTIMATOR_OUTPUT_PIN_2] != 0"
- "chEntry->pipe[FILTER_MOTIONEST][CMOTIONESTIMATOR_OUTPUT_PIN_3] != nullptr"
- "chEntry->pipe[FILTER_MOTIONEST][CMOTIONESTIMATOR_OUTPUT_PIN_4] != 0"
- "chEntry->pipe[FILTER_PCEALGO][CPCEALGOPROC_OUTPUT_IC] != 0"
- "chEntry->pipe[FILTER_PCEALGO][CPCEALGOPROC_OUTPUT_PDEPROC] != 0"
- "chEntry->pipe[FILTER_PDAF][CPDAF_OUTPUT_AFEPROC] != 0"
- "chEntry->pipe[FILTER_PDAF][CPDAF_OUTPUT_ALGOCONTROL_AFE] != 0"
- "chEntry->pipe[FILTER_PDAF][CPDAF_OUTPUT_ALGOCONTROL_MLAF] != 0"
- "chEntry->pipe[FILTER_PDEPROC][CPDEPROC_OUTPUT_AEIR] != 0"
- "chEntry->pipe[FILTER_PDEPROC][CPDEPROC_OUTPUT_DEPTH] != 0"
- "chEntry->pipe[FILTER_PDEPROC][CPDEPROC_OUTPUT_DEPTH_SLAF] != 0"
- "chEntry->pipe[FILTER_PDEPROC][CPDEPROC_OUTPUT_DEPTH_SLAF_MOTE] != 0"
- "chEntry->pipe[FILTER_PDEPROC][CPDEPROC_OUTPUT_FRAME] != 0"
- "chEntry->pipe[FILTER_PDEPROC][CPDEPROC_OUTPUT_IC] != 0"
- "chEntry->pipe[FILTER_PDEPROC][CPDEPROC_OUTPUT_PCE_ALGO] != 0"
- "chEntry->pipe[FILTER_PDEPROC][CPDEPROC_OUTPUT_PDAF] != 0"
- "chEntry->pipe[FILTER_SEMANTICAWB][CAWBSEMANTIC_CLRHIST2D_OUTPUT_ALGOCTRL] != 0"
- "chEntry->pipe[FILTER_SEMANTICAWB][CAWBSEMANTIC_CONFIDENCE_MAP_OUTPUT_AWB] != 0"
- "chEntry->pipe[FILTER_SEMANTICAWB][CAWBSEMANTIC_HIRES_OUTPUT_ALGOCTRL] != 0"
- "chEntry->pipe[FILTER_SEMANTICAWB][CAWBSEMANTIC_HIRES_OUTPUT_FESTAT] != 0"
- "chEntry->pipe[FILTER_SPD][CSPD_OUTPUT_PIN_PCE] != 0"
- "chEntry->pipe[FILTER_STF][CSTF_OUTPUT_MTH_SETTING_TO_ALGOCTRL] != 0"
- "chEntry->pipe[FILTER_STF][CSTF_OUTPUT_STF_COEFFICIENTS_SETTING_TO_ALGOCTRL] != 0"
- "chEntry->pipe[FILTER_STF][CSTF_OUTPUT_STF_WEIGHTMAP_SETTING_TO_ALGOCTRL] != 0"
- "chEntry->pipe[FILTER_STILLFLOW][FLOWBASE_OUTPUT_ALG_DATA] != 0"
- "chEntry->pipe[FILTER_STILLFLOW][FLOWBASE_OUTPUT_FRAME] != 0"
- "chEntry->pipe[FILTER_STILLFLOW][FLOWBASE_OUTPUT_RSCL_PRESCALE] != 0"
- "chEntry->pipe[FILTER_STILLFLOW][FLOWBASE_OUTPUT_SYNC_BUF]"
- "chEntry->pipe[FILTER_TIMEMACHINE][CTIMEMACHINE_OUTPUT_BES_STRIP_PROCESS] != 0"
- "chEntry->pipe[FILTER_TIMEMACHINE][CTIMEMACHINE_OUTPUT_LTM] != 0"
- "chEntry->pipe[FILTER_TIMEMACHINE][CTIMEMACHINE_OUTPUT_SPD] != 0"
- "chEntry->pipe[FILTER_TIMEMACHINE][CTIMEMACHINE_OUTPUT_TONECURVE] != 0"
- "chEntry->pipe[FILTER_TIMEMACHINE][CTIMEMACHINE_OUTPUT_VISION_RESIZE] != 0"
- "chEntry->pipe[FILTER_TIMEMACHINE][CTIMEMACHINE_OUTPUT_VISION_RESIZE_ER] != 0"
- "chEntry->pipe[FILTER_USERAGENT][CISPENGINEAGENT_OUTPUT_FRAME] != 0"
- "chEntry->pipe[FILTER_VIDEOFLOW][FLOWBASE_OUTPUT_ALG_DATA] != 0"
- "chEntry->pipe[FILTER_VIDEOFLOW][FLOWBASE_OUTPUT_FRAME] != 0"
- "chEntry->pipe[FILTER_VIDEOFLOW][FLOWBASE_OUTPUT_RSCL_PRESCALE] != 0"
- "chEntry->pipe[FILTER_VIDEOFLOW][FLOWBASE_OUTPUT_SYNC_BUF] != 0"
- "chEntry->pipe[FILTER_VIDEOFLOW][VFLOWH17_OUTPUT_ANST] != 0"
- "chEntry->pipe[FILTER_VIDEOFLOW][VFLOWH17_OUTPUT_BLURM] != 0"
- "chEntry->pipe[FILTER_VIDEOFLOW][VFLOWH17_OUTPUT_MLAF] != 0"
- "chEntry->pipe[FILTER_VIDEOFLOW][VFLOWH17_OUTPUT_VIO] != 0"
- "chEntry->pipe[FILTER_VIO][DESGEN_OUTPUT_PIN_0] != 0"
- "chEntry->pipe[FILTER_VISRESIZE][CVISIONRESIZEH17_OUTPUT_REGISTRATION] != 0"
- "chEntry->pipe[FILTER_VISRESIZE][CVISIONRESIZE_OUTPUT_0] != 0"
- "chEntry->pipe[FILTER_VISRESIZE][CVISIONRESIZE_OUTPUT_1] != 0"
- "chEntry->pool[FILTER_ALGOCONTROL][CALGOCONTROL_POOL_STATIC_DPC]"
- "chEntry->pool[FILTER_FESTAT][CFESTAT_POOL_STATS] != 0"
- "chEntry->pool[FILTER_KEY][CKEYPOINT_POOL_0] != 0"
- "chEntry->pool[FILTER_STILLFLOW][VFLOWH17_BUFFER_POOL_HITH] != 0"
- "chEntry->pool[FILTER_VIDEOFLOW][VFLOWH17_BUFFER_POOL_CTF] != 0"
- "chEntry->pool[FILTER_VIDEOFLOW][VFLOWH17_BUFFER_POOL_HITH] != 0"
- "clrpro"
- "descrCommon->motionCaptureOutuPipe[MC2LC_FAKE_CHANNEL] != 0"
- "descrCommon->motionCapturePool[CMOTIONCAPTURE_POOL_FRAME] != 0"
- "isp1"
- "lsConfig[%d][%d]: %d, %d, %d, %d \n"
- "oH:%d is less than vio max input, no need to downscale"
- "oW:%d is less than vio max input, no need to downscale"
- "oisLSCLog %s %d: ch=%zu, CTuningParamService::Instance()->TuningParams(ch)=%p\n"
- "oisLSCLog %s %d: ch=%zu, oisLSCMode = %d, sensorQuadraPatternSupported = %d \n"
- "oisLSCLog %s %d: split chroma table for h->ch=%zu, gridCountX=%d, gridCountY=%d stride = %d \n"
- "pApsCalData = %p %s !!!!\n"
- "pub key not ready\n"
- "statsMS=%d,IR-RGB=%d,rBWR=%d,wBWR=%d MBs,PMPCtrlEn=%d\n"
- "uBracketingCount[%d] smaller total tuning bracketing count[%d]!!!"
- "unremap WriteMessage failed\n"
- "v16@?0r^{lpdpcommands_lpdp_m3_to_isp_msg_s={lpdpcommands_lpdp_msg_hdr_s=CCCC}{lpdpcommands_lpdp_m3_to_isp_payload_types__opt=B{lpdpcommands_lpdp_m3_to_isp_payload_types=Q(?={?={lpdpcommands_lpdp_error_check_s=cC[6c]I}}{?={lpdpcommands_lpdp_send_eq_s=CCCCCCCC}}{?={lpdpcommands_lpdp_send_ad_eq_s=CBCCCCCCCC}}{?={lpdpcommands_lpdp_be_rx_info_s=cII}}{?={lpdpcommands_lpdp_send_dprxc_status_s=IIIIIIIIIIIII}}{?={lpdpcommands_lpdp_send_rc_params_s=CC}})}}}8"
- "v16@?0r^{sensorcommands_sensor_m3_to_isp_msg_s={sensorcommands_sensor_msg_hdr_s=CC}{sensorcommands_sensor_m3_to_isp_payload_types__opt=B{sensorcommands_sensor_m3_to_isp_payload_types=Q(?={?={sensorcommands_sensor_send_configs_tot_s=I}}{?={sensorcommands_sensor_send_config_s={sensorcommands_sensor_config_s=ISSCCSIISSIIISISSII}}})}}}8"
- "visoutputErr"

```
