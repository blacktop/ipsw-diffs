## h17_ane_fw_theia_d9x.im4p

> `h17_ane_fw_theia_d9x.im4p`

```diff

 
-  __TEXT.__text: 0x9ba10
-  __TEXT.__const: 0x41e0
-  __TEXT.__cstring: 0x13811
+  __TEXT.__text: 0xc373c
+  __TEXT.__cstring: 0x1cb21
+  __TEXT.__const: 0x4204
   __TEXT.ce_env: 0x4000
-  __TEXT.__constructor: 0x0
   __TEXT.text_env: 0x20
-  __DATA.__const: 0x9f10
+  __TEXT.__constructor: 0x0
+  __TEXT.__init_offsets: 0x0
+  __DATA.__const: 0x9d48
   __DATA._rtk_heap: 0x1000
-  __DATA.__data: 0xd68
+  __DATA.__data: 0x1078
   __DATA._rtk_power: 0x3b8
-  __DATA._rtk_patchbay: 0x278
+  __DATA._rtk_patchbay: 0x261
   __DATA._rtk_init_stack: 0x10000
   __DATA._rtk_irq_stack: 0x1000
   __DATA._rtk_exc_stack: 0x1000

   __DATA._rtk_page_tables: 0x80000
   __DATA._rtk_threads: 0x0
   __DATA._fwinfo: 0x100
-  __DATA.__data_copy: 0x8000
-  __DATA.__sysvars: 0x4
   __DATA._rtk_boot_l1: 0x80
-  __DATA.__chain_starts: 0x28
   __DATA._rtk_mtab: 0x2a0
   __DATA.__gxf_data: 0x10
+  __DATA.__data_copy: 0x8000
+  __DATA.__sysvars: 0x4
   __DATA.__mod_init_func: 0x0
-  __DATA.__zerofill: 0x1f9f20
-  UUID: 23F566C5-DD3B-3267-8D8D-1172F53F5086
-  Functions: 1392
+  __DATA.__chain_starts: 0x24
+  __DATA.__zerofill: 0x1c1f00
+  UUID: 0493EDB3-46D9-33F6-B2CA-9086E2D9BD72
+  Functions: 1529
   Symbols:   0
-  CStrings:  2225
+  CStrings:  3432
 
CStrings:
+ "\tBufs = %d uuid = 0x%llx\n"
+ "\tFW Latency Signposts 0x%x id 0x%x ts %lld"
+ " "
+ "          Bar[%d] : barIndex %d bufIndex %d"
+ "     [%d] : Offset %lld length %lld"
+ "     [%d] : Type %d nbrNe %d nbrOfLocalbarSetup %d"
+ "     [%d] : Type %d startAddr 0x%x endAddr 0x%x Size %x nbrNe %d nbrOfLocalbarSetup %d"
+ "     [%d] : format %d isCompressed 0x%x len 0x%llx offset %llx"
+ "     aneMapping[%d] : %d"
+ "     nBuf %d inputEvent %d priority %d uuid 0x%llx"
+ "   %6u : [P:%d, %s] -- [T:%d, %s] -> ERROR: %s\n"
+ "   %6u : [P:%d, %s] -- [T:%d, %s] -> [S:%d, %s]\n"
+ "   %6u : [P:%d, %s] -- [T:%d] -> ERROR: WRONG EVENT\n"
+ "  %s : There no state transitions\n"
+ "  %s [%p]: Last %zu transitions [total = %zu]:\n"
+ "  Commit Hash : %s\n"
+ " %d : handle 0x%x offset 0x%lx len 0x%lx with Remap count %d\n"
+ " %d : handle 0x%x offset 0x%lx len 0x%lx with map count %d\n"
+ " %d [%#x]"
+ " %p"
+ " %s: event (%d, %s)"
+ " %s: event (%d, %s), rc = %d [%#x]"
+ " %s: event=%d [%s] cb %s"
+ " Acquired %p"
+ " Acquiring %p"
+ " Released %p"
+ " To release %p"
+ "!(pageWiringOn && forceWiring)"
+ "!bSubNetworkCustomExecuteOrder"
+ "!commandBufPhysAddr"
+ "!endPointCb[pCmd->endPointId].shareMem.item[i].used"
+ "!pEntry->child"
+ "!pExeLoop->pSneTMDrv->getTQEn()"
+ "!reader"
+ "%-30s %-16.4f %-16lld %-16lld %-8lld\n"
+ "%-30s %-16s %-16s %-16s %-8s\n"
+ "%-30s %-6s %-8.4f %-8.4f\n"
+ "%-30s %-6s %-8.4f %-8s %-10.4f %-16lld %-16lld %-8lld\n"
+ "%-30s %-6s %-8s %-8.4f %-10.4f %-16lld %-16lld %-8lld\n"
+ "%-30s %-6s %-8s %-8s %-10.4f %-16lld %-16lld %-8lld\n"
+ "%-30s %-6s %-8s %-8s %-10s %-16s %-16s %-8s\n"
+ "%d : buf %p size 0x%lx index 0x%x\n"
+ "%lld delay trigger, %lld ignored due to exceeded execTimestamp"
+ "%s : *** ACK: Endpoint command %d with ticket %u seq %u\n"
+ "%s : *** endPoint %d cmd %d ack 0x%x ack_rc 0x%x ticket %u seq %u\n"
+ "%s : Configure pCmd endPointId = %d\n"
+ "%s : Free Shared Memory endPointId = %d at %p\n"
+ "%s : Get EndPoint Status %d\n"
+ "%s : Get Outstanding Ticket Cnt %d\n"
+ "%s : Malloc Shared Memory endPointId = %d\n"
+ "%s : SAP Register endPointId = %d sapId = 0x%x\n"
+ "%s : SAP UnRegister endPointId = %d sapId = 0x%x\n"
+ "%s : Send Buf endPointId %d sapId 0x%x %d\n"
+ "%s : Unset pCmd endPointId = %d\n"
+ "%s : valid %d bufIndex %d type %d addr 0x%llx memType %d size %lld tag %llx"
+ "%s [userId %d jobId %d fwPriority %d hwqId %d tqId %d] queueId %d"
+ "%s: (%d, %s): [%d, %s]->[%d, %s]"
+ "%s: CH = %zu START"
+ "%s: CH = %zu STOP"
+ "%s: GOING TO STOP"
+ "%s: SETUP"
+ "%s: START"
+ "%s: STOP"
+ "%s: TEARDOWN"
+ "(%s) %s\n"
+ "(((size_t)(blockArray[dBlock])) % alignment[dBlock]) == 0"
+ "((size_t)pointer) < ((size_t)(h->pMsg)) + h->queueDepth * sizeof(struct ffwInterProcMsg)"
+ "((size_t)pointer) >= ((size_t)(h->pMsg))"
+ "((uintptr_t)entry->stack & (RTK_CRT_STACK_ALIGNMENT - 1)) == 0"
+ "(*parent == logDepth) || (*parent == index)"
+ "(*parent == logDepth) || (*parent == pEntry->parent)"
+ "(FFWMUTEX)0 != lock"
+ "(IOP_RINGBUFFER_VERSION == (pBuf->_header._version>>16)) || (IOP_RINGBUFFER_VERSION_V2 == (pBuf->_header._version>>16))"
+ "(SEMA)0 != cmd.syncCmdSema"
+ "(appPriority >= 0 && appPriority <= 1) || (appPriority >= 2 && appPriority <= 7)"
+ "(call->priority >= 0 && call->priority <= 1) || (call->priority >= 2 && call->priority <= 7)"
+ "(callback == NULL) || (user_signal == 0)"
+ "(cmd->priority >= 2 && cmd->priority <= 7)"
+ "(ffwQueueCount (queue) == 0) || (((size_t) ffwQueueCount (queue)) == buffers)"
+ "(idx >= 0) && (idx < (mNumEntriesPerPool * mMaxPoolNum))"
+ "(idx >= 0) && (idx < hash_entries_num)"
+ "(inputs > 0) || (outputs > 0)"
+ "(mCurrPoolNum + pool_num) <= mMaxPoolNum"
+ "(new_end & HEAP_OFFSET) == 0"
+ "(operation == LOG_OPERATION_WIRED) || (operation == LOG_OPERATION_UNWIRED)"
+ "(pCmd->pBufIndex[i] & ~maskRemapIndex) < sizeof(endPointCb[pCmd->endPointId].shareMem.remap)/sizeof(endPointCb[pCmd->endPointId].shareMem.remap[0])"
+ "(pCmd->pBufIndex[i]) < sizeof(endPointCb[pCmd->endPointId].shareMem.item)/sizeof(endPointCb[pCmd->endPointId].shareMem.item[0])"
+ "(pCmdHdr->id == CSNE_CMD_PROCEDURE_CALL_CACHE_REQUEST) || (pCmdHdr->id == CSNE_CMD_PROCEDURE_CALL_CACHE_REQUEST_WITH_CUSTOM_BARS) || (pCmdHdr->id == CSNE_CMD_PROCEDURE_CALL_CACHE_REQUEST_WITH_SHARED_EVENTS)"
+ "(pTriggerCmd->execTimestamp > pGroupCacheReq->lastTriggerExecTimestamp) || ((pGroupCacheReq->lastTriggerExecTimestamp - pTriggerCmd->execTimestamp) & (0xF000000000000000LLU))"
+ "(size_t) ffwQueueCount (queue) == available"
+ "(size_t)source < INTERRUPT_SRC_TOTAL"
+ "(stacksize & (RTK_CRT_STACK_ALIGNMENT - 1)) == 0"
+ "*extra_heap_size >= extra_heap_size_min"
+ "*idx < CTASKPOOL_MAXTASK_HIST_ENTRIES"
+ "*indexOut == logDepth"
+ "*outsize <= maxOutsize"
+ "*outsize >= sizeof(struct sCSneCmdPrintEnable)"
+ "*print_buffer_base != 0"
+ "*sm_base != 0"
+ "*sm_size != 0"
+ "-----------interval------------\n"
+ "./ffw/ffw/CAsyncBufferManager.cpp"
+ "./ffw/ffw/CBuffer.cpp"
+ "./ffw/ffw/CBufferPool.cpp"
+ "./ffw/ffw/CBufferPoolDynamic.cpp"
+ "./ffw/ffw/CBufferPoolDynamicManager.cpp"
+ "./ffw/ffw/CBufferPoolDynamicManagerSynch.cpp"
+ "./ffw/ffw/CBufferPoolStatic.cpp"
+ "./ffw/ffw/CChannelManager.cpp"
+ "./ffw/ffw/CController.cpp"
+ "./ffw/ffw/CDMediaBusManager.cpp"
+ "./ffw/ffw/CExpandablePool.cpp"
+ "./ffw/ffw/CFSM.cpp"
+ "./ffw/ffw/CFifo.cpp"
+ "./ffw/ffw/CFilter.cpp"
+ "./ffw/ffw/CGPIOManager.cpp"
+ "./ffw/ffw/CHashTable.cpp"
+ "./ffw/ffw/CIOObject.cpp"
+ "./ffw/ffw/CIOPRingBuffer.cpp"
+ "./ffw/ffw/CIPSynchro.cpp"
+ "./ffw/ffw/CIndexPool.cpp"
+ "./ffw/ffw/CInterruptBuffer.cpp"
+ "./ffw/ffw/CLatencyProfiler.cpp"
+ "./ffw/ffw/CList.cpp"
+ "./ffw/ffw/CLoggerInterProcessor.cpp"
+ "./ffw/ffw/CLoggerSharedBuffer.cpp"
+ "./ffw/ffw/CMMU.cpp"
+ "./ffw/ffw/CMMULoggerPA.cpp"
+ "./ffw/ffw/CMMULoggerVA.cpp"
+ "./ffw/ffw/CMultiFilter.cpp"
+ "./ffw/ffw/CObject.cpp"
+ "./ffw/ffw/CObjectTree.cpp"
+ "./ffw/ffw/CPipe.cpp"
+ "./ffw/ffw/CPool.cpp"
+ "./ffw/ffw/CRoot.cpp"
+ "./ffw/ffw/CSharedMemory.cpp"
+ "./ffw/ffw/CSignalPool.cpp"
+ "./ffw/ffw/CTerminalOut.cpp"
+ "./ffw/ffw/CTimeProfiler.cpp"
+ "./ffw/ffw/ffwCRC.cpp"
+ "./ffw/ffw/rtkit/CDebugAgent.cpp"
+ "./ffw/ffw/rtkit/CEnvironment.cpp"
+ "./ffw/ffw/rtkit/CISRManager.cpp"
+ "./ffw/ffw/rtkit/CMMUDynamic.cpp"
+ "./ffw/ffw/rtkit/CMailboxPool.cpp"
+ "./ffw/ffw/rtkit/CQueuePool.cpp"
+ "./ffw/ffw/rtkit/CRTOSObjectPool.cpp"
+ "./ffw/ffw/rtkit/CResourcePool.cpp"
+ "./ffw/ffw/rtkit/CScopedLock.cpp"
+ "./ffw/ffw/rtkit/CSemaphorePool.cpp"
+ "./ffw/ffw/rtkit/CSharedMemoryHeap.cpp"
+ "./ffw/ffw/rtkit/CSharedMemoryHost.cpp"
+ "./ffw/ffw/rtkit/CTaskPool.cpp"
+ "./ffw/ffw/rtkit/CTimerManager.cpp"
+ "./ffw/ffw/rtkit/CTimerPool.cpp"
+ "./ffw/ffw/rtkit/CTraceEventBuffer.cpp"
+ "./ffw/ffw/rtkit/ffwMMU.cpp"
+ "./ffw/ffw/rtkit/ffwSharedMemory.cpp"
+ "./ffw/platform/common/CFakeChannel.cpp"
+ "./ffw/platform/common/CIPSynchroFake.cpp"
+ "./ffw/platform/common/ChannelTable.cpp"
+ "./ffw/platform/common/FakeChannelTable.cpp"
+ "./ffw/platform/theia/rtkit/CPlatformEnvironment.cpp"
+ "./ffw/platform/theia/rtkit/CPlatformGPIOManager.cpp"
+ "./ffw/platform/theia/rtkit/CPlatformISRManager.cpp"
+ "./ffw/platform/theia/rtkit/RealChannelTableTarget.cpp"
+ "./sne/aneEngine/common/CAneEngineExeLoopHx.cpp"
+ "./sne/aneEngine/common/CAneEngineExeLoopHxFSMDef.cpp"
+ "./sne/aneEngine/common/CAneProgramManager.cpp"
+ "./sne/aneEngine/common/CAneProgramManagerHx.cpp"
+ "./sne/common/Debug/CAneLatencyProfiler.cpp"
+ "./sne/drivers/CDeviceDriver.cpp"
+ "./sne/drivers/FE/CConfigDrvH11.cpp"
+ "./sne/drivers/tm/CSneTMDrvHx.cpp"
+ "./sne/ssi/src/rtxc/sema.cpp"
+ "0 < mpGroupBufCnt[group]"
+ "0 == ((size_t)virtualAddr & wiringPageMask)"
+ "0 == (physicalAddr & wiringPageMask)"
+ "0 == matched || 1 == matched"
+ "0 == mpGroupBufCnt[group]"
+ "0 == ret"
+ "0/1"
+ "04:37:26"
+ "1"
+ "<=== CMMU_LOGGER_FFW_ASSERT from %s\n"
+ "================="
+ "===> CMMU_LOGGER_FFW_ASSERT from %s\n"
+ ">>>>>>> Frame ID mismatch, expect: %lld, get: %lld"
+ "ACK \"%s\""
+ "ACTION"
+ "AFPP load is not allowed after program setup done\n"
+ "ALIGN_DOWN(pointer, CMMU::CacheLineSize()) == pointer"
+ "ALL_CPU(%)"
+ "ANE latency profiler already exists"
+ "ANE latency profiler created"
+ "ANE requestCallProc %zu"
+ "ANE_PROPERTY_PRC Channel related logs are disabled"
+ "ANE_PROPERTY_PRC Channel related logs are enabled"
+ "ANE_PROPERTY_PRC wrong valid"
+ "Ack Secure Mode event"
+ "AddScheduleInfo"
+ "AneVersionGet"
+ "AvailableScheduleInfo"
+ "BAR[%d] barIndex %d : bufferIndex %d"
+ "Buf MSG: sapId 0x%x bufNbr %d subPacketSize %d\n"
+ "Buf[%d] sz %lld type %d"
+ "BufferProcessor"
+ "CAneDebugEventsManager"
+ "CAneProgramManagerHx.cpp"
+ "CAneServer"
+ "CBufferPool::alignment != 0"
+ "CBufferPool::blockArray != 0"
+ "CBufferPool::size != 0"
+ "CBufferPool::stride != 0"
+ "CDMEDIABUSMANAGER_ENDPOINT_CMD_PING == pCmd->hdr.cmd"
+ "CDMEDIABUSMANAGER_ENDPOINT_CMD_REMAP == pCmd->hdr.cmd"
+ "CDMEDIABUSMANAGER_ENDPOINT_CMD_SEND_BUF_MSG == pCmd->hdr.cmd"
+ "CDMEDIABUSMANAGER_ENDPOINT_CMD_UNMAP == pCmd->hdr.cmd"
+ "CDMediaBusManager"
+ "CExpandablePool allocEntryIdx enter"
+ "CExpandablePool allocEntryIdx exit idx %zu"
+ "CExpandablePool expandPool enter expand pool num %d, mCurrPoolNum %d "
+ "CExpandablePool expandPool exit mCurrPoolNum %d"
+ "CExpandablePool freeEntryIdx enter idx %zu RefCount %d"
+ "CExpandablePool freeEntryIdx exit idx %zu RefCount %d"
+ "CExpandablePool freeEntryIdx free poolIdx %d, mCurrPoolNum %d"
+ "CExpandablePool maximum pool num (%d) allowed already allocated"
+ "CExpandablePool retain enter idx %zu RefCount %d"
+ "CExpandablePool retain exit idx %zu RefCount %d"
+ "CFakeChannel::chDescr"
+ "CGPIOManager::Instance() != NULL"
+ "CMD = %#04x [PROC CALL WITH BARS] at %lld : ProgId=%d ProcId=%d Proc=%d Pri=%d\n"
+ "CMD = %#04x [PROC CALL WITH EVENTS] at %lld : ProgId=%d ProcId=%d Proc=%d Pri=%d\n"
+ "CMD = %#04x [PROC CALL] at %lld : ProgId=%d ProcId=%d Proc=%d Pri=%d\n"
+ "CMMULoggerPA::hisEntry != 0"
+ "CMMULoggerPA::logEntry != 0"
+ "CMMULoggerVA::hisEntry != 0"
+ "CMMULoggerVA::logEntry != 0"
+ "CMMU_LOGGER_FFW_ASSERT:%d [%zu] PA = 0x%lx, length = 0x%zx\n"
+ "CMMU_LOGGER_FFW_ASSERT:%d [%zu] vir = %p, length = 0x%zx\n"
+ "CMailboxPool::Instance() != 0"
+ "CPU num: %d\n"
+ "CPU_0(%)"
+ "CPU_1(%)"
+ "CPU_ID"
+ "CQueuePool::Instance() != 0"
+ "CR 0x%llx single use already triggered"
+ "CRPCClient is down"
+ "CRPCClient::Instance() != __null"
+ "CSNE_CMD_SECURE_MODE_EVENT"
+ "CSNE_CMD_SECURE_MODE_RESUME_TRANSITION"
+ "CSNE_CMD_SET_ACTIVE_CACHE_REQUEST_IN_GROUP dropped. group/active cacheHandler not in use"
+ "CScopedLock"
+ "CSemaphorePool::Instance() != 0"
+ "CSharedMemory::Instance () != 0"
+ "CTaskPool::Instance() != 0"
+ "CTraceEventBuffer.cpp"
+ "CWorkTaskCore"
+ "CacheHandler (0x%llx) already removed from the list in the trigger ISR"
+ "CallProcedure"
+ "CallProcedure nbrOfCustomBars %d"
+ "CallProcedure progId %d procId %d numIoBuffers %d"
+ "CallProcedure progId %d procId %d numIoBuffers %d\n"
+ "CallProcedure2"
+ "Cannot find nid %llu with tid %llu event %llu"
+ "ChannelCmd"
+ "ChannelStarted"
+ "ChannelStopped"
+ "Cleanup complete. mpDataChainingStat at %p deallocated"
+ "Clear switched out req"
+ "CmdAFPPLoad"
+ "CmdAFPPUnload"
+ "CmdAcknowledge"
+ "CmdCpuLoadNotification"
+ "CmdDataChainingEvent"
+ "CmdDbgEvent"
+ "CmdDsidEvent"
+ "CmdErrorNotification"
+ "CmdGetEndPointStatus"
+ "CmdGetOutstandingTicketCnt"
+ "CmdIpcEndpointSet"
+ "CmdIpcEndpointUnset"
+ "CmdIpcSharedMemoryFree"
+ "CmdIpcSharedMemoryMalloc"
+ "CmdPowerControl"
+ "CmdProcessor"
+ "CmdProgramEvent"
+ "CmdProgramSetup"
+ "CmdProgramUnsetup"
+ "CmdPropertyAccess"
+ "CmdRegSAP"
+ "CmdReqProcessId"
+ "CmdReqProgramId"
+ "CmdResetNotification"
+ "CmdReturnProcessId"
+ "CmdReturnProgramId"
+ "CmdSendBufMsg"
+ "CmdUnRegSAP"
+ "CpuLoadNotification"
+ "Create"
+ "Create,%lu,%s"
+ "Data Chaining Latency for cacheReqIdx %d"
+ "DataChainingProgramEvent"
+ "DataProcessor"
+ "DbgEvent"
+ "Delete"
+ "Delete,%lu,%s"
+ "DeleteProgram"
+ "DeleteRTGraphProgram"
+ "DepriorDsid"
+ "DirectPost"
+ "Disable PSD flag %d"
+ "DriverCmdSanityCheck : off"
+ "DriverCmdSanityCheck : on"
+ "DriverCmdSanityCheck TD/overflow : off"
+ "DriverCmdSanityCheck TD/overflow : on"
+ "Dummy network NID %d TD Complete event %lld"
+ "Dummy network for NID %d TQ abort finished at %lld"
+ "DumpAFPP"
+ "EL"
+ "END"
+ "ENT: CFSM.cpp, "
+ "ENT: CScopedLock.cpp, "
+ "ENTER"
+ "EVENT_DISP options:"
+ "EXIT"
+ "EXT: CFSM.cpp, "
+ "EXT: CScopedLock.cpp, "
+ "Enable TQs after Dummy network finish in TQ[%d]"
+ "Enable TQs after letting TQ[%d] finish"
+ "EndPoint %d sends the Ping Message\n"
+ "EndPointUnset remap not by peer %d\n"
+ "EndpointCmdPing"
+ "EndpointCmdRemap"
+ "EndpointCmdSendBufMsg"
+ "EndpointCmdUnmap"
+ "Entry %d"
+ "Error: Borneo chip minor revison not supported!\n"
+ "Error: Nevis chip minor revison not supported!\n"
+ "Event %d nbrUsrD %d 22"
+ "Event 5 TID %d TQ %d"
+ "Event 6 TID %d TQ C %d P %d Idle %d"
+ "EventProcess"
+ "FFWMSG_PAYLOAD_GET(pMsg) <= sizeof(struct ffwMsgBuffRef)"
+ "FFWMSG_PAYLOAD_GET(pMsg) <= sizeof(struct ffwMsgCmd)"
+ "FFWMSG_PAYLOAD_GET(pMsg) <= sizeof(struct ffwMsgData)"
+ "FFW_INTERPROC_BUFF_ACK_FLAG_CHECK(extra) != 0"
+ "FFW_INTERPROC_BUFF_EXCHANGE_FLAG_CHECK(param2)"
+ "FFW_OK == ffwrc"
+ "FSMSwitchNonSecure"
+ "FSMSwitchSecure"
+ "FSM_EVENT_EXELOOP_IN_SECURE"
+ "FSM_EVENT_EXELOOP_START"
+ "FSM_EVENT_EXELOOP_STOP"
+ "FSM_EVENT_EXELOOP_SWITCH_FROM_SECURE"
+ "FSM_EVENT_EXELOOP_SWITCH_TO_SECURE"
+ "FSM_STATE_EXELOOP_IDLE"
+ "FSM_STATE_EXELOOP_PAUSE"
+ "FSM_STATE_EXELOOP_RUN"
+ "FSM_STATE_EXELOOP_RUN_2_PAUSE"
+ "Failed to map command buffer"
+ "FileInfo %s failed"
+ "Filewrite %p %zu bytes"
+ "Filewrite %s %s"
+ "Force Disable already set"
+ "Generic : [%d] bufferIndex %d"
+ "GetCacheReqEvent"
+ "GetCmdBuf"
+ "GetDirectProcCallEvent"
+ "GetFirstHWRunningSlot"
+ "GetPowerStatus"
+ "GetProcInfo"
+ "GetProgInfo"
+ "GetTraceBuffer"
+ "H11ISPInterruptMapping[(size_t)aispSource]->platformIntSrc != PLATFORM_INT_INVALID"
+ "H17TunableManager"
+ "HandleEventInt"
+ "HandleMcwInt"
+ "HandleStopTqInt"
+ "Hash Node %lld"
+ "Help"
+ "IDLE"
+ "IDLE_DEFAULT"
+ "ID_GET_SOURCE(id) < INTERRUPT_SRC_TOTAL"
+ "INVALID"
+ "IOP nothing to read"
+ "IOP read done: rtPtr %d wtPtr %d readCount %d"
+ "IOP read init: rtPtr %d wtPtr %d msgLen %zu"
+ "IOP wait for Read"
+ "IOP write done: rtPtr %d wtPtr %d writeCount %d"
+ "IOP write init: rtPtr %d wtPtr %d msgLen %zu (with header)"
+ "IOP write: Message length too big"
+ "IOP write: buffer overflow"
+ "IOP write: buffer wrapup"
+ "IOP write: pBuffer not initialized yet"
+ "IOP write: register 0x%zx 0x%x"
+ "ISR_ID_GET_BANK(id) < lines"
+ "ISR_ID_GET_INDEX(id) < ISR_CALLBACK_MAX"
+ "ISR_ID_GET_LINE(id) < ISR_REG_ENTRY"
+ "ITQ is not enabled"
+ "In SendSecureModeRequest()\n"
+ "Info"
+ "InitCacheRequest"
+ "InitProcedureCallCmds"
+ "InitProcedureCallCustomBarsCmds"
+ "InitProgrm"
+ "Initialization"
+ "InqTaskArg"
+ "Invalid log operation"
+ "Invalid secure mode %d"
+ "IpcEndpointSet"
+ "IpcEndpointUnset"
+ "Kernel : bufferIndex %d"
+ "Key[%lld]: 0x%zx"
+ "KickStartCe"
+ "Last seg's firstTID=%d\n"
+ "Load %s failed"
+ "LoadProgram"
+ "LoadProgramsInAFPP"
+ "LogEnterVerbose"
+ "MapTextSection"
+ "Master asking to release the remap while it is still being used by local user\n"
+ "May 24 2025"
+ "NO trace buffer to post!"
+ "NULL != clockToMicroSecondConvertFunc"
+ "NULL != encode_handler[encodeScheme]"
+ "NULL != entry"
+ "NULL != instance"
+ "NULL != nbytes"
+ "NULL != pCmd"
+ "NULL != pIpcRingBufferIn[pCmd->endPointId]"
+ "NULL != pIpcRingBufferOut[pCmd->endPointId]"
+ "NULL != pMsg"
+ "NULL != pResourceIndex[endPoint]"
+ "NULL != pResourceIndex[pCmd->endPointId]"
+ "NULL != pTaskHistoryHead"
+ "NULL != physical_addr"
+ "NULL != ppReadBufferAddr"
+ "NULL != ppWriteBufferAddr"
+ "NULL != semalist"
+ "NULL != semaphore"
+ "NULL != timeCodeGetFunc"
+ "NULL != timestampFrequencyFunc"
+ "NULL != virtualAddr"
+ "NULL == instance"
+ "NULL == mpGroups[group][j].buf && STATE_RELEASED == mpGroups[group][j].state"
+ "NULL == pHandler"
+ "NULL == pIpcRingBufferIn[pCmd->endPointId]"
+ "NULL == pIpcRingBufferOut[pCmd->endPointId]"
+ "Need dummy for TQ[%d]S[%d], b_queue_dummy_network %d"
+ "Notify score %u\n"
+ "Num of switched out requests exceeded numbrt of TQs"
+ "Overflow detected in dram event log: programId %d processId %d procedureId %d"
+ "POST CONDITION: "
+ "POWEROFF"
+ "POWERON"
+ "PRE CONDITION: "
+ "PROCESSING"
+ "PerfMode : off"
+ "PerfMode : on"
+ "Performance"
+ "Phase %d: %dus (avg %9.6fus, std sq %9.6fus statsCount %d)"
+ "PiningThreadsTotal: "
+ "PostCallback"
+ "PostCmd"
+ "PowerControl"
+ "PowerDown"
+ "PowerUp"
+ "PowerUpByState"
+ "PreMapProcessStatsBuf"
+ "PrintBufDesc"
+ "PrintDescriptorProp"
+ "PrintGeneric"
+ "PrintKernelProp"
+ "PrintOperation"
+ "PrintProcedure"
+ "ProcessEndpointCmd"
+ "ProcessSubPacket"
+ "ProgramEvent"
+ "PropertyWrite"
+ "Queue dummy network using NID %d Q[%d]S[%d] at %lld"
+ "RESET"
+ "ROUND_DOWN(paddr, CMMU::CacheLineSize()) == paddr"
+ "RPC Id is 0x%x\n"
+ "RPC read file size as %zu"
+ "RTK_ST_IS_SUCCESS(rc)"
+ "RTK_ST_OK == ret"
+ "RTK_queue_count(queue) == tot"
+ "RTK_vm_map_memory failed for 0x%llx length 0x%zu\n"
+ "RTK_vm_unmap failed\n"
+ "Read %s done %zu bytes"
+ "ReadMessage"
+ "Received Signal %p\n"
+ "Received an program whose has 0 operation : %d"
+ "Received an program whose procedure has invalid operation Index : %d vs %d"
+ "RegisterClient"
+ "ReloadTunables"
+ "Remap :  handle 0x%x : base %p : len 0x%lx\n"
+ "RemoveScheduleInfo"
+ "Report Debug Event : Debug Event %d count %d (tid:%d)"
+ "Reset"
+ "ReturnCacheReqEvent"
+ "ReturnDirectProcCallEvent"
+ "RunProc"
+ "RunProc2"
+ "RunProcCacheRequest"
+ "RunProcInternal"
+ "START"
+ "STOP"
+ "STREAM"
+ "STREAM_CMD_APPLY"
+ "STREAM_CMD_APPLY_NOW"
+ "STREAM_IDLE"
+ "STREAM_IDLE_DEFAULT"
+ "STREAM_INSTANDBY"
+ "STREAM_OFF"
+ "STREAM_PROCESSING"
+ "STREAM_RESET"
+ "STREAM_SETUP"
+ "STREAM_STANDBY"
+ "STREAM_START"
+ "STREAM_STOP"
+ "STREAM_TEARDOWN"
+ "SUCC"
+ "SVC"
+ "SaveProcedureCall"
+ "SaveRunToTdStop"
+ "SaveStatsBuffer"
+ "SaveToFile"
+ "Secure Mode Event %d at 0x%llx)"
+ "Secure mode switch handshake time %dus"
+ "Segment : bufferIndex %d"
+ "SendBufMsg"
+ "SendCall"
+ "SendHWRequest"
+ "SendMsg : endPointId %d sapId 0x%x subPacket %p subPacketSize %d\n"
+ "SendSecureModeEvent"
+ "SendSecureModeRequest"
+ "Set TQ[%d] cfg to 0x%x"
+ "Set TQ[%d] priority to 0x%x"
+ "SetPMUBaseAddress"
+ "SetProgram"
+ "Setting high watermark to %u\n"
+ "Setting low watermark to %u\n"
+ "Setting poll interval to %u seconds\n"
+ "Setting threshold to %u ticks\n"
+ "Setup complete. mpDataChainingStat at %p allocated"
+ "SetupEngineRequest"
+ "SetupExecute"
+ "SneTMDrvHx"
+ "Started"
+ "StatsBuf sz %lld type %d"
+ "Stopped"
+ "Suspend TQs for Dummy Network"
+ "SwitchExclaveMode"
+ "Switched out TQ[%d][%d]"
+ "Switched out request does not have prefetch DSID"
+ "Switched out request is NULL!"
+ "Switched out request not saved"
+ "TD : bufferIndex %d"
+ "TQ[%d] State %d set at %lld by %s:%d"
+ "TQ[%d] exceeded max TQ num"
+ "TQ[%d] should have request running"
+ "TQ[%d] state 0x%x"
+ "TQ[%d][0] should have enqueue Ts"
+ "TQ[%d][1] should have enqueue Ts"
+ "Task"
+ "TaskArg not found"
+ "TearDownExecute"
+ "TerminateCacheRequest"
+ "TerminateProcess"
+ "Thread time"
+ "Total Abort : Raise Priority %d TQ Abort %d"
+ "Total Process create/terminate : %d/%d"
+ "Total Program add/delete       : %d/%d"
+ "Total Scheduled Run : %d (failed %d)"
+ "Total finished  Run : %d"
+ "TracePost2Host"
+ "TransitionProcess"
+ "UnMapTextSection"
+ "UnRemap :  handle 0x%x : base : %p len : 0x%lx\n"
+ "Unexpected call. bIsExclaveSupported %d, bEnableSecureModeHandshake %d"
+ "Unexpected priority %d"
+ "UnloadProgram"
+ "UnsetMem : %p 0x%lx 0x%x\n"
+ "UnsetRemap : %p 0x%lx 0x%x\n"
+ "Update prog=%d proc=%d seg=%d:\n  nextSeg=%d isLast=%d isRewind=%d\n"
+ "WireShared"
+ "WriteMessage"
+ "Writer regAddr 0x%lx regValue 0x%x\n"
+ "[%d]: intermediate spill bar id %d, dsid 0x%llx"
+ "[%d]: prefetch bar id %d, dsid 0x%llx"
+ "[%s]  CMD = %#04x [%s] at %lld : type = 0x%x addr = %p, size = %d \n"
+ "[%s]  CMD = %#04x [PROC CALL WITH BARS] at %lld : ProgId=%d ProcId=%d Proc=%d Pri=%d\n"
+ "[%s]  CMD = %#04x [PROC CALL WITH EVENTS] at %lld : ProgId=%d ProcId=%d Proc=%d Pri=%d\n"
+ "[%s]  CMD = %#04x [PROC CALL] at %lld : ProgId=%d ProcId=%d Proc=%d Pri=%d\n"
+ "[%s] CMD = %#04x [%s] at %lld : enable=%d\n"
+ "[%s] CMD = %#04x [%s] at %lld [0x%x]\n"
+ "[0]: show options"
+ "[1]: TD events sorted by TID"
+ "[2]: TD events sorted by timestamp"
+ "[3]: TD performance profiling"
+ "[4]: show task switch event"
+ "[5]: network performance profiling"
+ "[ANE Exclave] Enter"
+ "[ANE Exclave] Exit"
+ "[ANE Power] down"
+ "[ANE Power] up"
+ "[ANE_EVENT_CONTEXT_SWITCH_IN]: tid=%3d, nid=%3d, prevTQ=%3d, progId=%3d, procId=%3d, currTQ=%d, timeStamp=%lld\n"
+ "[AneCmd] Allocated processId %d for programId %d at %lld"
+ "[AneCmd] Allocated processId %d for programId %d at %lld.\n"
+ "[AneCmd] Allocated programId = %d at %lld"
+ "[AneCmd] Allocated programId = %d at %lld."
+ "[AneCmd] Returned programId = %d at %lld."
+ "[AneCmd] Terminated processId %d for programId %d at %lld"
+ "[AneCmd] Unloaded programId = %d at %lld"
+ "[AneCmd] returned processId %d for programId %d at %lld."
+ "[Desciptor prop Section] Total %d"
+ "[Descriptor prop Section] X"
+ "[EXELOOP] CMD = %#04x [PROC CALL WITH BARS] at %lld : ProgId=%d ProcId=%d Proc=%d Pri=%d\n"
+ "[EXELOOP] CMD = %#04x [PROC CALL WITH EVENTS] at %lld : ProgId=%d ProcId=%d Proc=%d Pri=%d\n"
+ "[EXELOOP] CMD = %#04x [PROC CALL] at %lld : ProgId=%d ProcId=%d Proc=%d Pri=%d\n"
+ "[Generic Section] X"
+ "[Generic Section] maxAneUsed %d maxNe %d total Buf %d"
+ "[ISR] CMD = %#04x [%s] at %lld\n"
+ "[Kernel Prop Section] Total %d"
+ "[Kernel Prop Section] X"
+ "[MessageBack] cmdId %d counter 0x%x - %dus (cache command # : %zu)"
+ "[No] Generic Section"
+ "[No] Operation Section"
+ "[No] Procedure Section"
+ "[No] Segment Prop Section"
+ "[No] Segment Section"
+ "[OPERATION Section] Total %d"
+ "[OPERATION Section] X"
+ "[POST] cmdId %d counter 0x%x"
+ "[POST] cmdId %d counter 0x%x => Trace # %d"
+ "[PROCEDURE Section] Total %d"
+ "[PROCEDURE Section] X"
+ "[TestCond] ASSERTION is set"
+ "[TestCond] Cmd_Timeout is set"
+ "[WRN] Exeloop cmd %d latency %dus"
+ "[X] kernelPropSection is valid but no buffer!"
+ "[X] kernelSection is valid but no buffer!"
+ "[X] verifyBAR"
+ "[X] verifyDescriptorPropSection"
+ "[X] verifyDescriptors"
+ "[X] verifyGenericSection"
+ "[X] verifyKernelPropSection"
+ "[X] verifyOperationSection"
+ "[X] verifyProcedureSection"
+ "[ipc] Send %llu"
+ "[ipc] callProc Cb %llu"
+ "[ipc] pCb %llu"
+ "[isHWReady] fw priority queue is not empty!"
+ "[isHWReady] job queue is not empty!"
+ "[isHWReady] my hwq has more req to start!"
+ "[isHWReady] paired hwq has more req to start!"
+ "_AneCallBack"
+ "__null != pSneTMDrv"
+ "_maskUnmaskMutex != (FFWMUTEX)0"
+ "actionbuf.bin"
+ "active cache request index (%d) with handler 0x%llx in wrong state %d"
+ "active cacheHandler (0x%llx) does not match the one stored in cache request (0x%llx)"
+ "active cacheHandler is 0"
+ "addDbgEvent"
+ "addEntry"
+ "addr != NULL"
+ "alignment != 0"
+ "allocDbgEventIdx"
+ "allocEntryIdx"
+ "allocL2SpillBufferIdx"
+ "allocatedPoolAddr[i] != NULL"
+ "appPriority %d"
+ "appPriorityToFwPriority"
+ "array != 0"
+ "arrayEmptyBuffer != 0"
+ "array[index].ch != 0"
+ "array[index].ch == 0"
+ "array[index].inuse == false"
+ "available == tot"
+ "bGroupInUse[%d] %d"
+ "bGroupRequest set with invalid group cacheHandler %llx expect %llx."
+ "bSaved == true"
+ "b_found == false"
+ "blockArray != 0"
+ "blocks <= CBuffer::idTot"
+ "bootArgs != 0"
+ "buf %d: addr 0x%llx size %lld"
+ "bufMsg->hdr.len <= sizeof(msg)"
+ "bufNbr <= maxAneIpcBufMsg"
+ "buffPointer"
+ "buffPool != 0"
+ "bufferLen == 0"
+ "bufferLen > sizeof(sIOPRingBuffer_t)"
+ "buffers != 0"
+ "buffers <= FFW_INTERPROC_BUFF_TOT"
+ "builtInProgramId %d exceeded max (%d)!"
+ "builtInProgramId %d is not valid!"
+ "builtInProgramId %d should be invalid!"
+ "bundledBlocks <= CBuffer::idTot"
+ "bundledBlocksIn <= CBuffer::idTot"
+ "cacheRequest[groupCacheReqIdx].bGroupCacheRequest == true"
+ "cacheRequest[groupCacheReqIdx].cacheHandler == pCacheReq->pGroupInfo->groupCacheHandler"
+ "cacheRequest[groupCacheReqIdx].pGroupInfo != __null"
+ "cacheRequest[groupCacheReqIdx].pGroupInfo == __null"
+ "cachedAddr != 0"
+ "calcTriggerUsDelay"
+ "ch != 0"
+ "chMan != 0"
+ "chManH2T != 0"
+ "chTot <= ISP_CAMERA_CHANNEL_TOT"
+ "channel < inchannels"
+ "channelBufferSize != 0"
+ "channelPhys != 0"
+ "channelTotal != 0"
+ "channel_mem != NULL"
+ "checkBarEachAneOp"
+ "checkRunningSlotsAfterAbort"
+ "checkpointId < mMaxCheckpoints"
+ "clear output buf[%d] 0x%llx size %lld"
+ "cmd->statsBuffer.buffer >= pProc->pStatArrayBaseOrig"
+ "cmd->statsBuffer.size >= sizeof(sCAneStatsData) + sizeof(sEventDescriptors) + sizeof(sCAneStatsDataDbgEvent)"
+ "cmdBuffer_mem != 0"
+ "cmdDataCheck"
+ "cmdInternalSema != (SEMA)0"
+ "cmdMbox != (MBOX)0"
+ "cmdMboxSema != (SEMA)0"
+ "cmdSema != (SEMA)0"
+ "cmdSynchronizationSema != (SEMA)0"
+ "context != NULL"
+ "count"
+ "crashlog"
+ "create writeRingBufferLen %d with writeRingBufferAddr at 0x%lx %d\n"
+ "createCacheRequest"
+ "curEntry"
+ "dPrio != 0"
+ "dPrio % 2 == 0"
+ "dPrio <= 124"
+ "dPrio <= RTK_THREAD_PRIORITY_MAX"
+ "dPrio >= RTK_THREAD_PRIORITY_MIN"
+ "dataBufSize == pBuf->_header._size"
+ "dataChainingRecycleOutput"
+ "dataChainingTrigger"
+ "dataChainingTriggerIsr"
+ "debug event buffer: offset=%d size=%d\n"
+ "decPendingExeLoopCmdCnt"
+ "deferredCmdAck == false"
+ "delay trigger[%lld]: execTimestamp %lld cmdHandleTimestamp %lld"
+ "deleteCacheRequest"
+ "depriorDsid"
+ "descr.indexList != 0"
+ "descr.list != 0"
+ "descr.lock != (FFWMUTEX)0"
+ "dieRequest != (SEMA)0"
+ "dieRequest != 0"
+ "dieSema != (SEMA)0"
+ "dispDataChainingLatency"
+ "dummy return\n"
+ "duty : %u %\n"
+ "enableEventLogInNetworkDesc"
+ "endPoint < maxEndpoint"
+ "endPointCb[endPoint].shareMem.nbrOfRemapItem < sCDMediaBusManagerShareMemInfo::maxSharedMemInfo"
+ "endPointCb[i].curState < ECDMEDIABUSMANGER_ENDPOINT_CB_STATE_MAX"
+ "endPointCb[pCmd->endPointId].curState != ECDMEDIABUSMANGER_ENDPOINT_CB_STATE_IDLE"
+ "endPointCb[pCmd->endPointId].curState < ECDMEDIABUSMANGER_ENDPOINT_CB_STATE_MAX"
+ "endPointCb[pCmd->endPointId].shareMem.nbrOfItem"
+ "endPointCb[pCmd->endPointId].shareMem.nbrOfItem < sCDMediaBusManagerShareMemInfo::maxSharedMemInfo"
+ "endPointCb[pCmd->endPointId].shareMem.nbrOfItem == 0"
+ "endPointCb[pCmd->endPointId].shareMem.nbrOfRemapItem"
+ "endPointCb[pCmd->endPointId].shareMem.nbrOfRemapItem == 0"
+ "endPointCb[pCmd->endPointId].shareMem.remap[i].refCount==0"
+ "endPointId < maxEndpoint"
+ "entries != 0"
+ "entries > 0"
+ "entries_per_pool > 0"
+ "entry != 0"
+ "entry != NULL"
+ "entry->callback || entry->callback_with_source"
+ "entry->stack != 0"
+ "entry->used == true"
+ "entryList != 0"
+ "entry_size > 0"
+ "exe_interval(%)"
+ "execution(us)"
+ "expandPool"
+ "extra_heap_virt != NULL"
+ "false == pCacheReq->bSingleUse"
+ "false == pCacheReq->bSingleUseTriggered"
+ "ffwQueueCount (queue) == 0"
+ "ffwrc == FFW_OK"
+ "fileDescs[i].pData != nullptr"
+ "fileDescs[i].size == fileDescs[i].sizeRef"
+ "fileLen"
+ "fileWrite"
+ "filter == (class CObject *)0"
+ "fiq(us)"
+ "found"
+ "foundIndex < ((8) + (0))"
+ "foundQueue == ((8) + (0))"
+ "foundQueue == ((8) + (0)) || foundQueue == i"
+ "freeEntryIdx"
+ "freeL2SpillBuffIdx"
+ "freeUnusedL2SpillBufferPool"
+ "freeUnusedPool"
+ "func != 0"
+ "fwPriority < ((8) + (0))"
+ "fwPriorityQ[%d] has %s\n"
+ "getActionProperty"
+ "getCacheReqPendingCmdCnt"
+ "getCacheReqState"
+ "getCacheRequestInfo"
+ "getCacheRequestIoBuffers"
+ "getCacheRequestIoBuffersNbr"
+ "getCacheRequestSignalEvents"
+ "getDataChainingInputInfo"
+ "getFileSize"
+ "getL2SpillBufferAddr"
+ "getNbrOfTd"
+ "getNetworkDescBufAddr"
+ "getProcedureCallType"
+ "getRequestId"
+ "getReservedNetworkDesc"
+ "getSeg1stTd_RTGraphH13"
+ "gpTimerArray != 0"
+ "group < MAX_ASYNCBUFFERS_GROUPS"
+ "group cache request index (%d) with handler 0x%llx in wrong state %d"
+ "group cacheHandler (0x%llx) does not match the one stored in cache request (0x%llx)"
+ "group cacheHandler is 0"
+ "groupCacheReqIdx < (16 + 2)"
+ "h"
+ "h != 0"
+ "h->ch != 0"
+ "h->chH2T != 0"
+ "h->chT2H != 0"
+ "h->managed == 0"
+ "h->signature == CFSM_SIGNATURE"
+ "h2tchIOMan != 0"
+ "handle != 0"
+ "handle != NULL"
+ "handleAbortCacheRequest"
+ "handleAbort_abortRaisePriority"
+ "handleCallProcedureWithBar"
+ "handleCmdChannel"
+ "handleDelayedTriggerCmd"
+ "handleInferenceCall_inThread"
+ "handleInvalidSingleUseCacheRequest"
+ "handleIpcEndpointCmd"
+ "handlePendingCmd"
+ "handleStats"
+ "handleSwitchedOutReq"
+ "handler == memHandler"
+ "handshake_info != NULL"
+ "hashNodeIdxMutex != (FFWMUTEX)0"
+ "hash_table_size > 0"
+ "head == 0"
+ "heapSize != 0"
+ "heap_resource != (FFWMUTEX)0"
+ "heap_resource != 0"
+ "hwqId < ((8) + (0))"
+ "i <= 1000"
+ "id < max"
+ "id >= 0 && id < CDMEDIABUSMANAGER_CMD_COMMON_TOT"
+ "idx != 0"
+ "inUseList == 0"
+ "incPendingExeLoopCmdCnt"
+ "index < ((8) + (0))"
+ "index < entries"
+ "index < tot"
+ "index == pEntry->parent"
+ "index >= 0"
+ "indexOfGroup < MAX_ASYNCBUFFERS_IN_GROUP"
+ "info"
+ "initDbgEventMem"
+ "initPSDLibService"
+ "initSharedEvents"
+ "inputPipe != 0"
+ "inputPipeEnable != nullptr"
+ "insize != CCONTROLLER_INVALID_SHARED_INSIZE"
+ "insize == sizeof(struct sCSneCmdPrintEnable)"
+ "instance != 0"
+ "instance != NULL"
+ "instance == 0"
+ "instance == NULL"
+ "instance == nullptr"
+ "instance->ch != 0"
+ "instance->chT2H != 0"
+ "internalCmdListMutex_ != (FFWMUTEX)0"
+ "interrupt(us)"
+ "interruptTimerSignal != 0"
+ "invalid group 0x%llx active 0x%llx cacheHandler"
+ "iobuf0.bin"
+ "iobuf1.bin"
+ "iobuf2.bin"
+ "irqLine != 0"
+ "isAneIdle"
+ "isCacheReqInUse"
+ "isCacheReqSingleUse"
+ "isCacheReqValid"
+ "isHWReady"
+ "isHWReady_myHwq"
+ "isHWReady_pairedHwq"
+ "isLast=%d nid=%d,%d using=%d\n"
+ "isrHandle"
+ "isrhandle != 0"
+ "it"
+ "list == 0"
+ "loadMonitorTask != RTK_THREAD_NONE"
+ "lock != (FFWMUTEX) 0"
+ "lock != nullptr"
+ "log != 0"
+ "logCmdData"
+ "logDepth > 0"
+ "logEntry"
+ "logRecvCmdAck"
+ "logTot <= logDepth"
+ "logicalBarIndex %d is for Text"
+ "mLatencyStat.maxEntryNum > 0"
+ "mLatencyStat.pCheckpoint"
+ "mLatencyStat.pCheckpoint[i]"
+ "mLatencyStat.pLatency"
+ "mLatencyStat.pLatency[i]"
+ "mMaxCheckpoints > 0"
+ "mMutex != (RESOURCE)0"
+ "management"
+ "maskCount[aispSource] > 0"
+ "maxBuff != 0"
+ "maxPriorityNbr <= ((8) + (0))"
+ "maxUserRequest <= (((8) + (0)) * 32 * 2)"
+ "max_hash_entries > 0"
+ "max_pool_num > 0 && max_pool_num <= MAX_EXPANDABLE_POOL_NUM"
+ "maxchannels != 0"
+ "maxmbox > 0"
+ "maxqueue > 1"
+ "maxres > 0"
+ "maxsema > 0"
+ "maxsig > 0"
+ "maxtask > 1"
+ "maxtimers > 0"
+ "mboxPool != 0"
+ "mboxPool == 0"
+ "memory != 0"
+ "message != NULL"
+ "messages > 0"
+ "mmu"
+ "mmuLoggerOn == true"
+ "mode < eAnsCmdSecureMode_Max"
+ "mpEntryIdxRefCount"
+ "mpEntryIdxRefCount[idx] == 0"
+ "mpEntryIdxRefCount[idx] > 0"
+ "mpGroupBufCnt[%d] %d"
+ "mpGroupsOwnerName[%d] %s"
+ "mpPoolInfo"
+ "mpPoolInfo[mFirstUnusedPoolIdx].pIndexPool != NULL"
+ "mpPoolInfo[mFirstUnusedPoolIdx].pPoolBaseAddr == NULL"
+ "mpPoolInfo[poolIdx].pIndexPool != NULL"
+ "mpPoolInfo[poolIdx].valid != 0"
+ "msgHandler"
+ "msgLen > 0"
+ "msgPhys != 0"
+ "mutex != (FFWMUTEX) NULL"
+ "mutex != (RESOURCE) 0"
+ "my hwq = 0x%x\n"
+ "my hwq is free"
+ "my hwq is free\n"
+ "my hwq is full\n"
+ "my hwq is waiting for dummy network to complete"
+ "my hwq: slot %d has more segments to go\n"
+ "myDbg"
+ "myProcCb"
+ "nBytes != NULL"
+ "name != 0"
+ "nbrOfRemapLeft == endPointCb[pCmd->endPointId].shareMem.nbrOfRemapItem"
+ "newState < ECDMEDIABUSMANGER_ENDPOINT_CB_STATE_MAX"
+ "newTask != RTK_THREAD_NONE"
+ "new_end > new_start"
+ "newrdptr <= pBuf->_header._size"
+ "nextIdx < (int32_t)pCallProperty->nbrOfSegments"
+ "nextIdx > 0"
+ "nextSegIdx"
+ "no req"
+ "numSwitchedOutReq <= ((8) + (0))"
+ "object != 0"
+ "object != NULL"
+ "ok == true"
+ "operationbuf.bin"
+ "outputAddr && outputSize"
+ "outputPipe != 0"
+ "outsize != 0"
+ "outstanding"
+ "outstanding <= entries"
+ "outstanding == 0"
+ "owner != 0"
+ "pActiveCacheReq->cacheHandler == pCacheReq->pGroupInfo->activeSubCacheHandler"
+ "pActiveCacheReq->cacheHandler == pSetActiveCmd->activeCacheHandler"
+ "pActiveCacheReq->state == ANE_DATA_CHAINING_CACHE_REQUEST_IN_USE"
+ "pAddr != NULL"
+ "pAneLatencyProfiler != __null"
+ "pBuf->_header._rdptr + sizeof(sIOPRingBufferMsgHeaderV2_t) < pBuf->_header._wrptr"
+ "pBuf->_header._rdptr + sizeof(sIOPRingBufferMsgHeader_t) < pBuf->_header._wrptr"
+ "pBufAddr && pBufSize && pBufIndex"
+ "pBufAddr[i] && pBufSize[i]"
+ "pBuffMsg->buffers <= FFW_INTERPROC_BUFF_TOT"
+ "pCacheReq->pGroupInfo"
+ "pCacheReq->pGroupInfo != __null"
+ "pCacheReq->pGroupInfo->isActive"
+ "pCall->bSingleUse == false"
+ "pCall->cacheHandler"
+ "pCall->cacheHandler == cacheRequest[groupCacheReqIdx].cacheHandler"
+ "pChainingIOInfo"
+ "pChainingIOInfo->inputs.nbrOfBuffers == numOfInputInNetwork"
+ "pChainingIOInfo->inputs.totalNbrOfBuffers == pCall->totalNbrOfInputBuffers"
+ "pChainingIOInfo->nbrOfOutputSets == pCall->nbrOfOutputBufferSets"
+ "pCmd != NULL"
+ "pCmd->bufNbr <= maxAneIpcBufMsg"
+ "pCmd->pSubPacket"
+ "pCmd->sharedMemIndex < sCDMediaBusManagerShareMemInfo::maxSharedMemInfo"
+ "pCustomBar"
+ "pData"
+ "pDataChainingIntermediateBufferDesc->buffer.type == eCSneBufferDescriptorType_IntermediateBuffer"
+ "pEntry->parent != index"
+ "pEntry->parent < logDepth"
+ "pEntry->parent == index"
+ "pEntry->physicalAddr"
+ "pEntry->refCount"
+ "pEntry->virtualAddr"
+ "pExchange->buffers > 0"
+ "pGroupCacheReq->cacheHandler == pSetActiveCmd->groupCacheHandler"
+ "pGroupCacheReq->cacheHandler == pTriggerCmd->cacheHandler"
+ "pGroupCacheReq->pGroupInfo != __null"
+ "pGroupCacheReq->pGroupInfo == pActiveCacheReq->pGroupInfo"
+ "pGroupCacheReq->pGroupInfo->isActive"
+ "pGroupCacheReq->state == ANE_DATA_CHAINING_CACHE_REQUEST_IN_USE"
+ "pGroupInfo->isActive == false"
+ "pInternalCmdArray_"
+ "pInternalCmdFreeList_"
+ "pInternalCmdList_"
+ "pItem->bufferRefCount"
+ "pItem->pBase == pCmd->sharedMemPtr"
+ "pItem->used"
+ "pMMULogger != NULL"
+ "pMMULogger == NULL"
+ "pMsg"
+ "pMsg != 0"
+ "pMyMsg->id == FFW_INTERPROC_MSG_EXCHANGE"
+ "pNextSeg->len"
+ "pNodeData != NULL"
+ "pPC != __null"
+ "pPoolAddrToFree[i] != NULL"
+ "pReq->fwPriority < ((8) + (0))"
+ "pReq->request.bIsMultipleSegments && !pReq->request.bIsBondedNetwork"
+ "pRingBuffer != 0"
+ "pSecureModeCmdBuf != __null"
+ "pSetActiveCmd->activeCacheHandler != 0"
+ "pSetActiveCmd->groupCacheHandler != 0"
+ "pSetActiveCmd->groupCacheHandler == pSetActiveCmd->activeCacheHandler"
+ "pSize != 0"
+ "pSneDrv == __null"
+ "pSneItqDrv != __null"
+ "pStride != 0"
+ "pSubPacket != NULL"
+ "pSwitchedOutReq != __null"
+ "pSwitchedOutReq->request.prefetchDsid != (0xFF)"
+ "pTemp"
+ "pTemp + pCmd->pBufSize[i] <= (size_t)pItem->pBase + pItem->memSize"
+ "pTemp >= (size_t)pItem->pBase && pTemp <= (size_t)pItem->pBase + pItem->memSize"
+ "pThis->bIsExclaveSupported && pThis->bEnableSecureModeHandshake"
+ "pTriggerCmd->activeCacheHandler == pGroupCacheReq->pGroupInfo->activeSubCacheHandler"
+ "pTriggerCmd->bGroup"
+ "pUserStr != 0"
+ "paired hwq = 0x%x\n"
+ "param1 >= sizeof(struct ffwInterProcMsg)"
+ "parent < logDepth"
+ "parent == logDepth"
+ "parent == pEntry->parent"
+ "parentEntry->child"
+ "parentEntry->physicalAddr"
+ "parentEntry->virtualAddr"
+ "parseOperation"
+ "parseProc"
+ "physicalAddr"
+ "physicalAddr != (uintptr_t) -1"
+ "pin < buffPools"
+ "pin < inputs"
+ "pin < outputs"
+ "pin < portInputs"
+ "pointer"
+ "pointer != 0"
+ "pointer != NULL"
+ "pointer == VP(messagePhys)"
+ "pool != (void *)0"
+ "pool != 0"
+ "pool == ALIGN_DOWN(pool, CMMU::CacheLineSize())"
+ "poolArray != 0"
+ "poolArray[container->attach.id] == 0"
+ "poolArray[id] != 0"
+ "poolBufferReceived != 0"
+ "poolBufferReturned != 0"
+ "poolIdx < mMaxPoolNum"
+ "poolIdx >= 0 && poolIdx < mMaxPoolNum"
+ "poolsizeIn >= CBufferPoolStatic::PoolSizeGet(buffers, newbundledBlocks, newsize, newalignment)"
+ "port < inports"
+ "powerUpAne"
+ "powerUpAneStage1"
+ "powerUpAneStage2"
+ "print"
+ "printCommandInfo"
+ "printEnqueueHwqInfo"
+ "printInfo"
+ "printStats"
+ "printTQState"
+ "priority != 0"
+ "priority <= RTK_THREAD_PRIORITY_MAX"
+ "priority >= RTK_THREAD_PRIORITY_MIN"
+ "processCmdOnly == true"
+ "processedCmdCounter == 0"
+ "processorEnter"
+ "processorExit"
+ "prog.tdProp.buf %p procValid %d"
+ "programId 0x%x processId 0x%x nbrAneMapping %d"
+ "programId 0x%x processId 0x%x procedureId 0x%x"
+ "propertyWrite"
+ "pushHWQ: hwqId=%d jobId=%d isMultiSeg=%d nid=%d\n"
+ "pushHWQ: hwqId=%d jobId=%d isMultiSeg=%d segId=%d isRewind=%d\n"
+ "pushToHW"
+ "pushToHWDirect"
+ "queue != (FFWQUEUE)0"
+ "queueDepth > 1"
+ "queueId < (8)"
+ "queuePool != 0"
+ "queuePool == 0"
+ "rc != NULL"
+ "rc == 1"
+ "rc == RTK_ST_OK"
+ "rc >= 0"
+ "rdptr + sizeof(sIOPRingBufferMsgHeaderV2_t) < localCopyWrPtr"
+ "rdptr + sizeof(sIOPRingBufferMsgHeaderV2_t) < pBuf->_header._size"
+ "rdptr + sizeof(sIOPRingBufferMsgHeader_t) < localCopyWrPtr"
+ "rdptr + sizeof(sIOPRingBufferMsgHeader_t) < pBuf->_header._size"
+ "reader"
+ "recycleArray != 0"
+ "ref%d/%s"
+ "reportDataChainingTriggerFailed"
+ "reportFinishEvent"
+ "req"
+ "reqRunningStatus[index] != 0"
+ "reqRunning[index][0].request.hwEnqueueTimestamp"
+ "reqRunning[index][1].request.hwEnqueueTimestamp"
+ "resPool != 0"
+ "resPool == 0"
+ "reset"
+ "ret == 0"
+ "retain"
+ "retain == CBuffer::suspended"
+ "retainL2SpillBufferIdx"
+ "returnRequestId"
+ "rtbuddyFW: %s\n"
+ "rtkitSystemTaskList != 0"
+ "runningSegIdx < (int32_t)pCallProperty->nbrOfSegments"
+ "runningSegIdx >= 0"
+ "sCSneCmdProcedureCall [%d] : bufferIndex %d"
+ "saveSwitchedOutReq"
+ "saveToFile"
+ "scheduleAneReq"
+ "seg[%d]: id=%d nextId=%d 1stTid=%d isBranching=%d isBranched=%d isLast=%d isRewind=%d tdNbr=%d glbSegId=%d addr=0x%llx len=%lld\n"
+ "sema != 0"
+ "sema != NULL"
+ "sema == 0"
+ "semaArray != (SEMA *)0"
+ "semaArray[index] != (SEMA)0"
+ "semaIndex <= sizeof(semaArray)/sizeof(semaArray[0])"
+ "semaPool != 0"
+ "semaPool == 0"
+ "semaphore == (SEMA)0"
+ "semaphore == h->signalT2H"
+ "sendEnqueueEvt_prepareFinishEvt_inIsr"
+ "serialPollTimer[i] != 0"
+ "serialPortPoolTimeOut[i] != (SEMA)0"
+ "serialPortSignal[i] != (SEMA)0"
+ "set buf[%d] 0x%llx zero sz %lld"
+ "setActiveCacheRequestInGroup"
+ "setCustomBars"
+ "setDataChainingLatencyDisp"
+ "setDataChainingLatencyDisp %d"
+ "setDirectAneRequestInfo"
+ "setEnableDynamicPowerGate"
+ "setForceDisableCacheRequest"
+ "setInitFlags"
+ "setJobQueueId"
+ "setOtherTqState"
+ "setPerfMode"
+ "setResetMode"
+ "setResetMode %d"
+ "setStartTimestamp"
+ "setTQPriority"
+ "setTQState"
+ "setTaskSwitchEventDisp"
+ "setTaskSwitchEventDisp %d"
+ "setupAneReq_inIsr"
+ "setupCacheRequest"
+ "setupDirectProcCallEvents"
+ "setupEngineReq"
+ "setupEngineReqInternal"
+ "setupEngineReqStatsBuffer"
+ "setupNetworkDescriptor_withBars"
+ "shAddr != NULL"
+ "sharedEventsTrigger"
+ "sharedEventsTriggerIsr"
+ "sharedMem != 0"
+ "shwdStatus == 0"
+ "sigPool == 0"
+ "signal != 0"
+ "signalH2T != 0"
+ "signalNonSec2SecSema"
+ "signalResetNotification"
+ "signalSharedEvents"
+ "signalT2H != 0"
+ "size != 0"
+ "size <= sizeof(pBuffMsg->extra)"
+ "sizeInByte % 4 == 0"
+ "sizeInByte > 0"
+ "slotNext != -1"
+ "source < INT_NROF_VECTORS"
+ "source < ISR_REG_ENTRY"
+ "source < lines * ISR_REG_ENTRY"
+ "source >= 0"
+ "src != NULL"
+ "stacksize != 0"
+ "startInvalidateCacheRequestInExeLoop"
+ "started == false"
+ "statsBufOffset + cmd->statsBuffer.size < pProc->sizeOfStatBufArray"
+ "statsBufferSizeGet"
+ "status == FFW_OK"
+ "status == RTK_ST_OK"
+ "sub cache request index (%d) with handler 0x%llx in wrong state %d"
+ "super::Available() == (int)super::Managed()"
+ "switchToIsolatedMode"
+ "switched from NonSec -> Sec, ANE goes to PAUSE\n"
+ "switched from Sec, ANE goes to RUN\n"
+ "syncCmdMutex_ != (FFWMUTEX)0"
+ "synchronization != (SEMA)0"
+ "synchronize != (SEMA)0"
+ "syslog"
+ "task != (TASK)0"
+ "task != 0"
+ "taskId == self"
+ "taskPool == 0"
+ "taskTime != 0"
+ "temp != 0"
+ "this->buffers >= buffers"
+ "threadHistoryLock != (FFWMUTEX) 0"
+ "ticket < cmdDepth"
+ "timerHandle != NULL"
+ "timerSem != NULL"
+ "token != 0"
+ "tot != 0"
+ "tot == 0"
+ "tot > 0"
+ "totalElapsed %lld or totalElapsedInterval %lld is invalid value\n"
+ "totalElapsed(from tracekit) %lld, totalElapsedDuringCheckpoint %lld\n"
+ "totalElapsedInterval(from tracekit) %lld, totalElapsedIntervalDuringCheckpoint %lld\n"
+ "tqEnqueueReq_inIsr"
+ "tree_resource != (FFWMUTEX)0"
+ "tree_resource != 0"
+ "true"
+ "tryPushToHw_fromFwPriorityQ"
+ "unexpected usage for nidSecondary (%d), bIsMultipleSegments %d, bIsBondedNetwork %d"
+ "updateDefSetting"
+ "updateEngineRequestSegment"
+ "updateEngineRequestWithNextSegment"
+ "updateStatsBufferData"
+ "user1"
+ "vPrintLock != (SEMA)0"
+ "vPrintLock == (SEMA)NULL"
+ "value != NULL"
+ "verifyBAR"
+ "verifyCustomBar"
+ "verifyDescriptorPropSection"
+ "verifyDescriptors"
+ "verifyGenericSection"
+ "verifyKernelPropSection"
+ "verifyOperationSection"
+ "verifyProcedure"
+ "verifyProcedureSection"
+ "verifyProgram"
+ "virtualAddr"
+ "virtualAddr != NULL"
+ "waitTQIdle"
+ "wiringPageSize == 0x4000"
+ "write to overwrite ref%d/%s"
+ "~CScopedLock"
- "\tBufs = %d Priority = %d uuid = 0x%llx\n"
- "  %s : %s\n"
- "!pExeLoop->pSneDrv->GetTQEn()"
- "%s .Sanity check failure!\n"
- "(pCmdHdr->id == CSNE_CMD_PROCEDURE_CALL_CACHE_REQUEST_WITH_CUSTOM_BARS) || (pCmdHdr->id == CSNE_CMD_PROCEDURE_CALL_CACHE_REQUEST_WITH_SHARED_EVENTS)"
- "(pTdCmd->relocationCmd.r.barIdx & 1) == 0"
- "(pTriggerCmd->execTimestamp > pCacheReq->lastTriggerExecTimestamp) || ((pCacheReq->lastTriggerExecTimestamp - pTriggerCmd->execTimestamp) & (0xF000000000000000LLU))"
- "./ffw64_rtxc/ffw/CAsyncBufferManager.cpp"
- "./ffw64_rtxc/ffw/CBufferPoolDynamic.cpp"
- "./ffw64_rtxc/ffw/CBufferPoolDynamicManager.cpp"
- "./ffw64_rtxc/ffw/CBufferPoolDynamicManagerSynch.cpp"
- "./ffw64_rtxc/ffw/CDMediaBusManager.cpp"
- "./ffw64_rtxc/ffw/CFSM.cpp"
- "./ffw64_rtxc/ffw/CIOObject.cpp"
- "./ffw64_rtxc/ffw/CIOPRingBuffer.cpp"
- "./ffw64_rtxc/ffw/CIndexPool.cpp"
- "./ffw64_rtxc/ffw/rtkit/CMMUDynamic.cpp"
- "./ffw64_rtxc/ffw/rtkit/ffwMMU.cpp"
- "./sne/aneEngine/exeLoop/CAneEngineExeLoopH17FSMDef.cpp"
- "./sne/aneEngine/progManager/CAneProgramManager.cpp"
- "./sne/aneEngine/progManager/CAneProgramManagerH17.cpp"
- "./sne/drivers/tm/CSneTMDrv.cpp"
- "21:53:59"
- "Apr 20 2025"
- "CAneProgramManagerH17.cpp"
- "CMD = %#04x [%s] at %lld : ProgId = %d ProcId = %d, Proc = %d\n"
- "CMD = %#04x [PROC CALL WITH CUSTOM BARS] at %lld : ProgId = %d ProcId = %d, Proc = %d\n"
- "CMD = %#04x [PROC CALL WITH EVENTS] at %lld : ProgId = %d ProcId = %d, Proc = %d\n"
- "Couldn't find ShareMemInfoItem to free !!!\n"
- "Function should be overridden"
- "Function should be overridden and not supported"
- "IPC Endpoint cmd failed %d"
- "IPC Endpoint cmd failure"
- "Offset 0x%lx with value 0x%x"
- "Procedure %d exceeded maximum for program %d"
- "Run out of CSharedMemory !!!\n"
- "Seg enqueue [%d] ProcSegIdx:%d Job:%d nid:%d,%d using:%d isRewind:%d isLast:%d"
- "SneTMDrv"
- "[%s]  CMD = %#04x [%s] at %lld : ProgId = %d ProcId = %d, Proc = %d\n"
- "[%s]  CMD = %#04x [PROC CALL WITH CUSTOM BARS] at %lld : ProgId = %d ProcId = %d, Proc = %d\n"
- "[%s]  CMD = %#04x [PROC CALL WITH EVENTS] at %lld : ProgId = %d ProcId = %d, Proc = %d\n"
- "[ANE_TM_EVENT_TASK_SWITCH]: tid=%3d, nid=%3d, prevTQ=%3d, progId=%3d, procId=%3d, currTQ=%d, timeStamp=%lld\n"
- "[EXELOOP] CMD = %#04x [%s] at %lld : ProgId = %d ProcId = %d, Proc = %d\n"
- "[EXELOOP] CMD = %#04x [PROC CALL WITH CUSTOM BARS] at %lld : ProgId = %d ProcId = %d, Proc = %d\n"
- "[EXELOOP] CMD = %#04x [PROC CALL WITH EVENTS] at %lld : ProgId = %d ProcId = %d, Proc = %d\n"
- "[isHWReady] HW queue %d, slot %d have more segments to go!"
- "[isHWReady] HW queue is waiting for dummy network to complete"
- "[isHWReady] job queue is full!"
- "[isHWReady] no free slot!"
- "[isHWReady] priority queue is full!"
- "__null != pSneDrv"
- "__null != pTD && tdSize >= (sizeof(ane_TD_HEADER_t) - 4)"
- "__null == pOutAne"
- "__null == pOutTd"
- "appPriority < 8"
- "appPriority=%d"
- "call->priority < 8"
- "check HW pending TD count: queue_idx=%2d, pendingTDCount=%d"
- "foundIndex < 8"
- "foundQueue == 8"
- "foundQueue == 8 || foundQueue == i"
- "fwPriority < 8"
- "hwqId < 8"
- "index < 8"
- "maxPriorityNbr <= 8"
- "maxUserRequest <= (8 * 32 * 2)"
- "pCacheReq->cacheHandler == pTriggerCmd->cacheHandler"
- "pFwPriorityQueue[i]"
- "pJobQueue[i] != 0"
- "pProc != __null"
- "pProg != __null"
- "pReq->fwPriority < 8"
- "pReq->request.bIsMultipleSegments"
- "pReq->request.dbgEventIdx != CIndexPool::invalidIndex"
- "pReqNext->fwPriority == foundIndex"
- "pReqTemp == pReqNext"
- "priority < 8"
- "queueId < 8"
- "seg[%d]: id=%d nextId=%d 1stTid=%d isBranching=%d isBranched=%d isLast=%d isRewind=%d addr=0x%llx len=%lld\n"
- "slotNext == !slot"
- "switched from Sec -> Iso, ANE goes to RUN\n"
- "tdSize >= (sizeof(ane_TD_HEADER_t))"
- "unexpected usage for nidSecondary (%d), bIsMultipleSegments %d"
- "unremap WriteMessage failed\n"

```
