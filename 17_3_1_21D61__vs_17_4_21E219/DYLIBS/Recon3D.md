## Recon3D

> `/System/Library/PrivateFrameworks/Recon3D.framework/Recon3D`

```diff

-6.31.53.0.0
-  __TEXT.__text: 0x1185728
-  __TEXT.__auth_stubs: 0x2330
-  __TEXT.__const: 0xfd020
-  __TEXT.__gcc_except_tab: 0xb766c
-  __TEXT.__cstring: 0x33f84
-  __TEXT.__oslogstring: 0x3e68
-  __TEXT.__unwind_info: 0x2f670
+6.55.1.0.0
+  __TEXT.__text: 0x13f0d48
+  __TEXT.__auth_stubs: 0x23d0
+  __TEXT.__const: 0x107520
+  __TEXT.__gcc_except_tab: 0xd39f0
+  __TEXT.__cstring: 0x3a0ba
+  __TEXT.__oslogstring: 0x5413
+  __TEXT.__unwind_info: 0x311a0
   __TEXT.__eh_frame: 0x128
   __TEXT.__objc_classname: 0x1
-  __TEXT.__objc_methname: 0xbc4
-  __TEXT.__objc_stubs: 0xfa0
-  __DATA_CONST.__got: 0x360
-  __DATA_CONST.__const: 0x1b40
+  __TEXT.__objc_methname: 0xbe1
+  __TEXT.__objc_stubs: 0xfe0
+  __DATA_CONST.__got: 0x358
+  __DATA_CONST.__const: 0x1c50
   __DATA_CONST.__objc_imageinfo: 0x8
-  __DATA_CONST.__objc_selrefs: 0x3e8
-  __AUTH_CONST.__const: 0x52e30
+  __DATA_CONST.__objc_selrefs: 0x3f8
+  __DATA_CONST.__objc_classrefs: 0xd8
+  __AUTH_CONST.__const: 0x552e8
   __AUTH_CONST.__cfstring: 0x240
-  __AUTH_CONST.__auth_got: 0x11a8
-  __AUTH.__data: 0x48
+  __AUTH_CONST.__auth_got: 0x11f8
+  __AUTH.__data: 0x50
   __DATA.__got_weak: 0x8
-  __DATA.__objc_classrefs: 0xd0
-  __DATA.__data: 0xd768
+  __DATA.__data: 0xed30
   __DATA.__thread_vars: 0x48
   __DATA.__crash_info: 0x40
   __DATA.__thread_bss: 0x38
-  __DATA.__bss: 0x2838
-  __DATA.__common: 0xb0
+  __DATA.__bss: 0x2948
+  __DATA.__common: 0x4c0
   - /System/Library/Frameworks/Accelerate.framework/Accelerate
   - /System/Library/Frameworks/Accelerate.framework/Frameworks/vImage.framework/vImage
   - /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation

   - /usr/lib/libSystem.B.dylib
   - /usr/lib/libc++.1.dylib
   - /usr/lib/libobjc.A.dylib
-  UUID: 811EC7F2-3EEE-36B9-94FB-A3B15B700CB7
-  Functions: 35515
-  Symbols:   1498
-  CStrings:  4919
+  UUID: 6A48F4C5-B904-3558-94D0-8BA7AE7E3EDF
+  Functions: 36457
+  Symbols:   1516
+  CStrings:  5999
 
Symbols:
+ _CV3DReconFrameBundleSetAnalyticsMetadata
+ _CV3DReconFrameBundleSetCameraMetadata
+ _CV3DReconKeyframeGetCameraMetadata
+ _CV3DReconLoggingHandleStartLoggingToConsole
+ _CV3DReconPlaneDetectionStatefulLoggerCreate
+ _CV3DReconPlaneDetectionStatefulLoggerPushLogDict
+ _CV3DReconPlaneDetectionStatefulLoggerRelease
+ _OBJC_CLASS_$_NSData
+ __ZNSt3__111this_thread9sleep_forERKNS_6chrono8durationIxNS_5ratioILl1ELl1000000000EEEEE
+ __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEmc
+ __ZNSt3__14__fs10filesystem16_FilesystemClock3nowEv
+ __ZNSt3__16localeaSERKS0_
+ __ZnamSt11align_val_t
+ ___divti3
+ __os_log_pack_fill
+ __os_log_pack_size
+ _copyfile
+ _copyfile_state_alloc
+ _copyfile_state_free
+ _fmodf
+ _ilogb
+ _kCV3DPlaneDetectionPlaneOrientationOther
+ _malloc_type_aligned_alloc
+ _objc_release_x28
+ _objc_retain_x20
+ _objc_retain_x21
+ _objc_retain_x22
+ _objc_retain_x23
+ _objc_retain_x25
+ _objc_retain_x3
+ _os_log_pack_send
+ _xpc_dictionary_apply
+ _xpc_dictionary_get_count
+ _xpc_int64_create
+ _xpc_string_create
- _CV3DReconSessionConfigurationGetDownsampleFactor
- __ZNKSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4findEcm
- __ZNKSt3__115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEE3strEv
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE5eraseEmm
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEPKc
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEPKc
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEPKcm
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6insertEmPKc
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7replaceEmmPKc
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_mmRKS4_
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEaSEc
- __ZNSt3__115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEE3strERKNS_12basic_stringIcS2_S4_EE
- __ZNSt3__115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEEC1EOS5_
- __os_signpost_emit_with_name_impl
- _os_signpost_enabled
- _usleep
CStrings:
+ " .\\/:*?|<>\""
+ " already exists!"
+ " does not exist!"
+ " not in track"
+ " type-"
+ "!(d_erased ^ f_erased)"
+ "!(is_pose_update && is_external)"
+ "!CV3D_TARGET_IS_PUBLIC"
+ "!Contains(key)"
+ "!ContainsKey(raster_buffer, out_rendering.get())"
+ "!HasLoaded()"
+ "!KeyframeInfoExists(keyframe_data.uuid)"
+ "!ShouldEradicate()"
+ "!VoxelBlockOctreeNode::IsUnknown(allocated_index)"
+ "!VoxelBlockOctreeNode::IsUnknown(block_index)"
+ "!VoxelBlockOctreeNode::IsUnknown(info_index)"
+ "!candidate_cids.empty()"
+ "!cids.empty()"
+ "!clients.empty()"
+ "!color.color->Empty()"
+ "!confidence.Empty()"
+ "!config_.compute_normals || raster_normals_.back() && (!raster_normals_.back()->Empty())"
+ "!config_.render_semantics || (raster_semantics_.back() && (!raster_semantics_.back()->Empty()))"
+ "!coordinate_system_store_.count(cid) && \"Cluster already exist!\""
+ "!depth.Empty()"
+ "!depth.active_depth_mask->distance_transform.Empty()"
+ "!depth.confidence->Empty()"
+ "!depth.depth->Empty()"
+ "!depth.normals->Empty()"
+ "!depth.uncertainty->Empty()"
+ "!derived.invalid_pixel_mask->Empty()"
+ "!derived.processed_depth->Empty()"
+ "!derived.processed_semantics->Empty()"
+ "!derived.raster_depth->Empty()"
+ "!error_downstream_.empty()"
+ "!image.Empty()"
+ "!input.ColorRgba16f().Empty()"
+ "!input.DepthConfidence().Empty() && !input.NormalRgba16f().Empty()"
+ "!input.MaterialHistogram().Empty()"
+ "!input.SemanticHistogram().Empty()"
+ "!is_region(outer)"
+ "!keyframe_engine_result.jasper_clouds.has_value() && keyframe_engine_result.pending_updates.empty() && keyframe_engine_result.overlapping_candidates.empty() && keyframe_engine_result.integration_candidates.empty() && !keyframe_engine_result.monitoring_result.has_value()"
+ "!kf_config.nvs.use_nvs_network"
+ "!level.has_value()"
+ "!materials_image->Empty()"
+ "!metadata_block.IsErased()"
+ "!metadata_blocks_[idx_block].IsErased()"
+ "!metadata_blocks_[index].IsErased()"
+ "!metadata_blocks_[iter->second].IsErased()"
+ "!multi_voxel_store_.VoxelBlockAllocatedAt(std::nullopt, block_pos)"
+ "!normals.Empty()"
+ "!opt_label_confidence_view || opt_label_confidence_view->Size() == size"
+ "!recon::HasMappingAttribute(mask, MappingAttribute::JasperPoint)"
+ "!recon::HasMappingAttribute(mask, MappingAttribute::Normal)"
+ "!recon::HasMappingAttribute(mask, recon::MappingAttribute::JasperPoint)"
+ "!recon::HasMappingAttribute(mask, recon::MappingAttribute::Normal)"
+ "!scene_type.Empty()"
+ "!scene_type.confidence->Empty()"
+ "!scene_type.labels->Empty()"
+ "!semantic.confidence->Empty()"
+ "!semantic.labels->Empty()"
+ "!tracked_kfs.empty()"
+ "!update_for_invalid_pose"
+ "!vt1->IsOnAnyPlanes(*visible_planes)"
+ "# mirror boundary pixels"
+ "# mirror pixels"
+ "# mirror pixels with invalid plane fit"
+ "# mirror pixels with valid plane fit"
+ "# rejected due to bad plane fit"
+ "# rejected due to size"
+ "# valid plane fit"
+ "#tracked keyframes"
+ "%.3f"
+ "(!surface_conversion_params_.target_dimension || (scaled_kf->Camera().ImageSize() == *surface_conversion_params_.target_dimension))"
+ "((integrate_attribute_mask & config.mapping_attribute_mask) == integrate_attribute_mask)"
+ "(alpha >= 0.f && alpha <= 1.f)"
+ "(bytes_per_row % bytes_per_pixel == 0)"
+ "(cur_warp_mask & fusion_mask_) == cur_warp_mask"
+ "(depth.Width() >= 1 && depth.Height() >= 1)"
+ "(frame.Depth().has_value() || frame.Color().has_value())"
+ "(input.IsValid() && output.IsValid())"
+ "(keyframing_config.cpu_engine && keyframing_config.mono_depth.enable_mono_depth)"
+ "(kf1.Width() == kf2.Width() && kf1.Height() == kf2.Height())"
+ "(mesh.colors.empty() || mesh.colors.size() == mesh.vertices.size())"
+ "(mesh.colors.size() == 0 || mesh.colors.size() == mesh.vertices.size())"
+ "(mesh.colors_type == TriMeshMetadataType::PerVertex || mesh.colors_type == TriMeshMetadataType::Unknown)"
+ "(mesh.confidences.empty() || (mesh.confidences_type == kit::mesh::TriMeshMetadataType::PerVertex && mesh.confidences.size() == mesh.vertices.size()))"
+ "(mesh.materials.empty() || (mesh.materials_type == kit::mesh::TriMeshMetadataType::PerFace && mesh.materials.size() == mesh.faces.size()))"
+ "(mesh.materials.empty() || mesh.materials.size() == mesh.faces.size())"
+ "(mesh.normals.empty() || mesh.normals.size() == mesh.vertices.size())"
+ "(mesh.normals_type == TriMeshMetadataType::PerVertex || mesh.normals_type == TriMeshMetadataType::Unknown)"
+ "(mesh.semantics.empty() || (mesh.semantics_type == kit::mesh::TriMeshMetadataType::PerFace && mesh.semantics.size() == mesh.faces.size()))"
+ "(mesh.semantics.empty() || mesh.semantics.size() == mesh.faces.size())"
+ "(mesh.tex_coords.empty())"
+ "(mesh.tex_faces.empty())"
+ "(mesh.tex_faces.size() == 0)"
+ "(mesh.tex_faces.size() == mesh.faces.size())"
+ "(mesh.vertices.size() == mesh.normals.size() || mesh.normals.empty())"
+ "(mesh_ptr->faces.empty() == mesh_ptr->vertices.empty())"
+ "(new_weight >= 0 && new_weight <= std::numeric_limits<SdfVoxel::WeightType>::max())"
+ "(pruning_cg.max_num_keyframes >= pruning_cg.max_keyframe_safety_buffer + 10)"
+ "(semantic.Width() >= 1 && semantic.Height() >= 1)"
+ "(system::is_device_virtual_machine() || has_primitive_id_rendering())"
+ "(voxel_normal.e() > -128).all() && (voxel_normal.e() < 128).all()"
+ "(voxel_pt.e() > -128).all() && (voxel_pt.e() < 128).all()"
+ "(was external, removing pose update, setting update state to "
+ "(width == texture.width()) && (height == texture.height())"
+ "*c < *KeyframeBundleComponent::NumComponents"
+ ", using "
+ ".Topology"
+ ".snapshot_throttle"
+ "/AppleInternal/Library/BuildRoots/ce7a2ab7-ccb4-11ee-8860-1e1d6dc629d0/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.4.Internal.sdk/usr/local/include/boost/geometry/algorithms/detail/has_self_intersections.hpp"
+ "/AppleInternal/Library/BuildRoots/ce7a2ab7-ccb4-11ee-8860-1e1d6dc629d0/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.4.Internal.sdk/usr/local/include/boost/geometry/algorithms/detail/overlay/add_rings.hpp"
+ "/AppleInternal/Library/BuildRoots/ce7a2ab7-ccb4-11ee-8860-1e1d6dc629d0/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.4.Internal.sdk/usr/local/include/boost/geometry/algorithms/detail/overlay/get_turn_info_la.hpp"
+ "/AppleInternal/Library/BuildRoots/ce7a2ab7-ccb4-11ee-8860-1e1d6dc629d0/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.4.Internal.sdk/usr/local/include/boost/rational.hpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Essentials/Thread/src/DispatchQueue.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Essentials/Thread/src/DispatchQueueTypeUtil.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Kit/XPC/include/Kit/XPC/DictionaryRef.h"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Block/include/Reconstruction/Block/MultiVoxelStore.h"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Block/include/Reconstruction/Block/MultiVoxelStore.hpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Block/include/Reconstruction/Block/VoxelStore.hpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Common/src/CommonConfig.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Frame/include/Reconstruction/Frame/MeshBacklogger.h"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Frame/src/GenericGlobalReferenceSystem.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Frame/src/GlobalReferenceSystemManager.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Frame/src/KeyVolInterface.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Frame/src/KeyframeClusterProvider.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Frame/src/MeshBacklogger.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Geometry/include/Reconstruction/Geometry/NearestNeighbor3D.hpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Geometry/include/Reconstruction/Geometry/WalkAround.hpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/KeyframeOccupancy/include/Reconstruction/KeyframeOccupancy/FrameVoxelCollector.hpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/KeyframeOccupancy/include/Reconstruction/KeyframeOccupancy/Utils.h"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/KeyframeOccupancy/src/FrameVoxelCollector.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/KeyframeOccupancy/src/KeyframeObservationStore.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/KeyframePlanes/src/KeyframePlaneDetector.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Keyframing/src/KeyframeCache.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/SessionNodeGroup/src/ClusterIntegrator.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/SessionNodeGroup/src/CoordinateSystemContainer.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Utils/src/FailureSnapshot.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Visualization/src/VisualizationData.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Visualization/src/VisualizationDataIO.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/VolumetricMapper/src/BlockMarchingCubesMeshMerger.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/VolumetricMapper/src/ChunkMeshTable.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/VolumetricMapper/src/MirrorCorrectionFrame.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/VolumetricMapper/src/MirrorPlaneFitter.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/VolumetricMapper/src/MirrorRegions.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/VolumetricMapper/src/VolumetricMapperConfig.cpp"
+ ": failed to open file for overwrite"
+ "; KeyframeEngine::SaveSnapshotTo failed during cloning."
+ "<Neural>"
+ "<Occupancy>"
+ "<PointCloud>"
+ "<Volumetric>"
+ "A block must be smaller than a chunk"
+ "A plane from an opposite direction was added to a vertex"
+ "ACTIVITY_LOG_STDERR"
+ "Abort: "
+ "Access element out of bounds"
+ "Active depth mask buffer not valid"
+ "Add anchor block not valid"
+ "Adding non-finite point"
+ "All weights are zero"
+ "Allocated blocks before update: %i"
+ "Allocation failed"
+ "Analytics metadata is null"
+ "Anchor external keyframes"
+ "Array is NULL"
+ "Attach fails."
+ "Attempting to enable an already-enabled session. Ignoring..."
+ "Attribute not supported in per-frame meshing"
+ "Attribute requests not implemented"
+ "B24@?0r*8^v16"
+ "Base folder must exist"
+ "Base::BlockSize() < chunk_size_"
+ "Batch metadata does not match keyframing adaptor internal config."
+ "Block index out of bounds"
+ "Block table is expected to cache 15 neighbors"
+ "BlockPositionRangeContains(node_range, neighbor_position)"
+ "Buffer not created"
+ "Buffer not present"
+ "Bundle does not exist with bid-"
+ "Bundle does not exist with cid-"
+ "Bundle not found."
+ "CFLOG_FORCE_STDERR"
+ "CVA vector requires width multiple of 4"
+ "Callable must be valid"
+ "Camera metadata is null"
+ "Camera size should be identical for all keyframes"
+ "Can only erase an added block!"
+ "Can't handle requests for multiple res"
+ "Cannot allocate MTLBuffer of size zero"
+ "Cannot find the plane ID in parent_plane_id_."
+ "Cannot find the plane ID in plane_needs_remesh_."
+ "Cannot fuse rawframe"
+ "Cannot get an erased block"
+ "Cannot integrate an invalid material label"
+ "Cannot open file"
+ "Capacity not big enough."
+ "Cell index does not match."
+ "Chunk reference does not exist in the mesh map"
+ "Clipping point lux is not available"
+ "Cluster cannot be empty!"
+ "Cluster is disabled."
+ "Cluster not found"
+ "Cluster not found!"
+ "Cluster not initalized"
+ "Color buffer not valid"
+ "ColorAndMaterials"
+ "ColorAndSemantics"
+ "Completing boundary more than once"
+ "ComputeBlockTableBucketSize(config_.meshing) >= (1u << cfg::kMinBucketsOrderOfMagnitude)"
+ "ComputeMeshState is not supported by OccupancyMappedStateProvider"
+ "ComputeMeshStates is not supported by OccupancyMappedStateProvider"
+ "ComputeOccupancyState is not supported by MappedStateProvider"
+ "Confidence buffer not valid"
+ "Confidences and Vertices size do not match."
+ "Config is NULL"
+ "ConfusedSemanticsRatio"
+ "Contains(key)"
+ "ContentUpdates"
+ "Context may not be nullptr"
+ "Converting nan value to voxel position"
+ "Corner edge index out of bounds"
+ "Corner node index out of bounds"
+ "Could not find a polygon segment to the right of ray_start"
+ "Could not find containing polygon for inner ring"
+ "Could not rasterize mesh"
+ "Cpu rendering only supports CullMode::None now"
+ "Current keyframe ID should be in db_"
+ "Deallocating unknown block"
+ "Deintegrated %lu observation blocks"
+ "Deintegrating keyframe %s\n"
+ "Deintegrating keyframe %s - nothing to do\n"
+ "Deleted keyframe"
+ "Depth buffer not valid"
+ "Depth size is too small"
+ "Destination FPFH features and semantics size must match."
+ "Destination path is not absolute."
+ "Disk access unavailable, skipping saving snapshot: %s"
+ "Do not support meshing."
+ "Do not support volumetric mapper"
+ "Edge ID exceeds limit"
+ "Edge and node counts do not match"
+ "Edge and node counts must match"
+ "Edge end node not found"
+ "Edge index out of bounds"
+ "Edge start node not found"
+ "Edges from erased node not found"
+ "Edges from neighbor node not found"
+ "Edges from node not found"
+ "Edges from remaining node not found"
+ "Either confidence or uncertainty has to be valid, but not both"
+ "Empty DispatchQueueWorkGroup name."
+ "Error adding 2D network."
+ "Error adding depth network."
+ "Error allocating a texture"
+ "Error building espresso plan."
+ "Error cloning IPersistenceFilesystem: %s"
+ "Error cloning disk pool to: "
+ "Error cloning metadata db to: "
+ "Error creating destination directory %s"
+ "Error creating espresso context."
+ "Error creating espresso plan."
+ "Error saving system plist: "
+ "Error saving user plist: "
+ "Error snapshotting keyframes to the given path."
+ "Error snapshotting planes to the given path."
+ "Even though it was requested to write warpingresults, the mask for the desired surfaces is 0(no desired surfaces)."
+ "Exceeded maximum number of planes allowed."
+ "Exception when padding size to bytes"
+ "Expect IOSurface backed pixel buffer"
+ "Expect aligned faces"
+ "Expect aligned vertices"
+ "Expect buffer for allocated image"
+ "Expect exactly one of confidence or uncertainty"
+ "Expect finite positive voxel size"
+ "Expect keyframe is tracked"
+ "Expect no buffer for unallocated image"
+ "Expect no repeated kfs in construction of possible publishing list"
+ "Expect no suggestion for eradicated proposals"
+ "Expect non null command buffer"
+ "Expect per face semantics"
+ "Expect per vertex confidences"
+ "Expect single render viewpoint in Monitor when making a depth based suggestion."
+ "Expect to have valid depth and semantics."
+ "Expect to have valid transformation."
+ "Expect valid current frame when updating"
+ "Expect valid scene type"
+ "Expect valid texture"
+ "Expected input frame for monitoring result creation"
+ "Expected meshing node"
+ "Expected ptr to have been allocated"
+ "Expected scaling requests with preserved aspect ratio"
+ "Expected to convert a CFDictionaryRef"
+ "Expected to have a valid chunk size"
+ "ExportImageData requires data to be ImageData"
+ "ExportMeshData requires data to be MeshData"
+ "External keyframe should not have valid data"
+ "FPFH Descriptor is NULL"
+ "FPFH match result is NULL"
+ "Failed to access 2D network file"
+ "Failed to access 3D network file"
+ "Failed to access network file"
+ "Failed to add appender to logger"
+ "Failed to apply Gaussian smoothing (x)"
+ "Failed to apply Gaussian smoothing (y)"
+ "Failed to configure per-frame mesh semantics output. Check that MeshingConfig.integrate_attribute has the attribute enabled."
+ "Failed to create pixel buffer"
+ "Failed to create pixel buffer for conversion of YUV to BGRA"
+ "Failed to create pixel buffer for image scaling"
+ "Failed to create workgroup."
+ "Failed to estimate %{private}s height room floor/ceiling"
+ "Failed to load file"
+ "Failed to remove keyframe from disk"
+ "Failed to remove keyframe from shared memory"
+ "Failed to serialize occupancy data"
+ "Failed to set workgroup flags."
+ "Failed to write plist to: "
+ "Failure snapshot done event handler."
+ "FailureSnapshot: Attempted uuid %s"
+ "FailureSnapshot: CacheThrottlingSuggestions"
+ "FailureSnapshot: CacheThrottlingSuggestions - not cached"
+ "FailureSnapshot: CacheThrottlingSuggestions fail: %s"
+ "FailureSnapshot: Changed throttling file update time"
+ "FailureSnapshot: Errors detected, but not collected as failure"
+ "FailureSnapshot: Failed to create root dir"
+ "FailureSnapshot: OnSnapshot fail: %s"
+ "FailureSnapshot: SD won't throttle; num dir entries %zu "
+ "FailureSnapshot: TF won't throttle; last shapshot %zu hours ago"
+ "FailureSnapshot: snapshotting failed %s"
+ "FailureSnapshot: snapshotting failed: %s"
+ "File"
+ "File system access granted event handler."
+ "Filesystem doesn't support caching"
+ "FilesystemAccess granted"
+ "First dimension must not have paddings for the efficiency."
+ "First split node not found"
+ "FloorCeilingDeleted"
+ "FloorJump"
+ "FlushPendingKeyframes"
+ "For meshes with zero faces, vertices should be also zero and vice versa"
+ "Format is not serializable. Must be a non-dynamic format."
+ "Frame bundle is NULL"
+ "FrameBundleCamera"
+ "Function should contain valid target"
+ "FuseRawframeToKeyframe_"
+ "FuseRawframeToKeyframe_All"
+ "FuseRawframeToKeyframe_Base"
+ "FuseRawframeToKeyframe_Color"
+ "FuseRawframeToKeyframe_ColorAndMaterials"
+ "FuseRawframeToKeyframe_ColorAndSemantics"
+ "FuseRawframeToKeyframe_Materials"
+ "FuseRawframeToKeyframe_Semantics"
+ "FuseRawframeToKeyframe_SemanticsAndMaterials"
+ "GGRS: Adaptor keyframes are inconsistent with the CoordSystem/Adaptor: "
+ "GGRS: Coordinate update when reset volume, #kfs="
+ "GGRS: Invalid-UUID %lu/%lu  uuid: %s type: %s reason: %s"
+ "GGRS:%s Remove invalid KF %s"
+ "GPU capability check failed on non-virtual machine."
+ "Get a list of keyframes that are required by global reference system for remeshing."
+ "GetAllKeyframes should set err"
+ "Given data block is too big to be represented by uint32_t indexed ArrayView"
+ "Global anchor cannot be both in track and external"
+ "Global cluster does not exist"
+ "Global reference system flush pending update keyframes."
+ "Graph too small to process."
+ "Handles session wide pre and post-processing task."
+ "HasBundle<T>(bid)"
+ "IDE_DISABLED_OS_ACTIVITY_DT_MODE"
+ "If received confirmation is requested there must be at least one algorithm"
+ "Image format mismatch"
+ "Image shape does not match"
+ "Image size is too small"
+ "Image size mismatch"
+ "Image sizes must match"
+ "Impossible!"
+ "Impossible."
+ "Incorrect buffer size"
+ "Index out of bounds"
+ "Input KeyframeBundle should be valid"
+ "Input Session is NULL"
+ "Input and output images are expected to be valid."
+ "Input and output size should match"
+ "Input array not evenly divisible by 3*sizeof(float)."
+ "Input array not evenly divisible by 4*sizeof(float)."
+ "Input array not evenly divisible by 5*sizeof(float)."
+ "Input extent type is NULL"
+ "Input filepath is NULL"
+ "Input frame data should have valid depth and confidence frame!"
+ "Input image should not be empty"
+ "Input log dictionary is NULL"
+ "Input point clouds must have the same size"
+ "Input stateful logger pointer is NULL"
+ "InputDepth is NULL"
+ "InputWeight is NULL"
+ "Integrate and mapping attributes are not compatible"
+ "Integrate and perframe attributes are not compatible"
+ "Integrated %i occupied voxels into %lu blocks (%i total contributing points, %i voxels visited multiple times)"
+ "Integrated %i occupied voxels into %lu blocks used %i block lookups (%i total contributing points, %i voxels visited multiple times)"
+ "Integrated frames file cannot be created %s"
+ "Integrated free space (%i blocks tested, %i blocks had some free voxels)"
+ "Integrated kf should be in shared memory"
+ "Integrating depth points for %s\n"
+ "Integrating free space for %s\n"
+ "Integrating keyframe %s\n"
+ "Integration for planes requires validity of snapper and bundle."
+ "IntegrationCandidates"
+ "Invalid AE(%s)"
+ "Invalid Axis value"
+ "Invalid Petal device"
+ "Invalid SU semantic label."
+ "Invalid block index"
+ "Invalid block index for an occupied block"
+ "Invalid block neighborhood information"
+ "Invalid block position."
+ "Invalid block resolution."
+ "Invalid block size"
+ "Invalid boundary index."
+ "Invalid cache type"
+ "Invalid cache_neighbors size."
+ "Invalid cache_num_neighbors size."
+ "Invalid cache_weights size."
+ "Invalid chunk size"
+ "Invalid component"
+ "Invalid destination buffer!"
+ "Invalid device"
+ "Invalid event"
+ "Invalid flag index for an occupied block"
+ "Invalid floor index."
+ "Invalid front buffer!"
+ "Invalid fusion mask"
+ "Invalid grid index"
+ "Invalid grid position"
+ "Invalid index"
+ "Invalid info index"
+ "Invalid input keyframe"
+ "Invalid input keyframe pointer."
+ "Invalid interior polygon index."
+ "Invalid key"
+ "Invalid keyframe"
+ "Invalid map index"
+ "Invalid mapper"
+ "Invalid mask index"
+ "Invalid maximum depth."
+ "Invalid mesh"
+ "Invalid occupancy mapper"
+ "Invalid output keyframe pointer."
+ "Invalid persistence path"
+ "Invalid pixel mask not valid"
+ "Invalid point index."
+ "Invalid scale (either 0 or too large)"
+ "Invalid scale factor!"
+ "Invalid scene type height"
+ "Invalid scene type probability image"
+ "Invalid scene type width"
+ "Invalid segment index."
+ "Invalid source material label."
+ "Invalid target keyframe"
+ "Invalid target material label."
+ "Invalid update state"
+ "Invalid voxel size"
+ "Invalid voxel size."
+ "Invalid warped surface pointer"
+ "Invalid warped surface!"
+ "Invalid weight value"
+ "Invalidate keyframe callback required"
+ "Invalidated color of %i Keyframes"
+ "IsAligned(mesh_.faces.data(), kPageSize)"
+ "IsAligned(mesh_.semantics.data(), kPageSize)"
+ "IsAligned(mesh_.vertices.data(), kPageSize)"
+ "IsCpuPtr(ptr)"
+ "IsGlobalAnchorExternal(tracking_status_curr)"
+ "IsGlobalAnchorInTrack(tracking_status_curr)"
+ "IsGpuPtr(ptr)"
+ "IsOccupancySupported()"
+ "IsValid(input_ptr)"
+ "IsValid(input_ptr) && IsGpuPtr(input_ptr)"
+ "IsValid(output->surface) && IsGpuPtr(output->surface)"
+ "IsValid(ptr)"
+ "IsValid(target->surface)"
+ "IsValidEvent(cur_ev)"
+ "IsValidEvent(event)"
+ "IsValidEvent(in_ev)"
+ "It is mandated that all errors are handled and enforced by a processor. Add an error handler with AddErrorHandler()"
+ "KF "
+ "KFE:PUpdate:t:%f, RA:%zu, AN:%lu, AU:%lu, AE:%lu, AR:%lu, NU:%u, NRL:%u, NE:%u, NR:%u, NA:%zu, UAU:%u, TAU:%u, UuAU:%u, UAE:%u, IAE:%u, UAR:%u"
+ "KFE:Save"
+ "Kernel not found for input mask"
+ "Kernel size should be an odd number"
+ "Key already in the Pool"
+ "Keyframe cache missed KFE %s"
+ "Keyframe cannot be retrieved: %s with state: %s"
+ "Keyframe found in cache %s, input state: %s, cached state: %s"
+ "Keyframe in KeyframeBundleList: %s -> %i (%s)"
+ "Keyframe is NULL"
+ "Keyframe is empty"
+ "Keyframe is not found in any cluster"
+ "Keyframe list is NULL"
+ "Keyframe must have valid confidence"
+ "Keyframe must have valid depth"
+ "Keyframe must have valid normals"
+ "Keyframe not found"
+ "Keyframe should be valid in the cache"
+ "Keyframe should be valid, update the logic above"
+ "Keyframe was not scaled to match expected size"
+ "KeyframeBundle sizes don't match"
+ "KeyframeInfoExists(keyframe_data.uuid)"
+ "KeyframeInfoExists(uuid)"
+ "KeyframePlanes.GT"
+ "KeyframePlanes.GT.CreationTimestamp"
+ "KeyframePlanes.GT.KeyframeColor"
+ "KeyframePlanes.GT.KeyframeDepth"
+ "KeyframePlanes.GT.UpdatedKeyframeCamera"
+ "KeyframePlanes.GT.UpdatedKeyframeEquations"
+ "KeyframePlanes.GT.UpdatedKeyframeSegmentImage"
+ "KeyframePlanes.SingleShot.planes"
+ "KeyframePlanes.SingleShot.segmentation_mask"
+ "Keyframes should have unique uuids"
+ "Keyframing configuration is NULL"
+ "Keyframing.SurfaceWarpFuser.FuseRawframeToKeyframe"
+ "Local position has positive coordinates"
+ "Logged best floor dictionary contains an invalid device pose"
+ "Logged best floor dictionary contains an invalid plane pose"
+ "Logged best floor dictionary does not contain a device pose"
+ "Logged best floor dictionary does not contain a timestamp"
+ "Logged best floor dictionary does not contain is_cached"
+ "Logging handle is NULL"
+ "Lux"
+ "MTLDevice is NULL"
+ "Mapper already exist"
+ "Match index must be < match_size"
+ "Material buffer not valid"
+ "Materials"
+ "Maximum boundary size exceeded: %d"
+ "Maximum number of keyframes limit is too small or safety buffer size is too high."
+ "Merged edge index out of bounds"
+ "Merged node index out of bounds"
+ "Mesh is NULL"
+ "Mesh list is NULL"
+ "MeshDepthDifferent"
+ "MeshList can not contain null pointers!"
+ "Meshing configuration is NULL"
+ "Meshing is not supported"
+ "MeshingEngine.Volumetric.Chunks"
+ "MeshingResult has no RoomScanLite output"
+ "MeshingResult has no SyntheticRoomScanLite output"
+ "MeshingResult has no occupancy air mesh output"
+ "MeshingResult has no occupancy by proximity output"
+ "MeshingResult has no spatial subdivision output"
+ "MeshingResult has no visibility map output"
+ "Metadata database has already been loaded"
+ "MirrorCorrection projected behind user"
+ "MirrorCorrection ray did not intersect"
+ "Missing Volumetric mapper"
+ "Monitoring configuration is NULL"
+ "MonitoringResult is NULL"
+ "MonoDepth is only supported in CPU pipeline"
+ "More than 1 incoming edge to a node on shortest path"
+ "Must be an edge owned by a neighbor"
+ "NVS network on gpu is not implemented"
+ "NVS requires width multiple of 4"
+ "Neighbor node not found"
+ "Next corner edge index out of bounds"
+ "Next corner node index out of bounds"
+ "No PCM mapper config"
+ "No content updates expected from KeyframingEngine in Monitor mode"
+ "No integration blocks for the frame"
+ "No meshing config!"
+ "No points in block to compute mean"
+ "No render depth for rawframe"
+ "No timestamp as no KF result; skipping CA"
+ "No uncertainty data from rawframe"
+ "Node index out of bounds"
+ "Node not found"
+ "Non-graph external"
+ "Normals buffer not valid"
+ "Not a legitimate current event"
+ "Not a legitimate event"
+ "Not a legitimate in event"
+ "Not yet supported type-"
+ "Number of auxiliary frame mismatch"
+ "Number of auxiliary frames mismatch"
+ "Number of bins mismatch"
+ "Number of image channels and 3 mismatch."
+ "Number of keys must match number of values"
+ "Number of neighbors must be >= 2"
+ "Number of output channels and 3 mismatch."
+ "OSLogAppender"
+ "OS_ACTIVITY_DT_MODE"
+ "ObservationGraph"
+ "ObservationMapping-%i-%i.KF-%s.%s-%s"
+ "ObservationMapping-%i-%i.Res.Free"
+ "ObservationMapping-%i-%i.Res.Mesh"
+ "ObservationMapping-%i-%i.Res.Occupied"
+ "ObservationMapping-%i-%i.Res.Points"
+ "Observed KF plane %.13s not linked to KF segmentation %.13s"
+ "Occuancy is enabled, but not yet support cluster-recon."
+ "Occupancy air mesh must be enabled to extract occupancy air mesh."
+ "Occupancy by proximity result too big for serialization"
+ "OccupancyAirMeshResult is NULL"
+ "OccupancyByProximityResult is NULL"
+ "OccupancyMirrorCorrection"
+ "Only attributes present in the fusion mask can be written to warping resultPlease update the warping mask accordingly!"
+ "Only coarse granularity volume queries are supported."
+ "Only for volumetric mapper"
+ "Only medium and coarse granularity point queries are supported."
+ "Only semantic or material attributes are supported."
+ "Out of range"
+ "Output image size does not match input image"
+ "Output image size is not valid"
+ "OverlappingKeyframes"
+ "POR should use CVBuffer"
+ "PRR ground mesh user chunk contained a suspicious height estimate "
+ "PRR ground mesh user chunk did not contain a height estimate, using "
+ "Persistence data cannot be loaded if persistence is not set up and enabled"
+ "Persistence not enabled, so snapshot is not possible."
+ "Persistence storage path not set up, data path unavailable"
+ "Persistence storage path not set up, metadata path unavailable"
+ "Pixel format is invalid"
+ "Pixel type does not match required 444f format."
+ "Plane convex hull representation is missing."
+ "Plane detection configuration is NULL"
+ "Plane grid representation is missing."
+ "Plane snapper is null"
+ "PointCloud is NULL"
+ "Polygon must have at least three vertices."
+ "Post-processes FrameBundleResult."
+ "Postprocess FrameBundleResult"
+ "PredictedDepth is NULL"
+ "Preprocessing cannot fail"
+ "Preset is not supported!"
+ "ProcessKeyframeContentUpdates: KF %.13s not valid"
+ "Processed depth buffer not valid"
+ "Processed semantic buffer not valid"
+ "Provided depthmap must have the same dimension with input camera."
+ "Ptr to JasperClouds expected non-null in KF bundle"
+ "Ptr to occupied voxel blocks expected non-null"
+ "Query is NULL"
+ "Queue size after filling cache: %u"
+ "Raster depth should not be empty"
+ "Raster normal should not be empty"
+ "Raster semantics should not be empty"
+ "Rasterized depth buffer not valid"
+ "Raw frame mesh depth not found!"
+ "Raw frame unavailable"
+ "Received a monitoring result from keyframing when not set up to."
+ "Received an invalid (composite) update state as input."
+ "Received update for invalid pose"
+ "Recon-CoreAnalyticsQueue"
+ "RelativePositionIsValid(pos)"
+ "RelativePositionToIndex(relative_pos) == index"
+ "Remove anchor block not valid"
+ "Request all anchors block not valid"
+ "Requested NVS requires width multiple of 4"
+ "Requested color texture is not valid"
+ "Requested confidence type is not valid"
+ "Requesting KF Id %s from Database when it doesn't exist."
+ "Result has no keyframing output"
+ "Result has no meshing output"
+ "Result has no monitoring output"
+ "Result is NULL"
+ "RoomHeight"
+ "RoomScanLiteResult is NULL"
+ "SDF configuration is NULL"
+ "SLAM Mode is out of range"
+ "SLAM metadata is NULL"
+ "Scene Indoor Outdoor type label not available"
+ "Scene type buffer not valid"
+ "Scene type probability buffer not valid"
+ "Search radius must be > 0"
+ "Second split node not found"
+ "Semantic buffer not valid"
+ "Semantic confidence buffer not valid"
+ "Semantics"
+ "Semantics must be assigned for every polygon extents."
+ "Semantics-only integration should not have level"
+ "SemanticsAndMaterials"
+ "Serialized size doesn't match expected size"
+ "Session configuration is NULL"
+ "Session doesn't have keyframing capability"
+ "Session doesn't have meshing capability"
+ "Session doesn't have occupancy by proximity capability"
+ "Session doesn't have occupancy-mapping capability"
+ "Session is NULL"
+ "Shared memory not allocated"
+ "Shared session node"
+ "SharedSessionNode "
+ "Should be able to find it."
+ "Should not process a raw frame when SLAM is bad"
+ "Should provide color images"
+ "Should provide depth and normals images"
+ "Should provide material images"
+ "Should provide semantic images"
+ "Should provide valid depth or color"
+ "Size mismatch"
+ "Size() == frame.Size()"
+ "Size() == output.Size()"
+ "Size(samples) == 2"
+ "Slam metadata is NULL"
+ "Snapshots"
+ "Source FPFH features and semantics size must match."
+ "SpatialSubdivisionResult is NULL"
+ "Stack size can't be more than 32"
+ "Stats.Errors"
+ "Stats.FrameBundle.AnalyticsMetadata"
+ "Stats.FrameBundle.AnalyticsMetadata.TopKPairs"
+ "Stats.Keyframing.cache"
+ "Stats.MirrorCorrection.Frame.MirrorCount"
+ "Stats.MirrorCorrection.Frame.PixelCount"
+ "Stats.PRR.SpatialSubdivision"
+ "Stats.PRR.UserOutOfBounds"
+ "Stats.TelemetryMeasurements"
+ "Stats.Volumetric.Cluster.MeshBacklogger_"
+ "Stats.Volumetric.Cluster.result-"
+ "Stats.Volumetric.KeyframingAdaptorCache_"
+ "Stats.Volumetric.KeyframingAdaptor_"
+ "Stride must be >0"
+ "Support at most 254 holes."
+ "Synthesized results (%i blocks allocated after synthesis)"
+ "Synthesizing results for %lu blocks (%i blocks allocated)"
+ "Table size too small!"
+ "Takes a snapshot with all keyframes and their metadata, and copies it to the given directory."
+ "Texture and image size don't match"
+ "Texture and image stride don't match"
+ "Texture coordinates not supported"
+ "Texture faces not supported"
+ "The attributes enabled in `integrate_attribute_mask` should also be enabled in SessionConfig.common.mapping.attribute_mask"
+ "The block is erased"
+ "The block should not be in erased state"
+ "The mesh can only contain PerFace materials."
+ "The mesh can only contain PerFace semantics."
+ "The mesh can only contain PerVertex confidences."
+ "The mesh cannot contain colors."
+ "The mesh cannot contain edges."
+ "The mesh cannot contain normals."
+ "The mesh cannot contain tex_coords."
+ "The mesh cannot contain tex_faces."
+ "The mesh must contain per-face confidences"
+ "The mesh must contain per-face materials"
+ "The mesh must contain per-face semantics"
+ "The mesh must contain per-vertex confidences"
+ "The mesh must contain per-vertex normals"
+ "The mesh must have either no or per vertex normals"
+ "The number of 2D points and 3D points must be matched."
+ "The number of colors is non-zero and different from the number of vertices."
+ "The number of labels is non-zero and different from the number of faces."
+ "The number of materials is non-zero and different from the number of faces."
+ "The number of normals is non-zero and different from the number of vertices."
+ "The number of vertices is different from the number of per vertex tags."
+ "The result should be defined"
+ "This function assumes the keyframe is in memory"
+ "TimeFirstFloor"
+ "Timed out on synchronous read for file %s"
+ "Timed out while reading %s"
+ "Timestamp mismatch"
+ "Too many keyframes in memory"
+ "Too many votes for the chosen vote count type causes an overflow."
+ "Tracked keyframe cannot be empty."
+ "Tracked plane has more visible leaf cells to handle"
+ "Trajectory file cannot be created"
+ "Trivial AU(%s)%s"
+ "Trying to erase empty range"
+ "Two events cannot coexist"
+ "UUID is NULL"
+ "Unable to create data storage directory"
+ "Uncertainty buffer not valid"
+ "Uncertainty image should be present to generate confidence image!"
+ "Unexpected keyframe update state during strobing"
+ "Unexpected snapshot without root path set"
+ "Unknown AE(%s)"
+ "Unknown AR(%s)"
+ "Unknown AU(%s)"
+ "Unknown Attributes"
+ "Unknown block index"
+ "Unknown error while saving snapshot"
+ "Unknown info index"
+ "Unknown mapping attribute"
+ "Unknown mask index"
+ "Unsupported component"
+ "Unusable AU(%s)"
+ "UnwrapPose: Received a dictionary that does not contain a translation vector"
+ "UnwrapPose: Received an invalid translation vector"
+ "Update only in pending or droppable"
+ "Updated %lu voxel blocks (allocated blocks after update: %i)"
+ "Updated list of keyframes must be valid"
+ "VLM: Dump cached %lu chunks"
+ "VLM:GCRS CID:%s TS:%d MS:%d ToT:%lu UK:%lu PK:%lu M2V:(%3.3f, %3.3f, %3.3f,%3.3f, %3.3f, %3.3f)"
+ "VLM:GGRS TS:%i RK:%lu IK:%lu AP:%lu TP:%lu ToT: %lu"
+ "VLM:GGRSMD %s"
+ "VLM:KF:t:%f HA:%i RA:%i VB:%lu CH:%lu GCH:%lu RCY:%u CHE:%lu CHH:%d CHR:%d VX:%lu"
+ "VLM:KVA NC:%zu P:%zu LC:%zu EX:%zu D:%zu R:%d TP:%zu AP:%zu"
+ "VLM:MBL Flush %zu pending keyframes"
+ "VLM:MBL-%s CO:%llu CR: %llu PM:%llu EM:%llu"
+ "VLM:ME UPC:%d UPV:%d UPF:%d RMC:%d"
+ "Values exceed permitted range"
+ "Visibility map is NULL"
+ "Volumetric"
+ "Volumetric Mapper is not supported"
+ "Voxel size must be > 0"
+ "[%i %i %i]"
+ "[KeyframeBundleList] frames"
+ "[KeyframeBundleList] input_frame"
+ "[KeyframeBundleList] monitoring_mode"
+ "[KeyframeBundleList] pending_updates"
+ "_f"
+ "active_depth_dt size mismatch"
+ "active_depth_dt.Size() == size"
+ "add_callback"
+ "allocated_vertex_count >= chunk_mesh.vertices.size()"
+ "alpha value should within range [0, 1]"
+ "at least 3 point pairs are required"
+ "attr_metadata_type == kmesh::TriMeshMetadataType::PerVertex"
+ "attribute == MappingAttribute::Semantic || attribute == MappingAttribute::Material"
+ "aux_depth_2d.Shape() == image_shape"
+ "aux_mask_2d.Shape() == image_shape"
+ "batch_metadata->SupportsVolumetric() == keyvol_config.SupportsVolumetric()"
+ "batch_metadata.TimeMatch(keyframe_list) && !batch_metadata.volumetric.has_value()"
+ "batch_metadata.TimeMatch(keyframe_list) && SupportsVolumetric(config_, batch_metadata)"
+ "batch_size > 0"
+ "best_start_index != kUnset"
+ "bid == GetBaseBundleId<T>()"
+ "block_incoming_edges.count(target) == 1"
+ "block_index < allocated_voxel_blocks_.size()"
+ "block_index < allocated_voxel_masks_.size()"
+ "block_resolution > 0"
+ "boundary_index < result.edge_indices_.size()"
+ "boundary_index < result.nodes_.size()"
+ "boxes.size() < static_cast<size_t>(u16max)"
+ "brga_buffer_opt"
+ "brga_out_iosurface"
+ "buffer and tensor shape mismatch"
+ "buffer.length() == size[0] * size[1] * element_size"
+ "buffer_iosurface"
+ "buffer_no_copy"
+ "buffer_opt"
+ "bytes_per_row >= min_bytes_per_row"
+ "cache_neighbors.size() == cache_num_neighbors.size()"
+ "cache_neighbors.size() == cache_weights.size()"
+ "cache_neighbors.size() >= num_descriptors"
+ "callable != nullptr"
+ "camera->ImageSize() == camera_in.ImageSize()"
+ "camera.ImageSize() == depth_image.Size()"
+ "camera.ImageSize() == normals.Size()"
+ "camera.ImageWidth() % 4 == 0"
+ "camera_metadata"
+ "camera_ref.ImageWidth() == image.Shape(0) && camera_ref.ImageHeight() == image.Shape(1)"
+ "can't assign file content to non-empty directory "
+ "ceilingTotalRatio"
+ "chunk_mesh.confidences.size() == chunk_mesh.faces.size()"
+ "chunk_mesh.confidences.size() == chunk_mesh.vertices.size()"
+ "chunk_mesh.materials.size() == chunk_mesh.faces.size()"
+ "chunk_mesh.normals.size() == chunk_mesh.vertices.size()"
+ "chunk_mesh.semantics.size() == chunk_mesh.faces.size()"
+ "chunk_pos_iter != chunk_indices_.end()"
+ "chunk_size > 0"
+ "circular_queue"
+ "clouds"
+ "cluster_keyframe_list.input_frame->coord_transformer.has_value()"
+ "cluster_result_map.count(GlobalClusterId())"
+ "color1.Size() == color2.Size()"
+ "color_ref.Format() == kcv::PixelFormat::YpCbCr444BiplanarFullRange_8"
+ "color_texture"
+ "com.apple.Recon3D.recon.failures_v1"
+ "com.apple.Recon3D.recon.measurements_v1.30sec"
+ "com.apple.Recon3D.recon.snapshots_v1"
+ "com.apple.recon3d.extra.mirror_correction_flags"
+ "com.apple.recon3d.keyframing.creation.max_interframe_dist"
+ "com.apple.recon3d.keyframing.debug.keyframe_to_point_cloud_stride"
+ "com.apple.recon3d.keyframing.fusion.num_keyframes_integration"
+ "com.apple.recon3d.keyframing.memory.published_kf_cache_size"
+ "com.apple.recon3d.meshing.sdf_config.flattened_marching_cubes"
+ "com.apple.recon3d.session.allow_failure_snapshot"
+ "com.apple.recon3d.session.global_update_dt_seconds"
+ "com.apple.recon3d.session.polaris.unify_graphs"
+ "command_buffer.has_value()"
+ "common.persistence.allow_failure_snapshot"
+ "common.publish_global_update_dt_seconds"
+ "complete_histogram_s_.size() == histogram_length"
+ "component < CacheComponent::NumComponents"
+ "compute_pipeline_states_.count(kernel_name)"
+ "confidence_op.has_value() != uncertainty_op.has_value()"
+ "config.meshing->pcm_config.has_value()"
+ "config.meshing->sdf_config->coarse_voxel_threshold >= std::numeric_limits<float>::max()"
+ "config.meshing.has_value()"
+ "config.meshing.sdf_config->coarse_voxel_threshold >= std::numeric_limits<float>::max()"
+ "config.meshing.sdf_config.has_value()"
+ "config.plane_detection"
+ "config_.common.mapping.input_frame_size"
+ "config_.common.monitoring.output_per_frame_monitoring_result"
+ "config_.common.persistence.storage_path && config_.common.persistence.enabled"
+ "config_.material_label_to_switch_target >= PRRConfig::kInvalidMaterialLabel && config_.material_label_to_switch_target < static_cast<int32_t>(MaterialLabel::NumValidLabels)"
+ "config_.max_depth > 0.0f"
+ "config_.meshing.HasOccupancyAirMesh()"
+ "context"
+ "context != nullptr"
+ "coordinate_system_store_.at(cid) != nullptr"
+ "copyfile() call failed with code"
+ "count"
+ "ctx_ != NULL"
+ "current_frame"
+ "currently mesh cannot contain texture coordinates"
+ "currently mesh cannot contain texture faces"
+ "cv3d.recon.kf_pers"
+ "cv3d.recon.kfplanes_pers"
+ "cv3d.recon.vlm_sb"
+ "cv3d.recon3d"
+ "data or footprint is missing"
+ "data.keyframe && !data.keyframe->IsValid()"
+ "data.keyframe && data.keyframe->IsValid()"
+ "data_corrupted"
+ "depth and camera image size must match"
+ "depth and normal size must match"
+ "depth.Size() == camera.ImageSize()"
+ "depth.Size() == normal.Size()"
+ "depth_view.Size() == Size()"
+ "depth_view_size[0] == size_[0] && depth_view_size[1] == size_[1]"
+ "destination_surface.IsValid()"
+ "device_"
+ "device_pose"
+ "did coordinate update"
+ "did_sink_task_skip_large_updates"
+ "did_sink_task_skip_many_updates"
+ "did_sink_task_skip_update"
+ "directory_created"
+ "dispatch_group_wait failed"
+ "dot_product > -0.9"
+ "duration_of_last_indoor"
+ "duration_of_last_out_of_bounds"
+ "duration_of_last_outdoor"
+ "duration_of_mesh_depth_novel"
+ "edge1 out of bounds"
+ "edge2 out of bounds"
+ "edge_id < mesh.edges.size()"
+ "edge_owner != 0"
+ "edges from node not found"
+ "edges_.size() > index1"
+ "edges_.size() > index2"
+ "edges_from_node.count(erased_node_pos) == 1"
+ "edges_from_node.count(neighbor_pos) == 1"
+ "edges_from_node.count(node.position) == 1"
+ "edges_from_node.count(remaining_node_pos) == 1"
+ "edges_from_node_.count(node_position) == 1"
+ "err"
+ "error == 0"
+ "event != KeyVolEventInvalid"
+ "exists"
+ "expect initialized."
+ "face_labels.size() == mesh.faces.size()"
+ "face_state should be the same size as mesh.faces"
+ "failed to assign file content to "
+ "failed to convert CFUUIDRef to random::UUID"
+ "failed to create parent directory "
+ "failure_type"
+ "failure_user_category"
+ "fb.Depth() && fb.Confidence()"
+ "fb.Uncertainty().has_value()"
+ "fb.depth.depth.has_value() && fb.semantic.labels.has_value()"
+ "flags.size() == data.echos.size()"
+ "floorReplaceRatio"
+ "floorTotalRatio"
+ "floor_jump_timestamp"
+ "for meshes with texture coords, mesh's #tex_faces must be equal to #faces"
+ "for meshes without texture coords, mesh's #tex_faces must be zero"
+ "format != img::Format::Dynamic"
+ "fpfhs_dst.size() == semantics_dst.size()"
+ "fpfhs_src.size() == semantics_src.size()"
+ "frame"
+ "frame.ProcessedSemantic().has_value() && frame.ProcessedSemantic().has_value()"
+ "frame.SceneTypeProbability()"
+ "frame::IsValidKeyframeUpdateState(kf.update_state)"
+ "frame_data.Depth() && frame_data.Confidence()"
+ "fs::exists(base_path, fs_)"
+ "general__device_orientation__mean"
+ "general__device_worn__mean"
+ "general__lux_level__mean"
+ "general__num_error_logs__sum"
+ "general__scene_type__latest"
+ "general__sink_task_skip_large_updates__count"
+ "general__sink_task_skip_many_updates__count"
+ "general__sink_task_skip_updates__count"
+ "general__user_motion__sum"
+ "get_serialized_size() == size_in_bytes"
+ "global_chunk_mesh_table_ != nullptr"
+ "granularity_hint != OccupancyGranularity::Fine"
+ "granularity_hint == OccupancyGranularity::Coarse"
+ "histogram_[label] < std::numeric_limits<CountType>::max()"
+ "hit"
+ "id_iter != parent_plane_id_.end()"
+ "idx[0] >= 0 && idx[1] >= 0 && idx[0] < regions_buffer_.Width() && idx[1] < regions_buffer_.Height()"
+ "idx_block < metadata_blocks_.size()"
+ "image.ValueStride(0) == 1 && output.ValueStride(0) == 1 && confidences.ValueStride(0) == 1"
+ "image_data_ptr"
+ "img_size_ == camera.ImageSize()"
+ "index < edge_indices_.size()"
+ "index < mesh_buffers_.size()"
+ "index < metadata_blocks_.size()"
+ "index < nodes_.size()"
+ "index < num_elements_"
+ "index < plane_count_"
+ "index < valid_occupied_blocks"
+ "index < voxel_block.size()"
+ "index <= used_buffer_flags_.size()"
+ "index == cell_index"
+ "index out of range"
+ "index1 != index2"
+ "info_index < allocated_voxel_block_infos_.size()"
+ "initialized_"
+ "inner_ring_assignments[inner_i] != kUnassigned"
+ "input images should have the same size"
+ "input_ptr->IsValid()"
+ "integrator_map_.map_bundle_to_cluster.count(bid) == 0"
+ "inv_voxel_size_ > 0 && !std::isinf(inv_voxel_size_)"
+ "invalidate_keyframe_cb_"
+ "is_cached"
+ "is_flag(in)"
+ "is_region(inner)"
+ "it->second < mesh_buffers_.size()"
+ "it->second->ImageFormat() == format"
+ "it->second->ImageSize() == size"
+ "iter != batch_metadata.volumetric->kf_to_mesh_rendering.end()"
+ "iter != integrator_map_.map_cluster_to_bundles.end()"
+ "iter != kf_block_indices.end()"
+ "iter != parent_plane_id_.end()"
+ "iter != rankings.end()"
+ "iter != raster_buffer.end()"
+ "iter == voxels_and_indices.end()"
+ "iter == voxels_and_indices_.end()"
+ "iter_src != default_confusion_table.end()"
+ "iw % 4 == 0"
+ "kLevel < kNumMeshLevels - 1"
+ "kMaxRegions exceeded"
+ "k_num_aux == rgb_aux.size()"
+ "kern.hv_vmm_present"
+ "keyframe__num_data_corrupted__latest"
+ "keyframe__num_metadata_corrupted__latest"
+ "keyframe_db"
+ "keyframe_engine_result.global_reference_system_result.has_value()"
+ "keyframe_map_.count(kfid)"
+ "keyframe_ptr != nullptr"
+ "keyframe_result_future.valid()"
+ "keyframing->creation.max_interframe_dist"
+ "keyframing->debug.keyframe_to_point_cloud_stride"
+ "keyframing->fusion.num_keyframes_integration"
+ "keyframing->memory.published_kf_cache_size"
+ "keys.size() == values.size()"
+ "kf"
+ "kf->second.keyframe && kf->second.keyframe->IsValid()"
+ "kf.IsUsable()"
+ "kf.UpdateState() == frame::KeyframeUpdateStateContentUpdated || kf.UpdateState() == frame::KeyframeUpdateStateNoUpdate"
+ "kf_data.keyframe != nullptr"
+ "kf_database.Contains(current_id)"
+ "kf_integration_blocks.count(kvi::RawframeId()) != 0"
+ "kf_to_mesh_rendering.count(uuid)"
+ "kf_to_mesh_rendering.count(uuid) == 0"
+ "kfp__floor_jump__count"
+ "kfp__removed_floor_ceiling__count"
+ "kfp__time_delay_first_floor_plane__first"
+ "kfp__time_to_first_global_floor_plane__first"
+ "label < kNumMaterialLabels"
+ "latest_cluster_result_.has_value()"
+ "latest_frame_bundle_.timestamp == timestamp"
+ "lidar_image"
+ "linear_rgba_iosurface"
+ "load_factor <= kMaxLoad"
+ "loader must specify the format to load as"
+ "local_subblock_pos[0] >= 0 && local_subblock_pos[1] >= 0 && local_subblock_pos[2] >= 0"
+ "locations.size() == mesh.vertices.size()"
+ "m"
+ "mapper"
+ "mapper != nullptr"
+ "material histogram length not match with images size"
+ "materialIndex"
+ "material_view.Size() == Size()"
+ "math::IsFinite(point) && math::IsFinite(normal)"
+ "math::IsFinite(pos)"
+ "math::IsFinite(total_distance_sq) && \"Score is NaN\""
+ "math::IsFinite(voxel_size) && voxel_size > 0"
+ "math::IsOdd(kernel_size)"
+ "math::IsPowerOfTwo(block_size_)"
+ "math::IsPowerOfTwo(chunk_size_)"
+ "max_depth > 0.f"
+ "max_depth should be positive."
+ "max_weight > 0. && max_weight <= static_cast<double>(std::numeric_limits<SDFConfig::VoxelWeightType>::max())"
+ "maybe_format"
+ "memory_size > 0"
+ "mesh"
+ "mesh must either lack any colors, or have one color per vertex"
+ "mesh must either lack any normals, or have one normal per vertex"
+ "mesh's #colors must be either zero or equal to #vertices"
+ "mesh.confidences.size() == mesh.vertices.size()"
+ "mesh.edges.empty()"
+ "mesh.edges.size() > edge_id"
+ "mesh.faces and face_labels must be the same size"
+ "mesh.faces.size() == face_state.size()"
+ "mesh.tex_coords.empty()"
+ "mesh.tex_faces.empty()"
+ "mesh.vertices.size() == vertex_tag.size()"
+ "mesh_buffers_.size() == used_buffer_flags_.size()"
+ "mesh_data_ptr"
+ "mesh_ptr->confidences_type == kit::mesh::TriMeshMetadataType::PerVertex"
+ "mesh_ptr->faces.size() == mesh_ptr->semantics.size() && mesh_ptr->semantics_type == kit::mesh::TriMeshMetadataType::PerFace"
+ "mesh_uuid_it != parent_plane_id_to_mesh_id_.end()"
+ "meshes number and camera_pose number should be the same"
+ "meshes number and output_images number should be the same"
+ "meshes.size() == camera_from_world_vec.size()"
+ "meshes.size() == output_images.size()"
+ "meshing to vision"
+ "meshing->sdf_config->flattened_marching_cubes"
+ "meshing_node"
+ "metadata_corrupted"
+ "miss"
+ "monitoring__mesh_depth_different__count"
+ "monitoring__mesh_depth_different__duration__max"
+ "monorecon_resource_private/7r7uj7d8ph_510000/model.espresso.net"
+ "monorecon_resource_private/zmwu2uc7m2_10000/model.espresso.net"
+ "monorecon_resource_public/r5tuyggaps_540000/model.espresso.net"
+ "neighbor_cache_type_ != NeighborCache::Fifteen"
+ "net2d_path_opt"
+ "net3d_path_opt"
+ "net_path_opt"
+ "next_boundary_index < result.edge_indices_.size()"
+ "next_boundary_index < result.nodes_.size()"
+ "nodes.count(edge.from) == 1"
+ "nodes.count(edge.to) == 1"
+ "nodes.count(split_block_1) == 1"
+ "nodes.count(split_block_2) == 1"
+ "nodes.size() == edge_indices.size()"
+ "nodes_.count(neighbor_position) == 1"
+ "nodes_.count(node_position) == 1"
+ "normals.size() == locations.size()"
+ "novelty mask size mismatch"
+ "novelty_mask.Size() == size"
+ "num_aux == aux_to_world.size()"
+ "num_aux == camera_aux.size()"
+ "num_channels == kExpectedChannels"
+ "num_descriptors == normals.size()"
+ "num_descriptors == spfhs.size()"
+ "num_tracked_keyframes != 0"
+ "number of elements mismatch"
+ "number_depth_bin == depth_of_bins_.size()"
+ "obj export requires per-vertex colors"
+ "obj export requires per-vertex normals"
+ "obs.polygons.size() == obs.opSemantics->size()"
+ "occupied_blocks"
+ "occupied_blocks.has_value()"
+ "opt_internal_dict.has_value()"
+ "orientation"
+ "out of bounds"
+ "out_buffer_iosurface"
+ "out_channel == kExpectedChannels"
+ "out_iosurface"
+ "output_buffer.Shape() == buffer_shape"
+ "parent_plane_id_to_mesh_id_ should be consistent with plane_chunk_map_"
+ "pending keyframes"
+ "pending_buffer_accumulated"
+ "pending_buffer_temporary"
+ "pixel_iter == pixels_.end()"
+ "pixels_.size() == size_[0] * size_[1]"
+ "plane.convexHullExtent"
+ "plane.gridExtent"
+ "plane_cache_"
+ "plane_cache_ is not allocated."
+ "plane_count_ < kMaxNumPlanes"
+ "plane_detector_"
+ "plane_pose"
+ "plane_snapper_"
+ "plane_snapper_ && opt_frame_bundle->Depth() && opt_frame_bundle->Confidence()"
+ "planes_db"
+ "planes_result_future.valid()"
+ "pointcloud and spfhs size mismatch."
+ "points2d.size() == points3d.size()"
+ "points_.Count() > 0"
+ "points_.size() < points_.capacity()"
+ "polaris_config.unify_graphs"
+ "polygon.size() >= 3"
+ "polygons.size() <= static_cast<size_t>(std::numeric_limits<uint8_t>::max())"
+ "pose_update (ms)"
+ "pose_updates.size() >= GGRS::kMinimumGraphSizeForGlobalPoseEstimation"
+ "poses and depths size do not match"
+ "poses and normals size do not match"
+ "poses and semantics size do not match"
+ "position[0] % static_cast<int32_t>(stride_) == 0 && position[1] % static_cast<int32_t>(stride_) == 0 && position[2] % static_cast<int32_t>(stride_) == 0"
+ "possible_publish_set.size() == possible_publish_list.size()"
+ "predicted"
+ "priv().initialized_root_appenders_ == current_root_appenders"
+ "ptr"
+ "raster_depths.size() == 1u"
+ "raster_depths_.back() && (!raster_depths_.back()->Empty())"
+ "rasterizationResult.has_value()"
+ "ratio"
+ "ray_angle_2d.Shape() == image_shape"
+ "recon_didSinkTaskSkipLargeUpdates"
+ "recon_didSinkTaskSkipManyUpdates"
+ "recon_didSinkTaskSkipUpdates"
+ "remesh_it != plane_needs_remesh_.end()"
+ "remove_callback"
+ "render_targets[i].Buffer()"
+ "request.attributes == static_cast<MappingAttribute>(0u)"
+ "request_all_callback"
+ "res"
+ "result->input_frame.has_value()"
+ "result.IsDefined()"
+ "result.SaveToStream(ss)"
+ "result.edge_indices_.size() == result.nodes_.size()"
+ "result.keyframes_updated.empty()"
+ "result_meshlist"
+ "result_store_.count(cid)"
+ "ret == (adaptor != nullptr)"
+ "ret == 0"
+ "ring1 must be nonempty"
+ "ring1.size() > 0"
+ "ring2 must be nonempty"
+ "ring2.size() > 0"
+ "room height"
+ "root appenders have been illegally modified between Initialize() and Enable() of APILogging"
+ "root appenders have been illegally modified between Initialize() and EnableInternal() of APILogging"
+ "root appenders have been illegally modified between Initialize() and EnableInternalWithConfigurationFile() of APILogging"
+ "root_path_.has_value()"
+ "rsl__height__min"
+ "rsl__io_switch__count"
+ "rsl__out_of_bounds__count"
+ "rsl__out_of_bounds__duration__max"
+ "rsl__semantics_confusion__mean"
+ "scale_factor > 0.f"
+ "scale_factor > 0.f && scale_factor <= 1.f"
+ "scaled_image_iosurface"
+ "scene_type_block_height > 0"
+ "scene_type_block_height must be > 0"
+ "scene_type_block_width > 0"
+ "scene_type_block_width must be > 0"
+ "scene_type_ref.Shape()(0) == 1"
+ "scene_type_ref.Shape()(1) == 1"
+ "scheduler must be valid"
+ "sem_img.Size() == size"
+ "semantic histogram length not match with images size"
+ "semanticIndex"
+ "semanticMaterialPairTopK"
+ "semantic_view.Size() == Size()"
+ "semantic_view.Size() == material_view.Size()"
+ "semantic_view.Size()[0] == size_[0]"
+ "semantic_view.Size()[1] == size_[1]"
+ "semantics image and size mismatch"
+ "semantics.Size() == size"
+ "semantics_baseline size mismatch"
+ "semantics_baseline.Size() == size"
+ "si__ceiling_total_ratio__mean"
+ "si__floor_replace_ratio__mean"
+ "si__floor_total_ratio__mean"
+ "si__top_k_pairs_material_index__latest"
+ "si__top_k_pairs_ratio__latest"
+ "si__top_k_pairs_semantic_index__latest"
+ "si__wall_replace_ratio__mean"
+ "si__wall_total_ratio__mean"
+ "size_[0] > 0 && size_[1] > 0"
+ "size_without_padding <= size_in_bytes"
+ "source_ptr->Size() == target_ptr->Size()"
+ "space"
+ "src.size() == dst.size()"
+ "src.size() == weights->size()"
+ "src.size() >= 3"
+ "ss_config.meshing->HasMapper(MeshingMapperType::Volumetric)"
+ "ss_config.meshing.has_value()"
+ "states.cull_mode == petal::CullMode::None"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = 5U]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelOutput<cv3d::recon::sng::SessionPostprocessingResult>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelOutput<std::shared_future<bool>>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::kio::ProtocolInfoSample]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::recon::sng::SessionPostprocessingResult (const cv3d::recon::sng::ProcessFrameBundleResult &)]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::recon::sng::SessionPostprocessingResult]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = std::shared_future<bool> (const cv3d::recon::sng::KeyframePlaneSaveSnapshotToRequest &)]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = std::shared_future<bool> (const cv3d::recon::sng::KeyframeSaveSnapshotToRequest &)]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = std::shared_future<bool>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = std::vector<cv3d::recon::frame::KeyframeData> (const cv3d::recon::sng::FlushPendingUpdatedKeyframesGrefRequest &)]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = void (const cv3d::recon::sng::FailureSnapshotDoneRequest &)]"
+ "static_cast<uint32_t>(in_view.Height() * scale_factor) == out_view.Height()"
+ "storage_path"
+ "stride > 0"
+ "stride must be multiple of pixel size"
+ "stride must not overlap internally"
+ "system_data.plist"
+ "texture && (img.Width() == texture.width()) && (img.Height() == texture.height())"
+ "texture.width() == size[0] && texture.height() == size[1]"
+ "texture_"
+ "texture_out"
+ "texture_stride == image_stride"
+ "this->size() * kNumParameters * sizeof(float) == static_cast<size_t>(CFDataGetLength(data))"
+ "this->size() * kNumParameters * sizeof(float) == static_cast<size_t>(CFDataGetLength(points))"
+ "time_delay_floor"
+ "time_first_floor"
+ "top <= kMaxNodes"
+ "topKCount"
+ "total > 0"
+ "total_size < std::numeric_limits<uint32_t>::max()"
+ "total_weight > 0.f"
+ "tr_world_to_frame.has_value()"
+ "tracked_kfs_pose.size() >= GenericGlobalReferenceSystem::kMinimumGraphSizeForGlobalPoseEstimation"
+ "tracking_status.has_value()"
+ "trajectory_file"
+ "translation"
+ "trs_world_to_frame_.size() == raster_depths_.size()"
+ "trs_world_to_frame_.size() == raster_normals_.size()"
+ "trs_world_to_frame_.size() == raster_semantics_.size()"
+ "unexpected_state"
+ "unique_lock::lock: already locked"
+ "unique_lock::lock: references null mutex"
+ "unscaled_conf.Empty() ^ unscaled_uncertainty.Empty()"
+ "updated keyframes"
+ "updated_poses.size() == updated_uuids.size()"
+ "used_buffer_flags_[index] != 0"
+ "used_buffer_flags_[index] == 1"
+ "used_buffer_flags_[it->second] != 0"
+ "user_cb"
+ "user_data.plist"
+ "utils::CheckKeyframeResult(engine_result.keyframes_updated)"
+ "uuid_opt"
+ "verify_backlog(publishing_backlog_)"
+ "verteics.size() must be large than 2."
+ "vertices and normals size mismatch."
+ "vertices.size() > 2"
+ "vimage_err == kvImageNoError"
+ "volumetric"
+ "volumetric__num_kf_remesh__count"
+ "volumetric__semantics_confusion__mean"
+ "voxel_block_table.NeighborCacheType() == NeighborCache::Fifteen"
+ "voxel_mask != 0"
+ "voxel_size > 0.f"
+ "voxels_and_indices.size() == size[0] * size[1]"
+ "vt0 and vt1 should have been merged"
+ "wallReplaceRatio"
+ "wallTotalRatio"
+ "warped_surface"
+ "warped_surface_output != nullptr"
+ "warped_surfaces_mask"
+ "width == camera.width() && height == camera.height()"
+ "work_group_ != nullptr"
+ "worker"
+ "writeToURL:atomically:"
+ "{ KeyVolEventAnchorExternal }"
- " does not match the update state: "
- " num common OVB "
- " setting update state to "
- "!(d_erased ^ f_erased) && \"data or footprint is missing\""
- "!(is_pose_update && is_external) && \"Two events cannot coexist\""
- "!CV3D_TARGET_IS_PUBLIC && \"POR should use CVBuffer\""
- "!Contains(key) && \"Key already in the Pool\""
- "!ContainsKey(raster_buffer, out_rendering.get()) && \"Expect no buffer for unallocated image\""
- "!HasLoaded() && \"Metadata database has already been loaded\""
- "!ShouldEradicate() && \"Expect no suggestion for eradicated proposals\""
- "!VoxelBlockOctreeNode::IsUnknown(allocated_index) && \"Allocation failed\""
- "!VoxelBlockOctreeNode::IsUnknown(block_index) && \"Deallocating unknown block\""
- "!batch_metadata.volumetric.has_value() && \"Batch metadata should not have value\""
- "!candidate_cids.empty() && \"Keyframe is not found in any cluster\""
- "!cid.has_value() && \"Should not have cluster id.\""
- "!clients.empty() && \"If received confirmation is requested there must be at least one algorithm\""
- "!color.color->Empty() && \"Color buffer not valid\""
- "!confidence.Empty() && \"Keyframe must have valid confidence\""
- "!config_.compute_normals || raster_normals_.back() && (!raster_normals_.back()->Empty()) && \"Raster normal should not be empty\""
- "!config_.render_semantics || (raster_semantics_.back() && (!raster_semantics_.back()->Empty())) && \"Raster semantics should not be empty\""
- "!depth.Empty() && \"Keyframe must have valid depth\""
- "!depth.active_depth_mask->distance_transform.Empty() && \"Active depth mask buffer not valid\""
- "!depth.confidence->Empty() && \"Confidence buffer not valid\""
- "!depth.depth->Empty() && \"Depth buffer not valid\""
- "!depth.normals->Empty() && \"Normals buffer not valid\""
- "!depth.uncertainty->Empty() && \"Uncertainty buffer not valid\""
- "!derived.invalid_pixel_mask->Empty() && \"Invalid pixel mask not valid\""
- "!derived.processed_depth->Empty() && \"Processed depth buffer not valid\""
- "!derived.processed_semantics->Empty() && \"Processed semantic buffer not valid\""
- "!derived.raster_depth->Empty() && \"Rasterized depth buffer not valid\""
- "!error_downstream_.empty() && \"It is mandated that all errors are handled and enforced by a processor. \" \"Add an error handler with AddErrorHandler()\""
- "!image.Empty() && \"Input image should not be empty\""
- "!input.ColorRgba16f().Empty() && \"Should provide color images\""
- "!input.DepthConfidence().Empty() && !input.NormalRgba16f().Empty() && \"Should provide depth and normals images\""
- "!input.MaterialHistogram().Empty() && \"Should provide material images\""
- "!input.SemanticHistogram().Empty() && \"Should provide semantic images\""
- "!invalid_relocalize_update && \"Restored keyframes cannot exist when persistence is disabled\""
- "!is_tracked && \"Expect keyframe not in tracking\""
- "!keyframe_engine_result.jasper_clouds.has_value() && keyframe_engine_result.pending_updates.empty() && keyframe_engine_result.integration_candidates.empty() && !keyframe_engine_result.monitoring_result.has_value()"
- "!keyframe_list.frames.empty()"
- "!kf_config.nvs.use_nvs_network && \"NVS network on gpu is not implemented\""
- "!level.has_value() && \"Semantics-only integration should not have level\""
- "!materials_image->Empty() && \"Material buffer not valid\""
- "!metadata_block.IsErased() && \"The block should not be in erased state\""
- "!metadata_blocks_[idx_block].IsErased() && \"The block is erased\""
- "!metadata_blocks_[index].IsErased() && \"Cannot get an erased block\""
- "!metadata_blocks_[iter->second].IsErased() && \"The block is erased\""
- "!normals.Empty() && \"Keyframe must have valid normals\""
- "!recon::HasMappingAttribute(mask, MappingAttribute::JasperPoint) && \"Attribute not supported in per-frame meshing\""
- "!recon::HasMappingAttribute(mask, MappingAttribute::Normal) && \"Attribute not supported in per-frame meshing\""
- "!recon::HasMappingAttribute(mask, recon::MappingAttribute::JasperPoint) && \"Attribute not supported in per-frame meshing\""
- "!recon::HasMappingAttribute(mask, recon::MappingAttribute::Normal) && \"Attribute not supported in per-frame meshing\""
- "!scene_type.Empty() && \"Expect valid scene type\""
- "!scene_type.confidence->Empty() && \"Scene type probability buffer not valid\""
- "!scene_type.labels->Empty() && \"Scene type buffer not valid\""
- "!semantic.confidence->Empty() && \"Semantic confidence buffer not valid\""
- "!semantic.labels->Empty() && \"Semantic buffer not valid\""
- "!tracked_kfs.empty() && \"Tracked keyframe cannot be empty.\""
- "!update_for_invalid_pose && \"Received update for invalid pose\""
- "!vt1->IsOnAnyPlanes(*visible_planes) && \"vt0 and vt1 should have been merged\""
- "(!expected_frame_size_ || (expected_frame_size_ && *expected_frame_size_ != img::Size{})) && \"Expected size of input frame bundle is not valid\""
- "(!surface_conversion_params_.target_dimension || (scaled_kf->Camera().ImageSize() == *surface_conversion_params_.target_dimension)) && \"Keyframe was not scaled to match expected size\""
- "((integrate_attribute_mask & config.common.mapping.attribute_mask) == integrate_attribute_mask) && \"The attributes enabled in `integrate_attribute_mask` should also be enabled in \" \"SessionConfig.common.mapping.attribute_mask\""
- "(alpha >= 0.f && alpha <= 1.f) && \"alpha value should within range [0, 1]\""
- "(bytes_per_row % bytes_per_pixel == 0) && \"stride must be multiple of pixel size\""
- "(depth.Width() >= 1 && depth.Height() >= 1) && \"Depth size is too small\""
- "(frame.Depth().has_value() || frame.Color().has_value()) && \"Should provide valid depth or color\""
- "(input.IsValid() && output.IsValid()) && \"Input and output images are expected to be valid.\""
- "(keyframing_config.cpu_engine && keyframing_config.mono_depth.enable_mono_depth) && \"MonoDepth is only supported in CPU pipeline\""
- "(kf1.Width() == kf2.Width() && kf1.Height() == kf2.Height()) && \"Image sizes must match\""
- "(mesh.colors.empty() || mesh.colors.size() == mesh.vertices.size()) && \"The number of colors is non-zero and different from the number of vertices.\""
- "(mesh.colors.empty() || mesh.colors.size() == mesh.vertices.size()) && \"mesh must either lack any colors, or have one color per vertex\""
- "(mesh.colors.size() == 0 || mesh.colors.size() == mesh.vertices.size()) && \"mesh's #colors must be either zero or equal to #vertices\""
- "(mesh.colors_type == TriMeshMetadataType::PerVertex || mesh.colors_type == TriMeshMetadataType::Unknown) && \"obj export requires per-vertex colors\""
- "(mesh.confidences.empty() || (mesh.confidences_type == kit::mesh::TriMeshMetadataType::PerVertex && mesh.confidences.size() == mesh.vertices.size())) && \"The mesh can only contain PerVertex confidences.\""
- "(mesh.materials.empty() || (mesh.materials_type == kit::mesh::TriMeshMetadataType::PerFace && mesh.materials.size() == mesh.faces.size())) && \"The mesh can only contain PerFace materials.\""
- "(mesh.materials.empty() || mesh.materials.size() == mesh.faces.size()) && \"The number of materials is non-zero and different from the number of faces.\""
- "(mesh.normals.empty() || mesh.normals.size() == mesh.vertices.size()) && \"The number of normals is non-zero and different from the number of vertices.\""
- "(mesh.normals.empty() || mesh.normals.size() == mesh.vertices.size()) && \"mesh must either lack any normals, or have one normal per vertex\""
- "(mesh.normals_type == TriMeshMetadataType::PerVertex || mesh.normals_type == TriMeshMetadataType::Unknown) && \"obj export requires per-vertex normals\""
- "(mesh.semantics.empty() || (mesh.semantics_type == kit::mesh::TriMeshMetadataType::PerFace && mesh.semantics.size() == mesh.faces.size())) && \"The mesh can only contain PerFace semantics.\""
- "(mesh.semantics.empty() || mesh.semantics.size() == mesh.faces.size()) && \"The number of labels is non-zero and different from the number of faces.\""
- "(mesh.tex_coords.empty()) && \"Texture coordinates not supported\""
- "(mesh.tex_faces.empty()) && \"Texture faces not supported\""
- "(mesh.tex_faces.size() == 0) && \"for meshes without texture coords, mesh's #tex_faces must be zero\""
- "(mesh.tex_faces.size() == mesh.faces.size()) && \"for meshes with texture coords, mesh's #tex_faces must be equal to #faces\""
- "(mesh.vertices.size() == mesh.normals.size() || mesh.normals.empty()) && \"The mesh must have either no or per vertex normals\""
- "(mesh_ptr->faces.empty() == mesh_ptr->vertices.empty()) && \"For meshes with zero faces, vertices should be also zero and vice versa\""
- "(new_weight >= 0 && new_weight <= std::numeric_limits<SdfVoxel::WeightType>::max()) && \"Invalid weight value\""
- "(pruning_cg.max_num_keyframes >= pruning_cg.max_keyframe_safety_buffer + 10) && \"Maximum number of keyframes limit is too small or safety buffer size is too high.\""
- "(semantic.Width() >= 1 && semantic.Height() >= 1) && \"Image size is too small\""
- "(width == texture.width()) && (height == texture.height()) && \"Texture and image size don't match\""
- ") #EXmuted("
- ") #Pmuted("
- ") #remain("
- "*c < *KeyframeBundleComponent::NumComponents && \"Unsupported component\""
- ".Origins"
- "/AppleInternal/Library/BuildRoots/5a481bbe-9f57-11ee-9024-8efc15467d2d/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.3.Internal.sdk/usr/local/include/boost/geometry/algorithms/detail/has_self_intersections.hpp"
- "/AppleInternal/Library/BuildRoots/5a481bbe-9f57-11ee-9024-8efc15467d2d/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.3.Internal.sdk/usr/local/include/boost/geometry/algorithms/detail/overlay/add_rings.hpp"
- "/AppleInternal/Library/BuildRoots/5a481bbe-9f57-11ee-9024-8efc15467d2d/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.3.Internal.sdk/usr/local/include/boost/geometry/algorithms/detail/overlay/get_turn_info_la.hpp"
- "/AppleInternal/Library/BuildRoots/5a481bbe-9f57-11ee-9024-8efc15467d2d/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.3.Internal.sdk/usr/local/include/boost/rational.hpp"
- "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/ACV/SurfaceDetection/src/Image/ImageSegmentUtil.cpp"
- "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/ACV/SurfaceDetection/src/SingleShot/SegmentBasedPlanePopupDetector.cpp"
- "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Essentials/Root/src/Assert.cpp"
- "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Essentials/Thread/src/ThreadGroup.cpp"
- "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Essentials/Thread/src/WorkQueue.cpp"
- "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Essentials/Thread/src/WorkQueueTypeUtil.cpp"
- "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Kit/Image/include/Kit/Image/SharedImage.h:1219"
- "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/KeyframePlanes/src/SingleShotResultTool.cpp"
- "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Keyframing/src/Types.cpp"
- "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Mapper/src/GenericGlobalReferenceSystem.cpp"
- "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Mapper/src/KeyframeClusterProvider.cpp"
- "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Mapper/src/KeyframeImageCache.cpp"
- "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Mapper/src/KeyframeRankManager.cpp"
- "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Mapper/src/MeshBacklogger.cpp"
- "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/SessionNodeGroup/src/VisualizationData.cpp"
- "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/SessionNodeGroup/src/VisualizationDataIO.cpp"
- "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/Utils/src/CoreAnalyticsAggregator.cpp"
- "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/VolumetricMapper/src/KeyframePlanesMap.cpp"
- "/Library/Caches/com.apple.xbs/Sources/Recon3D/library/Reconstruction/VolumetricMapper/src/PlaneMeshExtractor.cpp"
- "00000000000000000000000000000000000000000"
- "3D bounding box does not intersect the clipping volume."
- "ActiveMask"
- "Anchor removal keyframes"
- "Ask Global Re-Mesh"
- "Ask Occupancy Mesh"
- "Ask Re-Mesh"
- "Base::BlockSize() < chunk_size_ && \"A block must be smaller than a chunk\""
- "Block has a reference to a chunk that does not exist in the mesh map."
- "BlockPositionRangeContains(node_range, neighbor_position) && \"Invalid block neighborhood information\""
- "Can't get here -- stack corruption?"
- "ChangeFromHideToShow"
- "ChangeFromShowToHide"
- "ChangeMask"
- "Clipped plane has no convex hull."
- "Completing spatial boundary more than once"
- "ComputeBlockTableBucketSize(config_.meshing.value()) >= (1u << cfg::kMinBucketsOrderOfMagnitude) && \"Table size too small!\""
- "Contains(key) && \"Invalid key\""
- "DepthParams"
- "Description"
- "Downsample scale factor is not in the range (0,1]"
- "Empty ThreadGroup name."
- "Enable PRR"
- "Error saving keyframing snapshot"
- "Error saving plane snapshot"
- "Failed to estimate %{private}s height"
- "Failed to load file into cache"
- "FilteredChange"
- "GGRS: IGNORED-UUID %lu/%lu uuid: %s type: %s reason: Non-graph External"
- "GGRS: MISSED-UUID %lu/%lu  uuid: %s type: %s reason: %s"
- "GGRS: meshing back logging #out("
- "GGRS: reset dominant plane tracking since anchor becomes external."
- "Generate NVS"
- "Get all Keyframes"
- "Get keyframe from uuid"
- "GetGPLinks: Stale KP %.13s in GP %.13s"
- "Global Mesh Update"
- "Hallucinated"
- "Hallucinated pipeline has failed. Potential out-of-sync risk: %s"
- "HallucinatedKeyframePlanes.PoC.extended_horizontal_planes"
- "HallucinatedKeyframePlanes.PoC.final_plane_segments"
- "HallucinatedKeyframePlanes.PoC.pop_up_plane_segments"
- "HasBundle<T>(cid) && \"Bundle does not exist\""
- "Hide"
- "IOClassification"
- "Image cached"
- "Integrated frames file cannot be created "
- "InverseWarpAndFuseKeyframe_All"
- "InverseWarpAndFuseKeyframe_Base"
- "InverseWarpAndFuseKeyframe_Color"
- "InverseWarpAndFuseKeyframe_ColorAndMaterials"
- "InverseWarpAndFuseKeyframe_ColorAndSemantics"
- "InverseWarpAndFuseKeyframe_Materials"
- "InverseWarpAndFuseKeyframe_Semantics"
- "InverseWarpAndFuseKeyframe_SemanticsAndMaterials"
- "IsAligned(mesh_.faces.data(), kPageSize) && \"Expect aligned faces\""
- "IsAligned(mesh_.semantics.data(), kPageSize) && \"Expect aligned faces\""
- "IsAligned(mesh_.vertices.data(), kPageSize) && \"Expect aligned vertices\""
- "IsCpuPtr(ptr) && \"Invalid keyframe\""
- "IsGpuPtr(ptr) && \"Invalid keyframe\""
- "IsOccupancySupported() && \"Invalid occupancy mapper\""
- "IsValid(input_ptr) && \"Invalid input keyframe\""
- "IsValid(input_ptr) && IsGpuPtr(input_ptr) && \"Invalid input keyframe pointer.\""
- "IsValid(output->surface) && IsGpuPtr(output->surface) && \"Invalid output keyframe pointer.\""
- "IsValid(ptr) && \"Invalid keyframe\""
- "IsValid(target->surface) && \"Invalid target keyframe\""
- "IsValidEvent(cur_ev) && \"Not a legitimate current event\""
- "IsValidEvent(event) && \"Not a legitimate event\""
- "IsValidEvent(in_ev) && \"Not a legitimate in event\""
- "JasperClouds"
- "KFE:IKC t:%f, NK:%lu, NC:%u"
- "KFE:PUpdate:t:%f, RA:%zu, AN:%lu, AU:%lu, AE:%lu, AR:%lu, NU:%u, NRL:%u, NE:%u, NR:%u NA:%zu"
- "KVA: SLAM is bad but num_integrated_rgbd delta (%d) is non-zero!"
- "KeyVol event: "
- "Keyframe cannot be retrieved: %s"
- "Keyframe polygon for plane %.13s could not be transformed onto global plane"
- "KeyframeEngine"
- "KeyframePlaneStorage: Deleted persisted item %.13s"
- "KeyframePlaneStorage: Failed to delete persisted item %.13s"
- "KeyframePlanes.GlobalPlanes.IntegrationCandidates"
- "Keyframes"
- "Keyframing.SurfaceWarpFuser.InverseWarpKeyframe"
- "Load Session"
- "Mesh Update"
- "MeshDepth"
- "Meshing World"
- "MeshingEngine"
- "NetworkOutputNodeAsync"
- "NormalsRGB"
- "Not supported by aggregator."
- "OSLogSurrogateAppender"
- "Occupancy Mesh Update"
- "PlaneDetector"
- "PointCloud"
- "PointsOfInterest"
- "Process Frame Bundle"
- "ProcessContentUpdate: KF %.13s not valid"
- "ProcessPoseUpdate: KF %.13s has no pose update"
- "Production"
- "Query Occupancy"
- "Query PRR"
- "Query synthetic PRR"
- "R3D"
- "RegionGraph"
- "RelativePositionIsValid(pos) && \"Invalid grid position\""
- "RelativePositionToIndex(relative_pos) == index && \"Invalid index\""
- "Removing pose update for keyframe: "
- "Removing redundant keyframe "
- "Reset Session"
- "Save Diagnostic data"
- "Save Keyframes"
- "Save Session"
- "Save Snapshot"
- "Save snapshot failed for hallucinated pipeline"
- "SemanticsExcludedMask"
- "SemanticsRGB"
- "Set Max Weight"
- "Set Meshing Period"
- "Show"
- "Size() == frame.Size() && \"KeyframeBundle sizes don't match\""
- "Size() == output.Size() && \"Input and output size should match\""
- "SplitGlobalPlanes: %zu/%zu global planes not considered for splitting due to pending pose updates."
- "Stats.Volumetric"
- "Stats.Volumetric.DropFrame"
- "Stats.Volumetric.GlobalCoordinateManager"
- "Stats.Volumetric.KeyframingAdaptor"
- "Stats.Volumetric.KeyframingAdaptorCache"
- "Stats.Volumetric.MeshBacklogger"
- "SupportsVolumetric(config_, batch_metadata) && \"Volumetric requested\""
- "Total pending loop closure keyframe updates"
- "Uninitialized"
- "UpdateVotingBlocks"
- "User World"
- "VLM:GGRS TS:%i MS: %i ID:%i RK:%lu IK:%lu"
- "VLM:KF:t:%f, HA:%i RA: %i VB:%lu CH:%lu RCY:%u CHE:%lu CHH:%d CHR:%d VX:%lu"
- "VLM:KVA NC:%zu P:%zu LC:%zu EX:%zu D:%zu R:%i TP:%zu, AP:%zu"
- "VLM:MBL CO:%llu CR: %llu PM:%llu EM:%llu"
- "Vision World"
- "Volumetric.Chunks"
- "Volumetric.KeyVol"
- "Volumetric.KeyVol.CT"
- "Volumetric.KeyVol.KeyframingAdaptor"
- "Volumetric.KeyVol.LoopClosure"
- "Volumetric.PlanarIntegrationPoints"
- "Volumetric.Planes.Chunks"
- "Volumetric.Planes.ConvexHulls"
- "Volumetric.Planes.Origins"
- "Wait Session"
- "Y/N"
- "[FillMapperMetadata] `engine_type` not supported"
- "_[%d_%d_%d]"
- "_f && \"Function should contain valid target\""
- "active_depth_dt.Size() == size && \"active_depth_dt size mismatch\""
- "active_depth_mask"
- "add_anchor"
- "add_callback && \"Add anchor block not valid\""
- "attach && \"Attach adaptor to bundle fails\""
- "attribute == MappingAttribute::Semantic || attribute == MappingAttribute::Material && \"Only semantic or material attributes are supported.\""
- "aux_depth_2d.Shape() == image_shape && \"Image shape does not match\""
- "aux_mask_2d.Shape() == image_shape && \"Image shape does not match\""
- "batch_metadata->SupportsVolumetric() == keyvol_config.SupportsVolumetric() && \"Batch metadata does not match keyframing adaptor internal config.\""
- "batch_metadata.ShouldProcessContentUpdateKeyframes() && \"Expect should process content update keyframes!\""
- "batch_metadata.SupportsVolumetric() && \"Volumetric batch metadata is requested\""
- "batch_metadata.TimeMatch(keyframe_list)"
- "best_start_index != kUnset && \"Could not find a polygon segment to the right of ray_start\""
- "bid == GetBaseBundleId<T>() && \"Mapper already exist\""
- "block_incoming_edges.count(target) == 1 && \"More than 1 incoming edge to a node on shortest path\""
- "block_index < allocated_voxel_blocks_.size() && \"Invalid block index\""
- "block_resolution > 0 && \"Invalid block resolution.\""
- "bool boost::geometry::detail::overlay::has_self_intersections(const Geometry &, const Strategy &, const RobustPolicy &, bool) [Geometry = std::vector<cv3d::recon::geometry::Polygon<float, 2>>, Strategy = boost::geometry::strategies::relate::cartesian<>, RobustPolicy = boost::geometry::detail::robust_policy<cva::Matrix<float, 2, 1>, boost::geometry::model::point<long long, 2, boost::geometry::cs::cartesian>, float>]"
- "boundary_index < result.edge_indices_.size() && \"Corner edge index out of bounds\""
- "boundary_index < result.edge_indices_.size() && \"Merged edge index out of bounds\""
- "boundary_index < result.nodes_.size() && \"Merged node index out of bounds\""
- "boxes.size() < static_cast<size_t>(u16max) && \"Tracked plane has more visible leaf cells to handle\""
- "brga_buffer_opt && \"Failed to create pixel buffer for conversion of YUV\" \" to BGRA\""
- "brga_out_iosurface && \"Expect IOSurface backed pixel buffer\""
- "buffer.length() == size[0] * size[1] * element_size && \"Incorrect buffer size\""
- "buffer_iosurface && \"Expect IOSurface backed pixel buffer\""
- "buffer_no_copy && \"Buffer not created\""
- "buffer_opt && \"Failed to create pixel buffer for image scaling\""
- "buffer_opt && \"Failed to create pixel buffer\""
- "bytes_per_row >= min_bytes_per_row && \"stride must not overlap internally\""
- "cache_neighbors.size() == cache_num_neighbors.size() && \"Invalid cache_num_neighbors size.\""
- "cache_neighbors.size() == cache_weights.size() && \"Invalid cache_weights size.\""
- "cache_neighbors.size() >= num_descriptors && \"Invalid cache_neighbors size.\""
- "callable != nullptr && \"Callable must be valid\""
- "camera->ImageSize() == camera_in.ImageSize() && \"Camera size should be identical for all keyframes\""
- "camera.ImageSize() == depth_image.Size() && \"Image size mismatch\""
- "camera.ImageSize() == normals.Size() && \"Size mismatch\""
- "camera.ImageWidth() % 4 == 0 && \"NVS requires width multiple of 4\""
- "chunk_mesh.confidences.size() == chunk_mesh.faces.size() && \"The mesh must contain per-face confidences\""
- "chunk_mesh.confidences.size() == chunk_mesh.vertices.size() && \"The mesh must contain per-vertex confidences\""
- "chunk_mesh.materials.size() == chunk_mesh.faces.size() && \"The mesh must contain per-face materials\""
- "chunk_mesh.normals.size() == chunk_mesh.vertices.size() && \"The mesh must contain per-vertex normals\""
- "chunk_mesh.semantics.size() == chunk_mesh.faces.size() && \"The mesh must contain per-face semantics\""
- "chunk_pos_iter != chunk_indices_.end() && \"Can only erase an added block!\""
- "chunk_size > 0 && \"Expected to have a valid chunk size\""
- "clouds && \"Ptr to JasperClouds expected non-null in KF bundle\""
- "color1.Size() == color2.Size() && \"input images should have the same size\""
- "color_ref.Format() == kcv::PixelFormat::YpCbCr444BiplanarFullRange_8 && \"Pixel type does not match required 444f format.\""
- "color_texture && \"Requested color texture is not valid\""
- "com.apple.recon3d.meshing.keyframing_adaptor_config.image_cache_capacity"
- "command_buffer.has_value() && \"Expect non null command buffer\""
- "complete_histogram_s_.size() == histogram_length && \"material histogram length not match with images size\""
- "complete_histogram_s_.size() == histogram_length && \"semantic histogram length not match with images size\""
- "component < CacheComponent::NumComponents && \"Invalid component\""
- "compute_pipeline_states_.count(kernel_name) && \"Kernel not found for input mask\""
- "confidence_op.has_value() != uncertainty_op.has_value() && \"Either confidence or uncertainty has to be valid, but not both\""
- "config.meshing && \"SessionConfig should have MeshingConfig for reconciliation\""
- "config.meshing->pcm_config.has_value() && \"No PCM mapper config\""
- "config.meshing.has_value() && \"Do not support meshing.\""
- "config_.common.monitoring.output_per_frame_monitoring_result && \"Received a monitoring result from keyframing when not set up to.\""
- "config_.common.persistence.storage_path && \"Pesistence storage path not set up, data path unavailable\""
- "config_.common.persistence.storage_path && \"Pesistence storage path not set up, metadata path unavailable\""
- "config_.common.persistence.storage_path && config_.common.persistence.enabled && \"Persistence data cannot be loaded if persistence is not set up and enabled\""
- "config_.material_label_to_switch_target >= PRRConfig::kInvalidMaterialLabel && config_.material_label_to_switch_target < static_cast<int32_t>(MaterialLabel::NumValidLabels) && \"Invalid target material label.\""
- "config_.max_depth > 0.0f && \"max_depth should be positive.\""
- "config_.meshing && \"Volumetric mapper needs a MeshingConfig\""
- "config_.meshing->HasMapper(MeshingMapperType::Volumetric)"
- "config_.meshing->sdf_config.has_value()"
- "config_.meshing.HasOccupancyAirMesh() && \"Occupancy air mesh must be enabled to extract occupancy air mesh.\""
- "config_.volumetric->image_cache_capacity > 0 && \"Without KeyVol+ cache image capacity must be non-zero.\""
- "const "
- "context != nullptr && \"Context may not be nullptr\""
- "context && \"Context may not be nullptr\""
- "convex hull"
- "coordinate transformer"
- "ctx_ != NULL && \"Error creating espresso context.\""
- "cur_cb == nullptr && \"Pre-abort callback is already set\""
- "current_frame && \"Expect valid current frame when updating\""
- "cv3d.recon.Stats."
- "cv3d.recon.kfplanes.async"
- "cv3dapi.recon3d.kfplanes.async"
- "depth.Size() == camera.ImageSize() && \"depth and camera image size must match\""
- "depth.Size() == normal.Size() && \"depth and normal size must match\""
- "destination_surface.IsValid() && \"Invalid destination buffer!\""
- "destination_surface.IsValid() && \"Invalid front buffer!\""
- "detail::CheckAttributeCompatibility( config.meshing->integrate_attribute_mask, config.meshing->output_per_frame_attribute_mask)"
- "detail::CheckAttributeCompatibility(config.common.mapping.attribute_mask, config.meshing->integrate_attribute_mask)"
- "dev_resource/models/r5tuyggaps_540000/model.espresso.net"
- "device && \"Invalid device\""
- "device_ && \"Invalid Petal device\""
- "directory_created && \"Unable to create data storage directory\""
- "dot_product > -0.9 && \"A plane from an opposite direction was added to a vertex\""
- "edge_id < mesh.edges.size() && \"Edge ID exceeds limit\""
- "edge_owner != 0 && \"Must be an edge owned by a neighbor\""
- "edges_.size() > index1 && \"edge1 out of bounds\""
- "edges_.size() > index2 && \"edge2 out of bounds\""
- "edges_from_node.count(current_position) == 1 && \"Edges from node not found\""
- "edges_from_node.count(erased_node_pos) == 1 && \"Edges from erased node not found\""
- "edges_from_node.count(neighbor_pos) == 1 && \"Edges from neighbor node not found\""
- "edges_from_node.count(node.position) == 1 && \"Edges from node not found\""
- "edges_from_node.count(remaining_node_pos) == 1 && \"Edges from remaining node not found\""
- "edges_from_node_.count(node_position) == 1 && \"edges from node not found\""
- "err && \"GetAllKeyframes should set err\""
- "error == 0 && \"dispatch_group_wait failed\""
- "event != KVE::KeyVolEventInvalid && \"Invalid event\""
- "face_labels.size() == mesh.faces.size() && \"mesh.faces and face_labels must be the same size\""
- "faces.size() == faces_planes.size()"
- "false && \"ComputeMeshState is not supported by OccupancyMappedStateProvider\""
- "false && \"ComputeMeshStates is not supported by OccupancyMappedStateProvider\""
- "false && \"ComputeOccupancyState is not supported by MappedStateProvider\""
- "false && \"Exception when padding size to bytes\""
- "false && \"FaceIndex is not initialized\""
- "false && \"Filesystem doesn't support caching\""
- "false && \"Invalid Axis value\""
- "false && \"Invalid SU semantic label.\""
- "false && \"Should be able to find it.\""
- "fb.Depth() && fb.Confidence() && \"Input frame data should have valid depth and confidence frame!\""
- "fb.Uncertainty().has_value() && \"No uncertainty data from rawframe\""
- "fb.depth.depth.has_value() && fb.semantic.labels.has_value() && \"Expect to have valid depth and semantics.\""
- "filtered_lidar"
- "flags.size() == data.echos.size() && \"Size mismatch\""
- "flying_pixels"
- "format != img::Format::Dynamic && \"loader must specify the format to load as\""
- "fpfhs_dst.size() == semantics_dst.size() && \"Destination FPFH features and semantics size must match.\""
- "fpfhs_src.size() == semantics_src.size() && \"Source FPFH features and semantics size must match.\""
- "frame && \"Preprocessing cannot fail\""
- "frame.SceneTypeProbability() && \"Invalid scene type probability image\""
- "frame::IsValidKeyframeUpdateState(kf.update_state) && \"Invalid update state\""
- "frame_data.Depth() && frame_data.Confidence() && \"Input frame data should have valid depth and confidence frame!\""
- "fs::exists(base_path, fs_) && \"Base folder must exist\""
- "get_serialized_size() == size_in_bytes && \"Serialized size doesn't match expected size\""
- "ggrs_pending_buffer_accu"
- "ggrs_pending_buffer_temp"
- "granularity_hint != OccupancyGranularity::Fine && \"Only medium and coarse granularity point queries are supported.\""
- "granularity_hint == OccupancyGranularity::Coarse && \"Only coarse granularity volume queries are supported.\""
- "hallucinated_planes"
- "has_primitive_id_rendering()"
- "histogram_[label] < std::numeric_limits<CountType>::max() && \"Too many votes for the chosen vote count type causes an overflow.\""
- "hw.optional.arm.FEAT_SME"
- "id_iter != parent_plane_id_.end() && \"Cannot find the plane ID in parent_plane_id_.\""
- "idx_block < metadata_blocks_.size() && \"Out of range\""
- "image.ValueStride(0) == 1 && output.ValueStride(0) == 1 && confidences.ValueStride(0) == 1 && \"First dimension must not have paddings for the efficiency.\""
- "image_data_ptr && \"ExportImageData requires data to be ImageData\""
- "img_size_ == camera.ImageSize() && \"Can't handle requests for multiple res\""
- "impl_"
- "index < edge_indices_.size() && \"Edge index out of bounds\""
- "index < metadata_blocks_.size() && \"Out of range\""
- "index < nodes_.size() && \"Node index out of bounds\""
- "index < num_elements_ && \"Access element out of bounds\""
- "index < plane_count_ && \"index out of range\""
- "index < valid_occupied_blocks && \"Block index out of bounds\""
- "index < voxel_block.size() && \"Invalid grid index\""
- "index == cell_index && \"Cell index does not match.\""
- "index1 != index2 && \"Trying to erase empty range\""
- "inner_ring_assignments[inner_i] != kUnassigned && \"Could not find containing polygon for inner ring\""
- "input_ptr->IsValid() && \"Input KeyframeBundle should be valid\""
- "inv_voxel_size_ > 0 && !std::isinf(inv_voxel_size_) && \"Expect finite positive voxel size\""
- "invalid_mask"
- "invalidate_keyframe_cb_ && \"Invalidate keyframe callback required\""
- "is_flag(in) && \"Received an invalid (composite) update state as input.\""
- "is_horizontal"
- "is_tracked && \"Expect keyframe in tracking\""
- "is_tracked && \"Untracked keyframe!\""
- "it->second->ImageFormat() == format && \"Image format mismatch\""
- "it->second->ImageSize() == size && \"Image size mismatch\""
- "iter != batch_metadata.volumetric->kf_to_mesh_rendering.end() && \"Raw frame mesh depth not found!\""
- "iter != bridge_edge_map_.end() && \"Should be able to find it.\""
- "iter != kf_block_indices.end() && \"Keyframe not found\""
- "iter != kf_to_mesh_rendering.end() && \"Newly created keyframe mesh depth not found!\""
- "iter != kf_to_mesh_rendering.end() && \"Raw frame mesh depth not found!\""
- "iter != parent_plane_id_.end() && \"Cannot find the plane ID in parent_plane_id_.\""
- "iter != rankings_.end()"
- "iter != raster_buffer.end() && \"Expect buffer for allocated image\""
- "iter->second.observation_count < std::numeric_limits<size_t>::max()"
- "iter_into != plane_uuid_to_id_.end()"
- "iter_src != default_confusion_table.end() && \"Invalid source material label.\""
- "iter_subsumed != plane_uuid_to_id_.end()"
- "iw % 4 == 0 && \"CVA vector requires width multiple of 4\""
- "keyframe->IsValid()"
- "keyframe_list.input_frame.has_value() && \"Raw frame unavailable\""
- "keyframe_map_.count(kfid) && \"Expect keyframe is tracked\""
- "keyframe_ptr != nullptr && \"Integrated kf should be in shared memory\""
- "keyframing_node_->C<KeyframeChannels::SaveSnapshot>().InputEnabled()"
- "keys.size() == values.size() && \"Number of keys must match number of values\""
- "kf.UpdateState() == frame::KeyframeUpdateStateContentUpdated || kf.UpdateState() == frame::KeyframeUpdateStateNoUpdate && \"Unexpected keyframe update state during strobing\""
- "kf_database.Contains(current_id) && \"Current keyframe ID should be in db_\""
- "kf_integration_blocks.count(kvi::RawframeId()) != 0 && \"No integration blocks for the frame\""
- "kf_to_mesh_rendering.count(uuid) != 0 && \"No mesh depth available.\""
- "kf_to_mesh_rendering.count(uuid) == 0 && \"Impossible.\""
- "label < kNumMaterialLabels && \"Cannot integrate an invalid material label\""
- "latest_batch_metadata_->volumetric->kf_to_mesh_rendering.count(kvi::RawframeId()) && \"No render depth for this rawframe!\""
- "latest_frame_bundle_.timestamp == timestamp && \"Timestamp mismatch\""
- "linear_rgba_iosurface && \"Expect IOSurface backed pixel buffer\""
- "load_factor <= kMaxLoad && \"Too many keyframes in memory\""
- "local_subblock_pos[0] >= 0 && local_subblock_pos[1] >= 0 && local_subblock_pos[2] >= 0 && \"Local position has positive coordinates\""
- "mapper && \"Missing Volumetric mapper\""
- "masked_confidence"
- "masked_depth"
- "materialsRGB"
- "math::IsFinite(point) && math::IsFinite(normal) && \"Adding non-finite point\""
- "math::IsFinite(pos) && \"Converting nan value to voxel position\""
- "math::IsFinite(voxel_size) && voxel_size > 0 && \"Invalid voxel size\""
- "math::IsOdd(kernel_size) && \"Kernel size should be an odd number\""
- "math::IsPowerOfTwo(block_size_) && \"Invalid block size\""
- "math::IsPowerOfTwo(chunk_size_) && \"Invalid chunk size\""
- "max_depth > 0.f && \"Invalid maximum depth.\""
- "maybe_format && \"Format is not serializable. Must be a non-dynamic format.\""
- "memory_size > 0 && \"Shared memory not allocated\""
- "mesh && \"MeshList can not contain null pointers!\""
- "mesh.colors.empty() && \"The mesh cannot contain colors.\""
- "mesh.confidences.size() == mesh.vertices.size() && \"Confidences and Vertices size do not match.\""
- "mesh.edges.empty() && \"The mesh cannot contain edges.\""
- "mesh.faces.size() == face_state.size() && \"face_state should be the same size as mesh.faces\""
- "mesh.normals.empty() && \"The mesh cannot contain normals.\""
- "mesh.tex_coords.empty() && \"The mesh cannot contain tex_coords.\""
- "mesh.tex_coords.empty() && \"currently mesh cannot contain texture coordinates\""
- "mesh.tex_faces.empty() && \"The mesh cannot contain tex_faces.\""
- "mesh.tex_faces.empty() && \"currently mesh cannot contain texture faces\""
- "mesh.vertices.size() == vertex_planes.size()"
- "mesh.vertices.size() == vertex_tag.size() && \"The number of vertices is different from the number of per vertex tags.\""
- "mesh_data_ptr && \"ExportMeshData requires data to be MeshData\""
- "mesh_uuid_it != parent_plane_id_to_mesh_id_.end() && \"parent_plane_id_to_mesh_id_ should be consistent with plane_chunk_map_\""
- "meshes.size() == camera_from_world_vec.size() && \"meshes number and camera_pose number should be the same\""
- "meshes.size() == output_images.size() && \"meshes number and output_images number should be the same\""
- "meshing status"
- "meshing("
- "meshing->keyframing_adaptor_config.image_cache_capacity"
- "meshing_node && \"Expected meshing node\""
- "monodepth_bundle"
- "neighbor_cache_type_ != NeighborCache::Fifteen && \"Invalid cache type\""
- "net2d_path_opt && \"Failed to access 2D network file\""
- "net3d_path_opt && \"Failed to access 3D network file\""
- "net_path_opt && \"Failed to access network file\""
- "next_boundary_index < result.edge_indices_.size() && \"Next corner edge index out of bounds\""
- "next_boundary_index < result.nodes_.size() && \"Next corner node index out of bounds\""
- "nodes.count(edge.from) == 1 && \"Edge start node not found\""
- "nodes.count(edge.to) == 1 && \"Edge end node not found\""
- "nodes.count(split_block_1) == 1 && \"First split node not found\""
- "nodes.count(split_block_2) == 1 && \"Second split node not found\""
- "nodes.size() == edge_indices.size() && \"Edge and node counts do not match\""
- "nodes_.count(neighbor_position) == 1 && \"Neighbor node not found\""
- "nodes_.count(node_position) == 1 && \"Node not found\""
- "normalsRGB"
- "novelty_mask.Size() == size && \"novelty mask size mismatch\""
- "num_aux == aux_to_world.size() && \"Number of auxiliary frames mismatch\""
- "num_aux == camera_aux.size() && \"Number of auxiliary frames mismatch\""
- "num_channels == kExpectedChannels && \"Number of image channels and 3 mismatch.\""
- "num_data_files"
- "num_descriptors == normals.size() && \"vertices and normals size mismatch.\""
- "num_descriptors == spfhs.size() && \"pointcloud and spfhs size mismatch.\""
- "num_metadata_files"
- "num_tracked_keyframes != 0 && \"expect initialized.\""
- "number_depth_bin == depth_of_bins_.size() && \"Number of bins mismatch\""
- "obs.polygons.size() == obs.opSemantics->size() && \"Semantics must be assigned for every polygon extents.\""
- "occupied_blocks && \"Ptr to occupied voxel blocks expected non-null\""
- "op_keyframe_planes_map.has_value()"
- "op_plane.has_value()"
- "opt_internal_dict.has_value() && \"Expected to convert a CFDictionaryRef\""
- "opt_label_confidence_view->Size() == size"
- "out_buffer_iosurface && \"Expect IOSurface backed pixel buffer\""
- "out_channel == kExpectedChannels && \"Number of output channels and 3 mismatch.\""
- "out_iosurface && \"Expect IOSurface backed pixel buffer\""
- "out_size[0] > 0 && out_size[1] > 0 && \"Output image size is not valid\""
- "output_buffer.Shape() == buffer_shape && \"buffer and tensor shape mismatch\""
- "pending_loop_closure_keyframes.count(uuid)"
- "plan_ != NULL && \"Error creating espresso plan.\""
- "plane.convexHullExtent && \"Plane convex hull representation is missing.\""
- "plane.gridExtent && \"Plane grid representation is missing.\""
- "planeSegments.Shape() == semanticSegments.Shape() && \"The shapes of plane segment and semantic segment are not matched.\""
- "plane_cache_ && \"plane_cache_ is not allocated.\""
- "plane_count_ < kMaxNumPlanes && \"Exceeded maximum number of planes allowed.\""
- "plane_detection_node_->C<KFPDC::SaveSnapshot>().InputEnabled()"
- "plane_idx < num_planes"
- "plane_snapper_ && \"Plane snapper is null\""
- "plane_snapper_ && opt_frame_bundle->Depth() && opt_frame_bundle->Confidence() && \"Integration for planes requires validity of snapper and bundle.\""
- "planes.size() == planeSemantics.size() && \"Plane and semantics do not have the equal number of elements.\""
- "planesImage.image().Shape(0) == camera.width() && planesImage.image().Shape(1) == camera.height() && planesImage.image().Shape() == surfaceSegments.image().Shape()"
- "points2d.size() == points3d.size() && \"The number of 2D points and 3D points must be matched.\""
- "points_.Count() > 0 && \"No points in block to compute mean\""
- "points_.size() < points_.capacity() && \"Capacity not big enough.\""
- "polygon.size() >= 3 && \"Polygon must have at least three vertices.\""
- "polygons.size() <= static_cast<size_t>(std::numeric_limits<uint8_t>::max()) && \"Support at most 254 holes.\""
- "pose_updates.size() >= GGRS::kMinimumGraphSizeForGlobalPoseEstimation && \"Graph too small to process.\""
- "position[0] % static_cast<int32_t>(stride_) == 0 && position[1] % static_cast<int32_t>(stride_) == 0 && position[2] % static_cast<int32_t>(stride_) == 0 && \"Invalid block position.\""
- "possible_publish_set.size() == possible_publish_list.size() && \"Expect no repeated kfs in construction of possible publishing list\""
- "previous input frame was dropped"
- "priv().initialized_root_appenders_ == current_root_appenders && \"root appenders have been illegally modified between Initialize() and \" \"Enable() of APILogging\""
- "priv().initialized_root_appenders_ == current_root_appenders && \"root appenders have been illegally modified between Initialize() and \" \"EnableInternal() of APILogging\""
- "priv().initialized_root_appenders_ == current_root_appenders && \"root appenders have been illegally modified between Initialize() and \" \"EnableInternalWithConfigurationFile() of APILogging\""
- "process event type"
- "processed_confidence"
- "processed_depth"
- "processed_semantics"
- "ptr && \"Expected ptr to have been allocated\""
- "raster_depths.size() == 1u && \"Expect single render viewpoint in Monitor when making a depth based suggestion.\""
- "raster_depths_.back() && (!raster_depths_.back()->Empty()) && \"Raster depth should not be empty\""
- "rasterizationResult.has_value() && \"Could not rasterize mesh\""
- "ray_angle_2d.Shape() == image_shape && \"Image shape does not match\""
- "reflective"
- "remesh_it != plane_needs_remesh_.end() && \"Cannot find the plane ID in plane_needs_remesh_.\""
- "remove_anchor"
- "remove_callback && \"Remove anchor block not valid\""
- "remove_redundant_active (ms)"
- "render_targets[i].Buffer() && \"Buffer not present\""
- "request.attributes == static_cast<MappingAttribute>(0u) && \"Attribute requests not implemented\""
- "request_all_callback && \"Request all anchors block not valid\""
- "res && \"Failed to remove keyframe from disk\""
- "res && \"Failed to remove keyframe from shared memory\""
- "result->input_frame.has_value() && \"Expected input frame for monitoring result creation\""
- "result.IsDefined() && \"The result should be defined\""
- "result.SaveToStream(ss) && \"Failed to serialize occupancy data\""
- "result.edge_indices_.size() == result.nodes_.size() && \"Edge and node counts must match\""
- "result.keyframes_updated.empty() && \"No content updates expected from KeyframingEngine in Monitor mode\""
- "ret == (adaptor != nullptr) && \"Attach fails.\""
- "ret == 0 && \"Failed to set workgroup flags.\""
- "ret == ESPRESSO_STATUS_SUCCESS && \"Error adding 2D network.\""
- "ret == ESPRESSO_STATUS_SUCCESS && \"Error adding depth network.\""
- "ret == ESPRESSO_STATUS_SUCCESS && \"Error building espresso plan.\""
- "ring1.size() > 0 && \"ring1 must be nonempty\""
- "ring2.size() > 0 && \"ring2 must be nonempty\""
- "scale_factor > 0.f && \"Invalid scale factor!\""
- "scale_factor > 0.f && scale_factor <= 1.f && \"Invalid scale factor!\""
- "scaled_image_iosurface && \"Expect IOSurface backed pixel buffer\""
- "scene_type_block_height > 0 && \"scene_type_block_height must be > 0\""
- "scene_type_block_width > 0 && \"scene_type_block_width must be > 0\""
- "scene_type_confidence"
- "scene_type_labels"
- "scene_type_ref.Shape()(0) == 1 && \"Invalid scene type width\""
- "scene_type_ref.Shape()(1) == 1 && \"Invalid scene type height\""
- "scheduler_ && \"scheduler must be valid\""
- "sem_img.Size() == size && \"semantics image and size mismatch\""
- "semantics.Size() == size && \"Image size mismatch\""
- "semanticsRGB"
- "semantics_baseline.Size() == size && \"semantics_baseline size mismatch\""
- "semantics_confidence"
- "size_without_padding <= size_in_bytes && \"Occupancy by proximity result too big for serialization\""
- "slam_state->IsGood() && \"Should not process a raw frame when SLAM is bad\""
- "soft_erase"
- "source_ptr->Size() == target_ptr->Size() && \"Output image size does not match input image\""
- "src.size() == dst.size() && \"number of elements mismatch\""
- "src.size() == weights->size() && \"number of elements mismatch\""
- "src.size() >= 3 && \"at least 3 point pairs are required\""
- "ss_config.meshing->HasMapper(MeshingMapperType::Volumetric) && \"Do not support volumetric mapper\""
- "ss_config.meshing.has_value() && \"No meshing config!\""
- "states.cull_mode == petal::CullMode::None && \"Cpu rendering only supports CullMode::None now\""
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ProtocolInfoSample]"
- "static_cast<uint32_t>(in_view.Height() * scale_factor) == out_view.Height() && \"Expected scaling requests with preserved aspect ratio\""
- "stride > 0 && \"Stride must be >0\""
- "stride > 0 && \"stride must be > 0\""
- "texture && (img.Width() == texture.width()) && (img.Height() == texture.height()) && \"Texture and image size don't match\""
- "texture.width() == size[0] && texture.height() == size[1] && \"Incorrect buffer size\""
- "texture_ && \"Error allocating a texture\""
- "texture_out && \"Expect valid texture\""
- "texture_stride == image_stride && \"Texture and image stride don't match\""
- "this->size() * kNumParameters * sizeof(float) == static_cast<size_t>(CFDataGetLength(data)) && \"Input array not evenly divisible by 4*sizeof(float).\""
- "this->size() * kNumParameters * sizeof(float) == static_cast<size_t>(CFDataGetLength(data)) && \"Input array not evenly divisible by 5*sizeof(float).\""
- "this->size() * kNumParameters * sizeof(float) == static_cast<size_t>(CFDataGetLength(points)) && \"Input array not evenly divisible by 3*sizeof(float).\""
- "total_size < std::numeric_limits<uint32_t>::max() && \"Given data block is too big to be represented by uint32_t indexed ArrayView\""
- "total_weight > 0.f && \"All weights are zero\""
- "tr_world_to_frame.has_value() && \"Expect to have valid transformation.\""
- "tracked_kfs_pose.size() >= GenericGlobalReferenceSystem::kMinimumGraphSizeForGlobalPoseEstimation && \"Graph too small to process.\""
- "tracking_status_prev != GlobalAnchorUninitialized && \"Expect tracking status initialized\""
- "trajectory"
- "trajectory_file && \"Trajectory file cannot be created\""
- "trs_world_to_frame_.size() == raster_depths_.size() && \"poses and depths size do not match\""
- "trs_world_to_frame_.size() == raster_normals_.size() && \"poses and normals size do not match\""
- "trs_world_to_frame_.size() == raster_semantics_.size() && \"poses and semantics size do not match\""
- "uncertainty && \"Uncertainty image should be present to generate confidence image!\""
- "unscaled_conf.Empty() ^ unscaled_uncertainty.Empty() && \"Expect exactly one of confidence or uncertainty\""
- "utils::CheckKeyframeResult(engine_result.keyframes_updated) && \"Keyframes should have unique uuids\""
- "utils::ResultTypeInputDropped(keyframe_engine_result.Type())"
- "uuid_opt && \"failed to convert CFUUIDRef to random::UUID\""
- "verify_backlog(publishing_backlog_) && \"Update only in pending or droppable\""
- "vertex_planes_connected.size() == vertices.size()"
- "vertices.size() == vertex_planes.size()"
- "vertices.size() > 2 && \"verteics.size() must be large than 2.\""
- "vimage_err == kvImageNoError && \"Failed to apply Gaussian smoothing (x)\""
- "vimage_err == kvImageNoError && \"Failed to apply Gaussian smoothing (y)\""
- "vm_mapper_bundle.adaptor != nullptr && \"No valid adaptor\""
- "volumetric && \"Only for volumetric mapper\""
- "voxel_block_table.NeighborCacheType() == NeighborCache::Fifteen && \"Block table is expected to cache 15 neighbors\""
- "voxel_size > 0.f && \"Invalid voxel size.\""
- "warped_surface && \"Invalid warped surface!\""
- "warped_surfaces_mask && \"Even though it was requested to write warping\" \"results, the mask for the desired surfaces is 0(no desired surfaces).\""
- "width == camera.width() && height == camera.height() && \"Provided depthmap must have the same dimension with input camera.\""
- "work_group_ != nullptr && \"Failed to create workgroup.\""
- "worker && \"Callable must be valid\""
- "{ KeyVolEventAnchorRemoval }"
- "⚠️⚠️⚠️: Depth image is not in cache. Request mesh depth can be expensive."

```
