## AppleCV3D

> `/System/Library/PrivateFrameworks/AppleCV3D.framework/AppleCV3D`

```diff

-6.31.53.0.0
-  __TEXT.__text: 0x1617ce4
-  __TEXT.__auth_stubs: 0x2d90
+6.58.55.0.0
+  __TEXT.__text: 0x1bd3e28
+  __TEXT.__auth_stubs: 0x31e0
   __TEXT.__init_offsets: 0x14
-  __TEXT.__const: 0x124290
-  __TEXT.__gcc_except_tab: 0x8fe00
-  __TEXT.__cstring: 0x72314
-  __TEXT.__oslogstring: 0x1f0b
-  __TEXT.__unwind_info: 0x361c8
-  __TEXT.__eh_frame: 0xe84
-  __TEXT.__objc_methname: 0x2cd
-  __TEXT.__objc_stubs: 0x440
-  __DATA_CONST.__got: 0x440
-  __DATA_CONST.__const: 0x1408
+  __TEXT.__const: 0x12f1ab
+  __TEXT.__gcc_except_tab: 0xf3904
+  __TEXT.__cstring: 0x86b5c
+  __TEXT.__oslogstring: 0xad97
+  __TEXT.__unwind_info: 0x3fa8c
+  __TEXT.__eh_frame: 0xebc
+  __TEXT.__objc_methname: 0x2fd
+  __TEXT.__objc_stubs: 0x4a0
+  __DATA_CONST.__got: 0x488
+  __DATA_CONST.__const: 0x1b78
   __DATA_CONST.__objc_imageinfo: 0x8
-  __DATA_CONST.__objc_selrefs: 0x110
-  __AUTH_CONST.__const: 0x69c00
-  __AUTH_CONST.__cfstring: 0x1820
-  __AUTH_CONST.__auth_got: 0x16d8
+  __DATA_CONST.__objc_selrefs: 0x128
+  __DATA_CONST.__objc_classrefs: 0x68
+  __AUTH_CONST.__const: 0x70430
+  __AUTH_CONST.__cfstring: 0x14c0
+  __AUTH_CONST.__auth_got: 0x1900
   __AUTH.__const_weak: 0x70
-  __AUTH.__data: 0x30
+  __AUTH.__data: 0x88
   __DATA.__got_weak: 0x38
-  __DATA.__objc_classrefs: 0x60
-  __DATA.__data: 0x18da8
-  __DATA.__crash_info: 0x40
+  __DATA.__data: 0x1aa20
   __DATA.__thread_vars: 0x30
+  __DATA.__crash_info: 0x40
   __DATA.__thread_bss: 0x30
-  __DATA.__bss: 0x1870
-  __DATA.__common: 0x28
+  __DATA.__bss: 0x7510
+  __DATA.__common: 0x48
   __DATA_DIRTY.__common: 0x18
   __DATA_DIRTY.__bss: 0x18
   - /System/Library/Frameworks/Accelerate.framework/Accelerate

   - /System/Library/PrivateFrameworks/CMCapture.framework/CMCapture
   - /System/Library/PrivateFrameworks/CMPhoto.framework/CMPhoto
   - /System/Library/PrivateFrameworks/CoreAnalytics.framework/CoreAnalytics
+  - /System/Library/PrivateFrameworks/DiagnosticRequest.framework/DiagnosticRequest
   - /System/Library/PrivateFrameworks/Espresso.framework/Espresso
   - /System/Library/PrivateFrameworks/LACC.framework/LACC
   - /System/Library/PrivateFrameworks/LearnedFeatures.framework/LearnedFeatures

   - /usr/lib/libc++.1.dylib
   - /usr/lib/libobjc.A.dylib
   - /usr/lib/librealtime_safety.dylib
-  UUID: B468482C-F99B-3C6C-95BF-EEB786EB02CC
-  Functions: 44036
-  Symbols:   1720
-  CStrings:  7816
+  UUID: 4D45B85A-A456-32D2-880C-A62086229341
+  Functions: 48994
+  Symbols:   1787
+  CStrings:  11014
 
Symbols:
+ _CFCopyTypeIDDescription
+ _CFDataCreateWithBytesNoCopy
+ _CFDictionaryCreate
+ _CFEqual
+ _CFNumberGetType
+ _CGColorSpaceCreateDeviceCMYK
+ _CGColorSpaceCreateDeviceGray
+ _CGColorSpaceCreateDeviceRGB
+ _CGColorSpaceGetModel
+ _CGColorSpaceGetNumberOfComponents
+ _CGDataConsumerCreate
+ _CGDataProviderCopyData
+ _CGDataProviderCreateSequential
+ _CGDataProviderCreateWithCFData
+ _CGImageCreate
+ _CGImageDestinationAddImage
+ _CGImageDestinationCreateWithDataConsumer
+ _CGImageDestinationFinalize
+ _CGImageGetAlphaInfo
+ _CGImageGetBitmapInfo
+ _CGImageGetBitsPerComponent
+ _CGImageGetBitsPerPixel
+ _CGImageGetByteOrderInfo
+ _CGImageGetBytesPerRow
+ _CGImageGetColorSpace
+ _CGImageGetDataProvider
+ _CGImageGetHeight
+ _CGImageGetPixelFormatInfo
+ _CGImageGetWidth
+ _CGImageSourceCreateImageAtIndex
+ _CGImageSourceCreateWithDataProvider
+ _CV3DDiagnosticsContextCreateWithFileDestination
+ _CV3DDiagnosticsContextGet
+ _CV3DDiagnosticsContextRecordText
+ _CV3DDiagnosticsContextRelease
+ _CV3DDiagnosticsContextRetain
+ _CV3DDiagnosticsContextRunAndCreateResults
+ _CV3DDiagnosticsRunOptionsCreate
+ _CV3DDiagnosticsRunOptionsCreateForSysdiagnose
+ _CV3DDiagnosticsRunOptionsGetArchivingEnabled
+ _CV3DDiagnosticsRunOptionsGetCauseDescription
+ _CV3DDiagnosticsRunOptionsGetCauseMachContinuousTime
+ _CV3DDiagnosticsRunOptionsGetCauseName
+ _CV3DDiagnosticsRunOptionsGetDurationLimitSeconds
+ _CV3DDiagnosticsRunOptionsGetMachContinuousTimeLimit
+ _CV3DDiagnosticsRunOptionsGetMemoryLimit
+ _CV3DDiagnosticsRunOptionsRelease
+ _CV3DDiagnosticsRunOptionsRetain
+ _CV3DDiagnosticsRunOptionsSetArchivingEnabled
+ _CV3DDiagnosticsRunOptionsSetCauseDescription
+ _CV3DDiagnosticsRunOptionsSetCauseMachContinuousTime
+ _CV3DDiagnosticsRunOptionsSetCauseName
+ _CV3DDiagnosticsRunOptionsSetDurationLimitSeconds
+ _CV3DDiagnosticsRunOptionsSetMachContinuousTimeLimit
+ _CV3DDiagnosticsRunOptionsSetMemoryLimit
+ _CV3DDiagnosticsRunResultsGetError
+ _CV3DDiagnosticsRunResultsGetErrorCode
+ _CV3DDiagnosticsRunResultsGetOutputPathAtIndex
+ _CV3DDiagnosticsRunResultsGetOutputPathCount
+ _CV3DDiagnosticsRunResultsRelease
+ _CV3DDiagnosticsRunResultsRetain
+ _CV3DSLAMAnchorUpdateIsPauseFinished
+ _CV3DSLAMCalibrationCameraVideoModeIsSupported
+ _CV3DSLAMCameraVideoModeGetDescription
+ _CV3DSLAMCameraVideoModeHeight
+ _CV3DSLAMCameraVideoModeIsSuperWide
+ _CV3DSLAMCameraVideoModeIsWide
+ _CV3DSLAMCameraVideoModeWidth
+ _CV3DSLAMInitializeVisualLoggerFromString
+ _CV3DSLAMStateCopyLoadedMapTimestamps
+ _CV3DSLAMStateGetCameraAllocationPerCamera
+ _CV3DSLAMStateGetSmudgeInfo
+ _CV3DSLAMStateHasLoadedMaps
+ _CV3DSLAMVisualLoggerDisable
+ _CV3DSLAMVisualLoggerEnable
+ _CV3DSLAMVisualLoggerInitializeFileLogger
+ _CV3DSLAMVisualLoggerInitializeNetworkLogger
+ _DRTailspinRequest
+ _OBJC_CLASS_$_NSNumber
+ __ZN4lacc7LaccABI14dump_registersERNS_13CallInterfaceE
+ __ZNK13lacc_hardware12LaccHardwarecvRN4lacc13CallInterfaceEEv
+ __ZNK13lacc_hardware12LaccHardwarecvRN4lacc15ConfigInterfaceEEv
+ __ZNKSt3__14__fs10filesystem4path6__stemEv
+ __ZNSt3__113basic_istreamIcNS_11char_traitsIcEEE5seekgExNS_8ios_base7seekdirE
+ __ZNSt3__113basic_istreamIcNS_11char_traitsIcEEErsERi
+ __ZNSt3__113basic_istreamIcNS_11char_traitsIcEEErsERm
+ __ZNSt3__113basic_istreamIcNS_11char_traitsIcEEErsERs
+ __ZNSt3__113basic_istreamIcNS_11char_traitsIcEEErsERt
+ __ZNSt3__113basic_istreamIcNS_11char_traitsIcEEErsERx
+ __ZNSt3__113basic_istreamIcNS_11char_traitsIcEEErsERy
+ __ZNSt3__115__thread_structC1Ev
+ __ZNSt3__115__thread_structD1Ev
+ __ZNSt3__118condition_variable10notify_oneEv
+ __ZNSt3__118condition_variable15__do_timed_waitERNS_11unique_lockINS_5mutexEEENS_6chrono10time_pointINS5_12system_clockENS5_8durationIxNS_5ratioILl1ELl1000000000EEEEEEE
+ __ZNSt3__118condition_variable4waitERNS_11unique_lockINS_5mutexEEE
+ __ZNSt3__119__shared_mutex_base11lock_sharedEv
+ __ZNSt3__119__shared_mutex_base13unlock_sharedEv
+ __ZNSt3__119__shared_mutex_base4lockEv
+ __ZNSt3__119__shared_mutex_base6unlockEv
+ __ZNSt3__119__shared_mutex_baseC1Ev
+ __ZNSt3__119__thread_local_dataEv
+ __ZNSt3__120__throw_system_errorEiPKc
+ __ZNSt3__14stodERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPm
+ __ZNSt3__14stofERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPm
+ __ZNSt3__16thread4joinEv
+ __ZNSt3__16threadD1Ev
+ __ZNSt3__18ios_base4moveERS0_
+ __ZNSt9exceptionD1Ev
+ __ZTISt12bad_any_cast
+ __ZTVSt12bad_any_cast
+ __ZTVSt9exception
+ __ZnamSt11align_val_t
+ ___darwin_check_fd_set_overflow
+ ___toupper
+ __os_log_pack_fill
+ __os_log_pack_size
+ __os_signpost_emit_unreliably_with_name_impl
+ _accept
+ _close
+ _connect
+ _espresso_plan_get_error_info
+ _fcntl
+ _freeaddrinfo
+ _getaddrinfo
+ _getpid
+ _getsockname
+ _getsockopt
+ _inet_ntop
+ _kCFAllocatorNull
+ _kCFErrorFilePathKey
+ _kCFErrorLocalizedDescriptionKey
+ _kCV3DDiagnosticsErrorCodeInternalException
+ _kCV3DDiagnosticsErrorCodeInvalidArgument
+ _kCV3DDiagnosticsErrorCodeNoError
+ _kCV3DDiagnosticsErrorCodeUnknownError
+ _kCV3DSLAMJasperPointCloudProjectorModeMacro
+ _nanosleep
+ _objc_autorelease
+ _objc_release_x21
+ _objc_release_x24
+ _objc_release_x25
+ _objc_release_x26
+ _objc_release_x27
+ _objc_release_x28
+ _objc_retainAutoreleasedReturnValue
+ _objc_retain_x21
+ _objc_retain_x22
+ _objc_retain_x23
+ _objc_retain_x24
+ _os_log_pack_send
+ _os_retain
+ _pthread_create
+ _pthread_setname_np
+ _pthread_setspecific
+ _pthread_threadid_np
+ _recv
+ _select
+ _send
+ _setsockopt
+ _shutdown
+ _socket
+ _strerror
+ _timespec_get
+ _vm_allocate
- _CFArrayCreate
- _CFStringCompare
- _CFStringCreateWithCString
- _CFStringGetCStringPtr
- _CV3DAnchorGeodesicDistanceArrayCreate
- _CV3DAnchorGeodesicDistanceArrayGetPtr
- _CV3DAnchorGeodesicDistanceArrayRelease
- _CV3DAnchorGeodesicDistanceArraySize
- _CV3DBaOptimizerAddAnchor
- _CV3DBaOptimizerAddPlanes
- _CV3DBaOptimizerCreateDataHandle
- _CV3DBaOptimizerExtractInputAnchors
- _CV3DBaOptimizerExtractInputPlanes
- _CV3DBaOptimizerGetRefinedPose
- _CV3DBaOptimizerInputAnchorsCopy
- _CV3DBaOptimizerInputPlanesCopy
- _CV3DBaOptimizerOutputPosesCopy
- _CV3DBaOptimizerReleaseDataHandle
- _CV3DBaOptimizerRun
- _CV3DBaOptimizerUpdateAnchor
- _CV3DCCCreate
- _CV3DCCInitialize
- _CV3DCCPushAccel
- _CV3DCCPushFeaturePoints
- _CV3DCCPushFrame
- _CV3DCCPushGyro
- _CV3DCCRelease
- _CV3DCCSetHomographyCallback
- _CV3DCCSetHomographyCallbackV2
- _CV3DPlaneDetectionGetSemanticLabelList
- _CV3DPlaneDetectionPlaneMergedIds
- _CV3DPlaneDetectionPolygonAtIndex
- _CV3DPlaneDetectionPolygonListLength
- _CV3DPlaneDetectionPolygonPointsNum
- _CV3DPlaneDetectionPolygonPointsRawPtr
- _CV3DPlaneDetectionSemanticLabelAtIndex
- _CV3DPlaneDetectionSemanticLabelListLength
- _CV3DPlaneDetectionSingleShotPlaneAtIndex
- _CV3DPlaneDetectionSingleShotPlaneExtentPolygons
- _CV3DPlaneDetectionSingleShotPlaneGetUncertainty
- _CV3DPlaneDetectionSingleShotPlaneListLength
- _CV3DPlaneDetectionSingleShotPlaneMergedUUID
- _CV3DPlaneDetectionSingleShotPlaneNormal
- _CV3DPlaneDetectionSingleShotPlaneSupport
- _CV3DPlaneDetectionSingleShotPlaneTransformationToWorld
- _CV3DPosePredictionConfigDisableSmoothing
- _CV3DPosePredictionConfigDisableStateClamping
- _CV3DPosePredictionConfigEnableSmoothing
- _CV3DPosePredictionConfigEnableStateClamping
- _CV3DPosePredictionConfigSetShouldFilterStaticJitter
- _CV3DPosePredictionConfigSetSmoothingWeight
- _CV3DSLAMConfigCalcMaxNumberOfFeatures
- _CV3DSLAMConfigConsistencyCheck
- _CV3DSLAMConfigDisableCameraSwitchingAndUseSecondaryCamera
- _CV3DSLAMConfigDisableStateClamping
- _CV3DSLAMConfigEnableBodyCropping
- _CV3DSLAMConfigEnableMultiFramePoseRefiner
- _CV3DSLAMConfigEnableRangingBasedRelocalization
- _CV3DSLAMConfigEnableReprojectionTracker
- _CV3DSLAMConfigEnableStateClamping
- _CV3DSLAMConfigSaveHighFrequencyTrajectories
- _CV3DSLAMConfigSetDataVerificationIMUParams
- _CV3DSLAMConfigSetMLDescriptorsFromCFData
- _CV3DSLAMConfigSetMinNumSuccessfullFramesToSwitchToVIO
- _CV3DSLAMConfigSetMinimumLux
- _CV3DSLAMConfigSetNumberJasperFramesToSelect
- _CV3DSLAMConfigSetSmoothingWeight
- _CV3DSLAMConfigUseMultiplePrimaryCameras
- _CV3DVIOAddIMUCalibrationToDictionary
- _CV3DVIOAddIMUCalibrationToDictionaryV2
- _CV3DVIOAddIMUCalibrationToDictionaryV3
- _CV3DVIOFillDebugHandle
- _CV3DVIOGetAVCaptureConfig2
- _CV3DVIOGlobalOptimizeMapAndTrajectory
- _CV3DVIOIsDeviceSupported
- _CV3DVIOSetOutputMapPoints
- _CV3DVIOSetPoseCallback2ForReconstruction
- _IsCV3DVIOVideoModeSupported
- __ZN13lacc_hardware12LaccHardwarecvRN4lacc13CallInterfaceEEv
- __ZN13lacc_hardware12LaccHardwarecvRN4lacc15ConfigInterfaceEEv
- __ZNKSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE2atEm
- __ZNKSt3__115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEE3strEv
- __ZNSt12domain_errorD2Ev
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEPKc
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEPKc
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEPKcm
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6insertEmPKc
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_mmRKS4_
- __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEaSEc
- __ZNSt3__115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEE3strERKNS_12basic_stringIcS2_S4_EE
- __os_signpost_emit_with_name_impl
- _dgeev$NEWLAPACK
- _gmtime_r
- _kCV3DCC_CalibrationForDeviceModel
- _kCV3DCC_CameraVideoMode
- _kCV3DCC_FrameFirmwareTimestamp
- _strncpy
CStrings:
+ "\tconstrains "
+ "\tforms an independent set (consider using Schur solver)\n"
+ "\tout of that "
+ "\treferenced by "
+ "\tthere are "
+ "\nFactor stats:\n"
+ "\nFrame alternator: "
+ "\nT_I_to_J: \n"
+ "\nVIO Health "
+ "\n[CM]["
+ "\ntlog.logger."
+ "\ntlog.logger.myLogger=NONE, Console, LogFile\ntlog.logger.myLogger.mySubLogger=WARN\n\n"
+ "\n}"
+ "       frame: {"
+ "    ----: traversal dist: "
+ "    Cluster ["
+ "    Found matches plane track %u from anchor frame index %zu (%lu <-> %lu)"
+ "    Normal diff (%lu, %lu) -> ori_diff: %f"
+ "    Reloc debug: "
+ "    ext submap: "
+ "    map alignment: "
+ "    num clusters "
+ "    submap ["
+ "   Track length %zu: %zu"
+ "   query_camera_source: "
+ "   ref submap id: "
+ "  %s: %d inlier measurements (of %d total)."
+ "  Accel timestamps: %f ... %f   { %zu }"
+ "  Done, it took %f"
+ "  Dropping oldest frame!"
+ "  Frame timestamps: %f ... %f   { %zu }"
+ "  Gyro  timestamps: %f ... %f   { %zu }"
+ "  Match plane data %f -> %f"
+ " != "
+ " != 6"
+ " (rad)"
+ " .\\/:*?|<>\""
+ " / "
+ " 2d-2d: "
+ " 2d-3d matches: "
+ " 2d-3d: "
+ " >= "
+ " D`, and restart your device. Alternatively, you can just remove the passcode. Error: "
+ " D`. Error: "
+ " DoF total)\n"
+ " Expected pose smoothing smoothing set is 5"
+ " Frame: "
+ " FrameID: "
+ " Health: "
+ " Inlier ratio: "
+ " Inliers: "
+ " Insufficient: "
+ " Map inliers: "
+ " Map["
+ " Num cams: "
+ " Num inliers in last "
+ " Num inliers map in latest map tracking state "
+ " Num tracks: "
+ " Num_ftrs: "
+ " Percentage short: "
+ " Ratio small res: "
+ " State id: "
+ " StateCorrectionLogic: "
+ " Stationary state: "
+ " Step size: "
+ " Stream "
+ " Submap: "
+ " Summation of Stereo_ftr_cnt: "
+ " Total num residual "
+ " Tracking map: "
+ " [deg] ->"
+ " [ms]"
+ " [ms] "
+ " [pix]"
+ " [pix] "
+ " accel_scale(): "
+ " accel_skew(): "
+ " and argument allow_extrapolate="
+ " and for the used inertial state at timestamp="
+ " and time "
+ " are free ("
+ " as "
+ " avg Vergence angle "
+ " avg: "
+ " because relocalization event"
+ " before newest timestamp"
+ " budget: "
+ " but current sample version is "
+ " but file contains "
+ " but image is of color format "
+ " but must be 8-bit Gray or Rgb to save as pnm."
+ " but pnm file contains "
+ " but should be "
+ " can't be saved with CoreGraphics."
+ " candidate: "
+ " cannot be created with default arguments"
+ " connected to server at "
+ " consistent_avg_propagated_pose: "
+ " converged: "
+ " counter: "
+ " dR(deg): "
+ " data."
+ " device"
+ " dp(m): "
+ " dt(s): "
+ " due to external relocalization"
+ " enabled: "
+ " encountered during loading is unrecognized. A data type ID of 0 indicates a serialization error (e.g. invalid data in the stream)"
+ " encountered during loading is unrecognized. The loader's package version may be too old."
+ " errors:\n"
+ " expected_points: "
+ " false"
+ " for "
+ " for KF classification"
+ " for LPFG."
+ " for logger "
+ " for the inertial state at timestamp="
+ " format, but file contains "
+ " format."
+ " from "
+ " from stream with file format "
+ " from the user defaults but it is absent"
+ " from the user defaults but it is not convertable to a bool"
+ " from the user defaults but it is not convertable to a double"
+ " from the user defaults but it is not convertable to an integer"
+ " from the user defaults with value "
+ " front_latest_state_inlier: "
+ " gyro_scale(): "
+ " gyro_skew(): "
+ " has inlier map factor: "
+ " image dist sq "
+ " imu_stationary "
+ " in "
+ " incompatible with pnm."
+ " inlier: "
+ " inlier: -> "
+ " inlier_cnt: "
+ " into Image of format "
+ " invalid. "
+ " is consistent: "
+ " is during reloc: "
+ " is greater than allowed maximum pose request time of "
+ " is greater than latest accel/gyro timestamps of "
+ " is incompatible with current version "
+ " is not a valid pnm format."
+ " is not found for serialization"
+ " is not serializable"
+ " is not supported for hardware features"
+ " last state_:"
+ " latest stationary "
+ " latest_map_tracking_state_id_: "
+ " latest_map_tracking_state_inlier_track_keys.size(): "
+ " low_health_tracking_state: "
+ " low_texture "
+ " map kfs:"
+ " map optmization count: "
+ " map_latest_state_inlier: "
+ " matched: "
+ " message"
+ " mono-cam inlier_ratio: "
+ " moving std: "
+ " multi-cam inlier_ratio: "
+ " not yet supported."
+ " num of no map measurements: "
+ " num_budget_points: "
+ " num_consecutive_map_tracking: "
+ " num_inler_map_factor_to_constrain_latest_state: "
+ " num_inliers: "
+ " num_pts_after_pruning: "
+ " num_sce_to_pri_streams: "
+ " num_state_correction: "
+ " num_stereo_matches: "
+ " num_temporal_matches: "
+ " of configurator of type "
+ " opt_query_state_id: "
+ " present in the system\n"
+ " present in the system ("
+ " projected: "
+ " query state "
+ " query: {"
+ " recall:"
+ " ref state "
+ " ref submap: "
+ " regular_count: "
+ " reloc_only: "
+ " resetting reference calibration at "
+ " sampled: "
+ " sec, "
+ " severe_low_texture "
+ " size "
+ " size:("
+ " smoothed indicator: "
+ " state correction applied to tracker: "
+ " state correction succeeded: "
+ " state_id: "
+ " stationary "
+ " std: "
+ " stereo_texture_ratio: "
+ " t: "
+ " t<="
+ " target_map_tracking_state_id: "
+ " that do not match the default intriniscs, "
+ " time: "
+ " timestamps: "
+ " to "
+ " to converge"
+ " tracks "
+ " traversal-distance "
+ " updated usage_ratio: "
+ " using the inertial state at timestamp="
+ " vel "
+ " vergence angle: "
+ " vio_moving "
+ " was requested of `Numbers` containing "
+ " weight: "
+ " | cnt: "
+ "!!*this"
+ "!(*near_vio_frame)->is_weak_frame()"
+ "!(*ref_vio_frame)->is_weak_frame()"
+ "!(*var_iter).second.state.isMarginalized() && !(*var_iter).second.state.isRemoved() && track_ptr->isPersistent()"
+ "!(config().enable_ml_descriptors_for_weak_keyframes && config().slam_relocalization_config.use_ml_vlad && config().ml_desc_config.feature_type != feature_detection::FeatureType::DetectorNoneDescriptorATUHardNetGlobalFeat)"
+ "!(config.enable_swproxy_hw_desgen && config.enable_swproxy)"
+ "!(use_hw_feature_points && use_sw_proxy_feature_points)"
+ "!ExactlyEqual(camera_matrix[0], 0.0) && ExactlyEqual(camera_matrix[1], 0.0) && !ExactlyEqual(camera_matrix[2], 0.0) && ExactlyEqual(camera_matrix[3], 0.0) && !ExactlyEqual(camera_matrix[4], 0.0) && !ExactlyEqual(camera_matrix[5], 0.0) && ExactlyEqual(camera_matrix[6], 0.0) && ExactlyEqual(camera_matrix[7], 0.0) && ExactlyEqual(camera_matrix[8], 1.0)"
+ "!ExactlyEqual(track.getStructure()->anchor_row_measurement(), VIOAnchoredPoint3DBase<Float>::kInvalidAnchorRowMeasurement)"
+ "!HasKeypointForRelocalization()"
+ "!HasNans(*user.R_map_keyframe_to_anchor_row_major)"
+ "!HasNans(*user.t_map_keyframe_to_anchor)"
+ "!HasNans(T_G_to_anchor)"
+ "!HasNans(keyframe.R_G_to_anchor_row_major)"
+ "!HasNans(keyframe.t_G_to_anchor)"
+ "!HasNans(user.R_G_to_anchor_row_major_)"
+ "!HasNans(user.t_G_to_anchor_)"
+ "!VIOVFusion().IsInitialized()"
+ "!VisionOnlyVFusion().IsInitialized()"
+ "!accumulated_pos_and_cov_queue_.empty()"
+ "!add_as_weak_keyframe"
+ "!ba_->config().estimate_extrinsics || baid.parameters().use_IMU"
+ "!cd.is_peridot_"
+ "!config_.enable_swproxy_hw_desgen"
+ "!config_.imu_filter_switch_config.enable_imu_filter_motion_switch || (config_.imu_filter_switch_config.enable_imu_filter_motion_switch && config_.imu_extrapolation_config.gyro_filter_config.num_taps == kNumGyroIMUPredTaps && config_.imu_extrapolation_config.gyro_filter_config.max_pred_samples == kNumGyroIMUPredOutputs)"
+ "!config_.imu_filter_switch_config.enable_imu_filter_motion_switch || (config_.imu_filter_switch_config.enable_imu_filter_motion_switch && pose_smoothing_imu_filter_data_.predictor_imu_filtering_config.imu_filter_enable)"
+ "!config_.map_data_dir.empty()"
+ "!config_.pose_filter_config.enable_predictor_pose_filtering || (config_.pose_smoothing_config.use_prev_prop_states && config_.pose_filter_config.enable_predictor_pose_filtering)"
+ "!depth_frames.empty()"
+ "!error_downstream_.empty()"
+ "!filter_->GetCurrentTimestamp().has_value()"
+ "!filter_->IsInitialized()"
+ "!has_secondary_observations || (std::isfinite(meas_dist_secondary[(len - 1)](0)) == std::isfinite(meas_dist_secondary[(len - 1)](1)))"
+ "!has_secondary_observations || kMeasurementSize < 2 || (meas_secondary[observation_index_in_track].e().isFinite().all() == meas_secondary[observation_index_in_track].e().isFinite().any())"
+ "!image_ids_of_state.empty()"
+ "!impl_->state_correction_logic_->HasRelocalizationInfo() && !impl_->state_correction_logic_->HasStateCorrectionRequest()"
+ "!imu_samples_buffer_.empty()"
+ "!loaded->storage->Active()"
+ "!m_fallbackToHostForIteration"
+ "!m_marginalizer.batchedMarginalizationConfig().isEnabled"
+ "!new_structure->ValidStructureCovariance()"
+ "!new_track_structure->ValidStructureCovariance()"
+ "!opt_last_frame_has_good_geometry_in_vio || (GetAdaptiveVIOState() == cv_types::AdaptiveVIOState::kVisionOnlySLAMAndVIOInitialization && opt_last_frame_has_good_geometry_in_vio.value() == last_frame_has_good_geometry_in_current_vfusion)"
+ "!opt_ret"
+ "!ordered"
+ "!pose_and_cov_accumulator()->accumulated_pos_and_cov_queue().empty()"
+ "!pose_smoothing_config.smoothing_set.empty()"
+ "!pred_samples.empty()"
+ "!predictor_state.vision_tracker_pose_metadata"
+ "!primary_camera_streams.empty()"
+ "!reordered_descriptors_valid_"
+ "!ret.second"
+ "!seed_estimate_.state_ids.empty()"
+ "!state->vision_tracker_pose_metadata"
+ "!state_.is_pause_finished || force_reinitialization_failure_"
+ "!state_imus.empty()"
+ "!state_set->empty()"
+ "!std::isnan(feature_sigma)"
+ "!std::isnan(lens->MinimumHalfFOV())"
+ "!std::isnan(pt_dist)"
+ "!std::isnan(trace)"
+ "!std::isnan(vision_models.back().lens_model()->MinimumHalfFOV())"
+ "!std::isnan(vision_models.front().lens_model()->MinimumHalfFOV())"
+ "!this->RelocalizationVerificationInProgress()"
+ "!this->bad_geometry_in_last_frame_.first"
+ "!this->config().bundle_adjuster_config.running_as_light_ba"
+ "!this->latest_vfusion_kf_state_id_ || state_id != this->latest_vfusion_kf_state_id_.value()"
+ "!this->opt_reloc_info_"
+ "!this->opt_request_"
+ "!this->viostate_variable_ids_.empty()"
+ "!track_set.findTrack(new_track_key)"
+ "!track_trail_went_cold"
+ "!use_lens_model_during_detection_"
+ "!vfusion().IsInitialized()"
+ "!vfusion().IsUsingIMU()"
+ "!window.FullWindowMode()"
+ "!window.frame_ids().empty()"
+ "# ----------------------------------------\n# Appenders:\n# ----------------------------------------\n# Appenders can have any name and can be used by multiple loggers.\n\n# ConsoleAppender logs to stdout/stderr\ntlog.appender.Console=tlog.ConsoleAppender\ntlog.appender.Console.layout=tlog.PatternLayout\ntlog.appender.Console.levelFilter=ALL\n# Verbose Pattern:\ntlog.appender.Console.layout.conversionPattern=%d [%t] %p %c (%F:%L,%f):%m%n\n# Brief Pattern:\n#tlog.appender.Console.layout.conversionPattern=%r %p %c (%F:%L):%m%n\n\n# FileAppender logs to a log file\ntlog.appender.LogFile=tlog.FileAppender\ntlog.appender.LogFile.filePath=Log.txt\ntlog.appender.LogFile.maxFileSize=1MB\ntlog.appender.LogFile.maxBackupIndex=10\ntlog.appender.LogFile.layout=tlog.PatternLayout\ntlog.appender.LogFile.layout.ConversionPattern=%d [%t] %p %c (%F:%L,%f):%m%n\ntlog.appender.LogFile.levelFilter=ALL\n"
+ "# ----------------------------------------\n# Logger Configuration:\n# ----------------------------------------\n# Configure loggers of the hierarchy with:\n#    'tlog.logger.{name}={LogLevel}, [CLEAR], [{Appender}, ..]'\n\n# Level NONE is default for all loggers and makes them use their parent's log level\n# The optional token 'CLEAR' will remove all appenders from the logger if it already exists\n# Every logger will always use all appenders of all it's parents.\n"
+ "# ----------------------------------------\n# Parameter Cheatsheet:\n# ----------------------------------------\n\n# Log levels:\n# TRACE, DEBUG, INFO, WARN, ERROR, FATAL\n# NONE (default for non-root) will use the closest parent's log level\n\n# Parameter tokens (optional logger parameters after {Log Level}):\n# CLEAR : deletes existing appenders of the logger before adding new ones\n\n# Log level filters (for PatternLayout.levelFilter):\n# TRACE, DEBUG, INFO, WARN, ERROR, FATAL, ALL, NONE,\n# TRACE_TO_FATAL, ... , ERROR_TO_FATAL\n\n# Pattern Format string tokens (for PatternLayout.conversionPattern):\n# %d : local date in ISO 8601 format (YYYY-MM-DD HH:MM:SS,mmm)\n# %r : milliseconds since creation of the first pattern formatter until creation\n#      of the logging event\n# %t : thread identification (hash of this_thread::thread_id)\n# %p : priority (log level)\n# %c : category of the message (logger name)\n# %m : log message\n# %n : system specific line separator\n# %F : file where the log was requested\n# %L : line number where the log was requested\n# %f : function where the log was requested\n# %% : a single %-sign"
+ "# ----------------------------------------\n# Root Logger:\n# ----------------------------------------\n# (Avoid using the root logger in your program directly, but create\n#  a child logger instead, since other libraries may overwrite the\n#  root logger with a conflicting configuration)\n"
+ "# Keyframes: "
+ "# TODO: Remove Console and LogFile appenders from root!\ntlog.rootLogger=INFO, Console, LogFile\n\n"
+ "# The 'CLEAR'-token removes the default log appender from the root logger!\ntlog.rootLogger=INFO, CLEAR\n\n"
+ "# Tracks: "
+ "%020llu"
+ "%5u: %-20s  (%zu)"
+ "%d"
+ "%d (%f) | "
+ "%s AnchorIONode recieved an error"
+ "%s AnchorIONode recieved an error with message [%s]"
+ "%s duration: %.5fs"
+ "%s skip loading camera extrinsics based on application defaults."
+ "%s skip loading camera extrinsics based on initialization parameters."
+ "%s."
+ "%sabling output sliding-window estimate in pose metadata"
+ "%sabling scan-order Laplacian readout"
+ "%{public}s (%{public}s) %{public}s"
+ "&vfusion() == &VisionOnlyVFusion()"
+ "'\nResource access in this folder may fail, as the target has not been ENABLED for execution."
+ "' (must only consist of letters, numbers and underscores)."
+ "' added twice"
+ "' already exists in diagnostics engine. Give storages a unique name."
+ "' already exists in the map of available Appender parameter types. Aborting.\n"
+ "' already exists in the map of available Appender types. Skipping.\n"
+ "' at "
+ "' data type id "
+ "' diagnostics ("
+ "' encountered during loading is unrecognized. An empty package name indicates a serialization error (e.g. invalid data in the stream)"
+ "' encountered during loading is unrecognized. To load data of this package, add the corresponding `Package` to the package-list in `SharedDataSample` or importer constructor or arguments by using the 'PackageList' function"
+ "' failed: call site #"
+ "' for configurator of type "
+ "' for parameter "
+ "' sequence protocol version "
+ "' was given"
+ "' was given."
+ "'("
+ "', expected "
+ "'. Expected pattern 'major.minor.revision'"
+ "'. Info file '"
+ "'. Reason: "
+ "'}"
+ "(!this->config().avoid_prune_external_submaps_to_empty || reanchored)"
+ "(!this_->config().adaptive_vio_logic_config.enable_adaptive_vio || this_->config().is_visual_slam_enabled)"
+ "(*calib_var_iter).second.variable.NumRegisteredTracks() == 0"
+ "(*camera_mask) && *(camera_mask + (len - 1))"
+ "(*first_state).front().timestamp < base_t"
+ "(*var_iter).second.state.isMarginalized() || (*var_iter).second.state.isRemoved()"
+ "(accelerometer_meas_.empty() || accelerometer_meas_.back().timestamp < accel_meas.timestamp)"
+ "(area_binning_num_bins_1d > 0 && gaussian_kernel_sigma > 0)"
+ "(block_cols + flint_info_offsets[colBlockIdx]) <= flint_info.columns()"
+ "(buffer_cameras_dest == buffer_cameras_end) || enforce_anchor_camera_only_triangulation_of_non_anchored_states"
+ "(buffer_tracks_dest == buffer_tracks_end) || enforce_anchor_camera_only_triangulation_of_non_anchored_states"
+ "(bytes_per_row % bytes_per_pixel == 0)"
+ "(confidence32_img_owner && *confidence32_img_owner)"
+ "(config_.imu_filter_switch_config.enable_imu_filter_motion_switch && config_.imu_extrapolation_config.gyro_filter_config.RLS_filter_mode == RLSTrainingFilterModes::MotionIMUFilteringSmooth) || (!config_.imu_filter_switch_config.enable_imu_filter_motion_switch && config_.imu_extrapolation_config.gyro_filter_config.RLS_filter_mode != RLSTrainingFilterModes::MotionIMUFilteringSmooth)"
+ "(config_.navigation_config.pose_tracker_config .run_pnp_after_epipolar_outlier_rejection_in_visual_slam || config_.navigation_config.pose_tracker_config.outlier_rejection_config .use_p3p_estimator_for_primary_stream_in_stereo)"
+ "(config_.permutation_matrix.empty() || config_.permutation_matrix.size() == kBitsPerFreakDescriptor)"
+ "(count == kBitsPerFreakDescriptor || ss.peek() == ',')"
+ "(curr_imu_it + 1)->timestamp > curr_imu_it->timestamp"
+ "(depth32_img_owner && *depth32_img_owner)"
+ "(edge.T_source_to_neighbor && edge.JtJ_source_to_neighbor)"
+ "(feat_idx < image_features_.size() && feat_idx >= 0)"
+ "(frame_downsampler_ != nullptr) != ExactlyEqual(result_upsampling_ratio_, 1.0)"
+ "(front_end_result.vfusion_return == VFusionReturn::kVFusionTakeStep || impl_->reinit_logic_controller_->state().maybe_reason_for_re_initialization)"
+ "(gyro_meas_.empty() || gyro_meas_.back().timestamp < gyro_meas.timestamp)"
+ "(image_id == ref_frame_image_id1 || image_id == ref_frame_image_id2)"
+ "(lf_feature_type == kDetectorNoneDescriptorHardnet || lf_feature_type == kDetectorNoneDescriptorATUHardNetGlobalFeat)"
+ "(lhs.metadata && !lhs.metadata->frames_info.empty())"
+ "(m_skipHWCalls || (ok2 && *ok2))"
+ "(m_skipHWCalls || ok)"
+ "(mesh.colors.size() == 0 || mesh.colors.size() == mesh.vertices.size())"
+ "(mesh.colors_type == TriMeshMetadataType::PerVertex || mesh.colors_type == TriMeshMetadataType::Unknown)"
+ "(mesh.normals_type == TriMeshMetadataType::PerVertex || mesh.normals_type == TriMeshMetadataType::Unknown)"
+ "(mesh.tex_faces.size() == 0)"
+ "(mesh.tex_faces.size() == mesh.faces.size())"
+ "(new_base_state_id - oldest_acc_pose_and_cov.state_id0) <= (oldest_acc_pose_and_cov.state_id0 - new_base_state_id)"
+ "(new_map_track->getTrackLength() == 1u)"
+ "(num_buckets_x == 1 && num_buckets_y == 1)"
+ "(num_variables == 0)"
+ "(oldest_acc_pose_and_cov.state_id1 - new_base_state_id) <= (new_base_state_id - oldest_acc_pose_and_cov.state_id1)"
+ "(pixels_per_bin_u_ != 0 && pixels_per_bin_v_ != 0)"
+ "(prop_states_.empty() || prop_states_.back().timestamp < timestamp)"
+ "(relative_pos_and_cov_queue_.front().state_id0 - new_base_state_id) <= (new_base_state_id - relative_pos_and_cov_queue_.front().state_id0)"
+ "(ret == AddPoseGraphEdgeReturn::kAddedNewEdge || ret == AddPoseGraphEdgeReturn::kSkipDueToDuplicatedEdge)"
+ "(rhs.metadata && !rhs.metadata->frames_info.empty())"
+ "(start + block_size * kNumRegionOfInterestBlocks <= dimension)"
+ "(states_.empty() || states_.back().timestamp < timestamp)"
+ "(std::isfinite(meas_dist_secondary[len - 1](0)) == std::isfinite(meas_dist_secondary[len - 1](1)))"
+ "(stream_id == 0 || stream_id == 1)"
+ "(this->camera_extrinsics_variable_ids_.size() == 0)"
+ "(use_baid_type1_ == !config.use_lp_fg || (!vio_baid1_ && !vio_baid2_ && !cached_vio_baid1_ && !cached_vio_baid2_))"
+ "(variable_offset + DIM) <= hessian.rows()"
+ "(vio::math::L2Norm4(anchor_plane_in.data()) >= 1e-6)"
+ ") "
+ ") for configurator of type "
+ ") in modified list was empty."
+ ") with ID '"
+ "), "
+ "). Add an appender before accessing its parameters."
+ "): "
+ ")]."
+ ")}"
+ "********************"
+ "*camera_mask && *(camera_mask + static_cast<ptrdiff_t>(len - 1u))"
+ "*est_period > 0."
+ "*prev_state_timestamp_iter <= query_timestamp && *next_state_timestamp_iter >= query_timestamp"
+ "*prior_inverse_sigma > 0"
+ "+FastMotion"
+ "+FastRotation"
+ "+LowFeatureCoverage"
+ ", \n"
+ ", Size: "
+ ", active: "
+ ", bits_per_component="
+ ", bits_per_pixel="
+ ", but is not supported by "
+ ", conservative track mode: "
+ ", cx,cy: "
+ ", dropped="
+ ", dst: "
+ ", error: "
+ ", expected "
+ ", expected [Algebra|Affine][F|D]"
+ ", expected [Center|Corner][Pinhole|Heikkila][F|D]"
+ ", expected [u|i|f][{size}]"
+ ", expected one of "
+ ", float_components="
+ ", get_current_state_ids().front(): "
+ ", health: "
+ ", k1,k2,p1,p2,k3: "
+ ", keyframe clusters:"
+ ", max queue size "
+ ", max_residual="
+ ", min="
+ ", reason: "
+ ", reloc_only="
+ ", server object has been destroyed"
+ ", transform:"
+ ", type "
+ ", values = {\n"
+ ", xc="
+ ", |residual|="
+ "----\n"
+ "---- kd_id:{"
+ "----transmit reloc_result from "
+ "-> "
+ "-> ("
+ ". File could not be opened."
+ ". File is not empty."
+ ". Invalid default logger name '"
+ ". Minimum version required is "
+ ". Missed camera stream IDs:"
+ ". track_ids size: "
+ ".csv"
+ ".json"
+ ".obj"
+ ".png"
+ ".tiff"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/AppleCV3D/AppleCV3D_framework/src/CV3DDiagnostics.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Essentials/IO/include/Essentials/IO/Archive.h"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Essentials/Thread/src/DispatchQueue.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Essentials/Thread/src/DispatchQueueTypeUtil.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Container/src/Lines.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Container/src/Points.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/CoreGraphics/src/ColorSpaceRef.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/CoreGraphics/src/DataProviderRef.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/CoreGraphics/src/ImageRef.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Diagnostics/include/Kit/Diagnostics/Channel.h"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Diagnostics/include/Kit/Diagnostics/Storage.h"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Diagnostics/src/Triggers.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Foundation/FoundationIO/include/Kit/FoundationIO/DictionaryRefIO.h"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Foundation/src/DictionaryRef.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Image/include/Kit/Image/ImageView.h:1287"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Image/include/Kit/Image/SharedImage.h:1229"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/ImageIO/include/Kit/ImageIO/ImageIO.h"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/ImageIO/src/Apple.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/ImageIO/src/ImageDestinationRef.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/ImageIO/src/ImageIO.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/ImageIO/src/Pnm.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/ImageIO/src/Serialization.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Mesh/include/Kit/Mesh/TriMeshAllocator.h"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Mesh/src/TriMesh.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Mesh/src/TriMeshAllocator.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Mesh/src/TriMeshIO.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Visualization/include/Kit/Visualization/DataIO.h"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Visualization/include/Kit/Visualization/IData.h"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Visualization/src/Client.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Visualization/src/DataIO.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Visualization/src/DataType.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Visualization/src/FileIOPrivate.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Visualization/src/IData.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Visualization/src/NetworkData.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/Analytics/src/InfieldCalibrationCoreAnalytics.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/CAPI/src/VisualLoggerUtils.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/Calibration/src/CalibrationDefaults.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/FeatureDetectionNodeGroup/include_private/VIO/FeatureDetectionNodeGroup/AreaBinningFeatureFilter.hpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/FrameDownsampleNodeGroup/src/FrameDownsampler.cpp:235"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/Odometry/src/AdaptiveVIOLogic.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/Odometry/src/InformativeBaselineDetermination.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/PosePredictor/src/MLPosePredictionConfigUtil.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/UserAnchorNodeGroup/src/AnchorsMap.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/Util/src/Statistics.cpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/VIOEstimator/include/VIO/VIOEstimator/SlidingWindowFilterFGUtil.hpp"
+ "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/VIOEstimator/src/PlaneBasedPointTrackOutlierRejection.cpp"
+ "/System/Library/PrivateFrameworks/AppleCV3D.framework/"
+ "0 < ang_step && ang_step < M_PI_2"
+ "0123456789"
+ "127.0.0.1"
+ "1st state need to match stationary config"
+ "2nd state need to match moving config"
+ "3840x2160"
+ "4-DoF Pose refinement failed. Estimated pose will be used as-is"
+ "6-DoF Pose refinement failed. Estimated pose will be used as-is."
+ "6d pose filters must have same max pred time"
+ ": \n"
+ ": D = "
+ ": Remaining target points: "
+ ": degree = "
+ ": waiting for "
+ "; External anchors: "
+ "; Health: "
+ "; Init Finished: "
+ "; Map Size: "
+ "; Removed anchors: "
+ "; Updated anchors: "
+ "; exporter is exporting only the first encountered timestamp, which was '"
+ "; r = "
+ "< 2 samples in resampled_imu buffer.  Not adding any samples to high speed sensor buffer"
+ "=INFO, Console, LogFile\n\n"
+ "A flag indicating whether to reset mapping module in reinitialization."
+ "A frame was not added because it has no features."
+ "A secondary feature must be assigned to a track either temporal or spatial"
+ "A->B transition time needs to be > 0"
+ "ACTIVITY_LOG_STDERR"
+ "ALC relocalization_ret: "
+ "ALL"
+ "ARKitTriage: !kIsInitializationFinished"
+ "ARKitTriage: !kIsInitialized"
+ "ARKitTriage: %{public}s"
+ "ARKitTriage: Frame Bundle Incomplete Due to Missing Frame at Timestamp "
+ "ARKitTriage: Total Feature Points < %u"
+ "ARKitTriage: kNumberOfInliersTracksInLatestState < %u"
+ "Abort: "
+ "Accel bias estimate from SLAM: %f, %f, %f"
+ "Accel measurement timestamps must be strictly increasing."
+ "Accel sample_time_diff = %lf is less than 0, indicating Accel samples are out of order at Accel timestamp = %lf. Accel sample not added to prediction bundler"
+ "Accel thresholds need to be increasing with higher motion"
+ "Accel: %d. Gyro: %d. Vision: %d (%d). Inlier fraction %f (%zu of %zu)"
+ "Accel: %d. Gyro: %d. Vision: %d (%d). Inlier fraction %f (%zu/%zu)\n\n"
+ "Accelerometer buffer is too full - popping oldest"
+ "Accessing resource path in:\n\t'"
+ "Accumulated pose and cov cannot be empty"
+ "Active group changing from "
+ "Adaptive VIO can only run for Moving SLAM"
+ "Adaptive VIO is not supported in asynchronous mapping/front-end"
+ "Add a keyframe because it has been too long since last keyframe."
+ "Add a keyframe because it's in initialization period."
+ "Add a keyframe because of absolute number of inliers (%d) being too small."
+ "Add a keyframe because of empty parallax."
+ "Add a keyframe because of large parallax: %f."
+ "Add a keyframe because of large rotation (%f deg) and small inlier ratio."
+ "Add a keyframe with ID %d at timestamp %f."
+ "Add a new IMU intrinsic prior factor with factor ID: %d."
+ "Add match with:%llu inliers: %zu"
+ "AddLoopClosureRelativePoseMeasurements"
+ "AddPredictiveMeasurement Failed: Cannot compute prediction filter"
+ "AddPredictiveMeasurement Failed: Filter taps not valid."
+ "AddPredictiveMeasurement failed: Needs to specify prediction time"
+ "AddRLSPredictiveMeasurement Error for predicting timetamp = %lf. Just copying last sample in buffer"
+ "AddSecondaryMeasurements() must be called prior to AddSecondaryMonoMeasurements()"
+ "Adding map measurement for frame "
+ "AffineD"
+ "AffineF"
+ "After BA marginalization.\n"
+ "After BA solve.\n"
+ "After OfflineMapBA"
+ "After optimize: Roll %f, pitch %f, Yaw %f"
+ "After update: "
+ "AlgebraD"
+ "AlgebraF"
+ "All features assigned to one cluster. This is OK, but could be a sign of a problem with the data"
+ "All three stationary. Inliers: "
+ "An octave for fixed-point implementation must be at least 16x16"
+ "An unexpected camera stream was pushed to the bundler."
+ "Anchor must have a group ID set"
+ "Anchor update is NULL"
+ "Anchors:Error:Trying to add an anchor to inactive group %s, active groups are %s"
+ "Anchors:Msg:Anchor removed because of an invalid pose: %s"
+ "Angular speed is : "
+ "Appender parameter string configuration generator with component name '"
+ "Appender string configuration generator with component name '"
+ "ApplyExternalLensUndistortion: id["
+ "Approximate external lens undistortion can be enabled only with Fisheye lens type."
+ "Approximate external lens undistortion is disabled: non fisheye lens model"
+ "Archive can't load BinaryBlob"
+ "AreaBinning: keypoints.size() > sample_size"
+ "Array"
+ "Assertion 'numberOfVariable<PoseVariableType>() <= "
+ "AssignScaleBuckets_Thresholding() does not support spatial buckets."
+ "Asynchronous callback not set"
+ "At initialization, the prior info must be inertial-based (Inertial part can, though, be invalid)"
+ "Attempt to add a new frame into map"
+ "Attempted to list keyframes in an invalid dir [%s]."
+ "Attempted to load extrinsics, but none found."
+ "Attempted to reinitialize mapping with submaps in the queue."
+ "Attempting Relocalization for image: %llu_(%u,%u) against submap: %llu"
+ "Attempting to add existing extrinsics calib. prior factor"
+ "Attempting to add existing intrinsics calib. prior factor"
+ "Attempting to backfill an empty track."
+ "Attempting to load [%llu] with dist %f m."
+ "Auto"
+ "BA pulse (%f seconds / iteration, cost %f)."
+ "BA: %u (%zu states, %zu tracks)"
+ "BA: refinement (%zu states, %zu tracks)"
+ "BAFilterConfig.enable_stereo_based_outlier_rejection"
+ "BAFilterConfig.enforce_anchor_camera_only_triangulation_of_non_anchored_states"
+ "BAFilterConfig.max_rotation_rate_to_enable_stereo_outlier_rejection_rad"
+ "BAFilterConfig.max_stereo_outlier_error_sq_in_std"
+ "BAFilterConfig.max_stereo_track_depth_m"
+ "BAFilterConfig.max_valid_cached_stereo_position_window_s"
+ "BAFilterConfig.min_num_inlier_tracks_to_enable_stereo_outlier_rejection"
+ "BAFilterConfig.min_stereo_outlier_pixel_error_sigma_scaling"
+ "BAFilterConfig.min_stereo_outlier_pixel_error_sigma_scaling_low_light"
+ "BAFilterConfig.num_logged_initial_states"
+ "BFFM: "
+ "Bad Initialization"
+ "Bad Tracking"
+ "Bad file name for FileAppender"
+ "Bad image_processing_width_for_points: %d (setting to 180)"
+ "Bad match index: "
+ "Bad stream"
+ "Base state timestamps must be strictly increasing."
+ "BaselineDeterminationConfig.min_num_triangulated_points_to_drop"
+ "BaselineDeterminationConfig.min_rotation_rate_threshold_deg"
+ "Batched marginalization not expected to be enabled in fallback to host."
+ "Before BA solve.\n"
+ "Before OfflineMapBA"
+ "Before optimize: Roll %f, pitch %f, Yaw %f"
+ "Blob"
+ "Block is NULL"
+ "Blocks must have a unique id"
+ "Body crop boundary vertex is behind the camera."
+ "BodyCropperConfig.body_cropping_enabled"
+ "Bool"
+ "Both coordinates in secondary observation track must be finite or not."
+ "Both enable_swproxy and enable_swproxy_hwdesgen should not be true at the same time."
+ "Buckets histogram is expected to be allocated on input."
+ "Burst mode not available with HWFP mode."
+ "But parameter object has already been created before. Second definition ignored."
+ "Byte order and bits per component do not correspond to a supported format."
+ "Byte order is incompatible."
+ "Byte order is inverted."
+ "Byte order size for non-8 bits per component does not match bits per component."
+ "CCD: "
+ "CCD: %hhu: waiting for %{public}s to converge"
+ "CCD: Abnormal extrinsics calibration update: "
+ "CCD: Abnormal intrinsics calibration update: "
+ "CCD: ChangeDetectorResultExtrinsics: SourceID %u, Rx %f, Ry %f, Rz %f"
+ "CCD: ChangeDetectorResultIntrinsics: Fx %f, Fy %f, Cx %f, Cy %f"
+ "CCD: [%02u] change detection result = %hhu"
+ "CCD: [%02u] num_streams=%u, converged=%{bool}d, fx=%f, fy=%f, cx=%f, cy=%f, rx=%f, ry=%f, rz=%f"
+ "CCD: [%02u] num_streams=%u, result=%hhu, t=%f, dr_deg=[%f, %f, %f], dk=[%f, %f, %f, %f]"
+ "CCD: [%02u][%02u] depth change: #samples=%u, mean=%f, median=%f, mad=%f, median_abs=%f, truncated_mad=%f, p95_abs=%f, max_abs=%f, rms=%f, stddev=%f"
+ "CCD: [%02u][%02u] depth_change=%f, should_update=%{bool}d"
+ "CCD: [%d:%d] num_streams=%zu, t=%f, fx=%f, fy=%f, cx=%f, cy=%f, rx=%f, ry=%f, rz=%f, health=%f, inlier_points=%d, stationary=%d, calibration_enabled=%d, vergence_angle=%f, lux=%e"
+ "CCD: collecting calibration parameters (%u/%zu)"
+ "CCD: parameter variance = [%e, %e, %e, %e, %e, %e, %e]"
+ "CCD: resetting convergence detection due to low confidence (%d)"
+ "CCD: resetting convergence detection due to low health (%f)"
+ "CCD: waiting for confident parameters (%d)"
+ "CCDAnalytics"
+ "CCDChange"
+ "CCDConvergence"
+ "CCDDiff"
+ "CCDIsConverged"
+ "CCDUpdateCalibration"
+ "CF ref argument for `DictionaryValueSample` must be Number, String, Bool, Array or Dictionary, but is "
+ "CFLOG_FORCE_STDERR"
+ "CLEAR"
+ "CMYK"
+ "CV3DMLFeatureDetection: MLDescriptorExtractionUtil: AreaBinning: Bin size should be a round number, image size [w:%i, h:%i], number of bins [w:%lu , h:%lu]"
+ "CV3DMLFeatureDetection: MLDescriptorExtractionUtil: AreaBinning: Invalid image width or height given: [w:%i, h:%i]"
+ "CV3DMLFeatureDetection: MLDescriptorExtractionUtil: AreaBinning: bin index out of bound: %lu, bins size: %lu, image width: %i, image height: %i, x: %f, y: %f"
+ "CV3DMLFeatureDetection: MLDescriptorExtractionUtil: SubsampleKeypoints: Invalid subsampling method specified: %i"
+ "CV3DMLFeatureDetection: MLDescriptorExtractor: could not get ML Model version, LFDescriptorModelVersion returned %i"
+ "CV3DMLFeatureDetection: MLFeatureExtractor: LFDetectAndComputeFeatures return value %i"
+ "CV3DMLFeatureDetection: MLFeatureExtractor: could not get ML Model version, LFDescriptorModelVersion returned %i"
+ "CV3DPosePrediction produced pose at timestamp %f"
+ "CV3DPosePrediction received SLAM state at timestamp %f"
+ "CV3DPosePrediction received frame at timestamp %f for camera id %d and stream id %d"
+ "Call to marginalize did not return as expected: "
+ "Call to marginalize failed: "
+ "Callable must be valid"
+ "Camera"
+ "Camera ID cannot exceeds 16 bits"
+ "Camera ID: %u adjusted disparity fraction to: %f."
+ "Camera descriptor size not match Vfusion camera size"
+ "Camera extrinsics: Camera ID: [%02u]: R_log_x: %f, R_log_y: %f, R_log_z: %f"
+ "Camera feature measuremetns are not aligned as zero based CameraIDs"
+ "Camera has no invalid stereo matches"
+ "Camera incremental pose must exist"
+ "Camera intrinsic focal length is smaller than zero"
+ "Camera intrinsics: Camera ID: [%02u]: fx_b: %f, fy_b: %f, cx_b: %f, cy_b: %f"
+ "Camera matrix must be a valid projection matrix."
+ "Camera must have two streams"
+ "Camera to IMU rotation must be a 3x3 orthogonal matrix."
+ "Camera to IMU translation larger than device dimensions?"
+ "CameraAllocation"
+ "CameraCalibVariables of this type have already been added."
+ "CameraCalibrationEnablerConfig.angular_velocity_stationary_threshold"
+ "CameraCalibrationEnablerConfig.linear_velocity_stationary_threshold"
+ "CameraCalibrationEnablerConfig.low_texture_threshold"
+ "CameraCalibrationEnablerConfig.num_frames_in_sliding_window"
+ "Camera{Type: "
+ "Can't append to sequence '"
+ "CanSerialize(to_serialize.RuntimeFormat(), *op_format)"
+ "Cannot added the marginalized constraint into th graph because there exist one edge already. This should be changed to merge constraint"
+ "Cannot batch in software mode."
+ "Cannot change BAID type once the object is initialized."
+ "Cannot copy CGImage of format "
+ "Cannot create object anchor cm!"
+ "Cannot delete the latest keyframe created by the VFusion front-end"
+ "Cannot enable both hw feature points and sw proxy at the same time!"
+ "Cannot find key frame"
+ "Cannot find node_id1"
+ "Cannot find node_id2"
+ "Cannot find the corresponding camera in viodatabase"
+ "Cannot find the corresponding frame bundle"
+ "Cannot find the feature"
+ "Cannot find the feature in the track"
+ "Cannot find the observation in the track"
+ "Cannot find the pose ref"
+ "Cannot find the state"
+ "Cannot find the state id in the bundle"
+ "Cannot find the track."
+ "Cannot prune the only state in a submap."
+ "Cannot receive. Connection not initialized"
+ "Cannot save data as '"
+ "Cannot send. Connection not initialized"
+ "Cannot set root context to inherit its enable-state"
+ "Cannot unset the track in batched operation."
+ "Cannot update state correction during verification"
+ "Caught exception: "
+ "Center"
+ "CenterHeikkilaD"
+ "CenterHeikkilaF"
+ "CenterPinholeD"
+ "CenterPinholeF"
+ "ChangeDetectionResult"
+ "Changing sliding window size disables headless mode!"
+ "Changing the image width to %d"
+ "Changing the number of features to track to %zu"
+ "Changing the sliding window size to %zu"
+ "Channels per pixel supported is 1, configured value %lu"
+ "Chronological"
+ "Client "
+ "Client cannot receive. Server connection not established."
+ "Client cannot send packet. Server connection not established."
+ "Client failed to connect to server at '"
+ "Client failed to send packet to "
+ "Client received invalid sync command from server."
+ "Client received no configuration from server after connection. This might mean the server could be outdated. Make sure to update VisualLogger server to protocol version 1.3.0+ (or same or newer version as the client)."
+ "ClientSyncUpdate"
+ "Collaborate mapping is disabled on VisionOS."
+ "Collaborative mapping data is not valid"
+ "Collapsing the latest frame."
+ "Collapsing the previous frame."
+ "Color space model "
+ "Color values are premultiplied with alpha."
+ "Compute ML-VLAD image descriptor when GlobalFeat is enabled"
+ "Compute track covariance"
+ "ComputeSamplePeriodEst error.  sample_time_diff = %lf is less than 0."
+ "Concluding Moving Platform IMU-Camera discrepancy at %f, using VIO health heuristics over re-initialization periods"
+ "Connecting to VisualLogger server %s"
+ "Connection already initialized"
+ "Consistent marginalization must be enabled to reach here."
+ "ConsoleAppenderConfigurator::setParameterValue(): "
+ "Contains(expected_camera_stream_ids_, features.camera_stream_id)"
+ "Context may not be nullptr"
+ "ConversionPattern"
+ "Copy path [%s] is non-existent."
+ "CopyCameraFrameRates not supported"
+ "CoreAnalyticsQueue"
+ "Corner"
+ "CornerHeikkilaD"
+ "CornerHeikkilaF"
+ "CornerPinholeD"
+ "CornerPinholeF"
+ "Corrected gravity direction in moving slam. Angles shift: %f   %f   %f\n"
+ "Corrected the pose of the state being added using re-localization before BA. Using camera %u with %lu inliers out of %lu 3D points"
+ "Corresponding VLAD does not exist"
+ "Corrupted external submap cannot have more than 1 odometry edge."
+ "Corrupted states should be in a tail submap. DeleteCorruptedStates() aborted."
+ "Could not accept new client %d: %s (%d)"
+ "Could not obtain application domain ID for user preferences!"
+ "Could not parse the `config_override.json`! If you have passcode enabled, make sure you had run `setclass "
+ "Could not parse the `config_override.json`! If you have passcode enabled, please do not use the path `"
+ "Covariance cannot be nullptr"
+ "Create SLAM session at system time "
+ "Create regular map keyframe "
+ "Create the predictor with the given algorithm %u"
+ "Creating IMU sample buffer"
+ "Creating LUT for "
+ "Cref_to_Ccur.opt_num_triangulated_points_for_pnp_ransac"
+ "Currently not supported"
+ "D factor\n"
+ "D variable\n"
+ "DEBUG_TO_FATAL"
+ "DOG features "
+ "DV:DROP:%{public}s,%f,%f"
+ "DV:LAT:High,%{public}s,%f,%f"
+ "DV:LAT:Low,%{public}s,%f,%f"
+ "DV:RATE:High,%{public}s,%f,%f"
+ "DV:RATE:Low,%{public}s,%f,%f"
+ "Data owner needs to be intialized"
+ "DataVerificationConfig: "
+ "Database can't add frame"
+ "Debug"
+ "Default lens of query VIO Frame is not available"
+ "Default lens of reference VIO Frame is not available"
+ "Default storage name must be 'Default' but '"
+ "Deleting file [%s] with same name as directory."
+ "Dense Depth Model not available."
+ "Deprecated. Use \"TriangulationBasedCalibrationChangeDetectorConfig.max_depth_change\" instead."
+ "Depth sensor mode is not set!"
+ "Depth sensor time-offset %f ms, VIO time-offset(%d): %f ms"
+ "DepthTOF"
+ "Descriptor size mis-match"
+ "DeserializeMapDataSampleToMapDirectory"
+ "Desired image format is "
+ "DetectFeatures not supported for harris tracker"
+ "Device: "
+ "DeviceN"
+ "Diagnostics are already configured. Make sure to call Configure only once, or revert the previous configuration."
+ "Diagnostics storage with ID '"
+ "Dictionary"
+ "Dictionary cannot be serialized. It must only hold Boolean, Number, String, Array or Dictionary values, but contains "
+ "Dictionary to convert to json must only contain Number, String, Bool, Array or Dictionary, but has "
+ "DictionaryData must only contain Number, Boolean, String, Array or Dictionary values, but contains "
+ "Dis"
+ "Disable existing IMU intrinsic prior factor with factor ID: %d."
+ "Disabled"
+ "Disabling extrinsics serialization due to application defaults."
+ "Disabling extrinsics serialization due to initialization parameters."
+ "Disparity fraction for superwide lens in degree."
+ "Does not support Planar mode\n"
+ "Done initializing pose tracker"
+ "Downsampler needs to be provided, unless scaling ratio is exactly 1.0."
+ "Drift ratio to conclude moving platform."
+ "Drop the keyframe because of too few inliers."
+ "Duplicate ML Descriptors from CM in External Map for frame: "
+ "Duplicate ML Descriptors from CM in Localized Map for frame:{%llu,%u,%u}"
+ "Duplicate features arrived! The DataVerificationNode should prevent ever getting here."
+ "Duplicate id detected. Not adding as node."
+ "Duplicate reference image ID, not added to vdb"
+ "Duplicate values found in permutation sequence: not a permutation."
+ "Duplicated key values are not allowed"
+ "Duplicated pose ref. This should not happen"
+ "Duplicated user %llu for session %llu"
+ "ERROR: Calling AddIMUMeasurementFilter with an empty imu_input_buffer."
+ "ERROR_TO_FATAL"
+ "Each block has to be at least 4 pixels big"
+ "Edge "
+ "Edge ("
+ "Edge must have transformation"
+ "Edge transfomation not exist"
+ "Empty DispatchQueueWorkGroup name."
+ "Empty depth measurement frames"
+ "Empty variant lens model invoked."
+ "En"
+ "Enable consistent marginalization (disabled by default)."
+ "Enable debug mode to allow controlling initialization timestamp."
+ "Enable extrinsic estimation in the first frame when the strategy is enabled."
+ "Enable intrinsic estimation in the first frame when the strategy is enabled."
+ "Enable moving screen rejection, requires stereo rejection to be enabled."
+ "Enable plane persistence."
+ "Enable stereo outlier rejection for reducing moving object drift."
+ "Enable thermal model of focal length."
+ "Enable/disable pose filter"
+ "Enabled"
+ "Enabling logging context: %s"
+ "Enabling root logging context"
+ "End should be smaller than size"
+ "Endianness conversion not implemented for this format"
+ "Enforce anchor camera only triangulation of non anchored states for outlier rejection."
+ "Engine failed to due to IMU and camera data push out sync."
+ "Engine failed to process data sample (%s)."
+ "Engine failed to process data sample."
+ "Engine instance must be provided"
+ "Ensure the request is coming from the same base state ID"
+ "Entering VIO only mode"
+ "Entering headless mode"
+ "Error"
+ "Error cannot find the lens\n"
+ "Error cannot find the vio_frame"
+ "Error closing socket %d: %s (%d)"
+ "Error connecting to %s:%d"
+ "Error connecting to %s:%d %s (%d)"
+ "Error connecting to socket %d: %s (%d)"
+ "Error creating socket: %s (%d)"
+ "Error dumping Descriptor sample co-ords."
+ "Error dumping Histogram."
+ "Error dumping Keypoints without Orientation information."
+ "Error dumping Long Descriptors."
+ "Error dumping Orientation sample co-ords."
+ "Error dumping Retina Samples."
+ "Error dumping Short Descriptors."
+ "Error dumping blur pyramid."
+ "Error dumping gaussian pyramid."
+ "Error dumping intermediate gaussian pyramid."
+ "Error dumping key point candidates."
+ "Error dumping key points."
+ "Error dumping response maps."
+ "Error getting host address %d: %s (%d)"
+ "Error getting the program metadata with code %d"
+ "Error in GetPredictionBundlePoseSmoothing: timestamp_apply_state_update is after pose query timestamp. No change in interp_timestamps."
+ "Error in GetPredictionBundlePoseSmoothing: timestamp_apply_state_update is before state timestamp No change in interp_timestamps."
+ "Error sending data to %d: %s (%d)"
+ "Error setsockopt: %s (%d)"
+ "Error setting socket blocking: %s (%d)"
+ "Error setting socket non-blocking: %s (%d)"
+ "Error starting client socket for "
+ "Error stopping socket %d: %s (%d)"
+ "Error the IMU sample buffer cannoty be empty!\n"
+ "Error the original timestamp is not set"
+ "Error the sensor_calibration_set is not set"
+ "Error the timeoffset variable is not set"
+ "Error we cannot retrieve the track-node"
+ "Error we cannot retrieve the viostate"
+ "Error while reading from %s. %s"
+ "Error with poducing DiagnosticRequest tailspin request: %s"
+ "Estimated angle update (%f deg) exceed angle bound (%f deg)"
+ "Estimated angles update exceed angle bound (%f deg)"
+ "Evaluate database"
+ "ExactlyEqual(ds_rates.back(), 1)"
+ "ExactlyEqual(extrap_timestamp, imu_measurements.back().timestamp)"
+ "ExactlyEqual(hardware_timestamp_of_planes, plane_measurements.hardware_timestamp)"
+ "ExactlyEqual(old_state.state_timestamp_end, switch_data->state_data.timestamp_end_TransitionMoving2Stationary)"
+ "ExactlyEqual(skipped_frame_org_timestamp, last_processed_org_timestamp_)"
+ "Exceed maximum number of streams"
+ "Exception during initialization of visual logging to file: %s"
+ "Excessive calls to `DiagnosticRequest` from `ReinitializationCAManager`, skipping..."
+ "Expected collection of log levels (NONE, TRACE... FATAL) separated by commas or given as 'XXX_TO_FATAL')"
+ "Expected magic byte 0x89 (Png), 0xff (Jpeg), 0x49 or 0x4d (Tiff) but found unknown magic byte '0x"
+ "Expected positive values"
+ "ExportImageData requires data to be ImageData"
+ "ExportMeshData requires data to be MeshData"
+ "ExtKf "
+ "Extend track: "
+ "External Map Info must have a Map Data"
+ "External Map Info must have a relocalization module"
+ "External keyframe exist in self map but not in pose graph"
+ "External lens distortion model (FFA) is not loaded."
+ "External map info must have a Map Data"
+ "External map info must have a relocalization module"
+ "External object anchor session should be different from self session"
+ "Extracted vision measurements with %zu frames and %zu tracks"
+ "FG"
+ "FG info must be a pose prior information"
+ "FOV must be valid in lens model"
+ "FOV must be valid."
+ "Factor with the same ID already exists."
+ "Fail to add PoseVariable or VelAndBiasVariable"
+ "Fail to add the camera variable this should never happen"
+ "Fail to add the edge in the pose-graph during deserialization. This should not happen since current design the graph should contain only one edges between each pair per type"
+ "Fail to add the edge to the graph"
+ "Fail to add the external pose-graph edge to self map"
+ "Fail to add the factor"
+ "Fail to add the factor into linear system. This could be due to duplicated factor id."
+ "Fail to add the factor into linear system. this could be due to duplicated factor id"
+ "Fail to add the factor!"
+ "Fail to add the factor. Likely duplicated factor id"
+ "Fail to add the factor. This should never happend"
+ "Fail to add the frame"
+ "Fail to add the odometry edge between "
+ "Fail to add the origin anchor because no regular keyframe"
+ "Fail to add the pre-integrated factor: %zu, state: %d -> %d\n"
+ "Fail to add the rematched epipolar constraint"
+ "Fail to add the state variable this should never happen"
+ "Fail to add varaible"
+ "Fail to compute calibrated measurement"
+ "Fail to convert odometry PG covariance to info "
+ "Fail to create a vioframe"
+ "Fail to create the object_anchor_cm using origin anchor. It should always succeed"
+ "Fail to find pose ref"
+ "Fail to find poseRef via image id"
+ "Fail to find pose_ref"
+ "Fail to find the anchor frame"
+ "Fail to find the camera features associated to the oldest state"
+ "Fail to find the lens"
+ "Fail to find the state and instrinsic pair"
+ "Fail to find the state whose timestamp greater than query"
+ "Fail to find the state within the bundle"
+ "Fail to find track sample!"
+ "Fail to insert a camera to the system. Camera is already there"
+ "Fail to load PCA data."
+ "Fail to load VLAD data."
+ "Fail to load the data for deserializer."
+ "Fail to locate the state!"
+ "Fail to relocalize after map optimization finished"
+ "Fail to remove a variable"
+ "Fail to remove node. this is not possible"
+ "Fail to remove state"
+ "Fail to remove state, this should not happen!"
+ "Fail to request buffer for deserializer (%s)."
+ "Fail to set anchor"
+ "Failed delete due to irregular keyframe path [%s]."
+ "Failed delete due to missing or irregular keypoint path [%s]."
+ "Failed to access [%s]."
+ "Failed to add FileAppender"
+ "Failed to add Pose prior factor"
+ "Failed to add a factor into the linear system. This could be due to duplicate factor id."
+ "Failed to add a node to track map"
+ "Failed to add appender "
+ "Failed to add imu calibration prior factor"
+ "Failed to add keyframe. This should never happen."
+ "Failed to add state prior factor [Moving Platform]"
+ "Failed to add vio frame to self database"
+ "Failed to allocate memory for FFA"
+ "Failed to build plan"
+ "Failed to compute 4-DoF pose update."
+ "Failed to compute P2P RANSAC"
+ "Failed to compute P3P RANSAC"
+ "Failed to compute P3P RANSAC for pose correction in moving slam"
+ "Failed to compute calibrated measurement"
+ "Failed to compute structure covariance."
+ "Failed to construct apple_util::PixelBufferPool"
+ "Failed to construct apple_util::PixelBufferTransferSession"
+ "Failed to correct VIO-position"
+ "Failed to create ["
+ "Failed to create workgroup."
+ "Failed to distort segment endpoints; %d segment candidates were discarded..."
+ "Failed to estimate the relative pose using P3P RANSAC. Triangulated %lu out of %u reference points"
+ "Failed to export data of type "
+ "Failed to extract pose variable covariance."
+ "Failed to factorize the marginalized component of the information matrix."
+ "Failed to find I_to_C transform"
+ "Failed to find ItoC transform for camera source"
+ "Failed to find a ProjectionRef"
+ "Failed to find anchor pose_ref"
+ "Failed to find frame in camera set features"
+ "Failed to find keyframe when querying its number of tracks with structure covariance"
+ "Failed to find object anchor"
+ "Failed to find pose-graph node"
+ "Failed to find pose-ref"
+ "Failed to find primary stream outlier rejection stats"
+ "Failed to find projection ref"
+ "Failed to find query frame"
+ "Failed to find state for keyframe"
+ "Failed to find state in ext_map_data"
+ "Failed to find state in self_map_data"
+ "Failed to find the anchor base keyframe"
+ "Failed to find the newly added external map"
+ "Failed to find the projection ref of the keyframe"
+ "Failed to find the track in the the front-end tracks."
+ "Failed to find the track that corresponds to the SLAM landmark variable."
+ "Failed to find the vio state"
+ "Failed to find vio frame"
+ "Failed to find vio frame in self map"
+ "Failed to get VisualSLAMMode Mapping"
+ "Failed to get VisualSLAMState Mapping"
+ "Failed to get or create directory."
+ "Failed to grvaity-align the front-end in moving slam"
+ "Failed to initialize file logger!"
+ "Failed to initialize network logger!"
+ "Failed to invert the factorization of the marginalized component of the information matrix."
+ "Failed to invert the marginalized component of the information matrix."
+ "Failed to linearize, solve and tacky marginalize: "
+ "Failed to load sample "
+ "Failed to load table of contents with error: %s"
+ "Failed to marginalize state "
+ "Failed to prune a candidate state (view: %d)"
+ "Failed to prune submap ID: %llu"
+ "Failed to read submap from disk."
+ "Failed to refine 4-DoF pose. State correction will be updated with the estimated pose as-is"
+ "Failed to refine 6-DoF pose. State correction will be updated with the estimated pose as-is"
+ "Failed to remove a variable."
+ "Failed to remove end point variables."
+ "Failed to save image to destination."
+ "Failed to send command(s) to client "
+ "Failed to set vision-pose tracker because no there is no stereo-camera"
+ "Failed to set workgroup flags."
+ "Failed to start new server socket %d (expected if connection was terminated)"
+ "Failed to triangulate the points for calibration change detection: "
+ "Failed to undistort chain points; %d segment candidates were discarded..."
+ "Failed to write to file: "
+ "Failure during "
+ "Failure to eigenvalues of 3x3 hessian matrix.  Setting minimum eigenvalue to zero"
+ "Failure to initialize mapping IO."
+ "Failure, Adding node failed!"
+ "Failure, Cannot find the frame!"
+ "Failure, Imcompatible feature index exceeds frame features!"
+ "Failure, Incompatible Track observation!"
+ "Failure, Track length < 2!"
+ "Failure, addCorrespondenceImageScene failed!"
+ "Falling back to propagating relative rotation from IMU."
+ "Fatal"
+ "Feature center should always be valid"
+ "Feature is to far away from camera to become a map feature"
+ "Feature out of bounds in prune."
+ "Feature should not be tracked temporaly and spatialy on the secondary stream"
+ "FeatureDetectionErrorFwd"
+ "FeatureProcessingConfig.enable_debug_mode"
+ "FeatureProcessingConfig.initial_starting_state_id"
+ "FeatureProcessingConfig.initialization_timestamp_for_debug_purpose"
+ "Features and depths are different size. Frame features are already pruned"
+ "File"
+ "FileAppenderConfigurator::setParameterValue(): "
+ "Filesystem error during prune: %s"
+ "Filesystem error during table of contents load: %s"
+ "Filter LS training samples needs to be > 10."
+ "Filter RLS forgetting factor needs tp be in range of [0.5,1]."
+ "Filter is not yet initialized"
+ "Filter max coefficient norm limit needs to be >= 0."
+ "Filter max prediction samples needs to be in range of [1,40]."
+ "Filter must have beeen reset at this point"
+ "Filter must not be initialized yet"
+ "Filter number of taps needs tp be in range of [1,100]."
+ "Filter regularization needs to be >= 0."
+ "FilterData data length less than filter length"
+ "Final cost was "
+ "First VIOState must exist to add the prior"
+ "First frame of incoming bundle not present in previous estimate."
+ "First pose ID different"
+ "First sensor timestamp: %.20f."
+ "FisheyeKR7"
+ "FisheyeLensKR7"
+ "Five-point ransac generated zero hypotheses"
+ "Five-point ransac received %zu correspondences, which is less than sample size %zu"
+ "Fix rotation around the gravity vector in the initial pose degree of freedom."
+ "Flag controlling whether reinitialization should be skipped / delayed for a short period of time when there are significant changes in camera lux values."
+ "Flag not supported for ExportLargeData"
+ "Flag to enable map measuremetns early return in reprojection map tracking."
+ "For channels="
+ "For primary stream, a feature must be assigned to a track"
+ "Format "
+ "Format is not serializable. Must be a non-dynamic format."
+ "Frame already contains ML descriptors."
+ "Frame already contains ML semantics."
+ "Frame buffer is overflowing:"
+ "Frame doesn't have an initial IMU constraint so dropping it - should only happen from a cold start"
+ "Frame id doesn't exist"
+ "Frame should be weak"
+ "Frame: Camera ID: [%02u], Rate:%f, Latency:%f, Expiration timestamp:%f, FP Expiration timestamp:%f"
+ "Frame: Camera ID: [%02u], Rate:%f, Latency:%f, Expiration timestamp:%f, FP Expiration timestamp:%f, Illum. current:%u, Illum. pulse width:%u"
+ "Frames are duplicated"
+ "Frames are out of order"
+ "FrontEndOdometryConfig.max_num_stereo_matches_for_low_stereo_coverage"
+ "Function can only be used in LS RLS update mode"
+ "Function can only be used in LS RLS update mode."
+ "Function can only be used in RLS update mode."
+ "Function should contain valid target"
+ "GetInertialStateAtTime (in GetPredictionBundlePoseSmoothing) failed with InterpolateFailed: Could not interpolate the IMU samples used for inertial state propagation for pose request timestamp="
+ "GetInertialStateAtTime Failed with NotBaseState: No inertial state added to pose predictor yet for pose request timestamp="
+ "GetInertialStateAtTime Failed with NotEnoughMeasurements: Less than two accel or gyro measurements to propagate the state were present for pose request timestamp = "
+ "GetInertialStateAtTime Failed with TimestampTooEarly: No inertial state found prior to pose timestamp="
+ "GetInertialStateAtTime Failed with TimestampTooFarAhead: Pose request timestamp="
+ "GetInertialStateAtTime: EResultGetInertialStateAtTime::TimestampTooFarAhead"
+ "GetInertialStateAtTime: EResultGetPredictionBundleAtTime::TimestampTooEarly"
+ "Given `camera` cannot be serialized. It does not contain a Kit_Camera camera"
+ "Given data block is too big to be represented by uint32_t indexed ArrayView"
+ "Given storage is of incompatible type for this channel, must be "
+ "Good Initialization"
+ "Good Tracking"
+ "Got %d point correspondences and %d line correspondences to reference frame (which is %zu frames back)"
+ "Gravity correction must not be used in VIO"
+ "GroupD"
+ "GroupF"
+ "Guard bytes got overwritten."
+ "Gyro avg gain must be in [0,1]!"
+ "Gyro bias estimate from SLAM: %f, %f, %f"
+ "Gyro buffer must be > 1"
+ "Gyro buffer must be synched with Accel Buffer size"
+ "Gyro measurement timestamps must be strictly increasing."
+ "Gyro measurements need to be synched to accel"
+ "Gyro sample_time_diff = %lf is less than 0, indicating Gyro samples are out of order at gyro timestamp = %lf. Gyro sample not added to prediction bundler"
+ "Gyro thresholds need to be increasing with higher motion"
+ "Gyro-based stationary detection."
+ "Gyroscope buffer is too full - popping oldest"
+ "HW feature matching for duplicated streams is not supported."
+ "Harris Feature Detector in not initialized"
+ "HasProcessedFirstWindow()"
+ "HasProcessedFirstWindow() > 0"
+ "HasValidSize()"
+ "Headless mode is still on"
+ "Health metric is not valid. It should never happen"
+ "Heikkila"
+ "Hessian matrix should be square."
+ "High Speed Interpolation Failed for new sample at end timestamp = %f"
+ "HighResolution"
+ "ICDSV:%d"
+ "ICDVS: Ignore hint. geo:%d, large-map:%d"
+ "ICDVS: Last loc_time: %f vs valid time %f, ground: %d"
+ "ICDVS: Send one time location request"
+ "ID: %u, %.9f, %.9f, %.9f, %.9f, %.9f, %.9f"
+ "IDE_DISABLED_OS_ACTIVITY_DT_MODE"
+ "IMU R factor contains NaNs."
+ "IMU R factor reaches high magnitudes."
+ "IMU State Variable already exists."
+ "IMU accel scale factor contains NaNs."
+ "IMU accel scale factor reaches high magnitudes."
+ "IMU accel skewness factor contains NaNs."
+ "IMU accel skewness factor reaches high magnitudes."
+ "IMU buffer > 1"
+ "IMU buffer does not cover the map-database. Please check the IMUdata"
+ "IMU buffer is not set\n"
+ "IMU buffer is too full - popping oldest"
+ "IMU dt factor contains NaNs."
+ "IMU dt factor reaches high magnitudes."
+ "IMU factor failed to factorize the noise model."
+ "IMU gyro scale factor contains NaNs."
+ "IMU gyro scale factor reaches high magnitudes."
+ "IMU gyro skewness factor contains NaNs."
+ "IMU gyro skewness factor reaches high magnitudes."
+ "IMU interpolation time delta less than 1e-4"
+ "IMU measurement buffer must not be empty"
+ "IMU measurements is zero\n"
+ "IMU noise sigma: "
+ "IMU sampler failed - unable to interpolate acclerometer. Dropping frame."
+ "IMU sampler failed - unable to interpolate gyroscope. Dropping frame."
+ "IMU sampler failed - unable to interpolate imu sensor. Not updating High Speed Filtered Buffer."
+ "IMU sampler failed in spline interpolation - unable to interpolate imu sample."
+ "IMU samples should span the entire extrapolation delta-time. Missing measurements must have been extrapolated/interpolated and resampled before this stage"
+ "IMU state factor contains NaNs."
+ "IMU state factor reaches high magnitudes."
+ "IMU timestamp must be in increasing order"
+ "IMU timestamps not non-decreasing"
+ "IMUSynchronizer IMU Frequency for timestamp=%lf into IMUSynchronizer/BA is close to expected frequency: Expected Frame IMU Input Frequency=%lf, Actual Frame Frequency=%lf, Output IMU Frame Frequency=%lf."
+ "IMUSynchronizer IMU Frequency for timestamp=%lf into IMUSynchronizer/BA is different than expected: Expected IMU Frame Frequency=%lf, Current IMU Frame Frequency=%lf."
+ "INFO_TO_FATAL"
+ "If the window is under-constrained, we must have reinitialized and skipped"
+ "Ignore submap "
+ "Ignore the gyro scale update."
+ "Image"
+ "Image descriptor does not exist!"
+ "Image descriptor does not exist."
+ "Image dimensions must be strictly positive."
+ "Image is NULL"
+ "Image is of format "
+ "Image resolution "
+ "Image width needs to be no less than kImageChunkSize + kMarginWidth * 2"
+ "ImageDestinationRef does not (yet) support format "
+ "ImageIO"
+ "Immediate re-initialization due to Heuristics"
+ "In Modify3DLandmarkWithAnchorPoseChange(), failed to find single-length track %u in transformation_from_old_global_to_new_global_ with node image ID (view: %u, source: %u)"
+ "In submapping mode with anchor layer, the user should not call MappingInterface::AddObjectAnchor"
+ "In the new pose-graph, the two states have to be regular to support submapping"
+ "InMotionInitializationConfig.initial_global_position"
+ "Incoming estimate from BA has 0 overlap with current sliding window"
+ "Incompatible aspect ratio: in=["
+ "Incompatible relative pose"
+ "Incompatible stateset. "
+ "Incompatible tracks observation for IO"
+ "Inconsistent bad geoemtry frame ID"
+ "Inconsistent control points"
+ "Inconsistent function value at the pole."
+ "Inconsistent mixed gradient at the pole."
+ "Inconsistent radial gradient at the pole."
+ "Inconsistent tangential gradient at the pole."
+ "Incorrect bin configuration in AreaBinning FeatureFilter"
+ "Incorrect number of cameras"
+ "Incorrect previous base state ID"
+ "Incorrect stream id"
+ "Incremental pose must exist"
+ "Indexed"
+ "Indices can only be reordered once."
+ "Indices exceed matrix bounds."
+ "Inference failed because %s"
+ "Info"
+ "Information missing from the input states. VerifyAndDeleteCorruptedExternalSubmaps() aborted."
+ "Inherit"
+ "Initial Camera extrinsics: Camera ID: [%02u]: R_log_x: %f, R_log_y: %f, R_log_z: %f"
+ "Initial Camera intrinsics: Camera ID: [%02u]: Fx: %f, Fy: %f, Cx: %f, Cy: %f"
+ "Initial accel bias estimate: %f, %f, %f"
+ "Initial gyro bias estimate: %f, %f, %f"
+ "Initial gyro scale estimate: %f, %f, %f"
+ "Initial pose: timestamp: %f, pose: %f, %f, %f, %f, %f, %f"
+ "Initial position in VIO global coordinate (m)."
+ "Initial starting state ID."
+ "Initial velocity: %f, %f, %f"
+ "Initial vision to IMU time-offset: %f"
+ "Initialization timestamp for debug purpose, only initialize after this timestamp."
+ "Initializing VisualLogger file exporter %s"
+ "Initializing early..."
+ "Initializing pose tracker"
+ "Initializing..."
+ "Input Session is NULL"
+ "Input dimension should be greater than 0"
+ "Input states are not properly sorted from latest to oldest. DeleteCorruptedExternalMapStates() aborted."
+ "Input track length is less than 2"
+ "Input variance is smaller than zero"
+ "Insert image id %zu with %zu features"
+ "Instantiated SLAM engine is null."
+ "Insufficient IMU measurements to estimate gyro rotation at extrapolation time"
+ "IntBinIndex is too small."
+ "IntFeatureIndex is too small."
+ "Inter session states has to be regular states "
+ "Invalid Anchor Added Result"
+ "Invalid CameraStreamId (source ID: %d)"
+ "Invalid FG Pior information"
+ "Invalid IMUIIRFilter Filter call!"
+ "Invalid JtJ"
+ "Invalid Pose Predictor"
+ "Invalid PosePredictor"
+ "Invalid Prediction Callback"
+ "Invalid Relocatization Callback"
+ "Invalid UUID when loading AnchorSetSample from disk"
+ "Invalid UUID."
+ "Invalid `Version` string '"
+ "Invalid argument "
+ "Invalid callback"
+ "Invalid configuration"
+ "Invalid configuration. Custom default storage name must be 'Default' but '"
+ "Invalid destination pointer"
+ "Invalid expression (console appender "
+ "Invalid expression (has to be assignment)"
+ "Invalid expression (invalid component '"
+ "Invalid expression (invalid parameter object content ("
+ "Invalid expression (invalid parameter type ("
+ "Invalid expression (invalid parameter value '"
+ "Invalid expression (left assignment empty)"
+ "Invalid expression (unknown appender "
+ "Invalid expression (unknown left identificator "
+ "Invalid expression (unknown parameter "
+ "Invalid expression (unknown right identificator "
+ "Invalid expression: Unknown appender '"
+ "Invalid factor is being picked"
+ "Invalid filename provided"
+ "Invalid gravity-aligned rotation matrix for state correction"
+ "Invalid half fov: "
+ "Invalid image format. Format "
+ "Invalid image, not added to vdb"
+ "Invalid inertial-state prior info."
+ "Invalid lens FOV"
+ "Invalid lens distortion."
+ "Invalid log level filter token "
+ "Invalid mode"
+ "Invalid number of U knots: "
+ "Invalid number of V knots: "
+ "Invalid number of control point values: "
+ "Invalid number of control points: "
+ "Invalid number of dimension: "
+ "Invalid plane debug pointer."
+ "Invalid pnm file. Format magic number not recognized."
+ "Invalid pnm file. Unexpected end of file in header."
+ "Invalid pose prior info."
+ "Invalid relocalization results"
+ "Invalid serialization format type: "
+ "Invalid state correction logic. We should not have existing request/reloc_info when next inplace relocalization is called"
+ "Invalid state, metadata was nullptr"
+ "Invalid submap request"
+ "Invalid sync type value"
+ "Invalid uuid in UserAnchorWithMetadataSample"
+ "Invalid vision sensor when selecting map keyframes"
+ "Invalid("
+ "IsGaussianPyramidGeneratorConfigValid(config)"
+ "IsKeyPointAndDescriptorGeneratorConfigValid(config)"
+ "IsResponseMapAndKPCGeneratorConfigValid(config)"
+ "IsUsingIMU()"
+ "It is expected that a11*a22 is s31"
+ "It is expected that a12*a21 is s31"
+ "It is mandated that all errors are handled and enforced by a processor. Add an error handler with AddErrorHandler()"
+ "It is mandated that there is only one error handler for a single consumer"
+ "It is mandated that there is only one output handler for a single consumer"
+ "It took %f sec to find the closest frames, %f sec to look up pose-refs, %f sec to allocate new track IDs and %f for keyframe matching"
+ "It's assumed the first camera ID is 0"
+ "Jpeg"
+ "JtJ.trace() > 0."
+ "KeyFrameIO: saved keyframe [%s]"
+ "Keyframe anchor rotation has nans"
+ "Keyframe anchor translation has nans"
+ "Keyframe sampling failed"
+ "Keyframes do not contain enough tracks with structure covariance."
+ "LP Noise model failed. Fallback succeeded."
+ "LSE:GLP: Timestamp Out of Window ts:%f min_ts:%f"
+ "LSTM expects interval of %.2fms between adjacent steps, but gets %.2fms"
+ "Lab"
+ "Landmark ID and track ID is different"
+ "Landmark with the given ID was not found."
+ "Laplacian pyramid built from Gaussian must have one less octaves."
+ "LargeCameraExtrinsicOffset:%d"
+ "LargeCameraExtrinsicOffsetWrtDefault"
+ "Last possible downsampling rate must be = 1"
+ "Latest depth extrinsics p: %f %f %f, R: %f, %f, %f, %f, %f, %f, %f, %f, %f"
+ "Latest depth sensor to IMU timeoffset %f"
+ "Latest timeoffset %f"
+ "LeastSquaresPredictionFilter: Filter taps norm too large check failed"
+ "LeastSquaresPredictionFilter: Sum of filter coefficieents not close to 1."
+ "Length of trak is 1 when first added"
+ "Lens does not exist"
+ "LevelFilter"
+ "Limit the amount of noise used in error propagation; inverse noise should be GT 0."
+ "Linear speed: "
+ "Lines2"
+ "Lines3"
+ "Loaded camera extrinsics from previous execution as rotation matrix: [[%lf, %lf, %lf], [%lf, %lf, %lf], [%lf, %lf, %lf]]"
+ "Loaded map have the same session as the new session in mapping,                        are you running with fixed session mode ? "
+ "Loaded submap must be valid."
+ "Location data received: %s"
+ "Location input is required."
+ "Location is NULL"
+ "Location request is NULL"
+ "LocationInfo is NULL."
+ "Log file "
+ "LowTextureHeuristics"
+ "M > 0"
+ "ML Segment based plane detector: %s"
+ "ML Segment based pop-up plane detector: %s"
+ "ML Vlad not supported for weak keyframes without GlobalFeat"
+ "MLDescriptorExtractor: extract desc for "
+ "MLFeatureEvent incomplete in Metadata in MLPriorityQueue"
+ "MLFeatureExtractor: extract feature for "
+ "MLModel selection."
+ "MLPosePredictionFilter expects %.2fms between two poses, but gets %.2fms"
+ "MLPosePredictionFilter takes %d IMU measurements between two poses, but gets %d"
+ "MLPosePredictor returns %u at %.6f"
+ "MachAbsolute"
+ "MachContinuous"
+ "Make sure last_track_used points to a valid track."
+ "Make sure last_valid_element points to a valid element"
+ "Malfromed `visual_logger` argument: must either be string that is either a file path or have the form `hostname:port`."
+ "Map Data must have a vio database"
+ "Map Data must have a viodatabase"
+ "Map spread %f"
+ "Map tracking. 2d->3D Matches Before Filter: %u, 2d->3D Matches:%u, Inlier Map Constraints:%u"
+ "MapClassifier [%d]: rotation-rate %f, revisited %d , health %f, far_away %d, speed %f, acceleration %f"
+ "MapDataSample"
+ "Mapping directory is not empty"
+ "Mapping directory path cannot be empty"
+ "Mapping manager is not instantiated"
+ "MappingManagerConfig.enable_reprojection_map_tracking_early_return"
+ "MappingManagerConfig.max_num_densedepth_tracks"
+ "Marginalizing..."
+ "Max allowed camera extrinsic rotation difference w.r.t. defualt value out of all input camera streams before determining drift in camera extrinsic, in rad."
+ "Max anchors per group must be positive"
+ "Max depth of stereo feature to be used for outlier rejection."
+ "Max dimensions supported is 640x8192, configured dimension %lux%lu"
+ "Max ratio of number of marginalized tracks in consistent marginalization."
+ "MaxBackupIndex"
+ "MaxFileSize"
+ "MaxNumFeatures "
+ "MaxNumTracks "
+ "Maximum distance to plane for outliers."
+ "Maximum error to be considered a ~correct~ but not neccearily ~inlier~ match."
+ "Maximum inliers to centroid mean distance to be a valid plane."
+ "Maximum multiples of avg inlier points to centroid dist for outliers."
+ "Maximum multiples of inlier points to centroid average dist on NSP for oulier points."
+ "Maximum number of RANSAC hypotheses."
+ "Maximum number of stereo matches for low stereo coverage."
+ "Maximum number of tracks created using dense depth per frame."
+ "Maximum number of trials."
+ "Maximum offset between plane and gravity direction."
+ "Maximum point to plane distance for inlier points."
+ "Maximum rotation rate of the last two states in the bundle to enable stereo based utlier rejection."
+ "Maximum time difference between camera and IMU to consider gyro measurements."
+ "Maximum time difference between current image and stereo feature to be used for outlier rejection."
+ "Mean is undefined for empty ranges"
+ "Median is undefined for empty ranges"
+ "Memory allocation error during prune: %s"
+ "Memory allocation error during table of contents load: %s"
+ "MergeSubmaps: Number of primary submaps = "
+ "Mesh IO"
+ "Method not imlemented. Rotation will be estimated using the history of the past poses"
+ "Metric for depth change."
+ "Min dimensions supported is 160x160, configured dimension %lux%lu"
+ "Minimal value of absolute gyro integral over time to classify as sufficient motion to enable IMU intrinsics estimation, in rad."
+ "Minimum centroid to primary camera distance to be a avlid plane."
+ "Minimum depth prior info required to enable anchor camera only triangulation."
+ "Minimum inlier points to be on the plane."
+ "Minimum inlier points to enable persistence."
+ "Minimum inlier ratio to enable persistence."
+ "Minimum inlier ratio."
+ "Minimum number of features to conclude moving platform."
+ "Minimum number of tracks required for stereo outlier rejection to run."
+ "Minimum number of triangulated points beyond a frame can be marked as bad-geometry (ie drop the frame)."
+ "Minimum propagated IMU pose difference in position to conclude drift in moving platform."
+ "Minimum rotation rate in deg/s. Beyond this threshold, a keyframe should be added to VIO."
+ "Miss aligned IMU segments"
+ "Missing Frame bundle ref in front-end"
+ "Missing camera set features in front-end"
+ "Missing features after prune."
+ "Missing latest camera set features!"
+ "Model "
+ "Modified the initial state from prior."
+ "MonoDominant"
+ "Monochrome"
+ "More tracks than features in prune."
+ "Moving average of camera to IMU timeoffset: "
+ "Moving average of gyro_scale[ "
+ "MovingIMUCameraDiscrepancyClassifierConfig.drift_ratio_to_conclude_moving_platform"
+ "MovingIMUCameraDiscrepancyClassifierConfig.min_num_features_to_conclude_moving_platform"
+ "MovingIMUCameraDiscrepancyClassifierConfig.min_num_stereo_matches_to_conclude_moving_platform"
+ "MovingIMUCameraDiscrepancyClassifierConfig.min_position_diff_to_conclude_moving_platform_in_m"
+ "MovingIMUCameraDiscrepancyClassifierConfig.vio_health_queue_size"
+ "MovingIMUCameraDiscrepancyClassifierConfig.vision_stationary_ratio_to_conclude_moving_platform"
+ "Must be running in LPS mode and must have solved before."
+ "Must choose format to save."
+ "Must contain feature points."
+ "Must have > 1 measurement"
+ "Must have R_map_keyframe_to_anchor set"
+ "Must have t_map_keyframe_to_anchor set"
+ "Must have valid lens model to compute frustum extrema."
+ "Must pass > 0 possible downsampling rates"
+ "N-th percentile parallax: %f."
+ "Name: "
+ "Near(mGyroMeasurementsForFrame.back().timestamp, timestamp)"
+ "Negative scale calculated!"
+ "Neither VLAD nor brute-force ranker was initialized"
+ "Neither per-frame intrinsics nor thermal model exists, even though calibration processor was configured to expect one of them."
+ "NetworkOutputNode_WorkQueue"
+ "New structure initialized to valid covariance."
+ "NewDataCallback"
+ "NewSubmapLogic::Update data: map session "
+ "Next submap session ID callback is not set!"
+ "No Camera to IMU translation for "
+ "No SLAM variable should exist at this point."
+ "No cameras in calbration"
+ "No extrinsics estimation in vision-only mode currently"
+ "No imu measurmeent available"
+ "No initialization or defaults parameters found. Will attempt to load camera extrinsics."
+ "No keyframe is added with ID %d at timestamp %f."
+ "No keyframes found for this vio state."
+ "No known common format"
+ "No known method to load file of "
+ "No method to save given format"
+ "No new samples beyond first sample time. Use 1st sample in buffer"
+ "No new samples beyond last sample time."
+ "No pose ref found"
+ "No sampled image_ids for matching"
+ "No smudge data"
+ "No stationary constraints"
+ "No such condition possible in pose filtering transitions"
+ "No such condition possible in pose filtering!"
+ "No such condition should occur"
+ "No track for feature when pruning"
+ "No tracks in supplied frame range."
+ "No translation from IMU to "
+ "No two sames factors"
+ "No weak keyframes are allowed to create new submap"
+ "Non-direct marginalization should not be used with LPS. Please disable."
+ "Non-monotonic IMU sensor timestamps: prev=%lf, cur=%lf. Dropping this sample."
+ "Non-monotonic accel timestamps: prev=%lf, cur=%lf. Dropping this sample."
+ "Non-monotonic gyro timestamps: prev=%lf, cur=%lf. Dropping this sample."
+ "Non-submapping case requires a single MapData instance."
+ "NoncentricKR7"
+ "NoncentricLensKR7"
+ "Not a lower bound."
+ "Not enough 2d-3d matches available for PnP pose estimation: "
+ "Not enough accelerometer Measurements to constrain the splines"
+ "Not enough correspondences available (%zu)"
+ "Not enough data to read"
+ "Not enough data to read binary blob"
+ "Not enough data to read span"
+ "Not enough data to read string"
+ "Not enough gyro Measurements to constrain the splines"
+ "Not enough inliers available (inlier: %lu, ratio: %f)"
+ "Not enough pixels in tile"
+ "Not enough poses for interpolation."
+ "Not implemented for lines"
+ "Not implemented yet."
+ "Not supported with reordered indices."
+ "Not supported without reordered indices."
+ "Not weak keyframe"
+ "NotSyncing"
+ "Num cycle count "
+ "Num measurements: %zu, avg reprojection RMSE: %f, avg normalized reprojection RMSE %f, meadian normalized re-projection RMSE %f"
+ "Num of octaves for fixed point "
+ "Num query descirptors "
+ "Num tracks after Compute structure covariance: %zu."
+ "Num tracks: %zu"
+ "NumStreams mismatch"
+ "Number"
+ "Number matched cannot be higher than the initial count of planes"
+ "Number of bins must be odd for AreaBinning"
+ "Number of bits for matching can only be 128/256"
+ "Number of bits for matching can only be 128/256/512"
+ "Number of cropped body points: %u ([before: %zu, after: %zu])"
+ "Number of eigen values has to be smaller than x_dimension"
+ "Number of features removed given indices([before, after]): ([%lu, %lu])."
+ "Number of frames in the sliding window filter."
+ "Number of good tracks cannot be smaller then num inlier tracks"
+ "Number of incremental camera rotations does not match number of camera streams"
+ "Number of keys must match number of values"
+ "Number of landmarks should be zero."
+ "Number of logged initial states before first BA solve. If the value is larger than state size in the BA, only max state size will be logged."
+ "Number of obs with cov: %u / %zu"
+ "Number of point features cropping to %f FOV ([before, after]): ([%lu, %lu])."
+ "Number of predictions must equal to number of anchor boxes."
+ "Number of re_initialization has to be positive"
+ "Number of scales for binomial gaussian pyramid must be 3."
+ "Number of scales minus 2 should be less than or equal to max expected"
+ "Number of scales per octave supported is 2, configured value %lu"
+ "Number of scales should be > 2"
+ "Number of tiles should be positive"
+ "Numbers"
+ "OS: "
+ "OSLogAppender"
+ "OS_ACTIVITY_DT_MODE"
+ "ObjAnchor "
+ "Offline BA not supported for vision-only SLAM"
+ "Oldest state ID in SLW: "
+ "Only stream ID 0 and 1 are supported."
+ "Only support given session!"
+ "Only supporting binomial gaussian pyramid, with 2 scales per octave"
+ "OptimizeHomography failed!"
+ "OptimizeMap()"
+ "Out of Bounds IMUFilter Sample Frequency"
+ "Out-of-order features arrived from across streams! Dropping these features."
+ "Outlier factor is not found"
+ "Overflow in appending point clouds."
+ "Overriding SLAM calibration to use `accel_conversion` specified by the `config_override.json`."
+ "Overriding SLAM calibration to use `gyro_conversion` specified by the `config_override.json`."
+ "Overriding SLAM configs using the file "
+ "Overriding the marginalization kernel setting for LPFG."
+ "Overwriting per frame focal length according to thermal model."
+ "P2\n"
+ "P3"
+ "P3\n"
+ "P3P must be enabled to compute the vision-propagted pose"
+ "P5"
+ "P5\n"
+ "P6"
+ "P6\n"
+ "PBPTOR:EP InlierSize:%lu InlierRatio:%lf CenToCamDist:%lf AvgPtsToCenDist:%lf Time:%lf ToBePersisted:%d ASpeed:%lf"
+ "PBPTOR:PersistentPlaneReturned"
+ "PBPTOR:ProjPlane SourceID:%u ProjCentroidX:%lf ProjCentroidY:%lf range:%lf"
+ "Package '"
+ "Package id '"
+ "Path to map file is nullptr"
+ "Pattern"
+ "Pause Finished should only be set if tracking has been paused."
+ "Pause mapping module only supports submapping mode"
+ "PeerInfo"
+ "Perform a reinitialization in LSE@ %f"
+ "Permutation indices must be separated by commas."
+ "Permutation matrix file size mismatch"
+ "Permutation sequence is too short."
+ "Persistence duration."
+ "Persistence report save failed with err: %s."
+ "Persistence report save failed."
+ "Persistent SLAM landmarks should not be larger the maximum optimized tracks"
+ "Pgm"
+ "Pinhole"
+ "Pixel format is not kCGImagePixelFormatPacked."
+ "PixelTransferSession failed"
+ "Plane fitting instance not valid."
+ "Plane measurement time mismatch"
+ "Plane to world:"
+ "Plane tracker created from map %zu"
+ "Plane tracker created from scratch - no map"
+ "PlaneBasedPointTrackOutlierRejection parameters"
+ "PlaneBasedPointTrackOutlierRejectionConfig.enable_plane_persistence"
+ "PlaneBasedPointTrackOutlierRejectionConfig.enable_rejection"
+ "PlaneBasedPointTrackOutlierRejectionConfig.max_outlier_pt_to_plane_dist_m"
+ "PlaneBasedPointTrackOutlierRejectionConfig.max_outlier_to_centroid_mean_dist_multiplier"
+ "PlaneBasedPointTrackOutlierRejectionConfig.max_outlier_to_centroid_nsp_range_multiplier_sq"
+ "PlaneBasedPointTrackOutlierRejectionConfig.max_valid_avg_inlier_to_centroid_dist_m"
+ "PlaneBasedPointTrackOutlierRejectionConfig.min_inlier_ratio_to_persist_plane"
+ "PlaneBasedPointTrackOutlierRejectionConfig.min_num_inlier_to_persist_plane"
+ "PlaneBasedPointTrackOutlierRejectionConfig.min_valid_plane_centroid_to_cam_dist_m"
+ "PlaneBasedPointTrackOutlierRejectionConfig.persist_duration_s"
+ "PlaneBasedPointTrackOutlierRejectionConfig.plane_fit_chunk_size"
+ "PlaneBasedPointTrackOutlierRejectionConfig.plane_fit_eigen_val_ratio_thresh"
+ "PlaneBasedPointTrackOutlierRejectionConfig.plane_fit_max_inlier_dist_m"
+ "PlaneBasedPointTrackOutlierRejectionConfig.plane_fit_max_num_hypotheses"
+ "PlaneBasedPointTrackOutlierRejectionConfig.plane_fit_max_orthogonal_vector_delta_cos"
+ "PlaneBasedPointTrackOutlierRejectionConfig.plane_fit_max_trials"
+ "PlaneBasedPointTrackOutlierRejectionConfig.plane_fit_min_inlier_ratio"
+ "PlaneBasedPointTrackOutlierRejectionConfig.plane_fit_min_num_inliers"
+ "Planes in tracker: %zu %zu"
+ "PnP pose estimation failed"
+ "Png"
+ "Point track missing structure."
+ "Points2"
+ "Points3"
+ "Pose Data: timestamp:%.30g, R:%.30g, %.30g, %.30g, %.30g, %.30g, %.30g, %.30g, %.30g, %.30g, t:%.30g, %.30g, %.30g"
+ "Pose graph: resuming optimization after it did not converge in the last frame (resume %ul / %ul)"
+ "Pose is invalid: "
+ "PoseFilterConfig parameters"
+ "PosePredictor error:  weight passed to AddTwoInertialStatesForPoseSmoothing negative or greater than 1."
+ "PosePredictor: Error propagating previous state using IMUs to current state at state time %f with error: %s."
+ "PosePredictorPoseFilter alphaBeta_theta needs to be on [0,1]"
+ "PosePredictorPoseFilter dt needs to be > 0"
+ "PosePredictorStats (this=%lu) over last %zu GetPose Calls at AddInertialStateTimestamp=%f, GetPose IMU Extrapolation Time (s) [min=%f, max=%f, median=%f,mean=%f, stdDev=%f]"
+ "PosePredictorStats (this=%lu) over last %zu GetPose Calls at AddInertialStateTimestamp=%f, GetPoseCallTimeDifference (s) [min=%f, max=%f, median=%f,mean=%f, stdDev=%f]"
+ "PosePredictorStats (this=%lu) over last %zu GetPose Calls at AddInertialStateTimestamp=%f, GetPoseTimestamp-LatestStateTimestamp (s) [min=%f, max=%f, median=%f,mean=%f, stdDev=%f]"
+ "PoseSmoothingStepProp called with insufficient number of IMU measurements: Assigning smooth_output_state=smooth_state_at_base_reset."
+ "PoseTracker::AddFrameMeasurements()          time elapsed %#7.3fms"
+ "PoseTracker::PrepareBundle()       time elapsed %#7.3fms"
+ "PoseTrackerConfig.min_drift_velocity_for_stationary_constraints"
+ "Ppm"
+ "Prediction must be in future"
+ "PredictionBundlerIMUFilter: Filter taps norm too large check failed"
+ "PredictionBundlerIMUFilter: IMU sampling period too small - using fixed sampling period."
+ "PredictionBundlerIMUFilter: Resampling buffer last timestamp different from last window sample"
+ "PredictionBundlerIMUFilter: Sum of filter coefficieents not close to 1."
+ "PredictionBundlerIMUFilter: imu interpolation failed"
+ "PredictorConfigOverrides: Attempting to read in overrides from file: "
+ "PredictorConfigOverrides: Could not find the overrides file."
+ "PredictorConfigOverrides: Successfully applied the overrides file!"
+ "PreemptiveRansac failed"
+ "Previously Propagated state timestamps must be strictly increasing."
+ "Primary"
+ "Primary and secondary reference points must be of the same size"
+ "Primary cameras can't be empty"
+ "Primary: %s: %zu features, %zu matches"
+ "PrimaryStreamFrameAlternatorNodeWorker cannot use multiple primary cameras."
+ "PrimaryStreamFrameAlternatorNodeWorker cannot use multiple secondary cameras."
+ "Prior factor should be added."
+ "Prior has to be symmetric"
+ "Problem solving the system at scale level %u at iteration %u"
+ "Proceeding"
+ "ProceedingConditionally"
+ "Process a gyro scale update with value: "
+ "Process external keyframe "
+ "Process: "
+ "Processing %zu IMU measurements"
+ "Processing a window of %zu frames (%zu point-tracks and %zu line-tracks)"
+ "Processing frame %d with timestamp %f"
+ "Product: "
+ "ProjectPoint did not converge: num_iterations="
+ "PromoteSlidingStateToRegular "
+ "PromoteWeakStateToRegular "
+ "PropagateAnchorUpdates not supported. If you need this switch to SLAMSession"
+ "Propagating %d of %zu frames..."
+ "Protocol: "
+ "Prune low-score tracks"
+ "Prune path [%s] is non-existent."
+ "Pruned tmp and keyframe files in [%s]."
+ "Pruned tmp files in [%s]."
+ "Pruning map before ML Descriptors from CM: "
+ "Pruning map before ML Descriptors from CM:{%llu,%u,%u}"
+ "Pruning tracks not required."
+ "Pure rotation or static motion."
+ "Query frame size is bigger than the frame_set.size(). Return all frames"
+ "Query frames histogram"
+ "Query source ID does not exist"
+ "Query state ID not compatible"
+ "Query state ID should be empty upon receiving state correction event"
+ "Query state does not exist in the database"
+ "Query state dose not exist"
+ "Query submap does not exist"
+ "RGB"
+ "RLSPredict failed: Need to specify prediction indices"
+ "RLSPredict failed: prediction indices must be in in [1,max_pred_samples] range."
+ "RLS_downsample_factor > 0"
+ "Ramp up period: not marginalizing anything"
+ "Range relocalization is not supported"
+ "Ratio by which the number of point features is adjusted in low stereo coverage."
+ "Ratio of stationary points must be greater than zero"
+ "Ratio of stationary points must be smaller or equal to 1"
+ "Ratio of the smallest to the the second smallest eigen values."
+ "Raw"
+ "Ray mapper type is out of range: "
+ "Re-initializing because the pose is out of space boundaries in moving slam"
+ "Re-initializing due to Health"
+ "Reading "
+ "Readout time not found in calibration."
+ "Receive packets from "
+ "Received Accel measurement exceeds maximum gap"
+ "Received Gyro measurement exceeds maximum gap"
+ "Received IMU measurement exceeds maximum gap"
+ "Received IMU measurement exceeds maximum gap of %lf. IMU buffer size = %zu, last buffer sample timestamp = %lf, received imu sample timestamp = %lf"
+ "Received a different target destination context during 'update enabled loggers' command. Retargeting of visualized textual log messages is not yet implemented. Command ignored."
+ "Received a weak-keyframe, which should not be shared with others"
+ "Received invalid Sync update from client "
+ "Received invalid format compatibility information"
+ "Received outdated Sync from client. Update the client to protocol 1.3.0 to sync with the server."
+ "Reducing the ba_config.max_num_optimized_tracks from "
+ "Reducing the max_num_map_constraints from "
+ "Reference and current points must be of the same size"
+ "RefinePose4DoF Non-Linear[%f -> %f]"
+ "RefinePose6DoF Non-Linear[%f -> %f]"
+ "Reinit health should be greater than tracking health threshold"
+ "ReinitializationLogicConfig.seconds_to_disable_catastrophic_lux_detector"
+ "ReinitializationLogicConfig.seconds_to_skip_reinitialization"
+ "ReinitializationLogicConfig.skip_reinitialization_during_severe_lux_changes"
+ "ReinitializationLogicConfig.use_heuristics"
+ "Reject state correction due to large update: Theta: %f, translation: %f, %f, %f"
+ "Reject track by Triangulator::ClassifyInlierTrack()."
+ "Relative poses has to be consecutive"
+ "RelocResult "
+ "RelocTask "
+ "Relocalization failed to compute covariance for pose."
+ "Relocalization failed to compute pose."
+ "Relocalization successfully computed pose with inliers: %lu / %lu"
+ "Relocalize by Vision!"
+ "Rematch image %u with %u with %zu tracks"
+ "Rematch tracks"
+ "Rematching not supported in HarrisTracker."
+ "Rematching processed %zu image pairs (%zu rev-skipped), allocated %zu track IDs, generated %zu new tracks."
+ "Remove outlier tracks after BA"
+ "Remove outlier tracks before BA"
+ "Remove short tracks"
+ "Removed a state (view:%d) in RemoveStateAndReanchor"
+ "Removing [%s] because of bad directory name."
+ "Removing [%s] because of directory to session ID mismatch."
+ "Removing outliers after update..."
+ "Repeat Sample must be > 0"
+ "Requested 8-bit image, but buffer is 16-bit"
+ "Requested format "
+ "Requested io-format "
+ "Requested to load "
+ "Requested to load format "
+ "Requesting save"
+ "Requesting save with at timestamp [%f]"
+ "ResampleIMUMeasurement Called with < 2 IMU measurements.  Skipping Resampling"
+ "Reset IMU-Camera discrepancy detection due to low texture %f"
+ "Reset mapping module only supports submapping mode"
+ "Reset the prior to previous window due to numerical failure in marginalziation."
+ "Resolution must be even for all octaves"
+ "Retrieved image: "
+ "RollingFileAppender"
+ "Run the second PnP that resulted in: Displacement (%.5f vs %.5f), 2D inliers ratio (%.1f vs %.1f), Spatial distribution (%f vs %f), Gyro-vs-vision-angle-diff (%.4f vs %.4f)"
+ "RunBAFilter creating a window with %lu frames"
+ "RunBAFilter has only %lu frames."
+ "Runtime error during prune: %s"
+ "Runtime error during table of contents load: %s"
+ "SLAM Health:%f, IE:%u, MC:%u"
+ "SLAM init state: Initialized:%{bool}d, Finished:%{bool}d, Num ReInit:%u"
+ "SLAM instance must be in invalid mode"
+ "SLAM pose timestamp: %f Pose:%f, %f, %f, %f, %f, %f"
+ "SLAM produced a new state with info "
+ "SLAM received location data"
+ "SLAM received per frame intrinsics, "
+ "SLAM session is NULL"
+ "SLAM state is NULL"
+ "SLAM variables associated to an entry in front-end tracks should not have been marked as marginalized or removed, and the track is persistent."
+ "SLAM variables not associated to an entry in front-end tracks should have been marked as marginalized or removed."
+ "SLAMCalibration (%d): %s"
+ "SLAMConfig (%d): %s"
+ "SN: "
+ "Samples vs Loaded: %zu %zu"
+ "Sampling interval must be > 0.0"
+ "Save interval must be greater than kMinSaveInterval."
+ "Saving weak keyframes is not supported."
+ "Scaling factor applied to feature signma for determining outliers in low light."
+ "Scaling factor applied to feature signma for determining outliers."
+ "Second PnP RANSAC failed using %lu reference points"
+ "Secondary"
+ "Secondary stream mon-tracks are not allowed in this mode"
+ "Secondary: %s: %zu features, %zu stereo matches and %zu across-time matches"
+ "Seconds to disable detector for catastrophic changes in lux. This prevents consecutively skipping reinitialization for a short period of time."
+ "Seed estimate should not be empty."
+ "Selected the second PnP RANSAC pose with %f inliers and %f spatial distribution"
+ "Self: "
+ "Semantics filtering: "
+ "Sending %zu frames and %zu tracks from BAFilter to PoseTracker"
+ "Sending %zu frames, %zu point tracks and %zu line tracks from PoseTracker to BAFilter"
+ "Sending a frame to pose tracker with %zu IMU samples at %f"
+ "Serialize"
+ "SerializeMapDirectoryToMapDataSample"
+ "Set Sampson threshold to "
+ "Setting up File VisualLogger for SLAM."
+ "Setting up Network VisualLogger for SLAM."
+ "Short Data Drop Reinitialization occurred."
+ "Should not be NAN."
+ "Should not be reached."
+ "Should not happen"
+ "Should not have bad_geometry_in_last_frame_"
+ "ShouldTriggerMapOptimization()"
+ "Sigma of the gaussian kernal used to assign the number of features selected from each region of the image."
+ "Sim1"
+ "Sim2"
+ "Size of camera models should be same as that of descriptors."
+ "Size of requested track mask exceeded maximum vector size."
+ "Size of requested track matrix exceeded maximum vector size."
+ "Sizes should match after updating from window."
+ "Skip IMU-Camera discrepancy because the error is decreasing  %f --> %f"
+ "Skipped the second PnP hypothesis for lack of points"
+ "Skips first component."
+ "Skips last component."
+ "Slam state is missing metadata"
+ "Smudge Detector filtering (HW): Camera ID: [%02u] SFeat: %u, Smudginess: %0.2f, PercentageSFeats: %0.2f, State Detector: %u"
+ "Smudge Detector filtering (SW): Camera ID: [%02u] SFeat: %u, Smudginess: /%0.2f, PercentageSFeats: %0.2f, State Detector: %u"
+ "Smudge parameters not initialized"
+ "SmudgeDetected"
+ "Some anchors were not classified."
+ "Span of value type "
+ "Special case to handle Err. Propagation order of magnitude disparity."
+ "Speed thresholds need to be increasing with higher motion"
+ "Speed tolerance factor must be positive"
+ "Standard deviation is undefined for empty ranges"
+ "Start initialization for SLAM session "
+ "Start should be greater than 0"
+ "Starting map optimization"
+ "State ID not set"
+ "State ["
+ "State already exists in vio database"
+ "State correction request is not set"
+ "State does not exist in pose-graph graph"
+ "State id does not match"
+ "State id size should be greater than 2"
+ "State must be weak"
+ "State set cannot be empty"
+ "State to be pruned must have 1 odometry edge."
+ "States size must match timestamps size"
+ "StaticFeatureDetectorConfig.max_gyro_camera_time_diff_s"
+ "Stationary factors are disabled"
+ "Stationary threshold for the device angular velocity (rad/s)."
+ "Stationary threshold for the device linear velocity."
+ "Steady"
+ "Stereo not yet supported for line tracking"
+ "StereoDominant"
+ "Still exists weak/sliding states before corrupted map removal."
+ "Stream ID cannot exceeds 16 bits"
+ "Stream index out of range"
+ "Stream input does not match system configuration."
+ "Stream must have valid secondary to primary matches"
+ "String"
+ "Submap ("
+ "Submap ID mismatch during MapUpdateSample move."
+ "Submap session ID must exist!"
+ "Submap: "
+ "Submitting a window to BA with %zu point tracks, %zu line tracks, and %zu frames (IDs %d...%d)"
+ "SuperWide"
+ "Surfacing a hint to the user %.3f seconds since last re-initialization and %.3f since start of session (or long data drop)"
+ "SwapDefaultStorage was given nullptr"
+ "Switched to sequential sampling since the VLAD/PCA model could not be loaded."
+ "Switching to VIO from VO because VIO health check has been succeeding for %u frames"
+ "Switching to VO because IMU and camera do not agree on motion."
+ "Switching to VO because VIO has been failing health check for %u frames"
+ "Switching to VO because VIO was re-initialized."
+ "Swproxy hw desgen is not supported in this flow."
+ "Sync"
+ "SyncCommand"
+ "Sync{"
+ "TRACE_TO_FATAL"
+ "TTFL:ReinitializedTimer i:%f, s:%f, l:%f"
+ "T_I_to_C"
+ "T_I_to_C_ptr"
+ "T_Iquery_cov: \n"
+ "T_Iquery_info: \n"
+ "T_ItoC"
+ "Target state id is after oldest_acc_pose_and_cov.state_id1"
+ "Target state id is before oldest_acc_pose_and_cov.state_id0"
+ "Target state id is not before relative_pos_and_cov_queue_.front().state_id0"
+ "TextLog"
+ "The CV3DModelRef object for the object region proposal model is provided but the region proposal model will be disabled for this slow device."
+ "The IMU sample buffer cannoty be empty!"
+ "The `accel_conversion` is specified, but does not have a length of 9... ignoring."
+ "The `color_map` may not be empty."
+ "The `gyro_conversion` is specified, but does not have a length of 9... ignoring."
+ "The anchor exist in the object anchor set!"
+ "The anchor must have post metadata attached"
+ "The anchor row measurement has not been set in rolling-shutter compensation."
+ "The bundle had been completed, yet we got another set of features for it! The DataVerificationNode should prevent ever getting here."
+ "The camera set features must exist for the already estimated state"
+ "The camera video mode is not supported for HWFP"
+ "The class has already been initialized, but the reference frame @%f was never added before."
+ "The current solver should NOT be a light BA solver."
+ "The delta transformation is empty"
+ "The edge type is not PoseGraphEdgeType::kVIOEpipolarFactor4DoF"
+ "The eigen value is small than zero"
+ "The feature sigma is not set!"
+ "The feature sigma is not set."
+ "The first P3P-based Two-view found %u inliers (of %zu total 2D-2D points = %f). Triangulated %lu out of %u reference 2D-3D correspondences"
+ "The first and the last observation in the track must be valid."
+ "The given CM data is NULL"
+ "The given `CV3DSLAMAnchorUpdateRef` is NULL"
+ "The given anchor group is NULL"
+ "The given anchor is NULL"
+ "The graph is not set"
+ "The gyro scale update is NOT applied due to being too large: %f."
+ "The incoming frame must not have been processed yet"
+ "The inertial states trajectory must have a pose for each optimized trajectory pose."
+ "The mapping_add_new_kf_output_queue_ needs to be empty when pushing new result"
+ "The minimum view number has to be larger 0"
+ "The new submap id is not consumed by front-end, resend again"
+ "The new track ID must not be used in the track_set."
+ "The number of 2D points and 3D points must be matched."
+ "The number of bins to divide each row/column of the image into."
+ "The number of elements in the output arrays must be the same on input."
+ "The number of features does not match number of cameras"
+ "The number of the 3D points must be equal to the number of 2D-points"
+ "The optional camera set model should be available for stereo pair."
+ "The persistent track is not associated to a SLAM landmark variable"
+ "The prior variance cannot be smaller or equal to 0"
+ "The prior variance cannot be smaller than 0"
+ "The requested IMU State (%d) does not exist in the StateSet"
+ "The resolution is too high; pixel sum will overflow."
+ "The sample size for each trial."
+ "The session has not been initialized. You need to call CV3DSLAMInitialize before calling this method"
+ "The session has not been initialized. You need to call. CV3DSLAMInitialize before calling this method"
+ "The skipping frame timestamp should be the same as the latest processed timestamp."
+ "The state associated to the latest observation should be in state set."
+ "The state does not align to the current bundle."
+ "The state timstamp should be less than IMU start iter"
+ "The time difference cannot be negative"
+ "The timestamp of imu measurements must increase monotonically"
+ "The timestamp of the new vio pose must increase monotonically"
+ "The track does not have a structure!"
+ "The track does not have the structure"
+ "The update must happen at the incoming state"
+ "The video mode was changed to %d"
+ "The window must be in incremental mode."
+ "There are %zu total constraints but only %zu scores were generated."
+ "There are %zu total constraints but will only select %zu with a valid score."
+ "There is no injection in fall-back mode."
+ "There must be a prior factor for the time offset variable."
+ "There must be a stereo camera for Vision Pose Tracker"
+ "There needs to be two states to interpolate in visual slam"
+ "There should not be any SLAM landmark Variable with this track ID."
+ "There were no IMU measurements. Data problem?"
+ "Thermocompensation model is missing. Calibration convergence detection will be inaccurate."
+ "This does nothing."
+ "This info should be invalid for regular SLAM candidate keyframes"
+ "This return should only be set once"
+ "Threshold for consecutive low texture states to disable calibration estimation."
+ "Threshold of conservative mode #2 should be smaller than that of mode #1, or mode #2 is disabled."
+ "Tiff"
+ "Time (seconds) to skip reinitialization in the event that there's a significant change in the lux estimates. Unit: sec."
+ "Time interval in seconds for logging calibration parameters."
+ "Time offset after initialized and healthy to start IMU intrinsics estimation."
+ "Time step error must be non-negative"
+ "Time: "
+ "Time: %f ICDVS: STR:%f, AVGF:%f, Stereo:%u, ERR:%f, PropVsBAOriERR:%f, AvgGyro:%f, vel:%f  should: %d drift: [%d | %d | %d]"
+ "Timeout connecting to %s:%d"
+ "Timeout while waiting for connection established"
+ "Timestamp: "
+ "Timestamps in vector haven't been sorted."
+ "To many features in prune."
+ "Toggle for using heuristics based reinitalization."
+ "Toggle odometry only mode in Local Slam Engine."
+ "Tolerance for depth change in the stereo forward direction, in meters."
+ "Too many octaves specified"
+ "Top pyramid level must have the same size."
+ "Trace cannot be NaN!"
+ "Track covariance skipped in mode 2."
+ "Track index has %zu frames (of %zu capacity)"
+ "Track length histogram after rematch"
+ "Track length histogram before rematch"
+ "Track set size : "
+ "TrackFeatures not supported for harris tracker"
+ "TrackingFailedDueToSmudge"
+ "TrackingStatusConfig.max_allowed_camera_extrinsic_rotation_diff_wrt_defualt_in_rad"
+ "Tracks in range: %zu With lengths: %zu to %zu"
+ "Trajectory optimization"
+ "Transform3"
+ "Transform3{src: "
+ "Transition window/time left must be non-negative"
+ "TransitionCameraMode"
+ "TriMesh"
+ "TriMeshData{\n"
+ "Triangle accepted due to semantic info: %d %f"
+ "TriangulationBasedCalibrationChangeDetectorConfig.enable_thermal_model"
+ "TriangulationBasedCalibrationChangeDetectorConfig.max_depth_change"
+ "TriangulationBasedCalibrationChangeDetectorConfig.metric"
+ "TriangulatorConfig.min_depth_prior_info_to_enable_anchor_camera_only_triangulation"
+ "Tried to create parameter object "
+ "Tried to insert an item with ID < last that was not present"
+ "Trigger a reinitialization at MultiCameraFeatureDetectionNodeWorker@ %f, based on reinit signal from LSE."
+ "Try to read "
+ "Trying to read "
+ "Tukey cost increase. Use previous scale."
+ "Two-point RANSAC generated zero hypotheses."
+ "Two-point ransac received %zu correspondences, which is less than sample size %zu"
+ "Two-view found %zu inliers (of %zu total) sampson: %f"
+ "U coordinate is not closed."
+ "UUID: "
+ "Unable to add IMU State"
+ "Unable to add reference object, err %d"
+ "Unable to find factor in linear system in replacing pose to pose constraint."
+ "Unable to find variable in linear system in replacing pose to pose constraint."
+ "Unable to handle no measurements."
+ "Unable to insert image id %zu because it already exists"
+ "Unable to interpolate AccelX IMU sample"
+ "Unable to interpolate AccelY IMU sample"
+ "Unable to interpolate AccelZ IMU sample"
+ "Unable to interpolate GyroX IMU sample"
+ "Unable to interpolate GyroY IMU sample"
+ "Unable to interpolate GyroZ IMU sample"
+ "Unexpected deserialization, Cannot find the frame"
+ "Unexpected deserialization, Imcompatible feature index exceeds frame features"
+ "Unexpected deserialization, Incompatible Track observation"
+ "Unexpected deserialization, anchor frame ID not found"
+ "Unexpected deserialization, failed to SetAnchor()!"
+ "Unexpected deserialization, failed to find pose_ref!"
+ "Unexpected deserialization, new structure should not be initialized to valid covariance."
+ "Unexpected value in permutation matrix"
+ "Unfound camera stream"
+ "Uninitialized image data pointer"
+ "Uninitialized image height"
+ "Uninitialized image width"
+ "Uninitialized image widthStep"
+ "Unknown Keyframe matching method!"
+ "Unknown Keyframe sampling method!"
+ "Unknown appender alias "
+ "Unknown collaborative mapping data type %hhu"
+ "Unknown health module"
+ "Unkonwn hit-test origin"
+ "Unsupported"
+ "Unsupported Format"
+ "Unsupported alpha info "
+ "Unsupported format"
+ "Unsupported pnm format. Loader does not support Rgb16u (.pbm) loading yet."
+ "Unsupported pnm format. Loader does not support intensity scaling. File specifies maximum intensity "
+ "Unsupported pose-graph edge type"
+ "Unsupported type"
+ "Unsupportted edges"
+ "Update VisualInertialBundleAdjusterConfig.initial_time_offset_variance: "
+ "Update existing IMU intrinsic prior factor with factor ID: %d."
+ "UpdateEnabledContexts"
+ "UpdateEnabledLoggers"
+ "UpdateFromStates did not match frame %zu (ID=%d), yet a previous frame was matched."
+ "UpdateSyncConfiguration"
+ "Updating track index from an estimate (ID=%d) containing %zu frames (IDs %d...%d)"
+ "Use Input800HzFilter3dB50Hz5thOrderOutput100Hz instead of Input800HzFilter3dB50Hz5rdOrderOutput100Hz."
+ "User anchor pose has nans"
+ "User anchor rotation has nans"
+ "User anchor translation has nans"
+ "User anchors are not enabled"
+ "User map keyframe to anchor rotation has nans"
+ "Using ESPRESSO_ENGINE_ANE_RUNTIME to create Espresso Context"
+ "Using ESPRESSO_ENGINE_MPS to create Espresso Context"
+ "Using In-Motion initialization."
+ "Using Stationary initialization."
+ "Using accel for interpolation at "
+ "Using five-point algorithm"
+ "Using gyro for interpolation at "
+ "V1_2_RequestOrAck"
+ "VDOrientationEstimation Error: "
+ "VDOrientationEstimation: IMU based rejection"
+ "VDOrientationRefiner: RotationRefinement Non-Linear [%f -> %f]"
+ "VDataExporter"
+ "VFusion Has not initialized yet"
+ "VFusion has not processed the window"
+ "VFusionConfig.min_abs_gyro_integral_for_imu_intrinsics_estimation"
+ "VFusionConfig.time_offset_to_start_imu_intrinsics_estimation_in_sec"
+ "VFusionTrackerConfig.disparity_fraction_for_superwide_in_deg"
+ "VIO Frame Lens is not set!"
+ "VIO Health Eigen vals for plane normal matrix %f, %f, %f"
+ "VIO database and state set must not be null or empty."
+ "VIO database and state set must not be null."
+ "VIO health buffer size."
+ "VIO only support 1 or 2 cameras."
+ "VIO state not found"
+ "VIO::MATH::CenterDataPolyFit: High condition number.  Return 0 poly coeffs."
+ "VIODataVerification ctor: "
+ "VIOFrame does not exist!"
+ "VIOFrame invalid feature index!"
+ "VIOFrame invalid feature_indices size!"
+ "VIOFrame invalid reloc feature index!"
+ "VIOFrame invalid reloc feature_indices size!"
+ "VIOMetadata must have pose metadata"
+ "VLAD: "
+ "VSExtrapolation. Source: %u, NumTriang: %f, 2dInliers: %f, translation: %f, GyroR: %f, VisionR: %f, PositionExtra: %d, UseGyroRot: %d"
+ "VSL starts to process feature sample of camera ID: %u, @%f"
+ "Variable missing"
+ "Variable stats:\n"
+ "Variables not being updated."
+ "Virtual channel %d not handled"
+ "Vision-Only initial state got updated using the prior state"
+ "Vision-Tracker metadata should be invalid"
+ "Vision-based stationary detection. Inliers: "
+ "Vision-only prediction not yet implemented"
+ "Vision-stationary ratio to conclude moving platform."
+ "VisualInertialBundleAdjusterConfig.enable_consistent_marginalization"
+ "VisualInertialBundleAdjusterConfig.extrinsics_estimation_strategy_enabled_init"
+ "VisualInertialBundleAdjusterConfig.fix_rotation_around_gravity_vector_degree_of_freedom"
+ "VisualInertialBundleAdjusterConfig.intrinsics_estimation_strategy_enabled_init"
+ "VisualInertialBundleAdjusterConfig.max_ratio_marginalized_tracks_in_consistent_marginalization"
+ "VisualInertialBundleAdjusterConfig.time_interval_for_logging_calibration_parameters"
+ "VisualLoggerServer %s:%d not running: %s"
+ "VisualSLAM1StOrderPoseExtrapolate: timestamp1 and timestamp2=%f too close.  Returning state2"
+ "VisualSLAMAddInertialState timestamp (%f) less than or equal to previous state timestamp (%f). Inertial state not updated."
+ "VisualSLAMGetInertialStateAtTime (in GetPredictionBundleVisualSLAM) failed with InterpolateFailed: Could not interpolate the IMU samples used for inertial state propagation for pose request timestamp="
+ "VisualSLAMGetInertialStateAtTime: Ignoring allow_extrapolate at time %f."
+ "WARN_TO_FATAL"
+ "Waiting"
+ "Waiting Front-end module to update latest map keyframe ID"
+ "Warn"
+ "We can only set the prior state if the filter is not initialized yet"
+ "We cannot have an object anchor that is not anchored."
+ "We fail to remove states which should not happen"
+ "We have an empty window!"
+ "We must be using IMU"
+ "We must be using a stereo camera in vision-only"
+ "We should always be able to find a track"
+ "We should be always able to add tracks"
+ "We should extrapolate the pose because PnP has failed"
+ "We should extrapolate the pose because exceeded the maximum frame-to-frame displacement (%f) while gyro-angle is %f."
+ "We should extrapolate the pose because we dont have enough 2D-3D correspondences to run PnP RANSAC (%u)."
+ "We should extrapolate the pose because we dont have enough inliers (%u)."
+ "We should have zero tracks"
+ "We should not call this function since it is ill implemented. See `Compute4DoFDeltaBetweenSE3Transforms()` for reference.\n"
+ "We should not failing set a anchor"
+ "We should not use tracks from this camera for mapping"
+ "We should only populate m_cameraToIMUVariables once."
+ "We will not succeed adding a factor"
+ "WeakMapClassifier [%d]: rotation-rate %f, revisited %d , health %f, far_away %d, speed %f, acceleration %f slow_rotation_rate %d"
+ "When re-anchoring, failed to set anchor for track using frame "
+ "When syncing is disabled, the first sync point must not be deferred"
+ "Whether to use area binning based feature selection."
+ "While connecting a new client, failed to send configuration to client: "
+ "Wide"
+ "Will"
+ "Will not"
+ "Window size is %.d"
+ "WindowSize "
+ "Wrong filter weight"
+ "XYZ"
+ "[ timestamp: ("
+ "[%.*s] Camera %d: Fx: %f, Fy: %f, Cx: %f, Cy: %f"
+ "[%.*s] Camera %d: fx_b: %f, fy_b: %f, cx_b: %f, cy_b: %f"
+ "[%.*s] extrinsic fg-p id[%d]: p %.8f, %.8f, %.8f, R: %.9f, %.9f, %.9f, %.9f, %.9f, %.9f, %.9f, %.9f, %.9f"
+ "[%llu] has been pruned.\n"
+ "[%llu] was missing from ToC.\n"
+ "[%s]"
+ "[%s] %s: Continued %d and created %d tracks (with %d invalid)."
+ "[%s] contains valid metadata."
+ "[%s] could not be deserialized."
+ "[%s] didn't allow access to subdirectories."
+ "[%s] does not contain metadata.\n"
+ "[%s] does not have metadata."
+ "[%s] does not have read permissions."
+ "[%s] exists in mapping directory."
+ "[%s] failed to commit temporary mapping IO files."
+ "[%s] failed to deserialize."
+ "[%s] failed to load submap.\n"
+ "[%s] failed to open stream."
+ "[%s] had a bad istream."
+ "[%s] load status was not successful."
+ "[%s] was not loaded."
+ "[%s] was removed because keyframe is missing."
+ "[%s] was removed because keypopints are missing."
+ "[%s] was removed do to improper directory name."
+ "[%s] was saved successfully."
+ "[Anchors] Timestamp:%f, Updated:%u, External:%u, Removed:%u, New :%u"
+ "[CA] "
+ "[CA] Allocation budgets: "
+ "[CA] Camera %u has %d tracks"
+ "[CA] CameraAllocationState: %{public}s"
+ "[CA] Low inlier mode: %{bool}d"
+ "[CA] Stereo tracking has poor quality: Primary cameras inlier ratio: %f Secondary cameras inlier ratio: %f Stereo match ratio: %f"
+ "[CA] camera: ["
+ "[CA] is low light: "
+ "[CA] mono_stream_camera_recall:  "
+ "[CA] multi_stream_camera_recall: "
+ "[CM] "
+ "[CM] Process external keyframe (%llu,%d) already exist in self map"
+ "[CM] Session: "
+ "[CM] User: "
+ "[CM]["
+ "[CVCalUpdate] Gyro scale factor applied: %f %f %f"
+ "[Camera %u, stream %u] Got %d point correspondences and %d line correspondences to reference frame (which is %zu frames back)"
+ "[ComputeAffinityMatrix] Maximum number of nonzero entries reached (%d). Returning a null matrix..."
+ "[DEPRECATED] Change '%s' to '%s'"
+ "[FG] Enable pose-graph because adding new keyframe"
+ "[FG] StateCorrection for state %d"
+ "[FeatureFilterTransform] Camera %u: Num features after pruning: %lu"
+ "[FeatureFilterTransform] T_Gcrop_to_C -- Camera %u @ Timestamp %f \nRotation {%f,%f,%f,%f,%f,%f,%f,%f,%f} \nTranslation: {%f,%f,%f}"
+ "[Features Tracking] Found %zu/%zu stereo-matches after refinement"
+ "[Features Tracking] stereo matching is disabled"
+ "[FinishUpdate] Got %zu/%zu inlier points, %zu/%zu inlier lines, and %zu/%zu inlier planes"
+ "[GetCandidateMatches] Maximum number of line segments reached (%ld).  Ending candidate matching prematureely..."
+ "[HealthHeuristics]"
+ "[LINE STATION] reject stationary? %d : inlier_eigenvalue %f, num_lines %zu, num_line_inliers %zu"
+ "[LINE STATION]: Line tracking Disabled"
+ "[LINE STATION]: NumTrackedFeatures: %zu"
+ "[MLPosePredictor]   Discard InertialState with timestamp %.4f, filter_timestamp_: %.4f, filter_timestamp_staged_: %.4f"
+ "[MLPosePredictor] Accel timestamp does not move foward."
+ "[MLPosePredictor] Computed imu_interval %.3f deviates from %.3f at %.6f. This might be caused by skipped frames. Reset latest_imu_interval_."
+ "[MLPosePredictor] Gyro timestamp does not move foward."
+ "[MLPosePredictor] InertialState timestamp does not move foward. Skipping."
+ "[MLPosePredictor] InertialState timestamp is earlier than IMU timestamp"
+ "[MLPosePredictor] PosePredictor's timestamp (%.8f) does not match filter (%.8f)"
+ "[MLPosePredictor] Reset MLFilter as InertialState gap is too large."
+ "[MLPosePredictor] Reset MLFilter as VIO is not initialized."
+ "[MLPosePredictor] Reset MLFilter by SLAM."
+ "[MLPosePredictor] Reset MLFilter due to accel drop at %.6f."
+ "[MLPosePredictor] Reset MLFilter due to discrepancy with SLAM."
+ "[MLPosePredictor] Reset MLFilter due to gyro drop at %.6f."
+ "[MLPosePredictor] Reset MLFilter due to kMaxMLFilterRuntime."
+ "[MLPosePredictor] Reset MLFilter due to long propagation."
+ "[MLPosePredictor] Reset MLFilter due to missing IMU measurements."
+ "[MLPosePredictor] SetIntervalRate to %.5f."
+ "[MLPosePredictor] Unable to predict for %.8f: timestamp too early (%.3f)"
+ "[MLPosePredictor] Unable to predict for %.8f: timestamp too late"
+ "[MLPosePredictor] We have a queued pose at %.8f but the query time is %.8f"
+ "[P3P Outlier Rejection] Triangulated %lu out of %u reference points"
+ "[RLC] Delayed reinitialization feature disabled until timestamp: @ %f"
+ "[RLC] Delayed updating re-initialization due to: Force Reinitialization Failure."
+ "[RLC] Delayed updating re-initialization due to: Lux Change."
+ "[RLC] Large change in lux detected, delay reinitialization for %f seconds"
+ "[RLC] Large lux change detector re-enabled @ %f"
+ "[RLC] Seconds until reinit re-enabled: %f"
+ "[RLC] Significant lux change:%{bool}d"
+ "[SC, Post update map measurements:"
+ "[SC, Prior update map measurements:"
+ "[Stationary drift] Stationary ratio:%f, Pos. Error:%f,  Velocity:%f"
+ "[TrackingStatusClassifier] ClearCache"
+ "[TrackingStatusClassifier] IMU fault detected: %u, %u, %u, %u"
+ "[TrackingStatusClassifier] Invalid time delta between measurements"
+ "[TrackingStatusClassifier] Invalid window side (time duration: %f)"
+ "[VIOBABase] : Cannot find the current IMU State's Variables."
+ "[VIOBABase] : The requested IMU State's Factors already exists."
+ "[row byte stride "
+ "]\n"
+ "] 2d-3d: "
+ "] Camera "
+ "] ExternalLens "
+ "] Trigger optimize map()"
+ "] file for MappingIO logging"
+ "] frame_to_frame="
+ "], out=["
+ "_f"
+ "`, place your overrides in the path `"
+ "`, run `setclass "
+ "`. Instead, delete it with `dvdo rm -f "
+ "`opt_camera_set_model` should be non-empty for a stereo feature sample."
+ "`opt_last_imu_in_latest_bad_geo_frame_` must be valid if the last frame had bad geometry."
+ "a: "
+ "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
+ "accel_buffer.size() == gyro_buffer.size()"
+ "accel_cfs.rows() == ls_pred_cfg_.num_taps && accel_cfs.columns() == ls_pred_cfg_.max_pred_samples"
+ "accel_it != mAccelerometerMeasurements.end()"
+ "accel_threshold needs to be > 0"
+ "accel_window_time_secs >= 0"
+ "acknowledge_until"
+ "active_channel_ == channel"
+ "added"
+ "affine3x4"
+ "algebra_r"
+ "algebra_t"
+ "alpha_beta_filter_default_dt > 0"
+ "anchor direction should be normalized to 1"
+ "anchor plane should not be all zeros"
+ "anchor.anchor_.group_id_"
+ "anchor_frame_index_iter != image_id_to_frame_index.end()"
+ "anchor_pose_ref"
+ "ang_step must be between 0 and M_PI_2."
+ "appender"
+ "area_binning_gaussian_kernel_sigma"
+ "area_binning_num_bins_1d"
+ "area_binning_num_bins_1d % 2 == 1"
+ "area_mapping::StringToKeyframeMatchingMethod( config_slam_relocalization.keyframe_matching_method) != area_mapping::KeyframeMatchingMethod::Unknown"
+ "area_mapping::StringToKeyframeSamplingMethod( config_slam_relocalization.keyframe_sampling_method) != area_mapping::KeyframeSamplingMethod::Unknown"
+ "auto_timestamp"
+ "bad geometry: "
+ "baid && (baid->linearSystem().updatedAfterSolve() || baid->linearSystem().revertedAfterSolve() || baid->linearSystem().solveAttemptedAndFailed())"
+ "base_pose_ref"
+ "bbox={"
+ "begin < end"
+ "bin index should always be 0"
+ "bin_index == 0"
+ "block_size >= kMinBlockSize"
+ "blocking caller while waiting for space in queue"
+ "both end points should be valid"
+ "box"
+ "buckets_hist.size() == bucket_num"
+ "bundle timestamp_index needs to be valid"
+ "bundle.prediction_type != VisualSLAMPosePredictionType::Interpolate || visual_slam_window_.states.size() == 2u"
+ "bundle_.switch_timestamp"
+ "bundle_.timestamp_index"
+ "bundle_prior_info_.type == BundlePriorInformationType::InertialStatePriorInfo"
+ "byte_size"
+ "bytes"
+ "bytes_per_row >= min_bytes_per_row"
+ "c_store.timestamp_info.original_timestamp() >= 0"
+ "callable != nullptr"
+ "cam_strm_id.camera_id < cam_list.size() && cam_strm_id.stream_id < cam_list[cam_strm_id.camera_id].NumStreams()"
+ "cam_strm_id.camera_id < camera_set_models.size()"
+ "camera"
+ "camera ID does not match: "
+ "camera ID is out of range: "
+ "camera_SE3Group_.count(imageID)"
+ "camera_descriptor_stores's camera id is not aligned as index"
+ "camera_descriptor_stores.size() == front_end_interface_->vfusion().GetCameraModelsWithDefaultIntrinsics().size()"
+ "camera_features.NumStreams() == descriptors.NumStreams()"
+ "camera_id <= 0xffff"
+ "camera_id == nav_->StateIDandIntrinsics().back_n(1).camera_set_intrinsic_vec.front().camera_id"
+ "camera_models->NumStreams() == 2u"
+ "camera_set_ftr"
+ "camera_switching_frame_rates and camera_switching_events must be the same size"
+ "camera_type"
+ "camera_vision_models.front().NumStreams() == 2u"
+ "cameras must not be empty"
+ "cannot create a new track"
+ "cannot find camera pose"
+ "cannot find camera pose for node"
+ "capi_return.has_value()"
+ "casted"
+ "caught runtime exception"
+ "caught unknown thrown object"
+ "cfg.transition_times.TransitionMoving2Stationary_window > 0.0"
+ "cfg.transition_times.TransitionMoving2Walking_window > 0.0"
+ "cfg.transition_times.TransitionStationary2Moving_window > 0.0"
+ "cfg.transition_times.TransitionWalking2Moving_window > 0.0"
+ "cfg.transition_times.stationary_window_to_switch_from_motion > 0.0"
+ "cfs_end.rows() == ls_pred_cfg_.num_taps && cfs_end.columns() == ls_pred_cfg_.max_pred_samples"
+ "cfs_start.rows() == ls_pred_cfg_.num_taps && cfs_start.columns() == ls_pred_cfg_.max_pred_samples"
+ "cg_image.IsValid()"
+ "chosen common I/O format is not supported for the data type"
+ "circular_queue"
+ "client"
+ "client Receive() threw exception"
+ "client can't reach server"
+ "client does not have syncing enabled"
+ "client not found"
+ "client send failure"
+ "clock_type"
+ "cloud.size() <= std::numeric_limits<size_t>::max() - non_filtered_structure.size()"
+ "cloud.size() == ids.size() * num_structure_per_element && cloud.size() == vergence_angle_cosines.size()"
+ "code"
+ "colors"
+ "colors={"
+ "colors_type"
+ "colors_type="
+ "com.apple.AppleCV3D.SLAM.DoffEvent"
+ "com.apple.AppleCV3D.SLAM.MapSaved"
+ "com.apple.arkit"
+ "compat.format.has_value()"
+ "confidence32_img_pool_"
+ "confidences={"
+ "confidences_type"
+ "confidences_type="
+ "config().ml_desc_config.feature_type != feature_detection::FeatureType::DetectorNoneDescriptorATUHardNetGlobalFeat"
+ "config.fine_height >> octave >= kernel_size()"
+ "config.fine_width >> octave >= kernel_size()"
+ "config.image_height - config.bucket_height <= std::numeric_limits<int>::max()"
+ "config.image_height - config.bucket_height is outside the range of int"
+ "config.image_width - config.bucket_width <= std::numeric_limits<int>::max()"
+ "config.image_width - config.bucket_width is outside the range of int"
+ "config.max_keypoints <= std::numeric_limits<int>::max()"
+ "config.max_keypoints is outside the range of int"
+ "config.max_subpixel_iterations <= std::numeric_limits<int>::max()"
+ "config.max_subpixel_iterations is outside the range of int"
+ "config.num_buckets_scale <= std::numeric_limits<int>::max()"
+ "config.num_buckets_x <= std::numeric_limits<int>::max()"
+ "config.num_buckets_y <= std::numeric_limits<int>::max()"
+ "config.num_scales_per_octave == 3"
+ "config_.bundle_adjuster_config.enable_consistent_marginalization"
+ "config_.conservative_tracking_speeds_m_s_sq[2] < config_.conservative_tracking_speeds_m_s_sq[1] || ExactlyEqual(config_.conservative_tracking_speeds_m_s_sq[2], 0.0)"
+ "config_.imu_extrapolation_config.accel_filter_config.RLS_filter_mode != RLSTrainingFilterModes::MotionIMUFilteringSmooth"
+ "config_.imu_filter_switch_config.transition_times .stationary_window_to_switch_from_motion > 0.0"
+ "config_.imu_filter_switch_config.transition_times.TransitionMoving2Stationary_window > 0.0"
+ "config_.imu_filter_switch_config.transition_times.TransitionMoving2Walking_window > 0.0"
+ "config_.imu_filter_switch_config.transition_times.TransitionStationary2Moving_window > 0.0"
+ "config_.imu_filter_switch_config.transition_times.TransitionWalking2Moving_window > 0.0"
+ "config_.imu_filter_switch_config.transition_times.enter_walking_mode_time_window > 0.0"
+ "config_.imu_filter_switch_config.transition_times.walking_mode_time_window > 0.0"
+ "config_.input_vio_pose_interval > 1e-6"
+ "config_.min_acceptable_health_for_reinit >= config_.min_acceptable_health"
+ "config_.min_num_pnp_inlier_map_matches.size() == config_.min_pnp_inlier_ratio.size()"
+ "config_.pose_filter_config.accel_window_time_secs >= 0.0"
+ "config_.pose_filter_config.alpha_beta_filter_default_dt > 0.0"
+ "config_.pose_filter_config.default_sample_rate > 0.0"
+ "config_.pose_filter_config.gyro_window_time_secs >= 0.0"
+ "config_.pose_filter_config.pose_filtering_motion_configs[0].user_motion_classifier == PoseFilteringMotionClassifier::UserStationary"
+ "config_.pose_filter_config.pose_filtering_motion_configs[1].accel_threshold > config_.pose_filter_config.pose_filtering_motion_configs[0].accel_threshold"
+ "config_.pose_filter_config.pose_filtering_motion_configs[1].gyro_threshold > config_.pose_filter_config.pose_filtering_motion_configs[0].gyro_threshold"
+ "config_.pose_filter_config.pose_filtering_motion_configs[1].speed_threshold > config_.pose_filter_config.pose_filtering_motion_configs[0].speed_threshold"
+ "config_.pose_filter_config.pose_filtering_motion_configs[1].user_motion_classifier == PoseFilteringMotionClassifier::UserMoving"
+ "config_.pose_filter_config.transition_config.hysteresis_time_window_in_motion >= 0.0"
+ "config_.pose_filter_config.transition_config.transition_window_state_A2B_sec >= 0.0"
+ "config_.pose_smoothing_config.hysteresis_buffer_size > 0"
+ "config_.primary_cameras.size() == 1"
+ "config_.save_interval > kMinSaveInterval"
+ "config_.secondary_cameras.size() == 1"
+ "config_.vio_health_queue_size > 0u"
+ "config_.visual_slam_config.rls_gyro_filter_config.max_pred_samples == config_.visual_slam_config.rls_accel_filter_config.max_pred_samples"
+ "config_.visual_slam_config.rls_gyro_filter_config.max_pred_samples > 0u"
+ "connection status update"
+ "conservative track mode: "
+ "consistent_avg_propagated_pose: "
+ "const char *cva::TypeNameDetail::prettyFunName() [T = cv3d::vio::Generic3DoFVariable<double>]"
+ "const char *cva::TypeNameDetail::prettyFunName() [T = cv3d::vio::GenericCalibVariablePriorFactor<double, cv3d::vio::IntrinsicsCalibVariable<double>>]"
+ "const char *cva::TypeNameDetail::prettyFunName() [T = cv3d::vio::StateAndIMUTimeOffsetPriorFactor<double>]"
+ "const char *cva::TypeNameDetail::prettyFunName() [T = cv3d::vio::TimeOffsetVariable]"
+ "const char *cva::TypeNameDetail::prettyFunName() [T = cv3d::vio::VIOCameraExtrinsicPriorFactor<double, cv3d::vio::VIOExtrinsicsVariable<double>>]"
+ "const char *cva::TypeNameDetail::prettyFunName() [T = cv3d::vio::VIODepthExtrinsicsVariable<double>]"
+ "const char *cva::TypeNameDetail::prettyFunName() [T = cv3d::vio::VIOIMUVelocityBiasesVariable<double>]"
+ "const char *cva::TypeNameDetail::prettyFunName() [T = cv3d::vio::VIOIMUWithDeltaTimeFactor<double>]"
+ "const char *cva::TypeNameDetail::prettyFunName() [T = cv3d::vio::VIOIMUWithIntrinsicsCalib<double>]"
+ "const char *cva::TypeNameDetail::prettyFunName() [T = cv3d::vio::VIOLandmarkDepthSqrtCauchyFactor<double, true>]"
+ "const char *cva::TypeNameDetail::prettyFunName() [T = cv3d::vio::VIOLandmarkDepthSqrtCauchyFactorMono<double, true>]"
+ "const char *cva::TypeNameDetail::prettyFunName() [T = cv3d::vio::VIOLandmarkVariable<double>]"
+ "const char *cva::TypeNameDetail::prettyFunName() [T = cv3d::vio::VIOMapLandmarkFactor<double>]"
+ "const char *cva::TypeNameDetail::prettyFunName() [T = cv3d::vio::VIOStatePriorFactor<double>]"
+ "const char *cva::TypeNameDetail::prettyFunName() [T = cv3d::vio::geometry::FisheyeLensModelT<cv3d::vio::geometry::LensType::FisheyeLensKR7>]"
+ "const char *cva::TypeNameDetail::prettyFunName() [T = cv3d::vio::geometry::NoncentricLensModelT<cv3d::vio::geometry::LensType::NoncentricLens>]"
+ "const char *cva::TypeNameDetail::prettyFunName() [T = cv3d::vio::geometry::NoncentricLensModelT<cv3d::vio::geometry::LensType::NoncentricLensKR7>]"
+ "const_model_ref_"
+ "const_shared_camera_set_features != nullptr"
+ "context"
+ "context != nullptr"
+ "context_enable_state_changes"
+ "contexts status update"
+ "cost=%f (vision=%f + inertial=%f + map=0.00 + stationary=%f + projected velocity=0.00 + prior=%f + planes=%f)"
+ "count == kBitsPerFreakDescriptor"
+ "create new map keyframe: "
+ "create new map session "
+ "curr_features.NumStreams() == 2u"
+ "curr_state_var_iter != viostate_variable_ids_.end()"
+ "current"
+ "custom_timestamp"
+ "cv3d.acv.surfacedetection"
+ "cv3d.applecv3d.slam"
+ "cv3d.dgn"
+ "cv3d.esn.resource"
+ "cv3d.kit.net"
+ "cv3d.kit.viz"
+ "cv3d.kit.viz I/O"
+ "cv3d.kit.viz client/server"
+ "cv3d.net"
+ "cv3d.odt.image_detection_and_tracking"
+ "cv3d.vio"
+ "cv3d.vio.MapPoints"
+ "cv3d.vio.area_mapping"
+ "cv3d.vio.batch_least_squares_unsanitized"
+ "cv3d.vio.calibration"
+ "cv3d.vio.capi"
+ "cv3d.vio.cv_types"
+ "cv3d.vio.feature_detection"
+ "cv3d.vio.feature_detection_node_group"
+ "cv3d.vio.feature_matching"
+ "cv3d.vio.feature_matching_unsanitized"
+ "cv3d.vio.flintToVio"
+ "cv3d.vio.geometry"
+ "cv3d.vio.geometry_unsanitized"
+ "cv3d.vio.inertial_sensor"
+ "cv3d.vio.map_optimization"
+ "cv3d.vio.math"
+ "cv3d.vio.odometry_engine"
+ "cv3d.vio.odometry_unsanitized"
+ "cv3d.vio.place_recognition"
+ "cv3d.vio.place_recognition_unsanitized"
+ "cv3d.vio.recognition"
+ "cv3d.vio.slam_engine"
+ "cv3d.vio.util"
+ "cv3d.viz"
+ "cva::exactlyEqual(last_update_timestamp_, -1.) || cva::exactlyEqual(timestamp, last_update_timestamp_)"
+ "d-slice #"
+ "data"
+ "data is invalid"
+ "data of type "
+ "data package unknown to serializer"
+ "data type unknown to package"
+ "data_"
+ "data_id"
+ "default_camera_set_sensor_models.size() == camera_descriptor_stores.size()"
+ "default_query_lens_for_computing_FOV"
+ "default_ref_lens_for_computing_FOV"
+ "default_sample_rate > 0"
+ "depth32_img_pool_"
+ "descriptor.pose_metadata_"
+ "diagnostics processing error"
+ "diagnostics_"
+ "dictionary"
+ "did_add_state"
+ "dimension > 0"
+ "disabled"
+ "disparity_fraction "
+ "dispatch_group_wait failed"
+ "distances equal"
+ "distortion_coeff"
+ "downstream_.empty()"
+ "ds_rates.size() > 0"
+ "dst"
+ "dst < dst_end"
+ "dst.data()"
+ "dt > 0"
+ "e: "
+ "e_dim <= x_dim"
+ "edge.T_source_to_neighbor"
+ "edge_type == PoseGraphEdgeType::kVIOEpipolarFactor4DoF"
+ "edges"
+ "edges={"
+ "eig_values[1 + i] >= 0"
+ "elem"
+ "empty last state propagated covariance"
+ "enable assert on error "
+ "enable latency verification "
+ "enable_predictor_pose_filtering"
+ "enabled"
+ "end_sample_timestamp larger than last sample in measurement buffer"
+ "engine"
+ "engine_"
+ "engine_result.engine != nullptr"
+ "error == 0"
+ "error allocating confidence frame for densification"
+ "error allocating depth frame for densification"
+ "error_callback_"
+ "error_downstream_.empty()"
+ "est period must be > 0"
+ "estimate_.state_ids.back() == bad_geometry_in_last_frame_.second"
+ "exception"
+ "expected_camera_stream_ids_.size() > 0"
+ "ext_reloc_result: "
+ "external_map_iter != external_submaps_.end()"
+ "external_submap.data()"
+ "external_submap.slam_relocalization()"
+ "f"
+ "f.size() >= 1"
+ "faces"
+ "faces={"
+ "factor_iter->second.factor.factor_valid()"
+ "failed to create file "
+ "failed to create frame pool for 32-bit confidence"
+ "failed to create frame pool for 32-bit depth"
+ "failed to load data"
+ "failed to open diagnostics output file: "
+ "failed to open file"
+ "failed to open stream"
+ "failed to project in calculating Jacobian: point + delta = "
+ "failed to project: xc="
+ "failed to read from stream"
+ "failed to retrieve query frame id"
+ "failed to triangulate track "
+ "failed to unproject: xd="
+ "failed to update state with correction for state "
+ "failed to write to diagnostics output file: "
+ "failed to write to stream"
+ "feature must be detected in at least one pyramid level"
+ "feature type is not supported"
+ "feature_points_ptr && \"Feature point ptr from pool is NULL.\""
+ "feature_samples.size() == 2u"
+ "feature_samples[stream_id].point_sample.sec_to_pri_matches"
+ "features[camera_id].R_gyro_prev_to_cur_cam_frame.size() == camera_model->CameraStreamIds().size()"
+ "features_to_keep.size() <= image_features_.size()"
+ "features_to_keep.size() <= num_features"
+ "feedforward_cfs.size() == feedforward_cfs_.size() && feedback_cfs.size() == feedback_cfs_.size()"
+ "fg_info.columns() >= (cv_types::InertialState::kDof + cv_types::CameraFromIMUTransformation::kDof)"
+ "fg_info.columns() >= (cv_types::InertialState::kPoseDof + cv_types::CameraFromIMUTransformation::kDof)"
+ "fg_info.type != BundlePriorInformationType::Invalid"
+ "fg_info.type == BundlePriorInformationType::PosePriorInfo"
+ "file contains different image format"
+ "file is of a different than specified format"
+ "file.good()"
+ "filename"
+ "filepath"
+ "filesystem operation failed"
+ "filter_->state_ids().size() >= 2u"
+ "filter_config.alphaBeta_theta >= 0.0 && filter_config.alphaBeta_theta <= 1.0"
+ "filter_config.dt > 0.0"
+ "filter_data.size() >= filter_taps.rows()"
+ "filter_output length must be equal to num_pred_smpls."
+ "filter_output length must be equal to pred_samples size."
+ "filter_output.rows() >= num_pred_smpls"
+ "filter_output.rows() >= pred_samples.size()"
+ "filter_status.state_timestamp_end >= filter_status.state_timestamp_start"
+ "filter_status.state_timestamp_wgt_gain > 0.0"
+ "find_submap"
+ "find_submap is not set"
+ "first_frame_index != -1"
+ "fixed_imu_freq > 0.0 && fixed_imu_freq <= 2000.0"
+ "focal_length"
+ "for meshes with texture coords, mesh's #tex_faces must be equal to #faces"
+ "for meshes without texture coords, mesh's #tex_faces must be zero"
+ "format != img::Format::Dynamic"
+ "format not implemented"
+ "found_cam_stream_id.camera_id == config_.camera_used_for_mapping"
+ "frame_bundle"
+ "frame_bundle.vio_frame.image_id().view == target_state_id"
+ "frame_bundle_ref"
+ "frame_pool_"
+ "frame_size == switching_size"
+ "fs::is_empty(config_.map_data_dir)"
+ "ftr_index_iter != feature_key_to_feature_index.end()"
+ "ftr_ptr != nullptr"
+ "gain_imu_median_est MUST be in range of [0,1]"
+ "get_next_capacity, allocator's max size reached"
+ "graph_"
+ "graph_node_iter != pose_graph.nodes().end()"
+ "gyro_buffer.size() > 1"
+ "gyro_dt >= 0.0"
+ "gyro_gain >= 0.0 && gyro_gain <= 1.0"
+ "gyro_it != mGyroMeasurements.end()"
+ "gyro_threshold needs to be > 0"
+ "gyro_window_time_secs >= 0"
+ "half FOV is out of range: "
+ "hardware_params.num_cameras()"
+ "hessian.rows() == hessian.columns()"
+ "holding_queue_.empty()"
+ "hostname:port %s:%d not valid"
+ "hysteresis buffer size needs to be > 0"
+ "hysteresis window needs to be > 0"
+ "hysteresis_time_window >= 0"
+ "hysteresis_time_window_in_motion >= 0"
+ "i1 < (1 << 30) && i1 >= -(1 << 30)"
+ "i2 < (1 << 30) && i2 >= -(1 << 30)"
+ "idx < static_cast<uint32_t>(DataType::End)"
+ "idx < static_cast<uint32_t>(NetworkDataType::End)"
+ "ignoring data of timestamp "
+ "image"
+ "image format not supported by io format"
+ "image height mismatch"
+ "image width mismatch"
+ "image.height() / std::pow(2.0, max_octaves - 1) >= 16"
+ "image.width() % static_cast<size_t>(std::pow(2.0, max_octaves)) == 0"
+ "image_data"
+ "image_data_ptr"
+ "image_descriptor_iter != ext_map_iter->second.data()->image_descriptors_.end()"
+ "image_descriptor_iter != this->data_->image_descriptors_.end()"
+ "image_dynamic.RuntimeFormat() == color_format"
+ "image_format"
+ "image_id == ref_frame_image_id"
+ "image_plane_size"
+ "image_plane_size must not be nullptr"
+ "image_size"
+ "image_width > 0 && image_height > 0"
+ "image_width > 0u && image_height > 0u"
+ "impl().camera_matrix()[0] > 0"
+ "impl_->camera_set_features_queue_.size() == 0 || incoming_state_timestamp > impl_->camera_set_features_queue_.back() ->camera_feature_samples.front() .feature_samples.front() .timestamp_info.timestamp()"
+ "imu.size() > 0"
+ "imu_buffer_orig.size() > 1"
+ "imu_features_syncer_ failed to process camera measurement"
+ "imu_filter_config.RLS_downsample_factor > 0"
+ "imu_filter_input size must match number of RLS filter taps"
+ "imu_filter_input.size() >= imu_filter_config.num_taps"
+ "imu_filter_params_.imu_default_sample_time > 0.0 && imu_filter_params_.current_period_rel_tol >= 0.0 && imu_filter_params_.est_period_rel_tol >= 0.0"
+ "imu_frame_bundle_ in VFusion is not saved."
+ "imu_frame_bundle_opt"
+ "imu_meas.size() > 0"
+ "imu_meas_iter >= imu_meas.begin()"
+ "imu_measurement iterator issues!"
+ "imu_measurements not enough samples."
+ "imu_measurements.size() >= 2"
+ "imu_measurements_segment >= 1"
+ "imu_sample_buffer_"
+ "imu_sample_buffer_->NumIMUSamples() > 0"
+ "inconsistent accumulated state_ID"
+ "incorrect reference keyframe in MultiFrame Reloc"
+ "index overflow"
+ "inertial_measurements_.NewestSample().timestamp <= window_imus.OldestSample().timestamp"
+ "info"
+ "info.json"
+ "info_"
+ "initial_sync_command"
+ "initialized_"
+ "input_delay_line length must be equal to num_taps."
+ "input_delay_line length must be longer than num_taps."
+ "input_delay_line.rows() == ls_pred_cfg_.num_taps"
+ "input_delay_line.rows() >= ls_pred_cfg_.num_taps"
+ "inserted.second"
+ "internal exception"
+ "internal_state_callback_"
+ "interp set must start with sample 0 and end with last sample in buffer"
+ "interp_set.size() > 1 && interp_set.front() == 0 && interp_set.back() == imu_buffer_orig.size() - 1"
+ "interp_state"
+ "invalid IOValueType string "
+ "invalid alpha"
+ "invalid argument"
+ "invalid arithmetic type string "
+ "invalid camera type"
+ "invalid camera type string "
+ "invalid clock_type "
+ "invalid data type"
+ "invalid enable-state string "
+ "invalid enable-state string '"
+ "invalid extrinsics calib iterator."
+ "invalid image format type string "
+ "invalid image size for AreaBinning FeatureFilter"
+ "invalid intrinsics calib iterator."
+ "invalid load into const data"
+ "invalid or unsupported file"
+ "invalid peer ID"
+ "invalid se3 type string "
+ "invalid serialization format type string "
+ "invalid size of array parameter"
+ "invalid sync status ("
+ "invalid sync type"
+ "invalid uuid string"
+ "invalid value type identifier"
+ "inverseAnchorCameraPoseIter != inverse_camera_SE3Group_.end()"
+ "io_format"
+ "is consumed: "
+ "is_device_worn"
+ "is_indoor"
+ "iter != incremental_poses_per_frame.end()"
+ "iter != input_neighbor_submaps.end()"
+ "iter != local_map_ref_state_poses_.end()"
+ "iter != ls.graph().template endFactor<TOffPriorFactor>()"
+ "iter != per_camera_usage.end()"
+ "iter != viodatabase_->track_list()->end()"
+ "iter->accel_threshold >= 0.0"
+ "iter->alphaBeta_theta >= 0.0 && iter->alphaBeta_theta <= 1.0"
+ "iter->gyro_threshold >= 0.0"
+ "iter->second->timestamp < imu_segment_start_iter->timestamp"
+ "iter->smoothing_wgt_overwrite_val >= 0.0 && iter->smoothing_wgt_overwrite_val <= 1.0"
+ "iter->speed_threshold >= 0.0"
+ "k16BitDepth"
+ "kCGImageAlphaOnly"
+ "kCGImageAlphaPremultipliedFirst"
+ "kCV3DVIO_UseFactorGraph was deprecated: Not disabling FactorGraph"
+ "kCV3DVIO_UseLowPower was deprecated: Not enabling Low power VFusion"
+ "kernel_size() <= std::numeric_limits<int>::max()"
+ "kernel_size() is outside the range of int"
+ "keypoints.size() > sample_size"
+ "keys.size() == values.size()"
+ "landmarkID == track->ID().key()"
+ "lap1.height() - 1 <= std::numeric_limits<int>::max()"
+ "lap1.height() - 1 is outside the range of int"
+ "lap1.width() - 1 <= std::numeric_limits<int>::max()"
+ "lap1.width() - 1 is outside the range of int"
+ "lap_scale0.height() == lap_scale1.height()"
+ "lap_scale0.width() == lap_scale1.width()"
+ "laplacian_pyr.num_scales_per_octave() == 2"
+ "laplacian_pyramid.fine_height() == gaussian_pyramid.fine_height()"
+ "laplacian_pyramid.fine_width() == gaussian_pyramid.fine_width()"
+ "laplacian_pyramid.num_scales_per_octave() == gaussian_pyramid.num_scales_per_octave() - 1"
+ "laplacian_pyramid.size() - 1 <= std::numeric_limits<int>::max()"
+ "laplacian_pyramid.size() - 1 is outside the range of int"
+ "last_relative_pose_and_cov_"
+ "last_relative_pose_and_cov_ must exist"
+ "last_track_used == static_cast<size_t>(-1) || (last_track_used < tracks.size() && tracks[last_track_used].size() > 0)"
+ "last_valid_element < elements.size() && predicate(elements[last_valid_element]) > 0"
+ "latest state ID: "
+ "latest_inertial_state.v().norm2Sq(): "
+ "lens != nullptr"
+ "lens0"
+ "lens_info_iter->second.measured_lens"
+ "lens_iter != image_id_lens_map.end()"
+ "line_cloud size must be equal to vergence angles size"
+ "line_cloud size must be twice the number of ids"
+ "line_cloud.size() == 2 * line_ids.size()"
+ "line_cloud.size() == vergence_angle_cosines.size()"
+ "linear_system.graph().template findFactor<FactorType>(factor_cnt) == linear_system.graph().template endFactor<FactorType>()"
+ "linear_system.graph().template numberOfVariable<VARIABLE_TUPLE>() == 0"
+ "linear_system.template findVariable<LandmarkType>(landmark_variable_id) != linear_system.template endVariable<LandmarkType>()"
+ "linear_system.template findVariable<SLAMLandmarkVariableType>(landmarkID) != linear_system.template endVariable<SLAMLandmarkVariableType>()"
+ "linear_system.template findVariable<SLAMLandmarkVariableType>(landmarkID) == linear_system.template endVariable<SLAMLandmarkVariableType>()"
+ "linear_system_.graph().template numberOfVariable<LandmarkVariableType>() == 0"
+ "lines2"
+ "lines3"
+ "load"
+ "loaded binary data size does not match given data blob size"
+ "loaded_external_submaps->size() == 1"
+ "loaded_submap"
+ "loader must specify the format to load as"
+ "localhost"
+ "location_info"
+ "log4j"
+ "log4j."
+ "logger"
+ "logger_enable_state_changes"
+ "ls.template extractCovariance<typename BATraits::PoseVariable>( variable_id, covariance)"
+ "ls_pred_cfg_.filter_max_L2_norm >= 0.0"
+ "ls_pred_cfg_.filter_reg_eps >= 0.0"
+ "ls_pred_cfg_.max_pred_samples > 0 && filter_config.max_pred_samples <= 40"
+ "ls_pred_cfg_.num_taps <= 100 && filter_config.num_taps > 0"
+ "ls_pred_cfg_.rls_forgetting_factor <= 1.0 && ls_pred_cfg_.rls_forgetting_factor >= 0.5"
+ "ls_pred_cfg_.training_samples > 10"
+ "lut_indices[4u] > 0"
+ "m: "
+ "mFrames.back().intrinsic_matrices().size() == 2"
+ "mGyroMeasurementsForFrame samples are non-increasing"
+ "mGyroMeasurementsForFrame.size() == mAccelerometerMeasurementsForFrame.size()"
+ "mGyroMeasurementsForFrame.size() > 1"
+ "m_data.size() == 1"
+ "makes sure reordered descriptors are not valid when adding feature without reordered descriptors"
+ "makes sure when adding features, no featues are considered as relocalization only"
+ "map_->HasPoseGraphNode(external_keyframe_info.vio_state_id)"
+ "map_data.viodatabase()"
+ "map_file_path"
+ "map_groups.count(submap) > 0"
+ "map_optimization_result.opt_T_Gold_to_Gnew_per_state"
+ "mapping_add_new_kf_output_queue_.empty()"
+ "matched_count == num_curr_planes"
+ "matching_search_circle_radius_pix: "
+ "materials"
+ "materials={"
+ "materials_type"
+ "materials_type="
+ "math::IsOrthogonal3x3(&camera_to_imu_rotation.front(), 1e-5)"
+ "max"
+ "max features "
+ "max pred must be > 0"
+ "max pred time must be the same"
+ "max pred time needs to be > 0"
+ "maxR > 0"
+ "max_anchors_per_group_ > 0"
+ "max_num_features <= std::numeric_limits<IntFeatureIndex>::max()"
+ "max_num_point_feature_large_scale <= valid_feature_size"
+ "max_num_point_feature_large_scale size invalid"
+ "max_pred_idx <= ls_pred_cfg_.max_pred_samples && min_pred_idx > 0u"
+ "max_slam_point_tracks <= parameters_.ba_config.max_num_optimized_tracks"
+ "maximal IMU interval "
+ "maximal IMU latency "
+ "maximal frame interval "
+ "maximal frame latency "
+ "maybe_format"
+ "maybe_uuid"
+ "meanabs"
+ "meantruncatedabs"
+ "measured_lens is not allocated"
+ "measurements.IsCameraIDAlignedAsIndex()"
+ "medianabs"
+ "merged_map_data"
+ "mesh is required to have per-vertex colors and normals"
+ "mesh's #colors must be either zero or equal to #vertices"
+ "mesh_data_ptr"
+ "metadata->pose_metadata"
+ "min"
+ "min_version"
+ "minimal IMU interval "
+ "minimal IMU latency "
+ "minimal frame interval "
+ "minimal frame latency "
+ "minimal time between frames "
+ "minimizer_parameters.use_IMU"
+ "minimum >= 1"
+ "mis-match the inlier ratio and minimum inlier number size."
+ "missing anchor observation"
+ "missing pose ref"
+ "ml_model_for_travel"
+ "moving_filter_wgt <= (1 + 1e-3) && moving_filter_wgt >= (0.0 - 1e-3)"
+ "n <= std::numeric_limits<uint32_t>::max()"
+ "n is outside the range of uint32_t"
+ "name"
+ "net_log->ContextTree() == contexts"
+ "new segment IMU meaasurements is not in order"
+ "new_anchor_pose_ref != nullptr"
+ "new_anchor_pose_ref->lens"
+ "new_features.size() == features_to_keep.size()"
+ "new_map_track"
+ "new_state != nullptr"
+ "next_state_timestamp_iter != state_timestamps.end()"
+ "next_submap_session_cb_"
+ "nit != new_track->end()"
+ "no error"
+ "node != nullptr"
+ "node_id1 != remove_state_var_id"
+ "node_id2 != remove_state_var_id"
+ "node_iter != pose_graph.nodes().end()"
+ "normals"
+ "normals={"
+ "normals_type"
+ "normals_type="
+ "not available"
+ "not implemented"
+ "not implemented yet. rdar://113779839"
+ "ns"
+ "num of buckets scale should be >= 1"
+ "num_anchors == tracked_anchors"
+ "num_bins < std::numeric_limits<IntBinIndex>::max() && num_bins * num_bins + 1 < std::numeric_limits<IntBinIndex>::max() && num_bins * num_bins * num_bins_multiplier + 1 < std::numeric_limits<IntBinIndex>::max() && (!ENABLE_MINMAX_BINNING || num_bins * num_bins * num_bins_multiplier * 2 + 1 < std::numeric_limits<IntBinIndex>::max())"
+ "num_buckets x and y should be 1, other settings are currently not supported"
+ "num_buckets_scale >= 1"
+ "num_buckets_scale is outside the range of int"
+ "num_buckets_x == 1 && num_buckets_y == 1"
+ "num_buckets_x is outside the range of int"
+ "num_buckets_y is outside the range of int"
+ "num_frontend_tracks_to_keep < num_frontend_tracks"
+ "num_matching_bits == 256"
+ "num_matching_bits == 512"
+ "num_observations * kMeasurementSize <= m_measurements.max_size()"
+ "num_observations <= m_mask.max_size()"
+ "num_octaves for dimension <= 320 should be 4, configured dimension %lux%lu num_octaves %lu"
+ "num_octaves for dimension > 320 should be 5, configured dimension %lux%lu num_octaves %lu"
+ "num_optimized_slam_landmarks_ == 0"
+ "num_pred_smpls <= ls_pred_cfg_.max_pred_samples && num_pred_smpls > 0u"
+ "num_pred_smpls must be in in [1,max_pred_samples] range."
+ "num_samples <= std::numeric_limits<uint32_t>::max() / 255"
+ "num_scales > 2"
+ "num_scales_minus2 <= kMaxNumOfScalesMinus2"
+ "num_secondary_streams == 0 || num_observations * kMeasurementSize <= m_secondary.front().measurements.max_size()"
+ "num_tracks_has_sufficient_inlier_measurements >= inlier_tracks.size()"
+ "num_updates=%d, duration_sec=%f, camera_source_id=%d, reason=%{public}s, algorithm=%{public}s, delta_camera_to_imu_rotation=[%f, %f, %f], delta_camera_intrinsics=[%f, %f, %f, %f], session_id=%{public}s, is_device_worn=%{bool}d, is_indoor=%{bool}d, reference_frame_id=%d"
+ "numberWithUnsignedInt:"
+ "numbers"
+ "obj export requires per-vertex colors"
+ "obj export requires per-vertex normals"
+ "obj_anchor.anchored()"
+ "object_anchor_set_"
+ "object_anchor_set_ == nullptr!"
+ "object_anchors_.count(object_id) == 0"
+ "object_id (%s) already exists"
+ "object_iter != src_map_data.object_anchor_set_.ObjectAnchors().end()"
+ "obs"
+ "obs_node"
+ "obs_pose_ref"
+ "old_anchor_pose_ref != nullptr"
+ "old_state.state_timestamp_end > old_state.state_timestamp_start"
+ "only supports stereo"
+ "op_health_metadata"
+ "op_uuid"
+ "opt"
+ "opt_cam_to_imu"
+ "opt_camera_set_model->NumStreams() == feature_samples.size()"
+ "opt_camera_set_model.has_value() == (feature_samples.size() > 1)"
+ "opt_camera_set_model.has_value() == (features.size() > 1)"
+ "opt_health_metadata"
+ "opt_incremental_pose"
+ "opt_last_imu_in_latest_bad_geo_frame_.has_value()"
+ "opt_latest_camera_set_features"
+ "opt_obj_cm"
+ "opt_object_anchor_cm"
+ "opt_query_frame"
+ "opt_query_submap"
+ "opt_ref_camera_set_features"
+ "opt_ref_image_descriptor"
+ "opt_spread_from_center.has_value()"
+ "opt_submap_session_id"
+ "optimized_trajectory.size() <= inertial_trajectory.size()"
+ "options"
+ "ordered"
+ "org.apache.log4j."
+ "orientation >= 0 && orientation < 256"
+ "orientation overflow"
+ "origin_"
+ "os_build_version"
+ "os_product_version"
+ "outlier_rej_stats_iter != outlier_rejection_stats.stats.end()"
+ "overflow detected resulting in invalid result"
+ "package_id"
+ "pair_edge.first submap is not within neighbor set"
+ "per-face"
+ "per-vertex"
+ "percentage_static_points"
+ "pixel_buffer"
+ "pixel_transfer_session_"
+ "plane_track->second->getStructure()"
+ "point_displacement_tolerance_factor > 0."
+ "point_feature_ratio_in_low_stereo_coverage"
+ "point_track_structure"
+ "points2"
+ "points2d.size() == points3d.size()"
+ "points3"
+ "points_3d.size() / 3u == xc.size() / 2u"
+ "pose_and_cov_accumulator()"
+ "pose_and_cov_accumulator_ ->GetOldestStateAccumulatedPoseAndCov(window_will_slide_in_next_iteration().first) .state_id1 == static_cast<uint32_t>(get_current_state_ids().front())"
+ "pose_and_cov_accumulator_->GetBaseStateID() == new_base_state_id"
+ "pose_and_cov_accumulator_->GetBaseStateID() == prev_base_state_id"
+ "pose_extrapolation_filters[0]->GetFilterConfig().max_pred_samples == pose_extrapolation_filters[0 + cv_types::InertialState::kPositionDof] ->GetFilterConfig() .max_pred_samples"
+ "pose_extrapolation_filters[0]->GetFilterConfig().max_pred_samples > 0"
+ "pose_filter_config"
+ "pose_filter_config.transition_config.transition_window_state_A2B_sec >= 0.0"
+ "pose_predictor_"
+ "pose_ref"
+ "pose_ref->lens"
+ "pose_smoothing_config must not be empty!"
+ "pose_smoothing_config.smoothing_set.size() == 5"
+ "pose_smoothing_config.smoothing_set.size() == expected_num_elems"
+ "pose_variable_id == vel_and_bias_variable_id"
+ "prediction_callback_"
+ "predictor pose filtering needs use_prev_prop_states option to be true!"
+ "prev_attached_plane.attached_state_id"
+ "prev_base_state_id == oldest_acc_pose_and_cov.state_id0"
+ "prev_state_var_iter != viostate_variable_ids_.end()"
+ "primary submap must be one of the submaps"
+ "principal_point"
+ "prior size empty!"
+ "prior.rows() == prior.columns()"
+ "prior.rows() >= state_offset + 3"
+ "prior_info.info.rows() >= 15"
+ "prior_info.info.rows() >= 6"
+ "prior_inverse_sigma->min() > 0"
+ "prior_variance > 0"
+ "priv().initialized_root_appenders_ == current_root_appenders"
+ "proceed_n"
+ "proceed_until"
+ "process ext reloc result: "
+ "processInfo"
+ "processName"
+ "process_"
+ "process_id"
+ "process_name"
+ "processing queue is full"
+ "product_name"
+ "propagated state against BA: "
+ "propagator != nullptr"
+ "propagator cannot be nullptr"
+ "protocol_info"
+ "ptr != nullptr"
+ "public.jpeg"
+ "public.png"
+ "public.tiff"
+ "query_camera_info.default_lens_minimum_half_fov_deg > 0."
+ "query_camera_lens->IsFisheye()"
+ "query_ext_state"
+ "query_map_data.viodatabase()"
+ "query_pose_ref"
+ "r: "
+ "rate > 1e-6"
+ "rate_index < config_.allowed_interval_rates.size()"
+ "rate_index == 0 || config_.allow_framerate_scaling"
+ "ratio_of_points_to_compute_avg_point_displacement <= 1."
+ "ratio_of_points_to_compute_avg_point_displacement > 0."
+ "read_channel >= 0u && read_channel < 4u && \"Read channel is in invalid range.\""
+ "reanchor should always succeed if avoid_prune_external_submaps_to_empty is set"
+ "received data of timestamp "
+ "ref frame cannot be nullptr"
+ "ref_frame_iter != ref_frames.end()"
+ "ref_frame_wrapper.size() > 0"
+ "ref_map_data.viodatabase()"
+ "ref_pose_ref"
+ "ref_sec_to_ref_pri_matches"
+ "ref_self_state"
+ "reference.model.lens_model()->calibrated_to_ray( direction.data(), reference.offsets.at(i).data(), xc.data())"
+ "reference_frame_id"
+ "rel_pose_and_cov1.state_id1 == rel_pose_and_cov2.state_id0"
+ "relocalization info should be empty upon receiving state correction event"
+ "relocalization_callback_"
+ "remove_factor_ids[first_factor_index] != remove_factor_ids[sec_factor_index]"
+ "removed_submap"
+ "removed_submap is invalid"
+ "repeat_output_starting_index > 0"
+ "res"
+ "res.second"
+ "reset_mapping_module_in_reinitialization"
+ "results"
+ "results.size() == num_anchor_boxes"
+ "ret"
+ "ret == 0"
+ "ret == elog::APILogging::Available()"
+ "ret == elog::APILogging::InternalAvailable()"
+ "ret.first"
+ "ret.second && ret2.second"
+ "root appenders have been illegally modified between Initialize() and Enable() of APILogging"
+ "root appenders have been illegally modified between Initialize() and EnableInternal() of APILogging"
+ "root appenders have been illegally modified between Initialize() and EnableInternalWithConfigurationFile() of APILogging"
+ "rootLogger"
+ "rotation is invalid: "
+ "rpf_"
+ "rt != camera_readout_times_.end()"
+ "runtime error"
+ "sample.packed_hwfp"
+ "sample_period > 0"
+ "sample_period must be greater than 0"
+ "sample_time_diff = %lf is less than 0, indicating IMU samples are out of order.  Estimated seriod not updated"
+ "save"
+ "scale == kp_scale"
+ "scale mismatch"
+ "scaled_hardware_params.num_cameras() == 1"
+ "scheduler must be valid"
+ "score == res_map_cube[1][1][1]"
+ "score mismatch"
+ "se3_type"
+ "seed_estimate_.bundle.num_frames() == seed_estimate_.state_ids.size()"
+ "semantics"
+ "semantics={"
+ "semantics_type"
+ "semantics_type="
+ "sequence file must not be named 'info'"
+ "sequence i/o failure"
+ "sequence.csv"
+ "serial_number"
+ "server Receive() threw exception"
+ "server can't reach client"
+ "server cannot receive "
+ "server cannot serialize data of unknown package"
+ "server cannot serialize package data of unknown data type"
+ "server send failure"
+ "server serialization failed"
+ "should never be in this condition!"
+ "should not be reached"
+ "significant data drop interval "
+ "size == image.Size()"
+ "skip deleting "
+ "slam-short-data-drop"
+ "smoothing_set.size() == expected_num_elems!"
+ "smoothing_wgt_overwrite_val needs to be in range of [0,1]"
+ "source and end points must have same track length"
+ "space"
+ "speed_threshold needs to be > 0"
+ "sqrt_I_ != nullptr"
+ "src"
+ "src.data()"
+ "src_to_dst"
+ "src_track_length == end_track_length"
+ "start >= 0"
+ "state != nullptr"
+ "state offset exceeds matrix size"
+ "state variable id error"
+ "state->pose_metadata->reinitialize_attempts >= 0"
+ "state_and_intrinsic_pair"
+ "state_index_in_bundle >= 0"
+ "state_pos_in_window >= 0"
+ "state_projection_ref_ptr"
+ "state_ptr"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = 2U]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = 3U]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = 5U]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = __CFDictionary]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::cam::Camera]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::cam::HeikkilaCamera<double, cv3d::kit::cam::PixelOrigin::Center>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::cam::HeikkilaCamera<double, cv3d::kit::cam::PixelOrigin::Corner>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::cam::HeikkilaCamera<float, cv3d::kit::cam::PixelOrigin::Center>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::cam::HeikkilaCamera<float, cv3d::kit::cam::PixelOrigin::Corner>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::cam::PinholeCamera<double, cv3d::kit::cam::PixelOrigin::Center>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::cam::PinholeCamera<double, cv3d::kit::cam::PixelOrigin::Corner>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::cam::PinholeCamera<float, cv3d::kit::cam::PixelOrigin::Center>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::cam::PinholeCamera<float, cv3d::kit::cam::PixelOrigin::Corner>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::cam::PixelOrigin::Center]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::cam::PixelOrigin::Corner]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::camio::CameraSample<>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::camio::HeikkilaCameraSample<double, cv3d::kit::cam::PixelOrigin::Center>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::camio::HeikkilaCameraSample<double, cv3d::kit::cam::PixelOrigin::Corner>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::camio::HeikkilaCameraSample<float, cv3d::kit::cam::PixelOrigin::Center>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::camio::HeikkilaCameraSample<float, cv3d::kit::cam::PixelOrigin::Corner>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::camio::PinholeCameraSample<double, cv3d::kit::cam::PixelOrigin::Center>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::camio::PinholeCameraSample<double, cv3d::kit::cam::PixelOrigin::Corner>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::camio::PinholeCameraSample<float, cv3d::kit::cam::PixelOrigin::Center>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::camio::PinholeCameraSample<float, cv3d::kit::cam::PixelOrigin::Corner>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::cf::DictionaryRefT<const __CFDictionary *, cv3d::kit::cf::FlavorDefault>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::cf::FlavorDefault]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::cfio::DictionaryRefSample<>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::cfio::DictionaryValueSample<>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::con::Blob]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::con::Lines<2>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::con::Lines<3>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::con::Number]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::con::Numbers]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::con::Points<2>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::con::Points<3>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelOutput<cv3d::vio::data_verification::DataVerificationStatus>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelOutput<cv3d::vio::feature_detection_node_group::LineEnablerOutput>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelOutput<cv3d::vio::multicamera_node_group::CalibrationRequests>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::OptionalReturn<cv3d::vio::capi::AnchorGroup> (const cv3d::vio::data_verification::DataVerificationStatus &)]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::OptionalReturn<std::vector<cv3d::kit::cf::ErrorRef>> (const cv3d::vio::data_verification::DataVerificationStatus &)]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::conio::BlobSample]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::conio::LinesSample<2>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::conio::LinesSample<3>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::conio::NumberSample]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::conio::NumbersSample]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::conio::PointsSample<2>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::conio::PointsSample<3>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::dgn::Storage]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::imgio::ImageSample<>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::imgio::ImageStructureSample<>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::kio::ProtocolInfoSample]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::mesh::TriMeshBoundingBoxSample<>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::mesh::TriMeshDataSample<>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::timeio::TimestampSample]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ClientSyncUpdateSample]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::DataInfoSample<>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ImageData]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::PackageData<cv3d::kit::cam::Camera, cv3d::kit::viz::Package, 5>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::PackageData<cv3d::kit::cf::DictionaryRefT<const __CFDictionary *, cv3d::kit::cf::FlavorDefault>, cv3d::kit::viz::Package, 6>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::PackageData<cv3d::kit::con::Blob, cv3d::kit::viz::Package, 9>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::PackageData<cv3d::kit::con::Lines<2>, cv3d::kit::viz::Package, 12>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::PackageData<cv3d::kit::con::Lines<3>, cv3d::kit::viz::Package, 13>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::PackageData<cv3d::kit::con::Number, cv3d::kit::viz::Package, 8>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::PackageData<cv3d::kit::con::Numbers, cv3d::kit::viz::Package, 2>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::PackageData<cv3d::kit::con::Points<2>, cv3d::kit::viz::Package, 3>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::PackageData<cv3d::kit::con::Points<3>, cv3d::kit::viz::Package, 4>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::PackageData<cv3d::kit::viz::PeerInfo, cv3d::kit::viz::NetworkPackage, 1>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::PackageData<cv3d::kit::viz::Sync, cv3d::kit::viz::NetworkPackage, 2>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::PackageData<cv3d::kit::viz::TextLog, cv3d::kit::viz::Package, 10>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::PackageData<cv3d::kit::viz::Transform3, cv3d::kit::viz::Package, 11>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::PackageData<cv3d::kit::viz::TriMesh, cv3d::kit::viz::Package, 7>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::PackageData<cv3d::kit::viz::UpdateEnabledContexts, cv3d::kit::viz::NetworkPackage, 3>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::PackageData<cv3d::kit::viz::UpdateEnabledLoggers, cv3d::kit::viz::NetworkPackage, 4>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::PackageData<cv3d::kit::viz::UpdateSyncConfiguration, cv3d::kit::viz::NetworkPackage, 5>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::PeerInfoSample<2U>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::PeerInfo]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::SE3Sample]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::SyncCommandSample]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::SyncSample]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::Sync]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::TextLog]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::Transform3Sample]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::Transform3]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::TriMesh]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::UnknownPackage]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::UpdateEnabledContextsSample]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::UpdateEnabledContexts]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::UpdateEnabledLoggersSample]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::UpdateEnabledLoggers]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::UpdateSyncConfigurationSample]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::UpdateSyncConfiguration]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ValueData<cv3d::kit::cam::Camera>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ValueData<cv3d::kit::cf::DictionaryRefT<const __CFDictionary *, cv3d::kit::cf::FlavorDefault>>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ValueData<cv3d::kit::con::Blob>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ValueData<cv3d::kit::con::Lines<2>>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ValueData<cv3d::kit::con::Lines<3>>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ValueData<cv3d::kit::con::Number>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ValueData<cv3d::kit::con::Numbers>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ValueData<cv3d::kit::con::Points<2>>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ValueData<cv3d::kit::con::Points<3>>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ValueData<cv3d::kit::img::SharedImage<cv3d::kit::img::Format::Dynamic, cv3d::kit::img::DynamicBuffer, cv3d::kit::img::Mutability::Const>>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ValueData<cv3d::kit::viz::PeerInfo>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ValueData<cv3d::kit::viz::Sync>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ValueData<cv3d::kit::viz::TextLog>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ValueData<cv3d::kit::viz::Transform3>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ValueData<cv3d::kit::viz::TriMesh>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ValueData<cv3d::kit::viz::UpdateEnabledContexts>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ValueData<cv3d::kit::viz::UpdateEnabledLoggers>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::viz::ValueData<cv3d::kit::viz::UpdateSyncConfiguration>]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::batch_least_squares::MetricName::kDelayReinitDueToSevereLuxFluctuations]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::batch_least_squares::MetricName::kIMUCameraDiscrepancyWithStationaryIMU]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::batch_least_squares::MetricName::kIsLowStereoCoverage]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::batch_least_squares::MetricName::kIsTransitionTrackingState]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::batch_least_squares::MetricName::kLargeCameraExtrinsicOffsetWrtDefault]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::batch_least_squares::MetricName::kMaxCameraExtrinsicRotationDiffWrtDefualtinRad]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::batch_least_squares::MetricName::kNumberOfIMUFactorsInMarginalization]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::batch_least_squares::MetricName::kNumberOfMapLandmarkFactorsInMarginalization]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::batch_least_squares::MetricName::kNumberOfMonoVIOLandmarkFactorsInMarginalization]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::batch_least_squares::MetricName::kNumberOfSLAMLandmarkFactorsInMarginalization]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::batch_least_squares::MetricName::kNumberOfStereoVIOLandmarkFactorsInMarginalization]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::batch_least_squares::MetricName::kOneTimeLocationRequest]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::batch_least_squares::MetricName::kPlaneBasedRejectionAvgInlierPointToCentroidDistance]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::batch_least_squares::MetricName::kPlaneBasedRejectionCentroidToCameraDistance]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::batch_least_squares::MetricName::kPlaneBasedRejectionInlierCount]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::batch_least_squares::MetricName::kPlaneBasedRejectionInlierRatio]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::batch_least_squares::MetricName::kSlidingStationaryPositionXStd]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::batch_least_squares::MetricName::kSlidingStationaryPositionYStd]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::batch_least_squares::MetricName::kSlidingStationaryPositionZStd]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::data_verification::DataVerificationStatus (cv3d::vio::slam_engine_node_group::DataVerificationResult)]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::feature_detection_node_group::LineEnablerOutput (const cv3d::vio::feature_detection_node_group::LineTrackingEnablerVIOHealthStatistics &)]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::feature_detection_node_group::LineEnablerOutput]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::mapping_types::MapAnalyticsMetricName::kNumOverlapMapInlierMatches]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::mapping_types::MapAnalyticsMetricName::kOverlapMapInlierMatchesRatio]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::multicamera_node_group::CalibrationRequests (const std::shared_ptr<cv3d::vio::metadata::VIOPoseMetadata> &)]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::multicamera_node_group::CalibrationRequests]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::slam_engine_node_group::DataVerificationResult (const cv3d::vio::data_verification::DataVerificationStatus &)]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = std::shared_ptr<const cv3d::vio::user_anchor_node_group::MetadataWithCMAnchors> (const std::shared_ptr<const cv3d::vio::odometry_engine::VIOMetadata> &)]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = void (const cv3d::vio::multicamera_node_group::CalibrationRequests &)]"
+ "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = void (const std::shared_ptr<cv3d::vio::cv_types::JasperPointCloudWithPose> &)]"
+ "static_cast<size_t>(config.fine_height) >> octave >= kernel_size()"
+ "static_cast<size_t>(config.fine_width) >> octave >= kernel_size()"
+ "static_cast<size_t>(image_width) >= kImageChunkSize + kMarginWidth * 2"
+ "stats.state.Get<SubmapRuntimeState::Flag::kIsSelfSubmap>() == submap.IsSelfSubmap()"
+ "status"
+ "std::fabs(feature.distance - distance_check) < 1e-6"
+ "std::fabs(vio::math::L2Norm3(anchor_direcrion.data()) - 1) <= 1e-6"
+ "std::fabs(vio::math::L2Norm3(src_anchor_direction.data()) - 1) <= 1e-6 && std::fabs(vio::math::L2Norm3(end_anchor_direction.data()) - 1) <= 1e-6"
+ "std::find(permutation_matrix.begin(), permutation_matrix.end(), value) == permutation_matrix.end()"
+ "std::isfinite(minimum_half_FOV_deg)"
+ "std::max(std::fabs(camera_to_imu_position[0]), std::max(std::fabs(camera_to_imu_position[1]), std::fabs(camera_to_imu_position[2]))) < 0.3"
+ "std::string"
+ "stereo_camera_iter != camera_sensor_models.end()"
+ "strategy.session_criteria() == AnchorStrategy::SessionCriteria::kGivenSession"
+ "stream ID is out of range: "
+ "stream_id < 2"
+ "stream_id <= 0xffff"
+ "stream_id == 0"
+ "stream_index < cur_descriptors_.size()"
+ "stream_index <= cv_types::CameraAllocationInfo::kMaxNumberOfStreams"
+ "strength_image.data() != nullptr"
+ "strength_image.height() != 0"
+ "strength_image.width() != 0"
+ "strength_image.widthStep() != 0"
+ "stride must be multiple of pixel size"
+ "stride must not overlap internally"
+ "submap"
+ "success"
+ "switch timestamp needs to be valid!"
+ "switch_data.has_value()"
+ "switch_data.has_value() && \"switch data must created!\""
+ "sync update"
+ "sync_command_id"
+ "sync_id"
+ "sync_type"
+ "sysdiagnose"
+ "sz >= cv_types::InertialState::kDof"
+ "target_context"
+ "targeted submap not passed in map_groups"
+ "tex0='"
+ "tex_coords"
+ "tex_coords={"
+ "tex_faces"
+ "tex_faces={"
+ "textures"
+ "the model is empty!"
+ "there is a map state view id that does not exist in transformation_from_old_global_to_new_global_"
+ "theta needs to be in range of [0,1]"
+ "this->GetOldestStateAccumulatedPoseAndCov(window_will_slide_in_next_iteration).state_id0 == new_base_state_id"
+ "this->HasOriginAnchor()"
+ "this->IsCameraIDAlignedAsIndex()"
+ "this->IsWeakState(target_weak_state_id)"
+ "this->config_.mapping_manager_config.enable_submapping"
+ "this->data_"
+ "this->depth_sensor_model_"
+ "this->map()"
+ "this->map_->config().enable_inter_session_regular_states_check"
+ "this->numbers.Size() % (N * 2) == 0"
+ "this->numbers.Size() % N == 0"
+ "this->opt_request_"
+ "this->opt_request_->query_state_id == reloc_info.query_image_id.view.key()"
+ "this->parameters().ba_config.use_direct_oldest_pose_marginalization"
+ "this->slam_relocalization_"
+ "this->viobadata_ref_.state_set && this->viobadata_ref_.state_set->sensor_calibration_set()"
+ "this->viobadata_ref_.state_to_imu_sample_time_offset"
+ "this->viodatabase() && this->viodatabase()->state_set()"
+ "this->viodatabase() && this->viodatabase()->state_set() && !this->viodatabase()->state_set()->empty()"
+ "this_->config().is_visual_slam_enabled || !keyframe_candidate_info.opt_num_triangulated_points_for_pnp_ransac.has_value()"
+ "this_->config().is_visual_slam_enabled || !this_->config() .vfusion_config.initialization_config .correct_gravity_direction_using_stationary_init"
+ "thread constructor failed"
+ "time_diffs.back() >= 0."
+ "time_in_transition_state > 0.0"
+ "time_since_last_initialization"
+ "time_step > 0.0"
+ "time_step >= 0"
+ "time_window > 0.0"
+ "timestamp > *latest_imu_timestamp_"
+ "timestamp > *latest_pose_timestamp_"
+ "timestamp is invalid"
+ "timestamp must be included in imu buffer"
+ "timestamp range failed"
+ "timestamping is inconsistent"
+ "tlog"
+ "tlog."
+ "tlog::Configurator (line "
+ "tlog::Configurator: "
+ "tlog::Configurator: cannot create default configuration file at "
+ "tlog::Configurator: could not open file "
+ "tlog::Configurator: creating configuration file for logger name '"
+ "tlog::Configurator: creating example configuration file at "
+ "tlog::Configurator: failed to create default configuration file at "
+ "tlog::Configurator: failed to generate default configuration file at "
+ "tlog::Configurator: invalid GenerateConfiguration type "
+ "total tracks: %zu, orphan tracks: %zu, triangulated tracks: %zu, do_batch_triangulation: %d"
+ "total_size < std::numeric_limits<uint32_t>::max()"
+ "tracing"
+ "track"
+ "track does not has structure or is not setup"
+ "track.getStructure() && track.getStructure()->isSetup()"
+ "track.getStructure()->isSetup()"
+ "track.getStructure()->src_point.isSetup() && track.getStructure()->src_point.isSetup()"
+ "track_iter != keyframe_cm.tracks.end()"
+ "track_iter != this->viobadata_ref_.front_end_tracks.end()"
+ "track_iter != track_list->end()"
+ "track_latest_state_with_obs_iter != this->viobadata_ref_.state_set->end()"
+ "track_ptr != this->viobadata_ref_.front_end_tracks.end()"
+ "tracking resolution %zu x %zu"
+ "tracks[last_track_used].size() > 0"
+ "transfer_succeeded"
+ "transition_config.hysteresis_time_window_in_motion >= 0.0"
+ "transition_window >= 0 && transition_time_left >= 0"
+ "transition_window_state_A2B_sec >= 0"
+ "translation_found"
+ "triangulation failed: "
+ "trying to cast camera"
+ "type"
+ "type "
+ "type must be array, but is "
+ "type must be boolean, but is "
+ "type must be number, but is "
+ "type_id"
+ "unexpected{"
+ "unique_lock::lock: already locked"
+ "unique_lock::lock: references null mutex"
+ "unique_lock::unlock: not locked"
+ "unknown allocator mode"
+ "unknown boost::container exception"
+ "unknown error code"
+ "unknown type id "
+ "unknown_package"
+ "unsupported format"
+ "unsupported metric: "
+ "unsupported or invalid sequence"
+ "update.user_session == data.map_data.user_session"
+ "use_area_binning_feature_filter"
+ "user.R_map_keyframe_to_anchor_row_major"
+ "user.t_map_keyframe_to_anchor"
+ "user_given_name"
+ "uuid"
+ "v "
+ "v <= 65280"
+ "validate_reloc_result"
+ "validate_reloc_result is not set"
+ "value < kBitsPerFreakDescriptor"
+ "value_type"
+ "var >= 0.0"
+ "var_id_to_state_id_iter1 != var_id_to_state_id_map.end()"
+ "var_id_to_state_id_iter2 != var_id_to_state_id_map.end()"
+ "var_iter != linear_system_.template endVariable<IntrinsicsCalibVariable<Float>>()"
+ "var_iter != linear_system_.template endVariable<VIOExtrinsicsVariable<Float>>()"
+ "var_iter != ls_->endVariable<VIO4DoFDeltaPoseVariable<double>>()"
+ "vergence angle: %f, %f, %f (%u / %u)"
+ "vergence angle: %f, %f, %f (%u / %zu)"
+ "vertices"
+ "vertices={"
+ "vfusion().IsUsingIMU()"
+ "vfusion().ReadyForRelocalization(true )"
+ "vfusion.HasProcessedFirstWindow()"
+ "vfusion_new.ReadyForRelocalization(true )"
+ "vio_frame"
+ "vio_frame->lens_model_"
+ "vio_frame_iter != dst_map_data.viodatabase()->end()"
+ "vio_frame_iter != ext_map_iter->second.data()->viodatabase()->end()"
+ "vio_frame_iter->get()->is_weak_frame()"
+ "vio_frame_was_created"
+ "vio_metadata->pose_metadata->pose_prediction_info_metadata.slam_mode != cv_types::SLAMMode::kUnknown"
+ "vio_pose_ref"
+ "vio_pose_ref does not exist!"
+ "vio_ref_pose_ref"
+ "vio_state"
+ "vio_state_ptr"
+ "viobadata_time_offset"
+ "viodatabase()->inertial_measurements()"
+ "viostate_factor_ids_.find(curr_state_id.key()) == viostate_factor_ids_.end()"
+ "viz::SharedData"
+ "vn "
+ "vt "
+ "width > 0"
+ "widthStep >= minimum_width_step"
+ "widthStep must be at least as big as minimum_width_step."
+ "work_group_ != nullptr"
+ "worker"
+ "world"
+ "x_ref_sec.size() == x_ref.size()"
+ "{Model: "
+ "{current="
+ "{empty string}"
+ "{fx,fy: "
+ "{requires log level (NONE, TRACE, DEBUG, INFO, WARN, ERROR, FATAL) as first argument}"
+ "{root}"
+ "{unespected end after appender}"
+ "{unexpected end after '"
+ "{unexpected end after layout identifier}"
+ "{unexpected token, needs to begin with tlog/log4j}"
+ "{unknown token after tlog}"
+ "|"
+ "}\n"
+ "} "
- " -> Responder user: "
- "!!*this && \"Guard bytes got overwritten.\""
- "!\"HW feature matching for duplicated streams is not supported.\""
- "!\"Invalid lens distortion.\""
- "!\"invalid size of array parameter\""
- "!(*near_vio_frame)->is_weak_frame() && \"Not weak keyframe\""
- "!(*ref_vio_frame)->is_weak_frame() && \"Not weak keyframe\""
- "!(config().enable_ml_descriptors_for_weak_keyframes && config().slam_relocalization_config.use_ml_vlad && config().ml_desc_config.feature_type != feature_detection::FeatureType::DetectorNoneDescriptorATUHardNetGlobalFeat) && \"ML Vlad not supported for weak keyframes without GlobalFeat\""
- "!(config.enable_swproxy_hw_desgen && config.enable_swproxy) && \"Both enable_swproxy and enable_swproxy_hwdesgen should not be true at the same time.\""
- "!(use_hw_feature_points && use_sw_proxy_feature_points) && \"Cannot enable both hw feature points and sw proxy at the same time!\""
- "!ExactlyEqual(calibration_data_camera_matrix[0], 0.0) && ExactlyEqual(calibration_data_camera_matrix[1], 0.0) && !ExactlyEqual(calibration_data_camera_matrix[2], 0.0) && ExactlyEqual(calibration_data_camera_matrix[3], 0.0) && !ExactlyEqual(calibration_data_camera_matrix[4], 0.0) && !ExactlyEqual(calibration_data_camera_matrix[5], 0.0) && ExactlyEqual(calibration_data_camera_matrix[6], 0.0) && ExactlyEqual(calibration_data_camera_matrix[7], 0.0) && ExactlyEqual(calibration_data_camera_matrix[8], 1.0) && \"Camera matrix must be a valid projection matrix.\""
- "!ExactlyEqual(track.getStructure()->anchor_row_measurement(), VIOAnchoredPoint3DBase<Float>::kInvalidAnchorRowMeasurement) && \"The anchor row measurement has not been set in rolling-shutter compensation.\""
- "!HasKeypointForRelocalization() && \"makes sure when adding features, no featues are considered as relocalization only\""
- "!add_as_weak_keyframe && \"No weak keyframes are allowed to create new submap\""
- "!ba_->config().estimate_extrinsics || baid.parameters().use_IMU && \"No extrinsics estimation in vision-only mode currently\""
- "!config_.enable_swproxy_hw_desgen && \"Swproxy hw desgen is not supported in this flow.\""
- "!config_.pose_filter_config.enable_predictor_pose_filtering || (config_.pose_smoothing_config.use_prev_prop_states && config_.pose_filter_config.enable_predictor_pose_filtering) && \"predictor pose filtering needs use_prev_prop_states option to be true!\""
- "!depth_frames.empty() && \"Empty depth measurement frames\""
- "!error_downstream_.empty() && \"It is mandated that all errors are handled and enforced by a processor. \" \"Add an error handler with AddErrorHandler()\""
- "!filter_->GetCurrentTimestamp().has_value() && \"Filter must have beeen reset at this point\""
- "!filter_->IsInitialized() && \"We can only set the prior state if the filter is not initialized yet\""
- "!has_secondary_observations || (std::isfinite(meas_dist_secondary[(len - 1)](0)) == std::isfinite(meas_dist_secondary[(len - 1)](1))) && \"Both coordinates in secondary observation track must be finite or not.\""
- "!has_secondary_observations || kMeasurementSize < 2 || (meas_secondary[observation_index_in_track].e().isFinite().all() == meas_secondary[observation_index_in_track].e().isFinite().any()) && \"Both coordinates in secondary observation track must be finite or not.\""
- "!image_ids_of_state.empty() && \"No keyframes found for this vio state.\""
- "!impl_->state_correction_logic_->HasRelocalizationInfo() && !impl_->state_correction_logic_->HasStateCorrectionRequest() && \"Invalid state correction logic. We should not have existing request/reloc_info \" \"when next inplace relocalization is called\""
- "!imu_samples_buffer_.empty() && \"Error the IMU sample buffer cannoty be empty!\\n\""
- "!imu_samples_buffer_.empty() && \"The IMU sample buffer cannoty be empty!\""
- "!m_fallbackToHostForIteration && \"There is no injection in fall-back mode.\""
- "!m_marginalizer.batchedMarginalizationConfig().isEnabled && \"Batched marginalization not expected to be enabled in fallback to host.\""
- "!maybe_moving_platform_imu_camera_discrepancy || (tracking_state == OdometryTrackingState::IMUCameraDiscrepancyWithStationaryVision)"
- "!new_structure->ValidStructureCovariance() && \"New structure initialized to valid covariance.\""
- "!new_track_structure->ValidStructureCovariance() && \"New structure initialized to valid covariance.\""
- "!opt_last_frame_has_good_geometry_in_vio || (this->GetAdaptiveVIOState() == cv_types::AdaptiveVIOState::kVisionOnlySLAMAndVIOInitialization && opt_last_frame_has_good_geometry_in_vio.value() == last_frame_has_good_geometry_in_current_vfusion)"
- "!opt_ret && \"This return should only be set once\""
- "!ordered && \"Not supported without reordered indices.\""
- "!pose_smoothing_config.smoothing_set.empty() && \"pose_smoothing_config must not be empty!\""
- "!pred_samples.empty() && \"RLSPredict failed: Need to specify prediction indices\""
- "!predictor_state.vision_tracker_pose_metadata && \"Vision-only prediction not yet implemented\""
- "!primary_camera_streams.empty() && \"Primary cameras can't be empty\""
- "!reordered_descriptors_valid_ && \"makes sure reordered descriptors are not valid when adding feature without \" \"reordered descriptors\""
- "!ret.second && \"We will not succeed adding a factor\""
- "!state->vision_tracker_pose_metadata && \"Vision-Tracker metadata should be invalid\""
- "!state_.is_pause_finished || force_reinitialization_failure_ && \"Pause Finished should only be set if tracking has been paused.\""
- "!state_imus.empty() && \"Unable to handle no measurements.\""
- "!state_set->empty() && \"State set cannot be empty\""
- "!std::isnan(feature_sigma) && \"The feature sigma is not set!\""
- "!std::isnan(feature_sigma) && \"The feature sigma is not set.\""
- "!std::isnan(lens->MinimumHalfFOV()) && \"FOV must be valid in lens model\""
- "!std::isnan(pt_dist) && \"Should not be NAN.\""
- "!std::isnan(trace) && \"Trace cannot be NaN!\""
- "!std::isnan(vision_models.back().lens_model()->MinimumHalfFOV()) && \"FOV must be valid in lens model\""
- "!std::isnan(vision_models.front().lens_model()->MinimumHalfFOV()) && \"FOV must be valid in lens model\""
- "!this->IsWeakState(state_id0) && !this->IsWeakState(state_id1) && \"Inter session states has to be regular states \""
- "!this->RelocalizationVerificationInProgress() && \"Cannot update state correction during verification\""
- "!this->bad_geometry_in_last_frame_.first && \"Should not have bad_geometry_in_last_frame_\""
- "!this->config().bundle_adjuster_config.running_as_light_ba && \"The current solver should NOT be a light BA solver.\""
- "!this->latest_vfusion_kf_state_id_ || state_id != this->latest_vfusion_kf_state_id_.value() && \"Cannot delete the latest keyframe created by the VFusion front-end\""
- "!this->opt_reloc_info_ && \"relocalization info should be empty upon receiving state correction event\""
- "!this->opt_request_ && \"Query state ID should be empty upon receiving state correction event\""
- "!this->pose_and_cov_accumulator()->accumulated_pos_and_cov_queue().empty()"
- "!this->vfusion()->IsInitialized() && \"Filter must not be initialized yet\""
- "!this->vfusion()->IsUsingIMU()"
- "!this->viostate_variable_ids_.empty() && \"First VIOState must exist to add the prior\""
- "!track_set.findTrack(new_track_key) && \"The new track ID must not be used in the track_set.\""
- "!track_trail_went_cold && \"Cannot unset the track in batched operation.\""
- "!use_lens_model_during_detection_ && \"Currently not supported\""
- "!var_iter->second.state.isMarginalized() && !var_iter->second.state.isRemoved() && track_ptr->isPersistent() && \"SLAM variables associated to an entry in front-end tracks should not have \" \"been marked as marginalized or removed, and the track is persistent.\""
- "!window.FullWindowMode() && \"The window must be in incremental mode.\""
- "!window.frame_ids().empty() && \"We have an empty window!\""
- "(!this->config().avoid_prune_external_submaps_to_empty || reanchored) && \"reanchor should always succeed if avoid_prune_external_submaps_to_empty is set\""
- "(!this_->config().adaptive_vio_logic_config.enable_adaptive_vio || this_->config().is_visual_slam_enabled) && \"Adaptive VIO can only run for Moving SLAM\""
- "(*camera_mask) && *(camera_mask + (len - 1)) && \"The first and the last observation in the track must be valid.\""
- "(*first_state).front().timestamp < base_t && \"Not a lower bound.\""
- "(buffer_cameras_dest == buffer_cameras_end) || enforce_anchor_camera_only_triangulation"
- "(buffer_tracks_dest == buffer_tracks_end) || enforce_anchor_camera_only_triangulation"
- "(confidence32_img_owner && *confidence32_img_owner) && \"error allocating confidence frame for densification\""
- "(config_.navigation_config.pose_tracker_config .run_pnp_after_epipolar_outlier_rejection_in_visual_slam || config_.navigation_config.pose_tracker_config.outlier_rejection_config .use_p3p_estimator_for_primary_stream_in_stereo) && \"P3P must be enabled to compute the vision-propagted pose\""
- "(config_.permutation_matrix.empty() || config_.permutation_matrix.size() == kBitsPerFreakDescriptor) && \"Permutation matrix file size mismatch\""
- "(count == kBitsPerFreakDescriptor || ss.peek() == ',') && \"Permutation indices must be separated by commas.\""
- "(curr_imu_it + 1)->timestamp > curr_imu_it->timestamp && \"IMU timestamp must be in increasing order\""
- "(depth32_img_owner && *depth32_img_owner) && \"error allocating depth frame for densification\""
- "(edge.T_source_to_neighbor && edge.JtJ_source_to_neighbor) && \"Edge must have transformation\""
- "(feat_idx < image_features_.size() && feat_idx >= 0) && \"Feature out of bounds in prune.\""
- "(frame_downsampler_ != nullptr) != ExactlyEqual(result_upsampling_ratio_, 1.0) && \"Downsampler needs to be provided, unless scaling ratio is exactly 1.0.\""
- "(front_end_result.vfusion_return == VFusionReturn::kVFusionTakeStep || impl_->reinit_logic_controller_->state().maybe_reason_for_re_initialization) && \"If the window is under-constrained, we must have reinitialized and skipped\""
- "(image_id == ref_frame_image_id1 || image_id == ref_frame_image_id2) && \"Failed to find query frame\""
- "(lf_feature_type == kDetectorNoneDescriptorHardnet || lf_feature_type == kDetectorNoneDescriptorATUHardNetGlobalFeat) && \"feature type is not supported\""
- "(lhs.metadata && !lhs.metadata->frames_info.empty()) && \"MLFeatureEvent incomplete in Metadata in MLPriorityQueue\""
- "(m_skipHWCalls || (ok2 && *ok2)) && \"Call failed.\""
- "(new_base_state_id - oldest_acc_pose_and_cov.state_id0) <= (oldest_acc_pose_and_cov.state_id0 - new_base_state_id) && \"Target state id is before oldest_acc_pose_and_cov.state_id0\""
- "(new_map_track->getTrackLength() == 1u) && \"Length of trak is 1 when first added\""
- "(num_buckets_x == 1 && num_buckets_y == 1) && \"num_buckets x and y should be 1, other settings are currently not supported\""
- "(num_variables == 0) && \"We should only populate m_cameraToIMUVariables once.\""
- "(oldest_acc_pose_and_cov.state_id1 - new_base_state_id) <= (new_base_state_id - oldest_acc_pose_and_cov.state_id1) && \"Target state id is after oldest_acc_pose_and_cov.state_id1\""
- "(prop_states_.empty() || prop_states_.back().timestamp < timestamp) && \"Previously Propagated state timestamps must be strictly increasing.\""
- "(relative_pos_and_cov_queue_.front().state_id0 - new_base_state_id) <= (new_base_state_id - relative_pos_and_cov_queue_.front().state_id0) && \"Target state id is not before relative_pos_and_cov_queue_.front().state_id0\""
- "(ret == AddPoseGraphEdgeReturn::kAddedNewEdge || ret == AddPoseGraphEdgeReturn::kSkipDueToDuplicatedEdge) && \"Fail to add the external pose-graph edge to self map\""
- "(rhs.metadata && !rhs.metadata->frames_info.empty()) && \"MLFeatureEvent incomplete in Metadata in MLPriorityQueue\""
- "(start + block_size * kNumRegionOfInterestBlocks <= dimension) && \"End should be smaller than size\""
- "(states_.empty() || states_.back().timestamp < timestamp) && \"Base state timestamps must be strictly increasing.\""
- "(std::isfinite(meas_dist_secondary[len - 1](0)) == std::isfinite(meas_dist_secondary[len - 1](1))) && \"Both coordinates in secondary observation track must be finite or not.\""
- "(stream_id == 0 || stream_id == 1) && \"Incorrect stream id\""
- "(this->camera_extrinsics_variable_ids_.size() == 0) && \"We should only populate m_cameraToIMUVariables once.\""
- "(this->eigen_threshold.e() >= 0.).all() && \"The eigenvalue threshold should be non-negative.\""
- "(up != traj_end || !traj_timestamps.empty()) && \"There must be a valid upper bound found.\""
- "(use_baid_type1_ == !config.use_lp_fg || (!vio_baid1_ && !vio_baid2_ && !cached_vio_baid1_ && !cached_vio_baid2_)) && \"Cannot change BAID type once the object is initialized.\""
- "(variable_offset + DIM) <= hessian.rows() && \"Indices exceed matrix bounds.\""
- "(vio::math::L2Norm4(anchor_plane_in.data()) >= 1e-6) && \"anchor plane should not be all zeros\""
- "*camera_mask && *(camera_mask + static_cast<ptrdiff_t>(len - 1u)) && \"The first and the last observation in the track must be valid.\""
- "*est_period > 0. && \"est period must be > 0\""
- "*prev_state_timestamp_iter <= query_timestamp && *next_state_timestamp_iter >= query_timestamp && \"timestamp range failed\""
- "*prior_inverse_sigma > 0 && \"The prior variance cannot be smaller or equal to 0\""
- ", this->get_current_state_ids().front(): "
- ".txt"
- "/AppleInternal/Library/BuildRoots/5a481bbe-9f57-11ee-9024-8efc15467d2d/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.3.Internal.sdk/usr/local/include/boost/geometry/algorithms/detail/has_self_intersections.hpp"
- "/AppleInternal/Library/BuildRoots/5a481bbe-9f57-11ee-9024-8efc15467d2d/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.3.Internal.sdk/usr/local/include/boost/rational.hpp"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/AppleCV3D/AppleCV3D_framework/src/CV3DCCInterface.cpp"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/AppleCV3D/AppleCV3D_framework/src/internal/CV3DSLAMCalibrationUtils.cpp"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Essentials/Thread/src/ThreadGroup.cpp"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Essentials/Thread/src/WorkQueue.cpp"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Essentials/Thread/src/WorkQueueTypeUtil.cpp"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/Kit/Concurrency/include/Kit/Concurrency/Channel/ChannelOutput.h"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/Analytics/src/CoreAnalyticsInterface.cpp"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/Calibration/src/CalibrationDefaultsIOS.cpp"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/ComputerVisionTypes/include/VIO/ComputerVisionTypes/FrameRateConfiguration.h"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/FeatureDetectionNodeGroup/src/CameraSystemFeatureDetectionNodeGroup.cpp"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/FrameDownsampleNodeGroup/src/FrameDownsampler.cpp:250"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/FrameDownsampleNodeGroup/src/SampleSelector.cpp"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/Geometry/src/RANSAC/RangeBasedPreemptiveRansac.cpp"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/Odometry/include/VIO/Odometry/AdaptiveVIOLogic.cpp"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/Odometry/src/VFusionBase.cpp"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/OdometryEngine/src/DataVerificationConfig.cpp"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/Ranging/src/RangingManager.cpp"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/Ranging/src/RangingManagerNodeWrapper.cpp"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/Ranging/src/RangingUtil.cpp"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/VIOEstimator/include/VIO/VIOEstimator/BundleAdjustmentRangeAlignment.hpp"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/VIOEstimator/include/VIO/VIOEstimator/MotionAnalyzer.hpp"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/VIOEstimator/include/VIO/VIOEstimator/RangeBasedInitializationAndOutlierRejection.h"
- "/Library/Caches/com.apple.xbs/Sources/AppleCV3D/library/VIO/VIOEstimator/src/PlanarBAPipeline.cpp"
- "/System/Library/PrivateFrameworks/LACC.framework/Firmware/"
- "/metadata.txt"
- "0 && \"Does not support Planar mode\\n\""
- "0 && \"Invalid `current_vision_measurements`, `UseVIODatabaseAsInternalStorage()` has \" \"to be false.\""
- "0 && \"Invalid inlier tracks. `UseVIODatabaseAsInternalStorage()` has to be true.\""
- "0 && \"Invalid relocalization results\""
- "0 && \"Received Accel measurement exceeds maximum gap\""
- "0 && \"Received Gyro measurement exceeds maximum gap\""
- "0 && \"Received IMU measurement exceeds maximum gap\""
- "0 && \"Unknown health module\""
- "0 && \"Unsupported pose-graph edge type\""
- "0 && \"Unsupported with viodatabase as internal storage\""
- "0 && \"Unsupportted edges\""
- "0 && \"We should not call this function since it is ill implemented. See \" \"`Compute4DoFDeltaBetweenSE3Transforms()` for reference.\\n\""
- "00000000000000000000000000000000000000000"
- "Accel Processing"
- "Add Anchor"
- "AddMeasurements "
- "Adds the user anchors to this node only if they were added to LSE and they are in the active group"
- "Anchor group fwd"
- "AnchorType"
- "Anchors:CM:ID:%s, GID:%s"
- "Assertion 'numberOfVariable<PoseVariableType>() <= 2' failed: call site #"
- "BAFilterConfig.enforce_anchor_camera_only_triangulation"
- "BeginTimestamp"
- "BodyCropperConfig.closer_point_x_offset_meters"
- "Boost.Geometry Overlay invalid input exception"
- "Bundles features from a single camera stream together"
- "CA:TP:%d"
- "CAPI Output Error"
- "CCAPICallbackQueue"
- "CCAPIWorkQueue"
- "CCDAnalytics Event: num_updates=%d, duration_sec=%f, camera_source_id=%d, reason=%{public}s, algorithm=%{public}s, delta_camera_to_imu_rotation=[%f, %f, %f], delta_camera_intrinsics=[%f, %f, %f, %f], session_id=%{public}s"
- "CCDChange Event: CCD: [%02u][%02u] num_streams=%u, depth_change=%f, should_update=%{bool}d, timestamp=%f"
- "CCDConvergence Event: CCD: [%02u] num_streams=%u, converged=%{bool}d, fx=%f, fy=%f, cx=%f, cy=%f, rx=%f, ry=%f, rz=%f"
- "CCDDiff Event: CCD: [%02u] num_streams=%u, result=%hhu, t=%f, dr_deg=[%f, %f, %f], dk=[%f, %f, %f, %f]"
- "CCDIsConverged Event: CCD: collecting calibration parameters (%u/%zu)"
- "CCDIsConverged Event: CCD: parameter variance = [%e, %e, %e, %e, %e, %e, %e]"
- "CCDUpdateCalibration Event: CCD: resetting convergence detection due to low confidence (%d)"
- "CCDUpdateCalibration Event: CCD: resetting convergence detection due to low health (%f)"
- "CCDUpdateCalibration Event: CCD: waiting for confident parameters (%d)"
- "CMData Input"
- "CW:NAIS:TS:%f, UA:%u, EA:%u, RA:%u"
- "CameraCalibrationEnablerConfig.max_time_since_last_toggle"
- "CameraCalibrationEnablerConfig.min_required_camera_lux"
- "CameraStreamGroup"
- "CameraSystemFeatureDetectionNodeGroup"
- "ChangeDetectionResult Event: CCD: [%02u] change detection result = %hhu"
- "ClearMap Request"
- "Config is null in CV3DPosePredictionConfigSetShouldFilterStaticJitter"
- "Contains(expected_camera_stream_ids_, features.camera_stream_id) && \"An unexpected camera stream was pushed to the bundler.\""
- "DV:DROP:%s,%f,%f"
- "DV:LAT:High,%s,%f,%f"
- "DV:LAT:Low,%s,%f,%f"
- "DV:RATE:High,%s,%f,%f"
- "DV:RATE:Low,%s,%f,%f"
- "Defines the offset in X-direction of a point closer to the camera.."
- "Delete Anchor Channel"
- "Deleted Groups Transform Node"
- "DenseDepthNodeGroup"
- "DownsamplingNodeGroup"
- "ERROR : Can't use clamping and SmoothingWeightMode::SpeedAdaptiveWithHysteresis together"
- "ERROR:Unknown"
- "Empty Mapping directory."
- "Empty ThreadGroup name."
- "Enable state clamping"
- "Enable/Disable camera switching for SLAM"
- "EnableRangingRelocalization"
- "EndTimestamp"
- "Enforce anchor camera only triangulation for outlier rejection."
- "Engine Debug"
- "Engine state"
- "ExactlyEqual(ds_rates.back(), 1) && \"Last possible downsampling rate must be = 1\""
- "ExactlyEqual(extrap_timestamp, imu_measurements.back().timestamp) && \"IMU samples should span the entire extrapolation delta-time. Missing measurements must \" \"have been extrapolated/interpolated and resampled before this stage\""
- "ExactlyEqual(hardware_timestamp_of_planes, plane_measurements.hardware_timestamp) && \"Plane measurement time mismatch\""
- "ExactlyEqual(skipped_frame_org_timestamp, last_processed_org_timestamp_) && \"The skipping frame timestamp should be the same as the latest processed timestamp.\""
- "ExcessiveMotion"
- "Ext_Pos_Max_Eig"
- "Ext_Pos_Min_Eig"
- "Ext_Vel_Max_Eig"
- "Ext_Vel_Min_Eig"
- "Feature Bundler Node Group"
- "Feature Detection"
- "FeatureBundlerNode"
- "FeatureBundlerNodeGroup_OutputFeatureFwd"
- "FeatureBundlerNodeGroup_OutputStatusFwd"
- "FeatureDetectionNodeGroup"
- "FilteringNodeGroup"
- "Frame rate switch"
- "Frame: Camera ID: [%02u], Rate:%f/%f, Latency:%f/%f, ET:%f, HWET:%f"
- "Frame: Camera ID: [%02u], Rate:%f/%f, Latency:%f/%f, ET:%f, HWET:%f, ILC:%u, ILPW:%u"
- "FrameDownsamplerNode"
- "FrameFirmwareTimestamp"
- "G_refined_poses.size() == dataset_length && \"The optimizer should return refined poses for each pose in the input trajectory.\""
- "Gyro Processing"
- "HU:HE:%f, IE:%u, NT:%u, MC:%u"
- "HU:TS:%{bool}d, ADK_BG:%{bool}d"
- "H_dense.columns() == kExtrinsicDofSize && H_dense.rows() == kExtrinsicDofSize"
- "HasProcessedFirstWindow() && \"Filter is not yet initialized\""
- "HasProcessedFirstWindow() > 0 && \"VFusion Has not initialized yet\""
- "HasValidSize() && \"Descriptor size mis-match\""
- "Health Info Channel"
- "Health_est."
- "ICDVS: STR:%f, AVGF:%f, Stereo:%u, ERR:%f, PropVsBAOriERR:%f, AvgGyro:%f, vel:%f"
- "IMU Processing"
- "IMU measurement processing"
- "INIT:I:%{bool}d, IF:%{bool}d, RIA:%{bool}d"
- "ImuToJasperTransform"
- "Inlier_range_mnt_ratio"
- "Input Anchor Added Channel"
- "Input CM Data Channel"
- "Input Metadata Channel"
- "Input camera frame rate"
- "InsufficientFeatures"
- "IsGaussianPyramidGeneratorConfigValid(config) && \"Invalid configuration\""
- "IsKeyPointAndDescriptorGeneratorConfigValid(config) && \"Invalid configuration\""
- "IsResponseMapAndKPCGeneratorConfigValid(config) && \"Invalid configuration\""
- "IsUsingIMU() && \"We must be using IMU\""
- "JDFrameSelectorFwd"
- "JDFrameSelectorNode"
- "Jasper Frame Channel"
- "Jasper Frame Selector Node Group"
- "Jasper Trigger Channel"
- "JasperDescription"
- "JtJ.trace() > 0. && \"Invalid JtJ\""
- "Keyframe"
- "Label"
- "Lidar Trigger Forward"
- "Limited"
- "Load anchor channel"
- "Location Channel"
- "LowHeuristics"
- "M > 0 && \"Invalid IMUIIRFilter Filter call!\""
- "MI:META: NA:%u, UA:%u, EA:%u, RA:%u"
- "MLFeature Channel"
- "MLMetadataFwdChannel"
- "MT:NM_B:%d, NM:%d, EPMT:%d, IL:%d, IF:%d"
- "Map Request"
- "Map Request Channel"
- "Map Save Fwd"
- "MergedPlaneIDs"
- "MeshBuffering"
- "Minimum required camera lux for online calibration to be enabled."
- "Mocap Pose processing"
- "MocapPose Processing"
- "MovingIMUCameraDiscrepancyClassifierConfig.min_num_stereo_matches_to_conclude_low_texture"
- "MultiCameraFeatureDetectionNodeGroup_ErrorFwd"
- "MultiCameraFeatureDetectionNodeGroup_GyroFwd"
- "Multicamera error fwd"
- "Near(mGyroMeasurementsForFrame.back().timestamp, timestamp) && \"timestamp must be included in imu buffer\""
- "NoReason"
- "Node group to do camera system feature detection"
- "Normal"
- "NotAvailable"
- "OSLogSurrogateAppender"
- "Outlier_range_ratio"
- "OutputErrFwd"
- "OutputSampleTransformNode"
- "Pause / Resume Channel"
- "Per-frame temperature is missing. Calibration convergence detection will be inaccurate."
- "Plane"
- "PlaneID"
- "PointsOfInterest"
- "Polygon"
- "PoseBuffering"
- "PoseID"
- "PoseMetadataFwd"
- "PoseTrackerConfig.min_dirft_velocity_for_stationary_constraints"
- "Production"
- "Properties"
- "Range-based BA for "
- "RangeCost"
- "RangingManager"
- "RangingManagerNode"
- "RangingManagerNodeGroup"
- "RangingMetadataDispatcher"
- "Recieve a gyro scale update with value: %.30g, %.30g, %.30g"
- "RelocEventFwd"
- "Reloc_cov_pos_max_eig"
- "Reloc_cov_pos_min_eig"
- "Reloc_cov_rot"
- "Reloc_info_max_eig"
- "Reloc_info_min_eig"
- "Relocalizing"
- "Remove Anchor"
- "Request Anchors Transform Node"
- "Request to add anchor"
- "Request to clear map"
- "Runtime mode"
- "SLAM does not support lines"
- "SP:TS:%f, P:%f, %f, %f, %f, %f, %f"
- "STD:LSS:%{bool}d, S:%{bool}d"
- "Save Request"
- "Save anchor channel"
- "Self_Pos_Max_Eig"
- "Self_Pos_Min_Eig"
- "Self_Vel_Max_Eig"
- "Self_Vel_Min_Eig"
- "Set latest camera frame rate."
- "Sim"
- "SingleShotPlanes"
- "Support"
- "T_G_to_C"
- "T_I_to_C && \"Cannot find the corresponding camera in viodatabase\""
- "T_I_to_C && \"Failed to find ItoC transform for camera source\""
- "T_I_to_C_ptr && \"Cannot find the corresponding camera in viodatabase\""
- "T_ItoC && \"Failed to find I_to_C transform\""
- "T_plane_to_G"
- "Toggle odometry only mode in Local Slam Engine"
- "Tolerance for average absolute depth error in the stereo forward direction, in meters."
- "TrackedPlanes"
- "Transform_ext_IMU_to_self_IMU.txt"
- "Uncertainty"
- "Unexpected CV3DSLAMCameraMode value"
- "Unsupported camera mode."
- "UserSessionID Request"
- "VIOBuffering"
- "VioHealthReason"
- "VioHealthState"
- "[ACCEL] "
- "[FRAME] "
- "[GYRO] "
- "[GyroScaleUpdate] InfieldCal gyro scale factor applied: %f %f %f"
- "[Master user: "
- "_f && \"Function should contain valid target\""
- "accel_buffer.size() == gyro_buffer.size() && \"Gyro buffer must be synched with Accel Buffer size\""
- "accel_it != mAccelerometerMeasurements.end() && \"Not enough accelerometer Measurements to constrain the splines\""
- "added && \"Failed to add vio frame to self database\""
- "added && \"Range factor must be successfully added.\""
- "added && \"State variable must be successfully added.\""
- "anchor.anchor_.group_id_ && \"Anchor must have a group ID set\""
- "anchor_frame_id_iter != frame_index_to_image_id.end() && \"Fail to find anchor frame!\\n\""
- "anchor_frame_index_iter != image_id_to_frame_index.end() && \"Fail to find the anchor frame\""
- "anchor_pose_ref && \"Fail to find pose ref\""
- "anchor_pose_ref && \"Failed to find anchor pose_ref\""
- "angular_velocity"
- "area_mapping::StringToKeyframeMatchingMethod( config_slam_relocalization.keyframe_matching_method) != area_mapping::KeyframeMatchingMethod::Unknown && \"Unknown Keyframe matching method!\""
- "area_mapping::StringToKeyframeSamplingMethod( config_slam_relocalization.keyframe_sampling_method) != area_mapping::KeyframeSamplingMethod::Unknown && \"Unknown Keyframe sampling method!\""
- "avg_cost.size() == 3u"
- "bad numeric conversion: negative overflow"
- "bad numeric conversion: positive overflow"
- "bad rational: non-zero singular denominator"
- "bad rational: zero denominator"
- "baid && (baid->linearSystem().updatedAfterSolve() || baid->linearSystem().revertedAfterSolve() || baid->linearSystem().solveAttemptedAndFailed()) && \"Must be running in LPS mode and must have solved before.\""
- "base_pose_ref && \"Failed to find pose-ref\""
- "begin < end && \"Mean is undefined for empty ranges\""
- "begin < end && \"Median is undefined for empty ranges\""
- "begin < end && \"Standard deviation is undefined for empty ranges\""
- "bin_index == 0 && \"bin index should always be 0\""
- "block_size >= kMinBlockSize && \"Each block has to be at least 4 pixels big\""
- "body_cropping_enabled"
- "bool boost::geometry::detail::overlay::has_self_intersections(const Geometry &, const Strategy &, const RobustPolicy &, bool) [Geometry = boost::geometry::model::multi_polygon<boost::geometry::model::polygon<boost::geometry::model::point<double, 2, boost::geometry::cs::cartesian>>>, Strategy = boost::geometry::strategies::relate::cartesian<>, RobustPolicy = boost::geometry::detail::robust_policy<boost::geometry::model::point<double, 2, boost::geometry::cs::cartesian>, boost::geometry::model::point<long long, 2, boost::geometry::cs::cartesian>, double>]"
- "bool boost::geometry::detail::overlay::has_self_intersections(const Geometry &, const Strategy &, const RobustPolicy &, bool) [Geometry = boost::geometry::model::polygon<boost::geometry::model::point<double, 2, boost::geometry::cs::cartesian>>, Strategy = boost::geometry::strategies::relate::cartesian<>, RobustPolicy = boost::geometry::detail::robust_policy<boost::geometry::model::point<double, 2, boost::geometry::cs::cartesian>, boost::geometry::model::point<long long, 2, boost::geometry::cs::cartesian>, double>]"
- "buckets_hist.size() == bucket_num && \"Buckets histogram is expected to be allocated on input.\""
- "bundle.prediction_type != VisualSLAMPosePredictionType::Interpolate || visual_slam_window_.states.size() == 2u && \"There needs to be two states to interpolate in visual slam\""
- "bundle_.switch_timestamp && \"switch timestamp needs to be valid!\""
- "bundle_.timestamp_index && \"bundle timestamp_index needs to be valid\""
- "bundle_prior_info_.type == BundlePriorInformationType::InertialStatePriorInfo && \"At initialization, the prior info must be inertial-based (Inertial part can, \" \"though, be invalid)\""
- "c_store.timestamp_info.original_timestamp() >= 0 && \"Error the original timestamp is not set\""
- "calib_var_iter->second.variable.NumRegisteredTracks() == 0 && \"We should have zero tracks\""
- "calibration_data_camera_matrix.size() == 9 && \"Camera matrix must be a 3x3 matrix.\""
- "calibration_data_camera_to_imu_position.size() == 3 && \"Camera to IMU translation must be a 3-vector.\""
- "calibration_data_camera_to_imu_rotation.size() == 9 && \"Camera to IMU rotation must be a 3x3 matrix.\""
- "calibration_data_radial_distortion.size() == 4 && \"Radial distortion must be a 4-vector.\""
- "callable != nullptr && \"Callable must be valid\""
- "cam_strm_id.camera_id < cam_list.size() && cam_strm_id.stream_id < cam_list[cam_strm_id.camera_id].NumStreams() && \"Stream input does not match system configuration.\""
- "cam_strm_id.camera_id < camera_set_models.size() && \"Size of camera models should be same as that of descriptors.\""
- "cameraPoseIter != camera_poses_.end() && \"cannot find camera pose for node\""
- "camera_SE3Group_.count(imageID) && \"Query state dose not exist\""
- "camera_descriptor_stores.size() == front_end_interface_->vfusion()->GetCameraModelsWithDefaultIntrinsics().size() && \"Camera descriptor size not match Vfusion camera size\""
- "camera_features.NumStreams() == descriptors.NumStreams() && \"NumStreams mismatch\""
- "camera_id <= 0xffff && \"Camera ID cannot exceeds 16 bits\""
- "camera_id == nav_->StateIDandIntrinsics().back_n(1).camera_set_intrinsic_vec.front().camera_id && \"It's assumed the first camera ID is 0\""
- "camera_models->NumStreams() == 2u && \"only supports stereo\""
- "camera_set_ftr && \"Missing camera set features in front-end\""
- "camera_vision_models.front().NumStreams() == 2u && \"We must be using a stereo camera in vision-only\""
- "capi_return.has_value() && \"Failed to get VisualSLAMMode Mapping\""
- "capi_return.has_value() && \"Failed to get VisualSLAMState Mapping\""
- "channel_outputs.size() == channel_inputs.size()"
- "cloud.size() <= std::numeric_limits<size_t>::max() - non_filtered_structure.size() && \"Overflow in appending point clouds.\""
- "cloud.size() == ids.size() * num_structure_per_element && cloud.size() == vergence_angle_cosines.size() && \"The number of elements in the output arrays must be the same on input.\""
- "code && \"Invalid Anchor Added Result\""
- "com.apple.applecv3d.slam.min_num_successfull_frames_to_switch_to_vio"
- "com.apple.applecv3d.slam.oahu.minimum_required_lux"
- "compensated_distance"
- "compensated_rotation"
- "confidence32_img_pool_ && \"failed to create frame pool for 32-bit confidence\""
- "config().ml_desc_config.feature_type != feature_detection::FeatureType::DetectorNoneDescriptorATUHardNetGlobalFeat && \"Compute ML-VLAD image descriptor when GlobalFeat is enabled\""
- "config.fine_height >> octave >= kernel_size() && \"Too many octaves specified\""
- "config.fine_width >> octave >= kernel_size() && \"Too many octaves specified\""
- "config.image_height - config.bucket_height <= std::numeric_limits<int>::max() && \"config.image_height - config.bucket_height is outside the range of int\""
- "config.image_width - config.bucket_width <= std::numeric_limits<int>::max() && \"config.image_width - config.bucket_width is outside the range of int\""
- "config.max_keypoints <= std::numeric_limits<int>::max() && \"config.max_keypoints is outside the range of int\""
- "config.max_subpixel_iterations <= std::numeric_limits<int>::max() && \"config.max_subpixel_iterations is outside the range of int\""
- "config.num_buckets_scale <= std::numeric_limits<int>::max() && \"num_buckets_scale is outside the range of int\""
- "config.num_buckets_x <= std::numeric_limits<int>::max() && \"num_buckets_x is outside the range of int\""
- "config.num_buckets_y <= std::numeric_limits<int>::max() && \"num_buckets_y is outside the range of int\""
- "config.num_scales_per_octave == 3 && \"Number of scales for binomial gaussian pyramid must be 3.\""
- "config_.conservative_tracking_speeds_m_s_sq[2] < config_.conservative_tracking_speeds_m_s_sq[1] || ExactlyEqual(config_.conservative_tracking_speeds_m_s_sq[2], 0.0) && \"Threshold of conservative mode #2 should be smaller than that of mode #1, \" \"or mode #2 is disabled.\""
- "config_.min_acceptable_health_for_reinit >= config_.min_acceptable_health && \"Reinit health should be greater than tracking health threshold\""
- "config_.min_num_pnp_inlier_map_matches.size() == config_.min_pnp_inlier_ratio.size() && \"mis-match the inlier ratio and minimum inlier number size.\""
- "config_.pose_filter_config.accel_window_time_secs >= 0.0 && \"accel_window_time_secs >= 0\""
- "config_.pose_filter_config.alpha_beta_filter_default_dt > 0.0 && \"alpha_beta_filter_default_dt > 0\""
- "config_.pose_filter_config.default_sample_rate > 0.0 && \"default_sample_rate > 0\""
- "config_.pose_filter_config.gyro_window_time_secs >= 0.0 && \"gyro_window_time_secs >= 0\""
- "config_.pose_filter_config.pose_filtering_motion_configs[0].user_motion_classifier == PoseFilteringMotionCalssifier::UserStationary && \"1st state need to match stationary config\""
- "config_.pose_filter_config.pose_filtering_motion_configs[1].accel_threshold > config_.pose_filter_config.pose_filtering_motion_configs[0].accel_threshold && \"Accel thresholds need to be increasing with higher motion\""
- "config_.pose_filter_config.pose_filtering_motion_configs[1].gyro_threshold > config_.pose_filter_config.pose_filtering_motion_configs[0].gyro_threshold && \"Gyro thresholds need to be increasing with higher motion\""
- "config_.pose_filter_config.pose_filtering_motion_configs[1].speed_threshold > config_.pose_filter_config.pose_filtering_motion_configs[0].speed_threshold && \"Speed thresholds need to be increasing with higher motion\""
- "config_.pose_filter_config.pose_filtering_motion_configs[1].user_motion_classifier == PoseFilteringMotionCalssifier::UserMoving && \"2nd state need to match moving config\""
- "config_.pose_filter_config.transition_config.hysteresis_time_window_in_motion >= 0.0 && \"hysteresis_time_window >= 0\""
- "config_.pose_filter_config.transition_config.transition_window_state_A2B_sec >= 0.0 && \"A->B transition time needs to be > 0\""
- "config_.pose_smoothing_config.hysteresis_buffer_size > 0 && \"hysteresis buffer size needs to be > 0\""
- "config_.primary_cameras.size() == 1 && \"PrimaryStreamFrameAlternatorNodeWorker cannot use multiple primary cameras.\""
- "config_.save_interval > kMinSaveInterval && \"Save interval must be greater than kMinSaveInterval.\""
- "config_.secondary_cameras.size() == 1 && \"PrimaryStreamFrameAlternatorNodeWorker cannot use multiple secondary cameras.\""
- "config_.visual_slam_config.rls_gyro_filter_config.max_pred_samples == config_.visual_slam_config.rls_accel_filter_config.max_pred_samples && \"max pred time must be the same\""
- "config_.visual_slam_config.rls_gyro_filter_config.max_pred_samples > 0u && \"max pred must be > 0\""
- "const "
- "const char *cva::TypeNameDetail::prettyFunName() [T = cv3d::vio::geometry::NoncentricLensModelImpl]"
- "const_model_ref_ && \"the model is empty!\""
- "const_shared_camera_set_features != nullptr && \"Fail to find the camera features associated to the oldest state\""
- "context != nullptr && \"Context may not be nullptr\""
- "context && \"Context may not be nullptr\""
- "count == kBitsPerFreakDescriptor && \"Permutation sequence is too short.\""
- "curr_features.NumStreams() == 2u && \"Camera must have two streams\""
- "curr_state_var_iter != viostate_variable_ids_.end() && \"[VIOBABase] : Cannot find the current IMU State's Variables.\""
- "cva::exactlyEqual(last_update_timestamp_, -1.) || cva::exactlyEqual(timestamp, last_update_timestamp_) && \"The update must happen at the incoming state\""
- "default_query_lens_for_computing_FOV && \"Default lens of query VIO Frame is not available\""
- "default_ref_lens_for_computing_FOV && \"Default lens of reference VIO Frame is not available\""
- "depth32_img_pool_ && \"failed to create frame pool for 32-bit depth\""
- "device_on"
- "did_add_state && \"Failed to add keyframe. This should never happen.\""
- "dimension > 0 && \"Input dimension should be greater than 0\""
- "distance_traveled"
- "downstream_.empty() && \"It is mandated that there is only one output handler for a single consumer\""
- "ds_rates.size() > 0 && \"Must pass > 0 possible downsampling rates\""
- "dst < dst_end && \"Invalid destination pointer\""
- "dst.data() && \"\""
- "dt > 0 && \"The time difference cannot be negative\""
- "e_dim <= x_dim && \"Number of eigen values has to be smaller than x_dimension\""
- "edge.JtJ_source_to_neighbor && \"Edge transfomation not exist\""
- "edge.T_source_to_neighbor && \"Edge transfomation not exist\""
- "edge_type == PoseGraphEdgeType::kVIOEpipolarFactor4DoF && \"The edge type is not PoseGraphEdgeType::kVIOEpipolarFactor4DoF\""
- "eig_values[1 + i] >= 0 && \"The eigen value is small than zero\""
- "elem && \"Invalid plane debug pointer.\""
- "enable_camera_stream_alternation"
- "enable_state_clamping"
- "engine_ && \"Engine instance must be provided\""
- "engine_ && \"Invalid PosePredictor\""
- "engine_result.engine != nullptr && \"Instantiated SLAM engine is null.\""
- "error == 0 && \"dispatch_group_wait failed\""
- "error_callback_ && \"Invalid callback\""
- "error_downstream_.empty() && \"It is mandated that there is only one error handler for a single consumer\""
- "estimate_.state_ids.back() == bad_geometry_in_last_frame_.second && \"Inconsistent bad geoemtry frame ID\""
- "expected_camera_stream_ids_.size() > 0 && \"Incorrect number of cameras\""
- "external_map_iter != external_submaps_.end() && \"Failed to find the newly added external map\""
- "external_submap.data() && \"External map info must have a Map Data\""
- "external_submap.slam_relocalization() && \"External map info must have a relocalization module\""
- "external_to_self_global_transform_"
- "extrap_timestamp >= state_timestamps.back() && \"Prediction must be in future\""
- "extrinsic_j_var.entity() != nullptr && \"User-to-user extrinsics must be set up.\""
- "extrinsic_offset + kExtrinsicDofSize == H_dense.rows() && \"Extrinsic is at the end of linear system.\""
- "f.size() >= 1 && \"feature must be detected in at least one pyramid level\""
- "fTime since last time intrinsics estimation was enabled (seconds)."
- "factor_iter->second.factor.factor_valid() && \"Invalid factor is being picked\""
- "false && \"Adaptive VIO is not supported in asynchronous mapping/front-end\""
- "false && \"Adding plane measurements is not supported in VFusionBase\""
- "false && \"Cannot batch in software mode.\""
- "false && \"Changing sliding window size disables headless mode!\""
- "false && \"DataVerificationConfig default params should be either VIO or SLAM\""
- "false && \"DetectFeatures not supported for harris tracker\""
- "false && \"Empty variant lens model invoked.\""
- "false && \"Image resolution is not supported for hardware features.\""
- "false && \"No such condition should occur\""
- "false && \"Not implemented for lines\""
- "false && \"Not implemented for this Vfusion type\""
- "false && \"Not implemented for this Vfusion\""
- "false && \"Not implemented yet.\""
- "false && \"Not supported for this Vfusion type\""
- "false && \"Not supported yet\""
- "false && \"Not supported\""
- "false && \"Not yet implemented for this Vfusion type\""
- "false && \"Rematching not supported in HarrisTracker.\""
- "false && \"Should not be reached.\""
- "false && \"This does nothing.\""
- "false && \"TrackFeatures not supported for harris tracker\""
- "false && \"Unkonwn hit-test origin\""
- "false && \"imu_measurements not enough samples.\""
- "feature_samples[stream_id].point_sample.sec_to_pri_matches && \"Stream must have valid secondary to primary matches\""
- "features[camera_id].R_gyro_prev_to_cur_cam_frame.size() == camera_model->CameraStreamIds().size() && \"Number of incremental camera rotations does not match number of camera streams\""
- "features_to_keep.size() <= image_features_.size() && \"To many features in prune.\""
- "features_to_keep.size() <= num_features && \"More tracks than features in prune.\""
- "fg_info.type != BundlePriorInformationType::Invalid && \"Invalid FG Pior information\""
- "fg_info.type == BundlePriorInformationType::PosePriorInfo && \"FG info must be a pose prior information\""
- "filename && \"Invalid filename provided\""
- "filter_->state_ids().size() >= 2u && \"State id size should be greater than 2\""
- "filter_config.alphaBeta_theta >= 0.0 && filter_config.alphaBeta_theta <= 1.0 && \"PosePredictorPoseFilter alphaBeta_theta needs to be on [0,1]\""
- "filter_config.dt > 0.0 && \"PosePredictorPoseFilter dt needs to be > 0\""
- "filter_data.size() >= filter_taps.rows() && \"FilterData data length less than filter length\""
- "filter_output.rows() >= num_pred_smpls && \"filter_output length must be equal to num_pred_smpls.\""
- "filter_output.rows() >= pred_samples.size() && \"filter_output length must be equal to pred_samples size.\""
- "find_submap && \"find_submap is not set\""
- "first_frame_index != -1 && \"First frame of incoming bundle not present in previous estimate.\""
- "first_obs_image_id_iter != frame_index_to_image_id.end() && \"Incompatible Track observation\""
- "first_range_timestamp >= state_set_i.begin()->second->timestamp && last_range_timestamp <= state_set_i.crbegin()->second->timestamp && first_range_timestamp >= state_set_j.begin()->second->timestamp && last_range_timestamp <= state_set_j.crbegin()->second->timestamp && \"First and last range measurements should be within the bound of each `VIOStateSet`.\""
- "first_vio_frame_iter != database.end() && \"Cannot find the frame\""
- "fixed_imu_freq > 0.0 && fixed_imu_freq <= 2000.0 && \"Out of Bounds IMUFilter Sample Frequency\""
- "found_cam_stream_id.camera_id == config_.camera_used_for_mapping && \"We should not use tracks from this camera for mapping\""
- "frame_bundle && \"Cannot find the corresponding frame bundle\""
- "frame_bundle.vio_frame.image_id().view == target_state_id && \"State id does not match\""
- "frame_bundle_ref && \"Missing Frame bundle ref in front-end\""
- "frame_pool_ && \"Failed to construct apple_util::PixelBufferPool\""
- "frame_rate_configuration_.ModValue() == 2 && \"Only ModValue 1 and 2 supported.\""
- "frame_size == switching_size && \"camera_switching_frame_rates and camera_switching_events must be the same size\""
- "frequency_level != 0 && \"Mod 0 undefined.\""
- "fs::is_empty(config_.map_data_dir) && \"Mapping directory is not empty\""
- "ftr_index_iter != feature_key_to_feature_index.end() && \"Cannot find the feature\""
- "ftr_ptr != nullptr && \"Cannot find the feature in the track\""
- "gain_imu_median_est >= 0.0 && gain_imu_median_est <= 1.0 && \"gain_imu_median_est MUST be in range of [0,1]\""
- "graph_ && \"The graph is not set\""
- "graph_node_iter != pose_graph.nodes().end() && \"State does not exist in pose-graph graph\""
- "gyro_buffer.size() > 1 && \"Gyro buffer must be > 1\""
- "gyro_dt >= 0.0 && \"mGyroMeasurementsForFrame samples are non-increasing\""
- "gyro_it != mGyroMeasurements.end() && \"Not enough gyro Measurements to constrain the splines\""
- "hardware_params.num_cameras() && \"No cameras in calbration\""
- "has_lost_tracking"
- "height > 0 && \"\""
- "hessian.rows() == hessian.columns() && \"Hessian matrix should be square.\""
- "holding_queue_.empty() && \"Attempted to reinitialize mapping with submaps in the queue.\""
- "hw.optional.arm.FEAT_SME"
- "i1 < (1 << 30) && i1 >= -(1 << 30) && \"It is expected that a11*a22 is s31\""
- "i2 < (1 << 30) && i2 >= -(1 << 30) && \"It is expected that a12*a21 is s31\""
- "id_map_i.count(id_i1) > 0 && id_map_i.count(id_i2) > 0 && id_map_j.count(id_j1) > 0 && id_map_j.count(id_j2) > 0"
- "idx < responder_size"
- "image && \"Image is NULL\""
- "image.height() / std::pow(2.0, max_octaves - 1) >= 16 && \"An octave for fixed-point implementation must be at least 16x16\""
- "image.width() % static_cast<size_t>(std::pow(2.0, max_octaves)) == 0 && \"Resolution must be even for all octaves\""
- "image_descriptor_iter != ext_map_iter->second.data()->image_descriptors_.end() && \"Image descriptor does not exist!\""
- "image_descriptor_iter != this->data_->image_descriptors_.end() && \"Corresponding VLAD does not exist\""
- "image_features.size() == densedepth.size() && \"features and depths are different\""
- "image_id == ref_frame_image_id && \"Failed to find query frame\""
- "image_plane_size && \"image_plane_size must not be nullptr\""
- "impl().camera_matrix()[0] > 0 && \"Camera intrinsic focal length is smaller than zero\""
- "impl_"
- "impl_->camera_set_features_queue_.size() == 0 || incoming_state_timestamp > impl_->camera_set_features_queue_.back() ->camera_feature_samples.front() .feature_samples.front() .timestamp_info.timestamp() && \"The incoming frame must not have been processed yet\""
- "impl_->vfusion()->UseVIODatabaseAsInternalStorage() && \"Keyframe data ref is only valid for VFusionFG\""
- "imu.size() > 0 && \"There were no IMU measurements. Data problem?\""
- "imu_buffer_orig.size() > 1 && \"IMU buffer > 1\""
- "imu_filter_input.size() >= imu_filter_config.num_taps && \"imu_filter_input size must match number of RLS filter taps\""
- "imu_filter_params_.imu_default_sample_time > 0.0 && imu_filter_params_.current_period_rel_tol >= 0.0 && imu_filter_params_.est_period_rel_tol >= 0.0 && \"Expected positive values\""
- "imu_frame_bundle_opt && \"imu_frame_bundle_ in VFusion is not saved.\""
- "imu_meas.size() > 0 && \"IMU measurement buffer must not be empty\""
- "imu_measurements.size() >= 2 && \"Insufficient IMU measurements to estimate gyro rotation at extrapolation time\""
- "imu_measurements_segment >= 1 && \"Miss aligned IMU segments\""
- "imu_sample_buffer_ && \"IMU buffer is not set\\n\""
- "imu_sample_buffer_->NumIMUSamples() > 0 && \"IMU measurements is zero\\n\""
- "inertial_measurements_.NewestSample().timestamp <= window_imus.OldestSample().timestamp && \"new segment IMU meaasurements is not in order\""
- "initbad"
- "initgood"
- "initialized_ && \"Harris Feature Detector in not initialized\""
- "input_delay_line.rows() == ls_pred_cfg_.num_taps && \"input_delay_line length must be equal to num_taps.\""
- "input_delay_line.rows() >= ls_pred_cfg_.num_taps && \"input_delay_line length must be longer than num_taps.\""
- "inserted.second && \"Blocks must have a unique id\""
- "internal_state_callback_ && \"Invalid callback\""
- "interp_set.size() > 1 && interp_set.front() == 0 && interp_set.back() == imu_buffer_orig.size() - 1 && \"interp set must start with sample 0 and end with last sample in buffer\""
- "interp_state && \"PredictionBundlerIMUFilter: imu interpolation failed\""
- "inverseAnchorCameraPoseIter != inverse_camera_SE3Group_.end() && \"cannot find camera pose\""
- "is_horizontal"
- "is_pose_free_ && added && \"prior factor should be successfully added when it's free.\""
- "is_stationary"
- "is_weak_stationary"
- "iter != epipolar_outlier_rejection_per_camera_stream_.end() && \"Unfound camera stream\""
- "iter != incremental_poses_per_frame.end() && \"Camera incremental pose must exist\""
- "iter != input_neighbor_submaps.end() && \"pair_edge.first submap is not within neighbor set\""
- "iter != iter_end"
- "iter != ls.graph().template endFactor<TOffPriorFactor>() && \"There must be a prior factor for the time offset variable.\""
- "iter != map_uuid_property_.end() && \"Input UUID must be valid.\""
- "iter != per_camera_usage.end() && \"Query source ID does not exist\""
- "iter != this->local_map_ref_state_poses_.end()"
- "iter != viodatabase_->track_list()->end() && \"Cannot find the track.\""
- "iter->accel_threshold >= 0.0 && \"accel_threshold needs to be > 0\""
- "iter->alphaBeta_theta >= 0.0 && iter->alphaBeta_theta <= 1.0 && \"theta needs to be in range of [0,1]\""
- "iter->gyro_threshold >= 0.0 && \"gyro_threshold needs to be > 0\""
- "iter->second->timestamp < imu_segment_start_iter->timestamp && \"The state timstamp should be less than IMU start iter\""
- "iter->smoothing_wgt_overwrite_val >= 0.0 && iter->smoothing_wgt_overwrite_val <= 1.0 && \"smoothing_wgt_overwrite_val needs to be in range of [0,1]\""
- "iter->speed_threshold >= 0.0 && \"speed_threshold needs to be > 0\""
- "k16BitDepth && \"Requested 8-bit image, but buffer is 16-bit\""
- "kernel_size() <= std::numeric_limits<int>::max() && \"kernel_size() is outside the range of int\""
- "keypoints.size() > sample_size && \"AreaBinning: keypoints.size() > sample_size\""
- "landmarkID == track->ID().key() && \"Landmark ID and track ID is different\""
- "lap1.height() - 1 <= std::numeric_limits<int>::max() && \"lap1.height() - 1 is outside the range of int\""
- "lap1.width() - 1 <= std::numeric_limits<int>::max() && \"lap1.width() - 1 is outside the range of int\""
- "lap_scale0.height() == lap_scale1.height() && \"image height mismatch\""
- "lap_scale0.width() == lap_scale1.width() && \"image width mismatch\""
- "laplacian_pyr.num_scales_per_octave() == 2 && \"Only supporting binomial gaussian pyramid, with 2 scales per octave\""
- "laplacian_pyramid.fine_height() == gaussian_pyramid.fine_height() && \"Top pyramid level must have the same size.\""
- "laplacian_pyramid.fine_width() == gaussian_pyramid.fine_width() && \"Top pyramid level must have the same size.\""
- "laplacian_pyramid.num_scales_per_octave() == gaussian_pyramid.num_scales_per_octave() - 1 && \"Laplacian pyramid built from Gaussian must have one less octaves.\""
- "laplacian_pyramid.size() - 1 <= std::numeric_limits<int>::max() && \"laplacian_pyramid.size() - 1 is outside the range of int\""
- "last_relative_pose_and_cov_ && \"last_relative_pose_and_cov_ must exist\""
- "last_valid_element < elements.size() && predicate(elements[last_valid_element]) > 0 && \"Make sure last_valid_element points to a valid element\""
- "lens && \"Error cannot find the lens\\n\""
- "lens0 && \"Invalid lens model\""
- "lens_info_iter->second.measured_lens && \"measured_lens is not allocated\""
- "lens_iter != image_id_lens_map.end() && \"Fail to find the lens\""
- "line_cloud.size() == 2 * line_ids.size() && \"line_cloud size must be twice the number of ids\""
- "line_cloud.size() == vergence_angle_cosines.size() && \"line_cloud size must be equal to vergence angles size\""
- "linear_system.graph().template findFactor<FactorType>(factor_cnt) == linear_system.graph().template endFactor<FactorType>() && \"Factor with the same ID already exists.\""
- "linear_system.graph().template numberOfVariable<VARIABLE_TUPLE>() == 0 && \"CameraCalibVariables of this type have already been added.\""
- "linear_system.template findVariable<LandmarkType>(landmark_variable_id) != linear_system.template endVariable<LandmarkType>() && \"Landmark with the given ID was not found.\""
- "linear_system.template findVariable<SLAMLandmarkVariableType>(landmarkID) != linear_system.template endVariable<SLAMLandmarkVariableType>() && \"The persistent track is not associated to a SLAM landmark variable\""
- "linear_system.template findVariable<SLAMLandmarkVariableType>(landmarkID) == linear_system.template endVariable<SLAMLandmarkVariableType>() && \"There should not be any SLAM landmark Variable with this track ID.\""
- "linear_system_.graph().template numberOfVariable<LandmarkVariableType>() == 0 && \"Number of landmarks should be zero.\""
- "loaded_external_submaps->size() == 1 && \"Non-submapping case requires a single MapData instance.\""
- "loaded_submap && \"Loaded submap must be valid.\""
- "location && \"Location input is required.\""
- "location_info && \"LocationInfo is NULL.\""
- "ls.template extractCovariance<typename BATraits::PoseVariable>( variable_id, covariance) && \"Failed to extract pose variable covariance.\""
- "ls_pred_cfg_.filter_max_L2_norm >= 0.0 && \"Filter max coefficient norm limit needs to be >= 0.\""
- "ls_pred_cfg_.filter_reg_eps >= 0.0 && \"Filter regularization needs to be >= 0.\""
- "ls_pred_cfg_.ls_update_mode == LeastSquaresPredictionUpdateMode::RLS && \"Function can only be used in LS RLS update mode\""
- "ls_pred_cfg_.ls_update_mode == LeastSquaresPredictionUpdateMode::RLS && \"Function can only be used in LS RLS update mode.\""
- "ls_pred_cfg_.ls_update_mode == LeastSquaresPredictionUpdateMode::RLS && \"Function can only be used in RLS update mode.\""
- "ls_pred_cfg_.max_pred_samples > 0 && filter_config.max_pred_samples <= 40 && \"Filter max prediction samples needs to be in range of [1,40].\""
- "ls_pred_cfg_.num_taps <= 20 && filter_config.num_taps > 0 && \"Filter number of taps needs tp be in range of [1,20].\""
- "ls_pred_cfg_.rls_forgetting_factor <= 1.0 && ls_pred_cfg_.rls_forgetting_factor >= 0.5 && \"Filter RLS forgetting factor needs tp be in range of [0.5,1].\""
- "ls_pred_cfg_.training_samples > 10 && \"Filter LS training samples needs to be > 10.\""
- "lut_indices[4u] > 0 && \"Feature center should always be valid\""
- "mFrames.back().intrinsic_matrices().size() == 2 && \"AddSecondaryMeasurements() must be called prior to \" \"AddSecondaryMonoMeasurements()\""
- "mGyroMeasurementsForFrame.size() == mAccelerometerMeasurementsForFrame.size() && \"Gyro measurements need to be synched to accel\""
- "mGyroMeasurementsForFrame.size() > 1 && \"Must have > 1 measurement\""
- "m_data.size() == 1 && \"Failed to read submap from disk.\""
- "map_->HasPoseGraphNode(external_keyframe_info.vio_state_id) && \"External keyframe exist in self map but not in pose graph\""
- "map_data.viodatabase() && \"Map Data must have a vio database\""
- "map_file_path && \"Path to map file is nullptr\""
- "map_groups.count(submap) > 0 && \"targeted submap not passed in map_groups\""
- "map_optimization_result.opt_T_Gold_to_Gnew_per_state && \"The delta transformation is empty\""
- "mapping_add_new_kf_output_queue_.empty() && \"The mapping_add_new_kf_output_queue_ needs to be empty when pushing new result\""
- "matched_count == num_curr_planes && \"Number matched cannot be higher than the initial count of planes\""
- "math::IsOrthogonal3x3(&calibration_data_camera_to_imu_rotation.front(), 1e-5) && \"Camera to IMU rotation must be a 3x3 orthogonal matrix.\""
- "max_anchors_per_group_ > 0 && \"Max anchors per group must be positive\""
- "max_num_features <= std::numeric_limits<IntFeatureIndex>::max() && \"IntFeatureIndex is too small.\""
- "max_num_point_feature_large_scale <= valid_feature_size && \"max_num_point_feature_large_scale size invalid\""
- "max_pred_idx <= ls_pred_cfg_.max_pred_samples && min_pred_idx > 0u && \"RLSPredict failed: prediction indices must be in in [1,max_pred_samples] range.\""
- "max_radius_noncentric > 0"
- "max_slam_point_tracks <= parameters_.ba_config.max_num_optimized_tracks && \"Persistent SLAM landmarks should not be larger the maximum optimized tracks\""
- "maybe_uuid && \"Invalid UUID when loading AnchorSetSample from disk\""
- "measurements.IsCameraIDAlignedAsIndex() && \"Camera feature measuremetns are not aligned as zero based CameraIDs\""
- "merged_map_data && \"primary submap must be one of the submaps\""
- "metadata->vio_metadata.pose_metadata && \"VIOMetadata must have pose metadata\""
- "minimizer_parameters.use_IMU && \"Offline BA not supported for vision-only SLAM\""
- "minimum >= 1 && \"The minimum view number has to be larger 0\""
- "n <= std::numeric_limits<uint32_t>::max() && \"n is outside the range of uint32_t\""
- "new_anchor_pose_ref != nullptr && \"Cannot find the pose ref\""
- "new_anchor_pose_ref->lens && \"Lens does not exist\""
- "new_features.size() == features_to_keep.size() && \"Missing features after prune.\""
- "new_map_track && \"We should be always able to add tracks\""
- "new_state != nullptr && \"Cannot find the state\""
- "next_state_timestamp_iter != state_timestamps.end() && \"Fail to find the state whose timestamp greater than query\""
- "next_submap_session_cb_ && \"Next submap session ID callback is not set!\""
- "nit != new_track->end() && \"Failed to add a node to track map\""
- "node != nullptr && \"Error we cannot retrieve the track-node\""
- "node_id1 != remove_state_var_id && \"state variable id error\""
- "node_id2 != remove_state_var_id && \"state variable id error\""
- "node_iter != pose_graph.nodes().end() && \"Failed to find pose-graph node\""
- "num_active_submaps"
- "num_anchors == tracked_anchors && \"Some anchors were not classified.\""
- "num_bins < std::numeric_limits<IntBinIndex>::max() && num_bins * num_bins + 1 < std::numeric_limits<IntBinIndex>::max() && num_bins * num_bins * num_bins_multiplier + 1 < std::numeric_limits<IntBinIndex>::max() && (!ENABLE_MINMAX_BINNING || num_bins * num_bins * num_bins_multiplier * 2 + 1 < std::numeric_limits<IntBinIndex>::max()) && \"IntBinIndex is too small.\""
- "num_buckets_scale >= 1 && \"num of buckets scale should be >= 1\""
- "num_buckets_x == 1 && num_buckets_y == 1 && \"AssignScaleBuckets_Thresholding() does not support spatial buckets.\""
- "num_external_submaps"
- "num_frontend_tracks_to_keep < num_frontend_tracks && \"Pruning tracks not required.\""
- "num_localized_submaps"
- "num_matches == traj_i.size()"
- "num_matches == traj_j.size()"
- "num_matching_bits == 256 && \"Number of bits for matching can only be 128/256\""
- "num_matching_bits == 512 && \"Number of bits for matching can only be 128/256/512\""
- "num_observations * kMeasurementSize <= m_measurements.max_size() && \"Size of requested track matrix exceeded maximum vector size.\""
- "num_observations <= m_mask.max_size() && \"Size of requested track mask exceeded maximum vector size.\""
- "num_optimized_slam_landmarks_ == 0 && \"No SLAM variable should exist at this point.\""
- "num_pred_smpls <= ls_pred_cfg_.max_pred_samples && num_pred_smpls > 0u && \"num_pred_smpls must be in in [1,max_pred_samples] range.\""
- "num_samples <= std::numeric_limits<uint32_t>::max() / 255 && \"The resolution is too high; pixel sum will overflow.\""
- "num_scales > 2 && \"Number of scales should be > 2\""
- "num_scales_minus2 <= kMaxNumOfScalesMinus2 && \"Number of scales minus 2 should be less than or equal to max expected\""
- "num_secondary_streams == 0 || num_observations * kMeasurementSize <= m_secondary.front().measurements.max_size() && \"Size of requested track matrix exceeded maximum vector size.\""
- "num_tracks_has_sufficient_inlier_measurements >= inlier_tracks.size() && \"Number of good tracks cannot be smaller then num inlier tracks\""
- "obj_anchor.anchored() && \"We cannot have an object anchor that is not anchored.\""
- "object_anchor_set_ && \"object_anchor_set_ == nullptr!\""
- "object_anchors_.count(object_id) == 0 && \"The anchor exist in the object anchor set!\""
- "object_iter != src_map_data.object_anchor_set_.ObjectAnchors().end() && \"Failed to find object anchor\""
- "obs && \"missing anchor observation\""
- "obs_image_id_iter != frame_index_to_image_id.end() && \"Incompatible Track observation\""
- "obs_node && \"Cannot find the observation in the track\""
- "obs_pose_ref && \"missing pose ref\""
- "ok && \"Call to marginalize did not return as expected.\""
- "old_anchor_pose_ref != nullptr && \"Cannot find the pose ref\""
- "on_instance_id"
- "op_health_metadata && \"Health metric is not valid. It should never happen\""
- "op_uuid && \"Invalid UUID.\""
- "opt && \"Invalid uuid in UserAnchorWithMetadataSample\""
- "opt_camera_set_model->NumStreams() == feature_samples.size() && \"The number of features does not match number of cameras\""
- "opt_camera_set_model.has_value() == (feature_samples.size() > 1) && \"The optional camera set model should be available for stereo pair.\""
- "opt_camera_set_model.has_value() == (features.size() > 1) && \"`opt_camera_set_model` should be non-empty for a stereo feature sample.\""
- "opt_cm"
- "opt_incremental_pose && \"Incremental pose must exist\""
- "opt_last_imu_in_latest_bad_geo_frame_.has_value() && \"`opt_last_imu_in_latest_bad_geo_frame_` must be valid if the last frame\" \" had bad geometry.\""
- "opt_latest_camera_set_features && \"Missing latest camera set features!\""
- "opt_obj_cm && \"Fail to create the object_anchor_cm using origin anchor. It should \" \"always succeed\""
- "opt_object_anchor_cm && \"Cannot create object anchor cm!\""
- "opt_query_frame && \"Failed to find frame in camera set features\""
- "opt_query_submap && \"Query submap does not exist\""
- "opt_ref_camera_set_features && \"The camera set features must exist for the already estimated state\""
- "opt_ref_image_descriptor && \"Image descriptor does not exist.\""
- "opt_submap_session_id && \"Submap session ID must exist!\""
- "optimized_trajectory.size() <= inertial_trajectory.size() && \"The inertial states trajectory must have a pose for each optimized trajectory pose.\""
- "ordered && \"Indices can only be reordered once.\""
- "ordered && \"Not supported with reordered indices.\""
- "orientation >= 0 && orientation < 256 && \"orientation overflow\""
- "outlier_rej_stats_iter != outlier_rejection_stats.stats.end() && \"Failed to find primary stream outlier rejection stats\""
- "pixel_buffer && \"Data owner needs to be intialized\""
- "pixel_transfer_session_ && \"Failed to construct apple_util::PixelBufferTransferSession\""
- "plane_track->second->getStructure() && \"The track does not have a structure!\""
- "point_displacement_tolerance_factor > 0. && \"Speed tolerance factor must be positive\""
- "point_track_structure && \"Point track missing structure.\""
- "points2d.size() == points3d.size() && \"The number of 2D points and 3D points must be matched.\""
- "points_3d.size() / 3u == xc.size() / 2u && \"The number of the 3D points must be equal to the number of 2D-points\""
- "pose_and_cov_accumulator_ ->GetOldestStateAccumulatedPoseAndCov( this->window_will_slide_in_next_iteration().first) .state_id1 == static_cast<uint32_t>(get_current_state_ids().front()) && \"The state does not align to the current bundle.\""
- "pose_and_cov_accumulator_->GetBaseStateID() == new_base_state_id && \"The state does not align to the current bundle.\""
- "pose_and_cov_accumulator_->GetBaseStateID() == prev_base_state_id && \"Incorrect previous base state ID\""
- "pose_extrapolation_filters[0]->GetFilterConfig().max_pred_samples == pose_extrapolation_filters[0 + cv_types::InertialState::kPositionDof] ->GetFilterConfig() .max_pred_samples && \"6d pose filters must have same max pred time\""
- "pose_extrapolation_filters[0]->GetFilterConfig().max_pred_samples > 0 && \"max pred time needs to be > 0\""
- "pose_filter_config.transition_config.transition_window_state_A2B_sec >= 0.0 && \"transition_window_state_A2B_sec >= 0\""
- "pose_predictor_ && \"Invalid Pose Predictor\""
- "pose_predictor_ && \"Invalid PosePredictor\""
- "pose_ref != nullptr && \"Cannot find the pose ref\""
- "pose_ref && \"No pose ref found\""
- "pose_ref->lens && \"Lens does not exist\""
- "pose_smoothing_config.smoothing_set.size() == 5 && \" Expected pose smoothing smoothing set is 5\""
- "pose_smoothing_config.smoothing_set.size() == expected_num_elems && \"smoothing_set.size() == expected_num_elems!\""
- "pose_variable_id == vel_and_bias_variable_id && \"First pose ID different\""
- "prediction_callback_ && \"Invalid Prediction Callback\""
- "prev_attached_plane.attached_state_id && \"State ID not set\""
- "prev_base_state_id == oldest_acc_pose_and_cov.state_id0 && \"Ensure the request is coming from the same base state ID\""
- "prev_state_var_iter != viostate_variable_ids_.end() && \"[VIOBABase] : Cannot find the current IMU State's Variables.\""
- "prev_timestamp < state->timestamp"
- "prewitt_on"
- "prior.rows() == prior.columns() && \"Prior has to be symmetric\""
- "prior.rows() >= state_offset + 3 && \"state offset exceeds matrix size\""
- "prior_info.info.rows() >= 15 && \"Invalid inertial-state prior info.\""
- "prior_info.info.rows() >= 6 && \"Invalid pose prior info.\""
- "prior_info.rows() == 4u && prior_info.columns() == 4u"
- "prior_inverse_sigma->min() > 0 && \"The prior variance cannot be smaller than 0\""
- "prior_variance > 0 && \"Input variance is smaller than zero\""
- "priv().initialized_root_appenders_ == current_root_appenders && \"root appenders have been illegally modified between Initialize() and \" \"Enable() of APILogging\""
- "priv().initialized_root_appenders_ == current_root_appenders && \"root appenders have been illegally modified between Initialize() and \" \"EnableInternal() of APILogging\""
- "priv().initialized_root_appenders_ == current_root_appenders && \"root appenders have been illegally modified between Initialize() and \" \"EnableInternalWithConfigurationFile() of APILogging\""
- "propagator != nullptr && \"propagator cannot be nullptr\""
- "query_camera_info.default_lens_minimum_half_fov_deg > 0. && \"FOV must be valid.\""
- "query_ext_state && \"Failed to find state in ext_map_data\""
- "query_map_data.viodatabase() && \"Map Data must have a viodatabase\""
- "query_pose_ref && \"Failed to find projection ref\""
- "range_calib.vioState_T_j_to_i.has_value() && \"Slave user must have slave-to-master transform.\""
- "range_i_var.entity() != nullptr && \"Range to IMU variable must be set up.\""
- "range_j_var.entity() != nullptr && \"Range to IMU variable must be set up.\""
- "range_measurements.begin()->timestamp >= traj_timestamps.begin()->second && range_measurements.rbegin()->timestamp <= traj_timestamps.rbegin()->second && \"Timestamp of range measurements should lie within that of pose states.\""
- "range_sigma_ > 0. && \"Sigma must be positive.\""
- "ranging_manager_"
- "ratio_of_points_to_compute_avg_point_displacement <= 1. && \"Ratio of stationary points must be smaller or equal to 1\""
- "ratio_of_points_to_compute_avg_point_displacement > 0. && \"Ratio of stationary points must be greater than zero\""
- "ref_frame_iter != ref_frames.end() && \"Failed to find query frame\""
- "ref_frame_wrapper.size() > 0 && \"incorrect reference keyframe in MultiFrame Reloc\""
- "ref_keyframe && \"ref frame cannot be nullptr\""
- "ref_map_data.viodatabase() && \"Map Data must have a vio database\""
- "ref_map_data.viodatabase() && \"Map Data must have a viodatabase\""
- "ref_proj_ref && \"Failed to find projection ref\""
- "ref_sec_to_ref_pri_matches && \"Camera has no invalid stereo matches\""
- "ref_self_state && \"Failed to find state in self_map_data\""
- "regular"
- "rel_pose_and_cov1.state_id1 == rel_pose_and_cov2.state_id0 && \"Relative poses has to be consecutive\""
- "relocalization_callback_ && \"Invalid Relocatization Callback\""
- "remove_factor_ids[first_factor_index] != remove_factor_ids[sec_factor_index] && \"No two sames factors\""
- "removed_submap && \"removed_submap is invalid\""
- "res && \"Failed to get or create directory.\""
- "result && \"Fail to set anchor\""
- "result && \"Failed to remove a variable.\""
- "result.keyframe_id && \"Result must have a keyframe id to be successfull\""
- "results.size() == num_anchor_boxes && \"Number of predictions must equal to number of anchor boxes.\""
- "ret && \"Database can't add frame\""
- "ret && \"Fail to add the edge to the graph\""
- "ret && \"Fail to add the state variable this should never happen\""
- "ret && \"Fail to compute calibrated measurement\""
- "ret && \"Fail to remove a variable\""
- "ret && \"Fail to remove node. this is not possible\""
- "ret && \"Fail to remove state\""
- "ret && \"Fail to remove state, this should not happen!\""
- "ret && \"Fail to set anchor\""
- "ret && \"Failed to compute calibrated measurement\""
- "ret && \"Failed to remove a variable.\""
- "ret && \"Failed to remove end point variables.\""
- "ret && \"We fail to remove states which should not happen\""
- "ret && \"We should not failing set a anchor\""
- "ret && \"When re-anchoring, failed to set anchor for track using frame \""
- "ret && \"empty last state propagated covariance\""
- "ret && \"imu_features_syncer_ failed to process camera measurement\""
- "ret == 0 && \"Failed to set workgroup flags.\""
- "ret.first && \"Failed to find the vio state\""
- "ret.second && \"Duplicated pose ref. This should not happen\""
- "ret.second && \"Fail to add the camera variable this should never happen\""
- "ret.second && \"Fail to add the factor into linear system. This could be due to \" \"duplicated factor id.\""
- "ret.second && \"Fail to add the factor into linear system. this could be due to \" \"duplicated factor id\""
- "ret.second && \"Fail to add the factor into linear system. this could be due to duplicated factor id\""
- "ret.second && \"Fail to add the factor!\""
- "ret.second && \"Fail to add the factor\""
- "ret.second && \"Fail to add the factor. Likely duplicated factor id\""
- "ret.second && \"Fail to add the factor. This should never happend\""
- "ret.second && \"Fail to add varaible\""
- "ret.second && \"Fail to insert a camera to the system. Camera is already there\""
- "ret.second && \"Failed to add Pose prior factor\""
- "ret.second && \"Failed to add a factor into the linear system. This could be due to \" \"duplicate factor id.\""
- "ret.second && \"Failed to add a factor into the linear system. This could be due to duplicate factor id.\""
- "ret.second && \"Failed to add imu calibration prior factor\""
- "ret.second && \"Failed to add state prior factor [Moving Platform]\""
- "rt != camera_readout_times_.end() && \"Readout time not found in calibration.\""
- "sample.packed_hwfp && \"Must contain feature points.\""
- "sample_period > 0 && \"sample_period must be greater than 0\""
- "scale == kp_scale && \"scale mismatch\""
- "scaled_hardware_params.num_cameras() == 1 && \"VIO only support 1 or 2 cameras.\""
- "scheduler_ && \"scheduler must be valid\""
- "score == res_map_cube[1][1][1] && \"score mismatch\""
- "seed_estimate_.bundle.num_frames() == seed_estimate_.state_ids.size() && \"Sizes should match after updating from window.\""
- "sequence_camera_stream_features_.size() > 0 && \"cameras must not be empty\""
- "size_configs.size() == frame_selector_config.size()"
- "slam_health"
- "slam_mode"
- "smudge_detected"
- "sqrt_I_ != nullptr && \"Covariance cannot be nullptr\""
- "src.data() && \"\""
- "src_track_length == end_track_length && \"source and end points must have same track length\""
- "start >= 0 && \"Start should be greater than 0\""
- "state != nullptr && \"Error we cannot retrieve the viostate\""
- "state && \"Query state dose not exist\""
- "state->pose_metadata->reinitialize_attempts >= 0 && \"Number of re_initialization has to be positive\""
- "state_and_intrinsic_pair && \"Fail to find the state and instrinsic pair\""
- "state_index_in_bundle >= 0 && \"Cannot find the state id in the bundle\""
- "state_pos_in_window >= 0 && \"Fail to find the state within the bundle\""
- "state_projection_ref_ptr && \"Failed to find a ProjectionRef\""
- "state_ptr && \"Failed to find state for keyframe\""
- "state_ptr && \"Query state does not exist in the database\""
- "state_timestamps.size() == states.size() && \"States size must match timestamps size\""
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = bool (const cv3d::vio::feature_detection_node_group::LineTrackingEnablerVIOHealthStatistics &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelError<cv3d::vio::feature_detection_node_group::FeatureDetectionError>]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelError<cv3d::vio::frame_downsample_node_group::FrameDownsamplerError>]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelError<cv3d::vio::frame_downsample_node_group::JasperFrameSelectorError>]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelOutput<cv3d::vio::cv_types::FrameData<unsigned char>>]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelOutput<cv3d::vio::cv_types::FrameRateConfiguration>]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelOutput<cv3d::vio::cv_types::GyroMeasurement>]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelOutput<cv3d::vio::feature_detection::NodeCameraStreamFeatures>]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelOutput<cv3d::vio::feature_detection::NodeCameraSystemFeatures>]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelOutput<cv3d::vio::frame_downsample_node_group::JasperFrameSelectorError>]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelOutput<cv3d::vio::multicamera_node_group::BundleCreationStatus>]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelOutput<cv3d::vio::multicamera_node_group::CalibrationAndFrameRateRequest>]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelOutput<double>]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelOutput<std::tuple<std::optional<cv3d::vio::feature_detection::NodeCameraSystemFeatures>, cv3d::vio::multicamera_node_group::BundleCreationStatus>>]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelOutput<std::variant<cv3d::vio::frame_downsample_node_group::FrameDownsamplerError, cv3d::vio::frame_downsample_node_group::JasperFrameSelectorError, cv3d::vio::feature_detection_node_group::FeatureDetectionError>>]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelOutput<std::vector<cv3d::vio::data_verification::DataVerificationStatus>>]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ChannelOutput<std::vector<std::shared_ptr<const cv3d::vio::cv_types::JasperPointCloud>>>]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::OptionalReturn<cv3d::vio::capi::AnchorGroup> (const std::vector<cv3d::vio::data_verification::DataVerificationStatus> &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::OptionalReturn<cv3d::vio::feature_detection::NodeCameraSystemFeatures> (std::tuple<std::optional<cv3d::vio::feature_detection::NodeCameraSystemFeatures>, cv3d::vio::multicamera_node_group::BundleCreationStatus>)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::OptionalReturn<std::vector<cv3d::kit::cf::ErrorRef>> (const std::vector<cv3d::vio::data_verification::DataVerificationStatus> &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ReturnOrThrow<cv3d::kit::concurrency::OptionalReturn<std::shared_ptr<const cv3d::vio::odometry_engine::SLAMMetadata>>, cv3d::vio::slam_engine_node_group::SlamEngineNodeError> (const cv3d::vio::cv_types::IMUMeasurements &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ReturnOrThrow<cv3d::kit::concurrency::OptionalReturn<std::vector<std::shared_ptr<const cv3d::vio::cv_types::JasperPointCloud>>>, cv3d::vio::frame_downsample_node_group::JasperFrameSelectorError> (const std::shared_ptr<const cv3d::vio::cv_types::JasperPointCloud> &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ReturnOrThrow<cv3d::kit::concurrency::OptionalReturn<std::vector<std::shared_ptr<const cv3d::vio::cv_types::JasperPointCloud>>>, cv3d::vio::frame_downsample_node_group::JasperFrameSelectorError> (double)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ReturnOrThrow<cv3d::vio::cv_types::ImageProcessingSample, cv3d::vio::frame_downsample_node_group::FrameDownsamplerError> (const cv3d::vio::cv_types::ImageProcessingSample &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::kit::concurrency::ReturnOrThrow<cv3d::vio::feature_detection::NodeCameraStreamFeatures, cv3d::vio::feature_detection_node_group::FeatureDetectionError> (const cv3d::vio::cv_types::ImageProcessingSample &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::batch_least_squares::MetricName::kIMUDisagreesWithVIOMotion]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::capi::AnchorGroup (const cv3d::vio::capi::AnchorGroup &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::cv_types::FrameData<unsigned char> (const cv3d::vio::cv_types::ImageProcessingSample &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::cv_types::FrameData<unsigned char>]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::cv_types::FrameRateConfiguration (const cv3d::vio::multicamera_node_group::CalibrationAndFrameRateRequest &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::cv_types::FrameRateConfiguration]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::cv_types::GyroMeasurement (cv3d::vio::cv_types::GyroMeasurement)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::cv_types::GyroMeasurement]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::cv_types::JasperPointCloud]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::feature_detection::NodeCameraStreamFeatures]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::feature_detection::NodeCameraSystemFeatures]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::feature_detection_node_group::FeatureDetectionError]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::frame_downsample_node_group::FrameDownsamplerError]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::frame_downsample_node_group::JasperFrameSelectorError (const cv3d::vio::frame_downsample_node_group::JasperFrameSelectorError &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::frame_downsample_node_group::JasperFrameSelectorError]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::multicamera_node_group::BundleCreationStatus (std::tuple<std::optional<cv3d::vio::feature_detection::NodeCameraSystemFeatures>, cv3d::vio::multicamera_node_group::BundleCreationStatus>)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::multicamera_node_group::BundleCreationStatus]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::multicamera_node_group::CalibrationAndFrameRateRequest (const std::shared_ptr<cv3d::vio::metadata::VIOPoseMetadata> &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::multicamera_node_group::CalibrationAndFrameRateRequest]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::slam_engine_node_group::DataVerificationResult (const std::vector<cv3d::vio::data_verification::DataVerificationStatus> &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::user_anchor_node_group::AnchorID (const cv3d::vio::user_anchor_node_group::AnchorID &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::user_anchor_node_group::DeletedGroups (const cv3d::vio::capi::AnchorGroup &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::user_anchor_node_group::DeletedGroups (const cv3d::vio::user_anchor_node_group::DeletedGroups &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::user_anchor_node_group::RequestAnchorGroups (const cv3d::vio::capi::AnchorGroup &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::user_anchor_node_group::RequestAnchorGroups (const cv3d::vio::user_anchor_node_group::RequestAnchorGroups &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = cv3d::vio::user_anchor_node_group::UserAnchorLoadedBundle (const cv3d::vio::user_anchor_node_group::UserAnchorLoadedBundle &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = double (cv3d::vio::feature_detection::NodeCameraSystemFeatures)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = std::optional<cv3d::vio::feature_detection::NodeCameraSystemFeatures>]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = std::shared_ptr<const cv3d::vio::user_anchor_node_group::MetadataWithCMAnchors> (const std::shared_ptr<const cv3d::vio::odometry_engine::SLAMMetadata> &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = std::tuple<std::optional<cv3d::vio::feature_detection::NodeCameraSystemFeatures>, cv3d::vio::multicamera_node_group::BundleCreationStatus> (const cv3d::vio::feature_detection::NodeCameraStreamFeatures &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = std::tuple<std::optional<cv3d::vio::feature_detection::NodeCameraSystemFeatures>, cv3d::vio::multicamera_node_group::BundleCreationStatus>]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = std::variant<cv3d::vio::frame_downsample_node_group::FrameDownsamplerError, cv3d::vio::frame_downsample_node_group::JasperFrameSelectorError, cv3d::vio::feature_detection_node_group::FeatureDetectionError> (cv3d::vio::feature_detection_node_group::FeatureDetectionError)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = std::variant<cv3d::vio::frame_downsample_node_group::FrameDownsamplerError, cv3d::vio::frame_downsample_node_group::JasperFrameSelectorError, cv3d::vio::feature_detection_node_group::FeatureDetectionError> (cv3d::vio::frame_downsample_node_group::FrameDownsamplerError)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = std::variant<cv3d::vio::frame_downsample_node_group::FrameDownsamplerError, cv3d::vio::frame_downsample_node_group::JasperFrameSelectorError, cv3d::vio::feature_detection_node_group::FeatureDetectionError> (cv3d::vio::frame_downsample_node_group::JasperFrameSelectorError)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = std::variant<cv3d::vio::frame_downsample_node_group::FrameDownsamplerError, cv3d::vio::frame_downsample_node_group::JasperFrameSelectorError, cv3d::vio::feature_detection_node_group::FeatureDetectionError>]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = std::vector<cv3d::vio::data_verification::DataVerificationStatus> (cv3d::vio::slam_engine_node_group::DataVerificationResult)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = std::vector<std::shared_ptr<const cv3d::vio::cv_types::JasperPointCloud>> (const std::vector<std::shared_ptr<const cv3d::vio::cv_types::JasperPointCloud>> &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = void (const cv3d::vio::cv_types::GyroMeasurement &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = void (const cv3d::vio::frame_downsample_node_group::JasperFrameSelectorEnableInfo &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = void (const cv3d::vio::multicamera_node_group::CalibrationAndFrameRateRequest &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = void (const std::shared_ptr<cv3d::vio::cv_types::JasperPointCloud> &)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = void (cv3d::vio::cv_types::FeatureFilterInputs)]"
- "static std::string cv3d::esn::TypeNameHelpers::PrettyArgName() [T = void (cv3d::vio::cv_types::FrameRateConfiguration)]"
- "static_cast<size_t>(config.fine_height) >> octave >= kernel_size() && \"Too many octaves specified\""
- "static_cast<size_t>(config.fine_width) >> octave >= kernel_size() && \"Too many octaves specified\""
- "static_cast<size_t>(image_width) >= kImageChunkSize + kMarginWidth * 2 && \"Image width needs to be no less than kImageChunkSize + kMarginWidth * 2\""
- "status && \"Tried to insert an item with ID < last that was not present\""
- "std::fabs(feature.distance - distance_check) < 1e-6 && \"distances equal\""
- "std::fabs(vio::math::L2Norm3(anchor_direcrion.data()) - 1) <= 1e-6 && \"anchor direction should be normalized to 1\""
- "std::fabs(vio::math::L2Norm3(src_anchor_direction.data()) - 1) <= 1e-6 && std::fabs(vio::math::L2Norm3(end_anchor_direction.data()) - 1) <= 1e-6 && \"anchor direction should be normalized to 1\""
- "std::find(permutation_matrix.begin(), permutation_matrix.end(), value) == permutation_matrix.end() && \"Duplicate values found in permutation sequence: not a permutation.\""
- "std::isfinite(minimum_half_FOV_deg) && \"Invalid lens FOV\""
- "std::max(std::fabs(calibration_data_camera_to_imu_position[0]), std::max(std::fabs(calibration_data_camera_to_imu_position[1]), std::fabs(calibration_data_camera_to_imu_position[2]))) < 0.3 && \"Camera to IMU translation larger than device dimensions?\""
- "stereo_camera_iter != camera_sensor_models.end() && \"There must be a stereo camera for Vision Pose Tracker\""
- "strategy.session_criteria() == AnchorStrategy::SessionCriteria::kGivenSession && \"Only support given session!\""
- "stream_id < 2 && \"Only stream ID 0 and 1 are supported.\""
- "stream_id <= 0xffff && \"Stream ID cannot exceeds 16 bits\""
- "stream_id == 0 && \"Incorrect stream id\""
- "stream_index < cur_descriptors_.size() && \"Stream index out of range\""
- "stream_index <= cv_types::CameraAllocationInfo::kMaxNumberOfStreams && \"Exceed maximum number of streams\""
- "strength_image.data() != nullptr && \"Uninitialized image data pointer\""
- "strength_image.height() != 0 && \"Uninitialized image height\""
- "strength_image.width() != 0 && \"Uninitialized image width\""
- "strength_image.widthStep() != 0 && \"Uninitialized image widthStep\""
- "submap && \"Invalid submap request\""
- "success && \"Fail to add the frame\""
- "sz >= cv_types::InertialState::kDof && \"prior size empty!\""
- "this->GetOldestStateAccumulatedPoseAndCov(window_will_slide_in_next_iteration).state_id0 == new_base_state_id && \"inconsistent accumulated state_ID\""
- "this->HasOriginAnchor() && \"Fail to add the origin anchor because no regular keyframe\""
- "this->IsCameraIDAlignedAsIndex() && \"camera_descriptor_stores's camera id is not aligned as index\""
- "this->IsWeakState(target_weak_state_id) && \"State must be weak\""
- "this->VIOVFusion() == nullptr || !this->VIOVFusion()->IsInitialized()"
- "this->VisionOnlyVFusion() == nullptr || !this->VisionOnlyVFusion()->IsInitialized()"
- "this->config_.mapping_manager_config.enable_submapping && \"Pause mapping module only supports submapping mode\""
- "this->depth_sensor_model_ && \"Depth sensor mode is not set!\""
- "this->eigen_threshold(i) >= this->eigen_threshold(i - 1) && \"The eigenvalue thresholds should be increasing order.\""
- "this->map() && \"Mapping manager is not instantiated\""
- "this->map_->config().enable_inter_session_regular_states_check && \"In the new pose-graph, the two states have to be regular to support submapping\""
- "this->opt_request_ && \"State correction request is not set\""
- "this->opt_request_->query_state_id == reloc_info.query_image_id.view.key() && \"Query state ID not compatible\""
- "this->parameters().ba_config.use_direct_oldest_pose_marginalization && \"Non-direct marginalization should not be used with LPS. Please disable.\""
- "this->pose_and_cov_accumulator()"
- "this->slam_relocalization_ && \"External Map Info must have a relocalization module\""
- "this->vfusion() == this->VisionOnlyVFusion()"
- "this->vfusion()->IsUsingIMU()"
- "this->viobadata_ref_.state_set && this->viobadata_ref_.state_set->sensor_calibration_set() && \"Error the sensor_calibration_set is not set\""
- "this->viobadata_ref_.state_to_imu_sample_time_offset && \"Error the timeoffset variable is not set\""
- "this_->config().is_visual_slam_enabled || !keyframe_candidate_info.opt_num_triangulated_points_for_pnp_ransac.has_value() && \"This info should be invalid for regular SLAM candidate keyframes\""
- "this_->config().is_visual_slam_enabled || !this_->config() .vfusion_config.initialization_config .correct_gravity_direction_using_stationary_init && \"Gravity correction must not be used in VIO\""
- "time_diffs.back() >= 0. && \"IMU timestamps not non-decreasing\""
- "time_step >= 0 && \"Time step error must be non-negative\""
- "time_to_load_map"
- "time_to_update_anchor"
- "timestamp > *latest_imu_timestamp_ && \"The timestamp of imu measurements must increase monotonically\""
- "timestamp > *latest_pose_timestamp_ && \"The timestamp of the new vio pose must increase monotonically\""
- "total_size < std::numeric_limits<uint32_t>::max() && \"Given data block is too big to be represented by uint32_t indexed ArrayView\""
- "total_time_on"
- "track && \"No track for feature when pruning\""
- "track->getStructure() && \"The track does not have a structure!\""
- "track->getStructure() && \"The track does not have the structure\""
- "track.getStructure() && track.getStructure()->isSetup() && \"track does not has structure or is not setup\""
- "track.getStructure()->isSetup() && \"track does not has structure or is not setup\""
- "track.getStructure()->src_point.isSetup() && track.getStructure()->src_point.isSetup() && \"both end points should be valid\""
- "track_iter != keyframe_cm.tracks.end() && \"Fail to find track sample!\""
- "track_iter != this->viobadata_ref_.front_end_tracks.end() && \"Failed to find the track in the the front-end tracks.\""
- "track_iter != track_list->end() && \"We should always be able to find a track\""
- "track_latest_state_with_obs_iter != this->viobadata_ref_.state_set->end() && \"The state associated to the latest observation should be in state set.\""
- "track_ptr != this->viobadata_ref_.front_end_tracks.end() && \"Failed to find the track that corresponds to the SLAM landmark variable.\""
- "tracks[last_track_used].size() > 0 && \"Attempting to backfill an empty track.\""
- "transfer_succeeded && \"PixelTransferSession failed\""
- "transition_config.hysteresis_time_window_in_motion >= 0.0 && \"hysteresis_time_window_in_motion >= 0\""
- "transition_window >= 0 && transition_time_left >= 0 && \"Transition window/time left must be non-negative\""
- "update.user_session == data.map_data.user_session && \"Submap ID mismatch during MapUpdateSample move.\""
- "user.t_map_keyframe_to_anchor && \"Must have t_map_keyframe_to_anchor set\""
- "user_slam_anchor.R_map_keyframe_to_anchor_row_major"
- "user_slam_anchor.t_map_keyframe_to_anchor"
- "v <= 65280 && \"overflow detected resulting in invalid result\""
- "validate() && \"Must have valid lens model to compute frustum extrema.\""
- "validate_reloc_result && \"validate_reloc_result is not set\""
- "value < kBitsPerFreakDescriptor && \"Unexpected value in permutation matrix\""
- "var_id_to_state_id_iter1 != var_id_to_state_id_map.end() && \"Cannot find node_id1\""
- "var_id_to_state_id_iter2 != var_id_to_state_id_map.end() && \"Cannot find node_id2\""
- "var_iter != linear_system_.template endVariable<IntrinsicsCalibVariable<Float>>() && \"invalid intrinsics calib iterator.\""
- "var_iter != linear_system_.template endVariable<VIOExtrinsicsVariable<Float>>() && \"invalid extrinsics calib iterator.\""
- "var_iter != ls_->endVariable<VIO4DoFDeltaPoseVariable<double>>() && \"Variable missing\""
- "var_iter->second.state.isMarginalized() || var_iter->second.state.isRemoved() && \"SLAM variables not associated to an entry in front-end tracks should \" \"have been marked as marginalized or removed.\""
- "verybad"
- "verygood"
- "vfusion()->ReadyForRelocalization(true ) && \"Failed to grvaity-align the front-end in moving slam\""
- "vfusion.HasProcessedFirstWindow() && \"VFusion has not processed the window\""
- "vfusion_new.ReadyForRelocalization(true ) && \"Failed to correct VIO-position\""
- "vio_frame && \"Error cannot find the vio_frame\""
- "vio_frame->lens_model_ && \"VIO Frame Lens is not set!\""
- "vio_frame_iter != dst_map_data.viodatabase()->end() && \"Failed to find vio frame in self map\""
- "vio_frame_iter != ext_map_iter->second.data()->viodatabase()->end() && \"VIOFrame does not exist!\""
- "vio_frame_iter != this->const_viodatabase()->end() && \"Failed to find vio frame\""
- "vio_frame_iter->get()->is_weak_frame() && \"Frame should be weak\""
- "vio_frame_was_created && \"Fail to create a vioframe\""
- "vio_metadata->pose_metadata->pose_prediction_info_metadata.slam_mode != cv_types::SLAMMode::kUnknown && \"SLAM instance must be in invalid mode\""
- "vio_pose_ref && \"vio_pose_ref does not exist!\""
- "vio_state && \"Fail to locate the state!\""
- "vio_state_ptr && \"VIO state not found\""
- "vio_stateset.RemoveStateAndPoseRef(iter->first)"
- "viobadata_time_offset && \"Error the timeoffset variable is not set\""
- "viodatabase()->inertial_measurements() && \"No imu measurmeent available\""
- "viostate_factor_ids_.find(curr_state_id.key()) == viostate_factor_ids_.end() && \"[VIOBABase] : The requested IMU State's Factors already exists.\""
- "void boost::rational<long long>::normalize() [T = long long]"
- "width > 0 && \"\""
- "widthStep >= minimum_width_step && \"widthStep must be at least as big as minimum_width_step.\""
- "work_group_ != nullptr && \"Failed to create workgroup.\""
- "worker && \"Callable must be valid\""
- "x_cur.size() == x_ref.size() && \"Reference and current points must be of the same size\""
- "x_ref_sec.size() == x_ref.size() && \"Primary and secondary reference points must be of the same size\""

```
