## libANGLE-shared.dylib

> `/System/Library/PrivateFrameworks/WebCore.framework/Frameworks/libANGLE-shared.dylib`

```diff

-620.2.4.10.7
-  __TEXT.__text: 0x2674b4
-  __TEXT.__auth_stubs: 0xe10
-  __TEXT.__const: 0x87db0
-  __TEXT.__cstring: 0x47e23
-  __TEXT.__gcc_except_tab: 0x2e60
+621.1.13.10.4
+  __TEXT.__text: 0x25c47c
+  __TEXT.__auth_stubs: 0xe70
+  __TEXT.__const: 0x8fbf8
+  __TEXT.__cstring: 0x38115
+  __TEXT.__gcc_except_tab: 0x2d2c
   __TEXT.__oslogstring: 0xf
-  __TEXT.__unwind_info: 0x1968
+  __TEXT.__unwind_info: 0x1868
   __TEXT.__objc_classname: 0x1
-  __TEXT.__objc_methname: 0x17fd
-  __TEXT.__objc_stubs: 0x1f00
-  __DATA_CONST.__got: 0x138
-  __DATA_CONST.__const: 0x17228
+  __TEXT.__objc_methname: 0x1825
+  __TEXT.__objc_stubs: 0x1f20
+  __DATA_CONST.__got: 0x130
+  __DATA_CONST.__const: 0x14c70
   __DATA_CONST.__objc_imageinfo: 0x8
-  __DATA_CONST.__objc_selrefs: 0x7c0
-  __AUTH_CONST.__auth_got: 0x718
+  __DATA_CONST.__objc_selrefs: 0x7c8
+  __AUTH_CONST.__auth_got: 0x748
   __AUTH_CONST.__auth_ptr: 0x8
-  __AUTH_CONST.__const: 0x16b78
-  __AUTH_CONST.__cfstring: 0x9e0
-  __DATA.__data: 0x2ee18
-  __DATA.__common: 0x370
-  __DATA.__bss: 0x4
-  __DATA_DIRTY.__data: 0xfd8
-  __DATA_DIRTY.__common: 0x4a8
-  __DATA_DIRTY.__bss: 0x288
+  __AUTH_CONST.__const: 0x168a0
+  __AUTH_CONST.__cfstring: 0x9c0
+  __DATA.__data: 0x2b6c8
+  __DATA.__bss: 0xc
+  __DATA.__common: 0x3c0
+  __DATA_DIRTY.__data: 0xf10
+  __DATA_DIRTY.__bss: 0x278
+  __DATA_DIRTY.__common: 0x4f8
   - /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation
   - /System/Library/Frameworks/CoreGraphics.framework/CoreGraphics
   - /System/Library/Frameworks/Foundation.framework/Foundation

   - /usr/lib/libc++.1.dylib
   - /usr/lib/libobjc.A.dylib
   - /usr/lib/libz.1.dylib
-  Functions: 9526
-  Symbols:   9899
-  CStrings:  8073
+  Functions: 9144
+  Symbols:   9953
+  CStrings:  6604
 
Symbols:
+ _EGL_LockVulkanQueueANGLE
+ _EGL_QuerySupportedCompressionRatesEXT
+ _EGL_UnlockVulkanQueueANGLE
+ _GL_BlendEquationOES
+ _GL_BlobCacheCallbacksANGLE
+ _GL_GetPointervANGLE
+ _GL_TexStorageAttribs2DEXT
+ _GL_TexStorageAttribs3DEXT
+ _ceilf
+ _dispatch_get_global_queue
+ _floorf
+ _ldexpf
+ _objc_retain_x27
+ _roundf
+ _sqrtf
+ _truncf
- __dispatch_main_q
- _dispatch_release
- _objc_retain_x26
CStrings:
+ "\n#define ANGLE_SAMPLE_COMPARE_GRADIENT_INDEX   0\n#define ANGLE_RASTERIZATION_DISCARD_INDEX     1\n#define ANGLE_MULTISAMPLED_RENDERING_INDEX    2\n#define ANGLE_DEPTH_WRITE_ENABLED_INDEX       3\n#define ANGLE_EMULATE_ALPHA_TO_COVERAGE_INDEX 4\n#define ANGLE_WRITE_HELPER_SAMPLE_MASK_INDEX  5\n\nconstant bool ANGLEUseSampleCompareGradient [[function_constant(ANGLE_SAMPLE_COMPARE_GRADIENT_INDEX)]];\nconstant bool ANGLERasterizerDisabled       [[function_constant(ANGLE_RASTERIZATION_DISCARD_INDEX)]];\nconstant bool ANGLEMultisampledRendering    [[function_constant(ANGLE_MULTISAMPLED_RENDERING_INDEX)]];\nconstant bool ANGLEDepthWriteEnabled        [[function_constant(ANGLE_DEPTH_WRITE_ENABLED_INDEX)]];\nconstant bool ANGLEEmulateAlphaToCoverage   [[function_constant(ANGLE_EMULATE_ALPHA_TO_COVERAGE_INDEX)]];\nconstant bool ANGLEWriteHelperSampleMask    [[function_constant(ANGLE_WRITE_HELPER_SAMPLE_MASK_INDEX)]];\n\n#define ANGLE_ALPHA0\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float3 const coord)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, coord.z);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float3 const coord,\n    float const bias)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, coord.z, metal::bias(bias));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::depth2d_array<float>> &env,\n    metal::float4 const coord)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::depth2d_array<float>> &env,\n    metal::float4 const coord,\n    float const bias)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::bias(bias));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::depthcube<float>> &env,\n    metal::float4 const coord)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xyz, coord.w);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::depthcube<float>> &env,\n    metal::float4 const coord,\n    float const bias)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xyz, coord.w, metal::bias(bias));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture2D(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float2 const coord)\n{\n    return env.texture->sample(*env.sampler, coord);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture2D(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float2 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord, metal::bias(bias));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DGradEXT(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float2 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord, metal::gradient2d(dPdx, dPdy));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DLod(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float2 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord, metal::level(level));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProj(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float3 const coord)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z);\n}\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProj(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float4 const coord)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProj(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float3 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z, metal::bias(bias));\n}\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProj(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float4 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w, metal::bias(bias));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjGradEXT(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z, metal::gradient2d(dPdx, dPdy));\n}\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjGradEXT(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjLod(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float3 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z, metal::level(level));\n}\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjLod(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float4 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w, metal::level(level));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture3D(\n    thread ANGLE_TextureEnv<metal::texture3d<float>> &env,\n    metal::float3 const coord)\n{\n    return env.texture->sample(*env.sampler, coord);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture3D(\n    thread ANGLE_TextureEnv<metal::texture3d<float>> &env,\n    metal::float3 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord, metal::bias(bias));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture3DLod(\n    thread ANGLE_TextureEnv<metal::texture3d<float>> &env,\n    metal::float3 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord, metal::level(level));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture3DProj(\n    thread ANGLE_TextureEnv<metal::texture3d<float>> &env,\n    metal::float4 const coord)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture3DProj(\n    thread ANGLE_TextureEnv<metal::texture3d<float>> &env,\n    metal::float4 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w, metal::bias(bias));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture3DProjLod(\n    thread ANGLE_TextureEnv<metal::texture3d<float>> &env,\n    metal::float4 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w, metal::level(level));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureCube(\n    thread ANGLE_TextureEnv<metal::texturecube<float>> &env,\n    metal::float3 const coord)\n{\n    return env.texture->sample(*env.sampler, coord);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureCube(\n    thread ANGLE_TextureEnv<metal::texturecube<float>> &env,\n    metal::float3 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord, metal::bias(bias));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureCubeGradEXT(\n    thread ANGLE_TextureEnv<metal::texturecube<float>> &env,\n    metal::float3 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord, metal::gradientcube(dPdx, dPdy));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureCubeLod(\n    thread ANGLE_TextureEnv<metal::texturecube<float>> &env,\n    metal::float3 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord, metal::level(level));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return env.texture->sample_compare(*env.sampler, coord.xy, coord.z, metal::gradient2d(dPdx, dPdy));\n    }\n    else\n    {\n        const float2 dims = float2(env.texture->get_width(0), env.texture->get_height(0));\n        const float lod = 0.5 * metal::log2(metal::max(metal::length_squared(dPdx * dims), metal::length_squared(dPdy * dims)));\n        return env.texture->sample_compare(*env.sampler, coord.xy, coord.z, metal::level(lod));\n    }\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad(\n    thread ANGLE_TextureEnv<metal::depth2d_array<float>> &env,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return env.texture->sample_compare(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::gradient2d(dPdx, dPdy));\n    }\n    else\n    {\n        const float2 dims = float2(env.texture->get_width(0), env.texture->get_height(0));\n        const float lod = 0.5 * metal::log2(metal::max(metal::length_squared(dPdx * dims), metal::length_squared(dPdy * dims)));\n        return env.texture->sample_compare(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::level(lod));\n    }\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad(\n    thread ANGLE_TextureEnv<metal::depthcube<float>> &env,\n    metal::float4 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return env.texture->sample_compare(*env.sampler, coord.xyz, coord.w, metal::gradientcube(dPdx, dPdy));\n    }\n    else\n    {\n        const float3 coord_abs = metal::abs(coord.xyz);\n        const bool z_major = coord_abs.z >= metal::max(coord_abs.x, coord_abs.y);\n        const bool y_major = coord_abs.y >= metal::max(coord_abs.x, coord_abs.z);\n        const float3 Q = z_major ? coord.xyz : (y_major ? coord.xzy : coord.yzx);\n        const float3 dQdx = z_major ? dPdx : (y_major ? dPdx.xzy : dPdx.yzx);\n        const float3 dQdy = z_major ? dPdy : (y_major ? dPdy.xzy : dPdy.yzx);\n        const float4 d = (float4(dQdx.xy, dQdy.xy) - (Q.xy / Q.z).xyxy * float4(dQdx.zz, dQdy.zz)) / Q.z;\n        const float dim = float(env.texture->get_width(0));\n        const float lod = -1.0 + 0.5 * metal::log2(dim * dim * metal::max(metal::length_squared(d.xy), metal::length_squared(d.zw)));\n        return env.texture->sample_compare(*env.sampler, coord.xyz, coord.w, metal::level(lod));\n    }\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    metal::int2 const offset)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return env.texture->sample_compare(*env.sampler, coord.xy, coord.z, metal::gradient2d(dPdx, dPdy), offset);\n    }\n    else\n    {\n        const float2 dims = float2(env.texture->get_width(0), env.texture->get_height(0));\n        const float lod = 0.5 * metal::log2(metal::max(metal::length_squared(dPdx * dims), metal::length_squared(dPdy * dims)));\n        return env.texture->sample_compare(*env.sampler, coord.xy, coord.z, metal::level(lod), offset);\n    }\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset(\n    thread ANGLE_TextureEnv<metal::depth2d_array<float>> &env,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    metal::int2 const offset)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return env.texture->sample_compare(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::gradient2d(dPdx, dPdy), offset);\n    }\n    else\n    {\n        const float2 dims = float2(env.texture->get_width(0), env.texture->get_height(0));\n        const float lod = 0.5 * metal::log2(metal::max(metal::length_squared(dPdx * dims), metal::length_squared(dPdy * dims)));\n        return env.texture->sample_compare(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::level(lod), offset);\n    }\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float3 const coord,\n    float const level)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, coord.z, metal::level(level));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod(\n    thread ANGLE_TextureEnv<metal::depth2d_array<float>> &env,\n    metal::float4 const coord,\n    float const level)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::level(level));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod(\n    thread ANGLE_TextureEnv<metal::depthcube<float>> &env,\n    metal::float4 const coord,\n    float const level)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xyz, coord.w, metal::level(level));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float3 const coord,\n    float const level,\n    int2 const offset)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, coord.z, metal::level(level), offset);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset(\n    thread ANGLE_TextureEnv<metal::depth2d_array<float>> &env,\n    metal::float4 const coord,\n    float const level,\n    metal::int2 const offset)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::level(level), offset);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float3 const coord,\n    metal::int2 const offset)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, coord.z, offset);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float3 const coord,\n    metal::int2 const offset,\n    float const bias)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, coord.z, metal::bias(bias), offset);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset(\n    thread ANGLE_TextureEnv<metal::depth2d_array<float>> &env,\n    metal::float4 const coord,\n    metal::int2 const offset)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, offset);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset(\n    thread ANGLE_TextureEnv<metal::depth2d_array<float>> &env,\n    metal::float4 const coord,\n    metal::int2 const offset,\n    float const bias)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::bias(bias), offset);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float4 const coord)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy/coord.w, coord.z/coord.w);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float4 const coord,\n    float const bias)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy/coord.w, coord.z/coord.w, metal::bias(bias));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return env.texture->sample_compare(*env.sampler, coord.xy/coord.w, coord.z/coord.w, metal::gradient2d(dPdx, dPdy));\n    }\n    else\n    {\n        const float2 dims = float2(env.texture->get_width(0), env.texture->get_height(0));\n        const float lod = 0.5 * metal::log2(metal::max(metal::length_squared(dPdx * dims), metal::length_squared(dPdy * dims)));\n        return env.texture->sample_compare(*env.sampler, coord.xy/coord.w, coord.z/coord.w, metal::level(lod));\n    }\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    int2 const offset)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return env.texture->sample_compare(*env.sampler, coord.xy/coord.w, coord.z/coord.w, metal::gradient2d(dPdx, dPdy), offset);\n    }\n    else\n    {\n        const float2 dims = float2(env.texture->get_width(0), env.texture->get_height(0));\n        const float lod = 0.5 * metal::log2(metal::max(metal::length_squared(dPdx * dims), metal::length_squared(dPdy * dims)));\n        return env.texture->sample_compare(*env.sampler, coord.xy/coord.w, coord.z/coord.w, metal::level(lod), offset);\n    }\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float4 const coord,\n    float const level)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy/coord.w, coord.z/coord.w, metal::level(level));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float4 const coord,\n    float const level,\n    int2 const offset)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy/coord.w, coord.z/coord.w, metal::level(level), offset);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float4 const coord,\n    int2 const offset)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy/coord.w, coord.z/coord.w, offset);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float4 const coord,\n    int2 const offset,\n    float const bias)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy/coord.w, coord.z/coord.w, metal::bias(bias), offset);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureSize(\n    thread ANGLE_TextureEnv<metal::depth2d_array<float>> &env,\n    int const level)\n{\n    return int3(env.texture->get_width(uint32_t(level)), env.texture->get_height(uint32_t(level)), env.texture->get_array_size());\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetch(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::int2 const coord,\n    int const level)\n{\n    return env.texture->read(uint2(coord), uint32_t(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetch(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    metal::int3 const coord,\n    int const level)\n{\n    return env.texture->read(uint2(coord.xy), uint32_t(coord.z), uint32_t(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetch(\n    thread ANGLE_TextureEnv<metal::texture2d_ms<T>> &env,\n    metal::int2 const coord,\n    int const sample)\n{\n    return env.texture->read(uint2(coord), uint32_t(sample));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetch(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::int3 const coord,\n    int const level)\n{\n    return env.texture->read(uint3(coord), uint32_t(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::int2 const coord,\n    int const level,\n    metal::int2 const offset)\n{\n    return env.texture->read(uint2(coord + offset), uint32_t(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    metal::int3 const coord,\n    int const level,\n    metal::int2 const offset)\n{\n    return env.texture->read(uint2(coord.xy + offset), uint32_t(coord.z), uint32_t(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::int3 const coord,\n    int const level,\n    metal::int3 const offset)\n{\n    return env.texture->read(uint3(coord + offset), uint32_t(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float2 const coord)\n{\n    return env.texture->sample(*env.sampler, coord);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float2 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord, metal::bias(bias));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    metal::float3 const coord)\n{\n    return env.texture->sample(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    metal::float3 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::bias(bias));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float3 const coord)\n{\n    return env.texture->sample(*env.sampler, coord);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float3 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord, metal::bias(bias));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::texturecube<T>> &env,\n    metal::float3 const coord)\n{\n    return env.texture->sample(*env.sampler, coord);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::texturecube<T>> &env,\n    metal::float3 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord, metal::bias(bias));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float2 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord, metal::gradient2d(dPdx, dPdy));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float3 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord, metal::gradient3d(dPdx, dPdy));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad(\n    thread ANGLE_TextureEnv<metal::texturecube<T>> &env,\n    metal::float3 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord, metal::gradientcube(dPdx, dPdy));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float2 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord, metal::gradient2d(dPdx, dPdy), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    metal::int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float3 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy,\n    int3 const offset)\n{\n    return env.texture->sample(*env.sampler, coord, metal::gradient3d(dPdx, dPdy), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float2 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord, metal::level(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    metal::float3 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::level(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float3 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord, metal::level(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod(\n    thread ANGLE_TextureEnv<metal::texturecube<T>> &env,\n    metal::float3 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord, metal::level(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float2 const coord,\n    float const level,\n    metal::int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord, metal::level(level), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    metal::float3 const coord,\n    float const level,\n    metal::int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::level(level), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float3 const coord,\n    float const level,\n    metal::int3 const offset)\n{\n    return env.texture->sample(*env.sampler, coord, metal::level(level), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float2 const coord,\n    metal::int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord, offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float2 const coord,\n    metal::int2 const offset,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord, metal::bias(bias), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    metal::float3 const coord,\n    metal::int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    metal::float3 const coord,\n    metal::int2 const offset,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::bias(bias), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float3 const coord,\n    metal::int3 const offset)\n{\n    return env.texture->sample(*env.sampler, coord, offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float3 const coord,\n    metal::int3 const offset,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord, metal::bias(bias), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float3 const coord)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float3 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z, metal::bias(bias));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float4 const coord)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float4 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w, metal::bias(bias));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float4 const coord)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float4 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w, metal::bias(bias));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z, metal::gradient2d(dPdx, dPdy));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float4 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w, metal::gradient3d(dPdx, dPdy));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z, metal::gradient2d(dPdx, dPdy), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float4 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy,\n    int3 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w, metal::gradient3d(dPdx, dPdy), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float3 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z, metal::level(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float4 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w, metal::level(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float4 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w, metal::level(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float3 const coord,\n    float const level,\n    int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z, metal::level(level), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float4 const coord,\n    float const level,\n    int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w, metal::level(level), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float4 const coord,\n    float const level,\n    int3 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w, metal::level(level), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float3 const coord,\n    int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z, offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float3 const coord,\n    int2 const offset,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z, metal::bias(bias), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float4 const coord,\n    int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w, offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float4 const coord,\n    int2 const offset,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w, metal::bias(bias), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float4 const coord,\n    int3 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w, offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float4 const coord,\n    int3 const offset,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w, metal::bias(bias), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureSize(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    int const level)\n{\n    return int3(env.texture->get_width(uint32_t(level)), env.texture->get_height(uint32_t(level)), env.texture->get_array_size());\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureSize(\n    thread ANGLE_TextureEnv<metal::texture2d_ms<T>> &env)\n{\n    return int2(env.texture->get_width(), env.texture->get_height());\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureSize(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    int const level)\n{\n    return int3(env.texture->get_width(uint32_t(level)), env.texture->get_height(uint32_t(level)), env.texture->get_depth(uint32_t(level)));\n}\n\n"
+ "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureSize(\n    thread ANGLE_TextureEnv<Texture> &env,\n    int const level)\n{\n    return int2(env.texture->get_width(uint32_t(level)), env.texture->get_height(uint32_t(level)));\n}\n\n"
+ "%lld"
+ "%s invalid attribute: 0x%X"
+ ".\nTranslated source:\n"
+ "2.1.24795 git hash: 91a559c9b102"
+ "4fb8e67e2e89e493734c8ae3e75a4a1c"
+ ":ARM_shader_framebuffer_fetch_depth_stencil:"
+ ":EXT_texture_query_lod:"
+ ":EXT_texture_shadow_lod:"
+ "ANGLE_GL_RENDERER"
+ "ANGLE_GL_VENDOR"
+ "ANGLE_GL_VERSION"
+ "ARM_shader_framebuffer_fetch_depth_stencil"
+ "Attribute EGL_CONTEXT_MEMORY_USAGE_ANGLE requires EGL_ANGLE_memory_usage_report."
+ "Attribute EGL_SURFACE_COMPRESSION_EXT requires extension EGL_EXT_surface_compression."
+ "Call a function"
+ "Completed MTLCommandBuffer failed, and error is "
+ "Constant union"
+ "EGL_ANDROID_front_buffer_auto_refresh"
+ "EGL_ANGLE_device_vulkan not supported"
+ "EGL_ANGLE_memory_usage_report"
+ "EGL_ANGLE_platform_angle_vulkan_device_uuid"
+ "EGL_CONFIG_CAVEAT invalid attribute: 0x%X"
+ "EGL_CONFORMANT"
+ "EGL_EXT_surface_compression"
+ "EGL_EXT_surface_compression not supported"
+ "EGL_FRONT_BUFFER_AUTO_REFRESH_ANDROID cannot be used without EGL_ANDROID_front_buffer_auto_refresh support."
+ "EGL_PLATFORM_ANGLE_VULKAN_DEVICE_UUID, EGL_PLATFORM_ANGLE_VULKAN_DRIVER_UUID and EGL_PLATFORM_ANGLE_VULKAN_DRIVER_ID require a platform type of EGL_PLATFORM_ANGLE_TYPE_VULKAN_ANGLE."
+ "EGL_RENDERABLE_TYPE"
+ "EGL_SURFACE_TYPE invalid attribute: 0x%X"
+ "EXT_texture_query_lod"
+ "EXT_texture_shadow_lod"
+ "Failed to allocate host memory."
+ "Found symbol with empty name"
+ "GL_ANGLE_blob_cache"
+ "GL_ARM_rgba8"
+ "GL_ARM_shader_framebuffer_fetch_depth_stencil"
+ "GL_EXT_EGL_image_storage_compression"
+ "GL_EXT_separate_depth_stencil"
+ "GL_EXT_texture_query_lod"
+ "GL_EXT_texture_shadow_lod"
+ "GL_EXT_texture_storage_compression"
+ "GL_OES_blend_subtract"
+ "GL_OES_required_internalformat"
+ "GL_OES_texture_mirrored_repeat"
+ "Internal error while linking shader. MSL compilation error:\n"
+ "Internal error. Metal error: "
+ "LastFragDepthARM"
+ "LastFragStencilARM"
+ "Offset must not exceed the maximum atomic counter buffer size"
+ "The renderbuffer has been bound to an existing EGL image."
+ "The texture has been bound to an existing EGL image."
+ "Unreachable code."
+ "abs(00C"
+ "abs(10C"
+ "abs(20C"
+ "abs(30C"
+ "all(10E"
+ "all(20E"
+ "all(30E"
+ "any(10E"
+ "any(20E"
+ "any(30E"
+ "areProgrammableSamplePositionsSupported"
+ "atomicAdd(00C00C"
+ "atomicAnd(00C00C"
+ "atomicCompSwap(00C00C00C"
+ "atomicCounter(00F"
+ "atomicCounterDecrement(00F"
+ "atomicCounterIncrement(00F"
+ "atomicExchange(00C00C"
+ "atomicMax(00C00C"
+ "atomicMin(00C00C"
+ "atomicOr(00C00C"
+ "atomicXor(00C00C"
+ "bitCount(00C"
+ "bitCount(10C"
+ "bitCount(20C"
+ "bitCount(30C"
+ "bitfieldExtract(00C00C00C"
+ "bitfieldExtract(00D00C00C"
+ "bitfieldExtract(10C00C00C"
+ "bitfieldExtract(10D00C00C"
+ "bitfieldExtract(20C00C00C"
+ "bitfieldExtract(20D00C00C"
+ "bitfieldExtract(30C00C00C"
+ "bitfieldExtract(30D00C00C"
+ "bitfieldInsert(00C00C00C00C"
+ "bitfieldInsert(00D00D00C00C"
+ "bitfieldInsert(10C10C00C00C"
+ "bitfieldInsert(10D10D00C00C"
+ "bitfieldInsert(20C20C00C00C"
+ "bitfieldInsert(20D20D00C00C"
+ "bitfieldInsert(30C30C00C00C"
+ "bitfieldInsert(30D30D00C00C"
+ "bitfieldReverse(00C"
+ "bitfieldReverse(10C"
+ "bitfieldReverse(20C"
+ "bitfieldReverse(30C"
+ "checkCommandBufferError"
+ "clamp(00C00C00C"
+ "clamp(10C00C00C"
+ "clamp(10C10C10C"
+ "clamp(20C00C00C"
+ "clamp(20C20C20C"
+ "clamp(30C00C00C"
+ "clamp(30C30C30C"
+ "eglLockVulkanQueueANGLE"
+ "eglQuerySupportedCompressionRatesEXT"
+ "eglUnlockVulkanQueueANGLE"
+ "equal(10C10C"
+ "equal(20C20C"
+ "equal(30C30C"
+ "expression statement is not allowed for interface blocks"
+ "findLSB(00C"
+ "findLSB(10C"
+ "findLSB(20C"
+ "findLSB(30C"
+ "findMSB(00C"
+ "findMSB(10C"
+ "findMSB(20C"
+ "findMSB(30C"
+ "frexp(00B00C"
+ "frexp(10B10C"
+ "frexp(20B20C"
+ "frexp(30B30C"
+ "glBlendEquationOES"
+ "glBlobCacheCallbacksANGLE"
+ "glGetPointervANGLE"
+ "glTexStorageAttribs2DEXT"
+ "glTexStorageAttribs3DEXT"
+ "gl_InstanceIndex"
+ "gl_LastFragDepthARM"
+ "gl_LastFragDepthARM and gl_LastFragStencilARM cannot be accessed because early_fragment_tests is specified"
+ "gl_LastFragStencilARM"
+ "gl_VertexIndex"
+ "greaterThan(10C10C"
+ "greaterThan(20C20C"
+ "greaterThan(30C30C"
+ "greaterThanEqual(10C10C"
+ "greaterThanEqual(20C20C"
+ "greaterThanEqual(30C30C"
+ "imageAtomicAdd(00q10C00C"
+ "imageAtomicAdd(00q10C00D"
+ "imageAtomicAdd(00r20C00C"
+ "imageAtomicAdd(00r20C00D"
+ "imageAtomicAdd(00s20C00C"
+ "imageAtomicAdd(00s20C00D"
+ "imageAtomicAdd(00t20C00C"
+ "imageAtomicAdd(00t20C00D"
+ "imageAtomicAdd(00u10C00C00C"
+ "imageAtomicAdd(00u10C00C00D"
+ "imageAtomicAdd(00v20C00C00C"
+ "imageAtomicAdd(00v20C00C00D"
+ "imageAtomicAdd(00w20C00C"
+ "imageAtomicAdd(00w20C00D"
+ "imageAtomicAdd(00x10C00C"
+ "imageAtomicAdd(00x10C00D"
+ "imageAtomicAdd(00y00C00C"
+ "imageAtomicAdd(00y00C00D"
+ "imageAtomicAdd(00z10C00C"
+ "imageAtomicAdd(00z10C00D"
+ "imageAtomicAdd(01A20C00C"
+ "imageAtomicAdd(01A20C00D"
+ "imageAtomicAdd(01B20C00C"
+ "imageAtomicAdd(01B20C00D"
+ "imageAtomicAdd(01C20C00C"
+ "imageAtomicAdd(01C20C00D"
+ "imageAtomicAdd(01D10C00C00C"
+ "imageAtomicAdd(01D10C00C00D"
+ "imageAtomicAdd(01E20C00C00C"
+ "imageAtomicAdd(01E20C00C00D"
+ "imageAtomicAdd(01F20C00C"
+ "imageAtomicAdd(01F20C00D"
+ "imageAtomicAdd(01G10C00C"
+ "imageAtomicAdd(01G10C00D"
+ "imageAtomicAdd(01H00C00C"
+ "imageAtomicAdd(01H00C00D"
+ "imageAtomicAdd(01I10C00C"
+ "imageAtomicAdd(01I10C00D"
+ "imageAtomicAdd(01J20C00C"
+ "imageAtomicAdd(01J20C00D"
+ "imageAtomicAdd(01K20C00C"
+ "imageAtomicAdd(01K20C00D"
+ "imageAtomicAdd(01L20C00C"
+ "imageAtomicAdd(01L20C00D"
+ "imageAtomicAdd(01M10C00C00C"
+ "imageAtomicAdd(01M10C00C00D"
+ "imageAtomicAdd(01N20C00C00C"
+ "imageAtomicAdd(01N20C00C00D"
+ "imageAtomicAdd(01O20C00C"
+ "imageAtomicAdd(01O20C00D"
+ "imageAtomicAdd(01P10C00C"
+ "imageAtomicAdd(01P10C00D"
+ "imageAtomicAdd(01Q00C00C"
+ "imageAtomicAdd(01Q00C00D"
+ "imageAtomicAnd(00q10C00C"
+ "imageAtomicAnd(00q10C00D"
+ "imageAtomicAnd(00r20C00C"
+ "imageAtomicAnd(00r20C00D"
+ "imageAtomicAnd(00s20C00C"
+ "imageAtomicAnd(00s20C00D"
+ "imageAtomicAnd(00t20C00C"
+ "imageAtomicAnd(00t20C00D"
+ "imageAtomicAnd(00u10C00C00C"
+ "imageAtomicAnd(00u10C00C00D"
+ "imageAtomicAnd(00v20C00C00C"
+ "imageAtomicAnd(00v20C00C00D"
+ "imageAtomicAnd(00w20C00C"
+ "imageAtomicAnd(00w20C00D"
+ "imageAtomicAnd(00x10C00C"
+ "imageAtomicAnd(00x10C00D"
+ "imageAtomicAnd(00y00C00C"
+ "imageAtomicAnd(00y00C00D"
+ "imageAtomicAnd(00z10C00C"
+ "imageAtomicAnd(00z10C00D"
+ "imageAtomicAnd(01A20C00C"
+ "imageAtomicAnd(01A20C00D"
+ "imageAtomicAnd(01B20C00C"
+ "imageAtomicAnd(01B20C00D"
+ "imageAtomicAnd(01C20C00C"
+ "imageAtomicAnd(01C20C00D"
+ "imageAtomicAnd(01D10C00C00C"
+ "imageAtomicAnd(01D10C00C00D"
+ "imageAtomicAnd(01E20C00C00C"
+ "imageAtomicAnd(01E20C00C00D"
+ "imageAtomicAnd(01F20C00C"
+ "imageAtomicAnd(01F20C00D"
+ "imageAtomicAnd(01G10C00C"
+ "imageAtomicAnd(01G10C00D"
+ "imageAtomicAnd(01H00C00C"
+ "imageAtomicAnd(01H00C00D"
+ "imageAtomicAnd(01I10C00C"
+ "imageAtomicAnd(01I10C00D"
+ "imageAtomicAnd(01J20C00C"
+ "imageAtomicAnd(01J20C00D"
+ "imageAtomicAnd(01K20C00C"
+ "imageAtomicAnd(01K20C00D"
+ "imageAtomicAnd(01L20C00C"
+ "imageAtomicAnd(01L20C00D"
+ "imageAtomicAnd(01M10C00C00C"
+ "imageAtomicAnd(01M10C00C00D"
+ "imageAtomicAnd(01N20C00C00C"
+ "imageAtomicAnd(01N20C00C00D"
+ "imageAtomicAnd(01O20C00C"
+ "imageAtomicAnd(01O20C00D"
+ "imageAtomicAnd(01P10C00C"
+ "imageAtomicAnd(01P10C00D"
+ "imageAtomicAnd(01Q00C00C"
+ "imageAtomicAnd(01Q00C00D"
+ "imageAtomicCompSwap(00q10C00C00C"
+ "imageAtomicCompSwap(00q10C00D00D"
+ "imageAtomicCompSwap(00r20C00C00C"
+ "imageAtomicCompSwap(00r20C00D00D"
+ "imageAtomicCompSwap(00s20C00C00C"
+ "imageAtomicCompSwap(00s20C00D00D"
+ "imageAtomicCompSwap(00t20C00C00C"
+ "imageAtomicCompSwap(00t20C00D00D"
+ "imageAtomicCompSwap(00u10C00C00C00C"
+ "imageAtomicCompSwap(00u10C00C00D00D"
+ "imageAtomicCompSwap(00v20C00C00C00C"
+ "imageAtomicCompSwap(00v20C00C00D00D"
+ "imageAtomicCompSwap(00w20C00C00C"
+ "imageAtomicCompSwap(00w20C00D00D"
+ "imageAtomicCompSwap(00x10C00C00C"
+ "imageAtomicCompSwap(00x10C00D00D"
+ "imageAtomicCompSwap(00y00C00C00C"
+ "imageAtomicCompSwap(00y00C00D00D"
+ "imageAtomicCompSwap(00z10C00C00C"
+ "imageAtomicCompSwap(00z10C00D00D"
+ "imageAtomicCompSwap(01A20C00C00C"
+ "imageAtomicCompSwap(01A20C00D00D"
+ "imageAtomicCompSwap(01B20C00C00C"
+ "imageAtomicCompSwap(01B20C00D00D"
+ "imageAtomicCompSwap(01C20C00C00C"
+ "imageAtomicCompSwap(01C20C00D00D"
+ "imageAtomicCompSwap(01D10C00C00C00C"
+ "imageAtomicCompSwap(01D10C00C00D00D"
+ "imageAtomicCompSwap(01E20C00C00C00C"
+ "imageAtomicCompSwap(01E20C00C00D00D"
+ "imageAtomicCompSwap(01F20C00C00C"
+ "imageAtomicCompSwap(01F20C00D00D"
+ "imageAtomicCompSwap(01G10C00C00C"
+ "imageAtomicCompSwap(01G10C00D00D"
+ "imageAtomicCompSwap(01H00C00C00C"
+ "imageAtomicCompSwap(01H00C00D00D"
+ "imageAtomicCompSwap(01I10C00C00C"
+ "imageAtomicCompSwap(01I10C00D00D"
+ "imageAtomicCompSwap(01J20C00C00C"
+ "imageAtomicCompSwap(01J20C00D00D"
+ "imageAtomicCompSwap(01K20C00C00C"
+ "imageAtomicCompSwap(01K20C00D00D"
+ "imageAtomicCompSwap(01L20C00C00C"
+ "imageAtomicCompSwap(01L20C00D00D"
+ "imageAtomicCompSwap(01M10C00C00C00C"
+ "imageAtomicCompSwap(01M10C00C00D00D"
+ "imageAtomicCompSwap(01N20C00C00C00C"
+ "imageAtomicCompSwap(01N20C00C00D00D"
+ "imageAtomicCompSwap(01O20C00C00C"
+ "imageAtomicCompSwap(01O20C00D00D"
+ "imageAtomicCompSwap(01P10C00C00C"
+ "imageAtomicCompSwap(01P10C00D00D"
+ "imageAtomicCompSwap(01Q00C00C00C"
+ "imageAtomicCompSwap(01Q00C00D00D"
+ "imageAtomicExchange(00q10C00B"
+ "imageAtomicExchange(00q10C00C"
+ "imageAtomicExchange(00q10C00D"
+ "imageAtomicExchange(00r20C00B"
+ "imageAtomicExchange(00r20C00C"
+ "imageAtomicExchange(00r20C00D"
+ "imageAtomicExchange(00s20C00B"
+ "imageAtomicExchange(00s20C00C"
+ "imageAtomicExchange(00s20C00D"
+ "imageAtomicExchange(00t20C00B"
+ "imageAtomicExchange(00t20C00C"
+ "imageAtomicExchange(00t20C00D"
+ "imageAtomicExchange(00u10C00C00B"
+ "imageAtomicExchange(00u10C00C00C"
+ "imageAtomicExchange(00u10C00C00D"
+ "imageAtomicExchange(00v20C00C00B"
+ "imageAtomicExchange(00v20C00C00C"
+ "imageAtomicExchange(00v20C00C00D"
+ "imageAtomicExchange(00w20C00B"
+ "imageAtomicExchange(00w20C00C"
+ "imageAtomicExchange(00w20C00D"
+ "imageAtomicExchange(00x10C00B"
+ "imageAtomicExchange(00x10C00C"
+ "imageAtomicExchange(00x10C00D"
+ "imageAtomicExchange(00y00C00B"
+ "imageAtomicExchange(00y00C00C"
+ "imageAtomicExchange(00y00C00D"
+ "imageAtomicExchange(00z10C00B"
+ "imageAtomicExchange(00z10C00C"
+ "imageAtomicExchange(00z10C00D"
+ "imageAtomicExchange(01A20C00B"
+ "imageAtomicExchange(01A20C00C"
+ "imageAtomicExchange(01A20C00D"
+ "imageAtomicExchange(01B20C00B"
+ "imageAtomicExchange(01B20C00C"
+ "imageAtomicExchange(01B20C00D"
+ "imageAtomicExchange(01C20C00B"
+ "imageAtomicExchange(01C20C00C"
+ "imageAtomicExchange(01C20C00D"
+ "imageAtomicExchange(01D10C00C00B"
+ "imageAtomicExchange(01D10C00C00C"
+ "imageAtomicExchange(01D10C00C00D"
+ "imageAtomicExchange(01E20C00C00B"
+ "imageAtomicExchange(01E20C00C00C"
+ "imageAtomicExchange(01E20C00C00D"
+ "imageAtomicExchange(01F20C00B"
+ "imageAtomicExchange(01F20C00C"
+ "imageAtomicExchange(01F20C00D"
+ "imageAtomicExchange(01G10C00B"
+ "imageAtomicExchange(01G10C00C"
+ "imageAtomicExchange(01G10C00D"
+ "imageAtomicExchange(01H00C00B"
+ "imageAtomicExchange(01H00C00C"
+ "imageAtomicExchange(01H00C00D"
+ "imageAtomicExchange(01I10C00B"
+ "imageAtomicExchange(01I10C00C"
+ "imageAtomicExchange(01I10C00D"
+ "imageAtomicExchange(01J20C00B"
+ "imageAtomicExchange(01J20C00C"
+ "imageAtomicExchange(01J20C00D"
+ "imageAtomicExchange(01K20C00B"
+ "imageAtomicExchange(01K20C00C"
+ "imageAtomicExchange(01K20C00D"
+ "imageAtomicExchange(01L20C00B"
+ "imageAtomicExchange(01L20C00C"
+ "imageAtomicExchange(01L20C00D"
+ "imageAtomicExchange(01M10C00C00B"
+ "imageAtomicExchange(01M10C00C00C"
+ "imageAtomicExchange(01M10C00C00D"
+ "imageAtomicExchange(01N20C00C00B"
+ "imageAtomicExchange(01N20C00C00C"
+ "imageAtomicExchange(01N20C00C00D"
+ "imageAtomicExchange(01O20C00B"
+ "imageAtomicExchange(01O20C00C"
+ "imageAtomicExchange(01O20C00D"
+ "imageAtomicExchange(01P10C00B"
+ "imageAtomicExchange(01P10C00C"
+ "imageAtomicExchange(01P10C00D"
+ "imageAtomicExchange(01Q00C00B"
+ "imageAtomicExchange(01Q00C00C"
+ "imageAtomicExchange(01Q00C00D"
+ "imageAtomicMax(00q10C00C"
+ "imageAtomicMax(00q10C00D"
+ "imageAtomicMax(00r20C00C"
+ "imageAtomicMax(00r20C00D"
+ "imageAtomicMax(00s20C00C"
+ "imageAtomicMax(00s20C00D"
+ "imageAtomicMax(00t20C00C"
+ "imageAtomicMax(00t20C00D"
+ "imageAtomicMax(00u10C00C00C"
+ "imageAtomicMax(00u10C00C00D"
+ "imageAtomicMax(00v20C00C00C"
+ "imageAtomicMax(00v20C00C00D"
+ "imageAtomicMax(00w20C00C"
+ "imageAtomicMax(00w20C00D"
+ "imageAtomicMax(00x10C00C"
+ "imageAtomicMax(00x10C00D"
+ "imageAtomicMax(00y00C00C"
+ "imageAtomicMax(00y00C00D"
+ "imageAtomicMax(00z10C00C"
+ "imageAtomicMax(00z10C00D"
+ "imageAtomicMax(01A20C00C"
+ "imageAtomicMax(01A20C00D"
+ "imageAtomicMax(01B20C00C"
+ "imageAtomicMax(01B20C00D"
+ "imageAtomicMax(01C20C00C"
+ "imageAtomicMax(01C20C00D"
+ "imageAtomicMax(01D10C00C00C"
+ "imageAtomicMax(01D10C00C00D"
+ "imageAtomicMax(01E20C00C00C"
+ "imageAtomicMax(01E20C00C00D"
+ "imageAtomicMax(01F20C00C"
+ "imageAtomicMax(01F20C00D"
+ "imageAtomicMax(01G10C00C"
+ "imageAtomicMax(01G10C00D"
+ "imageAtomicMax(01H00C00C"
+ "imageAtomicMax(01H00C00D"
+ "imageAtomicMax(01I10C00C"
+ "imageAtomicMax(01I10C00D"
+ "imageAtomicMax(01J20C00C"
+ "imageAtomicMax(01J20C00D"
+ "imageAtomicMax(01K20C00C"
+ "imageAtomicMax(01K20C00D"
+ "imageAtomicMax(01L20C00C"
+ "imageAtomicMax(01L20C00D"
+ "imageAtomicMax(01M10C00C00C"
+ "imageAtomicMax(01M10C00C00D"
+ "imageAtomicMax(01N20C00C00C"
+ "imageAtomicMax(01N20C00C00D"
+ "imageAtomicMax(01O20C00C"
+ "imageAtomicMax(01O20C00D"
+ "imageAtomicMax(01P10C00C"
+ "imageAtomicMax(01P10C00D"
+ "imageAtomicMax(01Q00C00C"
+ "imageAtomicMax(01Q00C00D"
+ "imageAtomicMin(00q10C00C"
+ "imageAtomicMin(00q10C00D"
+ "imageAtomicMin(00r20C00C"
+ "imageAtomicMin(00r20C00D"
+ "imageAtomicMin(00s20C00C"
+ "imageAtomicMin(00s20C00D"
+ "imageAtomicMin(00t20C00C"
+ "imageAtomicMin(00t20C00D"
+ "imageAtomicMin(00u10C00C00C"
+ "imageAtomicMin(00u10C00C00D"
+ "imageAtomicMin(00v20C00C00C"
+ "imageAtomicMin(00v20C00C00D"
+ "imageAtomicMin(00w20C00C"
+ "imageAtomicMin(00w20C00D"
+ "imageAtomicMin(00x10C00C"
+ "imageAtomicMin(00x10C00D"
+ "imageAtomicMin(00y00C00C"
+ "imageAtomicMin(00y00C00D"
+ "imageAtomicMin(00z10C00C"
+ "imageAtomicMin(00z10C00D"
+ "imageAtomicMin(01A20C00C"
+ "imageAtomicMin(01A20C00D"
+ "imageAtomicMin(01B20C00C"
+ "imageAtomicMin(01B20C00D"
+ "imageAtomicMin(01C20C00C"
+ "imageAtomicMin(01C20C00D"
+ "imageAtomicMin(01D10C00C00C"
+ "imageAtomicMin(01D10C00C00D"
+ "imageAtomicMin(01E20C00C00C"
+ "imageAtomicMin(01E20C00C00D"
+ "imageAtomicMin(01F20C00C"
+ "imageAtomicMin(01F20C00D"
+ "imageAtomicMin(01G10C00C"
+ "imageAtomicMin(01G10C00D"
+ "imageAtomicMin(01H00C00C"
+ "imageAtomicMin(01H00C00D"
+ "imageAtomicMin(01I10C00C"
+ "imageAtomicMin(01I10C00D"
+ "imageAtomicMin(01J20C00C"
+ "imageAtomicMin(01J20C00D"
+ "imageAtomicMin(01K20C00C"
+ "imageAtomicMin(01K20C00D"
+ "imageAtomicMin(01L20C00C"
+ "imageAtomicMin(01L20C00D"
+ "imageAtomicMin(01M10C00C00C"
+ "imageAtomicMin(01M10C00C00D"
+ "imageAtomicMin(01N20C00C00C"
+ "imageAtomicMin(01N20C00C00D"
+ "imageAtomicMin(01O20C00C"
+ "imageAtomicMin(01O20C00D"
+ "imageAtomicMin(01P10C00C"
+ "imageAtomicMin(01P10C00D"
+ "imageAtomicMin(01Q00C00C"
+ "imageAtomicMin(01Q00C00D"
+ "imageAtomicOr(00q10C00C"
+ "imageAtomicOr(00q10C00D"
+ "imageAtomicOr(00r20C00C"
+ "imageAtomicOr(00r20C00D"
+ "imageAtomicOr(00s20C00C"
+ "imageAtomicOr(00s20C00D"
+ "imageAtomicOr(00t20C00C"
+ "imageAtomicOr(00t20C00D"
+ "imageAtomicOr(00u10C00C00C"
+ "imageAtomicOr(00u10C00C00D"
+ "imageAtomicOr(00v20C00C00C"
+ "imageAtomicOr(00v20C00C00D"
+ "imageAtomicOr(00w20C00C"
+ "imageAtomicOr(00w20C00D"
+ "imageAtomicOr(00x10C00C"
+ "imageAtomicOr(00x10C00D"
+ "imageAtomicOr(00y00C00C"
+ "imageAtomicOr(00y00C00D"
+ "imageAtomicOr(00z10C00C"
+ "imageAtomicOr(00z10C00D"
+ "imageAtomicOr(01A20C00C"
+ "imageAtomicOr(01A20C00D"
+ "imageAtomicOr(01B20C00C"
+ "imageAtomicOr(01B20C00D"
+ "imageAtomicOr(01C20C00C"
+ "imageAtomicOr(01C20C00D"
+ "imageAtomicOr(01D10C00C00C"
+ "imageAtomicOr(01D10C00C00D"
+ "imageAtomicOr(01E20C00C00C"
+ "imageAtomicOr(01E20C00C00D"
+ "imageAtomicOr(01F20C00C"
+ "imageAtomicOr(01F20C00D"
+ "imageAtomicOr(01G10C00C"
+ "imageAtomicOr(01G10C00D"
+ "imageAtomicOr(01H00C00C"
+ "imageAtomicOr(01H00C00D"
+ "imageAtomicOr(01I10C00C"
+ "imageAtomicOr(01I10C00D"
+ "imageAtomicOr(01J20C00C"
+ "imageAtomicOr(01J20C00D"
+ "imageAtomicOr(01K20C00C"
+ "imageAtomicOr(01K20C00D"
+ "imageAtomicOr(01L20C00C"
+ "imageAtomicOr(01L20C00D"
+ "imageAtomicOr(01M10C00C00C"
+ "imageAtomicOr(01M10C00C00D"
+ "imageAtomicOr(01N20C00C00C"
+ "imageAtomicOr(01N20C00C00D"
+ "imageAtomicOr(01O20C00C"
+ "imageAtomicOr(01O20C00D"
+ "imageAtomicOr(01P10C00C"
+ "imageAtomicOr(01P10C00D"
+ "imageAtomicOr(01Q00C00C"
+ "imageAtomicOr(01Q00C00D"
+ "imageAtomicXor(00q10C00C"
+ "imageAtomicXor(00q10C00D"
+ "imageAtomicXor(00r20C00C"
+ "imageAtomicXor(00r20C00D"
+ "imageAtomicXor(00s20C00C"
+ "imageAtomicXor(00s20C00D"
+ "imageAtomicXor(00t20C00C"
+ "imageAtomicXor(00t20C00D"
+ "imageAtomicXor(00u10C00C00C"
+ "imageAtomicXor(00u10C00C00D"
+ "imageAtomicXor(00v20C00C00C"
+ "imageAtomicXor(00v20C00C00D"
+ "imageAtomicXor(00w20C00C"
+ "imageAtomicXor(00w20C00D"
+ "imageAtomicXor(00x10C00C"
+ "imageAtomicXor(00x10C00D"
+ "imageAtomicXor(00y00C00C"
+ "imageAtomicXor(00y00C00D"
+ "imageAtomicXor(00z10C00C"
+ "imageAtomicXor(00z10C00D"
+ "imageAtomicXor(01A20C00C"
+ "imageAtomicXor(01A20C00D"
+ "imageAtomicXor(01B20C00C"
+ "imageAtomicXor(01B20C00D"
+ "imageAtomicXor(01C20C00C"
+ "imageAtomicXor(01C20C00D"
+ "imageAtomicXor(01D10C00C00C"
+ "imageAtomicXor(01D10C00C00D"
+ "imageAtomicXor(01E20C00C00C"
+ "imageAtomicXor(01E20C00C00D"
+ "imageAtomicXor(01F20C00C"
+ "imageAtomicXor(01F20C00D"
+ "imageAtomicXor(01G10C00C"
+ "imageAtomicXor(01G10C00D"
+ "imageAtomicXor(01H00C00C"
+ "imageAtomicXor(01H00C00D"
+ "imageAtomicXor(01I10C00C"
+ "imageAtomicXor(01I10C00D"
+ "imageAtomicXor(01J20C00C"
+ "imageAtomicXor(01J20C00D"
+ "imageAtomicXor(01K20C00C"
+ "imageAtomicXor(01K20C00D"
+ "imageAtomicXor(01L20C00C"
+ "imageAtomicXor(01L20C00D"
+ "imageAtomicXor(01M10C00C00C"
+ "imageAtomicXor(01M10C00C00D"
+ "imageAtomicXor(01N20C00C00C"
+ "imageAtomicXor(01N20C00C00D"
+ "imageAtomicXor(01O20C00C"
+ "imageAtomicXor(01O20C00D"
+ "imageAtomicXor(01P10C00C"
+ "imageAtomicXor(01P10C00D"
+ "imageAtomicXor(01Q00C00C"
+ "imageAtomicXor(01Q00C00D"
+ "imageLoad(00q10C"
+ "imageLoad(00r20C"
+ "imageLoad(00s20C"
+ "imageLoad(00t20C"
+ "imageLoad(00w20C"
+ "imageLoad(00y00C"
+ "imageLoad(00z10C"
+ "imageLoad(01A20C"
+ "imageLoad(01B20C"
+ "imageLoad(01C20C"
+ "imageLoad(01F20C"
+ "imageLoad(01H00C"
+ "imageLoad(01I10C"
+ "imageLoad(01J20C"
+ "imageLoad(01K20C"
+ "imageLoad(01L20C"
+ "imageLoad(01O20C"
+ "imageLoad(01Q00C"
+ "imageSize(00q"
+ "imageSize(00r"
+ "imageSize(00s"
+ "imageSize(00t"
+ "imageSize(00w"
+ "imageSize(00y"
+ "imageSize(01F"
+ "imageSize(01I"
+ "imageSize(01O"
+ "imageSize(01Q"
+ "imageStore(00q10C30B"
+ "imageStore(00r20C30B"
+ "imageStore(00s20C30B"
+ "imageStore(00t20C30B"
+ "imageStore(00w20C30B"
+ "imageStore(00y00C30B"
+ "imageStore(00z10C30C"
+ "imageStore(01A20C30C"
+ "imageStore(01B20C30C"
+ "imageStore(01C20C30C"
+ "imageStore(01F20C30C"
+ "imageStore(01H00C30C"
+ "imageStore(01I10C30D"
+ "imageStore(01J20C30D"
+ "imageStore(01K20C30D"
+ "imageStore(01L20C30D"
+ "imageStore(01O20C30D"
+ "imageStore(01Q00C30D"
+ "imulExtended(00C00C00C00C"
+ "imulExtended(10C10C10C10C"
+ "imulExtended(20C20C20C20C"
+ "imulExtended(30C30C30C30C"
+ "intBitsToFloat(00C"
+ "intBitsToFloat(10C"
+ "intBitsToFloat(20C"
+ "intBitsToFloat(30C"
+ "interpolateAtSample(00B00C"
+ "interpolateAtSample(10B00C"
+ "interpolateAtSample(20B00C"
+ "interpolateAtSample(30B00C"
+ "ldexp(00B00C"
+ "ldexp(10B10C"
+ "ldexp(20B20C"
+ "ldexp(30B30C"
+ "lessThan(10C10C"
+ "lessThan(20C20C"
+ "lessThan(30C30C"
+ "lessThanEqual(10C10C"
+ "lessThanEqual(20C20C"
+ "lessThanEqual(30C30C"
+ "max(00C00C"
+ "max(10C00C"
+ "max(10C10C"
+ "max(20C00C"
+ "max(20C20C"
+ "max(30C00C"
+ "max(30C30C"
+ "metal::array<"
+ "min(00C00C"
+ "min(10C00C"
+ "min(10C10C"
+ "min(20C00C"
+ "min(20C20C"
+ "min(30C00C"
+ "min(30C30C"
+ "mix(00B00B00E"
+ "mix(00C00C00E"
+ "mix(00D00D00E"
+ "mix(00E00E00E"
+ "mix(10B10B10E"
+ "mix(10C10C10E"
+ "mix(10D10D10E"
+ "mix(10E10E10E"
+ "mix(20B20B20E"
+ "mix(20C20C20E"
+ "mix(20D20D20E"
+ "mix(20E20E20E"
+ "mix(30B30B30E"
+ "mix(30C30C30E"
+ "mix(30D30D30E"
+ "mix(30E30E30E"
+ "nil error"
+ "not(10E"
+ "not(20E"
+ "not(30E"
+ "notEqual(10C10C"
+ "notEqual(20C20C"
+ "notEqual(30C30C"
+ "num_rates cannot be null"
+ "onCommandBufferCompleted"
+ "pixel local storage binding out of range"
+ "pixelLocalLoadANGLE(01R"
+ "pixelLocalLoadANGLE(01S"
+ "pixelLocalLoadANGLE(01T"
+ "pixelLocalStoreANGLE(01R30B"
+ "pixelLocalStoreANGLE(01S30C"
+ "pixelLocalStoreANGLE(01T30D"
+ "rate_size cannot be negative."
+ "rates cannot be null when rate_size greater than 0."
+ "rgb_2_yuv(20B00G"
+ "samplePosition(00D"
+ "sequence operator is not allowed for interface blocks"
+ "shadow2DEXT(00c20B"
+ "shadow2DProjEXT(00c30B"
+ "sign(00C"
+ "sign(10C"
+ "sign(20C"
+ "sign(30C"
+ "subpassLoad(01U"
+ "subpassLoad(01V"
+ "subpassLoad(01W"
+ "texelFetch(00H10C00C"
+ "texelFetch(00I20C00C"
+ "texelFetch(00K20C00C"
+ "texelFetch(00L10C00C"
+ "texelFetch(00M10C00C"
+ "texelFetch(00O10C00C"
+ "texelFetch(00P20C00C"
+ "texelFetch(00Q10C00C"
+ "texelFetch(00R20C00C"
+ "texelFetch(00T20C00C"
+ "texelFetch(00U10C00C"
+ "texelFetch(00V20C00C"
+ "texelFetch(00W10C00C"
+ "texelFetch(00X20C00C"
+ "texelFetch(00Z20C00C"
+ "texelFetch(00a10C00C"
+ "texelFetch(00b20C00C"
+ "texelFetch(00f00C"
+ "texelFetch(00k00C"
+ "texelFetch(00n00C"
+ "texelFetchOffset(00H10C00C10C"
+ "texelFetchOffset(00I20C00C20C"
+ "texelFetchOffset(00K20C00C10C"
+ "texelFetchOffset(00Q10C00C10C"
+ "texelFetchOffset(00R20C00C20C"
+ "texelFetchOffset(00T20C00C10C"
+ "texelFetchOffset(00W10C00C10C"
+ "texelFetchOffset(00X20C00C20C"
+ "texelFetchOffset(00Z20C00C10C"
+ "texture(00H10B"
+ "texture(00H10B00B"
+ "texture(00I20B"
+ "texture(00I20B00B"
+ "texture(00L10B"
+ "texture(00L10B00B"
+ "texture(00Q10B"
+ "texture(00Q10B00B"
+ "texture(00R20B"
+ "texture(00R20B00B"
+ "texture(00W10B"
+ "texture(00W10B00B"
+ "texture(00X20B"
+ "texture(00X20B00B"
+ "texture(00c20B"
+ "texture(00c20B00B"
+ "texture(00d30B"
+ "texture(00d30B00B"
+ "texture(00g30B"
+ "texture(00g30B00B"
+ "texture(00h30B00B"
+ "texture(00h30B00B00B"
+ "texture(00l30B"
+ "texture(00o30B"
+ "texture(00o30B00B"
+ "texture(00p10B"
+ "texture2D(00H10B"
+ "texture2D(00H10B00B"
+ "texture2D(00L10B"
+ "texture2DGradEXT(00H10B10B10B"
+ "texture2DLod(00H10B00B"
+ "texture2DLodEXT(00H10B00B"
+ "texture2DProj(00H20B"
+ "texture2DProj(00H20B00B"
+ "texture2DProj(00H30B"
+ "texture2DProj(00H30B00B"
+ "texture2DProj(00L20B"
+ "texture2DProj(00L30B"
+ "texture2DProjGradEXT(00H20B10B10B"
+ "texture2DProjGradEXT(00H30B10B10B"
+ "texture2DProjLod(00H20B00B"
+ "texture2DProjLod(00H30B00B"
+ "texture2DProjLodEXT(00H20B00B"
+ "texture2DProjLodEXT(00H30B00B"
+ "texture2DRect(00N10B"
+ "texture2DRectProj(00N20B"
+ "texture2DRectProj(00N30B"
+ "texture3D(00I20B"
+ "texture3D(00I20B00B"
+ "texture3DLod(00I20B00B"
+ "texture3DProj(00I30B"
+ "texture3DProj(00I30B00B"
+ "texture3DProjLod(00I30B00B"
+ "textureCube(00J20B"
+ "textureCube(00J20B00B"
+ "textureCubeGradEXT(00J20B20B20B"
+ "textureCubeLod(00J20B00B"
+ "textureCubeLodEXT(00J20B00B"
+ "textureGather(00H10B"
+ "textureGather(00H10B00C"
+ "textureGather(00J20B"
+ "textureGather(00J20B00C"
+ "textureGather(00K20B00C"
+ "textureGather(00Q10B"
+ "textureGather(00Q10B00C"
+ "textureGather(00S20B"
+ "textureGather(00S20B00C"
+ "textureGather(00T20B00C"
+ "textureGather(00W10B"
+ "textureGather(00W10B00C"
+ "textureGather(00Y20B"
+ "textureGather(00Y20B00C"
+ "textureGather(00Z20B00C"
+ "textureGather(00c10B"
+ "textureGather(00c10B00B"
+ "textureGather(00d20B"
+ "textureGather(00d20B00B"
+ "textureGather(00g30B"
+ "textureGather(00g30B00C"
+ "textureGather(00h30B00B"
+ "textureGather(00l30B"
+ "textureGather(00l30B00C"
+ "textureGather(00o30B"
+ "textureGather(00o30B00C"
+ "textureGatherOffset(00H10B10C"
+ "textureGatherOffset(00H10B10C00C"
+ "textureGatherOffset(00K20B10C"
+ "textureGatherOffset(00K20B10C00C"
+ "textureGatherOffset(00Q10B10C"
+ "textureGatherOffset(00Q10B10C00C"
+ "textureGatherOffset(00T20B10C"
+ "textureGatherOffset(00T20B10C00C"
+ "textureGatherOffset(00W10B10C"
+ "textureGatherOffset(00W10B10C00C"
+ "textureGatherOffset(00Z20B10C"
+ "textureGatherOffset(00Z20B10C00C"
+ "textureGatherOffset(00c10B00B10C"
+ "textureGatherOffset(00e20B00B10C"
+ "textureGatherOffsets(00H10B10Cx4"
+ "textureGatherOffsets(00H10B10Cx400C"
+ "textureGatherOffsets(00K20B10Cx4"
+ "textureGatherOffsets(00K20B10Cx400C"
+ "textureGatherOffsets(00Q10B10Cx4"
+ "textureGatherOffsets(00Q10B10Cx400C"
+ "textureGatherOffsets(00T20B10Cx4"
+ "textureGatherOffsets(00T20B10Cx400C"
+ "textureGatherOffsets(00W10B10Cx4"
+ "textureGatherOffsets(00W10B10Cx400C"
+ "textureGatherOffsets(00Z20B10Cx4"
+ "textureGatherOffsets(00Z20B10Cx400C"
+ "textureGatherOffsets(00c10B00B10Cx4"
+ "textureGatherOffsets(00e20B00B10Cx4"
+ "textureGrad(00H10B10B10B"
+ "textureGrad(00I20B20B20B"
+ "textureGrad(00K20B10B10B"
+ "textureGrad(00Q10B10B10B"
+ "textureGrad(00R20B20B20B"
+ "textureGrad(00T20B10B10B"
+ "textureGrad(00W10B10B10B"
+ "textureGrad(00X20B20B20B"
+ "textureGrad(00Z20B10B10B"
+ "textureGrad(00c20B10B10B"
+ "textureGrad(00d30B20B20B"
+ "textureGrad(00e30B10B10B"
+ "textureGrad(00g30B20B20B"
+ "textureGrad(00l30B20B20B"
+ "textureGrad(00o30B20B20B"
+ "textureGradOffset(00H10B10B10B10C"
+ "textureGradOffset(00I20B20B20B20C"
+ "textureGradOffset(00K20B10B10B10C"
+ "textureGradOffset(00Q10B10B10B10C"
+ "textureGradOffset(00R20B20B20B20C"
+ "textureGradOffset(00T20B10B10B10C"
+ "textureGradOffset(00W10B10B10B10C"
+ "textureGradOffset(00X20B20B20B20C"
+ "textureGradOffset(00Z20B10B10B10C"
+ "textureGradOffset(00c20B10B10B10C"
+ "textureGradOffset(00e30B10B10B10C"
+ "textureLod(00H10B00B"
+ "textureLod(00I20B00B"
+ "textureLod(00Q10B00B"
+ "textureLod(00R20B00B"
+ "textureLod(00W10B00B"
+ "textureLod(00X20B00B"
+ "textureLod(00c20B00B"
+ "textureLod(00d30B00B"
+ "textureLod(00e30B00B"
+ "textureLod(00g30B00B"
+ "textureLod(00h30B00B00B"
+ "textureLod(00l30B00B"
+ "textureLod(00o30B00B"
+ "textureLodOffset(00H10B00B10C"
+ "textureLodOffset(00I20B00B20C"
+ "textureLodOffset(00K20B00B10C"
+ "textureLodOffset(00Q10B00B10C"
+ "textureLodOffset(00R20B00B20C"
+ "textureLodOffset(00T20B00B10C"
+ "textureLodOffset(00W10B00B10C"
+ "textureLodOffset(00X20B00B20C"
+ "textureLodOffset(00Z20B00B10C"
+ "textureLodOffset(00c20B00B10C"
+ "textureLodOffset(00e30B00B10C"
+ "textureOffset(00H10B10C"
+ "textureOffset(00H10B10C00B"
+ "textureOffset(00I20B20C"
+ "textureOffset(00I20B20C00B"
+ "textureOffset(00K20B10C"
+ "textureOffset(00K20B10C00B"
+ "textureOffset(00Q10B10C"
+ "textureOffset(00Q10B10C00B"
+ "textureOffset(00R20B20C"
+ "textureOffset(00R20B20C00B"
+ "textureOffset(00T20B10C"
+ "textureOffset(00T20B10C00B"
+ "textureOffset(00W10B10C"
+ "textureOffset(00W10B10C00B"
+ "textureOffset(00X20B20C"
+ "textureOffset(00X20B20C00B"
+ "textureOffset(00Z20B10C"
+ "textureOffset(00Z20B10C00B"
+ "textureOffset(00c20B10C"
+ "textureOffset(00c20B10C00B"
+ "textureOffset(00e30B10C"
+ "textureOffset(00e30B10C00B"
+ "textureProj(00H20B"
+ "textureProj(00H20B00B"
+ "textureProj(00H30B"
+ "textureProj(00H30B00B"
+ "textureProj(00L20B"
+ "textureProj(00L20B00B"
+ "textureProj(00L30B"
+ "textureProj(00L30B00B"
+ "textureProj(00Q20B"
+ "textureProj(00Q20B00B"
+ "textureProj(00Q30B"
+ "textureProj(00Q30B00B"
+ "textureProj(00W20B"
+ "textureProj(00W20B00B"
+ "textureProj(00W30B"
+ "textureProj(00W30B00B"
+ "textureProj(00c30B"
+ "textureProj(00c30B00B"
+ "textureProjGrad(00H20B10B10B"
+ "textureProjGrad(00H30B10B10B"
+ "textureProjGrad(00I30B20B20B"
+ "textureProjGrad(00Q20B10B10B"
+ "textureProjGrad(00Q30B10B10B"
+ "textureProjGrad(00R30B20B20B"
+ "textureProjGrad(00W20B10B10B"
+ "textureProjGrad(00W30B10B10B"
+ "textureProjGrad(00X30B20B20B"
+ "textureProjGrad(00c30B10B10B"
+ "textureProjGradOffset(00H20B10B10B10C"
+ "textureProjGradOffset(00H30B10B10B10C"
+ "textureProjGradOffset(00I30B20B20B20C"
+ "textureProjGradOffset(00Q20B10B10B10C"
+ "textureProjGradOffset(00Q30B10B10B10C"
+ "textureProjGradOffset(00R30B20B20B20C"
+ "textureProjGradOffset(00W20B10B10B10C"
+ "textureProjGradOffset(00W30B10B10B10C"
+ "textureProjGradOffset(00X30B20B20B20C"
+ "textureProjGradOffset(00c30B10B10B10C"
+ "textureProjLod(00H20B00B"
+ "textureProjLod(00H30B00B"
+ "textureProjLod(00Q20B00B"
+ "textureProjLod(00Q30B00B"
+ "textureProjLod(00W20B00B"
+ "textureProjLod(00W30B00B"
+ "textureProjLod(00c30B00B"
+ "textureProjLodOffset(00H20B00B10C"
+ "textureProjLodOffset(00H30B00B10C"
+ "textureProjLodOffset(00I30B00B20C"
+ "textureProjLodOffset(00Q20B00B10C"
+ "textureProjLodOffset(00Q30B00B10C"
+ "textureProjLodOffset(00R30B00B20C"
+ "textureProjLodOffset(00W20B00B10C"
+ "textureProjLodOffset(00W30B00B10C"
+ "textureProjLodOffset(00X30B00B20C"
+ "textureProjLodOffset(00c30B00B10C"
+ "textureProjOffset(00H20B10C"
+ "textureProjOffset(00H20B10C00B"
+ "textureProjOffset(00H30B10C"
+ "textureProjOffset(00H30B10C00B"
+ "textureProjOffset(00I30B20C"
+ "textureProjOffset(00I30B20C00B"
+ "textureProjOffset(00Q20B10C"
+ "textureProjOffset(00Q20B10C00B"
+ "textureProjOffset(00Q30B10C"
+ "textureProjOffset(00Q30B10C00B"
+ "textureProjOffset(00R30B20C"
+ "textureProjOffset(00R30B20C00B"
+ "textureProjOffset(00W20B10C"
+ "textureProjOffset(00W20B10C00B"
+ "textureProjOffset(00W30B10C"
+ "textureProjOffset(00W30B10C00B"
+ "textureProjOffset(00X30B20C"
+ "textureProjOffset(00X30B20C00B"
+ "textureProjOffset(00c30B10C"
+ "textureProjOffset(00c30B10C00B"
+ "textureQueryLOD"
+ "textureQueryLOD(00H10B"
+ "textureQueryLOD(00I20B"
+ "textureQueryLOD(00J20B"
+ "textureQueryLOD(00K10B"
+ "textureQueryLOD(00Q10B"
+ "textureQueryLOD(00R20B"
+ "textureQueryLOD(00S20B"
+ "textureQueryLOD(00T10B"
+ "textureQueryLOD(00W10B"
+ "textureQueryLOD(00X20B"
+ "textureQueryLOD(00Y20B"
+ "textureQueryLOD(00Z10B"
+ "textureQueryLOD(00c10B"
+ "textureQueryLOD(00d20B"
+ "textureQueryLOD(00e10B"
+ "textureQueryLOD(00g20B"
+ "textureQueryLOD(00h20B"
+ "textureQueryLOD(00l20B"
+ "textureQueryLOD(00o20B"
+ "textureSize(00H00C"
+ "textureSize(00I00C"
+ "textureSize(00J00C"
+ "textureSize(00K00C"
+ "textureSize(00L00C"
+ "textureSize(00M00C"
+ "textureSize(00O"
+ "textureSize(00Q00C"
+ "textureSize(00R00C"
+ "textureSize(00S00C"
+ "textureSize(00T00C"
+ "textureSize(00U"
+ "textureSize(00W00C"
+ "textureSize(00X00C"
+ "textureSize(00Y00C"
+ "textureSize(00Z00C"
+ "textureSize(00a"
+ "textureSize(00c00C"
+ "textureSize(00d00C"
+ "textureSize(00e00C"
+ "textureSize(00f"
+ "textureSize(00g00C"
+ "textureSize(00h00C"
+ "textureSize(00k"
+ "textureSize(00l00C"
+ "textureSize(00n"
+ "textureSize(00o00C"
+ "textureVideoWEBGL(00p10B"
+ "uaddCarry(00D00D00D"
+ "uaddCarry(10D10D10D"
+ "uaddCarry(20D20D20D"
+ "uaddCarry(30D30D30D"
+ "uintBitsToFloat(00D"
+ "uintBitsToFloat(10D"
+ "uintBitsToFloat(20D"
+ "uintBitsToFloat(30D"
+ "umulExtended(00D00D00D00D"
+ "umulExtended(10D10D10D10D"
+ "umulExtended(20D20D20D20D"
+ "umulExtended(30D30D30D30D"
+ "unknown error"
+ "unpackHalf2x16(00D"
+ "unpackSnorm2x16(00D"
+ "unpackSnorm4x8(00D"
+ "unpackUnorm2x16(00D"
+ "unpackUnorm4x8(00D"
+ "usubBorrow(00D00D00D"
+ "usubBorrow(10D10D10D"
+ "usubBorrow(20D20D20D"
+ "usubBorrow(30D30D30D"
+ "yuv_2_rgb(20B00G"
- "\n#define ANGLE_SAMPLE_COMPARE_GRADIENT_INDEX   0\n#define ANGLE_SAMPLE_COMPARE_LOD_INDEX        1\n#define ANGLE_RASTERIZATION_DISCARD_INDEX     2\n#define ANGLE_MULTISAMPLED_RENDERING_INDEX    3\n#define ANGLE_DEPTH_WRITE_ENABLED_INDEX       4\n#define ANGLE_EMULATE_ALPHA_TO_COVERAGE_INDEX 5\n#define ANGLE_WRITE_HELPER_SAMPLE_MASK_INDEX  6\n\nconstant bool ANGLEUseSampleCompareGradient [[function_constant(ANGLE_SAMPLE_COMPARE_GRADIENT_INDEX)]];\nconstant bool ANGLEUseSampleCompareLod      [[function_constant(ANGLE_SAMPLE_COMPARE_LOD_INDEX)]];\nconstant bool ANGLERasterizerDisabled       [[function_constant(ANGLE_RASTERIZATION_DISCARD_INDEX)]];\nconstant bool ANGLEMultisampledRendering    [[function_constant(ANGLE_MULTISAMPLED_RENDERING_INDEX)]];\nconstant bool ANGLEDepthWriteEnabled        [[function_constant(ANGLE_DEPTH_WRITE_ENABLED_INDEX)]];\nconstant bool ANGLEEmulateAlphaToCoverage   [[function_constant(ANGLE_EMULATE_ALPHA_TO_COVERAGE_INDEX)]];\nconstant bool ANGLEWriteHelperSampleMask    [[function_constant(ANGLE_WRITE_HELPER_SAMPLE_MASK_INDEX)]];\n\n#define ANGLE_ALPHA0\n\n"
- "\n#define ANGLE_texelFetch(env, ...) ANGLE_texelFetch_impl(*env.texture, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetch_impl(\n    thread Texture &texture,\n    metal::int2 const coord,\n    uint32_t level)\n{\n    return texture.read(uint2(coord), level);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetch_impl(\n    thread Texture &texture,\n    metal::int3 const coord,\n    uint32_t level)\n{\n    return texture.read(uint3(coord), level);\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetch_impl(\n    thread metal::texture2d_array<T> &texture,\n    metal::int3 const coord,\n    uint32_t level)\n{\n    return texture.read(uint2(coord.xy), uint32_t(coord.z), level);\n}\n\n"
- "\n#define ANGLE_texelFetchOffset(env, ...) ANGLE_texelFetchOffset_impl(*env.texture, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset_impl(\n    thread Texture &texture,\n    metal::int2 const coord,\n    uint32_t level,\n    metal::int2 const offset)\n{\n    return texture.read(uint2(coord + offset), level);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset_impl(\n    thread Texture &texture,\n    metal::int3 const coord,\n    uint32_t level,\n    metal::int3 const offset)\n{\n    return texture.read(uint3(coord + offset), level);\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset_impl(\n    thread metal::texture2d_array<T> &texture,\n    metal::int3 const coord,\n    uint32_t level,\n    metal::int2 const offset)\n{\n    return texture.read(uint2(coord.xy + offset), uint32_t(coord.z), level);\n}\n\n"
- "\n#define ANGLE_texture(env, ...) ANGLE_texture_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\n"
- "\n#define ANGLE_texture1DLod(env, ...) ANGLE_texture1DLod_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture1DLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    float const coord,\n    float level)\n{\n    return texture.sample(sampler, coord, metal::level(level));\n}\n\n"
- "\n#define ANGLE_texture1DProj(env, ...) ANGLE_texture1DProj_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture1DProj_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.x/coord.y, metal::bias(bias));\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture1DProj_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.x/coord.w, metal::bias(bias));\n}\n\n"
- "\n#define ANGLE_texture1DProjLod(env, ...) ANGLE_texture1DProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture1DProjLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.x/coord.y, metal::level(level));\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture1DProjLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.x/coord.w, metal::level(level));\n}\n\n"
- "\n#define ANGLE_texture2D(env, ...) ANGLE_texture2D_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2D_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord)\n{\n    return texture.sample(sampler, coord);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2D_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord,\n    float bias)\n{\n    return texture.sample(sampler, coord, metal::bias(bias));\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2D_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord)\n{\n    return texture.sample(sampler, coord);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2D_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float bias)\n{\n    return texture.sample(sampler, coord, metal::bias(bias));\n}\n\n"
- "\n#define ANGLE_texture2DGradEXT(env, ...) ANGLE_texture2DGradEXT_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DGradEXT_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return texture.sample(sampler, coord, metal::gradient2d(dPdx, dPdy));\n}\n\n"
- "\n#define ANGLE_texture2DLod(env, ...) ANGLE_texture2DLod_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord, metal::level(level));\n}\n\n"
- "\n#define ANGLE_texture2DProj(env, ...) ANGLE_texture2DProj_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProj_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.xy/coord.z, metal::bias(bias));\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProj_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.xy/coord.w, metal::bias(bias));\n}\n\n"
- "\n#define ANGLE_texture2DProjGradEXT(env, ...) ANGLE_texture2DProjGradEXT_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjGradEXT_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return texture.sample(sampler, coord.xy/coord.z, metal::gradient2d(dPdx, dPdy));\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjGradEXT_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy));\n}\n\n"
- "\n#define ANGLE_texture2DProjLod(env, ...) ANGLE_texture2DProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.xy/coord.z, metal::level(level));\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.xy/coord.w, metal::level(level));\n}\n\n"
- "\n#define ANGLE_texture2DRect(env, ...) ANGLE_texture2DRect_impl(*env.texture, *env.sampler, __VA_ARGS__)\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DRect_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord)\n{\n    return texture.sample(sampler, coord);\n}\n\n"
- "\n#define ANGLE_texture2DRectProj(env, ...) ANGLE_texture2DRectProj_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DRectProj_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord)\n{\n    return texture.sample(sampler, coord.xy/coord.z);\n}\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DRectProj_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord)\n{\n    return texture.sample(sampler, coord.xy/coord.w);\n}\n\n"
- "\n#define ANGLE_texture3DLod(env, ...) ANGLE_texture3DLod_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture3DLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord, metal::level(level));\n}\n\n"
- "\n#define ANGLE_texture3DProj(env, ...) ANGLE_texture3DProj_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture3DProj_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.xyz/coord.w, metal::bias(bias));\n}\n\n"
- "\n#define ANGLE_texture3DProjLod(env, ...) ANGLE_texture3DProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture3DProjLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.xyz/coord.w, metal::level(level));\n}\n\n"
- "\n#define ANGLE_textureCube(env, ...) ANGLE_textureCube_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureCube_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord)\n{\n    return texture.sample(sampler, coord);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureCube_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float bias)\n{\n    return texture.sample(sampler, coord, metal::bias(bias));\n}\n\n"
- "\n#define ANGLE_textureCubeGradEXT(env, ...) ANGLE_textureCubeGradEXT_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureCubeGradEXT_impl(\n    thread metal::texturecube<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy)\n{\n    return texture.sample(sampler, coord, metal::gradientcube(dPdx, dPdy));\n}\n\n"
- "\n#define ANGLE_textureCubeLod(env, ...) ANGLE_textureCubeLod_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureCubeLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord, metal::level(level));\n}\n\n"
- "\n#define ANGLE_textureCubeProj(env, ...) ANGLE_textureCubeProj_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureCubeProj_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.xyz/coord.w, metal::bias(bias));\n}\n\n"
- "\n#define ANGLE_textureCubeProjLod(env, ...) ANGLE_textureCubeProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureCubeProjLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.xyz/coord.w, metal::level(level));\n}\n\n"
- "\n#define ANGLE_textureGrad(env, ...) ANGLE_textureGrad_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\n"
- "\n#define ANGLE_textureGradOffset(env, ...) ANGLE_textureGradOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\n"
- "\n#define ANGLE_textureLod(env, ...) ANGLE_textureLod_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\n"
- "\n#define ANGLE_textureLodOffset(env, ...) ANGLE_textureLodOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord,\n    float level,\n    metal::int2 const offset)\n{\n    return texture.sample(sampler, coord, metal::level(level), offset);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level,\n    metal::int3 const offset)\n{\n    return texture.sample(sampler, coord, metal::level(level), offset);\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level,\n    int2 const offset)\n{\n    if (ANGLEUseSampleCompareLod)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xy, coord.z, metal::level(level), offset));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xy, metal::level(level), offset) > coord.z);\n    }\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(\n    thread metal::texture2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level,\n    metal::int2 const offset)\n{\n    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::level(level), offset);\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(\n    thread metal::texture2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level,\n    metal::int3 const offset)\n{\n    return texture.sample(sampler, coord.xyz, uint32_t(metal::round(coord.w)), metal::level(level), offset);\n}\n\n"
- "\n#define ANGLE_textureOffset(env, ...) ANGLE_textureOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord,\n    metal::int2 const offset)\n{\n    return texture.sample(sampler, coord, offset);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord,\n    metal::int2 const offset,\n    float bias)\n{\n    return texture.sample(sampler, coord, metal::bias(bias), offset);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::int2 const offset)\n{\n    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), offset);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::int2 const offset,\n    float bias)\n{\n    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::bias(bias), offset);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::int3 const offset)\n{\n    return texture.sample(sampler, coord, offset);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::int3 const offset,\n    float bias)\n{\n    return texture.sample(sampler, coord, metal::bias(bias), offset);\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::int2 const offset)\n{\n    return texture.sample_compare(sampler, coord.xy, coord.z, offset);\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::int2 const offset,\n    float bias)\n{\n    return texture.sample_compare(sampler, coord.xy, coord.z, metal::bias(bias), offset);\n}\n\n"
- "\n#define ANGLE_textureProj(env, ...) ANGLE_textureProj_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.xy/coord.z, metal::bias(bias));\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.xy/coord.w, metal::bias(bias));\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj_impl(\n    thread metal::texture3d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.xyz/coord.w, metal::bias(bias));\n}\n\n"
- "\n#define ANGLE_textureProjGrad(env, ...) ANGLE_textureProjGrad_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\n"
- "\n#define ANGLE_textureProjGradOffset(env, ...) ANGLE_textureProjGradOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\n"
- "\n#define ANGLE_textureProjLod(env, ...) ANGLE_textureProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\n"
- "\n#define ANGLE_textureProjLodOffset(env, ...) ANGLE_textureProjLodOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level,\n    int2 const offset)\n{\n    return texture.sample(sampler, coord.xy/coord.z, metal::level(level), offset);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level,\n    int2 const offset)\n{\n    return texture.sample(sampler, coord.xy/coord.w, metal::level(level), offset);\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level,\n    int2 const offset)\n{\n    if (ANGLEUseSampleCompareLod)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xy/coord.w, coord.z/coord.w, metal::level(level), offset));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xy/coord.w, metal::level(level), offset) > coord.z/coord.w);\n    }\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset_impl(\n    thread metal::texture3d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level,\n    int3 const offset)\n{\n    return texture.sample(sampler, coord.xyz/coord.w, metal::level(level), offset);\n}\n\n"
- "\n#define ANGLE_textureProjOffset(env, ...) ANGLE_textureProjOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    int2 const offset,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.xy/coord.z, metal::bias(bias), offset);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    int2 const offset,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.xy/coord.w, metal::bias(bias), offset);\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset_impl(\n    thread metal::texture3d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    int3 const offset,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.xyz/coord.w, metal::bias(bias), offset);\n}\n\n"
- "\n#define ANGLE_textureSize(env, ...) ANGLE_textureSize_impl(*env.texture, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureSize_impl(\n    thread Texture &texture,\n    int level)\n{\n    return int2(texture.get_width(uint32_t(level)), texture.get_height(uint32_t(level)));\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureSize_impl(\n    thread metal::texture3d<T> &texture,\n    int level)\n{\n    return int3(texture.get_width(uint32_t(level)), texture.get_height(uint32_t(level)), texture.get_depth(uint32_t(level)));\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureSize_impl(\n    thread metal::depth2d_array<T> &texture,\n    int level)\n{\n    return int3(texture.get_width(uint32_t(level)), texture.get_height(uint32_t(level)), texture.get_array_size());\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureSize_impl(\n    thread metal::texture2d_array<T> &texture,\n    int level)\n{\n    return int3(texture.get_width(uint32_t(level)), texture.get_height(uint32_t(level)), texture.get_array_size());\n}\n\n"
- "\ntemplate <int N>\nstruct ANGLE_gradient_traits;\ntemplate <>\nstruct ANGLE_gradient_traits<2> { using type = metal::gradient2d; };\ntemplate <>\nstruct ANGLE_gradient_traits<3> { using type = metal::gradient3d; };\n\ntemplate <int N>\nusing ANGLE_gradient = typename ANGLE_gradient_traits<N>::type;\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    metal::int2 const offset)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xy, coord.z, metal::gradient2d(dPdx, dPdy), offset));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xy, metal::gradient2d(dPdx, dPdy), offset) > coord.z);\n    }\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(\n    thread metal::depth2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    metal::int2 const offset)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::gradient2d(dPdx, dPdy), offset));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy), offset) > coord.w);\n    }\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(\n    thread metal::depthcube<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy,\n    metal::int3 const offset)\n{\n    return texture.sample_compare(sampler, coord.xyz, coord.w, metal::gradientcube(dPdx, dPdy), offset);\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(\n    thread metal::texturecube<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy,\n    metal::int3 const offset)\n{\n    return texture.sample(sampler, coord, metal::gradientcube(dPdx, dPdy), offset);\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xy, coord.z, metal::gradient2d(dPdx, dPdy)));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xy, metal::gradient2d(dPdx, dPdy)) > coord.z);\n    }\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(\n    thread metal::depth2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::gradient2d(dPdx, dPdy)));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy)) > coord.w);\n    }\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(\n    thread metal::depthcube<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xyz, coord.w, metal::gradientcube(dPdx, dPdy)));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xyz, metal::gradientcube(dPdx, dPdy)) > coord.w);\n    }\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(\n    thread metal::texturecube<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy)\n{\n    return texture.sample(sampler, coord, metal::gradientcube(dPdx, dPdy));\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level)\n{\n    if (ANGLEUseSampleCompareLod)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xy, coord.z, metal::level(level)));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xy, metal::level(level)) > coord.z);\n    }\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(\n    thread metal::texture2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::level(level));\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(\n    thread metal::texture2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.xyz, uint32_t(metal::round(coord.w)), metal::level(level));\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    int2 const offset)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xy/coord.w, coord.z/coord.w, metal::gradient2d(dPdx, dPdy), offset));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy), offset) > coord.z/coord.w);\n    }\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset_impl(\n    thread metal::texture3d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy,\n    int3 const offset)\n{\n    return texture.sample(sampler, coord.xyz/coord.w, metal::gradient3d(dPdx, dPdy), offset);\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xy/coord.w, coord.z/coord.w, metal::gradient2d(dPdx, dPdy)));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy)) > coord.z/coord.w);\n    }\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad_impl(\n    thread metal::texture3d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy)\n{\n    return texture.sample(sampler, coord.xyz/coord.w, metal::gradient3d(dPdx, dPdy));\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level)\n{\n    if (ANGLEUseSampleCompareLod)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xy/coord.w, coord.z/coord.w, metal::level(level)));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xy/coord.w, metal::level(level)) > coord.z/coord.w);\n    }\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod_impl(\n    thread metal::texture3d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.xyz/coord.w, metal::level(level));\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord)\n{\n    return texture.sample_compare(sampler, coord.xy, coord.z);\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float bias)\n{\n    return texture.sample_compare(sampler, coord.xy, coord.z, metal::bias(bias));\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread metal::depth2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord)\n{\n    return texture.sample_compare(sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w);\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread metal::depth2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float compare)\n{\n    return texture.sample_compare(sampler, coord.xyz, uint32_t(metal::round(coord.w)), compare);\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread metal::depthcube<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord)\n{\n    return texture.sample_compare(sampler, coord.xyz, coord.w);\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread metal::depthcube<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float bias)\n{\n    return texture.sample_compare(sampler, coord.xyz, coord.w, metal::bias(bias));\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread metal::texture2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord)\n{\n    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)));\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread metal::texture2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float bias)\n{\n    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::bias(bias));\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread metal::texture2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord)\n{\n    return texture.sample(sampler, coord.xyz, uint32_t(metal::round(coord.w)));\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread metal::texture2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float bias)\n{\n    return texture.sample(sampler, coord.xyz, uint32_t(metal::round(coord.w)), metal::bias(bias));\n}\n\n"
- "\ntemplate <typename Texture, int N>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::vec<float, N> const coord,\n    metal::vec<float, N> const dPdx,\n    metal::vec<float, N> const dPdy,\n    metal::vec<int, N> const offset)\n{\n    return texture.sample(sampler, coord, ANGLE_gradient<N>(dPdx, dPdy), offset);\n}\n\n"
- "\ntemplate <typename Texture, int N>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::vec<float, N> const coord,\n    metal::vec<float, N> const dPdx,\n    metal::vec<float, N> const dPdy)\n{\n    return texture.sample(sampler, coord, ANGLE_gradient<N>(dPdx, dPdy));\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    metal::int2 const offset)\n{\n    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy), offset);\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    metal::int2 const offset)\n{\n    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy), offset);\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy));\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy));\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord, metal::level(level));\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord, metal::level(level));\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    int2 const offset)\n{\n    return texture.sample(sampler, coord.xy/coord.z, metal::gradient2d(dPdx, dPdy), offset);\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    int2 const offset)\n{\n    return texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy), offset);\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return texture.sample(sampler, coord.xy/coord.z, metal::gradient2d(dPdx, dPdy));\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy));\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.xy/coord.z, metal::level(level));\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.xy/coord.w, metal::level(level));\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord)\n{\n    return texture.sample(sampler, coord);\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord,\n    float bias)\n{\n    return texture.sample(sampler, coord, metal::bias(bias));\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord)\n{\n    return texture.sample(sampler, coord);\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float bias)\n{\n    return texture.sample(sampler, coord, metal::bias(bias));\n}\n\n"
- " (internal function)"
- " <anonymous>"
- "!isAMDFireProDevice()"
- "!isOSX && !isCatalyst && !isSimulator"
- "!isOSX || GetMacOSVersion() >= OSVersion(12, 0, 0)"
- "#define ANGLE_tensor metal::array\n"
- "' "
- "(isOSX || isCatalyst) && !isARM"
- "(symbol id "
- "-----\n"
- "2.1.23740 git hash: 5a8eab96c6b7"
- "2b88385687d0f98f9b90956bcbf626b2"
- "<loadops> cannot be null."
- "<n> != ACTIVE_PIXEL_LOCAL_STORAGE_PLANES_ANGLE"
- "<params> cannot be null."
- "A buffer must be bound."
- "A program must be bound."
- "A program object is active for at least one, but not all of the shader stages that were present when the program was linked."
- "A renderbuffer must be bound."
- "A texture must be bound."
- "A transform feedback buffer that would be written to is also bound to a non-transform-feedback target, which would cause undefined behavior."
- "AMD Metal Drivers appear to have a bug this works around"
- "ANGLEUseSampleCompareLod"
- "ANGLE_tensor<"
- "Active atomic counter resources are not assigned name strings."
- "Active draw buffers with missing fragment shader outputs."
- "Active fragment shader does not include the layout qualifier matching the blend equation"
- "Add shaderRead usage to some multisampled texture formats"
- "Advanced blend equation can only be used when only one draw buffer is not NONE"
- "Advanced blend equations are not supported when pixel local storage is active."
- "Allow compressed formats"
- "Allow creation of render passes without any attachments"
- "Always prefer to upload texture data via a staging buffer and avoid MTLTexture::replaceRegion."
- "Always update buffers by copying the data to a staging buffer and then blitting it to the actual buffer"
- "An active buffer is mapped"
- "An enabled vertex array has no buffer and no pointer."
- "An enabled vertex array has no buffer."
- "Any command that transfers vertices to the GL requires a vertex shader if the current program uses a tessellation shader."
- "Apply a vendor-specific transformation to explicit cubemap derivatives"
- "Argument <%s> must be less than (MAX_COMBINED_DRAW_BUFFERS_AND_PIXEL_LOCAL_STORAGE_PLANES_ANGLE - ACTIVE_PIXEL_LOCAL_STORAGE_PLANES_ANGLE) when pixel local storage is active."
- "Argument <%s> must be less than MAX_COLOR_ATTACHMENTS_WITH_ACTIVE_PIXEL_LOCAL_STORAGE_ANGLE when pixel local storage is active."
- "At least one enabled attribute must have a divisor of zero."
- "Attachment type must be compatible with attachment object."
- "Attachments have been changed on a framebuffer configured for foveated rendering"
- "Attempt to blit from a multisampled framebuffer and the bounds don't match with the draw framebuffer."
- "Attempt to blit from a multisampled framebuffer and the bounds or format of the color buffer don't match with the draw framebuffer."
- "Attempt to delete an active transform feedback."
- "Attempt to read from a missing color attachment of a complete framebuffer."
- "Attempt to read from a missing depth/stencil attachment of a complete framebuffer."
- "Attempt to read from a multi-view framebuffer."
- "Attempt to write to a multi-view framebuffer."
- "Attempted to begin pixel local storage with GL_DITHER enabled."
- "Attempted to begin pixel local storage with GL_RASTERIZER_DISCARD enabled."
- "Attempted to begin pixel local storage with a blend function requiring the secondary color input."
- "Attempted to begin pixel local storage with a multisampled framebuffer."
- "Attempted to begin pixel local storage with an advanced blend equation enabled."
- "Attempted to begin pixel local storage with transform feedback active."
- "Attempted to enable a pixel local storage plane that is in a deinitialized state."
- "Attempted to flush a buffer not mapped for explicit flushing."
- "Attempted to flush buffer object zero."
- "Attempted to map buffer object zero."
- "Attempting to blit and the read and draw buffer formats don't match. read: 0x%04X draw: 0x%04X"
- "Attempts to detect undefined behavior when in WebGL mode and reject shaders if any detected."
- "Attempts to generate shaders that are shareable. More specifically, shaders end up with conditionals that are decided at run time via input parameters vs compile time. This results in bigger shaders."
- "Attribute list must be NULL or GL_NONE"
- "Attributes that begin with 'gl_' are not allowed."
- "Attributes that begin with 'webgl_', or '_webgl_' are not allowed."
- "Base level must be 0."
- "Base level must be at least 0."
- "Blend functions requiring the secondary color input are not supported when pixel local storage is active."
- "Blending must be disabled when writing to YUV framebuffers."
- "Blit extension not available."
- "Blit feedback loop: the read and draw framebuffers are the same."
- "BlitFramebuffer dimensions out of 32-bit integer range."
- "Blits are only supported from 2D texture, renderbuffer or default framebuffer attachments in this extension."
- "Blits are only supported to 2D texture, renderbuffer or default framebuffer attachments in this extension."
- "Blitting to or from a YUV framebuffer is disallowed."
- "Border must be 0."
- "Both width and height argument of drawn texture must be positive."
- "Buffer is already mapped."
- "Buffer is bound for transform feedback."
- "Buffer is immutable."
- "Buffer is not mapped."
- "Buffer is not updatable."
- "Buffer offset overflow."
- "Buffer textures are not allowed."
- "CONSTANT_COLOR (or ONE_MINUS_CONSTANT_COLOR) and CONSTANT_ALPHA (or ONE_MINUS_CONSTANT_ALPHA) cannot be used together as source and destination color factors in the blend function."
- "Cache MTLLibrary objects in memory."
- "Call a user-defined function"
- "Can not get pointer for reserved buffer name zero."
- "Cannot change active program while transform feedback is unpaused."
- "Cannot change program binary while program is associated with an active transform feedback object."
- "Cannot create a 2D texture from a multisampled EGL image."
- "Cannot disable foveation on a foveated texture"
- "Cannot generate mipmaps for a zero-size texture in a WebGL context."
- "Cannot have negative height, width, or depth."
- "Cannot have negative start."
- "Cannot have negative stride."
- "Cannot link program while program is associated with an active transform feedback object."
- "Cannot pop the default debug group."
- "Cannot push more than GL_MAX_DEBUG_GROUP_STACK_DEPTH debug groups."
- "Cannot use GL_LINEAR filter when blitting a integer framebuffer."
- "Cap 0x%04X cannot be enabled or disabled while pixel local storage is active."
- "Check the filesystem for shaders to use instead of those provided through glShaderSource"
- "Check the filesystem for translated shaders to use instead of the shader translator's"
- "Client data cannot be used with a non-default vertex array object."
- "Color number for primary color greater than or equal to MAX_DRAW_BUFFERS"
- "Color number for secondary color greater than or equal to MAX_DUAL_SOURCE_DRAW_BUFFERS"
- "Color writemask for a GL_RGB9_E5 draw buffer must have the same values for red, green, and blue channels."
- "Compile MTLLibrary in multiple threads."
- "Compiles metal shaders using command line tools and saves to BlobCache. Requires using --no-sandbox and disabling enableParallelMtlLibraryCompilation."
- "Compressed data is valid if-and-only-if the texture is compressed."
- "Compressed texture dimensions must exactly match the dimensions of the data passed in."
- "Compressed textures cannot be attached to a framebuffer."
- "Compute pipeline without a shader is invalid."
- "Compute shader precision not yet implemented."
- "Context does not support GL_ANGLE_texture_rectangle"
- "Context has been lost."
- "Copy*TextureCHROMIUM from EXTERNAL_OES to integer format requires OES_EGL_image_external_essl3"
- "Copying from a YUV framebuffer is disallowed."
- "Count exceeds MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS."
- "Create flags must only include bits defined by GL_ANGLE_external_objects_flags"
- "Cull mode not recognized."
- "Current matrix stack has only a single matrix."
- "Current matrix stack is full."
- "Current renderer doesn't support alpha-to-coverage."
- "Data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type."
- "Default framebuffer is bound."
- "Default framebuffer object name 0 does not support pixel local storage."
- "Default vertex array object is bound."
- "Depth must be less than or equal to MAX_ARRAY_TEXTURE_LAYERS"
- "Depth/stencil buffer format combination not allowed for blit."
- "Desired resource size is greater than max renderbuffer size."
- "Desired resource size is greater than max texture size."
- "Destination texture cannot be immutable."
- "Destination texture is not a valid texture object."
- "Destination texture too small."
- "Disable fast math in atan and invariance cases when running below macOS 12.0"
- "Disable programmable blending in order to test read_write pixel local storage textures"
- "Disable raster order groups in order to test pixel local storage memory barriers"
- "Disable support for GL_OES_get_program_binary"
- "Disable support for OES_draw_buffers_indexed and EXT_draw_buffers_indexed"
- "Disable support for anisotropic filtering"
- "Disable tier2 read_write textures in order to test tier1 support"
- "Disables multi-threaded decompression of compressed texture formats"
- "Disables saving programs to the cache"
- "Dispatch indirect buffer must be bound."
- "Do not create swizzled views of stencil textures"
- "Draw buffer greater than MAX_DRAW_BUFFERS."
- "Draw buffer must be zero when using depth or stencil."
- "Draw framebuffer has no attachments and no enabled, texture-backed pixel local storage planes."
- "Draw indirect buffer must be bound."
- "Draw mode must match current transform feedback object's draw mode."
- "Dual-source blending functions limit the number of supported draw buffers."
- "EGL image internal format is not supported as a renderbuffer."
- "EGL image internal format is not supported as a texture."
- "EGL image is not valid."
- "EGL_ANGLE_device_eagl"
- "EGL_ANGLE_platform_device_context_volatile_eagl"
- "EGL_ANGLE_robust_resource_initialization not enabled."
- "EXT/OES_draw_buffers_indexed is not available."
- "EXT/OES_draw_buffers_indexed or ES 3.1 are required but not available."
- "Each cubemap face must have equal width and height."
- "Element value exceeds element range."
- "Element value exceeds maximum element index."
- "Emulate ANGLE_shader_pixel_local_storage using shader images"
- "Emulate DontCare loadAction with Clear loadAction. The clear values will be randomized."
- "Enable EXT_multisampled_render_to_texture on non tiled GPUs."
- "Enable multi-draw and base vertex base instance extensions for non-WebGL contexts if they are emulated."
- "Enable to cache compiled shaders"
- "EndTiling called without corresponding StartTiling."
- "Enum 0x%04X is currently not supported."
- "Enum requires GLES 3.0"
- "Enum requires GLES 3.1"
- "Even if FrameCapture is enabled, enable GL_OES_get_program_binary"
- "Every binding point used in transform feedback mode must have a buffer object bound."
- "Expected a program name, but found a shader name."
- "Expected a shader name, but found a program name."
- "Extension is not disablable."
- "Extension is not enabled."
- "Extension is not requestable."
- "External texture attached to framebuffer is not YUV."
- "External texture extension not enabled"
- "Failed to allocate host memory"
- "Failed to get builtin compute function."
- "Failed to retrieve blit vertex shader \"blitVS\""
- "Failed to retrieve blit vertex shader \"clearVS\""
- "Feedback loop formed between Framebuffer and active Texture."
- "Fence must be set."
- "Flush after calls to StreamVertexData to work around driver bugs."
- "Flushed range does not fit into buffer mapping dimensions."
- "Force Depth24Stencil8 format as unsupported."
- "Force GL error checking (i.e. prevent applications from disabling error checking"
- "Force depth attachment initialization on clear ops"
- "Force flush after drawcall use shadow map for intel device."
- "Force the minimum GL_MAX_VERTEX_ATTRIBS that the context's client version allows."
- "Force-enable robust resource init"
- "Force-enable shader variable initialization"
- "Format cannot be GL_DEPTH_COMPONENT or GL_DEPTH_STENCIL if target is GL_TEXTURE_3D"
- "Format must match internal format."
- "Fragment output color index must be zero or one."
- "Fragment shader output type does not match the bound framebuffer attachment type."
- "Framebuffer cannot have images attached to color attachment points on or after COLOR_ATTACHMENT0 + MAX_COLOR_ATTACHMENTS_WITH_ACTIVE_PIXEL_LOCAL_STORAGE_ANGLE."
- "Framebuffer cannot have images attached to color attachment points on or after COLOR_ATTACHMENT0 + MAX_COMBINED_DRAW_BUFFERS_AND_PIXEL_LOCAL_STORAGE_PLANES_ANGLE - <n>."
- "Framebuffer is incomplete: All attachments must be unique."
- "Framebuffer is incomplete: All textures must have fixed samples if paired with multisample renderbuffers."
- "Framebuffer is incomplete: Attachment depth is greater than MAX_FRAMEBUFFER_LAYERS."
- "Framebuffer is incomplete: Attachment has zero size."
- "Framebuffer is incomplete: Attachment is an incomplete cube map."
- "Framebuffer is incomplete: Attachment is not renderable."
- "Framebuffer is incomplete: Attachment layer is greater than texture layer count."
- "Framebuffer is incomplete: Attachment level is not in the [base level, max level] range."
- "Framebuffer is incomplete: Attachment level not equal to the base level and the texture is not mipmap complete."
- "Framebuffer is incomplete: Attachment samples are greater than the maximum supported samples for this format."
- "Framebuffer is incomplete: Attachments are not all the same size."
- "Framebuffer is incomplete: Attachments have different sample counts."
- "Framebuffer is incomplete: Attachments have inconsistent bit plane counts."
- "Framebuffer is incomplete: Attachments have inconsistent fixed sample locations."
- "Framebuffer is incomplete: Attachments have inconsistent multiview base view."
- "Framebuffer is incomplete: Attachments have inconsistent multiview enabled state."
- "Framebuffer is incomplete: Attachments have inconsistent multiview view counts."
- "Framebuffer is incomplete: Depth and stencil attachments are not the same."
- "Framebuffer is incomplete: Depth attachment has no depth bits."
- "Framebuffer is incomplete: Depth stencil attachment has no depth bits or no stencil bits."
- "Framebuffer is incomplete: Depth stencil sample count must be divisible by the color sample count."
- "Framebuffer is incomplete: Depth stencil texture in color attachment."
- "Framebuffer is incomplete: Framebuffer is surfaceless."
- "Framebuffer is incomplete: If an attachments are layered, they must all be the same texture type."
- "Framebuffer is incomplete: If one attachment is layered, all must be layered."
- "Framebuffer is incomplete: Internal error."
- "Framebuffer is incomplete: Invalid framebuffer configuration for foveated rendering."
- "Framebuffer is incomplete: No attachments and default size is zero."
- "Framebuffer is incomplete: Separate depth and stencil buffers are unsupported."
- "Framebuffer is incomplete: Stencil attachment has depth bits."
- "Framebuffer is incomplete: Stencil attachment has no stencil bits."
- "Framebuffer is incomplete: The total number of color bits exceeds the number of output bits supported."
- "Framebuffer is incomplete: WebGL depth stencil state is inconsistent."
- "Framebuffer layer cannot be less than 0 or greater than GL_MAX_FRAMEBUFFER_LAYERS_EXT."
- "GLES1-only function."
- "GL_"
- "GL_ANGLE_copy_texture_3d extension not available."
- "GL_ANGLE_get_image extension not enabled."
- "GL_ANGLE_shader_pixel_local_storage not enabled."
- "GL_ANGLE_texture_multisample or GLES 3.1 required."
- "GL_ANGLE_texture_multisample, GL_ANGLE_get_tex_level_parameter or GLES 3.1 required."
- "GL_ANGLE_texture_multisample_array not enabled."
- "GL_BLEND with floating-point color attachments requires the EXT_float_blend extension."
- "GL_BUFFER_MAP_POINTER can only be queried with GetBufferPointerv."
- "GL_EXT_YUV_target not enabled."
- "GL_EXT_geometry_shader or GL_OES_geometry_shader extension not enabled."
- "GL_EXT_protected_textures not enabled."
- "GL_EXT_shader_framebuffer_fetch_non_coherent not enabled."
- "GL_EXT_tessellation_shader extension not enabled."
- "GL_FIXED is not supported in WebGL."
- "GL_KHR_blend_equation_advanced extension not enabled."
- "GL_NV_fence is not supported"
- "GL_OES_point_size_array not enabled."
- "GL_OES_tessellation_shader extension not enabled."
- "GL_QCOM_texture_foveated not enabled"
- "If buffer is nonzero, it must match the name of an existing buffer object."
- "If count is greater than zero, source and type cannot be GL_DONT_CARE."
- "If false, parts of the compile job cannot be parallelized"
- "If false, parts of the link job cannot be parallelized"
- "If the read buffer contains fixed-point or floating-point values, the draw buffer must as well."
- "If the read buffer contains fixed-point values, the draw buffer must as well."
- "If the read buffer contains signed integer values the draw buffer must as well."
- "If the read buffer contains unsigned integer values the draw buffer must as well."
- "If true, sub tasks of the link job are always threaded, regardless of GL_KHR_parallel_shader_compile"
- "Index exceeds active uniform block count."
- "Index is greater than or equal to the number of TRANSFORM_FEEDBACK_BUFFER indexed binding points."
- "Index is greater than the maximum supported color attachments"
- "Index must be less than MAX_ATOMIC_COUNTER_BUFFER_BINDINGS."
- "Index must be less than MAX_DRAW_BUFFERS."
- "Index must be less than MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS."
- "Index must be less than MAX_UNIFORM_BUFFER_BINDINGS."
- "Index must be less than MAX_VERTEX_ATTRIBS."
- "Index must be less than program active uniform block count."
- "Index must be less than program active uniform count."
- "Index must be less than the number of workgroup dimensions (3)."
- "Index must be less than the transform feedback varying count in the program."
- "Index must be less than the value of SAMPLES."
- "Index must be within [0, MAX_IMAGE_UNITS)."
- "Index must be within [0, MAX_SHADER_STORAGE_BUFFER_BINDINGS)."
- "Index must be within [0, MAX_VERTEX_ATTRIB_BINDINGS)."
- "Index must be within [0, NUM_EXTENSIONS)."
- "Index must be within [0, NUM_REQUESTABLE_EXTENSIONS_ANGLE)."
- "Inject asm() statements into loop bodies to force all loops to be treated as having side effects and not optimized out."
- "Insert explicit casts for float/double/unsigned/signed int on macOS 10.15 with Intel driver"
- "Insufficient buffer size"
- "Insufficient buffer size."
- "Internal error compiling Metal shader:\n"
- "Internal error compiling shader with Metal backend.\n"
- "Internal error: unknown internal format."
- "Internal format is not an accepted sized internal format."
- "Internal format is not renderable."
- "Internalformat is one of the unsupported unsized base internalformats."
- "Invalid Attachment Type."
- "Invalid OpenGL profile mask."
- "Invalid Shader count."
- "Invalid access bits when mapping buffer for reading"
- "Invalid access bits."
- "Invalid attachment when a user framebuffer is bound."
- "Invalid attachment when the default framebuffer is bound."
- "Invalid blend equation."
- "Invalid blend function."
- "Invalid blit filter."
- "Invalid blit mask."
- "Invalid boolean value. Must be GL_FALSE or GL_TRUE."
- "Invalid bufSize."
- "Invalid buffer binding size."
- "Invalid buffer target."
- "Invalid buffer usage enum."
- "Invalid buffer usage flags."
- "Invalid client vertex array type."
- "Invalid clip plane."
- "Invalid combination of format, type and internalFormat."
- "Invalid combination of pack parameters for WebGL."
- "Invalid combination of unpack parameters for WebGL."
- "Invalid compressed image size."
- "Invalid copy texture format combination."
- "Invalid debug severity."
- "Invalid debug source."
- "Invalid debug type."
- "Invalid depth enum."
- "Invalid destination texture type."
- "Invalid draw buffer."
- "Invalid draw mode."
- "Invalid element range."
- "Invalid enum provided."
- "Invalid fence object."
- "Invalid fog density (must be nonnegative)."
- "Invalid fog mode."
- "Invalid fog parameter."
- "Invalid format and type combination."
- "Invalid format."
- "Invalid framebuffer target."
- "Invalid handle type."
- "Invalid identifier."
- "Invalid image layout."
- "Invalid internal format 0x%04X."
- "Invalid level count."
- "Invalid light model parameter."
- "Invalid light parameter."
- "Invalid light."
- "Invalid logical operation."
- "Invalid mask bits."
- "Invalid material face."
- "Invalid material parameter."
- "Invalid matrix mode."
- "Invalid memory barrier bit."
- "Invalid memory object parameter."
- "Invalid memory object."
- "Invalid name."
- "Invalid operation on multisampled framebuffer"
- "Invalid or incompatible shader binary."
- "Invalid or unsupported precision type."
- "Invalid or unsupported texture target."
- "Invalid origin enum."
- "Invalid parameter name for framebuffer attachment."
- "Invalid parameters given for GL_TEXTURE_FOVEATED_FEATURE_BITS_QCOM"
- "Invalid perf monitor counter group."
- "Invalid perf monitor counter."
- "Invalid perf monitor."
- "Invalid pixel local storage Load Operation: 0x%04X."
- "Invalid pixel local storage Store Operation: 0x%04X."
- "Invalid pixel local storage internal format."
- "Invalid pixel local storage texture type."
- "Invalid pname."
- "Invalid point parameter value (must be non-negative)."
- "Invalid point parameter."
- "Invalid point size (must be positive)."
- "Invalid pointer query."
- "Invalid polygon mode."
- "Invalid primitive mode."
- "Invalid program interface."
- "Invalid program resource index."
- "Invalid program resource property."
- "Invalid projection matrix. Left/right, top/bottom, near/far intervals cannot be zero, and near/far cannot be less than zero."
- "Invalid propCount."
- "Invalid provoking vertex."
- "Invalid query Id."
- "Invalid query target."
- "Invalid query type."
- "Invalid read buffer"
- "Invalid region for compressed texture format."
- "Invalid renderbuffer internalformat."
- "Invalid renderbuffer target."
- "Invalid shader binary format."
- "Invalid shader type."
- "Invalid shading model."
- "Invalid shading rate."
- "Invalid source texture height or width."
- "Invalid source texture level."
- "Invalid stencil."
- "Invalid stride for built-in vertex attribute."
- "Invalid target."
- "Invalid texture combine mode."
- "Invalid texture combine operand."
- "Invalid texture combine source."
- "Invalid texture environment mode."
- "Invalid texture environment parameter."
- "Invalid texture environment scale."
- "Invalid texture environment target."
- "Invalid texture target and format combination."
- "Invalid to draw with foveation while current bound program uses tessellation or geometry shaders"
- "Invalid type for built-in vertex attribute."
- "Invalid type."
- "Invalid uniform location"
- "Invalid value for EGL_PLATFORM_ANGLE_DEVICE_CONTEXT_VOLATILE_EAGL_ANGLE attrib"
- "Invalid value for condition."
- "Invalid value for flags."
- "Invalid value for timeout."
- "Invalid width."
- "Invalid wrap mode for texture type."
- "It is a undefined behaviour to render without vertex shader stage or fragment shader stage."
- "It is invalid to change default FBO's attachments"
- "It is undefined behavior to use a pixel pack buffer that is bound for transform feedback."
- "It is undefined behavior to use a pixel unpack buffer that is bound for transform feedback."
- "It is undefined behavior to use a vertex buffer that is bound for transform feedback."
- "It is undefined behavior to use an element array buffer that is bound for transform feedback."
- "It is undefined behavior to use an uniform buffer that is bound for transform feedback."
- "It is undefined behaviour to have a used but unbound uniform buffer."
- "It is undefined behaviour to use a uniform buffer that is too small."
- "Ith value does not match COLOR_ATTACHMENTi or NONE."
- "Label length is larger than GL_MAX_LABEL_LENGTH."
- "Layer invalid for framebuffer texture attachment."
- "Layer is larger than texture depth."
- "Length must not be zero."
- "Level is larger than texture level count."
- "Level is negative."
- "Level of detail outside of range."
- "Light parameter out of range."
- "Linear blit not supported in this extension."
- "Load Operation GL_LOAD_OP_LOAD_ANGLE is invalid for memoryless planes."
- "Loads metal shaders from blob cache. Useful if compile_metal_shaders was used to generate shaders."
- "Location cannot be less than 0."
- "Location lengths must not be greater than 1024 characters."
- "Location must be less than (MAX_VERTEX_UNIFORM_VECTORS + MAX_FRAGMENT_UNIFORM_VECTORS) * 4"
- "Location name lengths must not be greater than 256 characters."
- "MAX_NUM_ACTIVE_VARIABLES requires a buffer or block interface."
- "MSL 2.1 is required to support all the features of OpenGL ES 2.0"
- "Mac GPU Family 2 is required to support all the features of OpenGL ES 2.0"
- "Make egl surface uncurrent when calling eglDestroySurface(), if the surface is still bound by the context of current render thread"
- "Makes bufferSubData always update via CPU"
- "Mapped range does not fit into buffer dimensions."
- "MaskNumber cannot be greater than or equal to the value of MAX_SAMPLE_MASK_WORDS."
- "Material parameter out of range."
- "Message length is larger than GL_MAX_DEBUG_MESSAGE_LENGTH."
- "Metal backend encountered an error"
- "Metal backend encountered an error: \n"
- "Metal buffers can be managed, shared, or private. Sometimes managed is fastest"
- "Metal buffers can be managed, shared, or private. Sometimes shared is fastest"
- "Metal iOS has a limit on the number of color target bits per pixel."
- "Mip level invalid for framebuffer texture attachment."
- "Mipmap level must be 0 when attaching a texture."
- "Mismatch between texture format and sampler type (signed/unsigned/float/shadow)."
- "Mismatched pixel local storage backing texture sizes."
- "Mismatched shader binary and shader object type."
- "Missing read attachment."
- "More parameters are required than were provided."
- "Multisampled depth/stencil blit is not supported by this extension."
- "Must have element array buffer bound."
- "NVIDIA GPUs are unsupported due to scarcity of the hardware."
- "Name contains invalid characters."
- "Near value cannot be greater than far."
- "Need to map buffer for either reading or writing."
- "Negative baseViewIndex."
- "Negative buffer size."
- "Negative count."
- "Negative layer."
- "Negative length."
- "Negative maxcount."
- "Negative number of attachments."
- "Negative offset."
- "Negative size."
- "No Texture is bound to the specified target."
- "No Transform Feedback object is active."
- "No active compute shader stage in this program."
- "No active geometry shader stage in this program."
- "No active program for the compute shader stage."
- "No active read framebuffer."
- "No defined conversion between clear value and attachment format."
- "No element array buffer and no pointer."
- "No program binary formats supported."
- "Not a valid compressed texture format."
- "Not a valid sync pointer."
- "Not a valid texture object name."
- "Not an allowed program resource property for this program interface"
- "Not enough space in bound transform feedback buffers."
- "OVR_multiview or OVR_multiview2 are not available."
- "Object cannot be used because it has not been generated."
- "Offset and size must be multiple of 4."
- "Offset must be a multiple of sizeof(uint) in basic machine units."
- "Offset must be a multiple of the passed in datatype."
- "Offset must be multiple of value of SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT."
- "Offset must be multiple of value of TEXTURE_BUFFER_OFFSET_ALIGNMENT."
- "Offset must be multiple of value of UNIFORM_BUFFER_OFFSET_ALIGNMENT."
- "Offset must be zero for external buffers"
- "Offset overflows texture dimensions."
- "On some GPUs, program binaries don't contain transform feedback varyings"
- "On some architectures using a shadow buffer can be faster for certain size buffers"
- "On systems that support both buffer' memory allocation on GPU and shared memory (such as macOS), force using GPU memory allocation for buffers everytime or not."
- "Only NONE or BACK are valid draw buffers for the default framebuffer"
- "Only UNSIGNED_SHORT and UNSIGNED_BYTE types are supported."
- "Only array uniforms may have count > 1."
- "Only nearest filtering can be used when blitting buffers other than the color buffer."
- "Only whole-buffer blit is supported from a multisampled read buffer in this extension."
- "Only whole-buffer depth and stencil blits are supported by this extension."
- "OpenGL ES 1.x or 3.2 Required"
- "OpenGL ES 2.0 Required."
- "OpenGL ES 3.0 Required."
- "OpenGL ES 3.1 Required"
- "OpenGL ES 3.2 Required"
- "OpenGL GLSL "
- "OpenGL profile mask requires an OpenGL context."
- "Operation not permitted while pixel local storage is active."
- "Other query is active."
- "PLS"
- "Packed depth stencil texture/buffer must not be mixed with other texture/buffer."
- "Parameter outside of bounds."
- "Params less than 0 or greater than GL_MAX_FRAMEBUFFER_HEIGHT."
- "Params less than 0 or greater than GL_MAX_FRAMEBUFFER_SAMPLES."
- "Params less than 0 or greater than GL_MAX_FRAMEBUFFER_WIDTH."
- "Passed in texture target and format must match the one originally used to define the texture."
- "Passed in texture type must match the one originally used to define the texture."
- "Perf monitor is not started."
- "Pixel data cannot be null."
- "Pixel data must be null."
- "Pixel density must be between 0.0 and 1.0"
- "Pixel local storage backing texture dimensions not equal to the rendering area."
- "Pixel local storage does not support more than 255 nested interruptions."
- "Pixel local storage is not active."
- "Pixel local storage on the draw framebuffer is interrupted."
- "Pixel local storage on the draw framebuffer is not interrupted."
- "Plane cannot be less than 0."
- "Plane must be less than GL_MAX_PIXEL_LOCAL_STORAGE_PLANES_ANGLE."
- "Planes must be greater than 0."
- "Planes must be less than or equal to GL_MAX_PIXEL_LOCAL_STORAGE_PLANES_ANGLE."
- "Primcount must be greater than or equal to zero."
- "Primitive mode is incompatible with the input primitive type of the geometry shader."
- "Prints the source to a shader before it's compiled."
- "Program and framebuffer YUV output state does not match."
- "Program binary format is not valid."
- "Program doesn't exist."
- "Program not linked."
- "Program object expected."
- "Program object was not linked with its PROGRAM_SEPARABLE status set."
- "Program pipeline does not exist."
- "Program pipeline link failed"
- "Query extension not enabled."
- "Query is active."
- "Query is not active."
- "Query type does not match target."
- "Read and draw framebuffers must both exist for a blit to succeed."
- "Read and write color attachments cannot be the same image."
- "Read and write depth stencil attachments cannot be the same image."
- "Read buffer has no attachment."
- "Read buffer is GL_NONE."
- "Read buffer must be GL_NONE or GL_BACK when reading from the default framebuffer."
- "Rectangle texture cannot have a compressed format."
- "Red, green and blue color writes must be enabled when writing to YUV framebuffers."
- "Render pipeline without vertex shader is invalid."
- "Renderbuffer width and height cannot be negative and cannot exceed maximum texture size."
- "Requested focal point exceeds the supported maximum"
- "Requested layer exceeds the supported maximum"
- "Rescope global variables that are only used in one function to be function-local."
- "Reset status is not valid"
- "Sampler is not valid"
- "Sampler uniform value out of range."
- "Samples may not be zero."
- "Samples must not be greater than maximum supported value for the format."
- "Scaling and flipping in BlitFramebufferANGLE not supported by this implementation."
- "Set the context limits like frame capturing was enabled"
- "Shader attachment already has a shader."
- "Shader object expected."
- "Shader to be detached must be currently attached to the program."
- "Simultaneous use of GL_CONSTANT_ALPHA/GL_ONE_MINUS_CONSTANT_ALPHA and GL_CONSTANT_COLOR/GL_ONE_MINUS_CONSTANT_COLOR as color factors is not supported by this implementation."
- "Size for built-in vertex attribute is outside allowed range."
- "Size must be greater than 0"
- "Size must not exceed the size of clientbuffer"
- "SizedInternalformat must be color-renderable, depth-renderable, or stencil-renderable."
- "Some Apple platforms such as iOS allows separate depth and stencil buffers, whereas others such as macOS don't"
- "Some GPUs ignore alpha-to-coverage when [[sample_mask]] is written"
- "Some GPUs produce incorrect derivatives unless [[sample_mask]] is written"
- "Some users rely on a lost context notification if a GL_OUT_OF_MEMORY error occurs"
- "Source texture internal format is invalid."
- "Source texture is not a valid texture object."
- "Source texture must be a valid texture type."
- "Source texture must have a compressed internal format."
- "Source texture must level 0 defined."
- "Specified unit must be in [GL_TEXTURE0, GL_TEXTURE0 + GL_MAX_COMBINED_IMAGE_UNITS)"
- "Specified unit must be in [GL_TEXTURE0, GL_TEXTURE0 + GL_MAX_TEXTURE_UNITS)"
- "Staged GPU upload of some packed texture formats such as RGB9_E5 fail on Intel GPUs."
- "StartTiling called without corresponding EndTiling."
- "Stencil reference and mask values must be the same for front facing and back facing triangles."
- "Stride is over the maximum stride allowed by WebGL."
- "Stride must be a multiple of the passed in datatype."
- "Stride must be within [0, MAX_VERTEX_ATTRIB_STRIDE)."
- "Surface not compatible with OpenGL Desktop."
- "Sync object does not exist."
- "Target is TRANSFORM_FEEDBACK_BUFFER and transform feedback is currently active."
- "Target must be TEXTURE_2D_MULTISAMPLE_ARRAY_OES."
- "Target must be TEXTURE_BUFFER."
- "Tessellation requires both control and evaluation shaders."
- "Textarget must match the texture target type."
- "Textarget must match the texture target type. Requested: %d Texture's: %d label: %s"
- "Texture base level out of range"
- "Texture buffer extension not available."
- "Texture buffer offset + size must be less than or equal to BUFFER_SIZE."
- "Texture buffer size must be a positive integer."
- "Texture dimensions must all be greater than zero."
- "Texture dimensions must be power-of-two."
- "Texture filter not recognized."
- "Texture format does not support mipmap generation."
- "Texture formats are not compatible"
- "Texture has incompatible target."
- "Texture is compressed, call GetCompressedTexImage instead."
- "Texture is compressed."
- "Texture is immutable."
- "Texture is not a three-dimensional, two-dimensional array, two-dimensional multisample array, cube map, or cube map array texture."
- "Texture is not compressed, call GetTexImage instead."
- "Texture is not cubemap complete. All cubemaps faces must be defined and be the same size."
- "Texture is not immutable."
- "Texture is not the name of an immutable texture object or a buffer texture."
- "Texture level does not exist."
- "Texture level must be zero."
- "Texture only supports NEAREST and LINEAR filtering."
- "Texture wrap mode not recognized."
- "The active Transform Feedback object is not paused."
- "The active Transform Feedback object is paused."
- "The active program has specified no output variables to record."
- "The active read framebuffer object has multiview attachments."
- "The cubemap depth must be a multiple of 6."
- "The current context doesn't support setting a non-zero divisor on the attribute with index zero. Please reorder the attributes in your vertex shader so that attribute zero can have a zero divisor."
- "The default framebuffer must have exactly one draw buffer."
- "The destination level of the destination texture must be defined."
- "The draw command is unsupported when transform feedback is active and not paused."
- "The explicit flushing bit may only be set if the buffer is mapped for writing."
- "The memory object is immutable."
- "The number of views in the active program and draw framebuffer does not match."
- "The provided parameters overflow with the provided buffer."
- "The read and write copy regions alias memory."
- "The renderer can cheaply break a render pass."
- "The renderer supports MSAA depth auto resolve at the end of render pass"
- "The renderer supports MSAA stencil auto resolve at the end of render pass"
- "The renderer supports MSAA store and resolve in the same pass"
- "The renderer supports MTL(Shared)Event"
- "The renderer supports base vertex instanced draw"
- "The renderer supports buffer read and write in the same shader"
- "The renderer supports changing sampler's compare mode outside shaders"
- "The renderer supports explicit memory barrier"
- "The renderer supports generating multiple mipmaps per pass"
- "The renderer supports non uniform compute shader dispatch's group size"
- "The renderer supports sample_compare with gradients"
- "The renderer supports sample_compare with lod"
- "The renderer supports stencil output from fragment shader"
- "The renderer supports texture swizzle"
- "The renderer supports using inline constant data for small client vertex data"
- "The renderer supports variable rasterization rate"
- "The source EGL image is incompatible with the target texture type."
- "The specified dimensions are outside of the bounds of the texture."
- "The texture is a non-power-of-two texture."
- "The texture is not complete."
- "The value of TEXTURE_IMMUTABLE_FORMAT for the texture currently bound to target on the active texture unit is true."
- "There is an active query for target GL_TIME_ELAPSED_EXT when the number of views in the active draw framebuffer is greater than 1."
- "There is an active transform feedback object when the number of views in the active draw framebuffer is greater than 1."
- "There is no current program object specified by UseProgram, there is a current program pipeline object, and that object is empty (no executable code is installed for any stage)."
- "Transform feedback has a buffer bound to multiple outputs."
- "Transform feedback is already active."
- "Transform feedback object that does not exist."
- "Turn this feature on to disallow Compute Shader based mipmap generation. Compute Shader based mipmap generation might cause GPU hang on some older iOS devices."
- "Turn this on to allow transform feedback in Metal using a 2-pass VS for GLES3."
- "Two textures of different types use the same sampler location."
- "Type is INT_10_10_10_2_OES or UNSIGNED_INT_10_10_10_2_OES and size is not 3 or 4."
- "Type is INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV and size is not 4."
- "Uniform size does not match uniform method."
- "Uniform type does not match uniform method."
- "Unknown parameter value."
- "Unpack alignment must be 1, 2, 4 or 8."
- "Unrecognized shader stage bit."
- "Unsupported format conversion"
- "Usage flags must only include bits defined by GL_ANGLE_external_objects_flags"
- "Used to check the backend works when the device's advertized limit is less than the code's limit"
- "Value must be greater than zero."
- "Value must be less than or equal to MAX_PATCH_SIZE."
- "Vertex array does not exist."
- "Vertex attribute size must be 1, 2, 3, or 4."
- "Vertex buffer is not big enough for the draw call"
- "Vertex shader input type does not match the type of the bound vertex attribute."
- "Viewport size cannot be negative."
- "ViewportIndex"
- "When tessellation is active the primitive mode must be GL_PATCHES."
- "When tessellation is not active the primitive mode must not be GL_PATCHES."
- "When uploading data to IOSurface-backed textures, use a staging buffer."
- "Width and height must be less than or equal to GL_MAX_TEXTURE_SIZE."
- "Write shader source to temp directory"
- "Write translated shaders to temp directory"
- "Zero is bound to target."
- "abs(00D"
- "abs(10D"
- "abs(20D"
- "abs(30D"
- "access is not one of the supported tokens."
- "all(10F"
- "all(20F"
- "all(30F"
- "allowSamplerCompareLod"
- "any(10F"
- "any(20F"
- "any(30F"
- "atomicAdd(00E00E"
- "atomicAnd(00E00E"
- "atomicCompSwap(00E00E00E"
- "atomicCounter(00G"
- "atomicCounterDecrement(00G"
- "atomicCounterIncrement(00G"
- "atomicExchange(00E00E"
- "atomicMax(00E00E"
- "atomicMin(00E00E"
- "atomicOr(00E00E"
- "atomicXor(00E00E"
- "baseViewIndex+numViews cannot be greater than GL_MAX_ARRAY_TEXTURE_LAYERS."
- "bitCount(00E"
- "bitCount(10E"
- "bitCount(20E"
- "bitCount(30E"
- "bitfieldExtract(00D00D00D"
- "bitfieldExtract(00E00D00D"
- "bitfieldExtract(10D00D00D"
- "bitfieldExtract(10E00D00D"
- "bitfieldExtract(20D00D00D"
- "bitfieldExtract(20E00D00D"
- "bitfieldExtract(30D00D00D"
- "bitfieldExtract(30E00D00D"
- "bitfieldInsert(00D00D00D00D"
- "bitfieldInsert(00E00E00D00D"
- "bitfieldInsert(10D10D00D00D"
- "bitfieldInsert(10E10E00D00D"
- "bitfieldInsert(20D20D00D00D"
- "bitfieldInsert(20E20E00D00D"
- "bitfieldInsert(30D30D00D00D"
- "bitfieldInsert(30E30E00D00D"
- "bitfieldReverse(00E"
- "bitfieldReverse(10E"
- "bitfieldReverse(20E"
- "bitfieldReverse(30E"
- "buf"
- "checkPackedDepthStencilAttachment"
- "clamp(00E00E00E"
- "clamp(10E00E00E"
- "clamp(10E10E10E"
- "clamp(20E00E00E"
- "clamp(20E20E20E"
- "clamp(30E00E00E"
- "clamp(30E30E30E"
- "components is not one of GL_RGB, GL_RGBA, GL_ALPHA or GL_NONE."
- "cw"
- "dataSize is too small"
- "dimension out of bounds"
- "drawbuffer"
- "eglQueryTimestampSupportedANDROID"
- "equal(10F10F"
- "equal(20F20F"
- "equal(30F30F"
- "false (override)"
- "findLSB(00E"
- "findLSB(10E"
- "findLSB(20E"
- "findLSB(30E"
- "findMSB(00E"
- "findMSB(10E"
- "findMSB(20E"
- "findMSB(30E"
- "format is not one of supported image unit formats."
- "frexp(00B00D"
- "frexp(10B10D"
- "frexp(20B20D"
- "frexp(30B30D"
- "function parameter array must be sized at compile time"
- "glAccum"
- "glAreTexturesResident"
- "glArrayElement"
- "glBegin"
- "glBeginConditionalRender"
- "glBeginQueryIndexed"
- "glBindBuffersBase"
- "glBindBuffersRange"
- "glBindFragDataLocation"
- "glBindFragDataLocationIndexed"
- "glBindImageTextures"
- "glBindSamplers"
- "glBindTextureUnit"
- "glBindTextures"
- "glBindVertexBuffers"
- "glBitmap"
- "glBlitNamedFramebuffer"
- "glBufferStorage"
- "glCallList"
- "glCallLists"
- "glCheckNamedFramebufferStatus"
- "glClampColor"
- "glClearAccum"
- "glClearBufferData"
- "glClearBufferSubData"
- "glClearDepth"
- "glClearIndex"
- "glClearNamedBufferData"
- "glClearNamedBufferSubData"
- "glClearNamedFramebufferfi"
- "glClearNamedFramebufferfv"
- "glClearNamedFramebufferiv"
- "glClearNamedFramebufferuiv"
- "glClearTexImage"
- "glClearTexSubImage"
- "glClipControl"
- "glClipPlane"
- "glColor3b"
- "glColor3bv"
- "glColor3d"
- "glColor3dv"
- "glColor3f"
- "glColor3fv"
- "glColor3i"
- "glColor3iv"
- "glColor3s"
- "glColor3sv"
- "glColor3ub"
- "glColor3ubv"
- "glColor3ui"
- "glColor3uiv"
- "glColor3us"
- "glColor3usv"
- "glColor4b"
- "glColor4bv"
- "glColor4d"
- "glColor4dv"
- "glColor4fv"
- "glColor4i"
- "glColor4iv"
- "glColor4s"
- "glColor4sv"
- "glColor4ubv"
- "glColor4ui"
- "glColor4uiv"
- "glColor4us"
- "glColor4usv"
- "glColorMaterial"
- "glColorP3ui"
- "glColorP3uiv"
- "glColorP4ui"
- "glColorP4uiv"
- "glCompressedTexImage1D"
- "glCompressedTexSubImage1D"
- "glCompressedTextureSubImage1D"
- "glCompressedTextureSubImage2D"
- "glCompressedTextureSubImage3D"
- "glCopyNamedBufferSubData"
- "glCopyPixels"
- "glCopyTexImage1D"
- "glCopyTexSubImage1D"
- "glCopyTextureSubImage1D"
- "glCopyTextureSubImage2D"
- "glCopyTextureSubImage3D"
- "glCreateBuffers"
- "glCreateFramebuffers"
- "glCreateProgramPipelines"
- "glCreateQueries"
- "glCreateRenderbuffers"
- "glCreateSamplers"
- "glCreateTextures"
- "glCreateTransformFeedbacks"
- "glCreateVertexArrays"
- "glDeleteLists"
- "glDepthRange"
- "glDepthRangeArrayv"
- "glDepthRangeIndexed"
- "glDisableVertexArrayAttrib"
- "glDrawArraysInstancedBaseInstance"
- "glDrawBuffer"
- "glDrawElementsInstancedBaseInstance"
- "glDrawElementsInstancedBaseVertexBaseInstance"
- "glDrawPixels"
- "glDrawTransformFeedback"
- "glDrawTransformFeedbackInstanced"
- "glDrawTransformFeedbackStream"
- "glDrawTransformFeedbackStreamInstanced"
- "glEdgeFlag"
- "glEdgeFlagPointer"
- "glEdgeFlagv"
- "glEnableVertexArrayAttrib"
- "glEnd"
- "glEndConditionalRender"
- "glEndList"
- "glEndQueryIndexed"
- "glEvalCoord1d"
- "glEvalCoord1dv"
- "glEvalCoord1f"
- "glEvalCoord1fv"
- "glEvalCoord2d"
- "glEvalCoord2dv"
- "glEvalCoord2f"
- "glEvalCoord2fv"
- "glEvalMesh1"
- "glEvalMesh2"
- "glEvalPoint1"
- "glEvalPoint2"
- "glFeedbackBuffer"
- "glFlushMappedNamedBufferRange"
- "glFogCoordPointer"
- "glFogCoordd"
- "glFogCoorddv"
- "glFogCoordf"
- "glFogCoordfv"
- "glFogi"
- "glFogiv"
- "glFramebufferFoveationConfigQCOM called on a framebuffer that has already been configured for foveated rendering"
- "glFramebufferFoveationParametersQCOM called on a framebuffer that has not been configured for foveated rendering"
- "glFramebufferTexture1D"
- "glFramebufferTexture3D"
- "glFrustum"
- "glGenLists"
- "glGenerateTextureMipmap"
- "glGetActiveAtomicCounterBufferiv"
- "glGetActiveSubroutineName"
- "glGetActiveSubroutineUniformName"
- "glGetActiveSubroutineUniformiv"
- "glGetActiveUniformName"
- "glGetBufferSubData"
- "glGetClipPlane"
- "glGetCompressedTexImage"
- "glGetCompressedTextureImage"
- "glGetCompressedTextureSubImage"
- "glGetDoublei_v"
- "glGetDoublev"
- "glGetFloati_v"
- "glGetFragDataIndex"
- "glGetInternalformati64v"
- "glGetLightiv"
- "glGetMapdv"
- "glGetMapfv"
- "glGetMapiv"
- "glGetMaterialiv"
- "glGetNamedBufferParameteri64v"
- "glGetNamedBufferParameteriv"
- "glGetNamedBufferPointerv"
- "glGetNamedBufferSubData"
- "glGetNamedFramebufferAttachmentParameteriv"
- "glGetNamedFramebufferParameteriv"
- "glGetNamedRenderbufferParameteriv"
- "glGetPixelMapfv"
- "glGetPixelMapuiv"
- "glGetPixelMapusv"
- "glGetPolygonStipple"
- "glGetProgramResourceLocationIndex"
- "glGetProgramStageiv"
- "glGetQueryBufferObjecti64v"
- "glGetQueryBufferObjectiv"
- "glGetQueryBufferObjectui64v"
- "glGetQueryBufferObjectuiv"
- "glGetQueryIndexediv"
- "glGetQueryObjecti64v"
- "glGetQueryObjectiv"
- "glGetQueryObjectui64v"
- "glGetSubroutineIndex"
- "glGetSubroutineUniformLocation"
- "glGetTexGendv"
- "glGetTexGenfv"
- "glGetTexGeniv"
- "glGetTexImage"
- "glGetTextureImage"
- "glGetTextureLevelParameterfv"
- "glGetTextureLevelParameteriv"
- "glGetTextureParameterIiv"
- "glGetTextureParameterIuiv"
- "glGetTextureParameterfv"
- "glGetTextureParameteriv"
- "glGetTextureSubImage"
- "glGetTransformFeedbacki64_v"
- "glGetTransformFeedbacki_v"
- "glGetTransformFeedbackiv"
- "glGetUniformSubroutineuiv"
- "glGetUniformdv"
- "glGetVertexArrayIndexed64iv"
- "glGetVertexArrayIndexediv"
- "glGetVertexArrayiv"
- "glGetVertexAttribLdv"
- "glGetVertexAttribdv"
- "glGetnColorTable"
- "glGetnCompressedTexImage"
- "glGetnConvolutionFilter"
- "glGetnHistogram"
- "glGetnMapdv"
- "glGetnMapfv"
- "glGetnMapiv"
- "glGetnMinmax"
- "glGetnPixelMapfv"
- "glGetnPixelMapuiv"
- "glGetnPixelMapusv"
- "glGetnPolygonStipple"
- "glGetnSeparableFilter"
- "glGetnTexImage"
- "glGetnUniformdv"
- "glIndexMask"
- "glIndexPointer"
- "glIndexd"
- "glIndexdv"
- "glIndexf"
- "glIndexfv"
- "glIndexi"
- "glIndexiv"
- "glIndexs"
- "glIndexsv"
- "glIndexub"
- "glIndexubv"
- "glInitNames"
- "glInterleavedArrays"
- "glInvalidateBufferData"
- "glInvalidateBufferSubData"
- "glInvalidateNamedFramebufferData"
- "glInvalidateNamedFramebufferSubData"
- "glInvalidateTexImage"
- "glInvalidateTexSubImage"
- "glIsList"
- "glLightModeli"
- "glLightModeliv"
- "glLighti"
- "glLightiv"
- "glLineStipple"
- "glListBase"
- "glLoadMatrixd"
- "glLoadName"
- "glLoadTransposeMatrixd"
- "glLoadTransposeMatrixf"
- "glMap1d"
- "glMap1f"
- "glMap2d"
- "glMap2f"
- "glMapBuffer"
- "glMapGrid1d"
- "glMapGrid1f"
- "glMapGrid2d"
- "glMapGrid2f"
- "glMapNamedBuffer"
- "glMapNamedBufferRange"
- "glMateriali"
- "glMaterialiv"
- "glMultMatrixd"
- "glMultTransposeMatrixd"
- "glMultTransposeMatrixf"
- "glMultiDrawArrays"
- "glMultiDrawArraysIndirect"
- "glMultiDrawArraysIndirectCount"
- "glMultiDrawElements"
- "glMultiDrawElementsBaseVertex"
- "glMultiDrawElementsIndirect"
- "glMultiDrawElementsIndirectCount"
- "glMultiTexCoord1d"
- "glMultiTexCoord1dv"
- "glMultiTexCoord1f"
- "glMultiTexCoord1fv"
- "glMultiTexCoord1i"
- "glMultiTexCoord1iv"
- "glMultiTexCoord1s"
- "glMultiTexCoord1sv"
- "glMultiTexCoord2d"
- "glMultiTexCoord2dv"
- "glMultiTexCoord2f"
- "glMultiTexCoord2fv"
- "glMultiTexCoord2i"
- "glMultiTexCoord2iv"
- "glMultiTexCoord2s"
- "glMultiTexCoord2sv"
- "glMultiTexCoord3d"
- "glMultiTexCoord3dv"
- "glMultiTexCoord3f"
- "glMultiTexCoord3fv"
- "glMultiTexCoord3i"
- "glMultiTexCoord3iv"
- "glMultiTexCoord3s"
- "glMultiTexCoord3sv"
- "glMultiTexCoord4d"
- "glMultiTexCoord4dv"
- "glMultiTexCoord4fv"
- "glMultiTexCoord4i"
- "glMultiTexCoord4iv"
- "glMultiTexCoord4s"
- "glMultiTexCoord4sv"
- "glMultiTexCoordP1ui"
- "glMultiTexCoordP1uiv"
- "glMultiTexCoordP2ui"
- "glMultiTexCoordP2uiv"
- "glMultiTexCoordP3ui"
- "glMultiTexCoordP3uiv"
- "glMultiTexCoordP4ui"
- "glMultiTexCoordP4uiv"
- "glNamedBufferData"
- "glNamedBufferStorage"
- "glNamedBufferSubData"
- "glNamedFramebufferDrawBuffer"
- "glNamedFramebufferDrawBuffers"
- "glNamedFramebufferParameteri"
- "glNamedFramebufferReadBuffer"
- "glNamedFramebufferRenderbuffer"
- "glNamedFramebufferTexture"
- "glNamedFramebufferTextureLayer"
- "glNamedRenderbufferStorage"
- "glNamedRenderbufferStorageMultisample"
- "glNewList"
- "glNormal3b"
- "glNormal3bv"
- "glNormal3d"
- "glNormal3dv"
- "glNormal3fv"
- "glNormal3i"
- "glNormal3iv"
- "glNormal3s"
- "glNormal3sv"
- "glNormalP3ui"
- "glNormalP3uiv"
- "glOrtho"
- "glPassThrough"
- "glPatchParameterfv"
- "glPixelMapfv"
- "glPixelMapuiv"
- "glPixelMapusv"
- "glPixelStoref"
- "glPixelTransferf"
- "glPixelTransferi"
- "glPixelZoom"
- "glPointParameteri"
- "glPointParameteriv"
- "glPolygonMode"
- "glPolygonOffsetClamp"
- "glPolygonStipple"
- "glPopAttrib"
- "glPopClientAttrib"
- "glPopName"
- "glPrimitiveRestartIndex"
- "glPrioritizeTextures"
- "glProgramUniform1d"
- "glProgramUniform1dv"
- "glProgramUniform2d"
- "glProgramUniform2dv"
- "glProgramUniform3d"
- "glProgramUniform3dv"
- "glProgramUniform4d"
- "glProgramUniform4dv"
- "glProgramUniformMatrix2dv"
- "glProgramUniformMatrix2x3dv"
- "glProgramUniformMatrix2x4dv"
- "glProgramUniformMatrix3dv"
- "glProgramUniformMatrix3x2dv"
- "glProgramUniformMatrix3x4dv"
- "glProgramUniformMatrix4dv"
- "glProgramUniformMatrix4x2dv"
- "glProgramUniformMatrix4x3dv"
- "glProvokingVertex"
- "glPushAttrib"
- "glPushClientAttrib"
- "glPushName"
- "glQueryCounter"
- "glRasterPos2d"
- "glRasterPos2dv"
- "glRasterPos2f"
- "glRasterPos2fv"
- "glRasterPos2i"
- "glRasterPos2iv"
- "glRasterPos2s"
- "glRasterPos2sv"
- "glRasterPos3d"
- "glRasterPos3dv"
- "glRasterPos3f"
- "glRasterPos3fv"
- "glRasterPos3i"
- "glRasterPos3iv"
- "glRasterPos3s"
- "glRasterPos3sv"
- "glRasterPos4d"
- "glRasterPos4dv"
- "glRasterPos4f"
- "glRasterPos4fv"
- "glRasterPos4i"
- "glRasterPos4iv"
- "glRasterPos4s"
- "glRasterPos4sv"
- "glRectd"
- "glRectdv"
- "glRectf"
- "glRectfv"
- "glRecti"
- "glRectiv"
- "glRects"
- "glRectsv"
- "glRenderMode"
- "glRotated"
- "glScaled"
- "glScissorArrayv"
- "glScissorIndexed"
- "glScissorIndexedv"
- "glSecondaryColor3b"
- "glSecondaryColor3bv"
- "glSecondaryColor3d"
- "glSecondaryColor3dv"
- "glSecondaryColor3f"
- "glSecondaryColor3fv"
- "glSecondaryColor3i"
- "glSecondaryColor3iv"
- "glSecondaryColor3s"
- "glSecondaryColor3sv"
- "glSecondaryColor3ub"
- "glSecondaryColor3ubv"
- "glSecondaryColor3ui"
- "glSecondaryColor3uiv"
- "glSecondaryColor3us"
- "glSecondaryColor3usv"
- "glSecondaryColorP3ui"
- "glSecondaryColorP3uiv"
- "glSecondaryColorPointer"
- "glSelectBuffer"
- "glShaderStorageBlockBinding"
- "glSpecializeShader"
- "glTexCoord1d"
- "glTexCoord1dv"
- "glTexCoord1f"
- "glTexCoord1fv"
- "glTexCoord1i"
- "glTexCoord1iv"
- "glTexCoord1s"
- "glTexCoord1sv"
- "glTexCoord2d"
- "glTexCoord2dv"
- "glTexCoord2f"
- "glTexCoord2fv"
- "glTexCoord2i"
- "glTexCoord2iv"
- "glTexCoord2s"
- "glTexCoord2sv"
- "glTexCoord3d"
- "glTexCoord3dv"
- "glTexCoord3f"
- "glTexCoord3fv"
- "glTexCoord3i"
- "glTexCoord3iv"
- "glTexCoord3s"
- "glTexCoord3sv"
- "glTexCoord4d"
- "glTexCoord4dv"
- "glTexCoord4f"
- "glTexCoord4fv"
- "glTexCoord4i"
- "glTexCoord4iv"
- "glTexCoord4s"
- "glTexCoord4sv"
- "glTexCoordP1ui"
- "glTexCoordP1uiv"
- "glTexCoordP2ui"
- "glTexCoordP2uiv"
- "glTexCoordP3ui"
- "glTexCoordP3uiv"
- "glTexCoordP4ui"
- "glTexCoordP4uiv"
- "glTexGend"
- "glTexGendv"
- "glTexGenf"
- "glTexGenfv"
- "glTexGeni"
- "glTexGeniv"
- "glTexImage1D"
- "glTexImage2DMultisample"
- "glTexImage3DMultisample"
- "glTexStorage1D"
- "glTexSubImage1D"
- "glTextureBarrier"
- "glTextureBuffer"
- "glTextureBufferRange"
- "glTextureFoveationParametersQCOM called on a texture that does not support GL_FOVEATION_ENABLE_BIT_QCOM"
- "glTextureParameterIiv"
- "glTextureParameterIuiv"
- "glTextureParameterf"
- "glTextureParameterfv"
- "glTextureParameteri"
- "glTextureParameteriv"
- "glTextureStorage1D"
- "glTextureStorage2D"
- "glTextureStorage2DMultisample"
- "glTextureStorage3D"
- "glTextureStorage3DMultisample"
- "glTextureSubImage1D"
- "glTextureSubImage2D"
- "glTextureSubImage3D"
- "glTextureView"
- "glTransformFeedbackBufferBase"
- "glTransformFeedbackBufferRange"
- "glTranslated"
- "glUniform1d"
- "glUniform1dv"
- "glUniform2d"
- "glUniform2dv"
- "glUniform3d"
- "glUniform3dv"
- "glUniform4d"
- "glUniform4dv"
- "glUniformMatrix2dv"
- "glUniformMatrix2x3dv"
- "glUniformMatrix2x4dv"
- "glUniformMatrix3dv"
- "glUniformMatrix3x2dv"
- "glUniformMatrix3x4dv"
- "glUniformMatrix4dv"
- "glUniformMatrix4x2dv"
- "glUniformMatrix4x3dv"
- "glUniformSubroutinesuiv"
- "glUnmapNamedBuffer"
- "glVertex2d"
- "glVertex2dv"
- "glVertex2f"
- "glVertex2fv"
- "glVertex2i"
- "glVertex2iv"
- "glVertex2s"
- "glVertex2sv"
- "glVertex3d"
- "glVertex3dv"
- "glVertex3f"
- "glVertex3fv"
- "glVertex3i"
- "glVertex3iv"
- "glVertex3s"
- "glVertex3sv"
- "glVertex4d"
- "glVertex4dv"
- "glVertex4f"
- "glVertex4fv"
- "glVertex4i"
- "glVertex4iv"
- "glVertex4s"
- "glVertex4sv"
- "glVertexArrayAttribBinding"
- "glVertexArrayAttribFormat"
- "glVertexArrayAttribIFormat"
- "glVertexArrayAttribLFormat"
- "glVertexArrayBindingDivisor"
- "glVertexArrayElementBuffer"
- "glVertexArrayVertexBuffer"
- "glVertexArrayVertexBuffers"
- "glVertexAttrib1d"
- "glVertexAttrib1dv"
- "glVertexAttrib1s"
- "glVertexAttrib1sv"
- "glVertexAttrib2d"
- "glVertexAttrib2dv"
- "glVertexAttrib2s"
- "glVertexAttrib2sv"
- "glVertexAttrib3d"
- "glVertexAttrib3dv"
- "glVertexAttrib3s"
- "glVertexAttrib3sv"
- "glVertexAttrib4Nbv"
- "glVertexAttrib4Niv"
- "glVertexAttrib4Nsv"
- "glVertexAttrib4Nub"
- "glVertexAttrib4Nubv"
- "glVertexAttrib4Nuiv"
- "glVertexAttrib4Nusv"
- "glVertexAttrib4bv"
- "glVertexAttrib4d"
- "glVertexAttrib4dv"
- "glVertexAttrib4iv"
- "glVertexAttrib4s"
- "glVertexAttrib4sv"
- "glVertexAttrib4ubv"
- "glVertexAttrib4uiv"
- "glVertexAttrib4usv"
- "glVertexAttribI1i"
- "glVertexAttribI1iv"
- "glVertexAttribI1ui"
- "glVertexAttribI1uiv"
- "glVertexAttribI2i"
- "glVertexAttribI2iv"
- "glVertexAttribI2ui"
- "glVertexAttribI2uiv"
- "glVertexAttribI3i"
- "glVertexAttribI3iv"
- "glVertexAttribI3ui"
- "glVertexAttribI3uiv"
- "glVertexAttribI4bv"
- "glVertexAttribI4sv"
- "glVertexAttribI4ubv"
- "glVertexAttribI4usv"
- "glVertexAttribL1d"
- "glVertexAttribL1dv"
- "glVertexAttribL2d"
- "glVertexAttribL2dv"
- "glVertexAttribL3d"
- "glVertexAttribL3dv"
- "glVertexAttribL4d"
- "glVertexAttribL4dv"
- "glVertexAttribLFormat"
- "glVertexAttribLPointer"
- "glVertexAttribP1ui"
- "glVertexAttribP1uiv"
- "glVertexAttribP2ui"
- "glVertexAttribP2uiv"
- "glVertexAttribP3ui"
- "glVertexAttribP3uiv"
- "glVertexAttribP4ui"
- "glVertexAttribP4uiv"
- "glVertexP2ui"
- "glVertexP2uiv"
- "glVertexP3ui"
- "glVertexP3uiv"
- "glVertexP4ui"
- "glVertexP4uiv"
- "glViewportArrayv"
- "glViewportIndexedf"
- "glViewportIndexedfv"
- "glWindowPos2d"
- "glWindowPos2dv"
- "glWindowPos2f"
- "glWindowPos2fv"
- "glWindowPos2i"
- "glWindowPos2iv"
- "glWindowPos2s"
- "glWindowPos2sv"
- "glWindowPos3d"
- "glWindowPos3dv"
- "glWindowPos3f"
- "glWindowPos3fv"
- "glWindowPos3i"
- "glWindowPos3iv"
- "glWindowPos3s"
- "glWindowPos3sv"
- "greaterThan(10E10E"
- "greaterThan(20E20E"
- "greaterThan(30E30E"
- "greaterThanEqual(10E10E"
- "greaterThanEqual(20E20E"
- "greaterThanEqual(30E30E"
- "handleError"
- "http://anglebug.com/1423136"
- "http://anglebug.com/355645824"
- "http://anglebug.com/40096835"
- "http://anglebug.com/40096835 http://anglebug.com/40096850"
- "http://anglebug.com/40096838"
- "http://anglebug.com/40096850"
- "http://anglebug.com/40096869"
- "http://anglebug.com/40644888"
- "http://anglebug.com/40644905"
- "http://anglebug.com/40644912"
- "http://anglebug.com/41488637"
- "http://anglebug.com/42261786"
- "http://anglebug.com/42263580"
- "http://anglebug.com/42264193"
- "http://anglebug.com/42264287"
- "http://anglebug.com/42264571"
- "http://anglebug.com/42265509"
- "http://anglebug.com/42265518"
- "http://anglebug.com/42265754"
- "http://anglebug.com/42266101"
- "http://anglebug.com/42266194"
- "http://anglebug.com/42266231"
- "http://anglebug.com/42266232"
- "http://anglebug.com/42266609"
- "http://anglebug.com/42266694"
- "http://anglebug.com/42266744"
- "http://anglebug.com/42266842"
- "http://crbug.com/1380790"
- "http://crbug.com/1385510"
- "http://crbug.com/1423136"
- "http://crbug.com/1513738"
- "http://crbug.com/350528343"
- "https://anglebug.com/42265720"
- "https://issuetracker.google.com/220069903"
- "https://issuetracker.google.com/292285899"
- "https://issuetracker.google.com/349489248"
- "imageAtomicAdd(00z10D00D"
- "imageAtomicAdd(00z10D00E"
- "imageAtomicAdd(01A20D00D"
- "imageAtomicAdd(01A20D00E"
- "imageAtomicAdd(01B20D00D"
- "imageAtomicAdd(01B20D00E"
- "imageAtomicAdd(01C20D00D"
- "imageAtomicAdd(01C20D00E"
- "imageAtomicAdd(01D00D00D"
- "imageAtomicAdd(01D00D00E"
- "imageAtomicAdd(01E10D00D"
- "imageAtomicAdd(01E10D00E"
- "imageAtomicAdd(01F10D00D00D"
- "imageAtomicAdd(01F10D00D00E"
- "imageAtomicAdd(01G20D00D00D"
- "imageAtomicAdd(01G20D00D00E"
- "imageAtomicAdd(01H20D00D"
- "imageAtomicAdd(01H20D00E"
- "imageAtomicAdd(01I10D00D"
- "imageAtomicAdd(01I10D00E"
- "imageAtomicAdd(01J00D00D"
- "imageAtomicAdd(01J00D00E"
- "imageAtomicAdd(01K10D00D"
- "imageAtomicAdd(01K10D00E"
- "imageAtomicAdd(01L20D00D"
- "imageAtomicAdd(01L20D00E"
- "imageAtomicAdd(01M20D00D"
- "imageAtomicAdd(01M20D00E"
- "imageAtomicAdd(01N20D00D"
- "imageAtomicAdd(01N20D00E"
- "imageAtomicAdd(01O00D00D"
- "imageAtomicAdd(01O00D00E"
- "imageAtomicAdd(01P10D00D"
- "imageAtomicAdd(01P10D00E"
- "imageAtomicAdd(01Q10D00D00D"
- "imageAtomicAdd(01Q10D00D00E"
- "imageAtomicAdd(01R20D00D00D"
- "imageAtomicAdd(01R20D00D00E"
- "imageAtomicAdd(01S20D00D"
- "imageAtomicAdd(01S20D00E"
- "imageAtomicAdd(01T10D00D"
- "imageAtomicAdd(01T10D00E"
- "imageAtomicAdd(01U00D00D"
- "imageAtomicAdd(01U00D00E"
- "imageAtomicAdd(01V10D00D"
- "imageAtomicAdd(01V10D00E"
- "imageAtomicAdd(01W20D00D"
- "imageAtomicAdd(01W20D00E"
- "imageAtomicAdd(01X20D00D"
- "imageAtomicAdd(01X20D00E"
- "imageAtomicAdd(01Y20D00D"
- "imageAtomicAdd(01Y20D00E"
- "imageAtomicAdd(01Z00D00D"
- "imageAtomicAdd(01Z00D00E"
- "imageAtomicAdd(01a10D00D"
- "imageAtomicAdd(01a10D00E"
- "imageAtomicAdd(01b10D00D00D"
- "imageAtomicAdd(01b10D00D00E"
- "imageAtomicAdd(01c20D00D00D"
- "imageAtomicAdd(01c20D00D00E"
- "imageAtomicAdd(01d20D00D"
- "imageAtomicAdd(01d20D00E"
- "imageAtomicAdd(01e10D00D"
- "imageAtomicAdd(01e10D00E"
- "imageAtomicAdd(01f00D00D"
- "imageAtomicAdd(01f00D00E"
- "imageAtomicAnd(00z10D00D"
- "imageAtomicAnd(00z10D00E"
- "imageAtomicAnd(01A20D00D"
- "imageAtomicAnd(01A20D00E"
- "imageAtomicAnd(01B20D00D"
- "imageAtomicAnd(01B20D00E"
- "imageAtomicAnd(01C20D00D"
- "imageAtomicAnd(01C20D00E"
- "imageAtomicAnd(01D00D00D"
- "imageAtomicAnd(01D00D00E"
- "imageAtomicAnd(01E10D00D"
- "imageAtomicAnd(01E10D00E"
- "imageAtomicAnd(01F10D00D00D"
- "imageAtomicAnd(01F10D00D00E"
- "imageAtomicAnd(01G20D00D00D"
- "imageAtomicAnd(01G20D00D00E"
- "imageAtomicAnd(01H20D00D"
- "imageAtomicAnd(01H20D00E"
- "imageAtomicAnd(01I10D00D"
- "imageAtomicAnd(01I10D00E"
- "imageAtomicAnd(01J00D00D"
- "imageAtomicAnd(01J00D00E"
- "imageAtomicAnd(01K10D00D"
- "imageAtomicAnd(01K10D00E"
- "imageAtomicAnd(01L20D00D"
- "imageAtomicAnd(01L20D00E"
- "imageAtomicAnd(01M20D00D"
- "imageAtomicAnd(01M20D00E"
- "imageAtomicAnd(01N20D00D"
- "imageAtomicAnd(01N20D00E"
- "imageAtomicAnd(01O00D00D"
- "imageAtomicAnd(01O00D00E"
- "imageAtomicAnd(01P10D00D"
- "imageAtomicAnd(01P10D00E"
- "imageAtomicAnd(01Q10D00D00D"
- "imageAtomicAnd(01Q10D00D00E"
- "imageAtomicAnd(01R20D00D00D"
- "imageAtomicAnd(01R20D00D00E"
- "imageAtomicAnd(01S20D00D"
- "imageAtomicAnd(01S20D00E"
- "imageAtomicAnd(01T10D00D"
- "imageAtomicAnd(01T10D00E"
- "imageAtomicAnd(01U00D00D"
- "imageAtomicAnd(01U00D00E"
- "imageAtomicAnd(01V10D00D"
- "imageAtomicAnd(01V10D00E"
- "imageAtomicAnd(01W20D00D"
- "imageAtomicAnd(01W20D00E"
- "imageAtomicAnd(01X20D00D"
- "imageAtomicAnd(01X20D00E"
- "imageAtomicAnd(01Y20D00D"
- "imageAtomicAnd(01Y20D00E"
- "imageAtomicAnd(01Z00D00D"
- "imageAtomicAnd(01Z00D00E"
- "imageAtomicAnd(01a10D00D"
- "imageAtomicAnd(01a10D00E"
- "imageAtomicAnd(01b10D00D00D"
- "imageAtomicAnd(01b10D00D00E"
- "imageAtomicAnd(01c20D00D00D"
- "imageAtomicAnd(01c20D00D00E"
- "imageAtomicAnd(01d20D00D"
- "imageAtomicAnd(01d20D00E"
- "imageAtomicAnd(01e10D00D"
- "imageAtomicAnd(01e10D00E"
- "imageAtomicAnd(01f00D00D"
- "imageAtomicAnd(01f00D00E"
- "imageAtomicCompSwap(00z10D00D00D"
- "imageAtomicCompSwap(00z10D00E00E"
- "imageAtomicCompSwap(01A20D00D00D"
- "imageAtomicCompSwap(01A20D00E00E"
- "imageAtomicCompSwap(01B20D00D00D"
- "imageAtomicCompSwap(01B20D00E00E"
- "imageAtomicCompSwap(01C20D00D00D"
- "imageAtomicCompSwap(01C20D00E00E"
- "imageAtomicCompSwap(01D00D00D00D"
- "imageAtomicCompSwap(01D00D00E00E"
- "imageAtomicCompSwap(01E10D00D00D"
- "imageAtomicCompSwap(01E10D00E00E"
- "imageAtomicCompSwap(01F10D00D00D00D"
- "imageAtomicCompSwap(01F10D00D00E00E"
- "imageAtomicCompSwap(01G20D00D00D00D"
- "imageAtomicCompSwap(01G20D00D00E00E"
- "imageAtomicCompSwap(01H20D00D00D"
- "imageAtomicCompSwap(01H20D00E00E"
- "imageAtomicCompSwap(01I10D00D00D"
- "imageAtomicCompSwap(01I10D00E00E"
- "imageAtomicCompSwap(01J00D00D00D"
- "imageAtomicCompSwap(01J00D00E00E"
- "imageAtomicCompSwap(01K10D00D00D"
- "imageAtomicCompSwap(01K10D00E00E"
- "imageAtomicCompSwap(01L20D00D00D"
- "imageAtomicCompSwap(01L20D00E00E"
- "imageAtomicCompSwap(01M20D00D00D"
- "imageAtomicCompSwap(01M20D00E00E"
- "imageAtomicCompSwap(01N20D00D00D"
- "imageAtomicCompSwap(01N20D00E00E"
- "imageAtomicCompSwap(01O00D00D00D"
- "imageAtomicCompSwap(01O00D00E00E"
- "imageAtomicCompSwap(01P10D00D00D"
- "imageAtomicCompSwap(01P10D00E00E"
- "imageAtomicCompSwap(01Q10D00D00D00D"
- "imageAtomicCompSwap(01Q10D00D00E00E"
- "imageAtomicCompSwap(01R20D00D00D00D"
- "imageAtomicCompSwap(01R20D00D00E00E"
- "imageAtomicCompSwap(01S20D00D00D"
- "imageAtomicCompSwap(01S20D00E00E"
- "imageAtomicCompSwap(01T10D00D00D"
- "imageAtomicCompSwap(01T10D00E00E"
- "imageAtomicCompSwap(01U00D00D00D"
- "imageAtomicCompSwap(01U00D00E00E"
- "imageAtomicCompSwap(01V10D00D00D"
- "imageAtomicCompSwap(01V10D00E00E"
- "imageAtomicCompSwap(01W20D00D00D"
- "imageAtomicCompSwap(01W20D00E00E"
- "imageAtomicCompSwap(01X20D00D00D"
- "imageAtomicCompSwap(01X20D00E00E"
- "imageAtomicCompSwap(01Y20D00D00D"
- "imageAtomicCompSwap(01Y20D00E00E"
- "imageAtomicCompSwap(01Z00D00D00D"
- "imageAtomicCompSwap(01Z00D00E00E"
- "imageAtomicCompSwap(01a10D00D00D"
- "imageAtomicCompSwap(01a10D00E00E"
- "imageAtomicCompSwap(01b10D00D00D00D"
- "imageAtomicCompSwap(01b10D00D00E00E"
- "imageAtomicCompSwap(01c20D00D00D00D"
- "imageAtomicCompSwap(01c20D00D00E00E"
- "imageAtomicCompSwap(01d20D00D00D"
- "imageAtomicCompSwap(01d20D00E00E"
- "imageAtomicCompSwap(01e10D00D00D"
- "imageAtomicCompSwap(01e10D00E00E"
- "imageAtomicCompSwap(01f00D00D00D"
- "imageAtomicCompSwap(01f00D00E00E"
- "imageAtomicExchange(00z10D00B"
- "imageAtomicExchange(00z10D00D"
- "imageAtomicExchange(00z10D00E"
- "imageAtomicExchange(01A20D00B"
- "imageAtomicExchange(01A20D00D"
- "imageAtomicExchange(01A20D00E"
- "imageAtomicExchange(01B20D00B"
- "imageAtomicExchange(01B20D00D"
- "imageAtomicExchange(01B20D00E"
- "imageAtomicExchange(01C20D00B"
- "imageAtomicExchange(01C20D00D"
- "imageAtomicExchange(01C20D00E"
- "imageAtomicExchange(01D00D00B"
- "imageAtomicExchange(01D00D00D"
- "imageAtomicExchange(01D00D00E"
- "imageAtomicExchange(01E10D00B"
- "imageAtomicExchange(01E10D00D"
- "imageAtomicExchange(01E10D00E"
- "imageAtomicExchange(01F10D00D00B"
- "imageAtomicExchange(01F10D00D00D"
- "imageAtomicExchange(01F10D00D00E"
- "imageAtomicExchange(01G20D00D00B"
- "imageAtomicExchange(01G20D00D00D"
- "imageAtomicExchange(01G20D00D00E"
- "imageAtomicExchange(01H20D00B"
- "imageAtomicExchange(01H20D00D"
- "imageAtomicExchange(01H20D00E"
- "imageAtomicExchange(01I10D00B"
- "imageAtomicExchange(01I10D00D"
- "imageAtomicExchange(01I10D00E"
- "imageAtomicExchange(01J00D00B"
- "imageAtomicExchange(01J00D00D"
- "imageAtomicExchange(01J00D00E"
- "imageAtomicExchange(01K10D00B"
- "imageAtomicExchange(01K10D00D"
- "imageAtomicExchange(01K10D00E"
- "imageAtomicExchange(01L20D00B"
- "imageAtomicExchange(01L20D00D"
- "imageAtomicExchange(01L20D00E"
- "imageAtomicExchange(01M20D00B"
- "imageAtomicExchange(01M20D00D"
- "imageAtomicExchange(01M20D00E"
- "imageAtomicExchange(01N20D00B"
- "imageAtomicExchange(01N20D00D"
- "imageAtomicExchange(01N20D00E"
- "imageAtomicExchange(01O00D00B"
- "imageAtomicExchange(01O00D00D"
- "imageAtomicExchange(01O00D00E"
- "imageAtomicExchange(01P10D00B"
- "imageAtomicExchange(01P10D00D"
- "imageAtomicExchange(01P10D00E"
- "imageAtomicExchange(01Q10D00D00B"
- "imageAtomicExchange(01Q10D00D00D"
- "imageAtomicExchange(01Q10D00D00E"
- "imageAtomicExchange(01R20D00D00B"
- "imageAtomicExchange(01R20D00D00D"
- "imageAtomicExchange(01R20D00D00E"
- "imageAtomicExchange(01S20D00B"
- "imageAtomicExchange(01S20D00D"
- "imageAtomicExchange(01S20D00E"
- "imageAtomicExchange(01T10D00B"
- "imageAtomicExchange(01T10D00D"
- "imageAtomicExchange(01T10D00E"
- "imageAtomicExchange(01U00D00B"
- "imageAtomicExchange(01U00D00D"
- "imageAtomicExchange(01U00D00E"
- "imageAtomicExchange(01V10D00B"
- "imageAtomicExchange(01V10D00D"
- "imageAtomicExchange(01V10D00E"
- "imageAtomicExchange(01W20D00B"
- "imageAtomicExchange(01W20D00D"
- "imageAtomicExchange(01W20D00E"
- "imageAtomicExchange(01X20D00B"
- "imageAtomicExchange(01X20D00D"
- "imageAtomicExchange(01X20D00E"
- "imageAtomicExchange(01Y20D00B"
- "imageAtomicExchange(01Y20D00D"
- "imageAtomicExchange(01Y20D00E"
- "imageAtomicExchange(01Z00D00B"
- "imageAtomicExchange(01Z00D00D"
- "imageAtomicExchange(01Z00D00E"
- "imageAtomicExchange(01a10D00B"
- "imageAtomicExchange(01a10D00D"
- "imageAtomicExchange(01a10D00E"
- "imageAtomicExchange(01b10D00D00B"
- "imageAtomicExchange(01b10D00D00D"
- "imageAtomicExchange(01b10D00D00E"
- "imageAtomicExchange(01c20D00D00B"
- "imageAtomicExchange(01c20D00D00D"
- "imageAtomicExchange(01c20D00D00E"
- "imageAtomicExchange(01d20D00B"
- "imageAtomicExchange(01d20D00D"
- "imageAtomicExchange(01d20D00E"
- "imageAtomicExchange(01e10D00B"
- "imageAtomicExchange(01e10D00D"
- "imageAtomicExchange(01e10D00E"
- "imageAtomicExchange(01f00D00B"
- "imageAtomicExchange(01f00D00D"
- "imageAtomicExchange(01f00D00E"
- "imageAtomicMax(00z10D00D"
- "imageAtomicMax(00z10D00E"
- "imageAtomicMax(01A20D00D"
- "imageAtomicMax(01A20D00E"
- "imageAtomicMax(01B20D00D"
- "imageAtomicMax(01B20D00E"
- "imageAtomicMax(01C20D00D"
- "imageAtomicMax(01C20D00E"
- "imageAtomicMax(01D00D00D"
- "imageAtomicMax(01D00D00E"
- "imageAtomicMax(01E10D00D"
- "imageAtomicMax(01E10D00E"
- "imageAtomicMax(01F10D00D00D"
- "imageAtomicMax(01F10D00D00E"
- "imageAtomicMax(01G20D00D00D"
- "imageAtomicMax(01G20D00D00E"
- "imageAtomicMax(01H20D00D"
- "imageAtomicMax(01H20D00E"
- "imageAtomicMax(01I10D00D"
- "imageAtomicMax(01I10D00E"
- "imageAtomicMax(01J00D00D"
- "imageAtomicMax(01J00D00E"
- "imageAtomicMax(01K10D00D"
- "imageAtomicMax(01K10D00E"
- "imageAtomicMax(01L20D00D"
- "imageAtomicMax(01L20D00E"
- "imageAtomicMax(01M20D00D"
- "imageAtomicMax(01M20D00E"
- "imageAtomicMax(01N20D00D"
- "imageAtomicMax(01N20D00E"
- "imageAtomicMax(01O00D00D"
- "imageAtomicMax(01O00D00E"
- "imageAtomicMax(01P10D00D"
- "imageAtomicMax(01P10D00E"
- "imageAtomicMax(01Q10D00D00D"
- "imageAtomicMax(01Q10D00D00E"
- "imageAtomicMax(01R20D00D00D"
- "imageAtomicMax(01R20D00D00E"
- "imageAtomicMax(01S20D00D"
- "imageAtomicMax(01S20D00E"
- "imageAtomicMax(01T10D00D"
- "imageAtomicMax(01T10D00E"
- "imageAtomicMax(01U00D00D"
- "imageAtomicMax(01U00D00E"
- "imageAtomicMax(01V10D00D"
- "imageAtomicMax(01V10D00E"
- "imageAtomicMax(01W20D00D"
- "imageAtomicMax(01W20D00E"
- "imageAtomicMax(01X20D00D"
- "imageAtomicMax(01X20D00E"
- "imageAtomicMax(01Y20D00D"
- "imageAtomicMax(01Y20D00E"
- "imageAtomicMax(01Z00D00D"
- "imageAtomicMax(01Z00D00E"
- "imageAtomicMax(01a10D00D"
- "imageAtomicMax(01a10D00E"
- "imageAtomicMax(01b10D00D00D"
- "imageAtomicMax(01b10D00D00E"
- "imageAtomicMax(01c20D00D00D"
- "imageAtomicMax(01c20D00D00E"
- "imageAtomicMax(01d20D00D"
- "imageAtomicMax(01d20D00E"
- "imageAtomicMax(01e10D00D"
- "imageAtomicMax(01e10D00E"
- "imageAtomicMax(01f00D00D"
- "imageAtomicMax(01f00D00E"
- "imageAtomicMin(00z10D00D"
- "imageAtomicMin(00z10D00E"
- "imageAtomicMin(01A20D00D"
- "imageAtomicMin(01A20D00E"
- "imageAtomicMin(01B20D00D"
- "imageAtomicMin(01B20D00E"
- "imageAtomicMin(01C20D00D"
- "imageAtomicMin(01C20D00E"
- "imageAtomicMin(01D00D00D"
- "imageAtomicMin(01D00D00E"
- "imageAtomicMin(01E10D00D"
- "imageAtomicMin(01E10D00E"
- "imageAtomicMin(01F10D00D00D"
- "imageAtomicMin(01F10D00D00E"
- "imageAtomicMin(01G20D00D00D"
- "imageAtomicMin(01G20D00D00E"
- "imageAtomicMin(01H20D00D"
- "imageAtomicMin(01H20D00E"
- "imageAtomicMin(01I10D00D"
- "imageAtomicMin(01I10D00E"
- "imageAtomicMin(01J00D00D"
- "imageAtomicMin(01J00D00E"
- "imageAtomicMin(01K10D00D"
- "imageAtomicMin(01K10D00E"
- "imageAtomicMin(01L20D00D"
- "imageAtomicMin(01L20D00E"
- "imageAtomicMin(01M20D00D"
- "imageAtomicMin(01M20D00E"
- "imageAtomicMin(01N20D00D"
- "imageAtomicMin(01N20D00E"
- "imageAtomicMin(01O00D00D"
- "imageAtomicMin(01O00D00E"
- "imageAtomicMin(01P10D00D"
- "imageAtomicMin(01P10D00E"
- "imageAtomicMin(01Q10D00D00D"
- "imageAtomicMin(01Q10D00D00E"
- "imageAtomicMin(01R20D00D00D"
- "imageAtomicMin(01R20D00D00E"
- "imageAtomicMin(01S20D00D"
- "imageAtomicMin(01S20D00E"
- "imageAtomicMin(01T10D00D"
- "imageAtomicMin(01T10D00E"
- "imageAtomicMin(01U00D00D"
- "imageAtomicMin(01U00D00E"
- "imageAtomicMin(01V10D00D"
- "imageAtomicMin(01V10D00E"
- "imageAtomicMin(01W20D00D"
- "imageAtomicMin(01W20D00E"
- "imageAtomicMin(01X20D00D"
- "imageAtomicMin(01X20D00E"
- "imageAtomicMin(01Y20D00D"
- "imageAtomicMin(01Y20D00E"
- "imageAtomicMin(01Z00D00D"
- "imageAtomicMin(01Z00D00E"
- "imageAtomicMin(01a10D00D"
- "imageAtomicMin(01a10D00E"
- "imageAtomicMin(01b10D00D00D"
- "imageAtomicMin(01b10D00D00E"
- "imageAtomicMin(01c20D00D00D"
- "imageAtomicMin(01c20D00D00E"
- "imageAtomicMin(01d20D00D"
- "imageAtomicMin(01d20D00E"
- "imageAtomicMin(01e10D00D"
- "imageAtomicMin(01e10D00E"
- "imageAtomicMin(01f00D00D"
- "imageAtomicMin(01f00D00E"
- "imageAtomicOr(00z10D00D"
- "imageAtomicOr(00z10D00E"
- "imageAtomicOr(01A20D00D"
- "imageAtomicOr(01A20D00E"
- "imageAtomicOr(01B20D00D"
- "imageAtomicOr(01B20D00E"
- "imageAtomicOr(01C20D00D"
- "imageAtomicOr(01C20D00E"
- "imageAtomicOr(01D00D00D"
- "imageAtomicOr(01D00D00E"
- "imageAtomicOr(01E10D00D"
- "imageAtomicOr(01E10D00E"
- "imageAtomicOr(01F10D00D00D"
- "imageAtomicOr(01F10D00D00E"
- "imageAtomicOr(01G20D00D00D"
- "imageAtomicOr(01G20D00D00E"
- "imageAtomicOr(01H20D00D"
- "imageAtomicOr(01H20D00E"
- "imageAtomicOr(01I10D00D"
- "imageAtomicOr(01I10D00E"
- "imageAtomicOr(01J00D00D"
- "imageAtomicOr(01J00D00E"
- "imageAtomicOr(01K10D00D"
- "imageAtomicOr(01K10D00E"
- "imageAtomicOr(01L20D00D"
- "imageAtomicOr(01L20D00E"
- "imageAtomicOr(01M20D00D"
- "imageAtomicOr(01M20D00E"
- "imageAtomicOr(01N20D00D"
- "imageAtomicOr(01N20D00E"
- "imageAtomicOr(01O00D00D"
- "imageAtomicOr(01O00D00E"
- "imageAtomicOr(01P10D00D"
- "imageAtomicOr(01P10D00E"
- "imageAtomicOr(01Q10D00D00D"
- "imageAtomicOr(01Q10D00D00E"
- "imageAtomicOr(01R20D00D00D"
- "imageAtomicOr(01R20D00D00E"
- "imageAtomicOr(01S20D00D"
- "imageAtomicOr(01S20D00E"
- "imageAtomicOr(01T10D00D"
- "imageAtomicOr(01T10D00E"
- "imageAtomicOr(01U00D00D"
- "imageAtomicOr(01U00D00E"
- "imageAtomicOr(01V10D00D"
- "imageAtomicOr(01V10D00E"
- "imageAtomicOr(01W20D00D"
- "imageAtomicOr(01W20D00E"
- "imageAtomicOr(01X20D00D"
- "imageAtomicOr(01X20D00E"
- "imageAtomicOr(01Y20D00D"
- "imageAtomicOr(01Y20D00E"
- "imageAtomicOr(01Z00D00D"
- "imageAtomicOr(01Z00D00E"
- "imageAtomicOr(01a10D00D"
- "imageAtomicOr(01a10D00E"
- "imageAtomicOr(01b10D00D00D"
- "imageAtomicOr(01b10D00D00E"
- "imageAtomicOr(01c20D00D00D"
- "imageAtomicOr(01c20D00D00E"
- "imageAtomicOr(01d20D00D"
- "imageAtomicOr(01d20D00E"
- "imageAtomicOr(01e10D00D"
- "imageAtomicOr(01e10D00E"
- "imageAtomicOr(01f00D00D"
- "imageAtomicOr(01f00D00E"
- "imageAtomicXor(00z10D00D"
- "imageAtomicXor(00z10D00E"
- "imageAtomicXor(01A20D00D"
- "imageAtomicXor(01A20D00E"
- "imageAtomicXor(01B20D00D"
- "imageAtomicXor(01B20D00E"
- "imageAtomicXor(01C20D00D"
- "imageAtomicXor(01C20D00E"
- "imageAtomicXor(01D00D00D"
- "imageAtomicXor(01D00D00E"
- "imageAtomicXor(01E10D00D"
- "imageAtomicXor(01E10D00E"
- "imageAtomicXor(01F10D00D00D"
- "imageAtomicXor(01F10D00D00E"
- "imageAtomicXor(01G20D00D00D"
- "imageAtomicXor(01G20D00D00E"
- "imageAtomicXor(01H20D00D"
- "imageAtomicXor(01H20D00E"
- "imageAtomicXor(01I10D00D"
- "imageAtomicXor(01I10D00E"
- "imageAtomicXor(01J00D00D"
- "imageAtomicXor(01J00D00E"
- "imageAtomicXor(01K10D00D"
- "imageAtomicXor(01K10D00E"
- "imageAtomicXor(01L20D00D"
- "imageAtomicXor(01L20D00E"
- "imageAtomicXor(01M20D00D"
- "imageAtomicXor(01M20D00E"
- "imageAtomicXor(01N20D00D"
- "imageAtomicXor(01N20D00E"
- "imageAtomicXor(01O00D00D"
- "imageAtomicXor(01O00D00E"
- "imageAtomicXor(01P10D00D"
- "imageAtomicXor(01P10D00E"
- "imageAtomicXor(01Q10D00D00D"
- "imageAtomicXor(01Q10D00D00E"
- "imageAtomicXor(01R20D00D00D"
- "imageAtomicXor(01R20D00D00E"
- "imageAtomicXor(01S20D00D"
- "imageAtomicXor(01S20D00E"
- "imageAtomicXor(01T10D00D"
- "imageAtomicXor(01T10D00E"
- "imageAtomicXor(01U00D00D"
- "imageAtomicXor(01U00D00E"
- "imageAtomicXor(01V10D00D"
- "imageAtomicXor(01V10D00E"
- "imageAtomicXor(01W20D00D"
- "imageAtomicXor(01W20D00E"
- "imageAtomicXor(01X20D00D"
- "imageAtomicXor(01X20D00E"
- "imageAtomicXor(01Y20D00D"
- "imageAtomicXor(01Y20D00E"
- "imageAtomicXor(01Z00D00D"
- "imageAtomicXor(01Z00D00E"
- "imageAtomicXor(01a10D00D"
- "imageAtomicXor(01a10D00E"
- "imageAtomicXor(01b10D00D00D"
- "imageAtomicXor(01b10D00D00E"
- "imageAtomicXor(01c20D00D00D"
- "imageAtomicXor(01c20D00D00E"
- "imageAtomicXor(01d20D00D"
- "imageAtomicXor(01d20D00E"
- "imageAtomicXor(01e10D00D"
- "imageAtomicXor(01e10D00E"
- "imageAtomicXor(01f00D00D"
- "imageAtomicXor(01f00D00E"
- "imageLoad(00z10D"
- "imageLoad(01A20D"
- "imageLoad(01B20D"
- "imageLoad(01C20D"
- "imageLoad(01H20D"
- "imageLoad(01J00D"
- "imageLoad(01K10D"
- "imageLoad(01L20D"
- "imageLoad(01M20D"
- "imageLoad(01N20D"
- "imageLoad(01S20D"
- "imageLoad(01U00D"
- "imageLoad(01V10D"
- "imageLoad(01W20D"
- "imageLoad(01X20D"
- "imageLoad(01Y20D"
- "imageLoad(01d20D"
- "imageLoad(01f00D"
- "imageSize is too small."
- "imageSize must be 0 if no texture data is provided."
- "imageSize(01M"
- "imageSize(01N"
- "imageSize(01S"
- "imageSize(01U"
- "imageSize(01V"
- "imageSize(01W"
- "imageSize(01X"
- "imageSize(01Y"
- "imageSize(01d"
- "imageSize(01f"
- "imageStore(00z10D30B"
- "imageStore(01A20D30B"
- "imageStore(01B20D30B"
- "imageStore(01C20D30B"
- "imageStore(01H20D30B"
- "imageStore(01J00D30B"
- "imageStore(01K10D30D"
- "imageStore(01L20D30D"
- "imageStore(01M20D30D"
- "imageStore(01N20D30D"
- "imageStore(01S20D30D"
- "imageStore(01U00D30D"
- "imageStore(01V10D30E"
- "imageStore(01W20D30E"
- "imageStore(01X20D30E"
- "imageStore(01Y20D30E"
- "imageStore(01d20D30E"
- "imageStore(01f00D30E"
- "imulExtended(00D00D00D00D"
- "imulExtended(10D10D10D10D"
- "imulExtended(20D20D20D20D"
- "imulExtended(30D30D30D30D"
- "indirect must be a multiple of the size of uint in basic machine units."
- "intBitsToFloat(00D"
- "intBitsToFloat(10D"
- "intBitsToFloat(20D"
- "intBitsToFloat(30D"
- "internalformat is a BPTC format and target is not GL_TEXTURE_2D_ARRAY."
- "internalformat is an ASTC format and target is not GL_TEXTURE_2D_ARRAY."
- "internalformat is an ETC1 or PVRTC1 format."
- "internalformat is an ETC2/EAC format and target is not GL_TEXTURE_2D_ARRAY."
- "internalformat is an RGTC format and target is not GL_TEXTURE_2D_ARRAY."
- "internalformat is an S3TC format and target is not GL_TEXTURE_2D_ARRAY."
- "interpolateAtSample(00B00D"
- "interpolateAtSample(10B00D"
- "interpolateAtSample(20B00D"
- "interpolateAtSample(30B00D"
- "isAMD()"
- "isAMDBronzeDriver()"
- "isIntel()"
- "isIntel() && GetMacOSVersion() < OSVersion(11, 0, 0)"
- "isIntel() && GetMacOSVersion() < OSVersion(12, 0, 0)"
- "isIntel() || isAMD()"
- "isOSX || isCatalyst || supportsAppleGPUFamily(3)"
- "isOSX || isCatalyst || supportsAppleGPUFamily(4)"
- "isSimulator || !supportsAppleGPUFamily(1)"
- "isubpassInputMS"
- "ldexp(00B00D"
- "ldexp(10B10D"
- "ldexp(20B20D"
- "ldexp(30B30D"
- "lessThan(10E10E"
- "lessThan(20E20E"
- "lessThan(30E30E"
- "lessThanEqual(10E10E"
- "lessThanEqual(20E20E"
- "lessThanEqual(30E30E"
- "max(00E00E"
- "max(10E00E"
- "max(10E10E"
- "max(20E00E"
- "max(20E20E"
- "max(30E00E"
- "max(30E30E"
- "metal::texture1d<float>"
- "metal::texture1d<int>"
- "metal::texture1d<uint32_t>"
- "metal::texture1d_array<float>"
- "metal::texture1d_array<int>"
- "metal::texture1d_array<uint32_t>"
- "min(00E00E"
- "min(10E00E"
- "min(10E10E"
- "min(20E00E"
- "min(20E20E"
- "min(30E00E"
- "min(30E30E"
- "mix(00B00B00F"
- "mix(00D00D00F"
- "mix(00E00E00F"
- "mix(00F00F00F"
- "mix(10B10B10F"
- "mix(10D10D10F"
- "mix(10E10E10F"
- "mix(10F10F10F"
- "mix(20B20B20F"
- "mix(20D20D20F"
- "mix(20E20E20F"
- "mix(20F20F20F"
- "mix(30B30B30F"
- "mix(30D30D30F"
- "mix(30E30E30F"
- "mix(30F30F30F"
- "name is not a valid buffer."
- "name is not a valid framebuffer."
- "name is not a valid program pipeline."
- "name is not a valid query."
- "name is not a valid renderbuffer."
- "name is not a valid sampler."
- "name is not a valid transform feedback."
- "name is not a valid vertex array."
- "not(10F"
- "not(20F"
- "not(30F"
- "notEqual(10F10F"
- "notEqual(20F20F"
- "notEqual(30F30F"
- "numViews cannot be greater than GL_MAX_VIEWS_ANGLE."
- "numViews cannot be less than 1."
- "num_groups_x cannot be greater than MAX_COMPUTE_WORK_GROUP_COUNT[0]"
- "num_groups_y cannot be greater than MAX_COMPUTE_WORK_GROUP_COUNT[1]"
- "num_groups_z cannot be greater than MAX_COMPUTE_WORK_GROUP_COUNT[2]"
- "offset must be a multiple of 4."
- "param is negative."
- "pixelLocalLoadANGLE(01g"
- "pixelLocalLoadANGLE(01h"
- "pixelLocalLoadANGLE(01i"
- "pixelLocalStoreANGLE(01g30B"
- "pixelLocalStoreANGLE(01h30D"
- "pixelLocalStoreANGLE(01i30E"
- "pls"
- "programInterface must be set to GL_PROGRAM_OUTPUT."
- "relativeOffset cannot be greater than MAX_VERTEX_ATTRIB_RELATIVE_OFFSET."
- "requireMsl21"
- "rgb_2_yuv(20B00H"
- "samplePosition(00E"
- "shadow2DEXT(00d20B"
- "shadow2DProjEXT(00d30B"
- "sign(00D"
- "sign(10D"
- "sign(20D"
- "sign(30D"
- "some GPUs are faster to read a texture by first copying the texture to a buffer"
- "some GPUs are faster to read an IOSurface texture by first copying the texture to a non-IOSurface texture"
- "subpassInputMS"
- "subpassLoad(01j"
- "subpassLoad(01k"
- "subpassLoad(01l"
- "subpassLoad(01m00D"
- "subpassLoad(01n00D"
- "subpassLoad(01o00D"
- "supportsAppleGPUFamily(1)"
- "supportsEitherGPUFamily(3, 1)"
- "supportsEitherGPUFamily(3, 1) && !isAMD()"
- "supportsEitherGPUFamily(3, 2)"
- "supportsEitherGPUFamily(4, 2)"
- "supportsEitherGPUFamily(5, 2)"
- "supportsMetal2_1() && !isIntel() && !isNVIDIA()"
- "supportsMetal2_1() && !isNVIDIA()"
- "supportsMetal2_1() && (isOSX || isCatalyst) && !isARM"
- "supportsMetal2_2() && supportsEitherGPUFamily(3, 2) && !isSimulator"
- "supportsVariableRasterizationRate()"
- "texelFetch(00I10D00D"
- "texelFetch(00J20D00D"
- "texelFetch(00L20D00D"
- "texelFetch(00M10D00D"
- "texelFetch(00N10D00D"
- "texelFetch(00P10D00D"
- "texelFetch(00Q20D00D"
- "texelFetch(00R10D00D"
- "texelFetch(00S20D00D"
- "texelFetch(00U20D00D"
- "texelFetch(00V10D00D"
- "texelFetch(00W20D00D"
- "texelFetch(00X10D00D"
- "texelFetch(00Y20D00D"
- "texelFetch(00a20D00D"
- "texelFetch(00b10D00D"
- "texelFetch(00c20D00D"
- "texelFetch(00j00D"
- "texelFetch(00r00D"
- "texelFetch(00w00D"
- "texelFetchOffset(00I10D00D10D"
- "texelFetchOffset(00J20D00D20D"
- "texelFetchOffset(00L20D00D10D"
- "texelFetchOffset(00R10D00D10D"
- "texelFetchOffset(00S20D00D20D"
- "texelFetchOffset(00U20D00D10D"
- "texelFetchOffset(00X10D00D10D"
- "texelFetchOffset(00Y20D00D20D"
- "texelFetchOffset(00a20D00D10D"
- "texture is not the name of an existing texture object."
- "texture(00I10B"
- "texture(00I10B00B"
- "texture(00L20B"
- "texture(00L20B00B"
- "texture(00N10B00B"
- "texture(00O10B"
- "texture(00R10B"
- "texture(00R10B00B"
- "texture(00U20B"
- "texture(00U20B00B"
- "texture(00X10B"
- "texture(00X10B00B"
- "texture(00a20B"
- "texture(00a20B00B"
- "texture(00d20B"
- "texture(00d20B00B"
- "texture(00f30B"
- "texture(00k30B"
- "texture(00k30B00B"
- "texture(00s30B"
- "texture(00s30B00B"
- "texture(00x30B"
- "texture(00x30B00B"
- "texture(00y10B"
- "texture1D"
- "texture1DLod"
- "texture1DProj"
- "texture1DProjLod"
- "texture2D(00I10B"
- "texture2D(00I10B00B"
- "texture2D(00M10B"
- "texture2DGradEXT(00I10B10B10B"
- "texture2DLod(00I10B00B"
- "texture2DLodEXT(00I10B00B"
- "texture2DProj(00I20B"
- "texture2DProj(00I20B00B"
- "texture2DProj(00I30B"
- "texture2DProj(00I30B00B"
- "texture2DProj(00M20B"
- "texture2DProj(00M30B"
- "texture2DProjGradEXT(00I20B10B10B"
- "texture2DProjGradEXT(00I30B10B10B"
- "texture2DProjLod(00I20B00B"
- "texture2DProjLod(00I30B00B"
- "texture2DProjLodEXT(00I20B00B"
- "texture2DProjLodEXT(00I30B00B"
- "texture2DRect(00O10B"
- "texture2DRectProj(00O20B"
- "texture2DRectProj(00O30B"
- "texture3D(00J20B"
- "texture3D(00J20B00B"
- "texture3DLod(00J20B00B"
- "texture3DProj(00J30B"
- "texture3DProj(00J30B00B"
- "texture3DProjLod(00J30B00B"
- "textureCube(00K20B"
- "textureCube(00K20B00B"
- "textureCubeGradEXT(00K20B20B20B"
- "textureCubeLod(00K20B00B"
- "textureCubeLodEXT(00K20B00B"
- "textureCubeProj"
- "textureCubeProjLod"
- "textureGather(00I10B"
- "textureGather(00I10B00D"
- "textureGather(00K20B00D"
- "textureGather(00L20B"
- "textureGather(00L20B00D"
- "textureGather(00R10B"
- "textureGather(00R10B00D"
- "textureGather(00T20B00D"
- "textureGather(00U20B"
- "textureGather(00U20B00D"
- "textureGather(00X10B"
- "textureGather(00X10B00D"
- "textureGather(00Z20B00D"
- "textureGather(00a20B"
- "textureGather(00a20B00D"
- "textureGather(00d10B"
- "textureGather(00d10B00B"
- "textureGather(00f20B"
- "textureGather(00f20B00B"
- "textureGather(00k30B"
- "textureGather(00k30B00D"
- "textureGather(00l30B00B"
- "textureGather(00s30B"
- "textureGather(00s30B00D"
- "textureGather(00x30B"
- "textureGather(00x30B00D"
- "textureGatherOffset(00I10B10D"
- "textureGatherOffset(00I10B10D00D"
- "textureGatherOffset(00L20B10D"
- "textureGatherOffset(00L20B10D00D"
- "textureGatherOffset(00R10B10D"
- "textureGatherOffset(00R10B10D00D"
- "textureGatherOffset(00U20B10D"
- "textureGatherOffset(00U20B10D00D"
- "textureGatherOffset(00X10B10D"
- "textureGatherOffset(00X10B10D00D"
- "textureGatherOffset(00a20B10D"
- "textureGatherOffset(00a20B10D00D"
- "textureGatherOffset(00d10B00B10D"
- "textureGatherOffset(00f20B00B10D"
- "textureGatherOffsets(00I10B10Dx4"
- "textureGatherOffsets(00I10B10Dx400D"
- "textureGatherOffsets(00L20B10Dx4"
- "textureGatherOffsets(00L20B10Dx400D"
- "textureGatherOffsets(00R10B10Dx4"
- "textureGatherOffsets(00R10B10Dx400D"
- "textureGatherOffsets(00U20B10Dx4"
- "textureGatherOffsets(00U20B10Dx400D"
- "textureGatherOffsets(00X10B10Dx4"
- "textureGatherOffsets(00X10B10Dx400D"
- "textureGatherOffsets(00a20B10Dx4"
- "textureGatherOffsets(00a20B10Dx400D"
- "textureGatherOffsets(00d10B00B10Dx4"
- "textureGatherOffsets(00f20B00B10Dx4"
- "textureGrad(00I10B10B10B"
- "textureGrad(00K20B20B20B"
- "textureGrad(00L20B10B10B"
- "textureGrad(00R10B10B10B"
- "textureGrad(00T20B20B20B"
- "textureGrad(00U20B10B10B"
- "textureGrad(00X10B10B10B"
- "textureGrad(00Z20B20B20B"
- "textureGrad(00a20B10B10B"
- "textureGrad(00d20B10B10B"
- "textureGrad(00e30B20B20B"
- "textureGrad(00f30B10B10B"
- "textureGrad(00k30B20B20B"
- "textureGrad(00s30B20B20B"
- "textureGrad(00x30B20B20B"
- "textureGradOffset(00I10B10B10B10D"
- "textureGradOffset(00J20B20B20B20D"
- "textureGradOffset(00L20B10B10B10D"
- "textureGradOffset(00R10B10B10B10D"
- "textureGradOffset(00S20B20B20B20D"
- "textureGradOffset(00U20B10B10B10D"
- "textureGradOffset(00X10B10B10B10D"
- "textureGradOffset(00Y20B20B20B20D"
- "textureGradOffset(00a20B10B10B10D"
- "textureGradOffset(00d20B10B10B10D"
- "textureGradOffset(00f30B10B10B10D"
- "textureLod(00I10B00B"
- "textureLod(00L20B00B"
- "textureLod(00R10B00B"
- "textureLod(00U20B00B"
- "textureLod(00X10B00B"
- "textureLod(00a20B00B"
- "textureLod(00d20B00B"
- "textureLod(00k30B00B"
- "textureLod(00s30B00B"
- "textureLod(00x30B00B"
- "textureLodOffset(00I10B00B10D"
- "textureLodOffset(00J20B00B20D"
- "textureLodOffset(00L20B00B10D"
- "textureLodOffset(00R10B00B10D"
- "textureLodOffset(00S20B00B20D"
- "textureLodOffset(00U20B00B10D"
- "textureLodOffset(00X10B00B10D"
- "textureLodOffset(00Y20B00B20D"
- "textureLodOffset(00a20B00B10D"
- "textureLodOffset(00d20B00B10D"
- "textureOffset(00I10B10D"
- "textureOffset(00I10B10D00B"
- "textureOffset(00J20B20D"
- "textureOffset(00J20B20D00B"
- "textureOffset(00L20B10D"
- "textureOffset(00L20B10D00B"
- "textureOffset(00R10B10D"
- "textureOffset(00R10B10D00B"
- "textureOffset(00S20B20D"
- "textureOffset(00S20B20D00B"
- "textureOffset(00U20B10D"
- "textureOffset(00U20B10D00B"
- "textureOffset(00X10B10D"
- "textureOffset(00X10B10D00B"
- "textureOffset(00Y20B20D"
- "textureOffset(00Y20B20D00B"
- "textureOffset(00a20B10D"
- "textureOffset(00a20B10D00B"
- "textureOffset(00d20B10D"
- "textureOffset(00d20B10D00B"
- "textureProj(00I20B"
- "textureProj(00I20B00B"
- "textureProj(00J30B"
- "textureProj(00J30B00B"
- "textureProj(00N20B00B"
- "textureProj(00N30B00B"
- "textureProj(00O20B"
- "textureProj(00O30B"
- "textureProj(00R20B"
- "textureProj(00R20B00B"
- "textureProj(00S30B"
- "textureProj(00S30B00B"
- "textureProj(00X20B"
- "textureProj(00X20B00B"
- "textureProj(00Y30B"
- "textureProj(00Y30B00B"
- "textureProj(00d30B"
- "textureProj(00d30B00B"
- "textureProjGrad(00I20B10B10B"
- "textureProjGrad(00I30B10B10B"
- "textureProjGrad(00J30B20B20B"
- "textureProjGrad(00R20B10B10B"
- "textureProjGrad(00R30B10B10B"
- "textureProjGrad(00S30B20B20B"
- "textureProjGrad(00X20B10B10B"
- "textureProjGrad(00X30B10B10B"
- "textureProjGrad(00Y30B20B20B"
- "textureProjGrad(00d30B10B10B"
- "textureProjGradOffset(00I20B10B10B10D"
- "textureProjGradOffset(00I30B10B10B10D"
- "textureProjGradOffset(00J30B20B20B20D"
- "textureProjGradOffset(00R20B10B10B10D"
- "textureProjGradOffset(00R30B10B10B10D"
- "textureProjGradOffset(00S30B20B20B20D"
- "textureProjGradOffset(00X20B10B10B10D"
- "textureProjGradOffset(00X30B10B10B10D"
- "textureProjGradOffset(00Y30B20B20B20D"
- "textureProjGradOffset(00d30B10B10B10D"
- "textureProjLod(00I20B00B"
- "textureProjLod(00J30B00B"
- "textureProjLod(00R20B00B"
- "textureProjLod(00S30B00B"
- "textureProjLod(00X20B00B"
- "textureProjLod(00Y30B00B"
- "textureProjLod(00d30B00B"
- "textureProjLodOffset(00I20B00B10D"
- "textureProjLodOffset(00I30B00B10D"
- "textureProjLodOffset(00J30B00B20D"
- "textureProjLodOffset(00R20B00B10D"
- "textureProjLodOffset(00R30B00B10D"
- "textureProjLodOffset(00S30B00B20D"
- "textureProjLodOffset(00X20B00B10D"
- "textureProjLodOffset(00X30B00B10D"
- "textureProjLodOffset(00Y30B00B20D"
- "textureProjLodOffset(00d30B00B10D"
- "textureProjOffset(00I20B10D"
- "textureProjOffset(00I20B10D00B"
- "textureProjOffset(00I30B10D"
- "textureProjOffset(00I30B10D00B"
- "textureProjOffset(00J30B20D"
- "textureProjOffset(00J30B20D00B"
- "textureProjOffset(00R20B10D"
- "textureProjOffset(00R20B10D00B"
- "textureProjOffset(00R30B10D"
- "textureProjOffset(00R30B10D00B"
- "textureProjOffset(00S30B20D"
- "textureProjOffset(00S30B20D00B"
- "textureProjOffset(00X20B10D"
- "textureProjOffset(00X20B10D00B"
- "textureProjOffset(00X30B10D"
- "textureProjOffset(00X30B10D00B"
- "textureProjOffset(00Y30B20D"
- "textureProjOffset(00Y30B20D00B"
- "textureProjOffset(00d30B10D"
- "textureProjOffset(00d30B10D00B"
- "textureSize(00I00D"
- "textureSize(00J00D"
- "textureSize(00K00D"
- "textureSize(00L00D"
- "textureSize(00M00D"
- "textureSize(00N00D"
- "textureSize(00Q"
- "textureSize(00R00D"
- "textureSize(00S00D"
- "textureSize(00T00D"
- "textureSize(00U00D"
- "textureSize(00W"
- "textureSize(00X00D"
- "textureSize(00Y00D"
- "textureSize(00Z00D"
- "textureSize(00a00D"
- "textureSize(00c"
- "textureSize(00d00D"
- "textureSize(00e00D"
- "textureSize(00f00D"
- "textureSize(00j"
- "textureSize(00k00D"
- "textureSize(00l00D"
- "textureSize(00r"
- "textureSize(00s00D"
- "textureSize(00w"
- "textureSize(00x00D"
- "textureVideoWEBGL(00y10B"
- "true (override)"
- "uaddCarry(00E00E00E"
- "uaddCarry(10E10E10E"
- "uaddCarry(20E20E20E"
- "uaddCarry(30E30E30E"
- "uintBitsToFloat(00E"
- "uintBitsToFloat(10E"
- "uintBitsToFloat(20E"
- "uintBitsToFloat(30E"
- "umulExtended(00E00E00E00E"
- "umulExtended(10E10E10E10E"
- "umulExtended(20E20E20E20E"
- "umulExtended(30E30E30E30E"
- "unpackHalf2x16(00E"
- "unpackSnorm2x16(00E"
- "unpackSnorm4x8(00E"
- "unpackUnorm2x16(00E"
- "unpackUnorm4x8(00E"
- "usubBorrow(00E00E00E"
- "usubBorrow(10E10E10E"
- "usubBorrow(20E20E20E"
- "usubBorrow(30E30E30E"
- "usubpassInputMS"
- "wglChoosePixelFormat"
- "wglCopyContext"
- "wglCreateContext"
- "wglCreateLayerContext"
- "wglDeleteContext"
- "wglDescribeLayerPlane"
- "wglDescribePixelFormat"
- "wglGetCurrentContext"
- "wglGetCurrentDC"
- "wglGetEnhMetaFilePixelFormat"
- "wglGetLayerPaletteEntries"
- "wglGetPixelFormat"
- "wglGetProcAddress"
- "wglMakeCurrent"
- "wglRealizeLayerPalette"
- "wglSetLayerPaletteEntries"
- "wglSetPixelFormat"
- "wglShareLists"
- "wglSwapBuffers"
- "wglSwapLayerBuffers"
- "wglUseFontBitmaps"
- "wglUseFontBitmapsA"
- "wglUseFontBitmapsW"
- "wglUseFontOutlines"
- "wglUseFontOutlinesA"
- "wglUseFontOutlinesW"
- "x = y = or z cannot be negative."
- "y"
- "yuv_2_rgb(20B00H"
- "z"
- "zoffset is larger than MAX_3D_TEXTURE_SIZE-1"

```
