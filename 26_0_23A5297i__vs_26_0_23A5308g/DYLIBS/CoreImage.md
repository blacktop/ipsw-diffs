## CoreImage

> `/System/Library/Frameworks/CoreImage.framework/CoreImage`

```diff

-1583.0.0.0.0
-  __TEXT.__text: 0x2d1cbc
+1590.0.0.0.0
+  __TEXT.__text: 0x2d28b4
   __TEXT.__auth_stubs: 0x2f10
-  __TEXT.__objc_methlist: 0x14f68
-  __TEXT.__const: 0xbb98
-  __TEXT.__gcc_except_tab: 0x5eac
-  __TEXT.__cstring: 0x8792a
+  __TEXT.__objc_methlist: 0x14f80
+  __TEXT.__const: 0xbcb8
+  __TEXT.__gcc_except_tab: 0x5eb0
+  __TEXT.__cstring: 0x89186
   __TEXT.__oslogstring: 0xa5db
   __TEXT.__dlopen_cstrs: 0x313
   __TEXT.__runtimeheader: 0xda3c
   __TEXT.__cikl2metal_pre: 0x50d
   __TEXT.__grain: 0x105040
-  __TEXT.__unwind_info: 0x6b58
+  __TEXT.__unwind_info: 0x6b70
   __TEXT.__eh_frame: 0x208
   __TEXT.__objc_classname: 0x2a59
   __TEXT.__objc_methname: 0x204ad
   __TEXT.__objc_methtype: 0x66c9
-  __TEXT.__objc_stubs: 0x104e0
+  __TEXT.__objc_stubs: 0x10520
   __DATA_CONST.__got: 0xa78
   __DATA_CONST.__const: 0x7500
   __DATA_CONST.__objc_classlist: 0x1038

   __DATA_CONST.__objc_selrefs: 0x8910
   __DATA_CONST.__objc_protorefs: 0x18
   __DATA_CONST.__objc_superrefs: 0x330
-  __DATA_CONST.__objc_arraydata: 0x14a0
+  __DATA_CONST.__objc_arraydata: 0x1490
   __AUTH_CONST.__auth_got: 0x17a0
-  __AUTH_CONST.__const: 0xd110
-  __AUTH_CONST.__cfstring: 0x19fa0
-  __AUTH_CONST.__objc_const: 0x2a598
+  __AUTH_CONST.__const: 0xd1b0
+  __AUTH_CONST.__cfstring: 0x1a000
+  __AUTH_CONST.__objc_const: 0x2a5c8
   __AUTH_CONST.__objc_intobj: 0xd98
-  __AUTH_CONST.__objc_dictobj: 0x438
+  __AUTH_CONST.__objc_dictobj: 0x410
   __AUTH_CONST.__objc_doubleobj: 0x29b0
   __AUTH_CONST.__objc_floatobj: 0x2e0
   __AUTH_CONST.__objc_arrayobj: 0x1b0
-  __AUTH.__objc_data: 0x9ab0
-  __AUTH.__data: 0x1e110
+  __AUTH.__objc_data: 0x9b50
+  __AUTH.__data: 0x1e010
   __AUTH.__thread_vars: 0x18
   __AUTH.__thread_bss: 0x8
-  __DATA.__objc_ivar: 0x1f14
-  __DATA.__data: 0x57a0
-  __DATA.__bss: 0x37c0
+  __DATA.__objc_ivar: 0x1f18
+  __DATA.__data: 0x5798
+  __DATA.__bss: 0x3798
   __DATA.__common: 0x38
-  __DATA_DIRTY.__objc_data: 0x780
+  __DATA_DIRTY.__objc_data: 0x6e0
   __DATA_DIRTY.__data: 0x4
   __DATA_DIRTY.__crash_info: 0x148
-  __DATA_DIRTY.__bss: 0x650
+  __DATA_DIRTY.__bss: 0x670
   __DATA_DIRTY.__common: 0x1f0
   - /System/Library/Frameworks/Accelerate.framework/Accelerate
   - /System/Library/Frameworks/ColorSync.framework/ColorSync

   - /usr/lib/libSystem.B.dylib
   - /usr/lib/libc++.1.dylib
   - /usr/lib/libobjc.A.dylib
-  UUID: 9DE83C37-34F4-3531-A3FA-A290FCEAF050
-  Functions: 14010
-  Symbols:   43349
-  CStrings:  18044
+  UUID: DFDE8AD8-A22A-37FF-822D-7CB74FB2D357
+  Functions: 14019
+  Symbols:   43378
+  CStrings:  18050
 
Symbols:
+ -[CUIGlassHighlightInternal inputCenter]
+ -[CUIGlassHighlightInternal setInputCenter:]
+ GCC_except_table286
+ GCC_except_table291
+ _OBJC_IVAR_$_CUIGlassHighlightInternal.inputCenter
+ __ZL19classLoadUniKernelsP10objc_class
+ __ZL21envCCMakeBlurMapClassv
+ __ZL21envCCMakeBlurMapClassv.cold.1
+ __ZN2CI24CUIGlassHighlightKernels21arg_name_s_scale_biasE
+ __ZN2CI24CUIGlassHighlightKernels40arg_name_s_values0_values1_sdfZero_colorE
+ __ZN2CI24CUIGlassHighlightKernels47arg_name_s_values0_values1_sdfZero_color_centerE
+ __ZN2CI24CUIGlassHighlightKernels52arg_name_s_radius_bias_amount_color_sdfScale_sdfZeroE
+ __ZN2CI24CUIGlassHighlightKernelsL38arg_type_Sampler_Float_Float_DestCoordE
+ __ZN2CI24CUIGlassHighlightKernelsL53arg_type_Sampler_Float4_Float4_Float_Float4_DestCoordE
+ __ZN2CI24CUIGlassHighlightKernelsL57arg_type_Sampler_Float_Float_Float4_Float_Float_DestCoordE
+ __ZN2CI24CUIGlassHighlightKernelsL60arg_type_Sampler_Float4_Float4_Float_Float4_Float2_DestCoordE
+ __ZN2CI24CUIGlassHighlightKernelsL65arg_type_Sampler_Float_Float2_Float2_Float_Float_Float4_DestCoordE
+ __ZN2CI25colormatch_builtinKernels49arg_name_im_headrooms_coefs_coeffs4_lut_dim_rangeE
+ __ZN2CI25colormatch_builtinKernelsL69arg_type_Sample_Float2_Float4_Float_Sampler2D_Float2_Float2_DestCoordE
+ __ZN8cikernel28_computeSmoothedFWidthCommonEP10SamplerObj4vec2fi
+ __ZN8cikernel28_computeSmoothedFWidthCommonEP10SamplerObj4vec2fi.cold.1
+ __ZNK2CI11SurfaceNode16chroma_scale_fixEb
+ __ZNK2CI12ProviderNode16chroma_scale_fixEb
+ __ZNSt3__16__treeIPKcNS_4lessIS2_EENS_9allocatorIS2_EEE25__emplace_unique_key_argsIS2_JS2_EEENS_4pairINS_15__tree_iteratorIS2_PNS_11__tree_nodeIS2_PvEElEEbEERKT_DpOT0_
+ ___22-[CUIGlow outputImage]_block_invoke
+ ___25-[CUISDFFill outputImage]_block_invoke
+ ___32-[CUIGlassHighlight outputImage]_block_invoke
+ ___41-[CUIGlassHighlightFromAlpha outputImage]_block_invoke
+ ___50-[CUISimplifiedShapeAwareGradientMask outputImage]_block_invoke
+ ___Block_byref_object_copy_.125
+ ___Block_byref_object_copy_.130
+ ___Block_byref_object_dispose_.126
+ ___Block_byref_object_dispose_.131
+ ____ZN2CIL20AppendConverterArrayEPNS_7ContextEPNS_4NodeENS_10ImageIndexEPK9__CFArrayNS_18ConverterDirectionEbb_block_invoke.111
+ ____ZN2CIL20AppendConverterArrayEPNS_7ContextEPNS_4NodeENS_10ImageIndexEPK9__CFArrayNS_18ConverterDirectionEbb_block_invoke.118
+ ____ZN2CIL21print_graph_recursiveINS_4NodeENS_9NodeIndexENS1_9NodeStatsEEEvP7__sFILEPKT_iRKNSt3__113unordered_mapIT0_T1_NS9_4hashISB_EENS9_8equal_toISB_EENS9_9allocatorINS9_4pairIKSB_SC_EEEEEE_block_invoke.127
+ ____ZN2CIL21print_graph_recursiveINS_4NodeENS_9NodeIndexENS1_9NodeStatsEEEvP7__sFILEPKT_iRKNSt3__113unordered_mapIT0_T1_NS9_4hashISB_EENS9_8equal_toISB_EENS9_9allocatorINS9_4pairIKSB_SC_EEEEEE_block_invoke.132
+ ___block_descriptor_120_e8_32r40r48r56r64r72r80r88r_e99_v32?0r*8i16S20^{__sFILE=*iiss{__sbuf=*i}i^v^?^?^?^?{__sbuf=*i}^{__sFILEX}i[3C][1C]{__sbuf=*i}iq}24lr32l8r40l8r48l8r56l8r64l8r72l8r80l8r88l8
+ ___block_descriptor_tmp.102
+ ___block_descriptor_tmp.129
+ ___block_descriptor_tmp.142
+ ___block_literal_global.123
+ ___block_literal_global.126
+ ___block_literal_global.150
+ ___block_literal_global.217
+ ___block_literal_global.257
+ ___block_literal_global.49
+ ___block_literal_global.64
+ _objc_msgSend$inputCenter
+ _objc_msgSend$kernelNamesFromMetalLibrary:
- -[CIDepthEffectMakeBlurMap unifiedRenderingOutputImage:].cold.3
- GCC_except_table134
- GCC_except_table284
- GCC_except_table285
- GCC_except_table289
- __ZN2CI19sw_distanceFractionERKNS_22SWRendererFunctionNodeEPKNS_26SWRendererFunctionArgumentEPKNS_24SWRendererFunctionOutputEP10SamplerObjPvRK6IPoint
- __ZN2CI24CUIGlassHighlightKernels17arg_name_s_fwidthE
- __ZN2CI24CUIGlassHighlightKernels34arg_name_s_sdfZero_sdfScale_radiusE
- __ZN2CI24CUIGlassHighlightKernels46arg_name_s_dfdxW_values0_values1_sdfZero_colorE
- __ZN2CI24CUIGlassHighlightKernels47arg_name_s_fwidth_values0_values1_sdfZero_colorE
- __ZN2CI24CUIGlassHighlightKernels66arg_name_distanceFraction_distanceFractionFWidth_bias_amount_colorE
- __ZN2CI24CUIGlassHighlightKernelsL43arg_type_Sample_Float_Float_Float_DestCoordE
- __ZN2CI24CUIGlassHighlightKernelsL45arg_type_Sample_Sample_Float_Float4_DestCoordE
- __ZN2CI24CUIGlassHighlightKernelsL59arg_type_Sample_Sample_Float4_Float4_Float_Float4_DestCoordE
- __ZN2CI24CUIGlassHighlightKernelsL64arg_type_Sample_Float_Float2_Float2_Float_Float_Float4_DestCoordE
- __ZN2CI25colormatch_builtinKernels43arg_name_im_headrooms_coefs_coeffs4_lut_dimE
- __ZN2CI25colormatch_builtinKernelsL62arg_type_Sample_Float2_Float4_Float_Sampler2D_Float2_DestCoordE
- __ZN2CIL17_distanceFractionE
- __ZN2CIL22_distanceFraction_nameE
- __ZNK2CI11SurfaceNode16chroma_scale_fixEv
- __ZNK2CI12ProviderNode16chroma_scale_fixEv
- ___Block_byref_object_copy_.124
- ___Block_byref_object_copy_.129
- ___Block_byref_object_dispose_.125
- ___Block_byref_object_dispose_.130
- ____ZN2CIL20AppendConverterArrayEPNS_7ContextEPNS_4NodeENS_10ImageIndexEPK9__CFArrayNS_18ConverterDirectionEbb_block_invoke.110
- ____ZN2CIL20AppendConverterArrayEPNS_7ContextEPNS_4NodeENS_10ImageIndexEPK9__CFArrayNS_18ConverterDirectionEbb_block_invoke.117
- ____ZN2CIL21print_graph_recursiveINS_4NodeENS_9NodeIndexENS1_9NodeStatsEEEvP7__sFILEPKT_iRKNSt3__113unordered_mapIT0_T1_NS9_4hashISB_EENS9_8equal_toISB_EENS9_9allocatorINS9_4pairIKSB_SC_EEEEEE_block_invoke.126
- ____ZN2CIL21print_graph_recursiveINS_4NodeENS_9NodeIndexENS1_9NodeStatsEEEvP7__sFILEPKT_iRKNSt3__113unordered_mapIT0_T1_NS9_4hashISB_EENS9_8equal_toISB_EENS9_9allocatorINS9_4pairIKSB_SC_EEEEEE_block_invoke.131
- ___block_descriptor_112_e8_32r40r48r56r64r72r80r_e99_v32?0r*8i16S20^{__sFILE=*iiss{__sbuf=*i}i^v^?^?^?^?{__sbuf=*i}^{__sFILEX}i[3C][1C]{__sbuf=*i}iq}24lr32l8r40l8r48l8r56l8r64l8r72l8r80l8
- ___block_descriptor_tmp.118
- ___block_descriptor_tmp.140
- ___block_literal_global.65
CStrings:
+ "%s::"
+ "1590"
+ "CoreImageKernels_only.ci"
+ "__ci_client_namespace__"
+ "float _computeSmoothedFWidthCommon(sampler s, vec2 dc, float scale, int channel) {\n  vec2 base_coord = samplerTransform(s, dc);\n  vec2 delta_x = samplerTransform(s, dc + vec2(1.0, 0.0)) - base_coord;\n  vec2 delta_y = samplerTransform(s, dc + vec2(0.0, 1.0)) - base_coord;\n  vec2 sample_offsets[41];\n  float sample_weights[41];\n  float smoothed_fwidth = 0.0;\n  for (int i = 0; i < 41; i++) {\n    vec2 offset = sample_offsets[i];\n    vec2 sample_coord = (base_coord + (offset.x * delta_x)) + (offset.y * delta_y);\n    vec4 left = sample(s, sample_coord - delta_x);\n    vec4 right = sample(s, sample_coord + delta_x);\n    vec4 down = sample(s, sample_coord - delta_y);\n    vec4 up = sample(s, sample_coord + delta_y);\n    float dfdx = (0.5 * scale) * (right[channel] - left[channel]);\n    float dfdy = (0.5 * scale) * (up[channel] - down[channel]);\n    float fwidth = abs(dfdx) + abs(dfdy);\n    smoothed_fwidth += fwidth * sample_weights[i];\n  }\n  smoothed_fwidth /= 3.170218e+00;\n  return (1.0 / 1.200) * clamp(smoothed_fwidth, 1e-4, 2.0);\n}\nfloat _computeSmoothedFWidthTransformed(sampler s, vec2 dc, float scale) {\n  return _computeSmoothedFWidthCommon(s, dc, scale, 0);\n}\nfloat _saturate(float a) {\n  return max(0.0, min(1.0, a));\n}\nkernel vec4 _glow(sampler s, float radius, float bias_amount, vec4 color, float sdfScale, float sdfZero) {\n  vec2 dc = destCoord();\n  float distance = (sample(s, samplerCoord(s)).x - sdfZero) * sdfScale;\n  float distanceFraction = distance / radius;\n  float strength = exp(((-0.5) * distanceFraction) * distanceFraction);\n  strength /= max((bias_amount * (1.0 - strength)) + 1.0, 1e-4);\n  float w = _computeSmoothedFWidthTransformed(s, dc, sdfScale / radius);\n  float mask = _saturate(0.5 + (distanceFraction / w));\n  color *= strength * mask;\n  return color;\n}\n"
+ "float _computeSmoothedFWidthCommon(sampler s, vec2 dc, float scale, int channel) {\n  vec2 base_coord = samplerTransform(s, dc);\n  vec2 delta_x = samplerTransform(s, dc + vec2(1.0, 0.0)) - base_coord;\n  vec2 delta_y = samplerTransform(s, dc + vec2(0.0, 1.0)) - base_coord;\n  vec2 sample_offsets[41];\n  float sample_weights[41];\n  float smoothed_fwidth = 0.0;\n  for (int i = 0; i < 41; i++) {\n    vec2 offset = sample_offsets[i];\n    vec2 sample_coord = (base_coord + (offset.x * delta_x)) + (offset.y * delta_y);\n    vec4 left = sample(s, sample_coord - delta_x);\n    vec4 right = sample(s, sample_coord + delta_x);\n    vec4 down = sample(s, sample_coord - delta_y);\n    vec4 up = sample(s, sample_coord + delta_y);\n    float dfdx = (0.5 * scale) * (right[channel] - left[channel]);\n    float dfdy = (0.5 * scale) * (up[channel] - down[channel]);\n    float fwidth = abs(dfdx) + abs(dfdy);\n    smoothed_fwidth += fwidth * sample_weights[i];\n  }\n  smoothed_fwidth /= 3.170218e+00;\n  return (1.0 / 1.200) * clamp(smoothed_fwidth, 1e-4, 2.0);\n}\nfloat _computeSmoothedFWidthTransformed(sampler s, vec2 dc, float scale) {\n  return _computeSmoothedFWidthCommon(s, dc, scale, 0);\n}\nkernel vec4 _sdfFill(sampler s, float scale, float bias) {\n  vec2 dc = destCoord();\n  float sdf = sample(s, samplerCoord(s)).x;\n  float t = (sdf * scale) + bias;\n  float r = _computeSmoothedFWidthTransformed(s, dc, scale) * 0.5;\n  float c = smoothstep(-r, r, t);\n  return vec4(c, 0.0, 0.0, 1.0);\n}\n"
+ "float _saturate(float a) {\n  return max(0.0, min(1.0, a));\n}\nfloat _computeSmoothedFWidthCommon(sampler s, vec2 dc, float scale, int channel) {\n  vec2 base_coord = samplerTransform(s, dc);\n  vec2 delta_x = samplerTransform(s, dc + vec2(1.0, 0.0)) - base_coord;\n  vec2 delta_y = samplerTransform(s, dc + vec2(0.0, 1.0)) - base_coord;\n  vec2 sample_offsets[41];\n  float sample_weights[41];\n  float smoothed_fwidth = 0.0;\n  for (int i = 0; i < 41; i++) {\n    vec2 offset = sample_offsets[i];\n    vec2 sample_coord = (base_coord + (offset.x * delta_x)) + (offset.y * delta_y);\n    vec4 left = sample(s, sample_coord - delta_x);\n    vec4 right = sample(s, sample_coord + delta_x);\n    vec4 down = sample(s, sample_coord - delta_y);\n    vec4 up = sample(s, sample_coord + delta_y);\n    float dfdx = (0.5 * scale) * (right[channel] - left[channel]);\n    float dfdy = (0.5 * scale) * (up[channel] - down[channel]);\n    float fwidth = abs(dfdx) + abs(dfdy);\n    smoothed_fwidth += fwidth * sample_weights[i];\n  }\n  smoothed_fwidth /= 3.170218e+00;\n  return (1.0 / 1.200) * clamp(smoothed_fwidth, 1e-4, 2.0);\n}\nfloat _computeSmoothedFWidthTransformed(sampler s, vec2 dc, float scale) {\n  return _computeSmoothedFWidthCommon(s, dc, scale, 0);\n}\nkernel vec4 _glassHighlight(sampler s, vec4 values0, vec4 values1, float sdfZero, vec4 color) {\n  vec2 dc = destCoord();\n  vec3 sdf = sample(s, samplerCoord(s)).xyz;\n  float height = values0.x;\n  float inset = values0.y;\n  float spread = values0.z;\n  float bias_amount = values0.w;\n  float curvature = values1.x;\n  vec2 light_dir = values1.yz;\n  float sdfScale = values1.w;\n  float distance = ((-(sdf.r - sdfZero)) * sdfScale) - inset;\n  vec2 gradient = -((sdf.gb * 2.0) - 1.0);\n  float d_norm = _saturate(distance / height);\n  float h = mix(1.0, 1.0 - d_norm, curvature);\n  float w = _computeSmoothedFWidthTransformed(s, dc, sdfScale);\n  float mask = _saturate(0.5 + ((height - distance) / w));\n  mask *= _saturate(0.5 + (distance / w));\n  float alpha = _saturate((dot(light_dir, gradient) - spread) / max(1.0 - float(spread), 1e-4));\n  alpha = alpha / max((bias_amount * (1.0 - alpha)) + 1.0, 1e-4);\n  color *= (mask * alpha) * h;\n  return color;\n}\n"
+ "float _saturate(float a) {\n  return max(0.0, min(1.0, a));\n}\nfloat _computeSmoothedFWidthCommon(sampler s, vec2 dc, float scale, int channel) {\n  vec2 base_coord = samplerTransform(s, dc);\n  vec2 delta_x = samplerTransform(s, dc + vec2(1.0, 0.0)) - base_coord;\n  vec2 delta_y = samplerTransform(s, dc + vec2(0.0, 1.0)) - base_coord;\n  vec2 sample_offsets[41];\n  float sample_weights[41];\n  float smoothed_fwidth = 0.0;\n  for (int i = 0; i < 41; i++) {\n    vec2 offset = sample_offsets[i];\n    vec2 sample_coord = (base_coord + (offset.x * delta_x)) + (offset.y * delta_y);\n    vec4 left = sample(s, sample_coord - delta_x);\n    vec4 right = sample(s, sample_coord + delta_x);\n    vec4 down = sample(s, sample_coord - delta_y);\n    vec4 up = sample(s, sample_coord + delta_y);\n    float dfdx = (0.5 * scale) * (right[channel] - left[channel]);\n    float dfdy = (0.5 * scale) * (up[channel] - down[channel]);\n    float fwidth = abs(dfdx) + abs(dfdy);\n    smoothed_fwidth += fwidth * sample_weights[i];\n  }\n  smoothed_fwidth /= 3.170218e+00;\n  return (1.0 / 1.200) * clamp(smoothed_fwidth, 1e-4, 2.0);\n}\nfloat _computeSmoothedFWidthTransformed(sampler s, vec2 dc, float scale) {\n  return _computeSmoothedFWidthCommon(s, dc, scale, 0);\n}\nkernel vec4 _simplifiedShapeAwareGradientMask(sampler s, float borderWidth, vec2 opacityBounds, vec2 contourOpacityBounds, float sdfScale, float sdfZero, vec4 bounds) {\n  vec2 dc = destCoord();\n  float distance = (-(sample(s, samplerCoord(s)).r - sdfZero)) * sdfScale;\n  float distanceFraction = _saturate(distance / borderWidth);\n  float verticalDistance = _saturate((dc.y - bounds.y) / bounds.w);\n  float verticalTransparency = mix(opacityBounds.y, opacityBounds.x, verticalDistance);\n  float verticalContourTransparency = mix(contourOpacityBounds.y, contourOpacityBounds.x, verticalDistance);\n  float transparencyWithContour = mix(verticalContourTransparency, verticalTransparency, distanceFraction);\n  transparencyWithContour = smoothstep(0.0, 1.0, transparencyWithContour);\n  float w = _computeSmoothedFWidthTransformed(s, dc, sdfScale);\n  float mask = _saturate(0.5 + (distanceFraction / w));\n  transparencyWithContour = mix(1.0, transparencyWithContour, mask);\n  return vec4(transparencyWithContour);\n}\n"
+ "float _saturate(float a) {\n  return max(0.0, min(1.0, a));\n}\nfloat _computeSmoothedFWidthCommon(sampler s, vec2 dc, float scale, int channel) {\n  vec2 base_coord = samplerTransform(s, dc);\n  vec2 delta_x = samplerTransform(s, dc + vec2(1.0, 0.0)) - base_coord;\n  vec2 delta_y = samplerTransform(s, dc + vec2(0.0, 1.0)) - base_coord;\n  vec2 sample_offsets[41];\n  float sample_weights[41];\n  float smoothed_fwidth = 0.0;\n  for (int i = 0; i < 41; i++) {\n    vec2 offset = sample_offsets[i];\n    vec2 sample_coord = (base_coord + (offset.x * delta_x)) + (offset.y * delta_y);\n    vec4 left = sample(s, sample_coord - delta_x);\n    vec4 right = sample(s, sample_coord + delta_x);\n    vec4 down = sample(s, sample_coord - delta_y);\n    vec4 up = sample(s, sample_coord + delta_y);\n    float dfdx = (0.5 * scale) * (right[channel] - left[channel]);\n    float dfdy = (0.5 * scale) * (up[channel] - down[channel]);\n    float fwidth = abs(dfdx) + abs(dfdy);\n    smoothed_fwidth += fwidth * sample_weights[i];\n  }\n  smoothed_fwidth /= 3.170218e+00;\n  return (1.0 / 1.200) * clamp(smoothed_fwidth, 1e-4, 2.0);\n}\nkernel vec4 _glassHighlightFromAlpha(sampler s, vec4 values0, vec4 values1, float sdfZero, vec4 color, vec2 center) {\n  vec2 dc = destCoord();\n  vec4 sample_val = sample(s, samplerCoord(s));\n  float height = values0.x;\n  float inset = values0.y;\n  float spread = values0.z;\n  float bias_amount = values0.w;\n  float curvature = values1.x;\n  vec2 light_dir = values1.yz;\n  float sdfScale = values1.w;\n  float distance = ((sample_val.w - sdfZero) * sdfScale) - inset;\n  float d_norm = _saturate(distance / height);\n  float h = mix(1.0, 1.0 - d_norm, curvature);\n  vec2 normal = normalize(dc - center);\n  bool fullBleed = inset == 0.0;\n  float w = _computeSmoothedFWidthCommon(s, dc, sdfScale, 3);\n  float mask = _saturate(0.5 + ((height - distance) / w));\n  if (!fullBleed) {\n    mask *= _saturate(0.5 + (distance / w));\n  }\n  float alpha = _saturate((dot(light_dir, normal) - spread) / max(1.0 - float(spread), 1e-4));\n  alpha = alpha / max(float((bias_amount * (1.0 - alpha)) + 1.0), 1e-4);\n  color *= (mask * alpha) * h;\n  return color;\n}\n"
+ "float _saturate(float a) {\n  return max(0.0, min(1.0, a));\n}\nkernel vec4 _shapeAwareGradientMask(vec4 s, float borderWidth, float minOpacity, vec2 opaqueEnd, float length, vec3 lightDirection, float sdfScale, float sdfZero) {\n  float distance = (-(s.r - sdfZero)) * sdfScale;\n  float distanceFraction = _saturate(distance / borderWidth);\n  float transparency = _saturate(dot(lightDirection.xy, opaqueEnd - destCoord()) / length);\n  float transparencyWithContour = mix(1.0 - transparency, transparency, distanceFraction);\n  float withGradient = mix(1.0, minOpacity, transparencyWithContour);\n  withGradient = smoothstep(0.0, 1.0, withGradient);\n  return vec4(withGradient);\n}\n"
+ "float _step_function(float edge, float x) {\n  return (x < edge) ? 0.0 : 1.0;\n}\nvec2 _saturate2(vec2 a) {\n  return max(vec2(0.0), min(vec2(1.0), a));\n}\nkernel vec4 _fallbackComputeNormals(vec4 s, vec4 dfDxdfDyX) {\n  float dist = s.x;\n  vec2 gradient = vec2(-dfDxdfDyX.x, dfDxdfDyX.y);\n  float size = length(gradient);\n  vec2 grad_norm = (_step_function(size, 1e-4) * gradient) / size;\n  vec4 combined = vec4(dist, _saturate2((grad_norm * vec2(0.5)) + vec2(0.5)), 1.0);\n  return combined;\n}\n"
+ "kernel vec4 _flexLumaScaling(vec4 im, vec2 headrooms, vec4 coefs, float coeffs4, sampler2D lut, vec2 dim, vec2 range) {\n  float imMax = max(im.r, max(im.g, im.b));\n  float Y = dot(coefs, vec4(im.rgb, imMax));\n  float signY = sign(Y);\n  Y = max(abs(Y), 1e-6);\n  Y = clamp(Y, 0.0, 1.0);\n  float lutCoord = (Y * dim.x) + dim.y;\n  float gain = texture2D(lut, vec2(lutCoord, 0.5)).r;\n  float scale = (signY * gain) * coeffs4;\n  vec4 result = vec4(im.rgb * scale, im.a);\n  result.rgb = clamp(result.rgb, range.x, range.y);\n  return result;\n}\n"
+ "loadShaders"
+ "namespace %s {\n"
+ "using namespace %s;\n"
+ "} // %s \n"
- "1583"
- "dfdxW"
- "distanceFraction"
- "distanceFractionFWidth"
- "float saturate(float a) {\n  return max(0.0, min(1.0, a));\n}\nkernel vec4 _glassHighlight(vec4 s, vec4 fwidth, vec4 values0, vec4 values1, float sdfZero, vec4 color) {\n  vec3 sdf = s.xyz;\n  float height = values0.x;\n  float inset = values0.y;\n  float spread = values0.z;\n  float bias_amount = values0.w;\n  float curvature = values1.x;\n  vec2 light_dir = values1.yz;\n  float sdfScale = values1.w;\n  float distance = ((-(sdf.r - sdfZero)) * sdfScale) - inset;\n  vec2 gradient = -((sdf.gb * 2.0) - 1.0);\n  float d_norm = saturate(distance / height);\n  float h = mix(1.0, 1.0 - d_norm, curvature);\n  float w = (1.0 / 1.200) * max(fwidth.x, 1e-4);\n  float mask = saturate(0.5 + ((height - distance) / w));\n  mask *= saturate(0.5 + (distance / w));\n  float alpha = saturate((dot(light_dir, gradient) - spread) / max(1.0 - float(spread), 1e-4));\n  alpha = alpha / max((bias_amount * (1.0 - alpha)) + 1.0, 1e-4);\n  color *= (mask * alpha) * h;\n  return color;\n}\n"
- "float saturate(float a) {\n  return max(0.0, min(1.0, a));\n}\nkernel vec4 _glassHighlightFromAlpha(vec4 s, vec4 dfdxW, vec4 values0, vec4 values1, float sdfZero, vec4 color) {\n  float height = values0.x;\n  float inset = values0.y;\n  float spread = values0.z;\n  float bias_amount = values0.w;\n  float curvature = values1.x;\n  vec2 light_dir = values1.yz;\n  float sdfScale = values1.w;\n  float distance = ((s.w - sdfZero) * sdfScale) - inset;\n  float d_norm = max(0.0, min(1.0, distance / height));\n  float h = mix(1.0, 1.0 - d_norm, curvature);\n  float horiz = dfdxW.x;\n  float vert = dfdxW.y;\n  vec2 normal = vec2(horiz, vert);\n  normal /= length(normal);\n  normal *= -1.0;\n  float fwidth = abs(horiz) + abs(vert);\n  float w = (1.0 / 1.200) * max(fwidth, 1e-4);\n  float mask = saturate(0.5 + ((height - distance) / w));\n  if (inset != 0.0) {\n    mask *= saturate(0.5 + (distance / w));\n  }\n  float alpha = saturate((dot(light_dir, normal) - spread) / max(1.0 - float(spread), 1e-4));\n  alpha = alpha / max(float((bias_amount * (1.0 - alpha)) + 1.0), 1e-4);\n  color *= (mask * alpha) * h;\n  return color;\n}\n"
- "float saturate(float a) {\n  return max(0.0, min(1.0, a));\n}\nkernel vec4 _glow(vec4 distanceFraction, vec4 distanceFractionFWidth, float bias_amount, vec4 color) {\n  float v = distanceFraction.x;\n  float strength = exp(((-0.5) * v) * v);\n  strength /= max((bias_amount * (1.0 - strength)) + 1.0, 1e-4);\n  float fwidth = distanceFractionFWidth.x;\n  float w = max(fwidth, 1e-4);\n  float mask = saturate(0.5 + (v / w));\n  color *= strength * mask;\n  return color;\n}\n"
- "float saturate(float a) {\n  return max(0.0, min(1.0, a));\n}\nkernel vec4 _shapeAwareGradientMask(vec4 s, float borderWidth, float minOpacity, vec2 opaqueEnd, float length, vec3 lightDirection, float sdfScale, float sdfZero) {\n  float distance = (-(s.r - sdfZero)) * sdfScale;\n  float distanceFraction = saturate(distance / borderWidth);\n  float transparency = saturate(dot(lightDirection.xy, opaqueEnd - destCoord()) / length);\n  float transparencyWithContour = mix(1.0 - transparency, transparency, distanceFraction);\n  float withGradient = mix(1.0, minOpacity, transparencyWithContour);\n  withGradient = smoothstep(0.0, 1.0, withGradient);\n  return vec4(withGradient);\n}\n"
- "float saturate(float a) {\n  return max(0.0, min(1.0, a));\n}\nkernel vec4 _simplifiedShapeAwareGradientMask(vec4 s, float borderWidth, vec2 opacityBounds, vec2 contourOpacityBounds, float sdfScale, float sdfZero, vec4 bounds) {\n  float distance = (-(s.r - sdfZero)) * sdfScale;\n  float distanceFraction = saturate(distance / borderWidth);\n  float verticalDistance = saturate((destCoord().y - bounds.y) / bounds.w);\n  float verticalTransparency = mix(opacityBounds.y, opacityBounds.x, verticalDistance);\n  float verticalContourTransparency = mix(contourOpacityBounds.y, contourOpacityBounds.x, verticalDistance);\n  float transparencyWithContour = mix(verticalContourTransparency, verticalTransparency, distanceFraction);\n  transparencyWithContour = smoothstep(0.0, 1.0, transparencyWithContour);\n  return vec4(transparencyWithContour);\n}\n"
- "float step_function(float edge, float x) {\n  return (x < edge) ? 0.0 : 1.0;\n}\nvec2 saturate2(vec2 a) {\n  return max(vec2(0.0), min(vec2(1.0), a));\n}\nkernel vec4 _fallbackComputeNormals(vec4 s, vec4 dfDxdfDyX) {\n  float dist = s.x;\n  vec2 gradient = vec2(-dfDxdfDyX.x, dfDxdfDyX.y);\n  float size = length(gradient);\n  vec2 grad_norm = (step_function(size, 1e-4) * gradient) / size;\n  vec4 combined = vec4(dist, saturate2((grad_norm * vec2(0.5)) + vec2(0.5)), 1.0);\n  return combined;\n}\n"
- "fwidth"
- "kernel vec4 _distanceFraction(vec4 s, float sdfZero, float sdfScale, float radius) {\n  float distance = (s.x - sdfZero) * sdfScale;\n  float distanceFraction = distance / radius;\n  return vec4(distanceFraction, distanceFraction, distanceFraction, 1.0);\n}\n"
- "kernel vec4 _flexLumaScaling(vec4 im, vec2 headrooms, vec4 coefs, float coeffs4, sampler2D lut, vec2 dim) {\n  float imMax = max(im.r, max(im.g, im.b));\n  float Y = dot(coefs, vec4(im.rgb, imMax));\n  float signY = sign(Y);\n  Y = max(abs(Y), 1e-6);\n  Y = clamp(Y, 0.0, 1.0);\n  float lutCoord = (Y * dim.x) + dim.y;\n  float gain = texture2D(lut, vec2(lutCoord, 0.5)).r;\n  float scale = (signY * gain) * coeffs4;\n  vec4 result = vec4(im.rgb * scale, im.a);\n  return result;\n}\n"
- "kernel vec4 _sdfFill(vec4 s, vec4 fwidth) {\n  float r = fwidth.x * 0.5;\n  float c = smoothstep(-r, r, s.x);\n  return vec4(c, 0.0, 0.0, 1.0);\n}\n"

```
