## SceneKit

> `/System/Library/Frameworks/SceneKit.framework/SceneKit`

```diff

-599.0.0.0.0
-  __TEXT.__text: 0x3b0fc8
-  __TEXT.__auth_stubs: 0x2e60
-  __TEXT.__objc_methlist: 0x11e04
+599.108.0.0.0
+  __TEXT.__text: 0x3b0d28
+  __TEXT.__auth_stubs: 0x2e80
+  __TEXT.__objc_methlist: 0x11d74
   __TEXT.__const: 0x26098
-  __TEXT.__oslogstring: 0x15eda
-  __TEXT.__cstring: 0x96aba
-  __TEXT.__gcc_except_tab: 0x3c9c
+  __TEXT.__oslogstring: 0x15cd2
+  __TEXT.__cstring: 0x96bda
+  __TEXT.__gcc_except_tab: 0x3cdc
+  __TEXT.__dlopen_cstrs: 0x45
   __TEXT.__ustring: 0x1e
-  __TEXT.__unwind_info: 0xaed8
+  __TEXT.__unwind_info: 0xaee0
   __TEXT.__eh_frame: 0x38
-  __TEXT.__objc_classname: 0x1cd0
-  __TEXT.__objc_methname: 0x2420c
-  __TEXT.__objc_methtype: 0x11ec4
-  __TEXT.__objc_stubs: 0x1d3a0
-  __DATA_CONST.__got: 0x530
-  __DATA_CONST.__const: 0x7080
-  __DATA_CONST.__objc_classlist: 0x6e0
+  __TEXT.__objc_classname: 0x1c4a
+  __TEXT.__objc_methname: 0x241fa
+  __TEXT.__objc_methtype: 0x11bce
+  __TEXT.__objc_stubs: 0x1d3c0
+  __DATA_CONST.__got: 0x538
+  __DATA_CONST.__const: 0x7068
+  __DATA_CONST.__objc_classlist: 0x6c8
   __DATA_CONST.__objc_catlist: 0xa0
   __DATA_CONST.__objc_protolist: 0x320
   __DATA_CONST.__objc_imageinfo: 0x8
-  __DATA_CONST.__objc_const: 0x27c40
-  __DATA_CONST.__objc_selrefs: 0x90f0
+  __DATA_CONST.__objc_const: 0x27a20
+  __DATA_CONST.__objc_selrefs: 0x9128
   __DATA_CONST.__objc_arraydata: 0x270
   __AUTH_CONST.__const: 0xa390
-  __AUTH_CONST.__cfstring: 0x20ae0
-  __AUTH_CONST.__objc_const: 0x6458
+  __AUTH_CONST.__cfstring: 0x20a60
+  __AUTH_CONST.__objc_const: 0x62f0
   __AUTH_CONST.__objc_intobj: 0x558
   __AUTH_CONST.__objc_arrayobj: 0xa8
   __AUTH_CONST.__objc_doubleobj: 0x20
   __AUTH_CONST.__objc_dictobj: 0xf0
   __AUTH_CONST.__objc_floatobj: 0x10
-  __AUTH_CONST.__auth_got: 0x1748
+  __AUTH_CONST.__auth_got: 0x1758
   __AUTH.__data: 0x3790
-  __AUTH.__objc_data: 0x4380
+  __AUTH.__objc_data: 0x4290
   __DATA.__objc_protorefs: 0x220
-  __DATA.__objc_classrefs: 0xa58
-  __DATA.__objc_superrefs: 0x600
-  __DATA.__objc_ivar: 0x1c68
+  __DATA.__objc_classrefs: 0xa40
+  __DATA.__objc_superrefs: 0x5e8
+  __DATA.__objc_ivar: 0x1c38
   __DATA.__data: 0x33ac
-  __DATA.__bss: 0x215d
+  __DATA.__bss: 0x216d
   __DATA.__common: 0x1b1
   __DATA_DIRTY.__objc_data: 0x140
   - /System/Library/Frameworks/AVFAudio.framework/AVFAudio

   - /System/Library/Frameworks/UniformTypeIdentifiers.framework/UniformTypeIdentifiers
   - /System/Library/PrivateFrameworks/CoreSymbolication.framework/CoreSymbolication
   - /System/Library/PrivateFrameworks/CoreUI.framework/CoreUI
+  - /System/Library/PrivateFrameworks/SoftLinking.framework/SoftLinking
   - /usr/lib/libMobileGestalt.dylib
   - /usr/lib/libSystem.B.dylib
   - /usr/lib/libc++.1.dylib

   - /usr/lib/libobjc.A.dylib
   - /usr/lib/libxml2.2.dylib
   - /usr/lib/libz.1.dylib
-  UUID: D133DA8B-2AFD-320E-A988-8D943910EDFE
-  Functions: 22179
-  Symbols:   55728
-  CStrings:  20220
+  UUID: 6D0212D4-6541-31DC-83AB-204B5C56D0FA
+  Functions: 22170
+  Symbols:   55683
+  CStrings:  20208
 
Symbols:
+ -[NSCoder(SCNExtensions) scn_decodeArrayOfObjectsOfClass:containingNestedContainersForKey:]
+ -[NSCoder(SCNExtensions) scn_decodeArrayOfObjectsOfClasses:containingNestedContainersForKey:]
+ -[NSCoder(SCNExtensions) scn_decodeDictionaryWithKeysOfClass:objectsOfClass:containingNestedContainersForKey:]
+ -[NSCoder(SCNExtensions) scn_decodeDictionaryWithKeysOfClasses:objectsOfClasses:containingNestedContainersForKey:]
+ -[SCNGeometryDeformerInstanceWrapper _currentFrameHash]
+ -[SCNGeometryWrapDeformer initWithInnerLayerNode:outerLayerNode:parameters:]
+ -[SCNGeometryWrapDeformerInstance dealloc]
+ -[SCNGeometryWrapDeformerInstance initWithNode:drivingNode:deformer:outputs:computeVertexCount:context:]
+ -[SCNGeometryWrapDeformerInstance initWithNode:drivingNode:deformer:outputs:computeVertexCount:context:].cold.1
+ -[SCNGeometryWrapDeformerInstance initWithNode:innerLayerNode:outerLayerNode:deformer:outputs:computeVertexCount:context:]
+ -[SCNGeometryWrapDeformerInstance initWithNode:innerLayerNode:outerLayerNode:deformer:outputs:computeVertexCount:context:].cold.1
+ -[SCNGeometryWrapDeformerInstance updateWithContext:]
+ -[SCNGeometryWrapDeformerParameters bindingMode]
+ -[SCNGeometryWrapDeformerParameters dealloc]
+ -[SCNGeometryWrapDeformerParameters extraLayerMeshesWithDrivingMesh0:drivingMesh1:]
+ -[SCNGeometryWrapDeformerParameters initParametersIfNeededWithDrivingNodeRef:deformedNodeRef:]
+ -[SCNGeometryWrapDeformerParameters initParametersIfNeededWithDrivingNodeRef:deformedNodeRef:].cold.1
+ -[SCNGeometryWrapDeformerParameters initParametersIfNeededWithDrivingNodeRef:deformedNodeRef:].cold.2
+ -[SCNGeometryWrapDeformerParameters initParametersIfNeededWithInnerLayerNodeRef:outerLayerNodeRef:deformedNodeRef:]
+ -[SCNGeometryWrapDeformerParameters initWithCoder:].cold.1
+ -[SCNGeometryWrapDeformerParameters initWithCoder:].cold.2
+ -[SCNGeometryWrapDeformerParameters initWithCoder:].cold.3
+ -[SCNGeometryWrapDeformerParameters initWithCoder:].cold.4
+ -[SCNGeometryWrapDeformerParameters initWithCoder:].cold.5
+ -[SCNGeometryWrapDeformerParameters initWithCoder:].cold.6
+ -[SCNGeometryWrapDeformerParameters initWithCoder:].cold.7
+ -[SCNGeometryWrapDeformerParameters initWithCoder:].cold.8
+ -[SCNGeometryWrapDeformerParameters initWithInnerLayerNode:outerLayerNode:deformedNode:bindingMode:bindingTransform:]
+ -[SCNMTLDeformerStack currentFrameHash]
+ _C3DMaterialGetBlendStatesUseConstantAlpha
+ _C3DPlaneMakeWithPoints
+ _C3DPlaneMakeWithTriangle
+ _C3DTriangle3PointAtIndex
+ _MDLAssetLoadingOptionPreserveTopology
+ _OBJC_CLASS_$_SCNGeometryWrapDeformerInstance
+ _OBJC_IVAR_$_SCNGeometryWrapDeformer._innerLayerNode
+ _OBJC_IVAR_$_SCNGeometryWrapDeformer._isLegacySingleLayerDeformer
+ _OBJC_IVAR_$_SCNGeometryWrapDeformer._legacyDrivingNode
+ _OBJC_IVAR_$_SCNGeometryWrapDeformer._outerLayerNode
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance._barycentricCoordsBuffer
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance._bindingMode
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance._computePipeline
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance._currentFrameHash
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance._deformedNode
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance._innerBindingOffsetsBuffer
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance._innerBindingSpaceVectorsBuffer
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance._innerLayerInfluencesBuffer
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance._innerLayerNode
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance._isLegacySingleLayerDeformer
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance._legacyDrivingNode
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance._legacyOffsetsOrTransformsBuffer
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance._legacyUniforms
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance._outerBindingOffsetsBuffer
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance._outerBindingSpaceVectorsBuffer
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance._outerLayerNode
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance._pointIndicesBuffer
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance._uniforms
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerParameters._bindingData
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerParameters._bindingMode
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerParameters._deformedToDrivingBindingTransform
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerParameters._isLegacySingleLayerDeformer
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerParameters._legacyDeformedNodeUVChannel
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerParameters._legacyDrivingNodeUVChannel
+ _OBJC_IVAR_$_SCNGeometryWrapDeformerParameters._vertexCount
+ _OBJC_IVAR_$_SCNMTLMorphDeformer._currentFrameHash
+ _OBJC_IVAR_$_SCNMTLSkinDeformer._currentFrameHash
+ _OBJC_IVAR_$_SCNMTLSmoothNormalsDeformer._currentFrameHash
+ _OBJC_METACLASS_$_SCNGeometryWrapDeformerInstance
+ __OBJC_$_INSTANCE_METHODS_SCNGeometryWrapDeformerInstance
+ __OBJC_$_INSTANCE_VARIABLES_SCNGeometryWrapDeformerInstance
+ __OBJC_$_INSTANCE_VARIABLES_SCNGeometryWrapDeformerParameters
+ __OBJC_$_PROP_LIST_SCNGeometryWrapDeformerInstance
+ __OBJC_$_PROP_LIST_SCNGeometryWrapDeformerParameters
+ __OBJC_CLASS_PROTOCOLS_$_SCNGeometryWrapDeformerInstance
+ __OBJC_CLASS_RO_$_SCNGeometryWrapDeformerInstance
+ __OBJC_METACLASS_RO_$_SCNGeometryWrapDeformerInstance
+ __Z30__computeBindingSpaceAndOffsetm13simd_float4x4Dv3_fS0_S0_S0_S0_PfS1_
+ __Z68C3DWrapDeformerComputeBindingPointIndicesAndBarycentricCoordsFromUVs34SCNGeometryWrapDeformerBindingMode13simd_float4x4jP9__C3DMeshS2_PK15__C3DMeshSourceS5_S5_S5_llll38SCNWrapDeformerBarycentricCoordsPolicyPhPtPjPfS8_PSA_Pm
+ __Z90C3DWrapDeformerComputeSharedBindingPointIndicesAndBarycentricCoordsFromSandwichedPositions34SCNGeometryWrapDeformerBindingMode13simd_float4x4jP9__C3DMeshS2_S2_PK15__C3DMeshSourceS5_S5_ll38SCNWrapDeformerBarycentricCoordsPolicyPhPtPjPfS8_SA_PSA_SB_PmSB_SB_SC_
+ __ZL10__bindToUVDv2_fP9__C3DMeshPK15__C3DMeshSourceS4_llPDv3_fS6_PDv3_j
+ __ZL19audit_stringModelIO
+ __ZL36__adjustDistanceByAligningProjectionDv3_fS_S_S_S_
+ __ZL36__adjustDistanceByAligningProjectionDv3_fS_S_S_S_.cold.1
+ __ZN23C3DSubdivCPUPrimvarDataIDv2_fE26_CreateMeshSourceForSourceERKN10OpenSubdiv6v3_1_13Far13TopologyLevelEbPK15__C3DMeshSourceP31C3DSubdivCPUMeshCreationContext.cold.1
+ __ZN23C3DSubdivCPUPrimvarDataIDv3_fE26_CreateMeshSourceForSourceERKN10OpenSubdiv6v3_1_13Far13TopologyLevelEbPK15__C3DMeshSourceP31C3DSubdivCPUMeshCreationContext.cold.1
+ __ZN23C3DSubdivCPUPrimvarDataIDv4_fE26_CreateMeshSourceForSourceERKN10OpenSubdiv6v3_1_13Far13TopologyLevelEbPK15__C3DMeshSourceP31C3DSubdivCPUMeshCreationContext.cold.1
+ __ZZL18ModelIOLibraryCorePPcE16frameworkLibrary.0
+ __ZZL53getMDLAssetLoadingOptionDefaultUSDColorSpaceSymbolLocvE3ptr.0
+ ___104-[SCNGeometryWrapDeformerInstance initWithNode:drivingNode:deformer:outputs:computeVertexCount:context:]_block_invoke
+ ___108-[SCNNode(SCNModelIO) _bakeNodes:folderPath:inVertex:bakeAO:quality:attenuation:geomSetter:terminateSetter:]_block_invoke.227
+ ___108-[SCNNode(SCNModelIO) _bakeNodes:folderPath:inVertex:bakeAO:quality:attenuation:geomSetter:terminateSetter:]_block_invoke_2.235
+ ___117-[SCNGeometryWrapDeformerParameters initWithInnerLayerNode:outerLayerNode:deformedNode:bindingMode:bindingTransform:]_block_invoke
+ ___122-[SCNGeometryWrapDeformerInstance initWithNode:innerLayerNode:outerLayerNode:deformer:outputs:computeVertexCount:context:]_block_invoke
+ ___142-[SCNGeometryWrapDeformerParameters initWithDrivingNode:deformedNode:bindingMode:bindingTransform:drivingNodeUVChannel:deformedNodeUVChannel:]_block_invoke
+ ____Z68C3DWrapDeformerComputeBindingPointIndicesAndBarycentricCoordsFromUVs34SCNGeometryWrapDeformerBindingMode13simd_float4x4jP9__C3DMeshS2_PK15__C3DMeshSourceS5_S5_S5_llll38SCNWrapDeformerBarycentricCoordsPolicyPhPtPjPfS8_PSA_Pm_block_invoke
+ ____Z68C3DWrapDeformerComputeBindingPointIndicesAndBarycentricCoordsFromUVs34SCNGeometryWrapDeformerBindingMode13simd_float4x4jP9__C3DMeshS2_PK15__C3DMeshSourceS5_S5_S5_llll38SCNWrapDeformerBarycentricCoordsPolicyPhPtPjPfS8_PSA_Pm_block_invoke_2
+ ____Z90C3DWrapDeformerComputeSharedBindingPointIndicesAndBarycentricCoordsFromSandwichedPositions34SCNGeometryWrapDeformerBindingMode13simd_float4x4jP9__C3DMeshS2_S2_PK15__C3DMeshSourceS5_S5_ll38SCNWrapDeformerBarycentricCoordsPolicyPhPtPjPfS8_SA_PSA_SB_PmSB_SB_SC__block_invoke
+ ____Z90C3DWrapDeformerComputeSharedBindingPointIndicesAndBarycentricCoordsFromSandwichedPositions34SCNGeometryWrapDeformerBindingMode13simd_float4x4jP9__C3DMeshS2_S2_PK15__C3DMeshSourceS5_S5_ll38SCNWrapDeformerBarycentricCoordsPolicyPhPtPjPfS8_SA_PSA_SB_PmSB_SB_SC__block_invoke_2
+ ____Z90C3DWrapDeformerComputeSharedBindingPointIndicesAndBarycentricCoordsFromSandwichedPositions34SCNGeometryWrapDeformerBindingMode13simd_float4x4jP9__C3DMeshS2_S2_PK15__C3DMeshSourceS5_S5_ll38SCNWrapDeformerBarycentricCoordsPolicyPhPtPjPfS8_SA_PSA_SB_PmSB_SB_SC__block_invoke_2.cold.1
+ ____ZL10__bindToUVDv2_fP9__C3DMeshPK15__C3DMeshSourceS4_llPDv3_fS6_PDv3_j_block_invoke
+ ____ZL10__bindToUVDv2_fP9__C3DMeshPK15__C3DMeshSourceS4_llPDv3_fS6_PDv3_j_block_invoke.cold.1
+ ____ZL18ModelIOLibraryCorePPc_block_invoke
+ ____ZL53getMDLAssetLoadingOptionDefaultUSDColorSpaceSymbolLocv_block_invoke
+ ____ZL53getMDLAssetLoadingOptionDefaultUSDColorSpaceSymbolLocv_block_invoke.cold.1
+ ___block_descriptor_128_e16_48r56r64r72r80r88r96r104r_e19_v32?0I8^I12I20^B24lr48l8r56l8r64l8r72l8r80l8r88l8r96l8r104l8
+ ___block_descriptor_128_e8_v16?0Q8l
+ ___block_descriptor_148_e8_32r_e19_v32?0I8^I12I20^B24lr32l8
+ ___block_descriptor_232_e8_v16?0Q8l
+ ___block_descriptor_32_e36_v32?08"SCNMTLDeformerStack"16^B24l
+ ___block_descriptor_40_e27_v32?08"NSMapTable"16^B24l
+ ___block_descriptor_64_e8_32o40o48r_e27_v32?08"NSMapTable"16^B24ls32l8r48l8s40l8
+ ___block_descriptor_88_e8_32o40o48o_e57_v24?0"<MTLFunction>"8"MTLStageInputOutputDescriptor"16ls32l8s40l8s48l8
+ ___block_descriptor_96_e8_32o40o48o_e57_v24?0"<MTLFunction>"8"MTLStageInputOutputDescriptor"16ls32l8s40l8s48l8
+ ___block_literal_global.221
+ ___block_literal_global.226
+ ___block_literal_global.230
+ ___block_literal_global.232
+ ___block_literal_global.234
+ ___block_literal_global.240
+ ___block_literal_global.242
+ ___block_literal_global.90
+ __sl_dlopen
+ _dlerror
+ _loadMDLAssetWithURL.cold.1
+ _objc_msgSend$_currentFrameHash
+ _objc_msgSend$currentFrameHash
+ _objc_msgSend$handleFailureInFunction:file:lineNumber:description:
+ _objc_msgSend$initParametersIfNeededWithInnerLayerNodeRef:outerLayerNodeRef:deformedNodeRef:
+ _objc_msgSend$initThroughSCNKitBridgeWithURL:options:error:
+ _objc_msgSend$instancesRespondToSelector:
+ _objc_msgSend$scn_decodeArrayOfObjectsOfClass:containingNestedContainersForKey:
+ _objc_msgSend$scn_decodeDictionaryWithKeysOfClasses:objectsOfClasses:containingNestedContainersForKey:
+ _objc_msgSend$setSwizzle:
- +[_SCNGeometryWrapDeformerParameters_Sandwich supportsSecureCoding]
- +[_SCNGeometryWrapDeformerParameters_Simple supportsSecureCoding]
- -[SCNGeometryWrapDeformer _getDeformedMeshBoundingBox:].cold.1
- -[SCNGeometryWrapDeformer initParametersIfNeededForDeformedNode:].cold.1
- -[SCNGeometryWrapDeformer initWithDriverSandwichNode0:driverSandwichNode1:parameters:]
- -[SCNGeometryWrapDeformer initWithDriverSandwichNode0:driverSandwichNode1:parameters:].cold.1
- -[SCNGeometryWrapDeformer initWithDrivingNode:parameters:].cold.1
- -[SCNGeometryWrapDeformer newDeformerInstanceForNode:outputs:computeVertexCount:context:].cold.1
- -[SCNGeometryWrapDeformer requiredInputs].cold.1
- -[SCNGeometryWrapDeformerInstance_Sandwich dealloc]
- -[SCNGeometryWrapDeformerInstance_Sandwich initWithNode:drivingNode0:drivingNode1:deformer:outputs:computeVertexCount:context:]
- -[SCNGeometryWrapDeformerInstance_Sandwich initWithNode:drivingNode0:drivingNode1:deformer:outputs:computeVertexCount:context:].cold.1
- -[SCNGeometryWrapDeformerInstance_Sandwich updateWithContext:]
- -[SCNGeometryWrapDeformerInstance_Simple dealloc]
- -[SCNGeometryWrapDeformerInstance_Simple initWithNode:drivingNode:deformer:outputs:computeVertexCount:context:]
- -[SCNGeometryWrapDeformerInstance_Simple initWithNode:drivingNode:deformer:outputs:computeVertexCount:context:].cold.1
- -[SCNGeometryWrapDeformerInstance_Simple updateWithContext:]
- -[SCNGeometryWrapDeformerParameters _initForCreateSubclass]
- -[SCNGeometryWrapDeformerParameters encodeWithCoder:].cold.1
- -[SCNGeometryWrapDeformerParameters initWithDriverSandwichNode0:driverSandwichNode1:deformedNode:mode:bindingTransform:]
- -[SCNGeometryWrapDeformerParameters initWithDriverSandwichNode0:driverSandwichNode1:extraLayers:deformedNode:mode:bindingTransform:]
- -[SCNMTLDeformerStack currentFrameIndex]
- -[_SCNGeometryWrapDeformerParameters_Sandwich _initParametersIfNeededForDifferentFaceIndicesWithDrivingNode0Ref:drivingNode1Ref:deformedNodeRef:]
- -[_SCNGeometryWrapDeformerParameters_Sandwich _initParametersIfNeededForSharedFaceIndicesWithDrivingNode0Ref:drivingNode1Ref:extraLayerMeshes:deformedNodeRef:]
- -[_SCNGeometryWrapDeformerParameters_Sandwich dealloc]
- -[_SCNGeometryWrapDeformerParameters_Sandwich encodeWithCoder:]
- -[_SCNGeometryWrapDeformerParameters_Sandwich initParametersIfNeededWithDrivingNode0Ref:drivingNode1Ref:deformedNodeRef:]
- -[_SCNGeometryWrapDeformerParameters_Sandwich initWithCoder:]
- -[_SCNGeometryWrapDeformerParameters_Sandwich initWithCoder:].cold.1
- -[_SCNGeometryWrapDeformerParameters_Sandwich initWithCoder:].cold.2
- -[_SCNGeometryWrapDeformerParameters_Sandwich initWithCoder:].cold.3
- -[_SCNGeometryWrapDeformerParameters_Sandwich initWithCoder:].cold.4
- -[_SCNGeometryWrapDeformerParameters_Sandwich initWithCoder:].cold.5
- -[_SCNGeometryWrapDeformerParameters_Sandwich initWithDriverSandwichNode0:driverSandwichNode1:extraLayers:deformedNode:mode:bindingTransform:]
- -[_SCNGeometryWrapDeformerParameters_Sandwich initWithDriverSandwichNode0:driverSandwichNode1:extraLayers:deformedNode:mode:bindingTransform:].cold.1
- -[_SCNGeometryWrapDeformerParameters_Simple dealloc]
- -[_SCNGeometryWrapDeformerParameters_Simple encodeWithCoder:]
- -[_SCNGeometryWrapDeformerParameters_Simple encodeWithCoder:].cold.1
- -[_SCNGeometryWrapDeformerParameters_Simple initParametersIfNeededWithDrivingNodeRef:deformedNodeRef:]
- -[_SCNGeometryWrapDeformerParameters_Simple initParametersIfNeededWithDrivingNodeRef:deformedNodeRef:].cold.1
- -[_SCNGeometryWrapDeformerParameters_Simple initParametersIfNeededWithDrivingNodeRef:deformedNodeRef:].cold.2
- -[_SCNGeometryWrapDeformerParameters_Simple initWithCoder:]
- -[_SCNGeometryWrapDeformerParameters_Simple initWithCoder:].cold.1
- -[_SCNGeometryWrapDeformerParameters_Simple initWithCoder:].cold.2
- -[_SCNGeometryWrapDeformerParameters_Simple initWithCoder:].cold.3
- -[_SCNGeometryWrapDeformerParameters_Simple initWithDrivingNode:deformedNode:bindingMode:bindingTransform:drivingNodeUVChannel:deformedNodeUVChannel:]
- GCC_except_table52
- _OBJC_CLASS_$_SCNGeometryWrapDeformerInstance_Sandwich
- _OBJC_CLASS_$_SCNGeometryWrapDeformerInstance_Simple
- _OBJC_CLASS_$__SCNGeometryWrapDeformerParameters_Sandwich
- _OBJC_CLASS_$__SCNGeometryWrapDeformerParameters_Simple
- _OBJC_IVAR_$_SCNGeometryWrapDeformer._drivingNode0
- _OBJC_IVAR_$_SCNGeometryWrapDeformer._drivingNode1
- _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance_Sandwich._bindingBuffers
- _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance_Sandwich._bindingDriver0InfluencesBuffer
- _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance_Sandwich._computePipeline
- _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance_Sandwich._deformedNode
- _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance_Sandwich._drivingNode0
- _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance_Sandwich._drivingNode1
- _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance_Sandwich._lastUpdateFrameIndex
- _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance_Sandwich._mode
- _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance_Sandwich._uniforms
- _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance_Simple._bindingBarycentricCoordsBuffer
- _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance_Simple._bindingMode
- _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance_Simple._bindingOffsetsOrTransformsBuffer
- _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance_Simple._bindingPointIndicesBuffer
- _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance_Simple._bindingTransformsBuffer
- _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance_Simple._computePipeline
- _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance_Simple._deformedNode
- _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance_Simple._drivingNode
- _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance_Simple._lastUpdateFrameIndex
- _OBJC_IVAR_$_SCNGeometryWrapDeformerInstance_Simple._uniforms
- _OBJC_IVAR_$_SCNMTLMorphDeformer._lastUpdateFrameIndex
- _OBJC_IVAR_$_SCNMTLSkinDeformer._lastUpdateFrameIndex
- _OBJC_IVAR_$_SCNMTLSmoothNormalsDeformer._lastUpdateFrameIndex
- _OBJC_IVAR_$__SCNGeometryWrapDeformerParameters_Sandwich._bindingData
- _OBJC_IVAR_$__SCNGeometryWrapDeformerParameters_Sandwich._bindingDriver0Influences
- _OBJC_IVAR_$__SCNGeometryWrapDeformerParameters_Sandwich._bindingDriver0InfluencesLength
- _OBJC_IVAR_$__SCNGeometryWrapDeformerParameters_Sandwich._deformedToDrivingBindingTransform
- _OBJC_IVAR_$__SCNGeometryWrapDeformerParameters_Sandwich._extraLayers
- _OBJC_IVAR_$__SCNGeometryWrapDeformerParameters_Sandwich._mode
- _OBJC_IVAR_$__SCNGeometryWrapDeformerParameters_Sandwich._vertexCount
- _OBJC_IVAR_$__SCNGeometryWrapDeformerParameters_Simple._bindingBarycentricCoords
- _OBJC_IVAR_$__SCNGeometryWrapDeformerParameters_Simple._bindingBarycentricCoordsFormat
- _OBJC_IVAR_$__SCNGeometryWrapDeformerParameters_Simple._bindingBarycentricCoordsStride
- _OBJC_IVAR_$__SCNGeometryWrapDeformerParameters_Simple._bindingMode
- _OBJC_IVAR_$__SCNGeometryWrapDeformerParameters_Simple._bindingOffsetsOrTransforms
- _OBJC_IVAR_$__SCNGeometryWrapDeformerParameters_Simple._bindingOffsetsOrTransformsLength
- _OBJC_IVAR_$__SCNGeometryWrapDeformerParameters_Simple._bindingPointIndices
- _OBJC_IVAR_$__SCNGeometryWrapDeformerParameters_Simple._bindingPointIndicesFormat
- _OBJC_IVAR_$__SCNGeometryWrapDeformerParameters_Simple._bindingPointIndicesStride
- _OBJC_IVAR_$__SCNGeometryWrapDeformerParameters_Simple._deformedNodeUVChannel
- _OBJC_IVAR_$__SCNGeometryWrapDeformerParameters_Simple._deformedToDrivingBindingTransform
- _OBJC_IVAR_$__SCNGeometryWrapDeformerParameters_Simple._drivingNodeUVChannel
- _OBJC_IVAR_$__SCNGeometryWrapDeformerParameters_Simple._vertexCount
- _OBJC_METACLASS_$_SCNGeometryWrapDeformerInstance_Sandwich
- _OBJC_METACLASS_$_SCNGeometryWrapDeformerInstance_Simple
- _OBJC_METACLASS_$__SCNGeometryWrapDeformerParameters_Sandwich
- _OBJC_METACLASS_$__SCNGeometryWrapDeformerParameters_Simple
- _SCNSceneSourceLoadingOptionUSDAssumeLinearDisplayP3SourceColorSpaceKey
- _SCNSceneSourceLoadingOptionUSDIgnoreVertexColorsKey
- __OBJC_$_CLASS_METHODS__SCNGeometryWrapDeformerParameters_Sandwich
- __OBJC_$_CLASS_METHODS__SCNGeometryWrapDeformerParameters_Simple
- __OBJC_$_INSTANCE_METHODS_SCNGeometryWrapDeformerInstance_Sandwich
- __OBJC_$_INSTANCE_METHODS_SCNGeometryWrapDeformerInstance_Simple
- __OBJC_$_INSTANCE_METHODS__SCNGeometryWrapDeformerParameters_Sandwich
- __OBJC_$_INSTANCE_METHODS__SCNGeometryWrapDeformerParameters_Simple
- __OBJC_$_INSTANCE_VARIABLES_SCNGeometryWrapDeformerInstance_Sandwich
- __OBJC_$_INSTANCE_VARIABLES_SCNGeometryWrapDeformerInstance_Simple
- __OBJC_$_INSTANCE_VARIABLES__SCNGeometryWrapDeformerParameters_Sandwich
- __OBJC_$_INSTANCE_VARIABLES__SCNGeometryWrapDeformerParameters_Simple
- __OBJC_$_PROP_LIST_SCNGeometryWrapDeformerInstance_Sandwich
- __OBJC_$_PROP_LIST_SCNGeometryWrapDeformerInstance_Simple
- __OBJC_CLASS_PROTOCOLS_$_SCNGeometryWrapDeformerInstance_Sandwich
- __OBJC_CLASS_PROTOCOLS_$_SCNGeometryWrapDeformerInstance_Simple
- __OBJC_CLASS_RO_$_SCNGeometryWrapDeformerInstance_Sandwich
- __OBJC_CLASS_RO_$_SCNGeometryWrapDeformerInstance_Simple
- __OBJC_CLASS_RO_$__SCNGeometryWrapDeformerParameters_Sandwich
- __OBJC_CLASS_RO_$__SCNGeometryWrapDeformerParameters_Simple
- __OBJC_METACLASS_RO_$_SCNGeometryWrapDeformerInstance_Sandwich
- __OBJC_METACLASS_RO_$_SCNGeometryWrapDeformerInstance_Simple
- __OBJC_METACLASS_RO_$__SCNGeometryWrapDeformerParameters_Sandwich
- __OBJC_METACLASS_RO_$__SCNGeometryWrapDeformerParameters_Simple
- __ZL38__bindToDriverMeshVertexIndicesUsingUVDv2_fP9__C3DMeshS1_PK15__C3DMeshSourceS4_lljjPDv3_fS6_PDv3_j
- __ZL44__bindToDriverMeshVertexIndicesUsingPositionDv3_fP9__C3DMeshS1_PK15__C3DMeshSourceljjPS_S5_PDv3_j
- __ZN23C3DSubdivCPUPrimvarDataIDv2_fE17CreateMeshSourcesERKN10OpenSubdiv6v3_1_13Far13TopologyLevelEPNS4_14PrimvarRefinerEbPK22C3DSubdivisionSettingsP31C3DSubdivCPUMeshCreationContext.cold.4
- __ZN23C3DSubdivCPUPrimvarDataIDv3_fE17CreateMeshSourcesERKN10OpenSubdiv6v3_1_13Far13TopologyLevelEPNS4_14PrimvarRefinerEbPK22C3DSubdivisionSettingsP31C3DSubdivCPUMeshCreationContext.cold.4
- __ZN23C3DSubdivCPUPrimvarDataIDv4_fE17CreateMeshSourcesERKN10OpenSubdiv6v3_1_13Far13TopologyLevelEPNS4_14PrimvarRefinerEbPK22C3DSubdivisionSettingsP31C3DSubdivCPUMeshCreationContext.cold.4
- ___108-[SCNNode(SCNModelIO) _bakeNodes:folderPath:inVertex:bakeAO:quality:attenuation:geomSetter:terminateSetter:]_block_invoke.221
- ___108-[SCNNode(SCNModelIO) _bakeNodes:folderPath:inVertex:bakeAO:quality:attenuation:geomSetter:terminateSetter:]_block_invoke_2.229
- ___111-[SCNGeometryWrapDeformerInstance_Simple initWithNode:drivingNode:deformer:outputs:computeVertexCount:context:]_block_invoke
- ___127-[SCNGeometryWrapDeformerInstance_Sandwich initWithNode:drivingNode0:drivingNode1:deformer:outputs:computeVertexCount:context:]_block_invoke
- ___142-[_SCNGeometryWrapDeformerParameters_Sandwich initWithDriverSandwichNode0:driverSandwichNode1:extraLayers:deformedNode:mode:bindingTransform:]_block_invoke
- ___150-[_SCNGeometryWrapDeformerParameters_Simple initWithDrivingNode:deformedNode:bindingMode:bindingTransform:drivingNodeUVChannel:deformedNodeUVChannel:]_block_invoke
- ____ZL38__bindToDriverMeshVertexIndicesUsingUVDv2_fP9__C3DMeshS1_PK15__C3DMeshSourceS4_lljjPDv3_fS6_PDv3_j_block_invoke
- ____ZL38__bindToDriverMeshVertexIndicesUsingUVDv2_fP9__C3DMeshS1_PK15__C3DMeshSourceS4_lljjPDv3_fS6_PDv3_j_block_invoke.cold.1
- ____ZL44__bindToDriverMeshVertexIndicesUsingPositionDv3_fP9__C3DMeshS1_PK15__C3DMeshSourceljjPS_S5_PDv3_j_block_invoke
- ____ZL44__bindToDriverMeshVertexIndicesUsingPositionDv3_fP9__C3DMeshS1_PK15__C3DMeshSourceljjPS_S5_PDv3_j_block_invoke.cold.1
- ____ZL55__computeBindingPointIndicesAndBarycentricCoordsFromUVsjP9__C3DMeshS0_PK15__C3DMeshSourceS3_S3_S3_llll38SCNWrapDeformerBarycentricCoordsPolicyPhPtPjPfS6__block_invoke
- ____ZL55__computeBindingPointIndicesAndBarycentricCoordsFromUVsjP9__C3DMeshS0_PK15__C3DMeshSourceS3_S3_S3_llll38SCNWrapDeformerBarycentricCoordsPolicyPhPtPjPfS6__block_invoke_2
- ____ZL61__computeBindingPointIndicesAndBarycentricCoordsFromPositions13simd_float4x4jP9__C3DMeshS1_PK15__C3DMeshSourceS4_ll38SCNWrapDeformerBarycentricCoordsPolicyPhPtPjPfS7_S9__block_invoke
- ____ZL67__computeSharedBindingPointIndicesAndBarycentricCoordsFromPositionsb13simd_float4x4jP9__C3DMeshS1_PK15__C3DMeshSourceS4_ll38SCNWrapDeformerBarycentricCoordsPolicyPhPtPjPfS7_S9__block_invoke
- ___block_descriptor_120_e16_48r56r64r72r80r_e19_v32?0I8^I12I20^B24lr48l8r56l8r64l8r72l8r80l8
- ___block_descriptor_136_e8_v16?0Q8l
- ___block_descriptor_156_e8_32r_e19_v32?0I8^I12I20^B24lr32l8
- ___block_descriptor_192_e8_v16?0Q8l
- ___block_descriptor_193_e8_v16?0Q8l
- ___block_descriptor_32_e17_v32?0^v8^v16^B24l
- ___block_descriptor_40_e17_v32?0^v8^v16^B24l
- ___block_descriptor_64_e8_32o40o48r_e17_v32?0^v8^v16^B24ls32l8r48l8s40l8
- ___block_descriptor_72_e8_32o40o48o_e57_v24?0"<MTLFunction>"8"MTLStageInputOutputDescriptor"16ls32l8s40l8s48l8
- ___block_descriptor_80_e8_32o40o_e57_v24?0"<MTLFunction>"8"MTLStageInputOutputDescriptor"16ls32l8s40l8
- ___block_literal_global.220
- ___block_literal_global.246
- ___block_literal_global.248
- ___block_literal_global.252
- ___block_literal_global.254
- ___block_literal_global.258
- ___block_literal_global.84
- _objc_msgSend$_initParametersIfNeededForDifferentFaceIndicesWithDrivingNode0Ref:drivingNode1Ref:deformedNodeRef:
- _objc_msgSend$_initParametersIfNeededForSharedFaceIndicesWithDrivingNode0Ref:drivingNode1Ref:extraLayerMeshes:deformedNodeRef:
- _objc_msgSend$currentFrameIndex
- _objc_msgSend$initParametersIfNeededWithDrivingNode0Ref:drivingNode1Ref:deformedNodeRef:
- _objc_msgSend$initWithDriverSandwichNode0:driverSandwichNode1:deformedNode:mode:bindingTransform:
- _objc_msgSend$initWithDriverSandwichNode0:driverSandwichNode1:extraLayers:deformedNode:mode:bindingTransform:
- _objc_msgSend$initWithDrivingNode:deformedNode:bindingMode:bindingTransform:drivingNodeUVChannel:deformedNodeUVChannel:
- _objc_msgSend$scn_colorWithLinearDisplayP3Red:green:blue:alpha:
CStrings:
+ "\n#import <metal_stdlib>\n\nusing namespace metal;\n\n#import \"scn_metal\"\n#import \"scn_util.h\"\n#import \"C3D-PBR.metal\"\n#import \"scn_tessellation.h\"\n\n\n\n#ifdef USE_LAYERED_RENDERING\n#define texture2d_layer texture2d_array\n#define sampleLayer(a,b) sample(a,b,in.sliceIndex)\n#else\n#define texture2d_layer texture2d\n#define sampleLayer(a,b) sample(a,b)\n#endif\n\n#ifdef C3D_USE_TEXTURE_FOR_LIGHT_INDICES\n#define LightIndex(lid) u_lightIndicesTexture.read((ushort)lid).x\n#else\n#define LightIndex(lid) u_lightIndicesBuffer[lid]\n#endif\n\n\n\ntypedef struct {\n\n#ifdef USE_MODELTRANSFORM\n    float4x4 modelTransform;\n#endif\n#ifdef USE_INVERSEMODELTRANSFORM\n    float4x4 inverseModelTransform;\n#endif\n#ifdef USE_MODELVIEWTRANSFORM\n    float4x4 modelViewTransform;\n#endif\n#ifdef USE_INVERSEMODELVIEWTRANSFORM\n    float4x4 inverseModelViewTransform;\n#endif\n#ifdef USE_NORMALTRANSFORM\n    float4x4 normalTransform;\n#endif\n#ifdef USE_MODELVIEWPROJECTIONTRANSFORM\n    float4x4 modelViewProjectionTransform;\n#endif\n#ifdef USE_INVERSEMODELVIEWPROJECTIONTRANSFORM\n    float4x4 inverseModelViewProjectionTransform;\n#endif\n#ifdef USE_MOTIONBLUR\n    float4x4 lastFrameModelTransform;\n    float motionBlurIntensity;\n#endif\n#ifdef USE_BOUNDINGBOX\n    float2x3 boundingBox;\n#endif\n#ifdef USE_WORLDBOUNDINGBOX\n    float2x3 worldBoundingBox;\n#endif\n#ifdef USE_NODE_OPACITY\n    float nodeOpacity;\n#endif\n#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)\n    sh2_coefficients shCoefficients;\n#elif defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 3)\n    sh3_coefficients shCoefficients;\n#endif\n} commonprofile_node;\n\ntypedef struct {\n    float3 position         [[attribute(SCNVertexSemanticPosition)]];\n#ifdef HAS_NORMAL\n    float3 normal           [[attribute(SCNVertexSemanticNormal)]];\n#endif\n#ifdef USE_TANGENT\n    float4 tangent          [[attribute(SCNVertexSemanticTangent)]];\n#endif\n#ifdef USE_VERTEX_COLOR\n    float4 color            [[attribute(SCNVertexSemanticColor)]];\n#endif\n#if defined(NEED_IN_TEXCOORD0) || defined(DEBUG_PIXEL)\n    float2 texcoord0        [[attribute(SCNVertexSemanticTexcoord0)]];\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    float2 texcoord1        [[attribute(SCNVertexSemanticTexcoord1)]];\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    float2 texcoord2        [[attribute(SCNVertexSemanticTexcoord2)]];\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    float2 texcoord3        [[attribute(SCNVertexSemanticTexcoord3)]];\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    float2 texcoord4        [[attribute(SCNVertexSemanticTexcoord4)]];\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    float2 texcoord5        [[attribute(SCNVertexSemanticTexcoord5)]];\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    float2 texcoord6        [[attribute(SCNVertexSemanticTexcoord6)]];\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    float2 texcoord7        [[attribute(SCNVertexSemanticTexcoord7)]];\n#endif\n} scn_vertex_t; \n\ntypedef struct {\n    float4 fragmentPosition [[position]]; \n#ifdef USE_POINT_RENDERING\n    float fragmentSize [[point_size]];\n#endif\n#ifdef USE_VERTEX_COLOR\n    float4 vertexColor;\n#endif\n#ifdef USE_PER_VERTEX_LIGHTING\n    float3 diffuse;\n#ifdef USE_SPECULAR\n    float3 specular;\n#endif\n#ifdef USE_CLEARCOAT\n    float clearCoat;\n#endif\n#ifdef USE_CLEARCOATROUGHNESS\n    float clearCoatRoughness;\n#endif\n#ifdef USE_CLEARCOATNORMAL\n    float clearCoatNormal;\n#endif\n#endif\n#if defined(USE_POSITION) && (USE_POSITION == 2)\n    float3 position;\n#endif\n#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)\n    float3 normal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    float3 tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    float3 bitangent;\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n    float2 displacementTexcoord;   \n#endif\n#ifdef USE_CLEARCOAT_MAP\n    float2 clearCoatTexcoord;   \n#endif\n#ifdef USE_CLEARCOATROUGHNESS_MAP\n    float2 clearCoatRoughnessTexcoord;   \n#endif\n#ifdef USE_CLEARCOATNORMAL_MAP\n    float2 clearCoatNormalTexcoord;   \n#endif\n#if defined(USE_PBR_TRANSPARENCY) && defined(USE_TRANSPARENCY)\n    float transparency;\n#endif\n#ifdef USE_NODE_OPACITY\n    float nodeOpacity;\n#endif\n#ifdef USE_TEXCOORD\n    __TexcoordDecl__\n#endif\n    \n#ifdef USE_EXTRA_VARYINGS\n    __ExtraVaryingsDecl__\n#endif\n    \n#ifdef USE_MOTIONBLUR\n    float3 mv_fragment;\n    float3 mv_lastFragment;\n#endif\n#ifdef USE_OUTLINE\n    float outlineHash [[ flat ]];\n#endif\n#ifdef USE_INSTANCING\n    uint   instanceID [[ flat ]];\n#endif\n#ifndef USE_VERTEX_AMPLIFICATION \n#ifdef USE_LAYERED_RENDERING\n    uint   sliceIndex [[render_target_array_index]];\n#endif\n#ifdef USE_MULTIPLE_VIEWPORTS_RENDERING\n    uint   sliceIndex [[viewport_array_index]];\n#endif\n#endif\n#if DEBUG_PIXEL\n    float2 uv0;\n#endif\n} commonprofile_io;\n\n\n#ifdef USE_SHADER_MODIFIERS\n__ShaderModifiersDecl__\n#endif\n\n\n#import \"C3D-Lighting.metal\"\n\nenum C3DColorMask {\n    kC3DColorMaskRed    = 0x1 << 3,\n    kC3DColorMaskGreen  = 0x1 << 2,\n    kC3DColorMaskBlue   = 0x1 << 1,\n    kC3DColorMaskAlpha  = 0x1 << 0\n};\n\ninline float4 colorFromMask(float4 col, int mask)\n{\n    switch (mask) {\n\n        case kC3DColorMaskRed:                      return col.r;\n        case kC3DColorMaskRed|kC3DColorMaskGreen:   return float4(col.rg, 0.f, 1.f);\n        case kC3DColorMaskRed|kC3DColorMaskBlue:    return float4(col.rb, 0.f, 1.f);\n        case kC3DColorMaskRed|kC3DColorMaskAlpha:   return float4(col.ra, 0.f, 1.f);\n\n        case kC3DColorMaskGreen:                    return col.g;\n        case kC3DColorMaskGreen|kC3DColorMaskBlue:  return float4(col.bg, 0.f, 1.f);\n        case kC3DColorMaskGreen|kC3DColorMaskAlpha: return float4(col.ag, 0.f, 1.f);\n\n        case kC3DColorMaskBlue:     return col.b;\n        case kC3DColorMaskBlue|kC3DColorMaskAlpha:  return float4(col.ab, 0.f, 1.f);\n\n        case kC3DColorMaskAlpha:    return col.a;\n    }\n    return col;\n}\n\n#ifndef USE_PBR\n\ninline float3 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)\n{\n    float3 albedo = surface.diffuse.rgb * surface.ambientOcclusion;\n    float3 color = lighting.diffuse * albedo;\n#if defined(USE_AMBIENT_LIGHTING) && (defined(LOCK_AMBIENT_WITH_DIFFUSE) || defined(USE_AMBIENT_AS_AMBIENTOCCLUSION))\n    color +=  lighting.ambient * albedo;\n#endif\n#ifdef USE_SELFILLUMINATION\n    color += surface.diffuse.rgb * surface.selfIllumination.rgb;\n#endif\n    \n    \n    \n#ifdef USE_SPECULAR\n    float3 S = lighting.specular;\n#elif defined(USE_REFLECTIVE)\n    float3 S = float3(0.);\n#endif\n#ifdef USE_REFLECTIVE\n    S += surface.reflective.rgb * surface.ambientOcclusion;\n#endif\n#ifdef USE_SPECULAR\n    S *= surface.specular.rgb;\n#endif\n#if (defined(USE_SPECULAR) || defined(USE_REFLECTIVE)) && !defined(DISABLE_SPECULAR)\n    color += S;\n#endif\n#if defined(USE_AMBIENT) && !defined(USE_AMBIENT_AS_AMBIENTOCCLUSION)\n    color += surface.ambient.rgb * lighting.ambient;\n#endif\n#ifdef USE_EMISSION\n    color += surface.emission.rgb;\n#endif\n#ifdef USE_MULTIPLY\n    color *= surface.multiply.rgb;\n#endif\n#ifdef USE_MODULATE\n    color *= lighting.modulate;\n#endif\n    return color;\n}\n#endif\n\nstruct SCNShaderGeometry\n{\n    float4 position;\n    float3 normal;\n    float4 tangent;\n    float4 color;\n    float pointSize;\n    float2 texcoords[8]; \n#ifdef USE_CLIP_DISTANCE0\n    float clipDistance0;\n#endif\n#ifdef USE_CLIP_DISTANCE1\n    float clipDistance1;\n#endif\n#ifdef USE_CLIP_DISTANCE2\n    float clipDistance2;\n#endif\n#ifdef USE_CLIP_DISTANCE3\n    float clipDistance3;\n#endif\n};\n\nstruct commonprofile_uniforms {\n    \n    float4 diffuseColor;\n    float4 specularColor;\n    float4 ambientColor;\n    float4 emissionColor;\n    float4 selfIlluminationColor;\n    float4 reflectiveColor;\n    float4 multiplyColor;\n    float4 transparentColor;\n    float clearCoat;\n    float clearCoatRoughness;\n    float3 clearCoatNormal;\n    float metalness;\n    \n    float roughness;\n    float diffuseIntensity;\n    float specularIntensity;\n    float normalIntensity;\n    float ambientIntensity;\n    float emissionIntensity;\n    float selfIlluminationIntensity;\n    float reflectiveIntensity;\n    float multiplyIntensity;\n    float transparentIntensity;\n    \n    float metalnessIntensity;\n    float roughnessIntensity;\n    float clearCoatIntensity;\n    float clearCoatRoughnessIntensity;\n    float clearCoatNormalIntensity;\n    float displacementIntensity;\n    float materialShininess;\n    float selfIlluminationOcclusion;\n    float transparency;\n    float3 fresnel; \n#if USE_ARGUMENT_BUFFERS\n    \n    texture2d<float>    emissionTexture;\n    sampler             emissionSampler;\n    texture2d<float>    ambientTexture;\n    sampler             ambientSampler;\n    \n    texture2d<float>    diffuseTexture;\n    sampler             diffuseSampler;\n    texture2d<float>    specularTexture;\n    sampler             specularSampler;\n#if defined(USE_REFLECTIVE_CUBEMAP)\n    texturecube<float>  reflectiveTexture;\n#else\n    texture2d<float>    reflectiveTexture;\n#endif\n    sampler             reflectiveSampler;\n    texture2d<float>    transparentTexture;\n    sampler             transparentSampler;\n    texture2d<float>    multiplyTexture;\n    sampler             multiplySampler;\n    \n    texture2d<float>    normalTexture;\n    sampler             normalSampler;\n    texture2d<float>    selfIlluminationTexture;\n    sampler             selfIlluminationSampler;\n    texture2d<float>    metalnessTexture;\n    sampler             metalnessSampler;\n    texture2d<float>    roughnessTexture;\n    sampler             roughnessSampler;\n    texture2d<float>    displacementTexture;\n    sampler             displacementSampler;\n    \n    \n#endif \n#ifdef TEXTURE_TRANSFORM_COUNT\n    float4x4 textureTransforms[TEXTURE_TRANSFORM_COUNT];\n#endif\n};\n\n#ifdef USE_OPENSUBDIV\n\n__OpenSubdivDeclPerGeometry__\n__OpenSubdivDeclPerPatchType__\n__OpenSubdivDeclShared__\n\nstruct osd_packed_vertex {\n    packed_float3 position;\n#if defined(OSD_USER_VARYING_DECLARE_PACKED)\n    OSD_USER_VARYING_DECLARE_PACKED\n#endif\n};\n\n#endif\n\n\n#ifdef USE_DISPLACEMENT_MAP\nstatic void applyDisplacement(texture2d<float>                 displacementTexture,\n                              sampler                          displacementTextureSampler,\n                              float2                           displacementTexcoord,\n                              thread SCNShaderGeometry&        geometry,\n                              constant commonprofile_uniforms& scn_commonprofile)\n{\n#ifdef USE_DISPLACEMENT_TEXTURE_COMPONENT\n\tfloat altitude = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n#ifdef USE_DISPLACEMENT_INTENSITY\n\taltitude *= scn_commonprofile.displacementIntensity;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n\tfloat3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));\n\tgeometry.position.xyz += geometry.normal * altitude;\n\t\n\tfloat3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);\n\tfloat3 h;\n\th.x = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\th.y = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\th.z = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord-offset.zy), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\t\n#ifdef USE_DISPLACEMENT_INTENSITY\n\th *= scn_commonprofile.displacementIntensity;\n#endif\n\t\n\tfloat3 n = normalize( float3( (h.x - h.y)/offset.x, 1., (h.x - h.z)/offset.y) );\n\tgeometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;\n\tgeometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));\n#endif \n#else \n\tfloat3 displacement = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;\n#ifdef USE_DISPLACEMENT_INTENSITY\n\tdisplacement *= scn_commonprofile.displacementIntensity;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n\tfloat3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));\n\tgeometry.position.xyz += geometry.tangent.xyz * displacement.x + geometry.normal.xyz * displacement.y + bitangent.xyz * displacement.z;\n\t\n\tfloat3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);\n\tfloat3 a = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;\n\tfloat3 b = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz).rgb;\n\tfloat3 c = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.zy).rgb;\n\t\n#ifdef USE_DISPLACEMENT_INTENSITY\n\ta *= scn_commonprofile.displacementIntensity;\n\tb *= scn_commonprofile.displacementIntensity;\n\tc *= scn_commonprofile.displacementIntensity;\n#endif\n\t\n\tb += offset.xzz;\n\tc -= offset.zzy;\n\tfloat3 n = (normalize( cross( b-a, c-a ) ));\n\tgeometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;\n\tgeometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));\n#endif \n#endif \n}\n#endif \n\n#ifdef USE_OUTLINE\nstatic inline float hash(float2 p)\n{\n    const float2 kMod2 = float2(443.8975f, 397.2973f);\n    p  = fract(p * kMod2);\n    p += dot(p.xy, p.yx+19.19f);\n    return fract(p.x * p.y);\n}\n#endif\n    \n\n\n\n\n#if defined(USE_TESSELLATION)\nstruct scn_patch_t {\n    patch_control_point<scn_vertex_t> controlPoints;\n};\n#endif\n\n#if defined(USE_OPENSUBDIV)\n#if OSD_IS_ADAPTIVE\n[[ patch(quad, VERTEX_CONTROL_POINTS_PER_PATCH) ]]\n#endif\n#elif defined(USE_TESSELLATION)\n[[ patch(triangle, 3) ]]\n#endif\n    \n    \nvertex commonprofile_io commonprofile_vert(\n#if !defined(USE_TESSELLATION)\n                                           scn_vertex_t                       in                               [[ stage_in ]]\n                                           , uint                             scn_vertexID                     [[ vertex_id ]]\n#else \n                                           \n#ifdef USE_OPENSUBDIV\n#if OSD_IS_ADAPTIVE\n#if USE_STAGE_IN\n                                           PatchInput                         patchInput                       [[ stage_in ]]\n#else\n                                           OsdVertexBufferSet                 patchInput\n#endif\n                                           , float2                           patchCoord                       [[ position_in_patch ]]\n                                           , uint                             patchID                          [[ patch_id ]]\n                                           , constant float&                  osdTessellationLevel             [[ buffer(TESSELLATION_LEVEL_BUFFER_INDEX) ]]\n#else \n                                           constant unsigned*                 osdIndicesBuffer                 [[ buffer(INDICES_BUFFER_INDEX) ]]\n                                           , constant osd_packed_vertex*      osdVertexBuffer                  [[ buffer(VERTEX_BUFFER_INDEX) ]]\n                                           , uint                             vertexID                         [[ vertex_id ]]\n#endif \n#if defined(OSD_FVAR_WIDTH)\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n                                           , constant uint32_t&               osdFaceVaryingChannelCount       [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_COUNT_INDEX) ]]\n                                           , constant OsdFVarChannelDesc*     osdFaceVaryingChannelDescriptors [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_DESCRIPTORS_INDEX) ]]\n                                           , constant uint32_t&               osdFaceVaryingPatchArrayIndex    [[ buffer(OSD_FVAR_CHANNELS_PATCH_ARRAY_INDEX_BUFFER_INDEX) ]]\n                                           , constant void*                   osdFaceVaryingChannelsPackedData [[ buffer(OSD_FVAR_CHANNELS_PACKED_DATA_BUFFER_INDEX) ]]\n#else\n                                           , constant float*                  osdFaceVaryingData               [[ buffer(OSD_FVAR_DATA_BUFFER_INDEX) ]]\n                                           , constant int*                    osdFaceVaryingIndices            [[ buffer(OSD_FVAR_INDICES_BUFFER_INDEX) ]]\n#if OSD_IS_ADAPTIVE\n                                           , constant packed_int3*            osdFaceVaryingPatchParams        [[ buffer(OSD_FVAR_PATCHPARAM_BUFFER_INDEX) ]]\n                                           , constant packed_int4&            osdFaceVaryingPatchArray         [[ buffer(OSD_FVAR_PATCH_ARRAY_BUFFER_INDEX) ]]\n#endif\n#endif \n#endif \n#else \n                                           scn_patch_t                        in                               [[ stage_in ]]\n                                           , float3                           patchCoord                       [[ position_in_patch ]]\n#endif \n#endif \n                                           \n#ifdef USE_MULTIPLE_RENDERING\n                                           , constant SCNSceneBuffer*         scn_frame_multi                  [[ buffer(0) ]]\n#else\n                                           , constant SCNSceneBuffer&         scn_frame                        [[ buffer(0) ]]\n#endif\n#if defined(USE_INSTANCING) || defined(USE_MULTIPLE_RENDERING)\n                                           , constant commonprofile_node*     scn_nodes                        [[ buffer(1) ]]\n#else\n                                           , constant commonprofile_node&     scn_node                         [[ buffer(1) ]]\n#endif\n#ifdef USE_PER_VERTEX_LIGHTING\n                                           , constant scn_light*              scn_lights                       [[ buffer(2) ]]\n                                           , constant float4*                 u_shadowKernel\n                                           , texture2d_array<float>           u_areaLightBakedDataTexture\n#endif\n                                           \n                                           , constant commonprofile_uniforms& scn_commonprofile\n#ifdef USE_INSTANCING\n                                           , uint                             scn_instanceID                   [[ instance_id ]]\n#endif\n#ifdef USE_VERTEX_AMPLIFICATION\n                                           , ushort                           amplificationID                  [[ amplification_id ]]\n#endif\n\n#ifdef USE_POINT_RENDERING\n                                           \n                                           , constant float3&                 scn_pointSize\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n#if USE_ARGUMENT_BUFFERS\n#define u_displacementTexture           scn_commonprofile.displacementTexture\n#define u_displacementTextureSampler    scn_commonprofile.displacementSampler\n#else\n                                           , texture2d<float>                 u_displacementTexture\n                                           , sampler                          u_displacementTextureSampler\n#endif \n#endif \n#ifdef USE_VERTEX_EXTRA_ARGUMENTS\n                                           __VertexExtraArguments__\n#endif\n                                           )\n{\n    commonprofile_io out;\n    \n#ifdef USE_MULTIPLE_RENDERING\n\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant SCNSceneBuffer& scn_frame = scn_frame_multi[amplificationID];\n#else\n    out.instanceID = scn_instanceID / USE_MULTIPLE_RENDERING;\n    out.sliceIndex = scn_instanceID % USE_MULTIPLE_RENDERING;\n    constant SCNSceneBuffer& scn_frame = scn_frame_multi[out.sliceIndex];\n#endif\n    \n#ifdef USE_INSTANCING\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& scn_node = scn_nodes[USE_MULTIPLE_RENDERING * scn_instanceID + amplificationID];\n#else\n    \n    \n    constant commonprofile_node& scn_node = scn_nodes[scn_instanceID];\n#endif\n#else\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& scn_node = scn_nodes[amplificationID];\n#else\n    constant commonprofile_node& scn_node = scn_nodes[out.sliceIndex];\n#endif\n#endif\n    \n#else \n    \n#ifdef USE_INSTANCING\n    out.instanceID = scn_instanceID;\n    constant commonprofile_node& scn_node = scn_nodes[scn_instanceID];\n#endif\n    \n#endif \n    \n    \n#ifdef USE_TESSELLATION\n    uint scn_vertexID; \n    scn_vertexID = 0;\n#endif\n    \n    \n    \n    \n    \n    SCNShaderGeometry _geometry;\n    \n#if !defined(USE_TESSELLATION)\n    \n    \n    _geometry.position = float4(in.position, 1.f);\n#if defined(USE_NORMAL) && defined(HAS_NORMAL)\n    _geometry.normal = in.normal;\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = in.tangent;\n#endif\n#ifdef NEED_IN_TEXCOORD0\n    _geometry.texcoords[0] = in.texcoord0;\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    _geometry.texcoords[1] = in.texcoord1;\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    _geometry.texcoords[2] = in.texcoord2;\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    _geometry.texcoords[3] = in.texcoord3;\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    _geometry.texcoords[4] = in.texcoord4;\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    _geometry.texcoords[5] = in.texcoord5;\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    _geometry.texcoords[6] = in.texcoord6;\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    _geometry.texcoords[7] = in.texcoord7;\n#endif\n#ifdef HAS_VERTEX_COLOR\n    _geometry.color = in.color;\n#elif USE_VERTEX_COLOR\n    _geometry.color = float4(1.);\n#endif\n    \n#else \n    \n#ifdef USE_OPENSUBDIV\n#if OSD_IS_ADAPTIVE\n#if USE_STAGE_IN\n    int3 patchParam = patchInput.patchParam;\n#else\n    int3 patchParam = patchInput.patchParamBuffer[patchID];\n#endif\n    \n    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);\n    float tessellationLevel = min(osdTessellationLevel, (float)OSD_MAX_TESS_LEVEL) / exp2((float)refinementLevel - 1);\n    \n    OsdPatchVertex patchVertex = OsdComputePatch(tessellationLevel, patchCoord, patchID, patchInput);\n    \n#if defined(OSD_FVAR_WIDTH)\n    int patchIndex = OsdGetPatchIndex(patchID);\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);\n#else\n    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingIndices, osdFaceVaryingData, osdFaceVaryingPatchParams, osdFaceVaryingPatchArray);\n#endif\n#endif\n    \n    _geometry.position = float4(patchVertex.position, 1.f);\n    \n#if defined(USE_NORMAL)\n    _geometry.normal = patchVertex.normal;\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = float4(patchVertex.tangent, -1.f);\n    \n#endif\n#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[0] = patchVertex.texcoord0;\n#endif\n#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[1] = patchVertex.texcoord1;\n#endif\n#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[2] = patchVertex.texcoord2;\n#endif\n#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[3] = patchVertex.texcoord3;\n#endif\n#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[4] = patchVertex.texcoord4;\n#endif\n#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[5] = patchVertex.texcoord5;\n#endif\n#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[6] = patchVertex.texcoord6;\n#endif\n#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[7] = patchVertex.texcoord7;\n#endif\n#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.color = patchVertex.color;\n#endif\n    \n#else \n    \n#if OSD_PATCH_QUADS\n    const uint primitiveIndex = vertexID / 6;\n#ifdef USE_NORMAL\n    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 0]].position;\n    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 1]].position;\n    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 2]].position;\n    float3 normal = normalize(cross(p2 - p1, p0 - p1));\n#endif\n    const uint triangleIndices[6] = { 0, 1, 2, 0, 2, 3 };\n    const uint quadVertexIndex = triangleIndices[vertexID % 6];\n    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + quadVertexIndex]];\n#elif OSD_PATCH_TRIANGLES\n    const uint primitiveIndex = vertexID / 3;\n#ifdef USE_NORMAL\n    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 0]].position;\n    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 1]].position;\n    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 2]].position;\n    float3 normal = normalize(cross(p2 - p1, p0 - p1));\n#endif\n    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[vertexID]];\n#endif\n    \n    float3 position = osdVertex.position;\n    \n#if defined(OSD_FVAR_WIDTH)\n    int patchIndex = OsdGetPatchIndex(primitiveIndex);\n#if OSD_PATCH_QUADS\n    float2 quadUVs[4] = { float2(0,0), float2(1,0), float2(1,1), float2(0,1) };\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);\n#else\n    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingIndices, osdFaceVaryingData);\n#endif\n#elif OSD_PATCH_TRIANGLES\n    \n#endif\n#endif \n    \n#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[0] = osdVertex.texcoord0;\n#endif\n#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[1] = osdVertex.texcoord1;\n#endif\n#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[2] = osdVertex.texcoord2;\n#endif\n#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[3] = osdVertex.texcoord3;\n#endif\n#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[4] = osdVertex.texcoord4;\n#endif\n#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[5] = osdVertex.texcoord5;\n#endif\n#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[6] = osdVertex.texcoord6;\n#endif\n#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[7] = osdVertex.texcoord7;\n#endif\n#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.color = osdVertex.color;\n#endif\n    \n    _geometry.position = float4(position, 1.f);\n#ifdef USE_NORMAL\n    _geometry.normal = normal;\n#endif\n    \n#endif \n    \n#else \n    \n    \n    \n    \n    \n#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE) || defined(TESSELLATION_SMOOTHING_MODE_PHONG)\n    float3 P0 = in.controlPoints[0].position;\n    float3 P1 = in.controlPoints[1].position;\n    float3 P2 = in.controlPoints[2].position;\n    float3 N0 = in.controlPoints[0].normal;\n    float3 N1 = in.controlPoints[1].normal;\n    float3 N2 = in.controlPoints[2].normal;\n#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE)\n    float3 position, normal;\n    scn_smooth_geometry_pn_triangle(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);\n#elif defined(TESSELLATION_SMOOTHING_MODE_PHONG)\n    float3 position, normal;\n    scn_smooth_geometry_phong(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);\n#endif\n    _geometry.position = float4(position, 1.f);\n#ifdef USE_NORMAL\n    _geometry.normal = normal;\n#endif\n#else \n    \n    _geometry.position = float4(scn::barycentric_mix(in.controlPoints[0].position, in.controlPoints[1].position, in.controlPoints[2].position, patchCoord), 1.f);\n#if defined(USE_NORMAL) && defined(HAS_NORMAL)\n    _geometry.normal = normalize(scn::barycentric_mix(in.controlPoints[0].normal, in.controlPoints[1].normal, in.controlPoints[2].normal, patchCoord));\n#endif\n#endif \n    \n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = normalize(scn::barycentric_mix(in.controlPoints[0].tangent, in.controlPoints[1].tangent, in.controlPoints[2].tangent, patchCoord));\n#endif\n#ifdef NEED_IN_TEXCOORD0\n    _geometry.texcoords[0] = scn::barycentric_mix(in.controlPoints[0].texcoord0, in.controlPoints[1].texcoord0, in.controlPoints[2].texcoord0, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    _geometry.texcoords[1] = scn::barycentric_mix(in.controlPoints[0].texcoord1, in.controlPoints[1].texcoord1, in.controlPoints[2].texcoord1, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    _geometry.texcoords[2] = scn::barycentric_mix(in.controlPoints[0].texcoord2, in.controlPoints[1].texcoord2, in.controlPoints[2].texcoord2, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    _geometry.texcoords[3] = scn::barycentric_mix(in.controlPoints[0].texcoord3, in.controlPoints[1].texcoord3, in.controlPoints[2].texcoord3, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    _geometry.texcoords[4] = scn::barycentric_mix(in.controlPoints[0].texcoord4, in.controlPoints[1].texcoord4, in.controlPoints[2].texcoord4, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    _geometry.texcoords[5] = scn::barycentric_mix(in.controlPoints[0].texcoord5, in.controlPoints[1].texcoord5, in.controlPoints[2].texcoord5, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    _geometry.texcoords[6] = scn::barycentric_mix(in.controlPoints[0].texcoord6, in.controlPoints[1].texcoord6, in.controlPoints[2].texcoord6, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    _geometry.texcoords[7] = scn::barycentric_mix(in.controlPoints[0].texcoord7, in.controlPoints[1].texcoord7, in.controlPoints[2].texcoord7, patchCoord);\n#endif\n#ifdef HAS_VERTEX_COLOR\n    _geometry.color = scn::barycentric_mix(in.controlPoints[0].color, in.controlPoints[1].color, in.controlPoints[2].color, patchCoord);\n#elif USE_VERTEX_COLOR\n    _geometry.color = float4(1.);\n#endif\n    \n#endif \n    \n#endif \n    \n#ifdef USE_POINT_RENDERING\n    _geometry.pointSize = scn_pointSize.x;\n#endif\n    \n#ifdef USE_TEXCOORD\n    __VertexDoVertexOnlyTexcoord__\n#endif\n    \n#ifdef USE_DISPLACEMENT_MAP\n    applyDisplacement(u_displacementTexture, u_displacementTextureSampler, _displacementTexcoord, _geometry, scn_commonprofile);\n    out.displacementTexcoord = _displacementTexcoord;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_GEOMETRY_MODIFIER\n    \n    __DoGeometryModifier__\n    \n#endif\n    \n#ifdef USE_CLIP_DISTANCE0\n    out.clipDistance[0] = _geometry.clipDistance0;\n#endif\n#ifdef USE_CLIP_DISTANCE1\n    out.clipDistance[1] = _geometry.clipDistance1;\n#endif\n#ifdef USE_CLIP_DISTANCE2\n    out.clipDistance[2] = _geometry.clipDistance2;\n#endif\n#ifdef USE_CLIP_DISTANCE3\n    out.clipDistance[3] = _geometry.clipDistance3;\n#endif\n    \n    \n    \n    \n    \n    \n#if defined(USE_POSITION) || (defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)) || defined(USE_TANGENT) || defined(USE_BITANGENT) || defined(USE_INSTANCING)\n    SCNShaderSurface _surface;\n#endif\n#if defined(USE_POSITION) || defined(USE_INSTANCING)\n    _surface.position = (scn_node.modelViewTransform * _geometry.position).xyz;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n#ifdef HINT_UNIFORM_SCALE\n    float3x3 nrmTransform = scn::mat3(scn_node.modelViewTransform);\n    _surface.normal = nrmTransform * _geometry.normal;\n#else\n    float3x3 modelViewTransform = scn::mat3(scn_node.modelViewTransform);\n    float3 invScaleSquared = 1.f / float3(length_squared(modelViewTransform[0]),\n                                          length_squared(modelViewTransform[1]),\n                                          length_squared(modelViewTransform[2]));\n    _surface.normal = normalize(modelViewTransform * (_geometry.normal * invScaleSquared));\n#endif\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _surface.tangent = normalize(scn::mat3(scn_node.modelViewTransform) * _geometry.tangent.xyz);\n    _surface.bitangent = _geometry.tangent.w * cross(_surface.tangent, _surface.normal); \n    \n#endif\n    \n    \n#ifdef USE_VIEW\n    _surface.view = normalize(-_surface.position);\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_PER_VERTEX_LIGHTING\n    \n    SCNShaderLightingContribution _lightingContribution(_surface, out);\n    _lightingContribution.diffuse = 0.;\n  #ifdef USE_SPECULAR\n    _lightingContribution.specular = 0.;\n    _surface.shininess = scn_commonprofile.materialShininess;\n  #endif\n    \n    __VertexDoLighting__\n    \n    out.diffuse = _lightingContribution.diffuse;\n  #ifdef USE_SPECULAR\n    out.specular = _lightingContribution.specular;\n  #endif\n#endif\n#if defined(USE_POSITION) && (USE_POSITION == 2)\n    out.position = _surface.position;\n#endif\n#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)\n    out.normal = _surface.normal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    out.tangent = _surface.tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    out.bitangent = _surface.bitangent;\n#endif\n#ifdef USE_VERTEX_COLOR\n    out.vertexColor = _geometry.color;\n#endif\n    \n#if DEBUG_PIXEL\n    out.uv0 = in.texcoord0;\n#endif\n\n#ifdef USE_TEXCOORD\n    __VertexDoTexcoord__\n#endif\n    \n    \n    \n    \n    \n#if defined(USE_POSITION) || defined(USE_INSTANCING)\n    out.fragmentPosition = scn_frame.projectionTransform * float4(_surface.position, 1.);\n#elif defined(USE_MODELVIEWPROJECTIONTRANSFORM) \n    out.fragmentPosition = scn_node.modelViewProjectionTransform * _geometry.position;\n#endif\n    \n#if defined(USE_PBR_TRANSPARENCY) && defined(USE_TRANSPARENCY)\n    out.transparency = scn_commonprofile.transparency;\n#endif\n#ifdef USE_NODE_OPACITY\n    out.nodeOpacity = scn_node.nodeOpacity;\n#endif\n    \n#ifdef USE_POINT_RENDERING\n    float screenSize = _geometry.pointSize / out.fragmentPosition.w;\n    out.fragmentSize = clamp(screenSize, scn_pointSize.y, scn_pointSize.z);\n#endif\n    \n#ifdef USE_MOTIONBLUR\n    float4 lastFrameFragmentPosition = scn_frame.lastFrameViewProjectionTransform * scn_node.lastFrameModelTransform * _geometry.position;\n    out.mv_fragment = out.fragmentPosition.xyw;\n    out.mv_lastFragment = lastFrameFragmentPosition.xyw;\n#endif\n    \n#ifdef USE_OUTLINE\n\tout.outlineHash = hash(scn_node.modelTransform[3].xy)+1.f/255.f;\n#endif\n    \n    return out;\n}\n\n\n\n\n\nstruct SCNOutput\n{\n    float4 color [[ color(0) ]];\n#ifdef USE_COLOR1_OUTPUT\n    half4 color1 [[ color(1) ]];\n#endif\n#ifdef USE_NORMALS_OUTPUT\n    half4 normals [[ color(2) ]];\n#endif\n#ifdef USE_MOTIONBLUR\n    half4 motionblur [[ color(3) ]];\n#endif\n#ifdef USE_REFLECTANCE_ROUGHNESS_OUTPUT\n    half4 reflectanceRoughnessOutput [[ color(4) ]];\n#endif\n#ifdef USE_RADIANCE_OUTPUT\n    half4 radiance [[ color(5) ]];\n#endif\n};\n    \n#ifdef USE_MODIFIER_FRAMEBUFFER\nstruct SCNFramebuffer\n{\n    float4 color;\n};\n#endif\n\nfragment SCNOutput commonprofile_frag(commonprofile_io                   in                          [[ stage_in  ]]\n                                      , constant commonprofile_uniforms& scn_commonprofile           [[ buffer(0) ]]\n#ifdef USE_MULTIPLE_RENDERING\n                                      , constant SCNSceneBuffer*         scn_frame_multi             [[ buffer(1) ]]\n#else\n                                      , constant SCNSceneBuffer&         scn_frame                   [[ buffer(1) ]]\n#endif\n#if defined(USE_INSTANCING) || defined(USE_MULTIPLE_RENDERING)\n                                      , constant commonprofile_node*     scn_nodes                   [[ buffer(2) ]]\n#else\n                                      , constant commonprofile_node&     scn_node                    [[ buffer(2) ]]\n#endif\n#ifdef USE_PER_PIXEL_LIGHTING\n                                      , constant scn_light*              scn_lights                  [[ buffer(3) ]]\n                                      , constant float4*                 u_shadowKernel\n                                      , texture2d_array<float>           u_areaLightBakedDataTexture\n#ifdef C3D_SUPPORT_CUBE_ARRAY\n                                      , texturecube_array<half>          u_reflectionProbeTexture\n#else\n                                      , texture2d_array<half>            u_reflectionProbeTexture\n#endif\n                                      , texture3d<ushort>                u_clusterTexture\n#ifdef C3D_USE_TEXTURE_FOR_LIGHT_INDICES\n                                      , texture1d<ushort>                u_lightIndicesTexture\n#else\n                                      , constant C3DLightIndexType*      u_lightIndicesBuffer\n#endif\n#endif\n#if defined(C3D_SUPPORTS_PROGRAMMABLE_BLENDING) && defined(USE_MODIFIER_FRAMEBUFFER_COLOR0)\n                                      , float4                           framebufferColor0           [[ color(0) ]]\n#endif\n#if USE_ARGUMENT_BUFFERS\n\n#define u_emissionTexture               scn_commonprofile.emissionTexture\n#define u_emissionTextureSampler        scn_commonprofile.emissionSampler\n#define u_ambientTexture                scn_commonprofile.ambientTexture\n#define u_ambientTextureSampler         scn_commonprofile.ambientSampler\n#define u_diffuseTexture                scn_commonprofile.diffuseTexture\n#define u_diffuseTextureSampler         scn_commonprofile.diffuseSampler\n#define u_specularTexture               scn_commonprofile.specularTexture\n#define u_specularTextureSampler        scn_commonprofile.specularSampler\n#define u_reflectiveTexture             scn_commonprofile.reflectiveTexture\n#define u_reflectiveTextureSampler      scn_commonprofile.reflectiveSampler\n#define u_transparentTexture            scn_commonprofile.transparentTexture\n#define u_transparentTextureSampler     scn_commonprofile.transparentSampler\n#define u_multiplyTexture               scn_commonprofile.multiplyTexture\n#define u_multiplyTextureSampler        scn_commonprofile.multiplySampler\n#define u_normalTexture                 scn_commonprofile.normalTexture\n#define u_normalTextureSampler          scn_commonprofile.normalSampler\n#define u_selfIlluminationTexture       scn_commonprofile.selfIlluminationTexture\n#define u_selfIlluminationTextureSampler scn_commonprofile.selfIlluminationSampler\n#define u_metalnessTexture              scn_commonprofile.metalnessTexture\n#define u_metalnessTextureSampler       scn_commonprofile.metalnessSampler\n#define u_roughnessTexture              scn_commonprofile.roughnessTexture\n#define u_roughnessTextureSampler       scn_commonprofile.roughnessSampler\n\n#else\n#ifdef USE_EMISSION_MAP\n                                      , texture2d<float>              u_emissionTexture\n                                      , sampler                       u_emissionTextureSampler\n#endif\n#ifdef USE_AMBIENT_MAP\n                                      , texture2d<float>              u_ambientTexture\n                                      , sampler                       u_ambientTextureSampler\n#endif\n#ifdef USE_DIFFUSE_MAP\n                                      , texture2d<float>              u_diffuseTexture\n                                      , sampler                       u_diffuseTextureSampler\n#endif\n#ifdef USE_SPECULAR_MAP\n                                      , texture2d<float>              u_specularTexture\n                                      , sampler                       u_specularTextureSampler\n#endif\n#ifdef USE_REFLECTIVE_MAP\n                                      , texture2d<float>              u_reflectiveTexture\n                                      , sampler                       u_reflectiveTextureSampler\n#elif defined(USE_REFLECTIVE_CUBEMAP)\n                                      , texturecube<float>            u_reflectiveTexture\n                                      , sampler                       u_reflectiveTextureSampler\n#endif\n#ifdef USE_TRANSPARENT_MAP\n                                      , texture2d<float>              u_transparentTexture\n                                      , sampler                       u_transparentTextureSampler\n#endif\n#ifdef USE_MULTIPLY_MAP\n                                      , texture2d<float>              u_multiplyTexture\n                                      , sampler                       u_multiplyTextureSampler\n#endif\n#ifdef USE_NORMAL_MAP\n                                      , texture2d<float>              u_normalTexture\n                                      , sampler                       u_normalTextureSampler\n#endif\n#ifdef USE_SELFILLUMINATION_MAP\n                                      , texture2d<float>              u_selfIlluminationTexture\n                                      , sampler                       u_selfIlluminationTextureSampler\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n                                      , texture2d<float>              u_displacementTexture\n                                      , sampler                       u_displacementTextureSampler\n#endif\n#ifdef USE_PBR\n#ifdef USE_METALNESS_MAP\n                                      , texture2d<float>              u_metalnessTexture\n                                      , sampler                       u_metalnessTextureSampler\n#endif\n#ifdef USE_ROUGHNESS_MAP\n                                      , texture2d<float>              u_roughnessTexture\n                                      , sampler                       u_roughnessTextureSampler\n#endif\n#ifdef USE_CLEARCOAT_MAP\n                                      , texture2d<float>              u_clearCoatTexture\n                                      , sampler                       u_clearCoatTextureSampler\n#endif\n#ifdef USE_CLEARCOATROUGHNESS_MAP\n                                      , texture2d<float>              u_clearCoatRoughnessTexture\n                                      , sampler                       u_clearCoatRoughnessTextureSampler\n#endif\n#ifdef USE_CLEARCOATNORMAL_MAP\n                                      , texture2d<float>              u_clearCoatNormalTexture\n                                      , sampler                       u_clearCoatNormalTextureSampler\n#endif\n#endif \n#endif \n#ifdef USE_PBR\n                                      , texturecube<float>            u_radianceTexture\n                                      , texture2d<float>              u_specularDFGDiffuseHammonTexture\n#if !defined(USE_SELFILLUMINATION_MAP)\n                                      , texturecube<float>            u_irradianceTexture\n#endif\n#endif \n#ifdef USE_SSAO\n                                      , texture2d<float>              u_ssaoTexture\n#endif\n#ifdef USE_FRAGMENT_EXTRA_ARGUMENTS\n                                      __FragmentExtraArguments__\n#endif\n#if defined(USE_DOUBLE_SIDED)\n                                      , bool                          isFrontFacing                    [[front_facing]]\n#endif\n#ifdef USE_POINT_RENDERING\n                                      , float2                        pointCoord                       [[point_coord]]\n#endif\n#ifdef USE_VERTEX_AMPLIFICATION\n                                      , ushort                        amplificationID                  [[amplification_id]]\n#endif\n                                      )\n{\n#ifdef USE_MULTIPLE_RENDERING\n    \n#ifdef USE_VERTEX_AMPLIFICATION\n    constant SCNSceneBuffer& scn_frame = scn_frame_multi[amplificationID];\n#else\n    constant SCNSceneBuffer& scn_frame = scn_frame_multi[in.sliceIndex];\n#endif\n    \n#ifdef USE_INSTANCING\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& scn_node = scn_nodes[USE_MULTIPLE_RENDERING * in.instanceID + amplificationID];\n#else\n    constant commonprofile_node& scn_node = scn_nodes[USE_MULTIPLE_RENDERING * in.instanceID + in.sliceIndex];\n#endif\n#else\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& scn_node = scn_nodes[amplificationID];\n#else\n    constant commonprofile_node& scn_node = scn_nodes[in.sliceIndex];\n#endif\n#endif\n    \n#else \n    \n#ifdef USE_INSTANCING\n    constant commonprofile_node& scn_node = scn_nodes[in.instanceID];\n#endif\n    \n#endif \n    \n    SCNOutput _output;\n\n    \n    \n    \n    \n    SCNShaderSurface _surface;\n#ifdef USE_TEXCOORD\n    __FragmentDoTexcoord__\n#endif\n    _surface.ambientOcclusion = 1.f; \n#ifdef USE_AMBIENT_MAP\n    #ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION\n        #if defined(USE_AMBIENT_TEXTURE_COMPONENT)\n            _surface.ambientOcclusion = colorFromMask(u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord), USE_AMBIENT_TEXTURE_COMPONENT).r;\n        #else\n            _surface.ambientOcclusion = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord).r;\n        #endif\n        #ifdef USE_AMBIENT_INTENSITY\n            _surface.ambientOcclusion = saturate(mix(1.f, _surface.ambientOcclusion, scn_commonprofile.ambientIntensity));\n        #endif\n    #else \n        _surface.ambient = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord);\n        #if defined(USE_AMBIENT_TEXTURE_COMPONENT)\n            _surface.ambient = colorFromMask(_surface.ambient, USE_AMBIENT_TEXTURE_COMPONENT);\n        #endif\n        #ifdef USE_AMBIENT_INTENSITY\n            _surface.ambient *= scn_commonprofile.ambientIntensity;\n        #endif\n    #endif \n#elif defined(USE_AMBIENT_COLOR)\n    _surface.ambient = scn_commonprofile.ambientColor;\n#elif defined(USE_AMBIENT)\n    _surface.ambient = float4(0.);\n#endif\n#if defined(USE_AMBIENT) && defined(USE_VERTEX_COLOR)\n    _surface.ambient *= in.vertexColor;\n#endif\n#if  defined(USE_SSAO)\n    _surface.ambientOcclusion *= u_ssaoTexture.sample( sampler(filter::linear), in.fragmentPosition.xy * scn_frame.inverseResolution.xy ).x;\n#endif\n    \n#ifdef USE_DIFFUSE_MAP\n    _surface.diffuse = u_diffuseTexture.sample(u_diffuseTextureSampler, _surface.diffuseTexcoord);\n#if defined(USE_DIFFUSE_TEXTURE_COMPONENT)\n    _surface.diffuse = colorFromMask(_surface.diffuse, USE_DIFFUSE_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_DIFFUSE_INTENSITY\n    _surface.diffuse.rgb *= scn_commonprofile.diffuseIntensity;\n#endif\n#elif defined(USE_DIFFUSE_COLOR)\n    _surface.diffuse = scn_commonprofile.diffuseColor;\n#else\n    _surface.diffuse = float4(0.f,0.f,0.f,1.f);\n#endif\n#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)\n    _surface.diffuse.rgb    *= in.vertexColor.rgb;\n    _surface.diffuse        *= in.vertexColor.a; \n#endif\n#ifdef USE_SPECULAR_MAP\n    _surface.specular = u_specularTexture.sample(u_specularTextureSampler, _surface.specularTexcoord);\n#if defined(USE_SPECULAR_TEXTURE_COMPONENT)\n    _surface.specular = colorFromMask(_surface.specular, USE_SPECULAR_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_SPECULAR_INTENSITY\n    _surface.specular *= scn_commonprofile.specularIntensity;\n#endif\n#elif defined(USE_SPECULAR_COLOR)\n    _surface.specular = scn_commonprofile.specularColor;\n#elif defined(USE_SPECULAR)\n    _surface.specular = float4(0.f);\n#endif\n    \n#ifdef USE_CLEARCOAT_MAP\n    _surface.clearCoat = u_clearCoatTexture.sample(u_clearCoatTextureSampler, _surface.clearCoatTexcoord).r;\n#if defined(USE_CLEARCOAT_TEXTURE_COMPONENT)\n    _surface.clearCoat = colorFromMask(_surface.clearCoat, USE_CLEARCOAT_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_CLEARCOAT_INTENSITY\n    _surface.clearCoat *= scn_commonprofile.clearCoatIntensity;\n#endif\n#elif defined(USE_CLEARCOAT_COLOR)\n    _surface.clearCoat = scn_commonprofile.clearCoat;\n#elif defined(USE_CLEARCOAT)\n    _surface.clearCoat = 0.f;\n#endif\n    \n#ifdef USE_CLEARCOATROUGHNESS_MAP\n#if defined(USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT)\n    _surface.clearCoatRoughness = colorFromMask(u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord), USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.clearCoatRoughness = u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord).r;\n#endif\n#ifdef USE_CLEARCOATROUGHNESS_INTENSITY\n    _surface.clearCoatRoughness *= scn_commonprofile.clearCoatRoughnessIntensity;\n#endif\n#elif defined(USE_CLEARCOATROUGHNESS_COLOR)\n    _surface.clearCoatRoughness = scn_commonprofile.clearCoatRoughness;\n#else\n    _surface.clearCoatRoughness = 0.03f;\n#endif\n \n#ifdef USE_EMISSION_MAP\n    _surface.emission = u_emissionTexture.sample(u_emissionTextureSampler, _surface.emissionTexcoord);\n#if defined(USE_EMISSION_TEXTURE_COMPONENT)\n    _surface.emission = colorFromMask(_surface.emission, USE_EMISSION_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_EMISSION_INTENSITY\n    _surface.emission *= scn_commonprofile.emissionIntensity;\n#endif\n#elif defined(USE_EMISSION_COLOR)\n    _surface.emission = scn_commonprofile.emissionColor;\n#elif defined(USE_EMISSION)\n    _surface.emission = float4(0.);\n#endif\n#ifdef USE_SELFILLUMINATION_MAP\n    _surface.selfIllumination = u_selfIlluminationTexture.sample(u_selfIlluminationTextureSampler, _surface.selfIlluminationTexcoord);\n#if defined(USE_SELFILLUMINATION_TEXTURE_COMPONENT)\n    _surface.selfIllumination = colorFromMask(_surface.selfIllumination, USE_SELFILLUMINATION_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_SELFILLUMINATION_INTENSITY\n    _surface.selfIllumination *= scn_commonprofile.selfIlluminationIntensity;\n#endif\n#elif defined(USE_SELFILLUMINATION_COLOR)\n    _surface.selfIllumination = scn_commonprofile.selfIlluminationColor;\n#elif defined(USE_SELFILLUMINATION)\n    _surface.selfIllumination = float4(0.);\n#endif\n#ifdef USE_MULTIPLY_MAP\n    _surface.multiply = u_multiplyTexture.sample(u_multiplyTextureSampler, _surface.multiplyTexcoord);\n#if defined(USE_MULTIPLY_TEXTURE_COMPONENT)\n    _surface.multiply = colorFromMask(_surface.multiply, USE_MULTIPLY_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_MULTIPLY_INTENSITY\n    _surface.multiply = mix(float4(1.), _surface.multiply, scn_commonprofile.multiplyIntensity);\n#endif\n#elif defined(USE_MULTIPLY_COLOR)\n    _surface.multiply = scn_commonprofile.multiplyColor;\n#elif defined(USE_MULTIPLY)\n    _surface.multiply = float4(1.);\n#endif\n#ifdef USE_TRANSPARENT_MAP\n    _surface.transparent = u_transparentTexture.sample(u_transparentTextureSampler, _surface.transparentTexcoord);\n#if defined(USE_TRANSPARENT_TEXTURE_COMPONENT)\n    _surface.transparent = colorFromMask(_surface.transparent, USE_TRANSPARENT_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_TRANSPARENT_INTENSITY\n    _surface.transparent *= scn_commonprofile.transparentIntensity;\n#endif\n#elif defined(USE_TRANSPARENT_COLOR)\n    _surface.transparent = scn_commonprofile.transparentColor;\n#elif defined(USE_TRANSPARENT)\n    _surface.transparent = float4(1.f);\n#endif\n    \n#ifdef USE_METALNESS_MAP\n#if defined(USE_METALNESS_TEXTURE_COMPONENT)\n    _surface.metalness = colorFromMask(u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord), USE_METALNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.metalness = u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord).r;\n#endif\n#ifdef USE_METALNESS_INTENSITY\n    _surface.metalness *= scn_commonprofile.metalnessIntensity;\n#endif\n#elif defined(USE_METALNESS_COLOR)\n    _surface.metalness = scn_commonprofile.metalness;\n#else\n    _surface.metalness = 0.f;\n#endif\n    \n#ifdef USE_ROUGHNESS_MAP\n#if defined(USE_ROUGHNESS_TEXTURE_COMPONENT)\n    _surface.roughness = colorFromMask(u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord), USE_ROUGHNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.roughness = u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord).r;\n#endif\n#ifdef USE_ROUGHNESS_INTENSITY\n    _surface.roughness *= scn_commonprofile.roughnessIntensity;\n#endif\n#elif defined(USE_ROUGHNESS_COLOR)\n    _surface.roughness = scn_commonprofile.roughness;\n#else\n    _surface.roughness = 0.f;\n#endif\n#if (defined USE_POSITION) && (USE_POSITION == 2)\n    _surface.position = in.position;\n#endif\n#if (defined USE_NORMAL) && (USE_NORMAL == 2)\n#if defined(HAS_NORMAL) || defined(USE_OPENSUBDIV)\n#ifdef USE_DOUBLE_SIDED\n    _surface.geometryNormal = normalize(in.normal.xyz) * (isFrontFacing ? 1.f : -1.f );\n#else\n    _surface.geometryNormal = normalize(in.normal.xyz);\n#endif\n#else \n    _surface.geometryNormal = normalize( cross(dfdy( _surface.position ), dfdx( _surface.position ) ));\n#endif\n    _surface.normal = _surface.geometryNormal;\n    _surface.clearCoatNormal = _surface.geometryNormal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    _surface.tangent = in.tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    _surface.bitangent = in.bitangent;\n#endif\n#if (defined USE_VIEW) && (USE_VIEW == 2)\n    _surface.view = normalize(-in.position);\n    {\n        \n        \n        float NoV = dot(_surface.geometryNormal, _surface.view);\n        _surface.view = _surface.view + max(0.f, -2.f * NoV) * _surface.geometryNormal;         \n        \n    }\n#endif\n#if defined(USE_NORMAL_MAP)\n    {\n        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.normal);\n#ifdef USE_NORMAL_MAP\n#if defined(USE_NORMAL_TEXTURE_COMPONENT)\n        _surface._normalTS.xy = colorFromMask(u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord), USE_NORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;\n        _surface._normalTS.z = sqrt(1.f - saturate(length_squared(_surface._normalTS.xy)));\n#else\n        _surface._normalTS = u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord).rgb;\n        _surface._normalTS = _surface._normalTS * 2.f - 1.f;\n#endif\n#ifdef USE_NORMAL_INTENSITY\n        _surface._normalTS = mix(float3(0.f, 0.f, 1.f), _surface._normalTS, scn_commonprofile.normalIntensity);\n#endif\n#else\n        _surface._normalTS = float3(0.f, 0.f, 1.f);\n#endif\n        _surface.normal.rgb = normalize(ts2vs * _surface._normalTS.xyz );\n    }\n#else\n    _surface._normalTS = float3(0.f, 0.f, 1.f);\n#endif\n#ifdef USE_PBR\n    {\n        float roughness = clamp(_surface.roughness, PBR_MIN_ROUGHNESS, 1.0);\n        float alpha = scn_filteredAlphaFromRoughness(_surface.normal, roughness);\n        _surface.roughness = sqrt(alpha);\n    }\n#endif\n#if defined(USE_CLEARCOATNORMAL_MAP)\n    {\n        \n        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.geometryNormal);\n#ifdef USE_CLEARCOATNORMAL_MAP\n#if defined(USE_CLEARCOATNORMAL_TEXTURE_COMPONENT)\n        _surface._clearCoatNormalTS.xy = colorFromMask(u_clearCoatNormalTexture.sample(u_clearCoatnormalTextureSampler, _surface.clearCoatNormalTexcoord), USE_CLEARCOATNORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;\n        _surface._clearCoatNormalTS.z = sqrt(1.f - saturate(length_squared(_surface._clearCoatNormalTS.xy)));\n#else\n        _surface._clearCoatNormalTS = u_clearCoatNormalTexture.sample(u_clearCoatNormalTextureSampler, _surface.clearCoatNormalTexcoord).rgb;\n        _surface._clearCoatNormalTS = _surface._clearCoatNormalTS * 2.f - 1.f;\n#endif\n#ifdef USE_CLEARCOATNORMAL_INTENSITY\n        _surface._clearCoatNormalTS = mix(float3(0.f, 0.f, 1.f), _surface._clearCoatNormalTS, scn_commonprofile.clearCoatNormalIntensity);\n#endif\n#else\n        _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);\n#endif\n        _surface.clearCoatNormal.rgb = normalize(ts2vs * _surface._clearCoatNormalTS.xyz );\n    }\n#else\n    _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);\n#endif\n    \n#ifdef USE_REFLECTIVE_MAP\n    float3 refl = reflect( -_surface.view, _surface.normal );\n    float m = 2.f * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.f)*(refl.z+1.f));\n    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, float2(float2(refl.x,-refl.y) / m) + 0.5f);\n#if defined(USE_REFLECTIVE_TEXTURE_COMPONENT)\n    _surface.reflective = colorFromMask(_surface.reflective, USE_REFLECTIVE_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_REFLECTIVE_INTENSITY\n    _surface.reflective *= scn_commonprofile.reflectiveIntensity;\n#endif\n#elif defined(USE_REFLECTIVE_CUBEMAP)\n    float3 refl = reflect( _surface.position, _surface.normal );\n    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, scn::mat4_mult_float3(scn_frame.viewToCubeTransform, refl)); \n#ifdef USE_REFLECTIVE_INTENSITY\n    _surface.reflective *= scn_commonprofile.reflectiveIntensity;\n#endif\n#elif defined(USE_REFLECTIVE_COLOR)\n    _surface.reflective = scn_commonprofile.reflectiveColor;\n#elif defined(USE_REFLECTIVE)\n    _surface.reflective = float4(0.);\n#endif\n#ifdef USE_FRESNEL\n    _surface.fresnel = scn_commonprofile.fresnel.x + scn_commonprofile.fresnel.y * pow(1.f - saturate(dot(_surface.view, _surface.normal)), scn_commonprofile.fresnel.z);\n    _surface.reflective *= _surface.fresnel;\n#endif\n#ifdef USE_SHININESS\n    _surface.shininess = scn_commonprofile.materialShininess;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_SURFACE_MODIFIER\n    \n    __DoSurfaceModifier__\n    \n#endif\n    \n    \n    \n    \n    \n    SCNShaderLightingContribution _lightingContribution(_surface, in);\n#ifdef USE_LIGHT_MODIFIER\n    __LightModifierCopyDecl__\n#endif\n#ifdef USE_AMBIENT_LIGHTING\n    _lightingContribution.ambient = scn_frame.ambientLightingColor.rgb;\n#endif\n#ifdef USE_LIGHTING\n#ifdef USE_PER_PIXEL_LIGHTING\n#ifdef USE_CLUSTERED_LIGHTING\n    uint3 clusterIndex;\n    clusterIndex.xy = uint2(in.fragmentPosition.xy * scn_frame.clusterScale.xy); \n    clusterIndex.z = in.position.z * scn_frame.clusterScale.z + scn_frame.clusterScale.w; \n    \n    \n    ushort4 cluster_offset_count = u_clusterTexture.read(clusterIndex);\n    int lid = cluster_offset_count.x;\n#endif\n\n#ifdef USE_PBR\n    _lightingContribution.prepareForPBR(u_specularDFGDiffuseHammonTexture, scn_commonprofile.selfIlluminationOcclusion);\n    \n    \n#ifdef USE_SELFILLUMINATION\n    _lightingContribution.add_irradiance_from_selfIllum();\n#else\n#ifdef USE_PROBES_LIGHTING \n    _lightingContribution.add_global_irradiance_from_sh(scn_frame.viewToCubeTransform, scn_node.shCoefficients);\n#else\n    _lightingContribution.add_global_irradiance_probe(u_irradianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);\n#endif\n#endif\n\n    \n#ifndef DISABLE_SPECULAR\n#ifdef C3D_USE_REFLECTION_PROBES\n    int probe_count = (cluster_offset_count.z & 0xff);\n    for (int i = 0 ; i < probe_count; ++i, ++lid) {\n        _lightingContribution.add_local_probe(scn_lights[LightIndex(lid)], u_reflectionProbeTexture);\n    }\n#if PROBES_NORMALIZATION\n#if PROBES_OUTER_BLENDING\n    _lightingContribution.specular += _lightingContribution.probesWeightedSum.rgb / max(1.f, _lightingContribution.probesWeightedSum.a);\n#else\n    _lightingContribution.specular += _lightingContribution.probesWeightedSum.rgb / _lightingContribution.probesWeightedSum.a;\n#endif\n    float globalFactor = saturate(1.f - _lightingContribution.probesWeightedSum.a);\n#else\n    float globalFactor = _lightingContribution.probeRadianceRemainingFactor;\n#endif\n    _lightingContribution.add_global_probe(scn_frame.viewToCubeTransform, globalFactor * scn_frame.environmentIntensity,\n                                           u_reflectionProbeTexture);\n#else \n   _lightingContribution.add_global_probe(u_radianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);\n    \n#ifdef USE_CLEARCOAT\n    _lightingContribution.add_global_probeClearCoat(u_radianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);\n#endif\n\n    \n#endif \n#endif \n\n#endif \n    #if DEBUG_PIXEL\n        switch (DEBUG_PIXEL) {\n            case 1: _output.color = float4(_surface.normal * 0.5f + 0.5f, 1.f); break;\n            case 2: _output.color = float4(_surface.geometryNormal * 0.5f + 0.5f, 1.f); break;\n            case 3: _output.color = float4(_surface.tangent * 0.5f + 0.5f, 1.f); break;\n            case 4: _output.color = float4(in.uv0, 0.f, 1.f); break;\n            case 5: _output.color = float4(_surface.diffuse.rgb, 1.f); break;\n            case 6: _output.color = float4(float3(_surface.roughness), 1.f); break;\n            case 7: _output.color = float4(float3(_surface.metalness), 1.f); break;\n            case 8: _output.color = float4(float3(_surface.ambientOcclusion), 1.f); break;\n            default: break;\n        }\n        return _output;\n    #endif\n    \n    __FragmentDoLighting__\n    \n    #ifdef USE_CLUSTERED_LIGHTING\n        \n        int omni_count = cluster_offset_count.y & 0xff;\n        for (int i = 0 ; i < omni_count; ++i, ++lid) {\n            _lightingContribution.add_local_omni(scn_lights[LightIndex(lid)]);\n        }\n\n        \n        int spot_count = (cluster_offset_count.y >> 8);\n        for (int i = 0 ; i < spot_count; ++i, ++lid) {\n            _lightingContribution.add_local_spot(scn_lights[LightIndex(lid)]);\n        }\n\n    #endif\n#else \n        _lightingContribution.diffuse = in.diffuse;\n    #ifdef USE_SPECULAR\n        _lightingContribution.specular = in.specular;\n    #endif\n#endif \n    #ifdef AVOID_OVERLIGHTING\n        _lightingContribution.diffuse = saturate(_lightingContribution.diffuse);\n    #ifdef USE_SPECULAR\n        _lightingContribution.specular = saturate(_lightingContribution.specular);\n    #endif \n    #endif \n#else \n    _lightingContribution.diffuse = float3(1.);\n#endif \n\n    \n    \n    \n    \n#ifdef USE_PBR\n    { \n        float3 diffuseAlbedo = mix(_lightingContribution.pbr.albedo, float3(0.0), _surface.metalness);\n        \n        \n#ifdef USE_PBR_TRANSPARENCY\n        float3 color = (_lightingContribution.ambient * _surface.ambientOcclusion) * _lightingContribution.pbr.albedo;\n#else\n        float3 color = (_lightingContribution.ambient * _surface.ambientOcclusion) * _surface.diffuse.rgb;\n#endif\n        \n        color += _lightingContribution.pbr.envDiffuse;\n        color += _lightingContribution.diffuse * diffuseAlbedo;\n#ifndef DISABLE_SPECULAR\n        color += _lightingContribution.pbr.envSpecular;\n        color += _lightingContribution.specular;\n#endif\n#ifdef USE_EMISSION\n        color += _surface.emission.rgb;\n#endif\n#ifdef USE_MULTIPLY\n        color *= _surface.multiply.rgb;\n#endif\n#ifdef USE_MODULATE\n        color *= _lightingContribution.modulate;\n#endif\n        _output.color.rgb = color;\n    }\n#else \n\n#ifdef USE_SHADOWONLY\n    _output.color.rgb = float3(0.0);\n    _output.color.a = 1. - _lightingContribution.shadowFactor;\n#else\n    _output.color.rgb = illuminate(_surface, _lightingContribution);\n#endif\n#endif\n\n#ifndef USE_SHADOWONLY\n  #ifdef USE_PBR_TRANSPARENCY\n    _output.color.a = _lightingContribution.pbr.transparency;\n  #else\n    _output.color.a = _surface.diffuse.a;\n  #endif\n#endif\n\n#ifdef USE_FOG\n    float fogFactor = pow(clamp(length(_surface.position.xyz) * scn_frame.fogParameters.x + scn_frame.fogParameters.y, 0., scn_frame.fogColor.a), scn_frame.fogParameters.z);\n    _output.color.rgb = mix(_output.color.rgb, scn_frame.fogColor.rgb * _output.color.a, fogFactor);\n#endif\n\n#if !defined(DIFFUSE_PREMULTIPLIED) && !defined(USE_PBR_TRANSPARENCY)\n    _output.color.rgb *= _surface.diffuse.a;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_SHADOWONLY\n    float transparencyFactor = 1.0;\n  #ifdef USE_NODE_OPACITY\n    transparencyFactor *= in.nodeOpacity;\n  #endif\n    _output.color.a *= transparencyFactor; \n\n#else \n\n#ifdef USE_TRANSPARENT \n    \n#ifdef USE_TRANSPARENCY\n    _surface.transparent *= scn_commonprofile.transparency;\n#endif\n    \n#ifdef USE_TRANSPARENCY_RGBZERO\n    \n    _surface.transparent.a = (_surface.transparent.r * 0.212671f) + (_surface.transparent.g * 0.715160f) + (_surface.transparent.b * 0.072169f);\n    _output.color *= (float4(1.f) - _surface.transparent);\n#else\n  #ifndef USE_PBR_TRANSPARENCY\n    _output.color *= _surface.transparent.a;\n  #endif\n#endif\n    \n#else \n    \n#ifdef USE_TRANSPARENCY \n  #ifndef USE_PBR_TRANSPARENCY\n    _output.color *= scn_commonprofile.transparency;\n  #endif\n#endif\n    \n#endif \n    \n#ifdef USE_NODE_OPACITY\n    _output.color *= in.nodeOpacity;\n#endif\n    \n#endif \n    \n    \n    \n    \n    \n#ifdef USE_MODIFIER_FRAMEBUFFER\n    const SCNFramebuffer _framebuffer = {\n#if defined(C3D_SUPPORTS_PROGRAMMABLE_BLENDING) && defined(USE_MODIFIER_FRAMEBUFFER_COLOR0)\n        .color = framebufferColor0\n#else\n        .color = 0.f\n#endif\n    };\n#endif\n    \n#ifdef USE_FRAGMENT_MODIFIER\n    \n    __DoFragmentModifier__\n    \n#endif\n#if defined(USE_CLUSTERED_LIGHTING) && defined(DEBUG_CLUSTER_TILE)\n    _output.color.rgb = mix(_output.color.rgb, float3(scn::debugColorForCount(clusterIndex.z).xyz), 0.1f);\n    _output.color.rgb = mix(_output.color.rgb, float3(clusterIndex.x & 0x1 ^ clusterIndex.y & 0x1).xyz, 0.01f);\n#endif\n#ifdef DISABLE_LINEAR_RENDERING\n    _output.color.rgb = scn::linear_to_srgb(_output.color.rgb);\n#endif\n    \n#ifdef USE_DISCARD\n    if (_output.color.a == 0.) \n        discard_fragment();\n#endif\n\n#ifdef USE_POINT_RENDERING\n    if ((dfdx(pointCoord.x) < 0.5f) && (length_squared(pointCoord * 2.f - 1.f) > 1.f)) {\n        discard_fragment();\n    }\n#endif\n    \n    \n#ifdef USE_OUTLINE\n    _output.color.rgb = in.outlineHash;\n#endif\n    \n\n#ifdef USE_MOTIONBLUR\n#ifdef USE_MULTIPLE_RENDERING\n    _output.motionblur.xy = half2((in.mv_fragment.xy - scn_frame.viewportSize.zw) / in.mv_fragment.z - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * scn_frame.motionBlurIntensity;\n#else\n    _output.motionblur.xy = half2((in.mv_fragment.xy / in.mv_fragment.z) - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * scn_frame.motionBlurIntensity;\n#endif\n    _output.motionblur.z = length(_output.motionblur.xy);\n    _output.motionblur.w = half(-_surface.position.z);\n#endif\n\n#ifdef USE_NORMALS_OUTPUT\n    _output.normals = half4( half3(_surface.normal.xyz), half(_surface.roughness) );\n#endif\n    \n#ifdef USE_RADIANCE_OUTPUT\n    _output.radiance.rgb = half3(_lightingContribution.specular.rgb);\n#endif\n                                 \n#ifdef USE_REFLECTANCE_ROUGHNESS_OUTPUT\n#ifdef USE_PBR\n    _output.reflectanceRoughnessOutput = half4( half3(_lightingContribution.pbr.probeReflectance), half(_surface.roughness) );\n#else \n    _output.reflectanceRoughnessOutput = half4( 0.h );\n#endif\n#endif\n    \n    return _output;\n}\n"
+ "\nenum {\n    SCNDeformerAttributeSrcPosition,\n    SCNDeformerAttributeSrcNormal,\n    SCNDeformerAttributeSrcTangent,\n    \n    SCNDeformerAttributeDstPosition,\n    SCNDeformerAttributeDstNormal,\n    SCNDeformerAttributeDstTangent,\n    \n    SCNDeformerAttributeCount\n};\n"
+ "!G"
+ "-[SCNGeometryWrapDeformerInstance initWithNode:drivingNode:deformer:outputs:computeVertexCount:context:]"
+ "-[SCNGeometryWrapDeformerInstance initWithNode:innerLayerNode:outerLayerNode:deformer:outputs:computeVertexCount:context:]"
+ "-[SCNGeometryWrapDeformerParameters initWithCoder:]"
+ "@32@0:8^{__C3DMesh=}16^{__C3DMesh=}24"
+ "C3DWrapDeformerComputeBindingPointIndicesAndBarycentricCoordsFromUVs"
+ "C3DWrapDeformerComputeSharedBindingPointIndicesAndBarycentricCoordsFromSandwichedPositions_block_invoke_2"
+ "MDLAssetLoadingOption getMDLAssetLoadingOptionDefaultUSDColorSpace()"
+ "MDLAssetLoadingOptionDefaultUSDColorSpace"
+ "SCNGeometryWrapDeformerInstance"
+ "SCNGeometryWrapDeformerUtils.mm"
+ "SCNModelIOPrivate.mm"
+ "Welcome to SceneKit 599.108 (Oct  3 2023 23:12:10)"
+ "__adjustDistanceByAligningProjection"
+ "__bindToUV_block_invoke"
+ "_barycentricCoordsBuffer"
+ "_currentFrameHash"
+ "_innerBindingOffsetsBuffer"
+ "_innerBindingSpaceVectorsBuffer"
+ "_innerLayerInfluencesBuffer"
+ "_innerLayerNode"
+ "_isLegacySingleLayerDeformer"
+ "_legacyDeformedNodeUVChannel"
+ "_legacyDrivingNode"
+ "_legacyDrivingNodeUVChannel"
+ "_legacyOffsetsOrTransformsBuffer"
+ "_legacyUniforms"
+ "_outerBindingOffsetsBuffer"
+ "_outerBindingSpaceVectorsBuffer"
+ "_outerLayerNode"
+ "_pointIndicesBuffer"
+ "bindingInnerLayerInfluences"
+ "bindingInnerLayerInfluencesLength"
+ "bindingInnerOffsets"
+ "bindingInnerTNBs"
+ "bindingOffsetsLength"
+ "bindingOffsetsOrTransformsLength"
+ "bindingOuterOffsets"
+ "bindingOuterTNBs"
+ "bindingSpaceVectorsLength"
+ "boneIndicesSInt16[i] < jointCount"
+ "currentFrameHash"
+ "decodedLength == _bindingData.innerLayerInfluencesLength"
+ "decodedLength == _bindingData.legacyOffsetsOrTransformsLength"
+ "decodedLength == _bindingData.offsetsLength"
+ "decodedLength == _bindingData.tnbMatricesLength"
+ "deformedTexcoordSource"
+ "deformer_wrap_absolute"
+ "deformer_wrap_legacy_absolute"
+ "deformer_wrap_legacy_relative"
+ "deformer_wrap_relative"
+ "driverTexcoordSource"
+ "extraLayerMeshesWithDrivingMesh0:drivingMesh1:"
+ "handleFailureInFunction:file:lineNumber:description:"
+ "initParametersIfNeededWithInnerLayerNodeRef:outerLayerNodeRef:deformedNodeRef:"
+ "initThroughSCNKitBridgeWithURL:options:error:"
+ "initWithInnerLayerNode:outerLayerNode:deformedNode:bindingMode:bindingTransform:"
+ "initWithInnerLayerNode:outerLayerNode:parameters:"
+ "instancesRespondToSelector:"
+ "isLegacySingleLayerDeformer"
+ "kMDLAssetDefaultUSDColorSpace"
+ "scn_decodeArrayOfObjectsOfClass:containingNestedContainersForKey:"
+ "scn_decodeArrayOfObjectsOfClasses:containingNestedContainersForKey:"
+ "scn_decodeDictionaryWithKeysOfClass:objectsOfClass:containingNestedContainersForKey:"
+ "scn_decodeDictionaryWithKeysOfClasses:objectsOfClasses:containingNestedContainersForKey:"
+ "setSwizzle:"
+ "softlink:r:path:/System/Library/Frameworks/ModelIO.framework/ModelIO"
+ "v32@?0@8@\"NSMapTable\"16^B24"
+ "v32@?0@8@\"SCNMTLDeformerStack\"16^B24"
+ "void *ModelIOLibrary()"
+ "{?=\"pointIndices\"^v\"pointIndicesStride\"Q\"pointIndicesFormat\"Q\"barycentricCoords\"^v\"barycentricCoordsStride\"Q\"barycentricCoordsFormat\"Q\"innerLayerInfluences\"^f\"innerLayerInfluencesLength\"Q\"innerLayerTNBs\"^f\"outerLayerTNBs\"^f\"tnbMatricesLength\"Q\"innerLayerOffsets\"^f\"outerLayerOffsets\"^f\"offsetsLength\"Q\"legacyOffsetsOrTransforms\"^f\"legacyOffsetsOrTransformsLength\"Q}"
+ "{?=\"vertexCount\"I\"innerLayerToDeformedTransform\"{?=\"columns\"[4]}\"outerLayerToDeformedTransform\"{?=\"columns\"[4]}}"
+ "{Cache=\"rasterizerStates\"^{__C3DRasterizerStates}\"mesh\"^{__C3DMesh}\"metalMesh\"@\"SCNMTLMesh\"\"meshElement\"^{__C3DMeshElement}\"metalMeshElement\"@\"SCNMTLMeshElement\"\"program\"^{__C3DFXMetalProgram}\"material\"^{__C3DMaterial}\"geometry\"^{__C3DGeometry}\"metalShadable\"@\"SCNMTLShadable\"\"commonProfile\"^{__C3DEffectCommonProfile}\"blendStates\"^{__C3DBlendStates}\"colorBufferWriteMask\"C\"primitiveTopologyClass\"C\"node\"^{__C3DNode}\"deformers\"^{__C3DDeformerStack}\"vertexDescriptorHash\"Q\"tessellationPipelineStateHash\"C\"renderPipeline\"@\"SCNMTLRenderPipeline\"}"
+ "\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xd2"
- "\n#import <metal_stdlib>\n\nusing namespace metal;\n\n#import \"scn_metal\"\n#import \"scn_util.h\"\n#import \"C3D-PBR.metal\"\n#import \"scn_tessellation.h\"\n\n\n\n#ifdef USE_LAYERED_RENDERING\n#define texture2d_layer texture2d_array\n#define sampleLayer(a,b) sample(a,b,in.sliceIndex)\n#else\n#define texture2d_layer texture2d\n#define sampleLayer(a,b) sample(a,b)\n#endif\n\n#ifdef C3D_USE_TEXTURE_FOR_LIGHT_INDICES\n#define LightIndex(lid) u_lightIndicesTexture.read((ushort)lid).x\n#else\n#define LightIndex(lid) u_lightIndicesBuffer[lid]\n#endif\n\n\n\ntypedef struct {\n\n#ifdef USE_MODELTRANSFORM\n    float4x4 modelTransform;\n#endif\n#ifdef USE_INVERSEMODELTRANSFORM\n    float4x4 inverseModelTransform;\n#endif\n#ifdef USE_MODELVIEWTRANSFORM\n    float4x4 modelViewTransform;\n#endif\n#ifdef USE_INVERSEMODELVIEWTRANSFORM\n    float4x4 inverseModelViewTransform;\n#endif\n#ifdef USE_NORMALTRANSFORM\n    float4x4 normalTransform;\n#endif\n#ifdef USE_MODELVIEWPROJECTIONTRANSFORM\n    float4x4 modelViewProjectionTransform;\n#endif\n#ifdef USE_INVERSEMODELVIEWPROJECTIONTRANSFORM\n    float4x4 inverseModelViewProjectionTransform;\n#endif\n#ifdef USE_MOTIONBLUR\n    float4x4 lastFrameModelTransform;\n    float motionBlurIntensity;\n#endif\n#ifdef USE_BOUNDINGBOX\n    float2x3 boundingBox;\n#endif\n#ifdef USE_WORLDBOUNDINGBOX\n    float2x3 worldBoundingBox;\n#endif\n#ifdef USE_NODE_OPACITY\n    float nodeOpacity;\n#endif\n#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)\n    sh2_coefficients shCoefficients;\n#elif defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 3)\n    sh3_coefficients shCoefficients;\n#endif\n} commonprofile_node;\n\ntypedef struct {\n    float3 position         [[attribute(SCNVertexSemanticPosition)]];\n#ifdef HAS_NORMAL\n    float3 normal           [[attribute(SCNVertexSemanticNormal)]];\n#endif\n#ifdef USE_TANGENT\n    float4 tangent          [[attribute(SCNVertexSemanticTangent)]];\n#endif\n#ifdef USE_VERTEX_COLOR\n    float4 color            [[attribute(SCNVertexSemanticColor)]];\n#endif\n#if defined(NEED_IN_TEXCOORD0) || defined(DEBUG_PIXEL)\n    float2 texcoord0        [[attribute(SCNVertexSemanticTexcoord0)]];\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    float2 texcoord1        [[attribute(SCNVertexSemanticTexcoord1)]];\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    float2 texcoord2        [[attribute(SCNVertexSemanticTexcoord2)]];\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    float2 texcoord3        [[attribute(SCNVertexSemanticTexcoord3)]];\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    float2 texcoord4        [[attribute(SCNVertexSemanticTexcoord4)]];\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    float2 texcoord5        [[attribute(SCNVertexSemanticTexcoord5)]];\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    float2 texcoord6        [[attribute(SCNVertexSemanticTexcoord6)]];\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    float2 texcoord7        [[attribute(SCNVertexSemanticTexcoord7)]];\n#endif\n} scn_vertex_t; \n\ntypedef struct {\n    float4 fragmentPosition [[position]]; \n#ifdef USE_POINT_RENDERING\n    float fragmentSize [[point_size]];\n#endif\n#ifdef USE_VERTEX_COLOR\n    float4 vertexColor;\n#endif\n#ifdef USE_PER_VERTEX_LIGHTING\n    float3 diffuse;\n#ifdef USE_SPECULAR\n    float3 specular;\n#endif\n#ifdef USE_CLEARCOAT\n    float clearCoat;\n#endif\n#ifdef USE_CLEARCOATROUGHNESS\n    float clearCoatRoughness;\n#endif\n#ifdef USE_CLEARCOATNORMAL\n    float clearCoatNormal;\n#endif\n#endif\n#if defined(USE_POSITION) && (USE_POSITION == 2)\n    float3 position;\n#endif\n#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)\n    float3 normal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    float3 tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    float3 bitangent;\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n    float2 displacementTexcoord;   \n#endif\n#ifdef USE_CLEARCOAT_MAP\n    float2 clearCoatTexcoord;   \n#endif\n#ifdef USE_CLEARCOATROUGHNESS_MAP\n    float2 clearCoatRoughnessTexcoord;   \n#endif\n#ifdef USE_CLEARCOATNORMAL_MAP\n    float2 clearCoatNormalTexcoord;   \n#endif\n#if defined(USE_PBR_TRANSPARENCY) && defined(USE_TRANSPARENCY)\n    float transparency;\n#endif\n#ifdef USE_NODE_OPACITY\n    float nodeOpacity;\n#endif\n#ifdef USE_TEXCOORD\n    __TexcoordDecl__\n#endif\n    \n#ifdef USE_EXTRA_VARYINGS\n    __ExtraVaryingsDecl__\n#endif\n    \n#ifdef USE_MOTIONBLUR\n    float3 mv_fragment;\n    float3 mv_lastFragment;\n#endif\n#ifdef USE_OUTLINE\n    float outlineHash [[ flat ]];\n#endif\n#ifdef USE_INSTANCING\n    uint   instanceID [[ flat ]];\n#endif\n#ifndef USE_VERTEX_AMPLIFICATION \n#ifdef USE_LAYERED_RENDERING\n    uint   sliceIndex [[render_target_array_index]];\n#endif\n#ifdef USE_MULTIPLE_VIEWPORTS_RENDERING\n    uint   sliceIndex [[viewport_array_index]];\n#endif\n#endif\n#if DEBUG_PIXEL\n    float2 uv0;\n#endif\n} commonprofile_io;\n\n\n#ifdef USE_SHADER_MODIFIERS\n__ShaderModifiersDecl__\n#endif\n\n\n#import \"C3D-Lighting.metal\"\n\nenum C3DColorMask {\n    kC3DColorMaskRed    = 0x1 << 3,\n    kC3DColorMaskGreen  = 0x1 << 2,\n    kC3DColorMaskBlue   = 0x1 << 1,\n    kC3DColorMaskAlpha  = 0x1 << 0\n};\n\ninline float4 colorFromMask(float4 col, int mask)\n{\n    switch (mask) {\n\n        case kC3DColorMaskRed:                      return col.r;\n        case kC3DColorMaskRed|kC3DColorMaskGreen:   return float4(col.rg, 0.f, 1.f);\n        case kC3DColorMaskRed|kC3DColorMaskBlue:    return float4(col.rb, 0.f, 1.f);\n        case kC3DColorMaskRed|kC3DColorMaskAlpha:   return float4(col.ra, 0.f, 1.f);\n\n        case kC3DColorMaskGreen:                    return col.g;\n        case kC3DColorMaskGreen|kC3DColorMaskBlue:  return float4(col.bg, 0.f, 1.f);\n        case kC3DColorMaskGreen|kC3DColorMaskAlpha: return float4(col.ag, 0.f, 1.f);\n\n        case kC3DColorMaskBlue:     return col.b;\n        case kC3DColorMaskBlue|kC3DColorMaskAlpha:  return float4(col.ab, 0.f, 1.f);\n\n        case kC3DColorMaskAlpha:    return col.a;\n    }\n    return col;\n}\n\n#ifndef USE_PBR\n\ninline float3 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)\n{\n    float3 albedo = surface.diffuse.rgb * surface.ambientOcclusion;\n    float3 color = lighting.diffuse * albedo;\n#if defined(USE_AMBIENT_LIGHTING) && (defined(LOCK_AMBIENT_WITH_DIFFUSE) || defined(USE_AMBIENT_AS_AMBIENTOCCLUSION))\n    color +=  lighting.ambient * albedo;\n#endif\n#ifdef USE_SELFILLUMINATION\n    color += surface.diffuse.rgb * surface.selfIllumination.rgb;\n#endif\n    \n    \n    \n#ifdef USE_SPECULAR\n    float3 S = lighting.specular;\n#elif defined(USE_REFLECTIVE)\n    float3 S = float3(0.);\n#endif\n#ifdef USE_REFLECTIVE\n    S += surface.reflective.rgb * surface.ambientOcclusion;\n#endif\n#ifdef USE_SPECULAR\n    S *= surface.specular.rgb;\n#endif\n#if (defined(USE_SPECULAR) || defined(USE_REFLECTIVE)) && !defined(DISABLE_SPECULAR)\n    color += S;\n#endif\n#if defined(USE_AMBIENT) && !defined(USE_AMBIENT_AS_AMBIENTOCCLUSION)\n    color += surface.ambient.rgb * lighting.ambient;\n#endif\n#ifdef USE_EMISSION\n    color += surface.emission.rgb;\n#endif\n#ifdef USE_MULTIPLY\n    color *= surface.multiply.rgb;\n#endif\n#ifdef USE_MODULATE\n    color *= lighting.modulate;\n#endif\n    return color;\n}\n#endif\n\nstruct SCNShaderGeometry\n{\n    float4 position;\n    float3 normal;\n    float4 tangent;\n    float4 color;\n    float pointSize;\n    float2 texcoords[8]; \n#ifdef USE_CLIP_DISTANCE0\n    float clipDistance0;\n#endif\n#ifdef USE_CLIP_DISTANCE1\n    float clipDistance1;\n#endif\n#ifdef USE_CLIP_DISTANCE2\n    float clipDistance2;\n#endif\n#ifdef USE_CLIP_DISTANCE3\n    float clipDistance3;\n#endif\n};\n\nstruct commonprofile_uniforms {\n    \n    float4 diffuseColor;\n    float4 specularColor;\n    float4 ambientColor;\n    float4 emissionColor;\n    float4 selfIlluminationColor;\n    float4 reflectiveColor;\n    float4 multiplyColor;\n    float4 transparentColor;\n    float clearCoat;\n    float clearCoatRoughness;\n    float3 clearCoatNormal;\n    float metalness;\n    \n    float roughness;\n    float diffuseIntensity;\n    float specularIntensity;\n    float normalIntensity;\n    float ambientIntensity;\n    float emissionIntensity;\n    float selfIlluminationIntensity;\n    float reflectiveIntensity;\n    float multiplyIntensity;\n    float transparentIntensity;\n    \n    float metalnessIntensity;\n    float roughnessIntensity;\n    float clearCoatIntensity;\n    float clearCoatRoughnessIntensity;\n    float clearCoatNormalIntensity;\n    float displacementIntensity;\n    float materialShininess;\n    float selfIlluminationOcclusion;\n    float transparency;\n    float3 fresnel; \n#if USE_ARGUMENT_BUFFERS\n    \n    texture2d<float>    emissionTexture;\n    sampler             emissionSampler;\n    texture2d<float>    ambientTexture;\n    sampler             ambientSampler;\n    \n    texture2d<float>    diffuseTexture;\n    sampler             diffuseSampler;\n    texture2d<float>    specularTexture;\n    sampler             specularSampler;\n#if defined(USE_REFLECTIVE_CUBEMAP)\n    texturecube<float>  reflectiveTexture;\n#else\n    texture2d<float>    reflectiveTexture;\n#endif\n    sampler             reflectiveSampler;\n    texture2d<float>    transparentTexture;\n    sampler             transparentSampler;\n    texture2d<float>    multiplyTexture;\n    sampler             multiplySampler;\n    \n    texture2d<float>    normalTexture;\n    sampler             normalSampler;\n    texture2d<float>    selfIlluminationTexture;\n    sampler             selfIlluminationSampler;\n    texture2d<float>    metalnessTexture;\n    sampler             metalnessSampler;\n    texture2d<float>    roughnessTexture;\n    sampler             roughnessSampler;\n    texture2d<float>    displacementTexture;\n    sampler             displacementSampler;\n    \n    \n#endif \n#ifdef TEXTURE_TRANSFORM_COUNT\n    float4x4 textureTransforms[TEXTURE_TRANSFORM_COUNT];\n#endif\n};\n\n#ifdef USE_OPENSUBDIV\n\n__OpenSubdivDeclPerGeometry__\n__OpenSubdivDeclPerPatchType__\n__OpenSubdivDeclShared__\n\nstruct osd_packed_vertex {\n    packed_float3 position;\n#if defined(OSD_USER_VARYING_DECLARE_PACKED)\n    OSD_USER_VARYING_DECLARE_PACKED\n#endif\n};\n\n#endif\n\n\n#ifdef USE_DISPLACEMENT_MAP\nstatic void applyDisplacement(texture2d<float>                 displacementTexture,\n                              sampler                          displacementTextureSampler,\n                              float2                           displacementTexcoord,\n                              thread SCNShaderGeometry&        geometry,\n                              constant commonprofile_uniforms& scn_commonprofile)\n{\n#ifdef USE_DISPLACEMENT_TEXTURE_COMPONENT\n\tfloat altitude = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n#ifdef USE_DISPLACEMENT_INTENSITY\n\taltitude *= scn_commonprofile.displacementIntensity;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n\tfloat3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));\n\tgeometry.position.xyz += geometry.normal * altitude;\n\t\n\tfloat3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);\n\tfloat3 h;\n\th.x = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\th.y = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\th.z = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord-offset.zy), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\t\n#ifdef USE_DISPLACEMENT_INTENSITY\n\th *= scn_commonprofile.displacementIntensity;\n#endif\n\t\n\tfloat3 n = normalize( float3( (h.x - h.y)/offset.x, 1., (h.x - h.z)/offset.y) );\n\tgeometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;\n\tgeometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));\n#endif \n#else \n\tfloat3 displacement = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;\n#ifdef USE_DISPLACEMENT_INTENSITY\n\tdisplacement *= scn_commonprofile.displacementIntensity;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n\tfloat3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));\n\tgeometry.position.xyz += geometry.tangent.xyz * displacement.x + geometry.normal.xyz * displacement.y + bitangent.xyz * displacement.z;\n\t\n\tfloat3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);\n\tfloat3 a = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;\n\tfloat3 b = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz).rgb;\n\tfloat3 c = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.zy).rgb;\n\t\n#ifdef USE_DISPLACEMENT_INTENSITY\n\ta *= scn_commonprofile.displacementIntensity;\n\tb *= scn_commonprofile.displacementIntensity;\n\tc *= scn_commonprofile.displacementIntensity;\n#endif\n\t\n\tb += offset.xzz;\n\tc -= offset.zzy;\n\tfloat3 n = (normalize( cross( b-a, c-a ) ));\n\tgeometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;\n\tgeometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));\n#endif \n#endif \n}\n#endif \n\n#ifdef USE_OUTLINE\nstatic inline float hash(float2 p)\n{\n    const float2 kMod2 = float2(443.8975f, 397.2973f);\n    p  = fract(p * kMod2);\n    p += dot(p.xy, p.yx+19.19f);\n    return fract(p.x * p.y);\n}\n#endif\n    \n\n\n\n\n#if defined(USE_TESSELLATION)\nstruct scn_patch_t {\n    patch_control_point<scn_vertex_t> controlPoints;\n};\n#endif\n\n#if defined(USE_OPENSUBDIV)\n#if OSD_IS_ADAPTIVE\n[[ patch(quad, VERTEX_CONTROL_POINTS_PER_PATCH) ]]\n#endif\n#elif defined(USE_TESSELLATION)\n[[ patch(triangle, 3) ]]\n#endif\n    \n    \nvertex commonprofile_io commonprofile_vert(\n#if !defined(USE_TESSELLATION)\n                                           scn_vertex_t                       in                               [[ stage_in ]]\n                                           , uint                             scn_vertexID                     [[ vertex_id ]]\n#else \n                                           \n#ifdef USE_OPENSUBDIV\n#if OSD_IS_ADAPTIVE\n#if USE_STAGE_IN\n                                           PatchInput                         patchInput                       [[ stage_in ]]\n#else\n                                           OsdVertexBufferSet                 patchInput\n#endif\n                                           , float2                           patchCoord                       [[ position_in_patch ]]\n                                           , uint                             patchID                          [[ patch_id ]]\n                                           , constant float&                  osdTessellationLevel             [[ buffer(TESSELLATION_LEVEL_BUFFER_INDEX) ]]\n#else \n                                           constant unsigned*                 osdIndicesBuffer                 [[ buffer(INDICES_BUFFER_INDEX) ]]\n                                           , constant osd_packed_vertex*      osdVertexBuffer                  [[ buffer(VERTEX_BUFFER_INDEX) ]]\n                                           , uint                             vertexID                         [[ vertex_id ]]\n#endif \n#if defined(OSD_FVAR_WIDTH)\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n                                           , constant uint32_t&               osdFaceVaryingChannelCount       [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_COUNT_INDEX) ]]\n                                           , constant OsdFVarChannelDesc*     osdFaceVaryingChannelDescriptors [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_DESCRIPTORS_INDEX) ]]\n                                           , constant uint32_t&               osdFaceVaryingPatchArrayIndex    [[ buffer(OSD_FVAR_CHANNELS_PATCH_ARRAY_INDEX_BUFFER_INDEX) ]]\n                                           , constant void*                   osdFaceVaryingChannelsPackedData [[ buffer(OSD_FVAR_CHANNELS_PACKED_DATA_BUFFER_INDEX) ]]\n#else\n                                           , constant float*                  osdFaceVaryingData               [[ buffer(OSD_FVAR_DATA_BUFFER_INDEX) ]]\n                                           , constant int*                    osdFaceVaryingIndices            [[ buffer(OSD_FVAR_INDICES_BUFFER_INDEX) ]]\n#if OSD_IS_ADAPTIVE\n                                           , constant packed_int3*            osdFaceVaryingPatchParams        [[ buffer(OSD_FVAR_PATCHPARAM_BUFFER_INDEX) ]]\n                                           , constant packed_int4&            osdFaceVaryingPatchArray         [[ buffer(OSD_FVAR_PATCH_ARRAY_BUFFER_INDEX) ]]\n#endif\n#endif \n#endif \n#else \n                                           scn_patch_t                        in                               [[ stage_in ]]\n                                           , float3                           patchCoord                       [[ position_in_patch ]]\n#endif \n#endif \n                                           \n#ifdef USE_MULTIPLE_RENDERING\n                                           , constant SCNSceneBuffer*         scn_frame_multi                  [[ buffer(0) ]]\n#else\n                                           , constant SCNSceneBuffer&         scn_frame                        [[ buffer(0) ]]\n#endif\n#if defined(USE_INSTANCING) || defined(USE_MULTIPLE_RENDERING)\n                                           , constant commonprofile_node*     scn_nodes                        [[ buffer(1) ]]\n#else\n                                           , constant commonprofile_node&     scn_node                         [[ buffer(1) ]]\n#endif\n#ifdef USE_PER_VERTEX_LIGHTING\n                                           , constant scn_light*              scn_lights                       [[ buffer(2) ]]\n                                           , constant float4*                 u_shadowKernel\n                                           , texture2d_array<float>           u_areaLightBakedDataTexture\n#endif\n                                           \n                                           , constant commonprofile_uniforms& scn_commonprofile\n#ifdef USE_INSTANCING\n                                           , uint                             scn_instanceID                   [[ instance_id ]]\n#endif\n#ifdef USE_VERTEX_AMPLIFICATION\n                                           , ushort                           amplificationID                  [[ amplification_id ]]\n#endif\n\n#ifdef USE_POINT_RENDERING\n                                           \n                                           , constant float3&                 scn_pointSize\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n#if USE_ARGUMENT_BUFFERS\n#define u_displacementTexture           scn_commonprofile.displacementTexture\n#define u_displacementTextureSampler    scn_commonprofile.displacementSampler\n#else\n                                           , texture2d<float>                 u_displacementTexture\n                                           , sampler                          u_displacementTextureSampler\n#endif \n#endif \n#ifdef USE_VERTEX_EXTRA_ARGUMENTS\n                                           __VertexExtraArguments__\n#endif\n                                           )\n{\n    commonprofile_io out;\n    \n#ifdef USE_MULTIPLE_RENDERING\n\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant SCNSceneBuffer& scn_frame = scn_frame_multi[amplificationID];\n#else\n    out.instanceID = scn_instanceID / USE_MULTIPLE_RENDERING;\n    out.sliceIndex = scn_instanceID % USE_MULTIPLE_RENDERING;\n    constant SCNSceneBuffer& scn_frame = scn_frame_multi[out.sliceIndex];\n#endif\n    \n#ifdef USE_INSTANCING\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& scn_node = scn_nodes[USE_MULTIPLE_RENDERING * scn_instanceID + amplificationID];\n#else\n    \n    \n    constant commonprofile_node& scn_node = scn_nodes[scn_instanceID];\n#endif\n#else\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& scn_node = scn_nodes[amplificationID];\n#else\n    constant commonprofile_node& scn_node = scn_nodes[out.sliceIndex];\n#endif\n#endif\n    \n#else \n    \n#ifdef USE_INSTANCING\n    out.instanceID = scn_instanceID;\n    constant commonprofile_node& scn_node = scn_nodes[scn_instanceID];\n#endif\n    \n#endif \n    \n    \n#ifdef USE_TESSELLATION\n    uint scn_vertexID; \n    scn_vertexID = 0;\n#endif\n    \n    \n    \n    \n    \n    SCNShaderGeometry _geometry;\n    \n#if !defined(USE_TESSELLATION)\n    \n    \n    _geometry.position = float4(in.position, 1.f);\n#if defined(USE_NORMAL) && defined(HAS_NORMAL)\n    _geometry.normal = in.normal;\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = in.tangent;\n#endif\n#ifdef NEED_IN_TEXCOORD0\n    _geometry.texcoords[0] = in.texcoord0;\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    _geometry.texcoords[1] = in.texcoord1;\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    _geometry.texcoords[2] = in.texcoord2;\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    _geometry.texcoords[3] = in.texcoord3;\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    _geometry.texcoords[4] = in.texcoord4;\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    _geometry.texcoords[5] = in.texcoord5;\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    _geometry.texcoords[6] = in.texcoord6;\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    _geometry.texcoords[7] = in.texcoord7;\n#endif\n#ifdef HAS_VERTEX_COLOR\n    _geometry.color = in.color;\n#elif USE_VERTEX_COLOR\n    _geometry.color = float4(1.);\n#endif\n    \n#else \n    \n#ifdef USE_OPENSUBDIV\n#if OSD_IS_ADAPTIVE\n#if USE_STAGE_IN\n    int3 patchParam = patchInput.patchParam;\n#else\n    int3 patchParam = patchInput.patchParamBuffer[patchID];\n#endif\n    \n    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);\n    float tessellationLevel = min(osdTessellationLevel, (float)OSD_MAX_TESS_LEVEL) / exp2((float)refinementLevel - 1);\n    \n    OsdPatchVertex patchVertex = OsdComputePatch(tessellationLevel, patchCoord, patchID, patchInput);\n    \n#if defined(OSD_FVAR_WIDTH)\n    int patchIndex = OsdGetPatchIndex(patchID);\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);\n#else\n    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingIndices, osdFaceVaryingData, osdFaceVaryingPatchParams, osdFaceVaryingPatchArray);\n#endif\n#endif\n    \n    _geometry.position = float4(patchVertex.position, 1.f);\n    \n#if defined(USE_NORMAL)\n    _geometry.normal = patchVertex.normal;\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = float4(patchVertex.tangent, -1.f);\n    \n#endif\n#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[0] = patchVertex.texcoord0;\n#endif\n#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[1] = patchVertex.texcoord1;\n#endif\n#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[2] = patchVertex.texcoord2;\n#endif\n#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[3] = patchVertex.texcoord3;\n#endif\n#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[4] = patchVertex.texcoord4;\n#endif\n#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[5] = patchVertex.texcoord5;\n#endif\n#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[6] = patchVertex.texcoord6;\n#endif\n#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[7] = patchVertex.texcoord7;\n#endif\n#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.color = patchVertex.color;\n#endif\n    \n#else \n    \n#if OSD_PATCH_QUADS\n    const uint primitiveIndex = vertexID / 6;\n#ifdef USE_NORMAL\n    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 0]].position;\n    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 1]].position;\n    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 2]].position;\n    float3 normal = normalize(cross(p2 - p1, p0 - p1));\n#endif\n    const uint triangleIndices[6] = { 0, 1, 2, 0, 2, 3 };\n    const uint quadVertexIndex = triangleIndices[vertexID % 6];\n    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + quadVertexIndex]];\n#elif OSD_PATCH_TRIANGLES\n    const uint primitiveIndex = vertexID / 3;\n#ifdef USE_NORMAL\n    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 0]].position;\n    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 1]].position;\n    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 2]].position;\n    float3 normal = normalize(cross(p2 - p1, p0 - p1));\n#endif\n    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[vertexID]];\n#endif\n    \n    float3 position = osdVertex.position;\n    \n#if defined(OSD_FVAR_WIDTH)\n    int patchIndex = OsdGetPatchIndex(primitiveIndex);\n#if OSD_PATCH_QUADS\n    float2 quadUVs[4] = { float2(0,0), float2(1,0), float2(1,1), float2(0,1) };\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);\n#else\n    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingIndices, osdFaceVaryingData);\n#endif\n#elif OSD_PATCH_TRIANGLES\n    \n#endif\n#endif \n    \n#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[0] = osdVertex.texcoord0;\n#endif\n#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[1] = osdVertex.texcoord1;\n#endif\n#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[2] = osdVertex.texcoord2;\n#endif\n#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[3] = osdVertex.texcoord3;\n#endif\n#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[4] = osdVertex.texcoord4;\n#endif\n#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[5] = osdVertex.texcoord5;\n#endif\n#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[6] = osdVertex.texcoord6;\n#endif\n#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[7] = osdVertex.texcoord7;\n#endif\n#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.color = osdVertex.color;\n#endif\n    \n    _geometry.position = float4(position, 1.f);\n#ifdef USE_NORMAL\n    _geometry.normal = normal;\n#endif\n    \n#endif \n    \n#else \n    \n    \n    \n    \n    \n#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE) || defined(TESSELLATION_SMOOTHING_MODE_PHONG)\n    float3 P0 = in.controlPoints[0].position;\n    float3 P1 = in.controlPoints[1].position;\n    float3 P2 = in.controlPoints[2].position;\n    float3 N0 = in.controlPoints[0].normal;\n    float3 N1 = in.controlPoints[1].normal;\n    float3 N2 = in.controlPoints[2].normal;\n#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE)\n    float3 position, normal;\n    scn_smooth_geometry_pn_triangle(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);\n#elif defined(TESSELLATION_SMOOTHING_MODE_PHONG)\n    float3 position, normal;\n    scn_smooth_geometry_phong(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);\n#endif\n    _geometry.position = float4(position, 1.f);\n#ifdef USE_NORMAL\n    _geometry.normal = normal;\n#endif\n#else \n    \n    _geometry.position = float4(scn::barycentric_mix(in.controlPoints[0].position, in.controlPoints[1].position, in.controlPoints[2].position, patchCoord), 1.f);\n#if defined(USE_NORMAL) && defined(HAS_NORMAL)\n    _geometry.normal = normalize(scn::barycentric_mix(in.controlPoints[0].normal, in.controlPoints[1].normal, in.controlPoints[2].normal, patchCoord));\n#endif\n#endif \n    \n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = normalize(scn::barycentric_mix(in.controlPoints[0].tangent, in.controlPoints[1].tangent, in.controlPoints[2].tangent, patchCoord));\n#endif\n#ifdef NEED_IN_TEXCOORD0\n    _geometry.texcoords[0] = scn::barycentric_mix(in.controlPoints[0].texcoord0, in.controlPoints[1].texcoord0, in.controlPoints[2].texcoord0, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    _geometry.texcoords[1] = scn::barycentric_mix(in.controlPoints[0].texcoord1, in.controlPoints[1].texcoord1, in.controlPoints[2].texcoord1, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    _geometry.texcoords[2] = scn::barycentric_mix(in.controlPoints[0].texcoord2, in.controlPoints[1].texcoord2, in.controlPoints[2].texcoord2, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    _geometry.texcoords[3] = scn::barycentric_mix(in.controlPoints[0].texcoord3, in.controlPoints[1].texcoord3, in.controlPoints[2].texcoord3, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    _geometry.texcoords[4] = scn::barycentric_mix(in.controlPoints[0].texcoord4, in.controlPoints[1].texcoord4, in.controlPoints[2].texcoord4, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    _geometry.texcoords[5] = scn::barycentric_mix(in.controlPoints[0].texcoord5, in.controlPoints[1].texcoord5, in.controlPoints[2].texcoord5, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    _geometry.texcoords[6] = scn::barycentric_mix(in.controlPoints[0].texcoord6, in.controlPoints[1].texcoord6, in.controlPoints[2].texcoord6, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    _geometry.texcoords[7] = scn::barycentric_mix(in.controlPoints[0].texcoord7, in.controlPoints[1].texcoord7, in.controlPoints[2].texcoord7, patchCoord);\n#endif\n#ifdef HAS_VERTEX_COLOR\n    _geometry.color = scn::barycentric_mix(in.controlPoints[0].color, in.controlPoints[1].color, in.controlPoints[2].color, patchCoord);\n#elif USE_VERTEX_COLOR\n    _geometry.color = float4(1.);\n#endif\n    \n#endif \n    \n#endif \n    \n#ifdef USE_POINT_RENDERING\n    _geometry.pointSize = scn_pointSize.x;\n#endif\n    \n#ifdef USE_TEXCOORD\n    __VertexDoVertexOnlyTexcoord__\n#endif\n    \n#ifdef USE_DISPLACEMENT_MAP\n    applyDisplacement(u_displacementTexture, u_displacementTextureSampler, _displacementTexcoord, _geometry, scn_commonprofile);\n    out.displacementTexcoord = _displacementTexcoord;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_GEOMETRY_MODIFIER\n    \n    __DoGeometryModifier__\n    \n#endif\n    \n#ifdef USE_CLIP_DISTANCE0\n    out.clipDistance[0] = _geometry.clipDistance0;\n#endif\n#ifdef USE_CLIP_DISTANCE1\n    out.clipDistance[1] = _geometry.clipDistance1;\n#endif\n#ifdef USE_CLIP_DISTANCE2\n    out.clipDistance[2] = _geometry.clipDistance2;\n#endif\n#ifdef USE_CLIP_DISTANCE3\n    out.clipDistance[3] = _geometry.clipDistance3;\n#endif\n    \n    \n    \n    \n    \n    \n#if defined(USE_POSITION) || (defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)) || defined(USE_TANGENT) || defined(USE_BITANGENT) || defined(USE_INSTANCING)\n    SCNShaderSurface _surface;\n#endif\n#if defined(USE_POSITION) || defined(USE_INSTANCING)\n    _surface.position = (scn_node.modelViewTransform * _geometry.position).xyz;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n#ifdef HINT_UNIFORM_SCALE\n    float3x3 nrmTransform = scn::mat3(scn_node.modelViewTransform);\n    _surface.normal = nrmTransform * _geometry.normal;\n#else\n    float3x3 modelViewTransform = scn::mat3(scn_node.modelViewTransform);\n    float3 invScaleSquared = 1.f / float3(length_squared(modelViewTransform[0]),\n                                          length_squared(modelViewTransform[1]),\n                                          length_squared(modelViewTransform[2]));\n    _surface.normal = normalize(modelViewTransform * (_geometry.normal * invScaleSquared));\n#endif\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _surface.tangent = normalize(scn::mat3(scn_node.modelViewTransform) * _geometry.tangent.xyz);\n    _surface.bitangent = _geometry.tangent.w * cross(_surface.tangent, _surface.normal); \n    \n#endif\n    \n    \n#ifdef USE_VIEW\n    _surface.view = normalize(-_surface.position);\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_PER_VERTEX_LIGHTING\n    \n    SCNShaderLightingContribution _lightingContribution(_surface, out);\n    _lightingContribution.diffuse = 0.;\n  #ifdef USE_SPECULAR\n    _lightingContribution.specular = 0.;\n    _surface.shininess = scn_commonprofile.materialShininess;\n  #endif\n    \n    __VertexDoLighting__\n    \n    out.diffuse = _lightingContribution.diffuse;\n  #ifdef USE_SPECULAR\n    out.specular = _lightingContribution.specular;\n  #endif\n#endif\n#if defined(USE_POSITION) && (USE_POSITION == 2)\n    out.position = _surface.position;\n#endif\n#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)\n    out.normal = _surface.normal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    out.tangent = _surface.tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    out.bitangent = _surface.bitangent;\n#endif\n#ifdef USE_VERTEX_COLOR\n    out.vertexColor = _geometry.color;\n#endif\n    \n#if DEBUG_PIXEL\n    out.uv0 = in.texcoord0;\n#endif\n\n#ifdef USE_TEXCOORD\n    __VertexDoTexcoord__\n#endif\n    \n    \n    \n    \n    \n#if defined(USE_POSITION) || defined(USE_INSTANCING)\n    out.fragmentPosition = scn_frame.projectionTransform * float4(_surface.position, 1.);\n#elif defined(USE_MODELVIEWPROJECTIONTRANSFORM) \n    out.fragmentPosition = scn_node.modelViewProjectionTransform * _geometry.position;\n#endif\n    \n#if defined(USE_PBR_TRANSPARENCY) && defined(USE_TRANSPARENCY)\n    out.transparency = scn_commonprofile.transparency;\n#endif\n#ifdef USE_NODE_OPACITY\n    out.nodeOpacity = scn_node.nodeOpacity;\n#endif\n    \n#ifdef USE_POINT_RENDERING\n    float screenSize = _geometry.pointSize / out.fragmentPosition.w;\n    out.fragmentSize = clamp(screenSize, scn_pointSize.y, scn_pointSize.z);\n#endif\n    \n#ifdef USE_MOTIONBLUR\n    float4 lastFrameFragmentPosition = scn_frame.lastFrameViewProjectionTransform * scn_node.lastFrameModelTransform * _geometry.position;\n    out.mv_fragment = out.fragmentPosition.xyw;\n    out.mv_lastFragment = lastFrameFragmentPosition.xyw;\n#endif\n    \n#ifdef USE_OUTLINE\n\tout.outlineHash = hash(scn_node.modelTransform[3].xy)+1.f/255.f;\n#endif\n    \n    return out;\n}\n\n\n\n\n\nstruct SCNOutput\n{\n    float4 color [[ color(0) ]];\n#ifdef USE_COLOR1_OUTPUT\n    half4 color1 [[ color(1) ]];\n#endif\n#ifdef USE_NORMALS_OUTPUT\n    half4 normals [[ color(2) ]];\n#endif\n#ifdef USE_MOTIONBLUR\n    half4 motionblur [[ color(3) ]];\n#endif\n#ifdef USE_REFLECTANCE_ROUGHNESS_OUTPUT\n    half4 reflectanceRoughnessOutput [[ color(4) ]];\n#endif\n#ifdef USE_RADIANCE_OUTPUT\n    half4 radiance [[ color(5) ]];\n#endif\n};\n    \n#ifdef USE_MODIFIER_FRAMEBUFFER\nstruct SCNFramebuffer\n{\n    float4 color;\n};\n#endif\n\nfragment SCNOutput commonprofile_frag(commonprofile_io                   in                          [[ stage_in  ]]\n                                      , constant commonprofile_uniforms& scn_commonprofile           [[ buffer(0) ]]\n#ifdef USE_MULTIPLE_RENDERING\n                                      , constant SCNSceneBuffer*         scn_frame_multi             [[ buffer(1) ]]\n#else\n                                      , constant SCNSceneBuffer&         scn_frame                   [[ buffer(1) ]]\n#endif\n#if defined(USE_INSTANCING) || defined(USE_MULTIPLE_RENDERING)\n                                      , constant commonprofile_node*     scn_nodes                   [[ buffer(2) ]]\n#else\n                                      , constant commonprofile_node&     scn_node                    [[ buffer(2) ]]\n#endif\n#ifdef USE_PER_PIXEL_LIGHTING\n                                      , constant scn_light*              scn_lights                  [[ buffer(3) ]]\n                                      , constant float4*                 u_shadowKernel\n                                      , texture2d_array<float>           u_areaLightBakedDataTexture\n#ifdef C3D_SUPPORT_CUBE_ARRAY\n                                      , texturecube_array<half>          u_reflectionProbeTexture\n#else\n                                      , texture2d_array<half>            u_reflectionProbeTexture\n#endif\n                                      , texture3d<ushort>                u_clusterTexture\n#ifdef C3D_USE_TEXTURE_FOR_LIGHT_INDICES\n                                      , texture1d<ushort>                u_lightIndicesTexture\n#else\n                                      , constant C3DLightIndexType*      u_lightIndicesBuffer\n#endif\n#endif\n#if defined(C3D_SUPPORTS_PROGRAMMABLE_BLENDING) && defined(USE_MODIFIER_FRAMEBUFFER_COLOR0)\n                                      , float4                           framebufferColor0           [[ color(0) ]]\n#endif\n#if USE_ARGUMENT_BUFFERS\n\n#define u_emissionTexture               scn_commonprofile.emissionTexture\n#define u_emissionTextureSampler        scn_commonprofile.emissionSampler\n#define u_ambientTexture                scn_commonprofile.ambientTexture\n#define u_ambientTextureSampler         scn_commonprofile.ambientSampler\n#define u_diffuseTexture                scn_commonprofile.diffuseTexture\n#define u_diffuseTextureSampler         scn_commonprofile.diffuseSampler\n#define u_specularTexture               scn_commonprofile.specularTexture\n#define u_specularTextureSampler        scn_commonprofile.specularSampler\n#define u_reflectiveTexture             scn_commonprofile.reflectiveTexture\n#define u_reflectiveTextureSampler      scn_commonprofile.reflectiveSampler\n#define u_transparentTexture            scn_commonprofile.transparentTexture\n#define u_transparentTextureSampler     scn_commonprofile.transparentSampler\n#define u_multiplyTexture               scn_commonprofile.multiplyTexture\n#define u_multiplyTextureSampler        scn_commonprofile.multiplySampler\n#define u_normalTexture                 scn_commonprofile.normalTexture\n#define u_normalTextureSampler          scn_commonprofile.normalSampler\n#define u_selfIlluminationTexture       scn_commonprofile.selfIlluminationTexture\n#define u_selfIlluminationTextureSampler scn_commonprofile.selfIlluminationSampler\n#define u_metalnessTexture              scn_commonprofile.metalnessTexture\n#define u_metalnessTextureSampler       scn_commonprofile.metalnessSampler\n#define u_roughnessTexture              scn_commonprofile.roughnessTexture\n#define u_roughnessTextureSampler       scn_commonprofile.roughnessSampler\n\n#else\n#ifdef USE_EMISSION_MAP\n                                      , texture2d<float>              u_emissionTexture\n                                      , sampler                       u_emissionTextureSampler\n#endif\n#ifdef USE_AMBIENT_MAP\n                                      , texture2d<float>              u_ambientTexture\n                                      , sampler                       u_ambientTextureSampler\n#endif\n#ifdef USE_DIFFUSE_MAP\n                                      , texture2d<float>              u_diffuseTexture\n                                      , sampler                       u_diffuseTextureSampler\n#endif\n#ifdef USE_SPECULAR_MAP\n                                      , texture2d<float>              u_specularTexture\n                                      , sampler                       u_specularTextureSampler\n#endif\n#ifdef USE_REFLECTIVE_MAP\n                                      , texture2d<float>              u_reflectiveTexture\n                                      , sampler                       u_reflectiveTextureSampler\n#elif defined(USE_REFLECTIVE_CUBEMAP)\n                                      , texturecube<float>            u_reflectiveTexture\n                                      , sampler                       u_reflectiveTextureSampler\n#endif\n#ifdef USE_TRANSPARENT_MAP\n                                      , texture2d<float>              u_transparentTexture\n                                      , sampler                       u_transparentTextureSampler\n#endif\n#ifdef USE_MULTIPLY_MAP\n                                      , texture2d<float>              u_multiplyTexture\n                                      , sampler                       u_multiplyTextureSampler\n#endif\n#ifdef USE_NORMAL_MAP\n                                      , texture2d<float>              u_normalTexture\n                                      , sampler                       u_normalTextureSampler\n#endif\n#ifdef USE_SELFILLUMINATION_MAP\n                                      , texture2d<float>              u_selfIlluminationTexture\n                                      , sampler                       u_selfIlluminationTextureSampler\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n                                      , texture2d<float>              u_displacementTexture\n                                      , sampler                       u_displacementTextureSampler\n#endif\n#ifdef USE_PBR\n#ifdef USE_METALNESS_MAP\n                                      , texture2d<float>              u_metalnessTexture\n                                      , sampler                       u_metalnessTextureSampler\n#endif\n#ifdef USE_ROUGHNESS_MAP\n                                      , texture2d<float>              u_roughnessTexture\n                                      , sampler                       u_roughnessTextureSampler\n#endif\n#ifdef USE_CLEARCOAT_MAP\n                                      , texture2d<float>              u_clearCoatTexture\n                                      , sampler                       u_clearCoatTextureSampler\n#endif\n#ifdef USE_CLEARCOATROUGHNESS_MAP\n                                      , texture2d<float>              u_clearCoatRoughnessTexture\n                                      , sampler                       u_clearCoatRoughnessTextureSampler\n#endif\n#ifdef USE_CLEARCOATNORMAL_MAP\n                                      , texture2d<float>              u_clearCoatNormalTexture\n                                      , sampler                       u_clearCoatNormalTextureSampler\n#endif\n#endif \n#endif \n#ifdef USE_PBR\n                                      , texturecube<float>            u_radianceTexture\n                                      , texture2d<float>              u_specularDFGDiffuseHammonTexture\n#if !defined(USE_SELFILLUMINATION_MAP)\n                                      , texturecube<float>            u_irradianceTexture\n#endif\n#endif \n#ifdef USE_SSAO\n                                      , texture2d<float>              u_ssaoTexture\n#endif\n#ifdef USE_FRAGMENT_EXTRA_ARGUMENTS\n                                      __FragmentExtraArguments__\n#endif\n#if defined(USE_DOUBLE_SIDED)\n                                      , bool                          isFrontFacing                    [[front_facing]]\n#endif\n#ifdef USE_POINT_RENDERING\n                                      , float2                        pointCoord                       [[point_coord]]\n#endif\n#ifdef USE_VERTEX_AMPLIFICATION\n                                      , ushort                        amplificationID                  [[amplification_id]]\n#endif\n                                      )\n{\n#ifdef USE_MULTIPLE_RENDERING\n    \n#ifdef USE_VERTEX_AMPLIFICATION\n    constant SCNSceneBuffer& scn_frame = scn_frame_multi[amplificationID];\n#else\n    constant SCNSceneBuffer& scn_frame = scn_frame_multi[in.sliceIndex];\n#endif\n    \n#ifdef USE_INSTANCING\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& scn_node = scn_nodes[USE_MULTIPLE_RENDERING * in.instanceID + amplificationID];\n#else\n    constant commonprofile_node& scn_node = scn_nodes[USE_MULTIPLE_RENDERING * in.instanceID + in.sliceIndex];\n#endif\n#else\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& scn_node = scn_nodes[amplificationID];\n#else\n    constant commonprofile_node& scn_node = scn_nodes[in.sliceIndex];\n#endif\n#endif\n    \n#else \n    \n#ifdef USE_INSTANCING\n    constant commonprofile_node& scn_node = scn_nodes[in.instanceID];\n#endif\n    \n#endif \n    \n    SCNOutput _output;\n\n    \n    \n    \n    \n    SCNShaderSurface _surface;\n#ifdef USE_TEXCOORD\n    __FragmentDoTexcoord__\n#endif\n    _surface.ambientOcclusion = 1.f; \n#ifdef USE_AMBIENT_MAP\n    #ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION\n        #if defined(USE_AMBIENT_TEXTURE_COMPONENT)\n            _surface.ambientOcclusion = colorFromMask(u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord), USE_AMBIENT_TEXTURE_COMPONENT).r;\n        #else\n            _surface.ambientOcclusion = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord).r;\n        #endif\n        #ifdef USE_AMBIENT_INTENSITY\n            _surface.ambientOcclusion = saturate(mix(1.f, _surface.ambientOcclusion, scn_commonprofile.ambientIntensity));\n        #endif\n    #else \n        _surface.ambient = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord);\n        #if defined(USE_AMBIENT_TEXTURE_COMPONENT)\n            _surface.ambient = colorFromMask(_surface.ambient, USE_AMBIENT_TEXTURE_COMPONENT);\n        #endif\n        #ifdef USE_AMBIENT_INTENSITY\n            _surface.ambient *= scn_commonprofile.ambientIntensity;\n        #endif\n    #endif \n#elif defined(USE_AMBIENT_COLOR)\n    _surface.ambient = scn_commonprofile.ambientColor;\n#elif defined(USE_AMBIENT)\n    _surface.ambient = float4(0.);\n#endif\n#if defined(USE_AMBIENT) && defined(USE_VERTEX_COLOR)\n    _surface.ambient *= in.vertexColor;\n#endif\n#if  defined(USE_SSAO)\n    _surface.ambientOcclusion *= u_ssaoTexture.sample( sampler(filter::linear), in.fragmentPosition.xy * scn_frame.inverseResolution.xy ).x;\n#endif\n    \n#ifdef USE_DIFFUSE_MAP\n    _surface.diffuse = u_diffuseTexture.sample(u_diffuseTextureSampler, _surface.diffuseTexcoord);\n#if defined(USE_DIFFUSE_TEXTURE_COMPONENT)\n    _surface.diffuse = colorFromMask(_surface.diffuse, USE_DIFFUSE_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_DIFFUSE_INTENSITY\n    _surface.diffuse.rgb *= scn_commonprofile.diffuseIntensity;\n#endif\n#elif defined(USE_DIFFUSE_COLOR)\n    _surface.diffuse = scn_commonprofile.diffuseColor;\n#else\n    _surface.diffuse = float4(0.f,0.f,0.f,1.f);\n#endif\n#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)\n    _surface.diffuse.rgb    *= in.vertexColor.rgb;\n    _surface.diffuse        *= in.vertexColor.a; \n#endif\n#ifdef USE_SPECULAR_MAP\n    _surface.specular = u_specularTexture.sample(u_specularTextureSampler, _surface.specularTexcoord);\n#if defined(USE_SPECULAR_TEXTURE_COMPONENT)\n    _surface.specular = colorFromMask(_surface.specular, USE_SPECULAR_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_SPECULAR_INTENSITY\n    _surface.specular *= scn_commonprofile.specularIntensity;\n#endif\n#elif defined(USE_SPECULAR_COLOR)\n    _surface.specular = scn_commonprofile.specularColor;\n#elif defined(USE_SPECULAR)\n    _surface.specular = float4(0.f);\n#endif\n    \n#ifdef USE_CLEARCOAT_MAP\n    _surface.clearCoat = u_clearCoatTexture.sample(u_clearCoatTextureSampler, _surface.clearCoatTexcoord).r;\n#if defined(USE_CLEARCOAT_TEXTURE_COMPONENT)\n    _surface.clearCoat = colorFromMask(_surface.clearCoat, USE_CLEARCOAT_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_CLEARCOAT_INTENSITY\n    _surface.clearCoat *= scn_commonprofile.clearCoatIntensity;\n#endif\n#elif defined(USE_CLEARCOAT_COLOR)\n    _surface.clearCoat = scn_commonprofile.clearCoat;\n#elif defined(USE_CLEARCOAT)\n    _surface.clearCoat = 0.f;\n#endif\n    \n#ifdef USE_CLEARCOATROUGHNESS_MAP\n#if defined(USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT)\n    _surface.clearCoatRoughness = colorFromMask(u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord), USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.clearCoatRoughness = u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord).r;\n#endif\n#ifdef USE_CLEARCOATROUGHNESS_INTENSITY\n    _surface.clearCoatRoughness *= scn_commonprofile.clearCoatRoughnessIntensity;\n#endif\n#elif defined(USE_CLEARCOATROUGHNESS_COLOR)\n    _surface.clearCoatRoughness = scn_commonprofile.clearCoatRoughness;\n#else\n    _surface.clearCoatRoughness = 0.03f;\n#endif\n \n#ifdef USE_EMISSION_MAP\n    _surface.emission = u_emissionTexture.sample(u_emissionTextureSampler, _surface.emissionTexcoord);\n#if defined(USE_EMISSION_TEXTURE_COMPONENT)\n    _surface.emission = colorFromMask(_surface.emission, USE_EMISSION_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_EMISSION_INTENSITY\n    _surface.emission *= scn_commonprofile.emissionIntensity;\n#endif\n#elif defined(USE_EMISSION_COLOR)\n    _surface.emission = scn_commonprofile.emissionColor;\n#elif defined(USE_EMISSION)\n    _surface.emission = float4(0.);\n#endif\n#ifdef USE_SELFILLUMINATION_MAP\n    _surface.selfIllumination = u_selfIlluminationTexture.sample(u_selfIlluminationTextureSampler, _surface.selfIlluminationTexcoord);\n#if defined(USE_SELFILLUMINATION_TEXTURE_COMPONENT)\n    _surface.selfIllumination = colorFromMask(_surface.selfIllumination, USE_SELFILLUMINATION_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_SELFILLUMINATION_INTENSITY\n    _surface.selfIllumination *= scn_commonprofile.selfIlluminationIntensity;\n#endif\n#elif defined(USE_SELFILLUMINATION_COLOR)\n    _surface.selfIllumination = scn_commonprofile.selfIlluminationColor;\n#elif defined(USE_SELFILLUMINATION)\n    _surface.selfIllumination = float4(0.);\n#endif\n#ifdef USE_MULTIPLY_MAP\n    _surface.multiply = u_multiplyTexture.sample(u_multiplyTextureSampler, _surface.multiplyTexcoord);\n#if defined(USE_MULTIPLY_TEXTURE_COMPONENT)\n    _surface.multiply = colorFromMask(_surface.multiply, USE_MULTIPLY_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_MULTIPLY_INTENSITY\n    _surface.multiply = mix(float4(1.), _surface.multiply, scn_commonprofile.multiplyIntensity);\n#endif\n#elif defined(USE_MULTIPLY_COLOR)\n    _surface.multiply = scn_commonprofile.multiplyColor;\n#elif defined(USE_MULTIPLY)\n    _surface.multiply = float4(1.);\n#endif\n#ifdef USE_TRANSPARENT_MAP\n    _surface.transparent = u_transparentTexture.sample(u_transparentTextureSampler, _surface.transparentTexcoord);\n#if defined(USE_TRANSPARENT_TEXTURE_COMPONENT)\n    _surface.transparent = colorFromMask(_surface.transparent, USE_TRANSPARENT_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_TRANSPARENT_INTENSITY\n    _surface.transparent *= scn_commonprofile.transparentIntensity;\n#endif\n#elif defined(USE_TRANSPARENT_COLOR)\n    _surface.transparent = scn_commonprofile.transparentColor;\n#elif defined(USE_TRANSPARENT)\n    _surface.transparent = float4(1.f);\n#endif\n    \n#ifdef USE_METALNESS_MAP\n#if defined(USE_METALNESS_TEXTURE_COMPONENT)\n    _surface.metalness = colorFromMask(u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord), USE_METALNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.metalness = u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord).r;\n#endif\n#ifdef USE_METALNESS_INTENSITY\n    _surface.metalness *= scn_commonprofile.metalnessIntensity;\n#endif\n#elif defined(USE_METALNESS_COLOR)\n    _surface.metalness = scn_commonprofile.metalness;\n#else\n    _surface.metalness = 0.f;\n#endif\n    \n#ifdef USE_ROUGHNESS_MAP\n#if defined(USE_ROUGHNESS_TEXTURE_COMPONENT)\n    _surface.roughness = colorFromMask(u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord), USE_ROUGHNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.roughness = u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord).r;\n#endif\n#ifdef USE_ROUGHNESS_INTENSITY\n    _surface.roughness *= scn_commonprofile.roughnessIntensity;\n#endif\n#elif defined(USE_ROUGHNESS_COLOR)\n    _surface.roughness = scn_commonprofile.roughness;\n#else\n    _surface.roughness = 0.f;\n#endif\n#if (defined USE_POSITION) && (USE_POSITION == 2)\n    _surface.position = in.position;\n#endif\n#if (defined USE_NORMAL) && (USE_NORMAL == 2)\n#if defined(HAS_NORMAL) || defined(USE_OPENSUBDIV)\n#ifdef USE_DOUBLE_SIDED\n    _surface.geometryNormal = normalize(in.normal.xyz) * (isFrontFacing ? 1.f : -1.f );\n#else\n    _surface.geometryNormal = normalize(in.normal.xyz);\n#endif\n#else \n    _surface.geometryNormal = normalize( cross(dfdy( _surface.position ), dfdx( _surface.position ) ));\n#endif\n    _surface.normal = _surface.geometryNormal;\n    _surface.clearCoatNormal = _surface.geometryNormal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    _surface.tangent = in.tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    _surface.bitangent = in.bitangent;\n#endif\n#if (defined USE_VIEW) && (USE_VIEW == 2)\n    _surface.view = normalize(-in.position);\n    {\n        \n        \n        float NoV = dot(_surface.geometryNormal, _surface.view);\n        _surface.view = _surface.view + max(0.f, -2.f * NoV) * _surface.geometryNormal;         \n        \n    }\n#endif\n#if defined(USE_NORMAL_MAP)\n    {\n        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.normal);\n#ifdef USE_NORMAL_MAP\n#if defined(USE_NORMAL_TEXTURE_COMPONENT)\n        _surface._normalTS.xy = colorFromMask(u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord), USE_NORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;\n        _surface._normalTS.z = sqrt(1.f - saturate(length_squared(_surface._normalTS.xy)));\n#else\n        _surface._normalTS = u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord).rgb;\n        _surface._normalTS = _surface._normalTS * 2.f - 1.f;\n#endif\n#ifdef USE_NORMAL_INTENSITY\n        _surface._normalTS = mix(float3(0.f, 0.f, 1.f), _surface._normalTS, scn_commonprofile.normalIntensity);\n#endif\n#else\n        _surface._normalTS = float3(0.f, 0.f, 1.f);\n#endif\n        _surface.normal.rgb = normalize(ts2vs * _surface._normalTS.xyz );\n    }\n#else\n    _surface._normalTS = float3(0.f, 0.f, 1.f);\n#endif\n#ifdef USE_PBR\n    {\n        float roughness = clamp(_surface.roughness, PBR_MIN_ROUGHNESS, 1.0);\n        float alpha = scn_filteredAlphaFromRoughness(_surface.normal, roughness);\n        _surface.roughness = sqrt(alpha);\n    }\n#endif\n#if defined(USE_CLEARCOATNORMAL_MAP)\n    {\n        \n        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.geometryNormal);\n#ifdef USE_CLEARCOATNORMAL_MAP\n#if defined(USE_CLEARCOATNORMAL_TEXTURE_COMPONENT)\n        _surface._clearCoatNormalTS.xy = colorFromMask(u_clearCoatNormalTexture.sample(u_clearCoatnormalTextureSampler, _surface.clearCoatNormalTexcoord), USE_CLEARCOATNORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;\n        _surface._clearCoatNormalTS.z = sqrt(1.f - saturate(length_squared(_surface._clearCoatNormalTS.xy)));\n#else\n        _surface._clearCoatNormalTS = u_clearCoatNormalTexture.sample(u_clearCoatNormalTextureSampler, _surface.clearCoatNormalTexcoord).rgb;\n        _surface._clearCoatNormalTS = _surface._clearCoatNormalTS * 2.f - 1.f;\n#endif\n#ifdef USE_CLEARCOATNORMAL_INTENSITY\n        _surface._clearCoatNormalTS = mix(float3(0.f, 0.f, 1.f), _surface._clearCoatNormalTS, scn_commonprofile.clearCoatNormalIntensity);\n#endif\n#else\n        _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);\n#endif\n        _surface.clearCoatNormal.rgb = normalize(ts2vs * _surface._clearCoatNormalTS.xyz );\n    }\n#else\n    _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);\n#endif\n    \n#ifdef USE_REFLECTIVE_MAP\n    float3 refl = reflect( -_surface.view, _surface.normal );\n    float m = 2.f * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.f)*(refl.z+1.f));\n    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, float2(float2(refl.x,-refl.y) / m) + 0.5f);\n#if defined(USE_REFLECTIVE_TEXTURE_COMPONENT)\n    _surface.reflective = colorFromMask(_surface.reflective, USE_REFLECTIVE_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_REFLECTIVE_INTENSITY\n    _surface.reflective *= scn_commonprofile.reflectiveIntensity;\n#endif\n#elif defined(USE_REFLECTIVE_CUBEMAP)\n    float3 refl = reflect( _surface.position, _surface.normal );\n    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, scn::mat4_mult_float3(scn_frame.viewToCubeTransform, refl)); \n#ifdef USE_REFLECTIVE_INTENSITY\n    _surface.reflective *= scn_commonprofile.reflectiveIntensity;\n#endif\n#elif defined(USE_REFLECTIVE_COLOR)\n    _surface.reflective = scn_commonprofile.reflectiveColor;\n#elif defined(USE_REFLECTIVE)\n    _surface.reflective = float4(0.);\n#endif\n#ifdef USE_FRESNEL\n    _surface.fresnel = scn_commonprofile.fresnel.x + scn_commonprofile.fresnel.y * pow(1.f - saturate(dot(_surface.view, _surface.normal)), scn_commonprofile.fresnel.z);\n    _surface.reflective *= _surface.fresnel;\n#endif\n#ifdef USE_SHININESS\n    _surface.shininess = scn_commonprofile.materialShininess;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_SURFACE_MODIFIER\n    \n    __DoSurfaceModifier__\n    \n#endif\n    \n    \n    \n    \n    \n    SCNShaderLightingContribution _lightingContribution(_surface, in);\n#ifdef USE_LIGHT_MODIFIER\n    __LightModifierCopyDecl__\n#endif\n#ifdef USE_AMBIENT_LIGHTING\n    _lightingContribution.ambient = scn_frame.ambientLightingColor.rgb;\n#endif\n#ifdef USE_LIGHTING\n#ifdef USE_PER_PIXEL_LIGHTING\n#ifdef USE_CLUSTERED_LIGHTING\n    uint3 clusterIndex;\n    clusterIndex.xy = uint2(in.fragmentPosition.xy * scn_frame.clusterScale.xy); \n    clusterIndex.z = in.position.z * scn_frame.clusterScale.z + scn_frame.clusterScale.w; \n    \n    \n    ushort4 cluster_offset_count = u_clusterTexture.read(clusterIndex);\n    int lid = cluster_offset_count.x;\n#endif\n\n#ifdef USE_PBR\n    _lightingContribution.prepareForPBR(u_specularDFGDiffuseHammonTexture, scn_commonprofile.selfIlluminationOcclusion);\n    \n    \n#ifdef USE_SELFILLUMINATION\n    _lightingContribution.add_irradiance_from_selfIllum();\n#else\n#ifdef USE_PROBES_LIGHTING \n    _lightingContribution.add_global_irradiance_from_sh(scn_frame.viewToCubeTransform, scn_node.shCoefficients);\n#else\n    _lightingContribution.add_global_irradiance_probe(u_irradianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);\n#endif\n#endif\n\n    \n#ifndef DISABLE_SPECULAR\n#ifdef C3D_USE_REFLECTION_PROBES\n    int probe_count = (cluster_offset_count.z & 0xff);\n    for (int i = 0 ; i < probe_count; ++i, ++lid) {\n        _lightingContribution.add_local_probe(scn_lights[LightIndex(lid)], u_reflectionProbeTexture);\n    }\n#if PROBES_NORMALIZATION\n#if PROBES_OUTER_BLENDING\n    _lightingContribution.specular += _lightingContribution.probesWeightedSum.rgb / max(1.f, _lightingContribution.probesWeightedSum.a);\n#else\n    _lightingContribution.specular += _lightingContribution.probesWeightedSum.rgb / _lightingContribution.probesWeightedSum.a;\n#endif\n    float globalFactor = saturate(1.f - _lightingContribution.probesWeightedSum.a);\n#else\n    float globalFactor = _lightingContribution.probeRadianceRemainingFactor;\n#endif\n    _lightingContribution.add_global_probe(scn_frame.viewToCubeTransform, globalFactor * scn_frame.environmentIntensity,\n                                           u_reflectionProbeTexture);\n#else \n   _lightingContribution.add_global_probe(u_radianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);\n    \n#ifdef USE_CLEARCOAT\n    _lightingContribution.add_global_probeClearCoat(u_radianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);\n#endif\n\n    \n#endif \n#endif \n\n#endif \n    #if DEBUG_PIXEL\n        switch (DEBUG_PIXEL) {\n            case 1: _output.color = float4(_surface.normal * 0.5f + 0.5f, 1.f); break;\n            case 2: _output.color = float4(_surface.geometryNormal * 0.5f + 0.5f, 1.f); break;\n            case 3: _output.color = float4(_surface.tangent * 0.5f + 0.5f, 1.f); break;\n            case 4: _output.color = float4(in.uv0, 0.f, 1.f); break;\n            case 5: _output.color = float4(_surface.diffuse.rgb, 1.f); break;\n            case 6: _output.color = float4(float3(_surface.roughness), 1.f); break;\n            case 7: _output.color = float4(float3(_surface.metalness), 1.f); break;\n            case 8: _output.color = float4(float3(_surface.ambientOcclusion), 1.f); break;\n            default: break;\n        }\n        return _output;\n    #endif\n    \n    __FragmentDoLighting__\n    \n    #ifdef USE_CLUSTERED_LIGHTING\n        \n        int omni_count = cluster_offset_count.y & 0xff;\n        for (int i = 0 ; i < omni_count; ++i, ++lid) {\n            _lightingContribution.add_local_omni(scn_lights[LightIndex(lid)]);\n        }\n\n        \n        int spot_count = (cluster_offset_count.y >> 8);\n        for (int i = 0 ; i < spot_count; ++i, ++lid) {\n            _lightingContribution.add_local_spot(scn_lights[LightIndex(lid)]);\n        }\n\n    #endif\n#else \n        _lightingContribution.diffuse = in.diffuse;\n    #ifdef USE_SPECULAR\n        _lightingContribution.specular = in.specular;\n    #endif\n#endif \n    #ifdef AVOID_OVERLIGHTING\n        _lightingContribution.diffuse = saturate(_lightingContribution.diffuse);\n    #ifdef USE_SPECULAR\n        _lightingContribution.specular = saturate(_lightingContribution.specular);\n    #endif \n    #endif \n#else \n    _lightingContribution.diffuse = float3(1.);\n#endif \n\n    \n    \n    \n    \n#ifdef USE_PBR\n    { \n        float3 diffuseAlbedo = mix(_lightingContribution.pbr.albedo, float3(0.0), _surface.metalness);\n        \n        \n        float3 color = (_lightingContribution.ambient * _surface.ambientOcclusion) * diffuseAlbedo;\n        \n        color += _lightingContribution.pbr.envDiffuse;\n        color += _lightingContribution.diffuse * diffuseAlbedo;\n#ifndef DISABLE_SPECULAR\n        color += _lightingContribution.pbr.envSpecular;\n        color += _lightingContribution.specular;\n#endif\n#ifdef USE_EMISSION\n        color += _surface.emission.rgb;\n#endif\n#ifdef USE_MULTIPLY\n        color *= _surface.multiply.rgb;\n#endif\n#ifdef USE_MODULATE\n        color *= _lightingContribution.modulate;\n#endif\n        _output.color.rgb = color;\n    }\n#else \n\n#ifdef USE_SHADOWONLY\n    _output.color.rgb = float3(0.0);\n    _output.color.a = 1. - _lightingContribution.shadowFactor;\n#else\n    _output.color.rgb = illuminate(_surface, _lightingContribution);\n#endif\n#endif\n\n#ifndef USE_SHADOWONLY\n  #ifdef USE_PBR_TRANSPARENCY\n    _output.color.a = _lightingContribution.pbr.transparency;\n  #else\n    _output.color.a = _surface.diffuse.a;\n  #endif\n#endif\n\n#ifdef USE_FOG\n    float fogFactor = pow(clamp(length(_surface.position.xyz) * scn_frame.fogParameters.x + scn_frame.fogParameters.y, 0., scn_frame.fogColor.a), scn_frame.fogParameters.z);\n    _output.color.rgb = mix(_output.color.rgb, scn_frame.fogColor.rgb * _output.color.a, fogFactor);\n#endif\n\n#if !defined(DIFFUSE_PREMULTIPLIED) && !defined(USE_PBR_TRANSPARENCY)\n    _output.color.rgb *= _surface.diffuse.a;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_SHADOWONLY\n    float transparencyFactor = 1.0;\n  #ifdef USE_NODE_OPACITY\n    transparencyFactor *= in.nodeOpacity;\n  #endif\n    _output.color.a *= transparencyFactor; \n\n#else \n\n#ifdef USE_TRANSPARENT \n    \n#ifdef USE_TRANSPARENCY\n    _surface.transparent *= scn_commonprofile.transparency;\n#endif\n    \n#ifdef USE_TRANSPARENCY_RGBZERO\n    \n    _surface.transparent.a = (_surface.transparent.r * 0.212671f) + (_surface.transparent.g * 0.715160f) + (_surface.transparent.b * 0.072169f);\n    _output.color *= (float4(1.f) - _surface.transparent);\n#else\n  #ifndef USE_PBR_TRANSPARENCY\n    _output.color *= _surface.transparent.a;\n  #endif\n#endif\n    \n#else \n    \n#ifdef USE_TRANSPARENCY \n  #ifndef USE_PBR_TRANSPARENCY\n    _output.color *= scn_commonprofile.transparency;\n  #endif\n#endif\n    \n#endif \n    \n#ifdef USE_NODE_OPACITY\n    _output.color *= in.nodeOpacity;\n#endif\n    \n#endif \n    \n    \n    \n    \n    \n#ifdef USE_MODIFIER_FRAMEBUFFER\n    const SCNFramebuffer _framebuffer = {\n#if defined(C3D_SUPPORTS_PROGRAMMABLE_BLENDING) && defined(USE_MODIFIER_FRAMEBUFFER_COLOR0)\n        .color = framebufferColor0\n#else\n        .color = 0.f\n#endif\n    };\n#endif\n    \n#ifdef USE_FRAGMENT_MODIFIER\n    \n    __DoFragmentModifier__\n    \n#endif\n#if defined(USE_CLUSTERED_LIGHTING) && defined(DEBUG_CLUSTER_TILE)\n    _output.color.rgb = mix(_output.color.rgb, float3(scn::debugColorForCount(clusterIndex.z).xyz), 0.1f);\n    _output.color.rgb = mix(_output.color.rgb, float3(clusterIndex.x & 0x1 ^ clusterIndex.y & 0x1).xyz, 0.01f);\n#endif\n#ifdef DISABLE_LINEAR_RENDERING\n    _output.color.rgb = scn::linear_to_srgb(_output.color.rgb);\n#endif\n    \n#ifdef USE_DISCARD\n    if (_output.color.a == 0.) \n        discard_fragment();\n#endif\n\n#ifdef USE_POINT_RENDERING\n    if ((dfdx(pointCoord.x) < 0.5f) && (length_squared(pointCoord * 2.f - 1.f) > 1.f)) {\n        discard_fragment();\n    }\n#endif\n    \n    \n#ifdef USE_OUTLINE\n    _output.color.rgb = in.outlineHash;\n#endif\n    \n\n#ifdef USE_MOTIONBLUR\n#ifdef USE_MULTIPLE_RENDERING\n    _output.motionblur.xy = half2((in.mv_fragment.xy - scn_frame.viewportSize.zw) / in.mv_fragment.z - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * scn_frame.motionBlurIntensity;\n#else\n    _output.motionblur.xy = half2((in.mv_fragment.xy / in.mv_fragment.z) - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * scn_frame.motionBlurIntensity;\n#endif\n    _output.motionblur.z = length(_output.motionblur.xy);\n    _output.motionblur.w = half(-_surface.position.z);\n#endif\n\n#ifdef USE_NORMALS_OUTPUT\n    _output.normals = half4( half3(_surface.normal.xyz), half(_surface.roughness) );\n#endif\n    \n#ifdef USE_RADIANCE_OUTPUT\n    _output.radiance.rgb = half3(_lightingContribution.specular.rgb);\n#endif\n                                 \n#ifdef USE_REFLECTANCE_ROUGHNESS_OUTPUT\n#ifdef USE_PBR\n    _output.reflectanceRoughnessOutput = half4( half3(_lightingContribution.pbr.probeReflectance), half(_surface.roughness) );\n#else \n    _output.reflectanceRoughnessOutput = half4( 0.h );\n#endif\n#endif\n    \n    return _output;\n}\n"
- "\nenum {\n    SCNDeformerAttributeSrcPosition,\n    SCNDeformerAttributeSrcNormal,\n    SCNDeformerAttributeSrcTangent,\n    \n    SCNDeformerAttributeDstPosition,\n    SCNDeformerAttributeDstNormal,\n    SCNDeformerAttributeDstTangent,\n};\n"
- "!D"
- "-[SCNGeometryWrapDeformerInstance_Sandwich initWithNode:drivingNode0:drivingNode1:deformer:outputs:computeVertexCount:context:]"
- "-[SCNGeometryWrapDeformerInstance_Simple initWithNode:drivingNode:deformer:outputs:computeVertexCount:context:]"
- "-[_SCNGeometryWrapDeformerParameters_Sandwich initWithCoder:]"
- "-[_SCNGeometryWrapDeformerParameters_Simple initWithCoder:]"
- "@120@0:8@16@24@32@40Q48{?=[4]}56"
- "Assertion '%s' failed. Can't encode SCNGeometryWrapDeformerParameters before it has computed its internal state"
- "Error: Extra layers can't be used with SCNGeometryWrapDeformerSandwichModeDriversUseDifferentFaceIndices"
- "SCNGeometryWrapDeformerInstance_Sandwich"
- "SCNGeometryWrapDeformerInstance_Simple"
- "Unreachable code: Deformer inconsistency error - SCNGeometryWrapDeformerParameters is a class cluster"
- "Unreachable code: Deformer inconsistency error - incompatible SCNGeometryWrapDeformerParameters subclass"
- "Unreachable code: Deformer inconsistency error - unknown SCNGeometryWrapDeformerParameters subclass"
- "Welcome to SceneKit 599 (Aug 11 2023 02:35:19)"
- "[2{?=\"pointIndices\"^v\"pointIndicesStride\"Q\"pointIndicesFormat\"Q\"barycentricCoords\"^v\"barycentricCoordsStride\"Q\"barycentricCoordsFormat\"Q}]"
- "[2{?=\"pointIndicesBuffer\"@\"<MTLBuffer>\"\"barycentricCoordsBuffer\"@\"<MTLBuffer>\"}]"
- "_SCNGeometryWrapDeformerParameters_Sandwich"
- "_SCNGeometryWrapDeformerParameters_Simple"
- "__bindToDriverMeshVertexIndicesUsingPosition_block_invoke"
- "__bindToDriverMeshVertexIndicesUsingUV_block_invoke"
- "__computeBindingPointIndicesAndBarycentricCoordsFromUVs"
- "_bindingBarycentricCoords"
- "_bindingBarycentricCoordsBuffer"
- "_bindingBarycentricCoordsFormat"
- "_bindingBarycentricCoordsStride"
- "_bindingBuffers"
- "_bindingDriver0Influences"
- "_bindingDriver0InfluencesBuffer"
- "_bindingDriver0InfluencesLength"
- "_bindingOffsetsOrTransforms"
- "_bindingOffsetsOrTransformsBuffer"
- "_bindingOffsetsOrTransformsLength"
- "_bindingPointIndices"
- "_bindingPointIndicesBuffer"
- "_bindingPointIndicesFormat"
- "_bindingPointIndicesStride"
- "_bindingTransformsBuffer"
- "_deformedNodeUVChannel"
- "_drivingNode"
- "_drivingNode0"
- "_drivingNode1"
- "_drivingNodeUVChannel"
- "_extraLayers"
- "_initForCreateSubclass"
- "_initParametersIfNeededForDifferentFaceIndicesWithDrivingNode0Ref:drivingNode1Ref:deformedNodeRef:"
- "_initParametersIfNeededForSharedFaceIndicesWithDrivingNode0Ref:drivingNode1Ref:extraLayerMeshes:deformedNodeRef:"
- "_lastUpdateFrameIndex"
- "_vertexCount != 0"
- "bindingBarycentricCoords0"
- "bindingBarycentricCoords1"
- "bindingBarycentricCoordsFormat0"
- "bindingBarycentricCoordsFormat1"
- "bindingBarycentricCoordsStride0"
- "bindingBarycentricCoordsStride1"
- "bindingDriver0Influences"
- "bindingDriver0InfluencesLength"
- "bindingPointIndices0"
- "bindingPointIndices1"
- "bindingPointIndicesFormat0"
- "bindingPointIndicesFormat1"
- "bindingPointIndicesStride0"
- "bindingPointIndicesStride1"
- "boneIndicesSInt16[i] < effectiveWeightCount"
- "currentFrameIndex"
- "decodedLength == _bindingDriver0InfluencesLength"
- "decodedLength == _bindingOffsetsOrTransformsLength"
- "deformer_wrap_offset"
- "deformer_wrap_sandwich_different_indices"
- "deformer_wrap_sandwich_shared_indices"
- "deformer_wrap_transform"
- "initParametersIfNeededWithDrivingNode0Ref:drivingNode1Ref:deformedNodeRef:"
- "initWithDriverSandwichNode0:driverSandwichNode1:deformedNode:mode:bindingTransform:"
- "initWithDriverSandwichNode0:driverSandwichNode1:extraLayers:deformedNode:mode:bindingTransform:"
- "initWithDriverSandwichNode0:driverSandwichNode1:parameters:"
- "kSceneSourceUSDAssumeLinearDisplayP3SourceColorSpace"
- "kSceneSourceUSDIgnoreVertexColors"
- "texcoordSource_deformed"
- "texcoordSource_driver"
- "v32@?0^v8^v16^B24"
- "v48@0:8^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}16^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}24@32^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}40"
- "{?=\"vertexCount\"I\"driver0ToDeformedTransform\"{?=\"columns\"[4]}\"driver1ToDeformedTransform\"{?=\"columns\"[4]}}"
- "{Cache=\"rasterizerStates\"^{__C3DRasterizerStates}\"mesh\"^{__C3DMesh}\"metalMesh\"@\"SCNMTLMesh\"\"meshElement\"^{__C3DMeshElement}\"metalMeshElement\"@\"SCNMTLMeshElement\"\"program\"^{__C3DFXMetalProgram}\"material\"^{__C3DMaterial}\"geometry\"^{__C3DGeometry}\"metalShadable\"@\"SCNMTLShadable\"\"commonProfile\"^{__C3DEffectCommonProfile}\"blendStates\"^{__C3DBlendStates}\"colorBufferWriteMask\"C\"primitiveTopologyClass\"C\"node\"^{__C3DNode}\"vertexDescriptorHash\"Q\"tessellationPipelineStateHash\"C\"renderPipeline\"@\"SCNMTLRenderPipeline\"}"
- "\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xc2"

```
