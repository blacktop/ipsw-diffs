## VFX

> `/System/Library/PrivateFrameworks/VFX.framework/VFX`

```diff

-203.0.21.0.0
-  __TEXT.__text: 0xd25e48
-  __TEXT.__auth_stubs: 0x6d60
-  __TEXT.__objc_methlist: 0x1d6bc
-  __TEXT.__const: 0x8d428
-  __TEXT.__gcc_except_tab: 0x6888
-  __TEXT.__cstring: 0xbba87
-  __TEXT.__oslogstring: 0x11b7e
+203.0.22.0.2
+  __TEXT.__text: 0xd2a308
+  __TEXT.__auth_stubs: 0x6d50
+  __TEXT.__objc_methlist: 0x1d744
+  __TEXT.__const: 0x8d468
+  __TEXT.__gcc_except_tab: 0x687c
+  __TEXT.__cstring: 0xbb9a7
+  __TEXT.__oslogstring: 0x11dd1
   __TEXT.__ustring: 0x22
-  __TEXT.__constg_swiftt: 0x27a1c
-  __TEXT.__swift5_typeref: 0xdcde
-  __TEXT.__swift5_fieldmd: 0x1d6d0
+  __TEXT.__constg_swiftt: 0x27a40
+  __TEXT.__swift5_typeref: 0xdcd2
+  __TEXT.__swift5_fieldmd: 0x1d6f4
   __TEXT.__swift5_builtin: 0x13d8
-  __TEXT.__swift5_reflstr: 0x13764
+  __TEXT.__swift5_reflstr: 0x137c4
   __TEXT.__swift5_assocty: 0x3ac0
   __TEXT.__swift5_proto: 0x6f14
   __TEXT.__swift5_types: 0x24c0
-  __TEXT.__swift5_capture: 0x11648
+  __TEXT.__swift5_capture: 0x116b8
   __TEXT.__swift5_mpenum: 0x27c
   __TEXT.__swift5_protos: 0x1f4
   __TEXT.__swift5_types2: 0x8
   __TEXT.__swift_as_entry: 0x68
   __TEXT.__swift_as_ret: 0x78
-  __TEXT.__unwind_info: 0x280c8
-  __TEXT.__eh_frame: 0x2dab0
-  __TEXT.__objc_classname: 0x210d
-  __TEXT.__objc_methname: 0x2c81c
-  __TEXT.__objc_methtype: 0x158b4
-  __TEXT.__objc_stubs: 0x20e20
+  __TEXT.__unwind_info: 0x280e0
+  __TEXT.__eh_frame: 0x2db58
+  __TEXT.__objc_classname: 0x210f
+  __TEXT.__objc_methname: 0x2c9bb
+  __TEXT.__objc_methtype: 0x15959
+  __TEXT.__objc_stubs: 0x20ee0
   __DATA_CONST.__got: 0x1e58
   __DATA_CONST.__const: 0x7158
   __DATA_CONST.__objc_classlist: 0x1fe0
   __DATA_CONST.__objc_catlist: 0xb8
   __DATA_CONST.__objc_protolist: 0x600
   __DATA_CONST.__objc_imageinfo: 0x8
-  __DATA_CONST.__objc_selrefs: 0xbdc0
+  __DATA_CONST.__objc_selrefs: 0xbe18
   __DATA_CONST.__objc_protorefs: 0x380
   __DATA_CONST.__objc_superrefs: 0x660
   __DATA_CONST.__objc_arraydata: 0x368
-  __AUTH_CONST.__auth_got: 0x36c8
-  __AUTH_CONST.__const: 0x8c8a0
-  __AUTH_CONST.__cfstring: 0x194c0
-  __AUTH_CONST.__objc_const: 0x47f70
+  __AUTH_CONST.__auth_got: 0x36c0
+  __AUTH_CONST.__const: 0x8c950
+  __AUTH_CONST.__cfstring: 0x19540
+  __AUTH_CONST.__objc_const: 0x47fe8
   __AUTH_CONST.__objc_intobj: 0x570
   __AUTH_CONST.__objc_arrayobj: 0x108
   __AUTH_CONST.__objc_floatobj: 0x10
   __AUTH_CONST.__objc_doubleobj: 0x10
   __AUTH_CONST.__objc_dictobj: 0xf0
-  __AUTH.__objc_data: 0xc468
+  __AUTH.__objc_data: 0xc4c8
   __AUTH.__data: 0x36570
   __AUTH.__thread_vars: 0x90
   __AUTH.__thread_data: 0x8
   __AUTH.__thread_bss: 0x20
-  __DATA.__objc_ivar: 0x1d30
-  __DATA.__data: 0x13ac8
-  __DATA.__bss: 0x7c010
-  __DATA.__common: 0xf89
+  __DATA.__objc_ivar: 0x1d38
+  __DATA.__data: 0x13ab8
+  __DATA.__bss: 0x7c000
+  __DATA.__common: 0xfb9
   __DATA_DIRTY.__objc_data: 0x3fb0
-  __DATA_DIRTY.__data: 0x10e50
-  __DATA_DIRTY.__bss: 0xbbe9
+  __DATA_DIRTY.__data: 0x10e80
+  __DATA_DIRTY.__bss: 0xbbd9
   __DATA_DIRTY.__common: 0x618
   - /System/Library/Frameworks/AVFAudio.framework/AVFAudio
   - /System/Library/Frameworks/AVFoundation.framework/AVFoundation

   - /usr/lib/swift/libswift_StringProcessing.dylib
   - /usr/lib/swift/libswiftos.dylib
   - /usr/lib/swift/libswiftsimd.dylib
-  UUID: FE7F91A3-B3BD-3EF5-9947-BD66B7B2A18B
-  Functions: 65782
+  UUID: 041FE6FA-A36B-376C-871E-60B9B427F83D
+  Functions: 65809
   Symbols:   2597
-  CStrings:  24915
+  CStrings:  24948
 
CStrings:
+ "\t_lightingContribution.add_directional_cascaded_shadows(vfx_lights[%@], %s, %d, %s, u_shadowKernel, %d, %s);\n"
+ "\t_lightingContribution.add_directional_gobo(vfx_lights[%@], u_goboTexture%d, u_goboTexture%dSampler);\n"
+ "\t_lightingContribution.add_directional_hard_shadows(vfx_lights[%@], %s);\n"
+ "\t_lightingContribution.add_directional_pcf_grid_shadows(vfx_lights[%@], %s, %d);\n"
+ "\t_lightingContribution.add_directional_soft_shadows(vfx_lights[%@], %s, u_shadowKernel, %d);\n"
+ "\t_lightingContribution.add_ies_soft_shadows(vfx_lights[%@], u_iesTexture%d, %s, u_shadowKernel, %d);\n"
+ "\t_lightingContribution.add_omni_soft_shadows(vfx_lights[%@], %s, u_shadowKernel, %d);\n"
+ "\t_lightingContribution.add_spot_gobo(vfx_lights[%@], u_goboTexture%d, u_goboTexture%dSampler);\n"
+ "\t_lightingContribution.add_spot_gobo_soft_shadows(vfx_lights[%@], u_shadowTexture%d, u_shadowKernel, %d, u_goboTexture%d, u_goboTexture%dSampler);\n"
+ "\t_lightingContribution.add_spot_soft_shadows(vfx_lights[%@], %s, u_shadowKernel, %d);\n"
+ "\n#pragma mark - Includes begin\n\n#import <metal_stdlib>\n\nusing namespace metal;\n\n#import \"vfx_metal\"\n#import \"vfx_util.h\"\n#import \"CFX-PBR.metal\"\n\n#ifdef USE_RE_SYSTEM_TREATMENTS\n#import \"vfx_re_shaders.h\"\n#import \"vfx_re_shaders_internal.h\"\n#import \"vfx_render_options.h\"\n#import \"vfx_shader_api_v2.h\"\n#endif \n\n#pragma mark - Includes end\n\n#pragma mark - Namespace Begin\n\n\n#import \"vfx_shadowmap_util.h\"\n#import \"vfx_tessellation.h\"\n\n\n\n\n#ifdef USE_LAYERED_RENDERING\n#define texture2d_layer texture2d_array\n#define sampleLayer(a,b) sample(a,b,in.sliceIndex)\n#else\n#define texture2d_layer texture2d\n#define sampleLayer(a,b) sample(a,b)\n#endif\n\n#ifdef CFX_USE_TEXTURE_FOR_LIGHT_INDICES\n#define LightIndex(lid) u_lightIndicesTexture.read((ushort)lid).x\n#else\n#define LightIndex(lid) u_lightIndicesBuffer[lid]\n#endif\n\n#ifdef IS_BEZIER_CURVE\n[[visible]] bool vfx_is_inside_bezier_curve(float2 p, device void const* curveData, device packed_float3 const* controlPoints);\n[[visible]] float vfx_distance_to_bezier_curve(float2 p, thread float2& directionToCurve, float maximumDistance, device void const* curveData, device packed_float3 const* controlPoints);\n#endif\n\n#ifdef USE_GBUFFER_OUTPUT\n    #undef USE_PER_VERTEX_LIGHTING\n    #undef USE_PER_PIXEL_LIGHTING\n    #undef USE_LIGHTING\n#endif\n\n\n\ntypedef struct {\n\n#ifdef USE_MODELTRANSFORM\n    float4x4 modelTransform;\n#endif\n#ifdef USE_INVERSEMODELTRANSFORM\n    float4x4 inverseModelTransform;\n#endif\n#ifdef USE_MODELVIEWTRANSFORM\n    float4x4 modelViewTransform;\n#endif\n#ifdef USE_INVERSEMODELVIEWTRANSFORM\n    float4x4 inverseModelViewTransform;\n#endif\n#ifdef USE_NORMALTRANSFORM\n    float4x4 normalTransform;\n#endif\n#ifdef USE_INVERSEMODELVIEWPROJECTIONTRANSFORM\n    float4x4 inverseModelViewProjectionTransform;\n#endif\n#ifdef USE_MODELVIEWPROJECTIONTRANSFORM\n    float4x4 modelViewProjectionTransform;\n#endif\n#ifdef USE_LASTFRAMETRANSFORM\n    float4x4 lastFrameModelTransform;\n#endif\n#ifdef USE_MOTIONBLUR\n    float motionBlurIntensity;\n#endif\n#ifdef USE_BOUNDINGBOX\n    float2x3 boundingBox;\n#endif\n#ifdef USE_WORLDBOUNDINGBOX\n    float2x3 worldBoundingBox;\n#endif\n#ifdef USE_NODE_OPACITY\n    float nodeOpacity;\n#endif\n#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)\n    sh2_coefficients shCoefficients;\n#elif defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 3)\n    sh3_coefficients shCoefficients;\n#endif\n#ifdef USE_CLUSTERED_LIGHTING\n    uint8_t categoryBitmask;\n#endif\n} commonprofile_node;\n\ntypedef struct {\n    float3 position         [[attribute(VFXVertexSemanticPosition)]];\n#ifdef HAS_NORMAL\n    float3 normal           [[attribute(VFXVertexSemanticNormal)]];\n#endif\n#ifdef USE_TANGENT\n    float4 tangent          [[attribute(VFXVertexSemanticTangent)]];\n#endif\n#ifdef USE_VERTEX_COLOR\n    float4 color            [[attribute(VFXVertexSemanticColor)]];\n#endif\n#if defined(NEED_IN_TEXCOORD0) || defined(DEBUG_PIXEL)\n    float2 texcoord0        [[attribute(VFXVertexSemanticTexcoord0)]];\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    float2 texcoord1        [[attribute(VFXVertexSemanticTexcoord1)]];\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    float2 texcoord2        [[attribute(VFXVertexSemanticTexcoord2)]];\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    float2 texcoord3        [[attribute(VFXVertexSemanticTexcoord3)]];\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    float2 texcoord4        [[attribute(VFXVertexSemanticTexcoord4)]];\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    float2 texcoord5        [[attribute(VFXVertexSemanticTexcoord5)]];\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    float2 texcoord6        [[attribute(VFXVertexSemanticTexcoord6)]];\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    float2 texcoord7        [[attribute(VFXVertexSemanticTexcoord7)]];\n#endif\n} vfx_vertex_t; \n\ntypedef struct {\n    float4 fragmentPosition [[position]]; \n#ifdef USE_POINT_RENDERING\n    float fragmentSize [[point_size]];\n#endif\n#ifdef USE_VERTEX_COLOR\n    float4 vertexColor;\n#endif\n#ifdef USE_PER_VERTEX_LIGHTING\n    float3 diffuse;\n#ifdef USE_SPECULAR\n    float3 specular;\n#endif\n#ifdef USE_CLEARCOAT\n    float clearCoat;\n#endif\n#ifdef USE_CLEARCOATROUGHNESS\n    float clearCoatRoughness;\n#endif\n#ifdef USE_CLEARCOATNORMAL\n    float clearCoatNormal;\n#endif\n#endif\n#if defined(USE_POSITION) && (USE_POSITION == 2)\n    float3 position;\n#endif\n#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)\n    float3 normal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    float3 tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    float3 bitangent;\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n    float2 displacementTexcoord;   \n#endif\n#ifdef USE_CLEARCOAT_MAP\n    float2 clearCoatTexcoord;   \n#endif\n#ifdef USE_CLEARCOATROUGHNESS_MAP\n    float2 clearCoatRoughnessTexcoord;   \n#endif\n#ifdef USE_CLEARCOATNORMAL_MAP\n    float2 clearCoatNormalTexcoord;   \n#endif\n#ifdef USE_NODE_OPACITY\n    float nodeOpacity;\n#endif\n#ifdef USE_TEXCOORD\n    __TexcoordDecl__\n#endif\n    \n#ifdef USE_EXTRA_VARYINGS\n    __ExtraVaryingsDecl__\n#endif\n#ifdef USE_LASTFRAMETRANSFORM\n    float3 mv_lastFragment;\n    float3 mv_fragment;\n#endif\n#ifdef USE_OUTLINE\n    float outlineHash [[ flat ]];\n#endif\n#ifdef USE_INSTANCING\n    uint   instanceID [[ flat ]];\n#endif\n#ifndef USE_VERTEX_AMPLIFICATION \n#ifdef USE_LAYERED_RENDERING\n    uint   sliceIndex [[render_target_array_index]];\n#endif\n#ifdef USE_MULTIPLE_VIEWPORTS_RENDERING\n    uint   sliceIndex [[viewport_array_index]];\n#endif\n#endif\n#if DEBUG_PIXEL\n    float2 uv0;\n#endif\n#if USE_SCREEN_UV\n    float2 screen_uv [[ center_no_perspective ]];\n#endif\n#ifdef USE_CR_WORLD_POSITION\n    float3 crworldPosition;\n#endif\n} commonprofile_io;\n\n\n#ifdef USE_SHADER_MODIFIERS\n__ShaderModifiersDecl__\n#endif\n\n\n#import \"CFX-Lighting.metal\"\n\nenum CFXColorMask {\n    kCFXColorMaskRed    = 0x1 << 3,\n    kCFXColorMaskGreen  = 0x1 << 2,\n    kCFXColorMaskBlue   = 0x1 << 1,\n    kCFXColorMaskAlpha  = 0x1 << 0\n};\n\ninline float4 colorFromMask(float4 col, int mask)\n{\n    switch (mask) {\n\n        case kCFXColorMaskRed:                      return col.r;\n        case kCFXColorMaskRed|kCFXColorMaskGreen:   return float4(col.rg, 0.f, 1.f);\n        case kCFXColorMaskRed|kCFXColorMaskBlue:    return float4(col.rb, 0.f, 1.f);\n        case kCFXColorMaskRed|kCFXColorMaskAlpha:   return float4(col.ra, 0.f, 1.f);\n\n        case kCFXColorMaskGreen:                    return col.g;\n        case kCFXColorMaskGreen|kCFXColorMaskBlue:  return float4(col.bg, 0.f, 1.f);\n        case kCFXColorMaskGreen|kCFXColorMaskAlpha: return float4(col.ag, 0.f, 1.f);\n\n        case kCFXColorMaskBlue:     return col.b;\n        case kCFXColorMaskBlue|kCFXColorMaskAlpha:  return float4(col.ab, 0.f, 1.f);\n\n        case kCFXColorMaskAlpha:    return col.a;\n    }\n    return col;\n}\n\n#ifndef USE_PBR\n\ninline float3 illuminate(VFXShaderSurface surface, VFXShaderLightingContribution lighting)\n{\n    float3 albedo = surface.diffuse.rgb * surface.ambientOcclusion;\n    float3 color = lighting.diffuse * albedo;\n#if defined(USE_AMBIENT_LIGHTING)\n    color +=  lighting.ambient * albedo;\n#endif\n#ifdef USE_SELFILLUMINATION\n    color += surface.diffuse.rgb * surface.selfIllumination.rgb;\n#endif\n    \n    \n    \n#ifdef USE_SPECULAR\n    float3 S = lighting.specular;\n#elif defined(USE_REFLECTIVE)\n    float3 S = float3(0.);\n#endif\n#ifdef USE_REFLECTIVE\n    S += surface.reflective.rgb * surface.ambientOcclusion;\n#endif\n#ifdef USE_SPECULAR\n    S *= surface.specular.rgb;\n#endif\n#if (defined(USE_SPECULAR) || defined(USE_REFLECTIVE)) && !defined(DISABLE_SPECULAR)\n    color += S;\n#endif\n#ifdef USE_EMISSION\n    color += surface.emission.rgb;\n#endif\n#ifdef USE_MULTIPLY\n    color *= surface.multiply.rgb;\n#endif\n#ifdef USE_MODULATE\n    color *= lighting.modulate;\n#endif\n    return color;\n}\n#endif\n\nstruct VFXShaderGeometry\n{\n    float4 position;\n    float3 normal;\n    float4 tangent;\n    float4 color;\n    float pointSize;\n    float2 texcoords[8]; \n#ifdef USE_CLIP_DISTANCE0\n    float clipDistance0;\n#endif\n#ifdef USE_CLIP_DISTANCE1\n    float clipDistance1;\n#endif\n#ifdef USE_CLIP_DISTANCE2\n    float clipDistance2;\n#endif\n#ifdef USE_CLIP_DISTANCE3\n    float clipDistance3;\n#endif\n};\n\nstruct commonprofile_uniforms {\n    \n    float4 diffuseColor;\n    float4 specularColor;\n    float4 ambientOcclusionColor;\n    float4 emissionColor;\n    float4 selfIlluminationColor;\n    float4 reflectiveColor;\n    float4 multiplyColor;\n    float4 transparentColor;\n    float clearCoat;\n    float clearCoatRoughness;\n    float3 clearCoatNormal;\n    float subsurface;\n    float4 subsurfaceRadius;\n    float transmission;\n    float4 transmissionColor;\n    float indexOfRefraction;\n    float metalness;\n    \n    float roughness;\n    float diffuseIntensity;\n    float specularIntensity;\n    float normalIntensity;\n    float ambientOcclusionIntensity;\n    float emissionIntensity;\n    float selfIlluminationIntensity;\n    float reflectiveIntensity;\n    float multiplyIntensity;\n    float transparentIntensity;\n    \n    float metalnessIntensity;\n    float roughnessIntensity;\n    float clearCoatIntensity;\n    float clearCoatRoughnessIntensity;\n    float clearCoatNormalIntensity;\n    float subsurfaceIntensity;\n    float subsurfaceRadiusIntensity;\n    float transmissionIntensity;\n    float transmissionColorIntensity;\n    float displacementIntensity;\n    float materialShininess;\n    float selfIlluminationOcclusion;\n    float alphaCutoff;\n    float3 fresnel; \n    \n#if USE_ARGUMENT_BUFFERS\n    texture2d<float>    emissionTexture;\n    sampler             emissionSampler;\n    texture2d<float>    ambientOcclusionTexture;\n    sampler             ambientOcclusionSampler;\n    texture2d<float>    diffuseTexture;\n    sampler             diffuseSampler;\n    texture2d<float>    specularTexture;\n    sampler             specularSampler;\n#if defined(USE_REFLECTIVE_CUBEMAP)\n    texturecube<float>  reflectiveTexture;\n#else\n    texture2d<float>    reflectiveTexture;\n#endif\n    sampler             reflectiveSampler;\n    texture2d<float>    transparentTexture;\n    sampler             transparentSampler;\n    texture2d<float>    multiplyTexture;\n    sampler             multiplySampler;\n    texture2d<float>    normalTexture;\n    sampler             normalSampler;\n    texture2d<float>    selfIlluminationTexture;\n    sampler             selfIlluminationSampler;\n    texture2d<float>    metalnessTexture;\n    sampler             metalnessSampler;\n    texture2d<float>    roughnessTexture;\n    sampler             roughnessSampler;\n    texture2d<float>    displacementTexture;\n    sampler             displacementSampler;\n    \n#endif \n#ifdef TEXTURE_TRANSFORM_COUNT\n    float4x4 textureTransforms[TEXTURE_TRANSFORM_COUNT];\n#endif\n};\n\n#ifdef USE_OPENSUBDIV\n\n__OpenSubdivDeclPerGeometry__\n__OpenSubdivDeclPerPatchType__\n__OpenSubdivDeclShared__\n\nstruct osd_packed_vertex {\n    packed_float3 position;\n#if defined(OSD_USER_VARYING_DECLARE_PACKED)\n    OSD_USER_VARYING_DECLARE_PACKED\n#endif\n};\n\n#endif\n\n\n#ifdef USE_DISPLACEMENT_MAP\nstatic void applyDisplacement(texture2d<float>                 displacementTexture,\n                              sampler                          displacementTextureSampler,\n                              float2                           displacementTexcoord,\n                              thread VFXShaderGeometry&        geometry,\n                              constant commonprofile_uniforms& vfx_commonprofile)\n{\n#ifdef USE_DISPLACEMENT_TEXTURE_COMPONENT\n\tfloat altitude = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n#ifdef USE_DISPLACEMENT_INTENSITY\n\taltitude *= vfx_commonprofile.displacementIntensity;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n\tfloat3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));\n\tgeometry.position.xyz += geometry.normal * altitude;\n\t\n\tfloat3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);\n\tfloat3 h;\n\th.x = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\th.y = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\th.z = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord-offset.zy), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\t\n#ifdef USE_DISPLACEMENT_INTENSITY\n\th *= vfx_commonprofile.displacementIntensity;\n#endif\n\t\n\tfloat3 n = normalize( float3( (h.x - h.y)/offset.x, 1., (h.x - h.z)/offset.y) );\n\tgeometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;\n\tgeometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));\n#endif \n#else \n\tfloat3 displacement = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;\n#ifdef USE_DISPLACEMENT_INTENSITY\n\tdisplacement *= vfx_commonprofile.displacementIntensity;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n\tfloat3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));\n\tgeometry.position.xyz += geometry.tangent.xyz * displacement.x + geometry.normal.xyz * displacement.y + bitangent.xyz * displacement.z;\n\t\n\tfloat3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);\n\tfloat3 a = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;\n\tfloat3 b = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz).rgb;\n\tfloat3 c = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.zy).rgb;\n\t\n#ifdef USE_DISPLACEMENT_INTENSITY\n\ta *= vfx_commonprofile.displacementIntensity;\n\tb *= vfx_commonprofile.displacementIntensity;\n\tc *= vfx_commonprofile.displacementIntensity;\n#endif\n\t\n\tb += offset.xzz;\n\tc -= offset.zzy;\n\tfloat3 n = (normalize( cross( b-a, c-a ) ));\n\tgeometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;\n\tgeometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));\n#endif \n#endif \n}\n#endif \n\n#ifdef USE_OUTLINE\nstatic inline float hash(float2 p)\n{\n    const float2 kMod2 = float2(443.8975f, 397.2973f);\n    p  = fract(p * kMod2);\n    p += dot(p.xy, p.yx+19.19f);\n    return fract(p.x * p.y);\n}\n#endif\n    \n\n\n\n\n#if defined(USE_TESSELLATION)\nstruct vfx_patch_t {\n    patch_control_point<vfx_vertex_t> controlPoints;\n};\n#endif\n\n#if defined(USE_OPENSUBDIV)\n#if OSD_IS_ADAPTIVE\n[[ patch(quad, VERTEX_CONTROL_POINTS_PER_PATCH) ]]\n#endif\n#elif defined(USE_TESSELLATION)\n[[ patch(triangle, 3) ]]\n#endif\n    \n    \nvertex commonprofile_io commonprofile_vert(\n#if !defined(USE_TESSELLATION)\n                                           vfx_vertex_t                       in                               [[ stage_in ]]\n                                           , uint                             vfx_vertexID                     [[ vertex_id ]]\n#else \n                                           \n#ifdef USE_OPENSUBDIV\n#if OSD_IS_ADAPTIVE\n#if USE_STAGE_IN\n                                           PatchInput                         patchInput                       [[ stage_in ]]\n#else\n                                           OsdVertexBufferSet                 patchInput\n#endif\n                                           , float2                           patchCoord                       [[ position_in_patch ]]\n                                           , uint                             patchID                          [[ patch_id ]]\n                                           , constant float&                  osdTessellationLevel             [[ buffer(TESSELLATION_LEVEL_BUFFER_INDEX) ]]\n#else \n                                           constant unsigned*                 osdIndicesBuffer                 [[ buffer(INDICES_BUFFER_INDEX) ]]\n                                           , constant osd_packed_vertex*      osdVertexBuffer                  [[ buffer(VERTEX_BUFFER_INDEX) ]]\n                                           , uint                             vertexID                         [[ vertex_id ]]\n#endif \n#if defined(OSD_FVAR_WIDTH)\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n                                           , constant uint32_t&               osdFaceVaryingChannelCount       [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_COUNT_INDEX) ]]\n                                           , constant OsdFVarChannelDesc*     osdFaceVaryingChannelDescriptors [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_DESCRIPTORS_INDEX) ]]\n                                           , constant uint32_t&               osdFaceVaryingPatchArrayIndex    [[ buffer(OSD_FVAR_CHANNELS_PATCH_ARRAY_INDEX_BUFFER_INDEX) ]]\n                                           , constant void*                   osdFaceVaryingChannelsPackedData [[ buffer(OSD_FVAR_CHANNELS_PACKED_DATA_BUFFER_INDEX) ]]\n#else\n                                           , constant float*                  osdFaceVaryingData               [[ buffer(OSD_FVAR_DATA_BUFFER_INDEX) ]]\n                                           , constant int*                    osdFaceVaryingIndices            [[ buffer(OSD_FVAR_INDICES_BUFFER_INDEX) ]]\n#if OSD_IS_ADAPTIVE\n                                           , constant packed_int3*            osdFaceVaryingPatchParams        [[ buffer(OSD_FVAR_PATCHPARAM_BUFFER_INDEX) ]]\n                                           , constant packed_int4&            osdFaceVaryingPatchArray         [[ buffer(OSD_FVAR_PATCH_ARRAY_BUFFER_INDEX) ]]\n#endif\n#endif \n#endif \n#else \n                                           vfx_patch_t                        in                               [[ stage_in ]]\n                                           , float3                           patchCoord                       [[ position_in_patch ]]\n#endif \n#endif \n                                           \n#ifdef USE_MULTIPLE_RENDERING\n                                           , constant VFXWorldBuffer*         vfx_frame_multi                  [[ buffer(0) ]]\n#else\n                                           , constant VFXWorldBuffer&         vfx_frame                        [[ buffer(0) ]]\n#endif\n#if defined(USE_INSTANCING) || defined(USE_MULTIPLE_RENDERING)\n                                           , constant commonprofile_node*     vfx_nodes_in                     [[ buffer(1) ]]\n#else\n                                           , constant commonprofile_node&     vfx_node_in                      [[ buffer(1) ]]\n#endif\n#ifdef USE_PER_VERTEX_LIGHTING\n                                           , constant vfx_light*              vfx_lights                       [[ buffer(2) ]]\n                                           , constant float4*                 u_shadowKernel\n                                           , texture2d_array<float>           u_areaLightBakedDataTexture\n#endif\n                                           \n                                           , constant commonprofile_uniforms& vfx_commonprofile\n#ifdef USE_RE_SYSTEM_TREATMENTS\n                                           , constant GlobalConstants&        u_re_globalConstants\n#endif\n#ifdef USE_INSTANCING\n                                           , uint                             vfx_instanceID                   [[ instance_id ]]\n#endif\n#ifdef USE_VERTEX_AMPLIFICATION\n                                           , ushort                           amplificationID                  [[ amplification_id ]]\n#endif\n\n#ifdef USE_POINT_RENDERING\n                                           \n                                           , constant float3&                 vfx_pointSize\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n#if USE_ARGUMENT_BUFFERS\n#define u_displacementTexture           vfx_commonprofile.displacementTexture\n#define u_displacementTextureSampler    vfx_commonprofile.displacementSampler\n#else\n                                           , texture2d<float>                 u_displacementTexture\n                                           , sampler                          u_displacementTextureSampler\n#endif \n#endif \n#ifdef USE_VERTEX_EXTRA_ARGUMENTS\n                                           __VertexExtraArguments__\n#endif\n                                           )\n{\n    commonprofile_io out;\n    \n#ifdef USE_MULTIPLE_RENDERING\n\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant VFXWorldBuffer& vfx_frame = vfx_frame_multi[amplificationID];\n#else\n    out.instanceID = vfx_instanceID / USE_MULTIPLE_RENDERING;\n    out.sliceIndex = vfx_instanceID % USE_MULTIPLE_RENDERING;\n    constant VFXWorldBuffer& vfx_frame = vfx_frame_multi[out.sliceIndex];\n#endif\n    \n#ifdef USE_INSTANCING\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& vfx_node_in = vfx_nodes_in[USE_MULTIPLE_RENDERING * vfx_instanceID + amplificationID];\n#else\n    \n    \n    constant commonprofile_node& vfx_node_in = vfx_nodes_in[vfx_instanceID];\n#endif\n#else\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& vfx_node_in = vfx_nodes_in[amplificationID];\n#else\n    constant commonprofile_node& vfx_node_in = vfx_nodes_in[out.sliceIndex];\n#endif\n#endif\n    \n#else \n    \n#ifdef USE_INSTANCING\n    out.instanceID = vfx_instanceID;\n    constant commonprofile_node& vfx_node_in = vfx_nodes_in[vfx_instanceID];\n#endif\n    \n#endif \n    \n    commonprofile_node vfx_node = vfx_node_in;\n    \n#ifdef USE_TESSELLATION\n    uint vfx_vertexID; \n    vfx_vertexID = 0;\n#endif\n    \n    \n    \n    \n    \n    VFXShaderGeometry _geometry;\n    \n#if !defined(USE_TESSELLATION)\n    \n    \n    _geometry.position = float4(in.position, 1.f);\n#if defined(USE_NORMAL) && defined(HAS_NORMAL)\n    _geometry.normal = in.normal;\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = in.tangent;\n#endif\n#if defined(NEED_IN_TEXCOORD0) || defined(DEBUG_PIXEL)\n    _geometry.texcoords[0] = in.texcoord0;\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    _geometry.texcoords[1] = in.texcoord1;\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    _geometry.texcoords[2] = in.texcoord2;\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    _geometry.texcoords[3] = in.texcoord3;\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    _geometry.texcoords[4] = in.texcoord4;\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    _geometry.texcoords[5] = in.texcoord5;\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    _geometry.texcoords[6] = in.texcoord6;\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    _geometry.texcoords[7] = in.texcoord7;\n#endif\n#ifdef HAS_VERTEX_COLOR\n    _geometry.color = in.color;\n#elif USE_VERTEX_COLOR\n    _geometry.color = float4(1.);\n#endif\n    \n#else \n    \n#ifdef USE_OPENSUBDIV\n#if OSD_IS_ADAPTIVE\n#if USE_STAGE_IN\n    int3 patchParam = patchInput.patchParam;\n#else\n    int3 patchParam = patchInput.patchParamBuffer[patchID];\n#endif\n    \n    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);\n    float tessellationLevel = min(osdTessellationLevel, (float)OSD_MAX_TESS_LEVEL) / exp2((float)refinementLevel - 1);\n    \n    OsdPatchVertex patchVertex = OsdComputePatch(tessellationLevel, patchCoord, patchID, patchInput);\n    \n#if defined(OSD_FVAR_WIDTH)\n    int patchIndex = OsdGetPatchIndex(patchID);\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);\n#else\n    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingIndices, osdFaceVaryingData, osdFaceVaryingPatchParams, osdFaceVaryingPatchArray);\n#endif\n#endif\n    \n    _geometry.position = float4(patchVertex.position, 1.f);\n    \n#if defined(USE_NORMAL)\n    _geometry.normal = patchVertex.normal;\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = float4(patchVertex.tangent, -1.f);\n    \n#endif\n#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[0] = patchVertex.texcoord0;\n#endif\n#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[1] = patchVertex.texcoord1;\n#endif\n#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[2] = patchVertex.texcoord2;\n#endif\n#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[3] = patchVertex.texcoord3;\n#endif\n#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[4] = patchVertex.texcoord4;\n#endif\n#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[5] = patchVertex.texcoord5;\n#endif\n#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[6] = patchVertex.texcoord6;\n#endif\n#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[7] = patchVertex.texcoord7;\n#endif\n#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.color = patchVertex.color;\n#endif\n    \n#else \n    \n#if OSD_PATCH_QUADS\n    const uint primitiveIndex = vertexID / 6;\n#ifdef USE_NORMAL\n    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 0]].position;\n    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 1]].position;\n    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 2]].position;\n    float3 normal = normalize(cross(p2 - p1, p0 - p1));\n#endif\n    const uint triangleIndices[6] = { 0, 1, 2, 0, 2, 3 };\n    const uint quadVertexIndex = triangleIndices[vertexID % 6];\n    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + quadVertexIndex]];\n#elif OSD_PATCH_TRIANGLES\n    const uint primitiveIndex = vertexID / 3;\n#ifdef USE_NORMAL\n    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 0]].position;\n    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 1]].position;\n    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 2]].position;\n    float3 normal = normalize(cross(p2 - p1, p0 - p1));\n#endif\n    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[vertexID]];\n#endif\n    \n    float3 position = osdVertex.position;\n    \n#if defined(OSD_FVAR_WIDTH)\n    int patchIndex = OsdGetPatchIndex(primitiveIndex);\n#if OSD_PATCH_QUADS\n    float2 quadUVs[4] = { float2(0,0), float2(1,0), float2(1,1), float2(0,1) };\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);\n#else\n    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingIndices, osdFaceVaryingData);\n#endif\n#elif OSD_PATCH_TRIANGLES\n    \n#endif\n#endif \n    \n#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[0] = osdVertex.texcoord0;\n#endif\n#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[1] = osdVertex.texcoord1;\n#endif\n#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[2] = osdVertex.texcoord2;\n#endif\n#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[3] = osdVertex.texcoord3;\n#endif\n#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[4] = osdVertex.texcoord4;\n#endif\n#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[5] = osdVertex.texcoord5;\n#endif\n#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[6] = osdVertex.texcoord6;\n#endif\n#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[7] = osdVertex.texcoord7;\n#endif\n#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.color = osdVertex.color;\n#endif\n    \n    _geometry.position = float4(position, 1.f);\n#ifdef USE_NORMAL\n    _geometry.normal = normal;\n#endif\n    \n#endif \n    \n#else \n    \n    \n    \n    \n    \n#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE) || defined(TESSELLATION_SMOOTHING_MODE_PHONG)\n    float3 P0 = in.controlPoints[0].position;\n    float3 P1 = in.controlPoints[1].position;\n    float3 P2 = in.controlPoints[2].position;\n    float3 N0 = in.controlPoints[0].normal;\n    float3 N1 = in.controlPoints[1].normal;\n    float3 N2 = in.controlPoints[2].normal;\n#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE)\n    float3 position, normal;\n    vfx_smooth_geometry_pn_triangle(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);\n#elif defined(TESSELLATION_SMOOTHING_MODE_PHONG)\n    float3 position, normal;\n    vfx_smooth_geometry_phong(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);\n#endif\n    _geometry.position = float4(position, 1.f);\n#ifdef USE_NORMAL\n    _geometry.normal = normal;\n#endif\n#else \n    \n    _geometry.position = float4(vfx::barycentric_mix(in.controlPoints[0].position, in.controlPoints[1].position, in.controlPoints[2].position, patchCoord), 1.f);\n#if defined(USE_NORMAL) && defined(HAS_NORMAL)\n    _geometry.normal = normalize(vfx::barycentric_mix(in.controlPoints[0].normal, in.controlPoints[1].normal, in.controlPoints[2].normal, patchCoord));\n#endif\n#endif \n    \n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = normalize(vfx::barycentric_mix(in.controlPoints[0].tangent, in.controlPoints[1].tangent, in.controlPoints[2].tangent, patchCoord));\n#endif\n#ifdef NEED_IN_TEXCOORD0\n    _geometry.texcoords[0] = vfx::barycentric_mix(in.controlPoints[0].texcoord0, in.controlPoints[1].texcoord0, in.controlPoints[2].texcoord0, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    _geometry.texcoords[1] = vfx::barycentric_mix(in.controlPoints[0].texcoord1, in.controlPoints[1].texcoord1, in.controlPoints[2].texcoord1, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    _geometry.texcoords[2] = vfx::barycentric_mix(in.controlPoints[0].texcoord2, in.controlPoints[1].texcoord2, in.controlPoints[2].texcoord2, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    _geometry.texcoords[3] = vfx::barycentric_mix(in.controlPoints[0].texcoord3, in.controlPoints[1].texcoord3, in.controlPoints[2].texcoord3, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    _geometry.texcoords[4] = vfx::barycentric_mix(in.controlPoints[0].texcoord4, in.controlPoints[1].texcoord4, in.controlPoints[2].texcoord4, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    _geometry.texcoords[5] = vfx::barycentric_mix(in.controlPoints[0].texcoord5, in.controlPoints[1].texcoord5, in.controlPoints[2].texcoord5, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    _geometry.texcoords[6] = vfx::barycentric_mix(in.controlPoints[0].texcoord6, in.controlPoints[1].texcoord6, in.controlPoints[2].texcoord6, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    _geometry.texcoords[7] = vfx::barycentric_mix(in.controlPoints[0].texcoord7, in.controlPoints[1].texcoord7, in.controlPoints[2].texcoord7, patchCoord);\n#endif\n#ifdef HAS_VERTEX_COLOR\n    _geometry.color = vfx::barycentric_mix(in.controlPoints[0].color, in.controlPoints[1].color, in.controlPoints[2].color, patchCoord);\n#elif USE_VERTEX_COLOR\n    _geometry.color = float4(1.);\n#endif\n    \n#endif \n    \n#endif \n    \n#ifdef USE_POINT_RENDERING\n    _geometry.pointSize = vfx_pointSize.x;\n#endif\n    \n#ifdef USE_TEXCOORD\n    __VertexDoVertexOnlyTexcoord__\n#endif\n    \n#ifdef USE_DISPLACEMENT_MAP\n    applyDisplacement(u_displacementTexture, u_displacementTextureSampler, _displacementTexcoord, _geometry, vfx_commonprofile);\n    out.displacementTexcoord = _displacementTexcoord;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_GEOMETRY_MODIFIER\n    \n    __DoGeometryModifier__\n    \n#endif\n    \n#ifdef USE_CLIP_DISTANCE0\n    out.clipDistance[0] = _geometry.clipDistance0;\n#endif\n#ifdef USE_CLIP_DISTANCE1\n    out.clipDistance[1] = _geometry.clipDistance1;\n#endif\n#ifdef USE_CLIP_DISTANCE2\n    out.clipDistance[2] = _geometry.clipDistance2;\n#endif\n#ifdef USE_CLIP_DISTANCE3\n    out.clipDistance[3] = _geometry.clipDistance3;\n#endif\n    \n    \n    \n    \n    \n    \n#if defined(USE_POSITION) || (defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)) || defined(USE_TANGENT) || defined(USE_BITANGENT) || defined(USE_INSTANCING)\n    VFXShaderSurface _surface;\n#endif\n#if defined(USE_POSITION) || defined(USE_INSTANCING)\n    _surface.position = (vfx_node.modelViewTransform * _geometry.position).xyz;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n#ifdef HINT_UNIFORM_SCALE\n    float3x3 nrmTransform = vfx::mat3(vfx_node.modelViewTransform);\n    _surface.normal = nrmTransform * _geometry.normal;\n#else\n    float3x3 modelViewTransform = vfx::mat3(vfx_node.modelViewTransform);\n    float3 invScaleSquared = 1.f / float3(length_squared(modelViewTransform[0]),\n                                          length_squared(modelViewTransform[1]),\n                                          length_squared(modelViewTransform[2]));\n    _surface.normal = normalize(modelViewTransform * (_geometry.normal * invScaleSquared));\n#endif\n#ifdef USE_GBUFFER_OUTPUT\n    _surface.normal = vfx::mat3(vfx_node.modelTransform) * _geometry.normal;\n#endif\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _surface.tangent = normalize(vfx::mat3(vfx_node.modelViewTransform) * _geometry.tangent.xyz);\n    _surface.bitangent = _geometry.tangent.w * cross(_surface.tangent, _surface.normal); \n    \n#endif\n    \n    \n#ifdef USE_VIEW\n    _surface.view = normalize(-_surface.position);\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_PER_VERTEX_LIGHTING\n    \n    VFXShaderLightingContribution _lightingContribution(_surface, out);\n    _lightingContribution.diffuse = 0.;\n  #ifdef USE_SPECULAR\n    _lightingContribution.specular = 0.;\n    _surface.shininess = vfx_commonprofile.materialShininess;\n  #endif\n    \n    __VertexDoLighting__\n    \n    out.diffuse = _lightingContribution.diffuse;\n  #ifdef USE_SPECULAR\n    out.specular = _lightingContribution.specular;\n  #endif\n#endif\n#if defined(USE_POSITION) && (USE_POSITION == 2)\n    out.position = _surface.position;\n#endif\n#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)\n    out.normal = _surface.normal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    out.tangent = _surface.tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    out.bitangent = _surface.bitangent;\n#endif\n#ifdef USE_VERTEX_COLOR\n    out.vertexColor = _geometry.color;\n#endif\n    \n#if DEBUG_PIXEL\n    out.uv0 = _geometry.texcoords[0];\n#endif\n\n#ifdef USE_TEXCOORD\n    __VertexDoTexcoord__\n#endif\n    \n#ifdef IS_BEZIER_CURVE\n    out.bezierCurveUV = in.texcoord0;\n#endif\n    \n    \n    \n    \n    \n#if defined(USE_POSITION) || defined(USE_INSTANCING)\n    out.fragmentPosition = vfx_frame.projectionTransform * float4(_surface.position, 1.);\n#elif defined(USE_MODELVIEWPROJECTIONTRANSFORM) \n    out.fragmentPosition = vfx_node.modelViewProjectionTransform * _geometry.position;\n#endif\n    \n#ifdef USE_NODE_OPACITY\n    out.nodeOpacity = vfx_node.nodeOpacity;\n#endif\n    \n#ifdef USE_POINT_RENDERING\n    float screenSize = _geometry.pointSize / out.fragmentPosition.w;\n    out.fragmentSize = clamp(screenSize, vfx_pointSize.y, vfx_pointSize.z);\n#endif\n    \n#ifdef USE_LASTFRAMETRANSFORM\n    float4 lastFrameFragmentPosition = vfx_frame.lastFrameViewProjectionTransform * vfx_node.lastFrameModelTransform * _geometry.position;\n    out.mv_fragment = out.fragmentPosition.xyw;\n    out.mv_lastFragment = lastFrameFragmentPosition.xyw;\n#endif\n    \n#ifdef USE_OUTLINE\n\tout.outlineHash = hash(vfx_node.modelTransform[3].xy)+1.f/255.f;\n#endif\n    \n#if USE_SCREEN_UV\n    float2 ndc = out.fragmentPosition.xy / out.fragmentPosition.w;\n    out.screen_uv = float2(ndc * float2(0.5f, -0.5f) + 0.5f);\n#endif\n\n#ifdef USE_CR_WORLD_POSITION\n    float3 worldPosition = (vfx_node.modelTransform * _geometry.position).xyz;\n#ifdef USE_RE_SYSTEM_TREATMENTS\n    out.crworldPosition = vfx::api_v2::crws_position(worldPosition, u_re_globalConstants);\n#else\n    \n#endif\n#endif\n\n    return out;\n}\n\n\n\n\n\nstruct VFXOutput\n{\n    float4 color [[ color(0) ]];\n#ifdef USE_COLOR1_OUTPUT\n    half4 color1 [[ color(1) ]];\n#endif\n#ifdef USE_NORMAL_ROUGHNESS_OUTPUT\n    half4 normalRoughness [[ color(2) ]];\n#endif\n#if defined(USE_MOTIONBLUR) && !defined(USE_GBUFFER_OUTPUT)\n    half4 motionblur [[ color(3) ]];\n#endif\n#ifdef USE_ALBEDO_METALNESS_OUTPUT\n    half4 albedoMetalnessOutput [[ color(4) ]];\n#endif\n#ifdef USE_RADIANCE_AO_OUTPUT\n    half4 radianceAOOutput [[ color(5) ]];\n#endif\n#ifdef USE_GBUFFER_OUTPUT\n    float4 albedo [[ color(VFXGBufferAttachmentAlbedo) ]];\n    float4 normals [[ color(VFXGBufferAttachmentNormal) ]];\n    float4 roughmetal [[ color(VFXGBufferAttachmentRoughnessMetalness) ]];\n    \n#ifdef USE_MOTIONBLUR\n    float4 velocity [[ color(VFXGBufferAttachmentVelocity) ]];\n#else\n    float2 velocity [[ color(VFXGBufferAttachmentVelocity) ]];\n#endif\n    half4 clearCoat [[ color(VFXGBufferAttachmentClearCoat) ]];\n    half4 subsurface [[ color(VFXGBufferAttachmentSubsurface) ]];\n    ushort4 transmission [[ color(VFXGBufferAttachmentTransmission) ]];\n#endif\n};\n    \n#ifdef USE_MODIFIER_FRAMEBUFFER\nstruct VFXFramebuffer\n{\n    float4 color;\n};\n#endif\n\nfragment VFXOutput commonprofile_frag(commonprofile_io                   in                          [[ stage_in  ]]\n                                      , constant commonprofile_uniforms& vfx_commonprofile           [[ buffer(0) ]]\n#ifdef USE_MULTIPLE_RENDERING\n                                      , constant VFXWorldBuffer*         vfx_frame_multi             [[ buffer(1) ]]\n#else\n                                      , constant VFXWorldBuffer&         vfx_frame                   [[ buffer(1) ]]\n#endif\n#if defined(USE_INSTANCING) || defined(USE_MULTIPLE_RENDERING)\n                                      , constant commonprofile_node*     vfx_nodes_in                [[ buffer(2) ]]\n#else\n                                      , constant commonprofile_node&     vfx_node_in                 [[ buffer(2) ]]\n#endif\n#ifdef USE_PER_PIXEL_LIGHTING\n                                      , constant vfx_light*              vfx_lights                  [[ buffer(3) ]]\n                                      , constant float4*                 u_shadowKernel\n                                      , texture2d_array<float>           u_areaLightBakedDataTexture\n#ifdef CFX_SUPPORT_CUBE_ARRAY\n                                      , texturecube_array<half>          u_reflectionProbeTexture\n#else\n                                      , texture2d_array<half>            u_reflectionProbeTexture\n#endif\n                                      , texture3d<ushort>                u_clusterTexture\n#ifdef CFX_USE_TEXTURE_FOR_LIGHT_INDICES\n                                      , texture1d<ushort>                u_lightIndicesTexture\n#else\n                                      , constant CFXLightIndexType*      u_lightIndicesBuffer\n#endif\n#endif\n#ifdef USE_RE_SYSTEM_TREATMENTS\n                                      , constant EntityConstants&           u_re_entityConstants\n                                      , constant ViewConstants&             u_re_viewConstants\n                                      , constant GlobalConstants&           u_re_globalConstants\n                                      , constant re_vfx_object_constants&   u_re_vfx_objectConstants\n                                      , constant re_entity_argument_buffer& u_re_vfx_entityArgumentBuffer\n                                      , constant re_scene_argument_buffer&  u_re_vfx_sceneArgumentBuffer\n#ifdef USE_RE_SYSTEM_TREATMENTS_TIER_1_AB\n                                      , constant VirtualEnvironmentProbeLighting::TextureArgumentBuffer& u_re_vfx_virtualEnvProbeTextures\n#endif\n#endif\n#if defined(CFX_SUPPORTS_PROGRAMMABLE_BLENDING) && defined(USE_MODIFIER_FRAMEBUFFER_COLOR0)\n                                      , float4                           framebufferColor0           [[ color(0) ]]\n#endif\n#if USE_ARGUMENT_BUFFERS\n\n#define u_emissionTexture               vfx_commonprofile.emissionTexture\n#define u_emissionTextureSampler        vfx_commonprofile.emissionSampler\n#define u_ambientOcclusionTexture       vfx_commonprofile.ambientOcclusionTexture\n#define u_ambientOcclusionTextureSampler vfx_commonprofile.ambientOcclusionSampler\n#define u_diffuseTexture                vfx_commonprofile.diffuseTexture\n#define u_diffuseTextureSampler         vfx_commonprofile.diffuseSampler\n#define u_specularTexture               vfx_commonprofile.specularTexture\n#define u_specularTextureSampler        vfx_commonprofile.specularSampler\n#define u_reflectiveTexture             vfx_commonprofile.reflectiveTexture\n#define u_reflectiveTextureSampler      vfx_commonprofile.reflectiveSampler\n#define u_transparentTexture            vfx_commonprofile.transparentTexture\n#define u_transparentTextureSampler     vfx_commonprofile.transparentSampler\n#define u_multiplyTexture               vfx_commonprofile.multiplyTexture\n#define u_multiplyTextureSampler        vfx_commonprofile.multiplySampler\n#define u_normalTexture                 vfx_commonprofile.normalTexture\n#define u_normalTextureSampler          vfx_commonprofile.normalSampler\n#define u_selfIlluminationTexture       vfx_commonprofile.selfIlluminationTexture\n#define u_selfIlluminationTextureSampler vfx_commonprofile.selfIlluminationSampler\n#define u_metalnessTexture              vfx_commonprofile.metalnessTexture\n#define u_metalnessTextureSampler       vfx_commonprofile.metalnessSampler\n#define u_roughnessTexture              vfx_commonprofile.roughnessTexture\n#define u_roughnessTextureSampler       vfx_commonprofile.roughnessSampler\n\n#else\n#ifdef USE_EMISSION_MAP\n                                      , texture2d<float>              u_emissionTexture\n                                      , sampler                       u_emissionTextureSampler\n#endif\n#ifdef USE_AMBIENTOCCLUSION_MAP\n                                      , texture2d<float>              u_ambientOcclusionTexture\n                                      , sampler                       u_ambientOcclusionTextureSampler\n#endif\n#ifdef USE_DIFFUSE_MAP\n                                      , texture2d<float>              u_diffuseTexture\n                                      , sampler                       u_diffuseTextureSampler\n#endif\n#ifdef USE_SPECULAR_MAP\n                                      , texture2d<float>              u_specularTexture\n                                      , sampler                       u_specularTextureSampler\n#endif\n#ifdef USE_REFLECTIVE_MAP\n                                      , texture2d<float>              u_reflectiveTexture\n                                      , sampler                       u_reflectiveTextureSampler\n#elif defined(USE_REFLECTIVE_CUBEMAP)\n                                      , texturecube<float>            u_reflectiveTexture\n                                      , sampler                       u_reflectiveTextureSampler\n#endif\n#ifdef USE_TRANSPARENT_MAP\n                                      , texture2d<float>              u_transparentTexture\n                                      , sampler                       u_transparentTextureSampler\n#endif\n#ifdef USE_MULTIPLY_MAP\n                                      , texture2d<float>              u_multiplyTexture\n                                      , sampler                       u_multiplyTextureSampler\n#endif\n#ifdef USE_NORMAL_MAP\n                                      , texture2d<float>              u_normalTexture\n                                      , sampler                       u_normalTextureSampler\n#endif\n#ifdef USE_SELFILLUMINATION_MAP\n                                      , texture2d<float>              u_selfIlluminationTexture\n                                      , sampler                       u_selfIlluminationTextureSampler\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n                                      , texture2d<float>              u_displacementTexture\n                                      , sampler                       u_displacementTextureSampler\n#endif\n#ifdef USE_PBR\n#ifdef USE_METALNESS_MAP\n                                      , texture2d<float>              u_metalnessTexture\n                                      , sampler                       u_metalnessTextureSampler\n#endif\n#ifdef USE_ROUGHNESS_MAP\n                                      , texture2d<float>              u_roughnessTexture\n                                      , sampler                       u_roughnessTextureSampler\n#endif\n#ifdef USE_CLEARCOAT_MAP\n                                      , texture2d<float>              u_clearCoatTexture\n                                      , sampler                       u_clearCoatTextureSampler\n#endif\n#ifdef USE_CLEARCOATROUGHNESS_MAP\n                                      , texture2d<float>              u_clearCoatRoughnessTexture\n                                      , sampler                       u_clearCoatRoughnessTextureSampler\n#endif\n#ifdef USE_CLEARCOATNORMAL_MAP\n                                      , texture2d<float>              u_clearCoatNormalTexture\n                                      , sampler                       u_clearCoatNormalTextureSampler\n#endif\n#ifdef USE_SUBSURFACE_MAP\n                                      , texture2d<float>              u_subsurfaceTexture\n                                      , sampler                       u_subsurfaceTextureSampler\n#endif\n#ifdef USE_SUBSURFACERADIUS_MAP\n                                      , texture2d<float>              u_subsurfaceRadiusTexture\n                                      , sampler                       u_subsurfaceRadiusTextureSampler\n#endif\n#ifdef USE_TRANSMISSION_MAP\n                                      , texture2d<float>              u_transmissionTexture\n                                      , sampler                       u_transmissionTextureSampler\n#endif\n#ifdef USE_TRANSMISSIONCOLOR_MAP\n                                      , texture2d<float>              u_transmissionColorTexture\n                                      , sampler                       u_transmissionColorTextureSampler\n#endif\n#endif \n#endif \n#ifdef USE_PBR\n                                      , texturecube<float>            u_radianceTexture\n                                      , texture2d<float>              u_specularDFGDiffuseHammonTexture\n#if !defined(USE_SELFILLUMINATION_MAP)\n                                      , texturecube<float>            u_irradianceTexture\n#endif\n#endif \n#ifdef USE_SSAO\n                                      , texture2d<float>              u_ssaoTexture\n#endif\n#ifdef USE_FRAGMENT_EXTRA_ARGUMENTS\n                                      __FragmentExtraArguments__\n#endif\n#if defined(USE_DOUBLE_SIDED)\n                                      , bool                          isFrontFacing                    [[front_facing]]\n#endif\n#ifdef USE_POINT_RENDERING\n                                      , float2                        pointCoord                       [[point_coord]]\n#endif\n#ifdef USE_VERTEX_AMPLIFICATION\n                                      , ushort                        amplificationID                  [[amplification_id]]\n#endif\n#ifdef USE_BARYCENTRIC_COORD\n                                      , float3                        u_barycentricCoord                 [[barycentric_coord]]\n#endif\n                                      )\n{\n#ifdef USE_MULTIPLE_RENDERING\n    \n#ifdef USE_VERTEX_AMPLIFICATION\n    constant VFXWorldBuffer& vfx_frame = vfx_frame_multi[amplificationID];\n#else\n    constant VFXWorldBuffer& vfx_frame = vfx_frame_multi[in.sliceIndex];\n#endif\n    \n#ifdef USE_INSTANCING\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& vfx_node_in = vfx_nodes_in[USE_MULTIPLE_RENDERING * in.instanceID + amplificationID];\n#else\n    constant commonprofile_node& vfx_node_in = vfx_nodes_in[USE_MULTIPLE_RENDERING * in.instanceID + in.sliceIndex];\n#endif\n#else\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant commonprofile_node& vfx_node_in = vfx_nodes_in[amplificationID];\n#else\n    constant commonprofile_node& vfx_node_in = vfx_nodes_in[in.sliceIndex];\n#endif\n#endif\n    \n#else \n    \n#ifdef USE_INSTANCING\n    constant commonprofile_node& vfx_node_in = vfx_nodes_in[in.instanceID];\n#endif\n    \n#endif \n    \n    commonprofile_node vfx_node = vfx_node_in;\n    \n#ifdef IS_BEZIER_CURVE\n    int vfx_bezierCurveCoverage = 0;\n    for (uint sampleID = 0; sampleID < get_num_samples(); ++sampleID) {\n        float2 uv = in.bezierCurveUV.interpolate_at_sample(sampleID);\n        bool insideCurve = vfx_is_inside_bezier_curve(uv, vfx_bezier_curve_data, vfx_bezier_curve_controlPoints);\n        vfx_bezierCurveCoverage += insideCurve;\n    }\n    if (vfx_bezierCurveCoverage == 0) {\n        discard_fragment();\n    }\n#endif\n    \n    VFXOutput _output;\n\n    \n    \n    \n    \n    VFXShaderSurface _surface;\n#ifdef USE_TEXCOORD\n    __FragmentDoTexcoord__\n#endif\n    _surface.ambientOcclusion = 1.f; \n\n#ifdef USE_AMBIENTOCCLUSION_MAP\n#if defined(USE_AMBIENTOCCLUSION_TEXTURE_COMPONENT)\n    _surface.ambientOcclusion = colorFromMask(u_ambientOcclusionTexture.sample(u_ambientOcclusionTextureSampler, _surface.ambientOcclusionTexcoord), USE_AMBIENTOCCLUSION_TEXTURE_COMPONENT).r;\n#else\n    _surface.ambientOcclusion = u_ambientOcclusionTexture.sample(u_ambientOcclusionTextureSampler, _surface.ambientOcclusionTexcoord).r;\n#endif \n#ifdef USE_AMBIENTOCCLUSION_INTENSITY\n    _surface.ambientOcclusion = saturate(mix(1.f, _surface.ambientOcclusion, vfx_commonprofile.ambientOcclusionIntensity));\n#endif\n#endif\n\n\n#if defined(USE_SSAO)\n    \n    \n    float2 uvSSAO = in.fragmentPosition.xy * vfx_frame.inverseResolution.xy;\n#if defined(USE_BENTNORMALS)\n    float4 aoBent = u_ssaoTexture.sample(sampler(filter::linear), uvSSAO).rgba;\n    _surface.ambientOcclusion *= aoBent.r;\n    _surface.bentNormal = aoBent.gba*2.0 - 1.0;\n#else\n    _surface.ambientOcclusion *= u_ssaoTexture.sample( sampler(filter::linear), uvSSAO).r;\n#endif\n#endif\n    \n#ifdef USE_DIFFUSE_MAP\n    _surface.diffuse = u_diffuseTexture.sample(u_diffuseTextureSampler, _surface.diffuseTexcoord);\n#if defined(USE_DIFFUSE_TEXTURE_COMPONENT)\n    _surface.diffuse = colorFromMask(_surface.diffuse, USE_DIFFUSE_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_DIFFUSE_INTENSITY\n    _surface.diffuse.rgb *= vfx_commonprofile.diffuseIntensity;\n#endif\n#elif defined(USE_DIFFUSE_COLOR)\n    _surface.diffuse = vfx_commonprofile.diffuseColor;\n#else\n    _surface.diffuse = float4(0.f,0.f,0.f,1.f);\n#endif\n#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)\n    _surface.diffuse.rgb    *= in.vertexColor.rgb;\n    _surface.diffuse        *= in.vertexColor.a; \n#endif\n#ifdef USE_SPECULAR_MAP\n    _surface.specular = u_specularTexture.sample(u_specularTextureSampler, _surface.specularTexcoord);\n#if defined(USE_SPECULAR_TEXTURE_COMPONENT)\n    _surface.specular = colorFromMask(_surface.specular, USE_SPECULAR_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_SPECULAR_INTENSITY\n    _surface.specular *= vfx_commonprofile.specularIntensity;\n#endif\n#elif defined(USE_SPECULAR_COLOR)\n    _surface.specular = vfx_commonprofile.specularColor;\n#elif defined(USE_SPECULAR)\n    _surface.specular = float4(0.f);\n#endif\n    \n#ifdef USE_CLEARCOAT_MAP\n    _surface.clearCoat = u_clearCoatTexture.sample(u_clearCoatTextureSampler, _surface.clearCoatTexcoord).r;\n#if defined(USE_CLEARCOAT_TEXTURE_COMPONENT)\n    _surface.clearCoat = colorFromMask(_surface.clearCoat, USE_CLEARCOAT_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_CLEARCOAT_INTENSITY\n    _surface.clearCoat *= vfx_commonprofile.clearCoatIntensity;\n#endif\n#elif defined(USE_CLEARCOAT_COLOR)\n    _surface.clearCoat = vfx_commonprofile.clearCoat;\n#else\n    _surface.clearCoat = 0.f;\n#endif\n    \n#ifdef USE_CLEARCOATROUGHNESS_MAP\n#if defined(USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT)\n    _surface.clearCoatRoughness = colorFromMask(u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord), USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.clearCoatRoughness = u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord).r;\n#endif\n#ifdef USE_CLEARCOATROUGHNESS_INTENSITY\n    _surface.clearCoatRoughness *= vfx_commonprofile.clearCoatRoughnessIntensity;\n#endif\n#elif defined(USE_CLEARCOATROUGHNESS_COLOR)\n    _surface.clearCoatRoughness = vfx_commonprofile.clearCoatRoughness;\n#else\n    _surface.clearCoatRoughness = 0.03f;\n#endif\n    \n#ifdef USE_SUBSURFACE\n#ifdef USE_SUBSURFACE_MAP\n    _surface.subsurface = u_subsurfaceTexture.sample(u_subsurfaceTextureSampler, _surface.subsurfaceTexcoord).r;\n#if defined(USE_SUBSURFACE_TEXTURE_COMPONENT)\n    _surface.subsurface = colorFromMask(_surface.subsurface, USE_SUBSURFACE_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_SUBSURFACE_INTENSITY\n    _surface.subsurface *= vfx_commonprofile.subsurfaceIntensity;\n#endif\n#elif defined(USE_SUBSURFACE_COLOR)\n    _surface.subsurface = vfx_commonprofile.subsurface;\n#else\n    _surface.subsurface = 0.f;\n#endif\n    \n#ifdef USE_SUBSURFACERADIUS_MAP\n    _surface.subsurfaceRadius = u_subsurfaceRadiusTexture.sample(u_subsurfaceRadiusTextureSampler, _surface.subsurfaceRadiusTexcoord).rgb;\n#if defined(USE_SUBSURFACERADIUS_TEXTURE_COMPONENT)\n    _surface.subsurfaceRadius = colorFromMask(_surface.subsurfaceRadius, USE_SUBSURFACERADIUS_TEXTURE_COMPONENT).rgb;\n#endif\n#ifdef USE_SUBSURFACERADIUS_INTENSITY\n    _surface.subsurfaceRadius *= vfx_commonprofile.subsurfaceRadiusIntensity;\n#endif\n#elif defined(USE_SUBSURFACERADIUS_COLOR)\n    _surface.subsurfaceRadius = vfx_commonprofile.subsurfaceRadius.rgb;\n#else\n    _surface.subsurfaceRadius = float3(0.f);\n#endif\n#endif\n    \n    \n#ifdef USE_TRANSMISSION\n#ifdef USE_TRANSMISSION_MAP\n    _surface.transmission = u_transmissionTexture.sample(u_transmissionTextureSampler, _surface.transmissionTexcoord).r;\n#if defined(USE_TRANSMISSION_TEXTURE_COMPONENT)\n    _surface.transmission = colorFromMask(_surface.transmission, USE_TRANSMISSION_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_TRANSMISSION_INTENSITY\n    _surface.transmission *= vfx_commonprofile.transmissionIntensity;\n#endif\n#elif defined(USE_TRANSMISSION_COLOR)\n    _surface.transmission = vfx_commonprofile.transmission;\n#else\n    _surface.transmission = 0.f;\n#endif\n    \n#ifdef USE_TRANSMISSIONCOLOR_MAP\n    _surface.transmissionColor = u_transmissionColorTexture.sample(u_transmissionColorTextureSampler, _surface.transmissionColorTexcoord).rgb;\n#if defined(USE_TRANSMISSIONCOLOR_TEXTURE_COMPONENT)\n    _surface.transmissionColor = colorFromMask(_surface.transmissionColor, USE_TRANSMISSIONCOLOR_TEXTURE_COMPONENT).rgb;\n#endif\n#ifdef USE_TRANSMISSIONCOLOR_INTENSITY\n    _surface.transmissionColor *= vfx_commonprofile.transmissionColorIntensity;\n#endif\n#elif defined(USE_TRANSMISSIONCOLOR_COLOR)\n    _surface.transmissionColor = vfx_commonprofile.transmissionColor.rgb;\n#else\n    _surface.transmissionColor = float3(0.f);\n#endif\n#endif\n    \n#ifdef USE_EMISSION_MAP\n    _surface.emission = u_emissionTexture.sample(u_emissionTextureSampler, _surface.emissionTexcoord);\n#if defined(USE_EMISSION_TEXTURE_COMPONENT)\n    _surface.emission = colorFromMask(_surface.emission, USE_EMISSION_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_EMISSION_INTENSITY\n    _surface.emission *= vfx_commonprofile.emissionIntensity;\n#endif\n#elif defined(USE_EMISSION_COLOR)\n    _surface.emission = vfx_commonprofile.emissionColor;\n#elif defined(USE_EMISSION)\n    _surface.emission = float4(0.);\n#endif\n#ifdef USE_SELFILLUMINATION_MAP\n    _surface.selfIllumination = u_selfIlluminationTexture.sample(u_selfIlluminationTextureSampler, _surface.selfIlluminationTexcoord);\n#if defined(USE_SELFILLUMINATION_TEXTURE_COMPONENT)\n    _surface.selfIllumination = colorFromMask(_surface.selfIllumination, USE_SELFILLUMINATION_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_SELFILLUMINATION_INTENSITY\n    _surface.selfIllumination *= vfx_commonprofile.selfIlluminationIntensity;\n#endif\n#elif defined(USE_SELFILLUMINATION_COLOR)\n    _surface.selfIllumination = vfx_commonprofile.selfIlluminationColor;\n#elif defined(USE_SELFILLUMINATION)\n    _surface.selfIllumination = float4(0.);\n#endif\n#ifdef USE_MULTIPLY_MAP\n    _surface.multiply = u_multiplyTexture.sample(u_multiplyTextureSampler, _surface.multiplyTexcoord);\n#if defined(USE_MULTIPLY_TEXTURE_COMPONENT)\n    _surface.multiply = colorFromMask(_surface.multiply, USE_MULTIPLY_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_MULTIPLY_INTENSITY\n    _surface.multiply = mix(float4(1.), _surface.multiply, vfx_commonprofile.multiplyIntensity);\n#endif\n#elif defined(USE_MULTIPLY_COLOR)\n    _surface.multiply = vfx_commonprofile.multiplyColor;\n#elif defined(USE_MULTIPLY)\n    _surface.multiply = float4(1.);\n#endif\n#ifdef USE_TRANSPARENT_MAP\n    _surface.transparent = u_transparentTexture.sample(u_transparentTextureSampler, _surface.transparentTexcoord);\n#if defined(USE_TRANSPARENT_TEXTURE_COMPONENT)\n    _surface.transparent = colorFromMask(_surface.transparent, USE_TRANSPARENT_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_TRANSPARENT_INTENSITY\n    _surface.transparent *= vfx_commonprofile.transparentIntensity;\n#endif\n#elif defined(USE_TRANSPARENT_COLOR)\n    _surface.transparent = vfx_commonprofile.transparentColor;\n#elif defined(USE_TRANSPARENT)\n    _surface.transparent = float4(1.f);\n#endif\n    \n#ifdef USE_METALNESS_MAP\n#if defined(USE_METALNESS_TEXTURE_COMPONENT)\n    _surface.metalness = colorFromMask(u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord), USE_METALNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.metalness = u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord).r;\n#endif\n#ifdef USE_METALNESS_INTENSITY\n    _surface.metalness *= vfx_commonprofile.metalnessIntensity;\n#endif\n#elif defined(USE_METALNESS_COLOR)\n    _surface.metalness = vfx_commonprofile.metalness;\n#else\n    _surface.metalness = 0.f;\n#endif\n    \n#ifdef USE_ROUGHNESS_MAP\n#if defined(USE_ROUGHNESS_TEXTURE_COMPONENT)\n    _surface.roughness = colorFromMask(u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord), USE_ROUGHNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.roughness = u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord).r;\n#endif\n#ifdef USE_ROUGHNESS_INTENSITY\n    _surface.roughness *= vfx_commonprofile.roughnessIntensity;\n#endif\n#elif defined(USE_ROUGHNESS_COLOR)\n    _surface.roughness = vfx_commonprofile.roughness;\n#else\n    _surface.roughness = 0.f;\n#endif\n#if (defined USE_POSITION) && (USE_POSITION == 2)\n    _surface.position = in.position;\n#endif\n#if (defined USE_NORMAL) && (USE_NORMAL == 2)\n#if defined(HAS_NORMAL) || defined(USE_OPENSUBDIV)\n#ifdef USE_DOUBLE_SIDED\n    _surface.geometryNormal = normalize(in.normal.xyz) * (isFrontFacing ? 1.f : -1.f );\n#else\n    _surface.geometryNormal = normalize(in.normal.xyz);\n#endif\n#else \n    _surface.geometryNormal = normalize( cross(dfdy( _surface.position ), dfdx( _surface.position ) ));\n#ifdef USE_GBUFFER_OUTPUT\n    _surface.geometryNormal = vfx::mat3(vfx_frame.inverseViewTransform) * _surface.geometryNormal;\n#endif\n#endif\n    _surface.normal = _surface.geometryNormal;\n    _surface.clearCoatNormal = _surface.geometryNormal;\n#ifdef USE_BENTNORMALS\n    _surface.aoDirectionnal = mix(0., _surface.ambientOcclusion, dot(_surface.bentNormal, _surface.normal)*0.5+0.5);\n#endif\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    _surface.tangent = in.tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    _surface.bitangent = in.bitangent;\n#endif\n#if (defined USE_VIEW) && (USE_VIEW == 2)\n    _surface.view = normalize(-in.position);\n    {\n        \n        float NoV = dot(_surface.geometryNormal, _surface.view);\n        _surface.view = _surface.view + max(0.f, -2.f * NoV) * _surface.geometryNormal;         \n        \n    }\n#endif\n#if defined(USE_NORMAL_MAP)\n    {\n        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.normal);\n#ifdef USE_NORMAL_MAP\n#if defined(USE_NORMAL_TEXTURE_COMPONENT)\n        _surface._normalTS.xy = colorFromMask(u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord), USE_NORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;\n        _surface._normalTS.z = sqrt(1.f - saturate(length_squared(_surface._normalTS.xy)));\n#else\n        _surface._normalTS = u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord).rgb;\n        _surface._normalTS = _surface._normalTS * 2.f - 1.f;\n#endif\n#ifdef USE_NORMAL_INTENSITY\n        _surface._normalTS = normalize(mix(float3(0.f, 0.f, 1.f), _surface._normalTS, vfx_commonprofile.normalIntensity));\n#endif\n#else\n        _surface._normalTS = float3(0.f, 0.f, 1.f);\n#endif\n        _surface.normal.rgb = normalize(ts2vs * _surface._normalTS.xyz );\n    }\n#else\n    _surface._normalTS = float3(0.f, 0.f, 1.f);\n#endif\n#if defined(USE_PBR) && !defined(USE_GBUFFER_OUTPUT)\n    {\n        _surface.rawRoughness = _surface.roughness;\n        float roughness = clamp(_surface.roughness, PBR_MIN_ROUGHNESS, 1.0);\n        float alpha = vfx_filteredAlphaFromRoughness(_surface.normal, roughness);\n        _surface.roughness = sqrt(alpha);\n    }\n#endif\n#if defined(USE_CLEARCOATNORMAL_MAP)\n    {\n        \n        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.geometryNormal);\n#ifdef USE_CLEARCOATNORMAL_MAP\n#if defined(USE_CLEARCOATNORMAL_TEXTURE_COMPONENT)\n        _surface._clearCoatNormalTS.xy = colorFromMask(u_clearCoatNormalTexture.sample(u_clearCoatnormalTextureSampler, _surface.clearCoatNormalTexcoord), USE_CLEARCOATNORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;\n        _surface._clearCoatNormalTS.z = sqrt(1.f - saturate(length_squared(_surface._clearCoatNormalTS.xy)));\n#else\n        _surface._clearCoatNormalTS = u_clearCoatNormalTexture.sample(u_clearCoatNormalTextureSampler, _surface.clearCoatNormalTexcoord).rgb;\n        _surface._clearCoatNormalTS = _surface._clearCoatNormalTS * 2.f - 1.f;\n#endif\n#ifdef USE_CLEARCOATNORMAL_INTENSITY\n        _surface._clearCoatNormalTS = mix(float3(0.f, 0.f, 1.f), _surface._clearCoatNormalTS, vfx_commonprofile.clearCoatNormalIntensity);\n#endif\n#else\n        _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);\n#endif\n        _surface.clearCoatNormal.rgb = normalize(ts2vs * _surface._clearCoatNormalTS.xyz );\n    }\n#else\n    _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);\n#endif\n    \n#ifdef USE_REFLECTIVE_MAP\n    float3 refl = reflect( -_surface.view, _surface.normal );\n    float m = 2.f * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.f)*(refl.z+1.f));\n    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, float2(float2(refl.x,-refl.y) / m) + 0.5f);\n#if defined(USE_REFLECTIVE_TEXTURE_COMPONENT)\n    _surface.reflective = colorFromMask(_surface.reflective, USE_REFLECTIVE_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_REFLECTIVE_INTENSITY\n    _surface.reflective *= vfx_commonprofile.reflectiveIntensity;\n#endif\n#elif defined(USE_REFLECTIVE_CUBEMAP)\n    float3 refl = reflect( _surface.position, _surface.normal );\n    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, vfx::mat4_mult_float3(vfx_frame.viewToCubeTransform, refl)); \n#ifdef USE_REFLECTIVE_INTENSITY\n    _surface.reflective *= vfx_commonprofile.reflectiveIntensity;\n#endif\n#elif defined(USE_REFLECTIVE_COLOR)\n    _surface.reflective = vfx_commonprofile.reflectiveColor;\n#elif defined(USE_REFLECTIVE)\n    _surface.reflective = float4(0.);\n#endif\n#ifdef USE_FRESNEL\n    _surface.fresnel = vfx_commonprofile.fresnel.x + vfx_commonprofile.fresnel.y * pow(1.f - saturate(dot(_surface.view, _surface.normal)), vfx_commonprofile.fresnel.z);\n    _surface.reflective *= _surface.fresnel;\n#endif\n#ifdef USE_SHININESS\n    _surface.shininess = vfx_commonprofile.materialShininess;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_SURFACE_MODIFIER\n    \n    __DoSurfaceModifier__\n    \n#endif\n    \n    \n    \n    \n    \n    VFXShaderLightingContribution _lightingContribution(_surface, in);\n#ifdef USE_LIGHT_MODIFIER\n    __LightModifierCopyDecl__\n#endif\n#ifdef USE_AMBIENT_LIGHTING\n    _lightingContribution.ambient = vfx_frame.ambientLightingColor.rgb;\n#endif\n#ifdef USE_LIGHTING\n#ifdef USE_PER_PIXEL_LIGHTING\n#ifdef USE_CLUSTERED_LIGHTING\n    uint3 clusterIndex;\n    clusterIndex.xy = uint2(in.fragmentPosition.xy * vfx_frame.clusterScale.xy); \n    clusterIndex.z = in.position.z * vfx_frame.clusterScale.z + vfx_frame.clusterScale.w; \n    \n    \n    ushort4 cluster_offset_count = u_clusterTexture.read(clusterIndex);\n    int lid = cluster_offset_count.x;\n#endif\n\n#ifdef USE_PBR\n    _lightingContribution.prepareForPBR(u_specularDFGDiffuseHammonTexture, vfx_commonprofile.selfIlluminationOcclusion);\n    \n    \n#ifdef USE_SELFILLUMINATION\n    _lightingContribution.add_irradiance_from_selfIllum();\n#else\n#ifdef USE_PROBES_LIGHTING \n\n#ifdef USE_IBL_TRANSFORM\n    _lightingContribution.add_global_irradiance_from_sh(vfx_frame.environmentTransform * vfx_frame.viewToCubeTransform, vfx_node.shCoefficients);\n#else\n    _lightingContribution.add_global_irradiance_from_sh(vfx_frame.viewToCubeTransform, vfx_node.shCoefficients);\n#endif \n\n#else\n\n#ifdef USE_IBL_TRANSFORM\n    _lightingContribution.add_global_irradiance_probe(u_irradianceTexture, vfx_frame.environmentTransform * vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#else\n    _lightingContribution.add_global_irradiance_probe(u_irradianceTexture, vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#endif \n\n#endif \n#endif\n\n    \n#ifdef CFX_USE_REFLECTION_PROBES\n    int probe_count = (cluster_offset_count.z & 0xff);\n    for (int i = 0 ; i < probe_count; ++i, ++lid) {\n        if ((vfx_node.categoryBitmask & vfx_lights[LightIndex(lid)].categoryBitmask) == 0) continue;\n        _lightingContribution.add_local_probe(vfx_lights[LightIndex(lid)], u_reflectionProbeTexture);\n    }\n#if PROBES_NORMALIZATION\n    float3 probesNormalization = 0;\n#if PROBES_OUTER_BLENDING\n    probesNormalization = _lightingContribution.probesWeightedSum.rgb / max(1.f, _lightingContribution.probesWeightedSum.a);\n#else\n    probesNormalization = _lightingContribution.probesWeightedSum.rgb / _lightingContribution.probesWeightedSum.a;\n#endif \n#ifdef DISABLE_SPECULAR\n    _lightingContribution.pbr.envDiffuse += probesNormalization;\n#else\n    _lightingContribution.specular += probesNormalization;\n#endif\n\n    float globalFactor = saturate(1.f - _lightingContribution.probesWeightedSum.a);\n#else\n    float globalFactor = _lightingContribution.probeRadianceRemainingFactor;\n#endif \n\n#ifndef DISABLE_SPECULAR\n#ifdef USE_IBL_TRANSFORM\n    _lightingContribution.add_global_probe(vfx_frame.environmentTransform * vfx_frame.viewToCubeTransform, globalFactor * vfx_frame.environmentIntensity,\n                                           u_reflectionProbeTexture);\n#else\n    _lightingContribution.add_global_probe(vfx_frame.viewToCubeTransform, globalFactor * vfx_frame.environmentIntensity,\n                                           u_reflectionProbeTexture);\n#endif \n#endif \n    \n#else \n\n#ifndef DISABLE_SPECULAR\n\n#ifdef USE_IBL_TRANSFORM\n    _lightingContribution.add_global_probe(u_radianceTexture, vfx_frame.environmentTransform * vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#else\n   _lightingContribution.add_global_probe(u_radianceTexture, vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#endif \n    \n#ifdef USE_CLEARCOAT\n    \n#ifdef USE_IBL_TRANSFORM\n    _lightingContribution.add_global_probeClearCoat(u_radianceTexture, vfx_frame.environmentTransform * vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#else\n    _lightingContribution.add_global_probeClearCoat(u_radianceTexture, vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#endif \n    \n#endif \n\n    \n#endif \n#endif \n\n#endif \n    #if DEBUG_PIXEL\n        switch (DEBUG_PIXEL) {\n            case 1: _output.color = float4(_surface.normal * 0.5f + 0.5f, 1.f); break;\n            case 2: _output.color = float4(_surface.geometryNormal * 0.5f + 0.5f, 1.f); break;\n            case 3: _output.color = float4(_surface.tangent * 0.5f + 0.5f, 1.f); break;\n            case 4: _output.color = float4(in.uv0, 0.f, 1.f); break;\n            case 5: _output.color = float4(_surface.diffuse.rgb, 1.f); break;\n            case 6: _output.color = float4(float3(_surface.roughness), 1.f); break;\n            case 7: _output.color = float4(float3(_surface.metalness), 1.f); break;\n            case 8: _output.color = float4(float3(_surface.ambientOcclusion), 1.f); break;\n                \n            #ifdef USE_BENTNORMALS\n                case 9: _output.color = float4(float3(_surface.bentNormal * 0.5f + 0.5f), 1.f); break;\n            #else\n                case 9: _output.color = float4(float3(_surface.normal * 0.5f + 0.5f), 1.f); break;\n            #endif\n            default: break;\n        }\n        return _output;\n    #endif\n    \n    __FragmentDoLighting__\n    \n    #ifdef USE_CLUSTERED_LIGHTING\n        \n        int omni_count = cluster_offset_count.y & 0xff;\n        for (int i = 0 ; i < omni_count; ++i, ++lid) {\n            if ((vfx_node.categoryBitmask & vfx_lights[LightIndex(lid)].categoryBitmask) == 0) continue;\n            _lightingContribution.add_local_omni(vfx_lights[LightIndex(lid)]);\n        }\n\n        \n        int spot_count = (cluster_offset_count.y >> 8);\n        for (int i = 0 ; i < spot_count; ++i, ++lid) {\n            if ((vfx_node.categoryBitmask & vfx_lights[LightIndex(lid)].categoryBitmask) == 0) continue;\n            _lightingContribution.add_local_spot(vfx_lights[LightIndex(lid)]);\n        }\n\n    #endif\n#else \n        _lightingContribution.diffuse = in.diffuse;\n    #ifdef USE_SPECULAR\n        _lightingContribution.specular = in.specular;\n    #endif\n#endif \n    #ifdef AVOID_OVERLIGHTING\n        _lightingContribution.diffuse = saturate(_lightingContribution.diffuse);\n    #ifdef USE_SPECULAR\n        _lightingContribution.specular = saturate(_lightingContribution.specular);\n    #endif \n    #endif \n#else \n    _lightingContribution.diffuse = float3(0.);\n#endif \n\n    \n    \n    \n    \n#ifndef USE_GBUFFER_OUTPUT\n#ifdef USE_PBR\n    { \n        float3 diffuseAlbedo = mix(_lightingContribution.pbr.albedo, float3(0.0), _surface.metalness);\n        \n        \n#ifdef USE_PBR_TRANSPARENCY\n        float3 color = (_lightingContribution.ambient * _surface.ambientOcclusion) * _lightingContribution.pbr.albedo;\n#else\n        float3 color = (_lightingContribution.ambient * _surface.ambientOcclusion) * _surface.diffuse.rgb;\n#endif\n        \n        color += _lightingContribution.pbr.envDiffuse;\n        color += _lightingContribution.diffuse * diffuseAlbedo;\n#ifndef DISABLE_SPECULAR\n#ifndef DISABLE_SPECULAR_IBL\n        color += _lightingContribution.pbr.envSpecular;\n#endif\n        color += _lightingContribution.specular;\n#endif\n#ifdef USE_EMISSION\n        color += _surface.emission.rgb;\n#endif\n#ifdef USE_MULTIPLY\n        color *= _surface.multiply.rgb;\n#endif\n#ifdef USE_MODULATE\n        color *= _lightingContribution.modulate;\n#endif\n#ifndef USE_GBUFFER_OUTPUT\n        _output.color.rgb = color;\n#endif\n    }\n#else \n\n#ifdef USE_SHADOWONLY\n    _output.color.rgb = float3(0.0);\n    _output.color.a = 1. - _lightingContribution.shadowFactor;\n#else\n#ifdef USE_CONSTANT\n    _output.color.rgb = _surface.diffuse.rgb;\n    \n#ifdef USE_EMISSION\n    _output.color.rgb += _surface.emission.rgb;\n#endif\n#ifdef USE_MULTIPLY\n    _output.color.rgb *= _surface.multiply.rgb;\n#endif\n    \n#else\n    _output.color.rgb = illuminate(_surface, _lightingContribution);\n#endif\n#endif \n#endif \n\n#ifndef USE_SHADOWONLY\n  #ifdef USE_PBR_TRANSPARENCY\n    _output.color.a = _lightingContribution.pbr.transparency;\n  #else\n    _output.color.a = _surface.diffuse.a;\n  #endif\n#endif\n\n#ifdef USE_FOG\n    applyFog(_output.color, length(_surface.position.xyz), vfx_frame.fogParameters, vfx_frame.fogColor);\n#endif\n\n#if !defined(DIFFUSE_PREMULTIPLIED) && !defined(USE_PBR_TRANSPARENCY)\n    _output.color.rgb *= _surface.diffuse.a;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_SHADOWONLY\n    float transparencyFactor = 1.0;\n  #ifdef USE_NODE_OPACITY\n    transparencyFactor *= in.nodeOpacity;\n  #endif\n    _output.color.a *= transparencyFactor; \n\n#else \n\n#ifdef USE_TRANSPARENT \n    \n#ifndef USE_PBR_TRANSPARENCY\n  _output.color *= _surface.transparent.a;\n#endif\n\n#endif \n    \n#ifdef USE_NODE_OPACITY\n    _output.color *= in.nodeOpacity;\n#endif\n    \n#endif \n#endif \n\n    \n    \n    \n    \n#ifdef USE_MODIFIER_FRAMEBUFFER\n    const VFXFramebuffer _framebuffer = {\n#if defined(CFX_SUPPORTS_PROGRAMMABLE_BLENDING) && defined(USE_MODIFIER_FRAMEBUFFER_COLOR0)\n        .color = framebufferColor0\n#else\n        .color = 0.f\n#endif\n    };\n#endif\n    \n#ifdef USE_FRAGMENT_MODIFIER\n    \n    __DoFragmentModifier__\n    \n#endif\n#if defined(USE_CLUSTERED_LIGHTING) && defined(DEBUG_CLUSTER_TILE)\n    _output.color.rgb = mix(_output.color.rgb, float3(vfx::debugColorForCount(clusterIndex.z).xyz), 0.1f);\n    _output.color.rgb = mix(_output.color.rgb, float3(clusterIndex.x & 0x1 ^ clusterIndex.y & 0x1).xyz, 0.01f);\n#endif\n    \n#ifdef USE_ALPHA_CUTOFF\n    if (_output.color.a <= vfx_commonprofile.alphaCutoff)\n        discard_fragment();\n#endif\n\n#ifdef USE_POINT_RENDERING\n    if ((dfdx(pointCoord.x) < 0.5f) && (length_squared(pointCoord * 2.f - 1.f) > 1.f)) {\n        discard_fragment();\n    }\n#endif\n    \n    \n#ifdef USE_OUTLINE\n    _output.color.rgb = in.outlineHash;\n#endif\n    \n\n#if defined(USE_MOTIONBLUR) && !defined(USE_GBUFFER_OUTPUT)\n#ifdef USE_MULTIPLE_RENDERING\n    _output.motionblur.xy = half2((in.mv_fragment.xy - vfx_frame.viewportSize.zw) / in.mv_fragment.z - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * vfx_frame.motionBlurIntensity;\n#else\n    _output.motionblur.xy = half2((in.mv_fragment.xy / in.mv_fragment.z) - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * vfx_frame.motionBlurIntensity;\n#endif\n    _output.motionblur.z = length(_output.motionblur.xy);\n    _output.motionblur.w = half(-_surface.position.z);\n#endif\n\n#ifdef USE_NORMAL_ROUGHNESS_OUTPUT\n#ifdef USE_PBR\n    _output.normalRoughness = half4( half3(_surface.normal.xyz), half(_surface.rawRoughness) );\n#else\n    _output.normalRoughness = half4( half3(_surface.normal.xyz), 0.h );\n#endif\n#endif\n                                 \n#ifdef USE_ALBEDO_METALNESS_OUTPUT\n#ifdef USE_PBR\n    _output.albedoMetalnessOutput = half4( half3(_surface.diffuse.rgb), half(_surface.metalness) );\n#else \n    _output.albedoMetalnessOutput = half4( 0.h );\n#endif\n#endif\n    \n#ifdef USE_RADIANCE_AO_OUTPUT\n#ifdef USE_PBR\n    _output.radianceAOOutput = half4(half3(_lightingContribution.pbr.envSpecular.rgb), half(_surface.ambientOcclusion));\n#else\n    _output.radianceAOOutput = half4(0.h, 0.h, 0.h, 0.h);\n#endif\n#endif\n    \n#ifdef USE_BARYCENTRIC_WIREFRAME\n#ifdef USE_BARYCENTRIC_COORD\n    const float3 d = 1.0f * fwidth(baryCoord);\n    const float3 s = smoothstep(d * 0.25f, d * 0.75, u_barycentricCoord);\n    _output.color = mix(float4(1.0), _output.color, min3(s.x, s.y, s.z));\n#endif\n#endif\n    \n#ifdef USE_GBUFFER_OUTPUT\n    float opacity = _surface.diffuse.a;\n#ifdef USE_NODE_OPACITY\n    opacity *= in.nodeOpacity;\n#endif\n    \n    float dither = vfx::interleaved_gradient_noise(in.fragmentPosition.xy);\n    dither = fract(dither + in.fragmentPosition.z * 1.61803398875);\n    dither = fract(dither + vfx_frame.frame * 1.61803398875);\n    if (opacity < dither) discard_fragment();\n    if (opacity < 0.01) discard_fragment();\n    \n    float3 emission = float3(0.);\n#ifdef USE_EMISSION\n    emission = _surface.emission.rgb;\n#endif\n    _output.albedo = float4(_surface.diffuse.rgb, opacity);\n    _output.normals = float4(_surface.normal.xyz, -_surface.position.z);\n    _output.roughmetal = float4(_surface.roughness, _surface.metalness, _surface.ambientOcclusion, 1.);\n    _output.color = float4(emission, 1.);\n    \n    float2 vfx_prevUv = (in.mv_lastFragment.xy / in.mv_lastFragment.z);\n    float2 vfx_uv = (in.mv_fragment.xy / in.mv_fragment.z);\n    _output.velocity.xy = (vfx_prevUv - vfx_uv) * float2(.5,-.5);\n    \n#ifdef USE_MOTIONBLUR\n    _output.velocity.z = length(_output.velocity.xy);\n    _output.velocity.w = -_surface.position.z;\n#endif\n    ushort clearcoatIR = packHalf2ToUShort(half2(_surface.clearCoat, _surface.clearCoatRoughness));\n    _output.clearCoat = half4(half3(_surface.clearCoatNormal), as_type<half>(clearcoatIR));\n    \n    _output.subsurface = half4(half3(_surface.subsurfaceRadius), half(_surface.subsurface));\n    \n    float transmissionColorLength = length(_surface.transmissionColor);\n    _surface.transmissionColor /= max(1e-4, transmissionColorLength);\n    ushort transmissionRG = packHalf2ToUShort(half2(_surface.transmissionColor.r, _surface.transmissionColor.g));\n    ushort transmissionBW = packHalf2ToUShort(half2(_surface.transmissionColor.b, _surface.transmission));\n    _output.transmission = ushort4(transmissionRG, transmissionBW,\n                                 as_type<ushort>(half(transmissionColorLength)), as_type<ushort>(half(vfx_commonprofile.indexOfRefraction)));\n#endif\n\n#ifdef USE_RE_SYSTEM_TREATMENTS\n\n#ifdef USE_MULTIPLE_RENDERING\n#ifdef USE_VERTEX_AMPLIFICATION\n    uint cameraIndex = amplificationID;\n#else\n    uint cameraIndex = in.sliceIndex;\n#endif\n#else\n    uint cameraIndex = 0;\n#endif \n\n    uint sampleMask = 0;\n\n    vfx::api_v2::re_buffers buffers = vfx::api_v2::re_buffers {\n        .entityConstants      = u_re_entityConstants,\n        .viewConstants        = u_re_viewConstants,\n        .globalConstants      = u_re_globalConstants,\n        .objectConstants      = u_re_vfx_objectConstants,\n        .entityArgumentBuffer = u_re_vfx_entityArgumentBuffer,\n        .sceneArgumentBuffer  = u_re_vfx_sceneArgumentBuffer,\n#ifdef USE_RE_SYSTEM_TREATMENTS_TIER_1_AB\n        .probeTextures        = u_re_vfx_virtualEnvProbeTextures\n#endif\n    };\n\n    auto params = vfx::api_v2::make_system_treatment_parameters(in.crworldPosition, in.fragmentPosition, cameraIndex, in.screen_uv);\n    _output.color = float4(vfx::api_v2::apply_system_treatments(half4(_output.color), params, buffers, sampleMask));\n#endif \n\n    return _output;\n}\n\n#pragma mark - Namespace End\n\n    \n"
+ "#define USE_QUAT_FOR_IES 1\n#define USE_PBR_DOMINANT_DIRECTION 1\n\n#define PBR_INTENSITY_FACTOR M_PI_2_F\n#define BoostFactor (20.0f * PBR_INTENSITY_FACTOR)\n\n\nstruct vfx_light\n{\n    float4 color; \n    float3 pos; \n    float3 dir; \n    float shadowRadius; \n    uint8_t lightType; \n    uint8_t shadowSampleCount; \n                                \n    union {\n        struct {\n            float4      cascadeScale[4]; \n            float4      cascadeBias[4];\n        } directional; \n        struct {\n            float4      attenuationFactors; \n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n            float4x4    projection;\n            float       depthBias;\n#else\n            float3      shadowScaleBias; \n#endif\n        } omni;\n        struct {\n            float4      _attenuationFactors; \n            float2      scaleBias; \n        } spot;\n        struct {\n            float4      _attenuationFactors; \n            float2      scaleBias; \n#if USE_QUAT_FOR_IES\n            float4      light_from_view_quat; \n#else\n            float4x4    light_from_view; \n#endif\n        } ies;\n        union {\n            struct {\n                float2 halfExtents;\n                float doubleSided;\n            } rectangle;\n            struct {\n                uint32_t vertexCount;\n                float doubleSided;\n            } polygon;\n            struct {\n                float halfLength;\n            } line;\n            struct {\n                float2 halfExtents;\n                float doubleSided;\n            } ellipse;\n            struct {\n                float3 halfExtents;\n            } ellipsoid;\n        } area;\n        struct {\n            float3  offset;\n            float4  halfExtents; \n            float3  parallaxCenter;\n            float3  parallaxExtents;\n            int32_t index; \n            int32_t parallaxCorrection; \n        } probe;\n    } parameters; \n\n    float4x4    shadowMatrix; \n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    float4 tiles[6]; \n#endif\n\tuint8_t categoryBitmask;\n};\n\n#if defined(__METAL_VERSION__) \n\nusing namespace metal;\n\nnamespace vfx_lighting {\n    static constexpr sampler linearSampler = sampler(filter::linear, mip_filter::linear);\n}\n\nstruct VFXShaderSurface {\n    float3 view;                \n    float3 position;            \n    float3 normal;              \n#ifdef USE_BENTNORMALS\n    float3 bentNormal;          \n    float aoDirectionnal;       \n#endif\n    float3 geometryNormal;      \n    float2 normalTexcoord;      \n    float3 tangent;             \n    float3 bitangent;           \n    float4 diffuse;             \n    float2 diffuseTexcoord;     \n    float4 specular;            \n    float2 specularTexcoord;    \n    float4 emission;            \n    float2 emissionTexcoord;    \n    float4 selfIllumination;            \n    float2 selfIlluminationTexcoord;    \n    float4 multiply;            \n    float2 multiplyTexcoord;    \n    float4 transparent;         \n    float2 transparentTexcoord; \n    float4 reflective;          \n    float  metalness;           \n    float2 metalnessTexcoord;   \n    float  roughness;           \n    float2 roughnessTexcoord;   \n    float  rawRoughness;        \n    float clearCoat;            \n    float2 clearCoatTexcoord;   \n    float clearCoatRoughness;   \n    float2 clearCoatRoughnessTexcoord;\n    float3 clearCoatNormal;     \n    float2 clearCoatNormalTexcoord;\n#ifdef USE_SUBSURFACE\n    float subsurface;\n    float2 subsurfaceTexcoord;\n    float3 subsurfaceRadius;\n    float2 subsurfaceRadiusTexcoord;\n#endif\n#ifdef USE_TRANSMISSION\n    float transmission;\n    float2 transmissionTexcoord;\n    float3 transmissionColor;\n    float2 transmissionColorTexcoord;\n#endif\n    float shininess;            \n    float fresnel;              \n    float ambientOcclusion;     \n    float2 ambientOcclusionTexcoord;   \n    float3 _normalTS;           \n    float3 _clearCoatNormalTS;  \n#ifdef USE_SURFACE_EXTRA_DECL\n    __SurfaceExtraDecl__\n#endif\n};\n\n\n\nstruct VFXShaderLight {\n    float4 intensity;\n    float3 direction;\n\n    float  _att;\n    float3 _spotDirection;\n    float  _distance;\n};\n\nenum VFXShadingModel\n{\n    VFXShadingModelConstant,\n    VFXShadingModelPhong,\n    VFXShadingModelNone,\n    VFXShadingModelPhysicallyBased,\n    VFXShadingModelShadowOnly,\n\n    VFXShadingModelCustom \n};\n\n#define PROBES_NORMALIZATION 0\n#define PROBES_OUTER_BLENDING 1\n\nstruct VFXShaderLightingContribution\n{\n    float3 ambient;\n    float3 diffuse;\n    float3 specular;\n    float3 modulate;\n\n#ifdef USE_SHADOWONLY\n    float shadowFactor;\n#endif\n\n#if PROBES_NORMALIZATION\n    float4 probesWeightedSum; \n#else\n    float  probeRadianceRemainingFactor;\n#endif\n\n    thread VFXShaderSurface& surface;\n\n#ifdef USE_PER_VERTEX_LIGHTING\n    commonprofile_io out;\n#else\n    commonprofile_io in;\n#endif\n\n#ifdef USE_PBR\n    struct {\n        float3 albedo;\n        float3 envDiffuse;\n        float3 envSpecular;\n        float3 reflectance;\n        float3 probeReflectance;\n#ifndef USE_PBR_LAMBERTIAN_REFLECTION\n        float2 diffuseHammonFactors;\n#endif\n#ifdef USE_PBR_TRANSPARENCY\n        float  transparency;\n#endif\n        float  NoV;\n        float  selfIlluminationOcclusion;\n#ifdef USE_CLEARCOAT\n        float  NoVClearCoat;\n        float3 probeReflectanceClearCoat;\n#endif\n    } pbr;\n#endif\n    \n    VFXShaderLightingContribution(thread VFXShaderSurface& iSurface, commonprofile_io io):surface(iSurface)\n#ifdef USE_PER_VERTEX_LIGHTING\n    ,out(io)\n#else\n    ,in(io)\n#endif\n    {\n        ambient = 0.f;\n        diffuse = 0.f;\n        specular = 0.f;\n#ifdef USE_SHADOWONLY\n        shadowFactor = 1.f;\n#endif\n\n#if PROBES_NORMALIZATION\n#if PROBES_OUTER_BLENDING\n        probesWeightedSum = float4(0.f);\n#else\n        probesWeightedSum = float4(0.f, 0.f, 0.f, 0.000001f); \n#endif\n#else\n        probeRadianceRemainingFactor = 1.f;\n#endif\n\n#ifdef USE_MODULATE\n        modulate = 1.f;\n#else\n        modulate = 0.f;\n#endif\n    }\n\n#ifdef USE_PBR\n    void prepareForPBR(texture2d<float, access::sample> specularDFGDiffuseHammonTexture, float occ)\n    {\n        pbr.envDiffuse = 0.f;\n        pbr.envSpecular = 0.f;\n        pbr.selfIlluminationOcclusion = occ;\n      \n        pbr.albedo = surface.diffuse.rgb;\n#ifdef USE_PBR_TRANSPARENCY\n  #ifdef DIFFUSE_PREMULTIPLIED\n        \n        pbr.transparency = 1.f;\n  #else\n        pbr.transparency = surface.diffuse.a;\n  #endif\n  #ifdef USE_TRANSPARENCY\n    #ifdef USE_PER_VERTEX_LIGHTING\n        pbr.transparency *= out.transparency;\n    #else\n        pbr.transparency *= in.transparency;\n    #endif\n  #endif\n  #ifdef USE_TRANSPARENT\n        pbr.transparency *= surface.transparent.a;\n  #endif\n        pbr.albedo *= pbr.transparency;\n  #ifdef DIFFUSE_PREMULTIPLIED\n        \n        \n        pbr.transparency *= surface.diffuse.a;\n  #endif\n#endif\n        \n        float3 n = surface.normal;\n        float3 v = surface.view;\n        pbr.NoV = abs(dot(n, v));\n        \n        float roughness = surface.roughness;\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        float2 specularDFG = specularDFGDiffuseHammonTexture.sample(vfx_lighting::linearSampler, float2(pbr.NoV, roughness)).rg;\n#else\n#ifdef USE_RE_RADIANCE_IRRADIANCE_MAP_SAMPLING\n        float4 env = specularDFGDiffuseHammonTexture.sample(vfx_lighting::linearSampler, float2(roughness, 1.0f - pbr.NoV));\n#else\n        float4 env = specularDFGDiffuseHammonTexture.sample(vfx_lighting::linearSampler, float2(pbr.NoV, roughness));\n#endif\n        float2 specularDFG = env.xy;\n        pbr.diffuseHammonFactors = env.zw;\n#endif\n        \n        pbr.reflectance = mix(PBR_F0_NON_METALLIC, pbr.albedo, surface.metalness);\n        pbr.probeReflectance = pbr.reflectance * specularDFG.r + specularDFG.g;\n                                \n#ifdef USE_CLEARCOAT\n        pbr.NoVClearCoat = abs(dot(surface.clearCoatNormal, v));\n        float2 DFGClearCoat = specularDFGDiffuseHammonTexture.sample(vfx_lighting::linearSampler, float2(pbr.NoVClearCoat, surface.clearCoatRoughness)).rg;\n        pbr.probeReflectanceClearCoat = 0.04 * DFGClearCoat.r + DFGClearCoat.g;\n#endif\n    }\n#endif\n\n\n#ifdef USE_LIGHT_MODIFIER\n    __LightModifierExtraDecl__\n#endif\n\n    float4 debug_pixel(float2 fragmentPosition)\n    {\n        const int width = 64;\n        switch (int(fragmentPosition.x + fragmentPosition.y ) / width) {\n            case 0: return float4(surface.view, 1.f);\n            case 1: return float4(surface.position, 1.f);\n            case 2: return float4(surface.normal, 1.f);\n            case 3: return float4(surface.geometryNormal, 1.f);\n            case 4: return float4(float3(surface.ambientOcclusion), 1.f);\n            case 5: return surface.diffuse;\n            case 6: return float4(float3(surface.metalness), 1.f);\n            case 7: return float4(float3(surface.roughness), 1.f);\n            case 8: return float4(ambient, 1.f);\n            case 9: return float4(diffuse, 1.f);\n            default: return float4(specular, 1.f);\n        }\n    }\n\n    \n\n    static inline float3 lambert_diffuse(float3 l, float3 n, float3 color, float intensity) {\n        return color * (intensity * saturate(dot(n, l)));\n    }\n\n    void phong(float3 l, float3 color, float intensity)\n    {\n        float3 D = lambert_diffuse(l, surface.normal, color, intensity);\n        diffuse += D;\n\n        float3 r = reflect(-l, surface.normal);\n        specular += powr(saturate(dot(r, surface.view)), surface.shininess) * D;\n    }\n\n#ifdef USE_PBR\n    void physicallyBased(float3 l, float3 color, float intensity)\n    {\n        float3 n         = surface.normal;\n        float3 v         = surface.view;\n        float  roughness = surface.roughness;\n        float  alpha     = roughness * roughness;\n\n        float3 h = normalize(l + v);\n\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n        \n        float D   = vfx_brdf_D(alpha, NoH);\n        float3 F  = vfx_brdf_F_opt(pbr.reflectance, LoH);\n        float Vis = vfx_brdf_V(alpha, NoL, pbr.NoV);\n\n        \n        diffuse  += color * (NoL * M_1_PI_F * intensity);\n        specular += color * F * (NoL * D * Vis * intensity);\n        \n        #ifdef USE_CLEARCOAT\n            n = surface.clearCoatNormal;\n\n            roughness = max(surface.clearCoatRoughness, 0.089f);\n            alpha = roughness * roughness; \n        \n            \n            \n            float NoH_coat = saturate(dot(n, h));\n            float NoL_coat = saturate(dot(n, l));\n            D   = vfx_brdf_D(alpha, NoH_coat);\n            F   = vfx_brdf_F_opt(0.04, LoH) * surface.clearCoat;\n            Vis = vfx_brdf_V(alpha, NoL_coat, saturate(dot(n,v)));\n        \n            float attenuation = 1.0 - F.r;\n            specular *=  (attenuation * attenuation);\n            specular += color * F * ( NoL_coat * D * Vis * intensity);\n        #endif\n    }\n#endif\n\n    void custom(float3 _l, float3 _color, float _intensity)\n    {\n#ifdef USE_LIGHT_MODIFIER\n        thread VFXShaderLightingContribution &_lightingContribution = *this;\n        thread VFXShaderSurface& _surface = surface;\n        VFXShaderLight _light = {.direction = _l, .intensity = float4(_color, 1.f), ._att = _intensity };\n        \n        __DoLightModifier__\n        \n#endif\n    }\n\n    void shade(float3 l, float3 color, float intensity)\n    {\n#ifdef LIGHTING_MODEL\n        switch (LIGHTING_MODEL) {\n#ifdef USE_SHADOWONLY\n            case VFXShadingModelShadowOnly:      shadowFactor *= intensity; break;\n#endif\n            case VFXShadingModelPhong:           phong(l, color, intensity); break;\n#ifdef USE_PBR\n            case VFXShadingModelPhysicallyBased: physicallyBased(l, color, intensity); break;\n#endif\n            case VFXShadingModelCustom:          custom(l, color, intensity); break;\n            default:  break; \n        }\n#endif\n    }\n\n    \n    \n    \n    float pbr_dist_attenuation_alternate(float3 l, float cutoff) {\n        \n        float radius = 0.1f; \n        float factor = 1.f / (1.f + length(l)/radius);\n        float attenuation = saturate(factor * factor); \n        return saturate((attenuation - cutoff) / (1.f - cutoff));\n    }\n\n    float pbr_dist_attenuation(float3 l, float inv_square_radius) {\n        float sqr_dist = length_squared(l);\n        float atten = 1.f / max(sqr_dist, 0.0001f);\n\n        \n        float factor = saturate(1.f - vfx::sq(sqr_dist * inv_square_radius));\n        return atten * factor * factor;\n    }\n\n    float non_pbr_dist_attenuation(float3 l, float4 att)\n    {\n        return powr(saturate(length(l) * att.x + att.y), att.z);\n    }\n\n    float dist_attenuation(float3 unnormalized_l, vfx_light light)\n    {\n#ifdef USE_PBR\n        return pbr_dist_attenuation(unnormalized_l, light.parameters.omni.attenuationFactors.w);\n        \n        \n#else\n#ifdef USE_SHADOWONLY\n        return 1.f;\n#endif\n        return non_pbr_dist_attenuation(unnormalized_l, light.parameters.omni.attenuationFactors);\n#endif\n    }\n\n    float spot_attenuation(float3 l, vfx_light light)\n    {\n#ifdef USE_SHADOWONLY\n        return 1.f;\n#endif\n        \n        return saturate(dot(l, light.dir) * light.parameters.spot.scaleBias.x + light.parameters.spot.scaleBias.y);\n    }\n\n    void shade_modulate(float3 l, float4 color, float intensity)\n    {\n        constexpr half3 white = half3(1.h);\n        \n        modulate *= float3(mix(white, half3(color.rgb), half(color.a * intensity)));\n    }\n\n#ifdef USE_GOBO\n    float3 gobo(float3 pos, vfx_light light, texture2d<half> goboTexture, sampler goboSampler)\n    {\n        half3 g = texture2DProj(goboTexture, goboSampler, (light.shadowMatrix * float4(pos, 1.f))).rgb;\n        return light.color.rgb * float3(mix(1.h, g, half(light.color.a)));\n    }\n#endif\n\n    float shadow_hard(float3 pos, vfx_light light, depth2d<float> shadowMap)\n    {\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n        float4 tile = light.tiles[0];\n#else\n        float4 tile = {0.0, 0.0, 1.0, 1.0};\n#endif\n        float shadow = ComputeShadow(vfx_shadow_sampler, pos, light.shadowMatrix, shadowMap, tile);\n        return 1.f - shadow * light.color.a; \n    }\n\n    \n    float shadow_soft_dynamic(float3 pos, vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel)\n    {\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n        float4 tile = light.tiles[0];\n#else\n        float4 tile = {0.0, 0.0, 1.0, 1.0};\n#endif\n        float4 lightScreen = transformViewPosInShadowSpace(pos, light.shadowMatrix);\n        lightScreen.xyz /= lightScreen.w;\n        float shadow = ComputeSoftShadow(vfx_shadow_sampler, lightScreen.xyz, shadowMap, shadowKernel, light.shadowSampleCount, light.shadowRadius, tile);\n        return 1.f - shadow * light.color.a; \n    }\n\n    float shadow_soft(float3 pos, vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int shadowSampleCount)\n    {\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n        float4 tile = light.tiles[0];\n#else\n        float4 tile = {0.0, 0.0, 1.0, 1.0};\n#endif\n        float4 lightScreen = transformViewPosInShadowSpace(pos, light.shadowMatrix);\n        lightScreen.xyz /= lightScreen.w;\n        float shadow = ComputeSoftShadow(vfx_shadow_sampler, lightScreen.xyz, shadowMap, shadowKernel, shadowSampleCount, light.shadowRadius, tile);\n        return 1.f - shadow * light.color.a; \n    }\n\n    float shadow_pcf_grid(float3 pos, vfx_light light, depth2d<float> shadowMap, int shadowSampleCount)\n    {\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n        float4 tile = light.tiles[0];\n#else\n        float4 tile = {0.0, 0.0, 1.0, 1.0};\n#endif\n        float shadow = ComputeSoftShadowGrid(vfx_shadow_sampler, pos, light.shadowMatrix, shadowMap, shadowSampleCount, tile);\n        return 1.f - shadow * light.color.a; \n    }\n\n\nushort getCubeFace(float3 dir)\n{\n    \n    float3 absDir = abs(dir);\n    float maxAxis = max(absDir.x, max(absDir.y, absDir.z));\n    if (absDir.z == maxAxis) {\n        \n        return dir.z > 0.0f ? 4 : 5;\n    } else if (absDir.y == maxAxis) {\n        \n        return dir.y > 0.0f ? 2 : 3;\n    } else {\n        \n        \n        return dir.x > 0.0f ? 0 : 1;\n    }\n}\n\n\nfloat4x4 getFaceRotation(ushort face) {\n    float4 xAxis(1.0, 0.0, 0.0, 0.0);\n    float4 yAxis(0.0, 1.0, 0.0, 0.0);\n    float4 zAxis(0.0, 0.0, 1.0, 0.0);\n    float4 zero (0.0, 0.0, 0.0, 1.0);\n    switch (face) {\n        case 0: return float4x4(-zAxis, yAxis,  xAxis, zero); \n        case 1: return float4x4( zAxis, yAxis, -xAxis, zero); \n        case 2: return float4x4( xAxis,-zAxis,  yAxis, zero); \n        case 3: return float4x4( xAxis, zAxis, -yAxis, zero); \n        case 4: return float4x4(-xAxis, yAxis, -zAxis, zero); \n        default:  return float4x4( xAxis, yAxis,  zAxis, zero); \n    }\n}\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    float shadow_omni(float3 pos_vs, float3 nrm_vs, vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n#else\n    float shadow_omni(float3 pos_vs, float3 nrm_vs, vfx_light light, depthcube<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n#endif\n    {\n        \n#define USE_TANGENT_SAMPLING 0\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n        float  depthBias = light.parameters.omni.depthBias;\n#else\n        float2 scaleBias = light.parameters.omni.shadowScaleBias.xy;\n        float  depthBias = light.parameters.omni.shadowScaleBias.z;\n#endif\n\n        \n        pos_vs += nrm_vs * depthBias;\n\n        \n        float4 pos_ls = (light.shadowMatrix * float4(pos_vs, 1.f));\n\n#if !CFX_USE_ATLAS_FOR_SHADOW_MAP\n        \n        float z_lin = vfx::reduce_max(abs(pos_ls));\n\n        \n        \n        \n        \n        float z_ndc = (z_lin * scaleBias.x + scaleBias.y) / z_lin - depthBias;\n#endif\n\n        \n        float shadow;\n        if (sampleCount <= 1) {\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n            ushort face = getCubeFace(normalize(pos_ls.xyz));\n            float4 tile = light.tiles[face];\n            shadow = ComputeShadow(vfx_shadow_sampler, (getFaceRotation(face) * pos_ls).xyz, light.parameters.omni.projection, shadowMap, tile);\n#else\n            shadow = shadowMap.sample_compare(vfx_shadow_sampler, pos_ls.xyz, z_ndc);\n#endif\n        } else {\n\n            \n            float filteringSizeFactor = light.shadowRadius;\n\n#if USE_TANGENT_SAMPLING\n            float3 tgt_x, tgt_y;\n            vfx::orthogonal_basis(pos_ls, tgt_x, tgt_y);\n#else\n            float3 nrm_ls = (light.shadowMatrix * float4(nrm_vs, 0.f)).xyz;\n#endif\n\n            \n            float totalAccum = 0.0;\n            for(int i=0; i < sampleCount; i++){\n\n#if USE_TANGENT_SAMPLING\n                float2 scale = shadowKernel[i].xy * filteringSizeFactor * 2.f;\n                float3 smp_ls = pos_ls.xyz + tgt_x * scale.x + tgt_y * scale.y;\n#else\n                float3 smp_ls = pos_ls.xyz + vfx::randomHemisphereDir(nrm_ls, shadowKernel[i].xy * 0.5 + 0.5) * filteringSizeFactor;\n#endif\n\n                \n                \n                \n\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n                ushort face = getCubeFace(normalize(smp_ls.xyz));\n                float4 tile = light.tiles[face];\n                totalAccum += ComputeShadow(vfx_shadow_sampler, (getFaceRotation(face) * float4(smp_ls, 1.0)).xyz, light.parameters.omni.projection, shadowMap, tile);\n#else\n                totalAccum += shadowMap.sample_compare(vfx_shadow_sampler, smp_ls, z_ndc);\n#endif\n\n            }\n            shadow = totalAccum / float(sampleCount);\n        }\n\n        return 1.f - shadow * light.color.a; \n    }\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    float shadow_cascaded(float3 pos, constant vfx_light& light, depth2d<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount)\n    {\n        float shadow = ComputeCascadedShadow(vfx_shadow_sampler, pos, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius, light.tiles).a;\n        return 1.f - shadow * light.color.a; \n    }\n#else\n    float shadow_cascaded(float3 pos, constant vfx_light& light, depth2d_array<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount)\n    {\n        float shadow = ComputeCascadedShadow(vfx_shadow_sampler, pos, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius).a;\n        return 1.f - shadow * light.color.a; \n    }\n#endif\n\n    \n\n    void add_directional(vfx_light light)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n#ifdef USE_GOBO\n    void add_directional_gobo(vfx_light light, texture2d<half> goboTexture, sampler goboSampler)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n#endif\n\n    \n    void add_directional_hard_shadows(vfx_light light, depth2d<float> shadowMap)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        intensity *= shadow_hard(surface.position, light, shadowMap);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n    void add_directional_soft_shadows_dynamic(vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        intensity *= shadow_soft_dynamic(surface.position, light, shadowMap, shadowKernel);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    void add_directional_soft_shadows(vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        intensity *= shadow_soft(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    void add_directional_pcf_grid_shadows(vfx_light light, depth2d<float> shadowMap, int sampleCount)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        intensity *= shadow_pcf_grid(surface.position, light, shadowMap, sampleCount);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    void add_directional_cascaded_shadows(constant vfx_light& light, depth2d<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount, bool debugCascades)\n#else\n    void add_directional_cascaded_shadows(constant vfx_light& light, depth2d_array<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount, bool debugCascades)\n#endif\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        if (debugCascades) {\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n            float4 shadowDebug = ComputeCascadedShadow(vfx_shadow_sampler, surface.position, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius, light.tiles);\n#else\n            float4 shadowDebug = ComputeCascadedShadow(vfx_shadow_sampler, surface.position, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius);\n#endif\n            intensity *= (1.f - shadowDebug.a);\n            shade(light.dir, light.color.rgb, intensity);\n            diffuse.rgb = mix(diffuse.rgb, shadowDebug.rgb, light.color.a);\n        } else {\n            intensity *= shadow_cascaded(surface.position, light, shadowMaps, cascadeCount, blendCascade, shadowKernel, sampleCount);\n            shade(light.dir, light.color.rgb, intensity);\n        }\n    }\n\n    \n\n    void add_omni(vfx_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        shade(l, light.color.rgb, dist_attenuation(unnormalized_l, light) * BoostFactor);\n    }\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    void add_omni_soft_shadows(vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n#else\n    void add_omni_soft_shadows(vfx_light light, depthcube<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n#endif\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light) * BoostFactor;\n        intensity *= shadow_omni(surface.position, surface.normal, light, shadowMap, shadowKernel, sampleCount);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    void add_local_omni(vfx_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        shade(l, light.color.rgb, dist_attenuation(unnormalized_l, light) * BoostFactor);\n    }\n\n    \n\n    void add_spot(vfx_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light) * BoostFactor;\n        intensity      *= spot_attenuation(l, light);\n        shade(l, light.color.rgb, intensity);\n    }\n\n#ifdef USE_GOBO\n    void add_spot_gobo(vfx_light light, texture2d<half> goboTexture, sampler goboSampler)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light) * BoostFactor;\n        intensity      *= spot_attenuation(l, light);\n        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);\n\n        \n        \n        \n              shade(l, light.color.rgb, intensity);\n        \n    }\n#endif\n\n    void add_local_spot(vfx_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light) * BoostFactor;\n        intensity      *= spot_attenuation(l, light);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    \n    void add_spot_soft_shadows(vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light) * BoostFactor;;\n        intensity      *= spot_attenuation(l, light);\n        intensity      *= shadow_soft(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        shade(l, light.color.rgb, intensity);\n    }\n    \n#ifdef USE_GOBO\n    void add_spot_gobo_soft_shadows(vfx_light light,\n                                    depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount,\n                                    texture2d<half> goboTexture, sampler goboSampler)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= spot_attenuation(l, light);\n        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);\n        shade(l, light.color.rgb, intensity);\n    }\n#endif\n\n    \n\n#ifdef USE_PBR\n\n    \n\n#ifdef CFX_SUPPORT_CUBE_ARRAY\n    void add_local_probe(vfx_light light, texturecube_array<half> probeTextureArray)\n#else\n    void add_local_probe(vfx_light light, texture2d_array<half> probeTextureArray)\n#endif\n    {\n#if !PROBES_NORMALIZATION\n        if (probeRadianceRemainingFactor <= 0.f)\n            return;\n#endif\n\n        bool parallaxCorrection = light.parameters.probe.parallaxCorrection;\n        int    probeIndex       = light.parameters.probe.index;\n        float3 probeExtents     = light.parameters.probe.halfExtents.xyz;\n        float  blendDist        = light.parameters.probe.halfExtents.w;\n        float3 probeOffset      = light.parameters.probe.offset;\n        float3 parallaxExtents  = light.parameters.probe.parallaxExtents;\n        float3 parallaxCenter   = light.parameters.probe.parallaxCenter;\n\n        float3 n = surface.normal;\n        float3 v = surface.view;\n        float3 r = reflect(-v, n); \n\n        float3 specDir = vfx::mat4_mult_float3(light.shadowMatrix, r);\n\n        \n        float3 pos_ls = (light.shadowMatrix * float4(surface.position, 1.f)).xyz;\n\n        \n        float3 d = abs(pos_ls) - probeExtents;\n#if PROBES_OUTER_BLENDING\n        if (any(d > blendDist))\n#else\n        if (any(d > 0.f))\n#endif\n        {\n            return;\n        }\n\n#if PROBES_NORMALIZATION\n        \n        \n#if PROBES_OUTER_BLENDING\n        float3 nd = saturate(-(d / blendDist) * 0.5f + 0.5f);\n#else\n        float3 nd = saturate(-(d / blendDist));\n#endif\n        float probeFactor = (nd.x * nd.y * nd.z) * light.color.r;\n#else\n        \n        float sd = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n#if PROBES_OUTER_BLENDING\n        float probeFactor = saturate(1.f - sd / blendDist);\n#else\n        float probeFactor = saturate(-sd / blendDist);\n#endif\n        \n        \n        \n        probeFactor *= probeRadianceRemainingFactor * light.color.r; \n#endif\n\n        if (parallaxCorrection ) {\n            \n            float3 pos_off = pos_ls + parallaxCenter;\n            float3 t1 = ( parallaxExtents - pos_off) / specDir;\n            float3 t2 = (-parallaxExtents - pos_off) / specDir;\n            float3 tmax = max(max(0, t1), t2); \n            float t = min(tmax.x, min(tmax.y, tmax.z));\n\n            \n            float3 hit_ls = pos_ls + specDir * t;\n            specDir = hit_ls - probeOffset;\n        }\n\n        \n        specDir.z *= -1.0;\n        \n        \n        \n        float ao = surface.ambientOcclusion;\n#ifdef USE_BENTNORMALS\n        ao = mix(mix(max(dot(surface.bentNormal, r), 0.), 1., ao), ao, surface.roughness*surface.roughness);\n#endif\n        \n        float mipd = float(probeTextureArray.get_num_mip_levels()) - 1.f;\n        const float intensity = ao * probeFactor;\n\n        float mips = surface.roughness * mipd;\n#ifdef CFX_SUPPORT_CUBE_ARRAY\n        float3 LD = float3(probeTextureArray.sample(vfx_lighting::linearSampler, specDir, probeIndex, level(mips)).rgb);\n#else\n        float2 specUV = vfx::dual_paraboloid_from_cartesian(normalize(specDir));\n        float3 LD = float3(probeTextureArray.sample(vfx_lighting::linearSampler, specUV, probeIndex, level(mips)).rgb);\n#endif\n\n        \n\n        \n#if PROBES_NORMALIZATION\n        probesWeightedSum += float4(LD * intensity * pbr.probeReflectance, probeFactor);\n#else\n        probeRadianceRemainingFactor = saturate(probeRadianceRemainingFactor - probeFactor);\n#ifdef DISABLE_SPECULAR\n        pbr.envDiffuse += LD * intensity * pbr.probeReflectance;\n#else\n        pbr.envSpecular += LD * intensity * pbr.probeReflectance;\n#endif\n#endif\n        \n#ifdef USE_CLEARCOAT\n        n = surface.clearCoatNormal;\n        r = reflect(-v, n);\n        specDir = vfx::mat4_mult_float3(light.shadowMatrix, r);\n        \n        specDir.z *= -1.0;\n        if (parallaxCorrection ) {\n            float3 pos_off = pos_ls + parallaxCenter;\n            \n            float3 t1 = ( parallaxExtents - pos_off) / specDir;\n            float3 t2 = (-parallaxExtents - pos_off) / specDir;\n            float3 tmax = max(max(0, t1), t2); \n            float t = min(tmax.x, min(tmax.y, tmax.z));\n            \n            \n            float3 hit_ls = pos_ls + specDir * t;\n            specDir = hit_ls - probeOffset;\n        }\n        mips = surface.clearCoatRoughness * mipd;\n#ifdef CFX_SUPPORT_CUBE_ARRAY\n        LD = float3(probeTextureArray.sample(vfx_lighting::linearSampler, specDir, probeIndex, level(mips)).rgb);\n#else\n        specUV = vfx::dual_paraboloid_from_cartesian(normalize(specDir));\n        LD = float3(probeTextureArray.sample(vfx_lighting::linearSampler, specUV, probeIndex, level(mips)).rgb);\n#endif\n#if PROBES_NORMALIZATION\n        probesWeightedSum += float4(LD * intensity * pbr.probeReflectanceClearCoat, probeFactor) * surface.clearCoat;\n#else\n\n#ifdef DISABLE_SPECULAR\n        pbr.envDiffuse += LD * intensity * pbr.probeReflectanceClearCoat  * surface.clearCoat;\n#else\n        specular += LD * intensity * pbr.probeReflectanceClearCoat  * surface.clearCoat;\n#endif\n#endif\n#endif\n    }\n\n    void add_global_probe(float4x4 localDirToWorldCubemapDir,\n                          float environmentIntensity,\n#ifdef CFX_SUPPORT_CUBE_ARRAY\n                          texturecube_array<half> probeTextureArray\n#else\n                          texture2d_array<half> probeTextureArray\n#endif\n                          )\n    {\n        float3 n = surface.normal;\n        float3 v = surface.view;\n        float3 r = reflect(-v, n); \n        \n        float3 specDir = vfx::mat4_mult_float3(localDirToWorldCubemapDir, r);\n        float mips = surface.roughness * float(probeTextureArray.get_num_mip_levels() - 1);\n        \n#ifdef CFX_SUPPORT_CUBE_ARRAY\n        float3 LD = float3(probeTextureArray.sample(vfx_lighting::linearSampler, specDir, 0, level(mips)).rgb);\n#else\n        float2 specUV = vfx::dual_paraboloid_from_cartesian(normalize(specDir));\n        float3 LD = float3(probeTextureArray.sample(vfx_lighting::linearSampler, specUV, 0, level(mips)).rgb);\n#endif\n        \n        \n        specular += pbr.probeReflectance * LD * surface.ambientOcclusion * environmentIntensity;\n    }\n\n    void add_global_probe(texturecube<float, access::sample> specularLD,\n                          float4x4                           localDirToWorldCubemapDir,\n                          float                              environmentIntensity)\n    {\n        float3 n        = surface.normal;\n        float3 v        = surface.view;\n        float3 r        = reflect(-v, n); \n        float roughness = surface.roughness;\n\n#if USE_PBR_DOMINANT_DIRECTION\n        float alpha = roughness * roughness;\n        float smoothness = 1.0f - alpha;\n        \n        float specularLerpFactor = (1. - smoothness * (sqrt(smoothness) + alpha));\n        \n        float3 specularDominantNDirection = mix(r, n, specularLerpFactor); \n#else\n        float3 specularDominantNDirection = r;\n#endif\n        \n        float ao = surface.ambientOcclusion;\n        \n        \n        \n#ifdef USE_BENTNORMALS\n        ao = mix(mix(max(dot(surface.bentNormal, r), 0.), 1., ao), ao, roughness*roughness);\n#endif\n        \n        \n#ifdef USE_RE_RADIANCE_IRRADIANCE_MAP_SAMPLING\n        float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);\n#else\n        float mipLevel = sqrt(roughness) * float(specularLD.get_num_mip_levels() - 1);\n#endif\n        float3 dir = vfx::mat4_mult_float3(localDirToWorldCubemapDir, specularDominantNDirection);\n        float3 LD = specularLD.sample(vfx_lighting::linearSampler, dir, level(mipLevel)).rgb;\n        pbr.envSpecular += pbr.probeReflectance * LD * ao * environmentIntensity;\n    }\n\n#ifdef USE_CLEARCOAT\n    void add_global_probeClearCoat(texturecube<float, access::sample> specularLD,\n                          float4x4                           localDirToWorldCubemapDir,\n                          float                              environmentIntensity)\n    {\n        float3 n = surface.clearCoatNormal;\n        \n        float3 v        = surface.view;\n        float3 r        = reflect(-v, n); \n        float roughness = surface.clearCoatRoughness;\n\n        \n        \n        float ao = surface.ambientOcclusion;\n        \n        \n#ifdef USE_BENTNORMALS\n        ao = mix(mix(max(dot(surface.bentNormal, r), 0.), 1., ao), ao, roughness*roughness);\n#endif\n        \n        \n        float mipLevel = sqrt(roughness) * float(specularLD.get_num_mip_levels() - 1);\n        float3 LD = specularLD.sample(vfx_lighting::linearSampler, vfx::mat4_mult_float3(localDirToWorldCubemapDir, r), level(mipLevel)).rgb;\n\n        \n        float Fc = vfx_brdf_F_opt(0.04f, pbr.NoVClearCoat).r * surface.clearCoat;\n        float attenuation = 1.0f - Fc;\n        specular *= (attenuation * attenuation);\n        \n        specular += pbr.probeReflectanceClearCoat * LD  * surface.clearCoat * ao * environmentIntensity;\n    }\n#endif\n    \n    \n\n    void add_irradiance_from_selfIllum()\n    {\n        float selfIlluminationAO = saturate(mix(1.f, surface.ambientOcclusion, pbr.selfIlluminationOcclusion));\n        float3 irradiance = surface.selfIllumination.rgb;\n        \n        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        pbr.envDiffuse += selfIlluminationAO * irradiance * diffuseAlbedo;\n#else\n        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);\n        pbr.envDiffuse += selfIlluminationAO * irradiance * diffuseReflectance;\n#endif\n    }\n\n    void add_global_irradiance_from_sh(float4x4         localDirToWorldCubemapDir,\n#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)\n                                       sh2_coefficients shCoefficients)\n#else\n    sh3_coefficients shCoefficients)\n#endif\n    {\n#ifdef USE_BENTNORMALS\n        float3 n = surface.bentNormal;\n        float ao = surface.aoDirectionnal;\n#else\n        float3 n = surface.normal;\n        float ao = surface.ambientOcclusion;\n#endif\n        float3 n_sh_space = vfx::mat4_mult_float3(localDirToWorldCubemapDir, n);\n        float3 irradiance = shEvalDirection(float4(n_sh_space.xy, -n_sh_space.z, 1.), shCoefficients);\n        \n        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        pbr.envDiffuse += ao * irradiance * diffuseAlbedo;\n#else\n        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);\n        pbr.envDiffuse += ao * irradiance * diffuseReflectance;\n#endif\n    }\n\n    void add_global_irradiance_probe(texturecube<float, access::sample> irradianceTexture,\n                                     float4x4                           localDirToWorldCubemapDir,\n                                     float                              environmentIntensity)\n    {\n#if USE_PBR_DOMINANT_DIRECTION\n#ifdef USE_BENTNORMALS\n        float3 n = surface.bentNormal;\n        float ao = surface.aoDirectionnal;\n#else\n        float3 n = surface.normal;\n        float ao = surface.ambientOcclusion;\n#endif\n        float3 v = surface.view;\n        \n        \n        const half a = 1.02341h * surface.roughness - 1.51174h; \n        const half b = -0.511705h * surface.roughness + 0.755868h;\n        const half diffuseBendFactor = saturate((pbr.NoV * a + b) * surface.roughness);\n        float3 diffuseDominantNDirection = mix(n, v, diffuseBendFactor);\n#else\n        float3 diffuseDominantNDirection = n;\n#endif\n        \n        float3 n_cube_space = vfx::mat4_mult_float3(localDirToWorldCubemapDir, diffuseDominantNDirection);\n        float3 irradiance = irradianceTexture.sample(vfx_lighting::linearSampler, n_cube_space).rgb;\n        \n        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);\n        \n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        pbr.envDiffuse += (ao * environmentIntensity) * irradiance * diffuseAlbedo;\n#else\n        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);\n        pbr.envDiffuse += (ao * environmentIntensity) * irradiance * diffuseReflectance;\n#endif\n    }\n\n#endif \n\n#ifdef USE_IES_LIGHT\n    \n\n    static constexpr sampler iesSampler = sampler(filter::linear, mip_filter::none, address::clamp_to_edge);\n    \n    float ies_attenuation(float3 l, vfx_light light, texture2d<half> iesTexture)\n    {\n#if USE_QUAT_FOR_IES\n        float3 v    = vfx::quaternion_rotate_vector(light.parameters.ies.light_from_view_quat, -l);\n#else\n        float3 v    = vfx::matrix_rotate(light.parameters.ies.light_from_view, -l);\n#endif\n        float phi   = (v.z * light.parameters.ies.scaleBias.x + light.parameters.ies.scaleBias.y);\n        float theta = atan2(v.y, v.x) * 0.5f * M_1_PI_F;\n        return iesTexture.sample(iesSampler, float2(phi, abs(theta))).r;\n    }\n\n    void add_ies(vfx_light light, texture2d<half> iesTexture)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= ies_attenuation(l, light, iesTexture);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    void add_ies_soft_shadows(vfx_light light, texture2d<half> iesTexture, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= ies_attenuation(l, light, iesTexture);\n        intensity      *= shadow_soft(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        shade(l, light.color.rgb, intensity);\n    }\n#endif\n\n#ifdef USE_AREA_LIGHT\n    \n\n    void add_area_rectangle(vfx_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n        float3 v = surface.view;\n        float3 n = surface.normal;\n        float3 p = surface.position;\n\n        \n        float3 tangent = normalize(v - n * dot(v, n));\n        float3 bitangent = cross(n, tangent);\n        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));\n\n        float3 lightCenter = light.shadowMatrix[3].xyz;\n        \n        \n        float sidedness = dot(light.dir, lightCenter - p);\n        if (light.parameters.area.rectangle.doubleSided == false && sidedness <= 0.f)\n            return;\n        \n        float3 lightRight = light.shadowMatrix[0].xyz * light.parameters.area.rectangle.halfExtents.x * sign(sidedness);\n        float3 lightTop   = light.shadowMatrix[1].xyz * light.parameters.area.rectangle.halfExtents.y;\n        \n        float4x3 cornerDirections = float4x3((lightCenter + lightRight + lightTop) - p,\n                                             (lightCenter + lightRight - lightTop) - p,\n                                             (lightCenter - lightRight - lightTop) - p,\n                                             (lightCenter - lightRight + lightTop) - p);\n\n        cornerDirections[0] = shadingSpaceTransform * cornerDirections[0];\n        cornerDirections[1] = shadingSpaceTransform * cornerDirections[1];\n        cornerDirections[2] = shadingSpaceTransform * cornerDirections[2];\n        cornerDirections[3] = shadingSpaceTransform * cornerDirections[3];\n\n        float diffuseAmount = pbr_area_light_eval_rectangle(cornerDirections);\n\n        float brdfNorm = 1.f;\n        float3x3 inverseLTCMatrix = vfx_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);\n\n        cornerDirections[0] = inverseLTCMatrix * cornerDirections[0];\n        cornerDirections[1] = inverseLTCMatrix * cornerDirections[1];\n        cornerDirections[2] = inverseLTCMatrix * cornerDirections[2];\n        cornerDirections[3] = inverseLTCMatrix * cornerDirections[3];\n\n        float specularAmount = brdfNorm * pbr_area_light_eval_rectangle(cornerDirections);\n\n        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); \n        \n        float3 lightColor = light.color.rgb;\n        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;\n        specular += specularAmount * lightColor * pbr.reflectance;\n#endif\n    }\n\n    void add_area_polygon(vfx_light light, texture2d_array<float> bakedDataTexture, device packed_float2 *vertexPositions)\n    {\n#ifdef USE_PBR\n        float3 v = surface.view;\n        float3 n = surface.normal;\n        float3 p = surface.position;\n\n        \n        float3 tangent = normalize(v - n * dot(v, n));\n        float3 bitangent = cross(n, tangent);\n        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));\n\n        float3 lightCenter = light.shadowMatrix[3].xyz;\n        \n        \n        float sidedness = dot(light.dir, lightCenter - p);\n        if (light.parameters.area.polygon.doubleSided == false && sidedness <= 0.f)\n            return;\n        \n        float3 lightRight = light.shadowMatrix[0].xyz * sign(sidedness);\n        float3 lightTop   = light.shadowMatrix[1].xyz;\n\n        p           = shadingSpaceTransform * p;\n        lightCenter = shadingSpaceTransform * lightCenter;\n        lightRight  = shadingSpaceTransform * lightRight;\n        lightTop    = shadingSpaceTransform * lightTop;\n\n        float diffuseAmount = pbr_area_light_eval_polygon(p, lightCenter, lightRight, lightTop, light.parameters.area.polygon.vertexCount, vertexPositions);\n\n        float brdfNorm = 1.f;\n        float3x3 inverseLTCMatrix = vfx_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);\n\n        p           = inverseLTCMatrix * p;\n        lightCenter = inverseLTCMatrix * lightCenter;\n        lightRight  = inverseLTCMatrix * lightRight;\n        lightTop    = inverseLTCMatrix * lightTop;\n\n        float specularAmount = brdfNorm * pbr_area_light_eval_polygon(p, lightCenter, lightRight, lightTop, light.parameters.area.polygon.vertexCount, vertexPositions);\n        \n        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); \n\n        float3 lightColor = light.color.rgb;\n        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;\n        specular += specularAmount * lightColor * pbr.reflectance;\n#endif\n    }\n\n    void add_area_line(vfx_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n        float3 v = surface.view;\n        float3 n = surface.normal;\n        float3 p = surface.position;\n\n        \n        float3 tangent = normalize(v - n * dot(v, n));\n        float3 bitangent = cross(n, tangent);\n        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));\n\n        float3 lightCenter = light.shadowMatrix[3].xyz;\n        float3 lightRight  = light.shadowMatrix[0].xyz * light.parameters.area.line.halfLength;\n\n        float2x3 cornerDirections = float2x3((lightCenter + lightRight) - p,\n                                             (lightCenter - lightRight) - p);\n\n        cornerDirections[0] = shadingSpaceTransform * cornerDirections[0];\n        cornerDirections[1] = shadingSpaceTransform * cornerDirections[1];\n\n        float diffuseAmount = pbr_area_light_eval_line(cornerDirections);\n\n        float brdfNorm = 1.f;\n        float3x3 inverseLTCMatrix = vfx_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);\n\n        cornerDirections[0] = inverseLTCMatrix * cornerDirections[0];\n        cornerDirections[1] = inverseLTCMatrix * cornerDirections[1];\n\n        float specularAmount = brdfNorm * pbr_area_light_eval_line(cornerDirections);\n\n        float3 ortho = normalize(cross(cornerDirections[0], cornerDirections[1]));\n        float ltcWidthFactor = 1.0 / length(vfx_ltc_matrix_invert_transpose(inverseLTCMatrix) * ortho);\n        specularAmount *= ltcWidthFactor;\n        \n        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); \n\n        float3 lightColor = light.color.rgb;\n        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;\n        specular += specularAmount * lightColor * pbr.reflectance;\n#endif\n    }\n\n    void add_area_ellipse(vfx_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n#endif\n    }\n\n    void add_area_ellipsoid(vfx_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n#endif\n    }\n#endif\n};\n\n#endif \n"
+ "-[VFXMTLMorphDeformer setupMorphTargetsWithComputeContext:]_block_invoke"
+ "@24@0:8^{__CFXCoreEntityHandle={__CFXEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__CFXWorld}q}^{__CFString}^{__CFDictionary}^{__CFArray}iB^v}16"
+ "CFXWorldHasOptions(_world, CFXWorldCreationOptionDisableVFXCoreFeatures) == false"
+ "Error: CFXAnimationManagerRemoveAllAnimationsForObject - null animation for key %@"
+ "Error: Can't build content (with data %@ and count %d) for mesh source %@"
+ "Error: Can't build content (with data length %zu and offset %llu) for mesh source %@"
+ "Error: asking for entityObject on a presentation coreEntityHandle, should use entityhHelper instead"
+ "Error: can't copy a presentation core entity handle"
+ "Info: [Deformers] %s | Normal source: %@"
+ "Info: [Deformers] %s | Position source: %@"
+ "T@\"VFXNode\",W,N,V_ownerNode"
+ "T@\"_TtC3VFX20EntityPropertyHelper\",R,N"
+ "T@,N,R"
+ "USE_AREA_LIGHT"
+ "USE_CR_WORLD_POSITION"
+ "USE_GOBO"
+ "USE_IES_LIGHT"
+ "Unreachable code: [Deformers] Morph target \"%@\" at index %d for \"%@\" failed at `CFXNumberOfPackedSparseVertices`"
+ "Welcome to VFX 203.0.22.0.2 (Jul 11 2025 21:29:09)"
+ "_ownerNode"
+ "_runtimeAuthoringGraphCopy"
+ "commonInit:"
+ "initPresentationWithEntityHandle:"
+ "initWithCoreEntityHandleRef:"
+ "opaqueEntityHelper"
+ "ownerNode"
+ "prepareForLoad"
+ "presentationBehaviorGraphWithEntityHandle:"
+ "presentationHandleWithCFXCoreEntityHandle:"
+ "presentationLock"
+ "presentationParticleColliderWithEntityHandle:"
+ "presentationParticleEmitterWithEntityHandle:"
+ "setOwnerNode:"
+ "\x81"
- "\t_lightingContribution.add_directional(vfx_lights[%@], %s);\n"
- "\t_lightingContribution.add_directional(vfx_lights[%@], %s, %d, %s, u_shadowKernel, %d, %s);\n"
- "\t_lightingContribution.add_directional(vfx_lights[%@], %s, u_shadowKernel, %d);\n"
- "\t_lightingContribution.add_directional(vfx_lights[%@], u_goboTexture%d, u_goboTexture%dSampler);\n"
- "\t_lightingContribution.add_ies(vfx_lights[%@], u_iesTexture%d, %s, u_shadowKernel, %d);\n"
- "\t_lightingContribution.add_omni(vfx_lights[%@], %s, u_shadowKernel, %d);\n"
- "\t_lightingContribution.add_spot(vfx_lights[%@], %s, u_shadowKernel, %d);\n"
- "\t_lightingContribution.add_spot(vfx_lights[%@], u_goboTexture%d, u_goboTexture%dSampler);\n"
- "\t_lightingContribution.add_spot(vfx_lights[%@], u_shadowTexture%d, u_shadowKernel, %d, u_goboTexture%d, u_goboTexture%dSampler);\n"
- "\n#pragma mark - Includes begin\n\n#import <metal_stdlib>\n\nusing namespace metal;\n\n#import \"vfx_metal\"\n#import \"vfx_util.h\"\n#import \"CFX-PBR.metal\"\n\n#ifdef USE_RE_SYSTEM_TREATMENTS\n#import \"vfx_re_shaders.h\"\n#import \"vfx_re_shaders_internal.h\"\n#import \"vfx_render_options.h\"\n#import \"vfx_shader_api_v2.h\"\n#endif \n\n#pragma mark - Includes end\n\n#pragma mark - Namespace Begin\n\n\n#import \"vfx_shadowmap_util.h\"\n#import \"vfx_tessellation.h\"\n\n\n\n\n#ifdef USE_LAYERED_RENDERING\n#define texture2d_layer texture2d_array\n#define sampleLayer(a,b) sample(a,b,in.sliceIndex)\n#else\n#define texture2d_layer texture2d\n#define sampleLayer(a,b) sample(a,b)\n#endif\n\n#ifdef CFX_USE_TEXTURE_FOR_LIGHT_INDICES\n#define LightIndex(lid) u_lightIndicesTexture.read((ushort)lid).x\n#else\n#define LightIndex(lid) u_lightIndicesBuffer[lid]\n#endif\n\n#ifdef IS_BEZIER_CURVE\n[[visible]] bool vfx_is_inside_bezier_curve(float2 p, device void const* curveData, device packed_float3 const* controlPoints);\n[[visible]] float vfx_distance_to_bezier_curve(float2 p, thread float2& directionToCurve, float maximumDistance, device void const* curveData, device packed_float3 const* controlPoints);\n#endif\n\n#ifdef USE_GBUFFER_OUTPUT\n    #undef USE_PER_VERTEX_LIGHTING\n    #undef USE_PER_PIXEL_LIGHTING\n    #undef USE_LIGHTING\n#endif\n\n\n\ntypedef struct {\n\n#ifdef USE_MODELTRANSFORM\n    float4x4 modelTransform;\n#endif\n#ifdef USE_INVERSEMODELTRANSFORM\n    float4x4 inverseModelTransform;\n#endif\n#ifdef USE_MODELVIEWTRANSFORM\n    float4x4 modelViewTransform;\n#endif\n#ifdef USE_INVERSEMODELVIEWTRANSFORM\n    float4x4 inverseModelViewTransform;\n#endif\n#ifdef USE_NORMALTRANSFORM\n    float4x4 normalTransform;\n#endif\n#ifdef USE_INVERSEMODELVIEWPROJECTIONTRANSFORM\n    float4x4 inverseModelViewProjectionTransform;\n#endif\n#ifdef USE_MODELVIEWPROJECTIONTRANSFORM\n    float4x4 modelViewProjectionTransform;\n#endif\n#ifdef USE_LASTFRAMETRANSFORM\n    float4x4 lastFrameModelTransform;\n#endif\n#ifdef USE_MOTIONBLUR\n    float motionBlurIntensity;\n#endif\n#ifdef USE_BOUNDINGBOX\n    float2x3 boundingBox;\n#endif\n#ifdef USE_WORLDBOUNDINGBOX\n    float2x3 worldBoundingBox;\n#endif\n#ifdef USE_NODE_OPACITY\n    float nodeOpacity;\n#endif\n#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)\n    sh2_coefficients shCoefficients;\n#elif defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 3)\n    sh3_coefficients shCoefficients;\n#endif\n#ifdef USE_CLUSTERED_LIGHTING\n    uint8_t categoryBitmask;\n#endif\n} commonprofile_node;\n\nstatic commonprofile_node compute_view_dependant_uniforms(device commonprofile_node& vfx_node, constant VFXWorldBuffer& vfx_frame) {\n    \n#ifdef USE_LATE_LATCHING\n#ifdef USE_MODELVIEWTRANSFORM\n    vfx_node.modelViewTransform = vfx_frame.viewTransform * vfx_node.modelTransform;\n#endif\n#if defined(USE_INVERSEMODELVIEWTRANSFORM) || defined(USE_NORMALTRANSFORM)\n    vfx_node.inverseModelViewTransform = vfx_node.inverseModelTransform * vfx_frame.inverseViewTransform;\n#endif\n#ifdef USE_NORMALTRANSFORM\n    vfx_node.normalTransform = transpose(vfx_node.inverseModelViewTransform);\n#endif\n#ifdef USE_MODELVIEWPROJECTIONTRANSFORM\n    vfx_node.modelViewProjectionTransform = vfx_frame.viewProjectionTransform * vfx_node.modelTransform;\n#endif\n#ifdef USE_INVERSEMODELVIEWPROJECTIONTRANSFORM\n    vfx_node.inverseModelViewProjectionTransform = vfx_node.inverseModelTransform * vfx_frame.inverseViewProjectionTransform;\n#endif\n#endif \n    return vfx_node;\n}\n\ntypedef struct {\n    float3 position         [[attribute(VFXVertexSemanticPosition)]];\n#ifdef HAS_NORMAL\n    float3 normal           [[attribute(VFXVertexSemanticNormal)]];\n#endif\n#ifdef USE_TANGENT\n    float4 tangent          [[attribute(VFXVertexSemanticTangent)]];\n#endif\n#ifdef USE_VERTEX_COLOR\n    float4 color            [[attribute(VFXVertexSemanticColor)]];\n#endif\n#if defined(NEED_IN_TEXCOORD0) || defined(DEBUG_PIXEL)\n    float2 texcoord0        [[attribute(VFXVertexSemanticTexcoord0)]];\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    float2 texcoord1        [[attribute(VFXVertexSemanticTexcoord1)]];\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    float2 texcoord2        [[attribute(VFXVertexSemanticTexcoord2)]];\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    float2 texcoord3        [[attribute(VFXVertexSemanticTexcoord3)]];\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    float2 texcoord4        [[attribute(VFXVertexSemanticTexcoord4)]];\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    float2 texcoord5        [[attribute(VFXVertexSemanticTexcoord5)]];\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    float2 texcoord6        [[attribute(VFXVertexSemanticTexcoord6)]];\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    float2 texcoord7        [[attribute(VFXVertexSemanticTexcoord7)]];\n#endif\n} vfx_vertex_t; \n\ntypedef struct {\n    float4 fragmentPosition [[position]]; \n#ifdef USE_POINT_RENDERING\n    float fragmentSize [[point_size]];\n#endif\n#ifdef USE_VERTEX_COLOR\n    float4 vertexColor;\n#endif\n#ifdef USE_PER_VERTEX_LIGHTING\n    float3 diffuse;\n#ifdef USE_SPECULAR\n    float3 specular;\n#endif\n#ifdef USE_CLEARCOAT\n    float clearCoat;\n#endif\n#ifdef USE_CLEARCOATROUGHNESS\n    float clearCoatRoughness;\n#endif\n#ifdef USE_CLEARCOATNORMAL\n    float clearCoatNormal;\n#endif\n#endif\n#if defined(USE_POSITION) && (USE_POSITION == 2)\n    float3 position;\n#endif\n#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)\n    float3 normal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    float3 tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    float3 bitangent;\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n    float2 displacementTexcoord;   \n#endif\n#ifdef USE_CLEARCOAT_MAP\n    float2 clearCoatTexcoord;   \n#endif\n#ifdef USE_CLEARCOATROUGHNESS_MAP\n    float2 clearCoatRoughnessTexcoord;   \n#endif\n#ifdef USE_CLEARCOATNORMAL_MAP\n    float2 clearCoatNormalTexcoord;   \n#endif\n#ifdef USE_NODE_OPACITY\n    float nodeOpacity;\n#endif\n#ifdef USE_TEXCOORD\n    __TexcoordDecl__\n#endif\n    \n#ifdef USE_EXTRA_VARYINGS\n    __ExtraVaryingsDecl__\n#endif\n#ifdef USE_LASTFRAMETRANSFORM\n    float3 mv_lastFragment;\n    float3 mv_fragment;\n#endif\n#ifdef USE_OUTLINE\n    float outlineHash [[ flat ]];\n#endif\n#ifdef USE_INSTANCING\n    uint   instanceID [[ flat ]];\n#endif\n#ifndef USE_VERTEX_AMPLIFICATION \n#ifdef USE_LAYERED_RENDERING\n    uint   sliceIndex [[render_target_array_index]];\n#endif\n#ifdef USE_MULTIPLE_VIEWPORTS_RENDERING\n    uint   sliceIndex [[viewport_array_index]];\n#endif\n#endif\n#if DEBUG_PIXEL\n    float2 uv0;\n#endif\n#if USE_SCREEN_UV\n    float2 screen_uv [[ center_no_perspective ]];\n#endif\n#ifdef USE_CR_WORLD_POSITION\n    float3 crworldPosition;\n#endif\n} commonprofile_io;\n\n\n#ifdef USE_SHADER_MODIFIERS\n__ShaderModifiersDecl__\n#endif\n\n\n#import \"CFX-Lighting.metal\"\n\nenum CFXColorMask {\n    kCFXColorMaskRed    = 0x1 << 3,\n    kCFXColorMaskGreen  = 0x1 << 2,\n    kCFXColorMaskBlue   = 0x1 << 1,\n    kCFXColorMaskAlpha  = 0x1 << 0\n};\n\ninline float4 colorFromMask(float4 col, int mask)\n{\n    switch (mask) {\n\n        case kCFXColorMaskRed:                      return col.r;\n        case kCFXColorMaskRed|kCFXColorMaskGreen:   return float4(col.rg, 0.f, 1.f);\n        case kCFXColorMaskRed|kCFXColorMaskBlue:    return float4(col.rb, 0.f, 1.f);\n        case kCFXColorMaskRed|kCFXColorMaskAlpha:   return float4(col.ra, 0.f, 1.f);\n\n        case kCFXColorMaskGreen:                    return col.g;\n        case kCFXColorMaskGreen|kCFXColorMaskBlue:  return float4(col.bg, 0.f, 1.f);\n        case kCFXColorMaskGreen|kCFXColorMaskAlpha: return float4(col.ag, 0.f, 1.f);\n\n        case kCFXColorMaskBlue:     return col.b;\n        case kCFXColorMaskBlue|kCFXColorMaskAlpha:  return float4(col.ab, 0.f, 1.f);\n\n        case kCFXColorMaskAlpha:    return col.a;\n    }\n    return col;\n}\n\n#ifndef USE_PBR\n\ninline float3 illuminate(VFXShaderSurface surface, VFXShaderLightingContribution lighting)\n{\n    float3 albedo = surface.diffuse.rgb * surface.ambientOcclusion;\n    float3 color = lighting.diffuse * albedo;\n#if defined(USE_AMBIENT_LIGHTING)\n    color +=  lighting.ambient * albedo;\n#endif\n#ifdef USE_SELFILLUMINATION\n    color += surface.diffuse.rgb * surface.selfIllumination.rgb;\n#endif\n    \n    \n    \n#ifdef USE_SPECULAR\n    float3 S = lighting.specular;\n#elif defined(USE_REFLECTIVE)\n    float3 S = float3(0.);\n#endif\n#ifdef USE_REFLECTIVE\n    S += surface.reflective.rgb * surface.ambientOcclusion;\n#endif\n#ifdef USE_SPECULAR\n    S *= surface.specular.rgb;\n#endif\n#if (defined(USE_SPECULAR) || defined(USE_REFLECTIVE)) && !defined(DISABLE_SPECULAR)\n    color += S;\n#endif\n#ifdef USE_EMISSION\n    color += surface.emission.rgb;\n#endif\n#ifdef USE_MULTIPLY\n    color *= surface.multiply.rgb;\n#endif\n#ifdef USE_MODULATE\n    color *= lighting.modulate;\n#endif\n    return color;\n}\n#endif\n\nstruct VFXShaderGeometry\n{\n    float4 position;\n    float3 normal;\n    float4 tangent;\n    float4 color;\n    float pointSize;\n    float2 texcoords[8]; \n#ifdef USE_CLIP_DISTANCE0\n    float clipDistance0;\n#endif\n#ifdef USE_CLIP_DISTANCE1\n    float clipDistance1;\n#endif\n#ifdef USE_CLIP_DISTANCE2\n    float clipDistance2;\n#endif\n#ifdef USE_CLIP_DISTANCE3\n    float clipDistance3;\n#endif\n};\n\nstruct commonprofile_uniforms {\n    \n    float4 diffuseColor;\n    float4 specularColor;\n    float4 ambientOcclusionColor;\n    float4 emissionColor;\n    float4 selfIlluminationColor;\n    float4 reflectiveColor;\n    float4 multiplyColor;\n    float4 transparentColor;\n    float clearCoat;\n    float clearCoatRoughness;\n    float3 clearCoatNormal;\n    float subsurface;\n    float4 subsurfaceRadius;\n    float transmission;\n    float4 transmissionColor;\n    float indexOfRefraction;\n    float metalness;\n    \n    float roughness;\n    float diffuseIntensity;\n    float specularIntensity;\n    float normalIntensity;\n    float ambientOcclusionIntensity;\n    float emissionIntensity;\n    float selfIlluminationIntensity;\n    float reflectiveIntensity;\n    float multiplyIntensity;\n    float transparentIntensity;\n    \n    float metalnessIntensity;\n    float roughnessIntensity;\n    float clearCoatIntensity;\n    float clearCoatRoughnessIntensity;\n    float clearCoatNormalIntensity;\n    float subsurfaceIntensity;\n    float subsurfaceRadiusIntensity;\n    float transmissionIntensity;\n    float transmissionColorIntensity;\n    float displacementIntensity;\n    float materialShininess;\n    float selfIlluminationOcclusion;\n    float alphaCutoff;\n    float3 fresnel; \n    \n#if USE_ARGUMENT_BUFFERS\n    texture2d<float>    emissionTexture;\n    sampler             emissionSampler;\n    texture2d<float>    ambientOcclusionTexture;\n    sampler             ambientOcclusionSampler;\n    texture2d<float>    diffuseTexture;\n    sampler             diffuseSampler;\n    texture2d<float>    specularTexture;\n    sampler             specularSampler;\n#if defined(USE_REFLECTIVE_CUBEMAP)\n    texturecube<float>  reflectiveTexture;\n#else\n    texture2d<float>    reflectiveTexture;\n#endif\n    sampler             reflectiveSampler;\n    texture2d<float>    transparentTexture;\n    sampler             transparentSampler;\n    texture2d<float>    multiplyTexture;\n    sampler             multiplySampler;\n    texture2d<float>    normalTexture;\n    sampler             normalSampler;\n    texture2d<float>    selfIlluminationTexture;\n    sampler             selfIlluminationSampler;\n    texture2d<float>    metalnessTexture;\n    sampler             metalnessSampler;\n    texture2d<float>    roughnessTexture;\n    sampler             roughnessSampler;\n    texture2d<float>    displacementTexture;\n    sampler             displacementSampler;\n    \n#endif \n#ifdef TEXTURE_TRANSFORM_COUNT\n    float4x4 textureTransforms[TEXTURE_TRANSFORM_COUNT];\n#endif\n};\n\n#ifdef USE_OPENSUBDIV\n\n__OpenSubdivDeclPerGeometry__\n__OpenSubdivDeclPerPatchType__\n__OpenSubdivDeclShared__\n\nstruct osd_packed_vertex {\n    packed_float3 position;\n#if defined(OSD_USER_VARYING_DECLARE_PACKED)\n    OSD_USER_VARYING_DECLARE_PACKED\n#endif\n};\n\n#endif\n\n\n#ifdef USE_DISPLACEMENT_MAP\nstatic void applyDisplacement(texture2d<float>                 displacementTexture,\n                              sampler                          displacementTextureSampler,\n                              float2                           displacementTexcoord,\n                              thread VFXShaderGeometry&        geometry,\n                              constant commonprofile_uniforms& vfx_commonprofile)\n{\n#ifdef USE_DISPLACEMENT_TEXTURE_COMPONENT\n\tfloat altitude = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n#ifdef USE_DISPLACEMENT_INTENSITY\n\taltitude *= vfx_commonprofile.displacementIntensity;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n\tfloat3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));\n\tgeometry.position.xyz += geometry.normal * altitude;\n\t\n\tfloat3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);\n\tfloat3 h;\n\th.x = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\th.y = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\th.z = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord-offset.zy), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;\n\t\n#ifdef USE_DISPLACEMENT_INTENSITY\n\th *= vfx_commonprofile.displacementIntensity;\n#endif\n\t\n\tfloat3 n = normalize( float3( (h.x - h.y)/offset.x, 1., (h.x - h.z)/offset.y) );\n\tgeometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;\n\tgeometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));\n#endif \n#else \n\tfloat3 displacement = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;\n#ifdef USE_DISPLACEMENT_INTENSITY\n\tdisplacement *= vfx_commonprofile.displacementIntensity;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n\tfloat3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));\n\tgeometry.position.xyz += geometry.tangent.xyz * displacement.x + geometry.normal.xyz * displacement.y + bitangent.xyz * displacement.z;\n\t\n\tfloat3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);\n\tfloat3 a = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;\n\tfloat3 b = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz).rgb;\n\tfloat3 c = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.zy).rgb;\n\t\n#ifdef USE_DISPLACEMENT_INTENSITY\n\ta *= vfx_commonprofile.displacementIntensity;\n\tb *= vfx_commonprofile.displacementIntensity;\n\tc *= vfx_commonprofile.displacementIntensity;\n#endif\n\t\n\tb += offset.xzz;\n\tc -= offset.zzy;\n\tfloat3 n = (normalize( cross( b-a, c-a ) ));\n\tgeometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;\n\tgeometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));\n#endif \n#endif \n}\n#endif \n\n#ifdef USE_OUTLINE\nstatic inline float hash(float2 p)\n{\n    const float2 kMod2 = float2(443.8975f, 397.2973f);\n    p  = fract(p * kMod2);\n    p += dot(p.xy, p.yx+19.19f);\n    return fract(p.x * p.y);\n}\n#endif\n    \n\n\n\n\n#if defined(USE_TESSELLATION)\nstruct vfx_patch_t {\n    patch_control_point<vfx_vertex_t> controlPoints;\n};\n#endif\n\n#if defined(USE_OPENSUBDIV)\n#if OSD_IS_ADAPTIVE\n[[ patch(quad, VERTEX_CONTROL_POINTS_PER_PATCH) ]]\n#endif\n#elif defined(USE_TESSELLATION)\n[[ patch(triangle, 3) ]]\n#endif\n    \n    \nvertex commonprofile_io commonprofile_vert(\n#if !defined(USE_TESSELLATION)\n                                           vfx_vertex_t                       in                               [[ stage_in ]]\n                                           , uint                             vfx_vertexID                     [[ vertex_id ]]\n#else \n                                           \n#ifdef USE_OPENSUBDIV\n#if OSD_IS_ADAPTIVE\n#if USE_STAGE_IN\n                                           PatchInput                         patchInput                       [[ stage_in ]]\n#else\n                                           OsdVertexBufferSet                 patchInput\n#endif\n                                           , float2                           patchCoord                       [[ position_in_patch ]]\n                                           , uint                             patchID                          [[ patch_id ]]\n                                           , constant float&                  osdTessellationLevel             [[ buffer(TESSELLATION_LEVEL_BUFFER_INDEX) ]]\n#else \n                                           constant unsigned*                 osdIndicesBuffer                 [[ buffer(INDICES_BUFFER_INDEX) ]]\n                                           , constant osd_packed_vertex*      osdVertexBuffer                  [[ buffer(VERTEX_BUFFER_INDEX) ]]\n                                           , uint                             vertexID                         [[ vertex_id ]]\n#endif \n#if defined(OSD_FVAR_WIDTH)\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n                                           , constant uint32_t&               osdFaceVaryingChannelCount       [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_COUNT_INDEX) ]]\n                                           , constant OsdFVarChannelDesc*     osdFaceVaryingChannelDescriptors [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_DESCRIPTORS_INDEX) ]]\n                                           , constant uint32_t&               osdFaceVaryingPatchArrayIndex    [[ buffer(OSD_FVAR_CHANNELS_PATCH_ARRAY_INDEX_BUFFER_INDEX) ]]\n                                           , constant void*                   osdFaceVaryingChannelsPackedData [[ buffer(OSD_FVAR_CHANNELS_PACKED_DATA_BUFFER_INDEX) ]]\n#else\n                                           , constant float*                  osdFaceVaryingData               [[ buffer(OSD_FVAR_DATA_BUFFER_INDEX) ]]\n                                           , constant int*                    osdFaceVaryingIndices            [[ buffer(OSD_FVAR_INDICES_BUFFER_INDEX) ]]\n#if OSD_IS_ADAPTIVE\n                                           , constant packed_int3*            osdFaceVaryingPatchParams        [[ buffer(OSD_FVAR_PATCHPARAM_BUFFER_INDEX) ]]\n                                           , constant packed_int4&            osdFaceVaryingPatchArray         [[ buffer(OSD_FVAR_PATCH_ARRAY_BUFFER_INDEX) ]]\n#endif\n#endif \n#endif \n#else \n                                           vfx_patch_t                        in                               [[ stage_in ]]\n                                           , float3                           patchCoord                       [[ position_in_patch ]]\n#endif \n#endif \n                                           \n#ifdef USE_MULTIPLE_RENDERING\n                                           , constant VFXWorldBuffer*         vfx_frame_multi                  [[ buffer(0) ]]\n#else\n                                           , constant VFXWorldBuffer&         vfx_frame                        [[ buffer(0) ]]\n#endif\n#if defined(USE_INSTANCING) || defined(USE_MULTIPLE_RENDERING)\n                                           , device commonprofile_node*     vfx_nodes_in                     [[ buffer(1) ]]\n#else\n                                           , device commonprofile_node&     vfx_node_in                      [[ buffer(1) ]]\n#endif\n#ifdef USE_PER_VERTEX_LIGHTING\n                                           , constant vfx_light*              vfx_lights                       [[ buffer(2) ]]\n                                           , constant float4*                 u_shadowKernel\n                                           , texture2d_array<float>           u_areaLightBakedDataTexture\n#endif\n                                           \n                                           , constant commonprofile_uniforms& vfx_commonprofile\n#ifdef USE_RE_SYSTEM_TREATMENTS\n                                           , constant GlobalConstants&        u_re_globalConstants\n#endif\n#ifdef USE_INSTANCING\n                                           , uint                             vfx_instanceID                   [[ instance_id ]]\n#endif\n#ifdef USE_VERTEX_AMPLIFICATION\n                                           , ushort                           amplificationID                  [[ amplification_id ]]\n#endif\n\n#ifdef USE_POINT_RENDERING\n                                           \n                                           , constant float3&                 vfx_pointSize\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n#if USE_ARGUMENT_BUFFERS\n#define u_displacementTexture           vfx_commonprofile.displacementTexture\n#define u_displacementTextureSampler    vfx_commonprofile.displacementSampler\n#else\n                                           , texture2d<float>                 u_displacementTexture\n                                           , sampler                          u_displacementTextureSampler\n#endif \n#endif \n#ifdef USE_VERTEX_EXTRA_ARGUMENTS\n                                           __VertexExtraArguments__\n#endif\n                                           )\n{\n    commonprofile_io out;\n    \n#ifdef USE_MULTIPLE_RENDERING\n\n#ifdef USE_VERTEX_AMPLIFICATION\n    constant VFXWorldBuffer& vfx_frame = vfx_frame_multi[amplificationID];\n#else\n    out.instanceID = vfx_instanceID / USE_MULTIPLE_RENDERING;\n    out.sliceIndex = vfx_instanceID % USE_MULTIPLE_RENDERING;\n    constant VFXWorldBuffer& vfx_frame = vfx_frame_multi[out.sliceIndex];\n#endif\n    \n#ifdef USE_INSTANCING\n#ifdef USE_VERTEX_AMPLIFICATION\n    device commonprofile_node& vfx_node_in = vfx_nodes_in[USE_MULTIPLE_RENDERING * vfx_instanceID + amplificationID];\n#else\n    \n    \n    device commonprofile_node& vfx_node_in = vfx_nodes_in[vfx_instanceID];\n#endif\n#else\n#ifdef USE_VERTEX_AMPLIFICATION\n    device commonprofile_node& vfx_node_in = vfx_nodes_in[amplificationID];\n#else\n    device commonprofile_node& vfx_node_in = vfx_nodes_in[out.sliceIndex];\n#endif\n#endif\n    \n#else \n    \n#ifdef USE_INSTANCING\n    out.instanceID = vfx_instanceID;\n    device commonprofile_node& vfx_node_in = vfx_nodes_in[vfx_instanceID];\n#endif\n    \n#endif \n    \n    commonprofile_node vfx_node = compute_view_dependant_uniforms(vfx_node_in, vfx_frame);\n    \n#ifdef USE_TESSELLATION\n    uint vfx_vertexID; \n    vfx_vertexID = 0;\n#endif\n    \n    \n    \n    \n    \n    VFXShaderGeometry _geometry;\n    \n#if !defined(USE_TESSELLATION)\n    \n    \n    _geometry.position = float4(in.position, 1.f);\n#if defined(USE_NORMAL) && defined(HAS_NORMAL)\n    _geometry.normal = in.normal;\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = in.tangent;\n#endif\n#if defined(NEED_IN_TEXCOORD0) || defined(DEBUG_PIXEL)\n    _geometry.texcoords[0] = in.texcoord0;\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    _geometry.texcoords[1] = in.texcoord1;\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    _geometry.texcoords[2] = in.texcoord2;\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    _geometry.texcoords[3] = in.texcoord3;\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    _geometry.texcoords[4] = in.texcoord4;\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    _geometry.texcoords[5] = in.texcoord5;\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    _geometry.texcoords[6] = in.texcoord6;\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    _geometry.texcoords[7] = in.texcoord7;\n#endif\n#ifdef HAS_VERTEX_COLOR\n    _geometry.color = in.color;\n#elif USE_VERTEX_COLOR\n    _geometry.color = float4(1.);\n#endif\n    \n#else \n    \n#ifdef USE_OPENSUBDIV\n#if OSD_IS_ADAPTIVE\n#if USE_STAGE_IN\n    int3 patchParam = patchInput.patchParam;\n#else\n    int3 patchParam = patchInput.patchParamBuffer[patchID];\n#endif\n    \n    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);\n    float tessellationLevel = min(osdTessellationLevel, (float)OSD_MAX_TESS_LEVEL) / exp2((float)refinementLevel - 1);\n    \n    OsdPatchVertex patchVertex = OsdComputePatch(tessellationLevel, patchCoord, patchID, patchInput);\n    \n#if defined(OSD_FVAR_WIDTH)\n    int patchIndex = OsdGetPatchIndex(patchID);\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);\n#else\n    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingIndices, osdFaceVaryingData, osdFaceVaryingPatchParams, osdFaceVaryingPatchArray);\n#endif\n#endif\n    \n    _geometry.position = float4(patchVertex.position, 1.f);\n    \n#if defined(USE_NORMAL)\n    _geometry.normal = patchVertex.normal;\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = float4(patchVertex.tangent, -1.f);\n    \n#endif\n#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[0] = patchVertex.texcoord0;\n#endif\n#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[1] = patchVertex.texcoord1;\n#endif\n#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[2] = patchVertex.texcoord2;\n#endif\n#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[3] = patchVertex.texcoord3;\n#endif\n#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[4] = patchVertex.texcoord4;\n#endif\n#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[5] = patchVertex.texcoord5;\n#endif\n#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[6] = patchVertex.texcoord6;\n#endif\n#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[7] = patchVertex.texcoord7;\n#endif\n#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.color = patchVertex.color;\n#endif\n    \n#else \n    \n#if OSD_PATCH_QUADS\n    const uint primitiveIndex = vertexID / 6;\n#ifdef USE_NORMAL\n    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 0]].position;\n    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 1]].position;\n    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 2]].position;\n    float3 normal = normalize(cross(p2 - p1, p0 - p1));\n#endif\n    const uint triangleIndices[6] = { 0, 1, 2, 0, 2, 3 };\n    const uint quadVertexIndex = triangleIndices[vertexID % 6];\n    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + quadVertexIndex]];\n#elif OSD_PATCH_TRIANGLES\n    const uint primitiveIndex = vertexID / 3;\n#ifdef USE_NORMAL\n    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 0]].position;\n    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 1]].position;\n    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 2]].position;\n    float3 normal = normalize(cross(p2 - p1, p0 - p1));\n#endif\n    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[vertexID]];\n#endif\n    \n    float3 position = osdVertex.position;\n    \n#if defined(OSD_FVAR_WIDTH)\n    int patchIndex = OsdGetPatchIndex(primitiveIndex);\n#if OSD_PATCH_QUADS\n    float2 quadUVs[4] = { float2(0,0), float2(1,0), float2(1,1), float2(0,1) };\n#if OSD_FVAR_USES_MULTIPLE_CHANNELS\n    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);\n#else\n    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingIndices, osdFaceVaryingData);\n#endif\n#elif OSD_PATCH_TRIANGLES\n    \n#endif\n#endif \n    \n#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[0] = osdVertex.texcoord0;\n#endif\n#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[1] = osdVertex.texcoord1;\n#endif\n#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[2] = osdVertex.texcoord2;\n#endif\n#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[3] = osdVertex.texcoord3;\n#endif\n#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[4] = osdVertex.texcoord4;\n#endif\n#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[5] = osdVertex.texcoord5;\n#endif\n#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[6] = osdVertex.texcoord6;\n#endif\n#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.texcoords[7] = osdVertex.texcoord7;\n#endif\n#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)\n    _geometry.color = osdVertex.color;\n#endif\n    \n    _geometry.position = float4(position, 1.f);\n#ifdef USE_NORMAL\n    _geometry.normal = normal;\n#endif\n    \n#endif \n    \n#else \n    \n    \n    \n    \n    \n#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE) || defined(TESSELLATION_SMOOTHING_MODE_PHONG)\n    float3 P0 = in.controlPoints[0].position;\n    float3 P1 = in.controlPoints[1].position;\n    float3 P2 = in.controlPoints[2].position;\n    float3 N0 = in.controlPoints[0].normal;\n    float3 N1 = in.controlPoints[1].normal;\n    float3 N2 = in.controlPoints[2].normal;\n#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE)\n    float3 position, normal;\n    vfx_smooth_geometry_pn_triangle(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);\n#elif defined(TESSELLATION_SMOOTHING_MODE_PHONG)\n    float3 position, normal;\n    vfx_smooth_geometry_phong(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);\n#endif\n    _geometry.position = float4(position, 1.f);\n#ifdef USE_NORMAL\n    _geometry.normal = normal;\n#endif\n#else \n    \n    _geometry.position = float4(vfx::barycentric_mix(in.controlPoints[0].position, in.controlPoints[1].position, in.controlPoints[2].position, patchCoord), 1.f);\n#if defined(USE_NORMAL) && defined(HAS_NORMAL)\n    _geometry.normal = normalize(vfx::barycentric_mix(in.controlPoints[0].normal, in.controlPoints[1].normal, in.controlPoints[2].normal, patchCoord));\n#endif\n#endif \n    \n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _geometry.tangent = normalize(vfx::barycentric_mix(in.controlPoints[0].tangent, in.controlPoints[1].tangent, in.controlPoints[2].tangent, patchCoord));\n#endif\n#ifdef NEED_IN_TEXCOORD0\n    _geometry.texcoords[0] = vfx::barycentric_mix(in.controlPoints[0].texcoord0, in.controlPoints[1].texcoord0, in.controlPoints[2].texcoord0, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD1\n    _geometry.texcoords[1] = vfx::barycentric_mix(in.controlPoints[0].texcoord1, in.controlPoints[1].texcoord1, in.controlPoints[2].texcoord1, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD2\n    _geometry.texcoords[2] = vfx::barycentric_mix(in.controlPoints[0].texcoord2, in.controlPoints[1].texcoord2, in.controlPoints[2].texcoord2, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD3\n    _geometry.texcoords[3] = vfx::barycentric_mix(in.controlPoints[0].texcoord3, in.controlPoints[1].texcoord3, in.controlPoints[2].texcoord3, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD4\n    _geometry.texcoords[4] = vfx::barycentric_mix(in.controlPoints[0].texcoord4, in.controlPoints[1].texcoord4, in.controlPoints[2].texcoord4, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD5\n    _geometry.texcoords[5] = vfx::barycentric_mix(in.controlPoints[0].texcoord5, in.controlPoints[1].texcoord5, in.controlPoints[2].texcoord5, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD6\n    _geometry.texcoords[6] = vfx::barycentric_mix(in.controlPoints[0].texcoord6, in.controlPoints[1].texcoord6, in.controlPoints[2].texcoord6, patchCoord);\n#endif\n#ifdef NEED_IN_TEXCOORD7\n    _geometry.texcoords[7] = vfx::barycentric_mix(in.controlPoints[0].texcoord7, in.controlPoints[1].texcoord7, in.controlPoints[2].texcoord7, patchCoord);\n#endif\n#ifdef HAS_VERTEX_COLOR\n    _geometry.color = vfx::barycentric_mix(in.controlPoints[0].color, in.controlPoints[1].color, in.controlPoints[2].color, patchCoord);\n#elif USE_VERTEX_COLOR\n    _geometry.color = float4(1.);\n#endif\n    \n#endif \n    \n#endif \n    \n#ifdef USE_POINT_RENDERING\n    _geometry.pointSize = vfx_pointSize.x;\n#endif\n    \n#ifdef USE_TEXCOORD\n    __VertexDoVertexOnlyTexcoord__\n#endif\n    \n#ifdef USE_DISPLACEMENT_MAP\n    applyDisplacement(u_displacementTexture, u_displacementTextureSampler, _displacementTexcoord, _geometry, vfx_commonprofile);\n    out.displacementTexcoord = _displacementTexcoord;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_GEOMETRY_MODIFIER\n    \n    __DoGeometryModifier__\n    \n#endif\n    \n#ifdef USE_CLIP_DISTANCE0\n    out.clipDistance[0] = _geometry.clipDistance0;\n#endif\n#ifdef USE_CLIP_DISTANCE1\n    out.clipDistance[1] = _geometry.clipDistance1;\n#endif\n#ifdef USE_CLIP_DISTANCE2\n    out.clipDistance[2] = _geometry.clipDistance2;\n#endif\n#ifdef USE_CLIP_DISTANCE3\n    out.clipDistance[3] = _geometry.clipDistance3;\n#endif\n    \n    \n    \n    \n    \n    \n#if defined(USE_POSITION) || (defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)) || defined(USE_TANGENT) || defined(USE_BITANGENT) || defined(USE_INSTANCING)\n    VFXShaderSurface _surface;\n#endif\n#if defined(USE_POSITION) || defined(USE_INSTANCING)\n    _surface.position = (vfx_node.modelViewTransform * _geometry.position).xyz;\n#endif\n#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)\n#ifdef HINT_UNIFORM_SCALE\n    float3x3 nrmTransform = vfx::mat3(vfx_node.modelViewTransform);\n    _surface.normal = nrmTransform * _geometry.normal;\n#else\n    float3x3 modelViewTransform = vfx::mat3(vfx_node.modelViewTransform);\n    float3 invScaleSquared = 1.f / float3(length_squared(modelViewTransform[0]),\n                                          length_squared(modelViewTransform[1]),\n                                          length_squared(modelViewTransform[2]));\n    _surface.normal = normalize(modelViewTransform * (_geometry.normal * invScaleSquared));\n#endif\n#ifdef USE_GBUFFER_OUTPUT\n    _surface.normal = vfx::mat3(vfx_node.modelTransform) * _geometry.normal;\n#endif\n#endif\n#if defined(USE_TANGENT) || defined(USE_BITANGENT)\n    _surface.tangent = normalize(vfx::mat3(vfx_node.modelViewTransform) * _geometry.tangent.xyz);\n    _surface.bitangent = _geometry.tangent.w * cross(_surface.tangent, _surface.normal); \n    \n#endif\n    \n    \n#ifdef USE_VIEW\n    _surface.view = normalize(-_surface.position);\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_PER_VERTEX_LIGHTING\n    \n    VFXShaderLightingContribution _lightingContribution(_surface, out);\n    _lightingContribution.diffuse = 0.;\n  #ifdef USE_SPECULAR\n    _lightingContribution.specular = 0.;\n    _surface.shininess = vfx_commonprofile.materialShininess;\n  #endif\n    \n    __VertexDoLighting__\n    \n    out.diffuse = _lightingContribution.diffuse;\n  #ifdef USE_SPECULAR\n    out.specular = _lightingContribution.specular;\n  #endif\n#endif\n#if defined(USE_POSITION) && (USE_POSITION == 2)\n    out.position = _surface.position;\n#endif\n#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)\n    out.normal = _surface.normal;\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    out.tangent = _surface.tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    out.bitangent = _surface.bitangent;\n#endif\n#ifdef USE_VERTEX_COLOR\n    out.vertexColor = _geometry.color;\n#endif\n    \n#if DEBUG_PIXEL\n    out.uv0 = _geometry.texcoords[0];\n#endif\n\n#ifdef USE_TEXCOORD\n    __VertexDoTexcoord__\n#endif\n    \n#ifdef IS_BEZIER_CURVE\n    out.bezierCurveUV = in.texcoord0;\n#endif\n    \n    \n    \n    \n    \n#if defined(USE_POSITION) || defined(USE_INSTANCING)\n    out.fragmentPosition = vfx_frame.projectionTransform * float4(_surface.position, 1.);\n#elif defined(USE_MODELVIEWPROJECTIONTRANSFORM) \n    out.fragmentPosition = vfx_node.modelViewProjectionTransform * _geometry.position;\n#endif\n    \n#ifdef USE_NODE_OPACITY\n    out.nodeOpacity = vfx_node.nodeOpacity;\n#endif\n    \n#ifdef USE_POINT_RENDERING\n    float screenSize = _geometry.pointSize / out.fragmentPosition.w;\n    out.fragmentSize = clamp(screenSize, vfx_pointSize.y, vfx_pointSize.z);\n#endif\n    \n#ifdef USE_LASTFRAMETRANSFORM\n    float4 lastFrameFragmentPosition = vfx_frame.lastFrameViewProjectionTransform * vfx_node.lastFrameModelTransform * _geometry.position;\n    out.mv_fragment = out.fragmentPosition.xyw;\n    out.mv_lastFragment = lastFrameFragmentPosition.xyw;\n#endif\n    \n#ifdef USE_OUTLINE\n\tout.outlineHash = hash(vfx_node.modelTransform[3].xy)+1.f/255.f;\n#endif\n    \n#if USE_SCREEN_UV\n    float2 ndc = out.fragmentPosition.xy / out.fragmentPosition.w;\n    out.screen_uv = float2(ndc * float2(0.5f, -0.5f) + 0.5f);\n#endif\n\n#ifdef USE_CR_WORLD_POSITION\n    float3 worldPosition = (vfx_node.modelTransform * _geometry.position).xyz;\n#ifdef USE_RE_SYSTEM_TREATMENTS\n    out.crworldPosition = vfx::api_v2::crws_position(worldPosition, u_re_globalConstants);\n#else\n    \n#endif\n#endif\n\n    return out;\n}\n\n\n\n\n\nstruct VFXOutput\n{\n    float4 color [[ color(0) ]];\n#ifdef USE_COLOR1_OUTPUT\n    half4 color1 [[ color(1) ]];\n#endif\n#ifdef USE_NORMAL_ROUGHNESS_OUTPUT\n    half4 normalRoughness [[ color(2) ]];\n#endif\n#if defined(USE_MOTIONBLUR) && !defined(USE_GBUFFER_OUTPUT)\n    half4 motionblur [[ color(3) ]];\n#endif\n#ifdef USE_ALBEDO_METALNESS_OUTPUT\n    half4 albedoMetalnessOutput [[ color(4) ]];\n#endif\n#ifdef USE_RADIANCE_AO_OUTPUT\n    half4 radianceAOOutput [[ color(5) ]];\n#endif\n#ifdef USE_GBUFFER_OUTPUT\n    float4 albedo [[ color(VFXGBufferAttachmentAlbedo) ]];\n    float4 normals [[ color(VFXGBufferAttachmentNormal) ]];\n    float4 roughmetal [[ color(VFXGBufferAttachmentRoughnessMetalness) ]];\n    \n#ifdef USE_MOTIONBLUR\n    float4 velocity [[ color(VFXGBufferAttachmentVelocity) ]];\n#else\n    float2 velocity [[ color(VFXGBufferAttachmentVelocity) ]];\n#endif\n    half4 clearCoat [[ color(VFXGBufferAttachmentClearCoat) ]];\n    half4 subsurface [[ color(VFXGBufferAttachmentSubsurface) ]];\n    ushort4 transmission [[ color(VFXGBufferAttachmentTransmission) ]];\n#endif\n};\n    \n#ifdef USE_MODIFIER_FRAMEBUFFER\nstruct VFXFramebuffer\n{\n    float4 color;\n};\n#endif\n\nfragment VFXOutput commonprofile_frag(commonprofile_io                   in                          [[ stage_in  ]]\n                                      , constant commonprofile_uniforms& vfx_commonprofile           [[ buffer(0) ]]\n#ifdef USE_MULTIPLE_RENDERING\n                                      , constant VFXWorldBuffer*         vfx_frame_multi             [[ buffer(1) ]]\n#else\n                                      , constant VFXWorldBuffer&         vfx_frame                   [[ buffer(1) ]]\n#endif\n#if defined(USE_INSTANCING) || defined(USE_MULTIPLE_RENDERING)\n                                      , device commonprofile_node*     vfx_nodes_in                [[ buffer(2) ]]\n#else\n                                      , device commonprofile_node&     vfx_node_in                 [[ buffer(2) ]]\n#endif\n#ifdef USE_PER_PIXEL_LIGHTING\n                                      , constant vfx_light*              vfx_lights                  [[ buffer(3) ]]\n                                      , constant float4*                 u_shadowKernel\n                                      , texture2d_array<float>           u_areaLightBakedDataTexture\n#ifdef CFX_SUPPORT_CUBE_ARRAY\n                                      , texturecube_array<half>          u_reflectionProbeTexture\n#else\n                                      , texture2d_array<half>            u_reflectionProbeTexture\n#endif\n                                      , texture3d<ushort>                u_clusterTexture\n#ifdef CFX_USE_TEXTURE_FOR_LIGHT_INDICES\n                                      , texture1d<ushort>                u_lightIndicesTexture\n#else\n                                      , constant CFXLightIndexType*      u_lightIndicesBuffer\n#endif\n#endif\n#ifdef USE_RE_SYSTEM_TREATMENTS\n                                      , constant EntityConstants&           u_re_entityConstants\n                                      , constant ViewConstants&             u_re_viewConstants\n                                      , constant GlobalConstants&           u_re_globalConstants\n                                      , constant re_vfx_object_constants&   u_re_vfx_objectConstants\n                                      , constant re_entity_argument_buffer& u_re_vfx_entityArgumentBuffer\n                                      , constant re_scene_argument_buffer&  u_re_vfx_sceneArgumentBuffer\n#ifdef USE_RE_SYSTEM_TREATMENTS_TIER_1_AB\n                                      , constant VirtualEnvironmentProbeLighting::TextureArgumentBuffer& u_re_vfx_virtualEnvProbeTextures\n#endif\n#endif\n#if defined(CFX_SUPPORTS_PROGRAMMABLE_BLENDING) && defined(USE_MODIFIER_FRAMEBUFFER_COLOR0)\n                                      , float4                           framebufferColor0           [[ color(0) ]]\n#endif\n#if USE_ARGUMENT_BUFFERS\n\n#define u_emissionTexture               vfx_commonprofile.emissionTexture\n#define u_emissionTextureSampler        vfx_commonprofile.emissionSampler\n#define u_ambientOcclusionTexture       vfx_commonprofile.ambientOcclusionTexture\n#define u_ambientOcclusionTextureSampler vfx_commonprofile.ambientOcclusionSampler\n#define u_diffuseTexture                vfx_commonprofile.diffuseTexture\n#define u_diffuseTextureSampler         vfx_commonprofile.diffuseSampler\n#define u_specularTexture               vfx_commonprofile.specularTexture\n#define u_specularTextureSampler        vfx_commonprofile.specularSampler\n#define u_reflectiveTexture             vfx_commonprofile.reflectiveTexture\n#define u_reflectiveTextureSampler      vfx_commonprofile.reflectiveSampler\n#define u_transparentTexture            vfx_commonprofile.transparentTexture\n#define u_transparentTextureSampler     vfx_commonprofile.transparentSampler\n#define u_multiplyTexture               vfx_commonprofile.multiplyTexture\n#define u_multiplyTextureSampler        vfx_commonprofile.multiplySampler\n#define u_normalTexture                 vfx_commonprofile.normalTexture\n#define u_normalTextureSampler          vfx_commonprofile.normalSampler\n#define u_selfIlluminationTexture       vfx_commonprofile.selfIlluminationTexture\n#define u_selfIlluminationTextureSampler vfx_commonprofile.selfIlluminationSampler\n#define u_metalnessTexture              vfx_commonprofile.metalnessTexture\n#define u_metalnessTextureSampler       vfx_commonprofile.metalnessSampler\n#define u_roughnessTexture              vfx_commonprofile.roughnessTexture\n#define u_roughnessTextureSampler       vfx_commonprofile.roughnessSampler\n\n#else\n#ifdef USE_EMISSION_MAP\n                                      , texture2d<float>              u_emissionTexture\n                                      , sampler                       u_emissionTextureSampler\n#endif\n#ifdef USE_AMBIENTOCCLUSION_MAP\n                                      , texture2d<float>              u_ambientOcclusionTexture\n                                      , sampler                       u_ambientOcclusionTextureSampler\n#endif\n#ifdef USE_DIFFUSE_MAP\n                                      , texture2d<float>              u_diffuseTexture\n                                      , sampler                       u_diffuseTextureSampler\n#endif\n#ifdef USE_SPECULAR_MAP\n                                      , texture2d<float>              u_specularTexture\n                                      , sampler                       u_specularTextureSampler\n#endif\n#ifdef USE_REFLECTIVE_MAP\n                                      , texture2d<float>              u_reflectiveTexture\n                                      , sampler                       u_reflectiveTextureSampler\n#elif defined(USE_REFLECTIVE_CUBEMAP)\n                                      , texturecube<float>            u_reflectiveTexture\n                                      , sampler                       u_reflectiveTextureSampler\n#endif\n#ifdef USE_TRANSPARENT_MAP\n                                      , texture2d<float>              u_transparentTexture\n                                      , sampler                       u_transparentTextureSampler\n#endif\n#ifdef USE_MULTIPLY_MAP\n                                      , texture2d<float>              u_multiplyTexture\n                                      , sampler                       u_multiplyTextureSampler\n#endif\n#ifdef USE_NORMAL_MAP\n                                      , texture2d<float>              u_normalTexture\n                                      , sampler                       u_normalTextureSampler\n#endif\n#ifdef USE_SELFILLUMINATION_MAP\n                                      , texture2d<float>              u_selfIlluminationTexture\n                                      , sampler                       u_selfIlluminationTextureSampler\n#endif\n#ifdef USE_DISPLACEMENT_MAP\n                                      , texture2d<float>              u_displacementTexture\n                                      , sampler                       u_displacementTextureSampler\n#endif\n#ifdef USE_PBR\n#ifdef USE_METALNESS_MAP\n                                      , texture2d<float>              u_metalnessTexture\n                                      , sampler                       u_metalnessTextureSampler\n#endif\n#ifdef USE_ROUGHNESS_MAP\n                                      , texture2d<float>              u_roughnessTexture\n                                      , sampler                       u_roughnessTextureSampler\n#endif\n#ifdef USE_CLEARCOAT_MAP\n                                      , texture2d<float>              u_clearCoatTexture\n                                      , sampler                       u_clearCoatTextureSampler\n#endif\n#ifdef USE_CLEARCOATROUGHNESS_MAP\n                                      , texture2d<float>              u_clearCoatRoughnessTexture\n                                      , sampler                       u_clearCoatRoughnessTextureSampler\n#endif\n#ifdef USE_CLEARCOATNORMAL_MAP\n                                      , texture2d<float>              u_clearCoatNormalTexture\n                                      , sampler                       u_clearCoatNormalTextureSampler\n#endif\n#ifdef USE_SUBSURFACE_MAP\n                                      , texture2d<float>              u_subsurfaceTexture\n                                      , sampler                       u_subsurfaceTextureSampler\n#endif\n#ifdef USE_SUBSURFACERADIUS_MAP\n                                      , texture2d<float>              u_subsurfaceRadiusTexture\n                                      , sampler                       u_subsurfaceRadiusTextureSampler\n#endif\n#ifdef USE_TRANSMISSION_MAP\n                                      , texture2d<float>              u_transmissionTexture\n                                      , sampler                       u_transmissionTextureSampler\n#endif\n#ifdef USE_TRANSMISSIONCOLOR_MAP\n                                      , texture2d<float>              u_transmissionColorTexture\n                                      , sampler                       u_transmissionColorTextureSampler\n#endif\n#endif \n#endif \n#ifdef USE_PBR\n                                      , texturecube<float>            u_radianceTexture\n                                      , texture2d<float>              u_specularDFGDiffuseHammonTexture\n#if !defined(USE_SELFILLUMINATION_MAP)\n                                      , texturecube<float>            u_irradianceTexture\n#endif\n#endif \n#ifdef USE_SSAO\n                                      , texture2d<float>              u_ssaoTexture\n#endif\n#ifdef USE_FRAGMENT_EXTRA_ARGUMENTS\n                                      __FragmentExtraArguments__\n#endif\n#if defined(USE_DOUBLE_SIDED)\n                                      , bool                          isFrontFacing                    [[front_facing]]\n#endif\n#ifdef USE_POINT_RENDERING\n                                      , float2                        pointCoord                       [[point_coord]]\n#endif\n#ifdef USE_VERTEX_AMPLIFICATION\n                                      , ushort                        amplificationID                  [[amplification_id]]\n#endif\n#ifdef USE_BARYCENTRIC_COORD\n                                      , float3                        u_barycentricCoord                 [[barycentric_coord]]\n#endif\n                                      )\n{\n#ifdef USE_MULTIPLE_RENDERING\n    \n#ifdef USE_VERTEX_AMPLIFICATION\n    constant VFXWorldBuffer& vfx_frame = vfx_frame_multi[amplificationID];\n#else\n    constant VFXWorldBuffer& vfx_frame = vfx_frame_multi[in.sliceIndex];\n#endif\n    \n#ifdef USE_INSTANCING\n#ifdef USE_VERTEX_AMPLIFICATION\n    device commonprofile_node& vfx_node_in = vfx_nodes_in[USE_MULTIPLE_RENDERING * in.instanceID + amplificationID];\n#else\n    device commonprofile_node& vfx_node_in = vfx_nodes_in[USE_MULTIPLE_RENDERING * in.instanceID + in.sliceIndex];\n#endif\n#else\n#ifdef USE_VERTEX_AMPLIFICATION\n    device commonprofile_node& vfx_node_in = vfx_nodes_in[amplificationID];\n#else\n    device commonprofile_node& vfx_node_in = vfx_nodes_in[in.sliceIndex];\n#endif\n#endif\n    \n#else \n    \n#ifdef USE_INSTANCING\n    device commonprofile_node& vfx_node_in = vfx_nodes_in[in.instanceID];\n#endif\n    \n#endif \n    \n    commonprofile_node vfx_node = vfx_node_in;\n    \n#ifdef IS_BEZIER_CURVE\n    int vfx_bezierCurveCoverage = 0;\n    for (uint sampleID = 0; sampleID < get_num_samples(); ++sampleID) {\n        float2 uv = in.bezierCurveUV.interpolate_at_sample(sampleID);\n        bool insideCurve = vfx_is_inside_bezier_curve(uv, vfx_bezier_curve_data, vfx_bezier_curve_controlPoints);\n        vfx_bezierCurveCoverage += insideCurve;\n    }\n    if (vfx_bezierCurveCoverage == 0) {\n        discard_fragment();\n    }\n#endif\n    \n    VFXOutput _output;\n\n    \n    \n    \n    \n    VFXShaderSurface _surface;\n#ifdef USE_TEXCOORD\n    __FragmentDoTexcoord__\n#endif\n    _surface.ambientOcclusion = 1.f; \n\n#ifdef USE_AMBIENTOCCLUSION_MAP\n#if defined(USE_AMBIENTOCCLUSION_TEXTURE_COMPONENT)\n    _surface.ambientOcclusion = colorFromMask(u_ambientOcclusionTexture.sample(u_ambientOcclusionTextureSampler, _surface.ambientOcclusionTexcoord), USE_AMBIENTOCCLUSION_TEXTURE_COMPONENT).r;\n#else\n    _surface.ambientOcclusion = u_ambientOcclusionTexture.sample(u_ambientOcclusionTextureSampler, _surface.ambientOcclusionTexcoord).r;\n#endif \n#ifdef USE_AMBIENTOCCLUSION_INTENSITY\n    _surface.ambientOcclusion = saturate(mix(1.f, _surface.ambientOcclusion, vfx_commonprofile.ambientOcclusionIntensity));\n#endif\n#endif\n\n\n#if defined(USE_SSAO)\n    \n    \n    float2 uvSSAO = in.fragmentPosition.xy * vfx_frame.inverseResolution.xy;\n#if defined(USE_BENTNORMALS)\n    float4 aoBent = u_ssaoTexture.sample(sampler(filter::linear), uvSSAO).rgba;\n    _surface.ambientOcclusion *= aoBent.r;\n    _surface.bentNormal = aoBent.gba*2.0 - 1.0;\n#else\n    _surface.ambientOcclusion *= u_ssaoTexture.sample( sampler(filter::linear), uvSSAO).r;\n#endif\n#endif\n    \n#ifdef USE_DIFFUSE_MAP\n    _surface.diffuse = u_diffuseTexture.sample(u_diffuseTextureSampler, _surface.diffuseTexcoord);\n#if defined(USE_DIFFUSE_TEXTURE_COMPONENT)\n    _surface.diffuse = colorFromMask(_surface.diffuse, USE_DIFFUSE_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_DIFFUSE_INTENSITY\n    _surface.diffuse.rgb *= vfx_commonprofile.diffuseIntensity;\n#endif\n#elif defined(USE_DIFFUSE_COLOR)\n    _surface.diffuse = vfx_commonprofile.diffuseColor;\n#else\n    _surface.diffuse = float4(0.f,0.f,0.f,1.f);\n#endif\n#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)\n    _surface.diffuse.rgb    *= in.vertexColor.rgb;\n    _surface.diffuse        *= in.vertexColor.a; \n#endif\n#ifdef USE_SPECULAR_MAP\n    _surface.specular = u_specularTexture.sample(u_specularTextureSampler, _surface.specularTexcoord);\n#if defined(USE_SPECULAR_TEXTURE_COMPONENT)\n    _surface.specular = colorFromMask(_surface.specular, USE_SPECULAR_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_SPECULAR_INTENSITY\n    _surface.specular *= vfx_commonprofile.specularIntensity;\n#endif\n#elif defined(USE_SPECULAR_COLOR)\n    _surface.specular = vfx_commonprofile.specularColor;\n#elif defined(USE_SPECULAR)\n    _surface.specular = float4(0.f);\n#endif\n    \n#ifdef USE_CLEARCOAT_MAP\n    _surface.clearCoat = u_clearCoatTexture.sample(u_clearCoatTextureSampler, _surface.clearCoatTexcoord).r;\n#if defined(USE_CLEARCOAT_TEXTURE_COMPONENT)\n    _surface.clearCoat = colorFromMask(_surface.clearCoat, USE_CLEARCOAT_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_CLEARCOAT_INTENSITY\n    _surface.clearCoat *= vfx_commonprofile.clearCoatIntensity;\n#endif\n#elif defined(USE_CLEARCOAT_COLOR)\n    _surface.clearCoat = vfx_commonprofile.clearCoat;\n#else\n    _surface.clearCoat = 0.f;\n#endif\n    \n#ifdef USE_CLEARCOATROUGHNESS_MAP\n#if defined(USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT)\n    _surface.clearCoatRoughness = colorFromMask(u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord), USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.clearCoatRoughness = u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord).r;\n#endif\n#ifdef USE_CLEARCOATROUGHNESS_INTENSITY\n    _surface.clearCoatRoughness *= vfx_commonprofile.clearCoatRoughnessIntensity;\n#endif\n#elif defined(USE_CLEARCOATROUGHNESS_COLOR)\n    _surface.clearCoatRoughness = vfx_commonprofile.clearCoatRoughness;\n#else\n    _surface.clearCoatRoughness = 0.03f;\n#endif\n    \n#ifdef USE_SUBSURFACE\n#ifdef USE_SUBSURFACE_MAP\n    _surface.subsurface = u_subsurfaceTexture.sample(u_subsurfaceTextureSampler, _surface.subsurfaceTexcoord).r;\n#if defined(USE_SUBSURFACE_TEXTURE_COMPONENT)\n    _surface.subsurface = colorFromMask(_surface.subsurface, USE_SUBSURFACE_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_SUBSURFACE_INTENSITY\n    _surface.subsurface *= vfx_commonprofile.subsurfaceIntensity;\n#endif\n#elif defined(USE_SUBSURFACE_COLOR)\n    _surface.subsurface = vfx_commonprofile.subsurface;\n#else\n    _surface.subsurface = 0.f;\n#endif\n    \n#ifdef USE_SUBSURFACERADIUS_MAP\n    _surface.subsurfaceRadius = u_subsurfaceRadiusTexture.sample(u_subsurfaceRadiusTextureSampler, _surface.subsurfaceRadiusTexcoord).rgb;\n#if defined(USE_SUBSURFACERADIUS_TEXTURE_COMPONENT)\n    _surface.subsurfaceRadius = colorFromMask(_surface.subsurfaceRadius, USE_SUBSURFACERADIUS_TEXTURE_COMPONENT).rgb;\n#endif\n#ifdef USE_SUBSURFACERADIUS_INTENSITY\n    _surface.subsurfaceRadius *= vfx_commonprofile.subsurfaceRadiusIntensity;\n#endif\n#elif defined(USE_SUBSURFACERADIUS_COLOR)\n    _surface.subsurfaceRadius = vfx_commonprofile.subsurfaceRadius.rgb;\n#else\n    _surface.subsurfaceRadius = float3(0.f);\n#endif\n#endif\n    \n    \n#ifdef USE_TRANSMISSION\n#ifdef USE_TRANSMISSION_MAP\n    _surface.transmission = u_transmissionTexture.sample(u_transmissionTextureSampler, _surface.transmissionTexcoord).r;\n#if defined(USE_TRANSMISSION_TEXTURE_COMPONENT)\n    _surface.transmission = colorFromMask(_surface.transmission, USE_TRANSMISSION_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_TRANSMISSION_INTENSITY\n    _surface.transmission *= vfx_commonprofile.transmissionIntensity;\n#endif\n#elif defined(USE_TRANSMISSION_COLOR)\n    _surface.transmission = vfx_commonprofile.transmission;\n#else\n    _surface.transmission = 0.f;\n#endif\n    \n#ifdef USE_TRANSMISSIONCOLOR_MAP\n    _surface.transmissionColor = u_transmissionColorTexture.sample(u_transmissionColorTextureSampler, _surface.transmissionColorTexcoord).rgb;\n#if defined(USE_TRANSMISSIONCOLOR_TEXTURE_COMPONENT)\n    _surface.transmissionColor = colorFromMask(_surface.transmissionColor, USE_TRANSMISSIONCOLOR_TEXTURE_COMPONENT).rgb;\n#endif\n#ifdef USE_TRANSMISSIONCOLOR_INTENSITY\n    _surface.transmissionColor *= vfx_commonprofile.transmissionColorIntensity;\n#endif\n#elif defined(USE_TRANSMISSIONCOLOR_COLOR)\n    _surface.transmissionColor = vfx_commonprofile.transmissionColor.rgb;\n#else\n    _surface.transmissionColor = float3(0.f);\n#endif\n#endif\n    \n#ifdef USE_EMISSION_MAP\n    _surface.emission = u_emissionTexture.sample(u_emissionTextureSampler, _surface.emissionTexcoord);\n#if defined(USE_EMISSION_TEXTURE_COMPONENT)\n    _surface.emission = colorFromMask(_surface.emission, USE_EMISSION_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_EMISSION_INTENSITY\n    _surface.emission *= vfx_commonprofile.emissionIntensity;\n#endif\n#elif defined(USE_EMISSION_COLOR)\n    _surface.emission = vfx_commonprofile.emissionColor;\n#elif defined(USE_EMISSION)\n    _surface.emission = float4(0.);\n#endif\n#ifdef USE_SELFILLUMINATION_MAP\n    _surface.selfIllumination = u_selfIlluminationTexture.sample(u_selfIlluminationTextureSampler, _surface.selfIlluminationTexcoord);\n#if defined(USE_SELFILLUMINATION_TEXTURE_COMPONENT)\n    _surface.selfIllumination = colorFromMask(_surface.selfIllumination, USE_SELFILLUMINATION_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_SELFILLUMINATION_INTENSITY\n    _surface.selfIllumination *= vfx_commonprofile.selfIlluminationIntensity;\n#endif\n#elif defined(USE_SELFILLUMINATION_COLOR)\n    _surface.selfIllumination = vfx_commonprofile.selfIlluminationColor;\n#elif defined(USE_SELFILLUMINATION)\n    _surface.selfIllumination = float4(0.);\n#endif\n#ifdef USE_MULTIPLY_MAP\n    _surface.multiply = u_multiplyTexture.sample(u_multiplyTextureSampler, _surface.multiplyTexcoord);\n#if defined(USE_MULTIPLY_TEXTURE_COMPONENT)\n    _surface.multiply = colorFromMask(_surface.multiply, USE_MULTIPLY_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_MULTIPLY_INTENSITY\n    _surface.multiply = mix(float4(1.), _surface.multiply, vfx_commonprofile.multiplyIntensity);\n#endif\n#elif defined(USE_MULTIPLY_COLOR)\n    _surface.multiply = vfx_commonprofile.multiplyColor;\n#elif defined(USE_MULTIPLY)\n    _surface.multiply = float4(1.);\n#endif\n#ifdef USE_TRANSPARENT_MAP\n    _surface.transparent = u_transparentTexture.sample(u_transparentTextureSampler, _surface.transparentTexcoord);\n#if defined(USE_TRANSPARENT_TEXTURE_COMPONENT)\n    _surface.transparent = colorFromMask(_surface.transparent, USE_TRANSPARENT_TEXTURE_COMPONENT);\n#endif\n#ifdef USE_TRANSPARENT_INTENSITY\n    _surface.transparent *= vfx_commonprofile.transparentIntensity;\n#endif\n#elif defined(USE_TRANSPARENT_COLOR)\n    _surface.transparent = vfx_commonprofile.transparentColor;\n#elif defined(USE_TRANSPARENT)\n    _surface.transparent = float4(1.f);\n#endif\n    \n#ifdef USE_METALNESS_MAP\n#if defined(USE_METALNESS_TEXTURE_COMPONENT)\n    _surface.metalness = colorFromMask(u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord), USE_METALNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.metalness = u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord).r;\n#endif\n#ifdef USE_METALNESS_INTENSITY\n    _surface.metalness *= vfx_commonprofile.metalnessIntensity;\n#endif\n#elif defined(USE_METALNESS_COLOR)\n    _surface.metalness = vfx_commonprofile.metalness;\n#else\n    _surface.metalness = 0.f;\n#endif\n    \n#ifdef USE_ROUGHNESS_MAP\n#if defined(USE_ROUGHNESS_TEXTURE_COMPONENT)\n    _surface.roughness = colorFromMask(u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord), USE_ROUGHNESS_TEXTURE_COMPONENT).r;\n#else\n    _surface.roughness = u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord).r;\n#endif\n#ifdef USE_ROUGHNESS_INTENSITY\n    _surface.roughness *= vfx_commonprofile.roughnessIntensity;\n#endif\n#elif defined(USE_ROUGHNESS_COLOR)\n    _surface.roughness = vfx_commonprofile.roughness;\n#else\n    _surface.roughness = 0.f;\n#endif\n#if (defined USE_POSITION) && (USE_POSITION == 2)\n    _surface.position = in.position;\n#endif\n#if (defined USE_NORMAL) && (USE_NORMAL == 2)\n#if defined(HAS_NORMAL) || defined(USE_OPENSUBDIV)\n#ifdef USE_DOUBLE_SIDED\n    _surface.geometryNormal = normalize(in.normal.xyz) * (isFrontFacing ? 1.f : -1.f );\n#else\n    _surface.geometryNormal = normalize(in.normal.xyz);\n#endif\n#else \n    _surface.geometryNormal = normalize( cross(dfdy( _surface.position ), dfdx( _surface.position ) ));\n#ifdef USE_GBUFFER_OUTPUT\n    _surface.geometryNormal = vfx::mat3(vfx_frame.inverseViewTransform) * _surface.geometryNormal;\n#endif\n#endif\n    _surface.normal = _surface.geometryNormal;\n    _surface.clearCoatNormal = _surface.geometryNormal;\n#ifdef USE_BENTNORMALS\n    _surface.aoDirectionnal = mix(0., _surface.ambientOcclusion, dot(_surface.bentNormal, _surface.normal)*0.5+0.5);\n#endif\n#endif\n#if defined(USE_TANGENT) && (USE_TANGENT == 2)\n    _surface.tangent = in.tangent;\n#endif\n#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)\n    _surface.bitangent = in.bitangent;\n#endif\n#if (defined USE_VIEW) && (USE_VIEW == 2)\n    _surface.view = normalize(-in.position);\n    {\n        \n        float NoV = dot(_surface.geometryNormal, _surface.view);\n        _surface.view = _surface.view + max(0.f, -2.f * NoV) * _surface.geometryNormal;         \n        \n    }\n#endif\n#if defined(USE_NORMAL_MAP)\n    {\n        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.normal);\n#ifdef USE_NORMAL_MAP\n#if defined(USE_NORMAL_TEXTURE_COMPONENT)\n        _surface._normalTS.xy = colorFromMask(u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord), USE_NORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;\n        _surface._normalTS.z = sqrt(1.f - saturate(length_squared(_surface._normalTS.xy)));\n#else\n        _surface._normalTS = u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord).rgb;\n        _surface._normalTS = _surface._normalTS * 2.f - 1.f;\n#endif\n#ifdef USE_NORMAL_INTENSITY\n        _surface._normalTS = normalize(mix(float3(0.f, 0.f, 1.f), _surface._normalTS, vfx_commonprofile.normalIntensity));\n#endif\n#else\n        _surface._normalTS = float3(0.f, 0.f, 1.f);\n#endif\n        _surface.normal.rgb = normalize(ts2vs * _surface._normalTS.xyz );\n    }\n#else\n    _surface._normalTS = float3(0.f, 0.f, 1.f);\n#endif\n#if defined(USE_PBR) && !defined(USE_GBUFFER_OUTPUT)\n    {\n        _surface.rawRoughness = _surface.roughness;\n        float roughness = clamp(_surface.roughness, PBR_MIN_ROUGHNESS, 1.0);\n        float alpha = vfx_filteredAlphaFromRoughness(_surface.normal, roughness);\n        _surface.roughness = sqrt(alpha);\n    }\n#endif\n#if defined(USE_CLEARCOATNORMAL_MAP)\n    {\n        \n        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.geometryNormal);\n#ifdef USE_CLEARCOATNORMAL_MAP\n#if defined(USE_CLEARCOATNORMAL_TEXTURE_COMPONENT)\n        _surface._clearCoatNormalTS.xy = colorFromMask(u_clearCoatNormalTexture.sample(u_clearCoatnormalTextureSampler, _surface.clearCoatNormalTexcoord), USE_CLEARCOATNORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;\n        _surface._clearCoatNormalTS.z = sqrt(1.f - saturate(length_squared(_surface._clearCoatNormalTS.xy)));\n#else\n        _surface._clearCoatNormalTS = u_clearCoatNormalTexture.sample(u_clearCoatNormalTextureSampler, _surface.clearCoatNormalTexcoord).rgb;\n        _surface._clearCoatNormalTS = _surface._clearCoatNormalTS * 2.f - 1.f;\n#endif\n#ifdef USE_CLEARCOATNORMAL_INTENSITY\n        _surface._clearCoatNormalTS = mix(float3(0.f, 0.f, 1.f), _surface._clearCoatNormalTS, vfx_commonprofile.clearCoatNormalIntensity);\n#endif\n#else\n        _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);\n#endif\n        _surface.clearCoatNormal.rgb = normalize(ts2vs * _surface._clearCoatNormalTS.xyz );\n    }\n#else\n    _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);\n#endif\n    \n#ifdef USE_REFLECTIVE_MAP\n    float3 refl = reflect( -_surface.view, _surface.normal );\n    float m = 2.f * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.f)*(refl.z+1.f));\n    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, float2(float2(refl.x,-refl.y) / m) + 0.5f);\n#if defined(USE_REFLECTIVE_TEXTURE_COMPONENT)\n    _surface.reflective = colorFromMask(_surface.reflective, USE_REFLECTIVE_TEXTURE_COMPONENT).r;\n#endif\n#ifdef USE_REFLECTIVE_INTENSITY\n    _surface.reflective *= vfx_commonprofile.reflectiveIntensity;\n#endif\n#elif defined(USE_REFLECTIVE_CUBEMAP)\n    float3 refl = reflect( _surface.position, _surface.normal );\n    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, vfx::mat4_mult_float3(vfx_frame.viewToCubeTransform, refl)); \n#ifdef USE_REFLECTIVE_INTENSITY\n    _surface.reflective *= vfx_commonprofile.reflectiveIntensity;\n#endif\n#elif defined(USE_REFLECTIVE_COLOR)\n    _surface.reflective = vfx_commonprofile.reflectiveColor;\n#elif defined(USE_REFLECTIVE)\n    _surface.reflective = float4(0.);\n#endif\n#ifdef USE_FRESNEL\n    _surface.fresnel = vfx_commonprofile.fresnel.x + vfx_commonprofile.fresnel.y * pow(1.f - saturate(dot(_surface.view, _surface.normal)), vfx_commonprofile.fresnel.z);\n    _surface.reflective *= _surface.fresnel;\n#endif\n#ifdef USE_SHININESS\n    _surface.shininess = vfx_commonprofile.materialShininess;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_SURFACE_MODIFIER\n    \n    __DoSurfaceModifier__\n    \n#endif\n    \n    \n    \n    \n    \n    VFXShaderLightingContribution _lightingContribution(_surface, in);\n#ifdef USE_LIGHT_MODIFIER\n    __LightModifierCopyDecl__\n#endif\n#ifdef USE_AMBIENT_LIGHTING\n    _lightingContribution.ambient = vfx_frame.ambientLightingColor.rgb;\n#endif\n#ifdef USE_LIGHTING\n#ifdef USE_PER_PIXEL_LIGHTING\n#ifdef USE_CLUSTERED_LIGHTING\n    uint3 clusterIndex;\n    clusterIndex.xy = uint2(in.fragmentPosition.xy * vfx_frame.clusterScale.xy); \n    clusterIndex.z = in.position.z * vfx_frame.clusterScale.z + vfx_frame.clusterScale.w; \n    \n    \n    ushort4 cluster_offset_count = u_clusterTexture.read(clusterIndex);\n    int lid = cluster_offset_count.x;\n#endif\n\n#ifdef USE_PBR\n    _lightingContribution.prepareForPBR(u_specularDFGDiffuseHammonTexture, vfx_commonprofile.selfIlluminationOcclusion);\n    \n    \n#ifdef USE_SELFILLUMINATION\n    _lightingContribution.add_irradiance_from_selfIllum();\n#else\n#ifdef USE_PROBES_LIGHTING \n\n#ifdef USE_IBL_TRANSFORM\n    _lightingContribution.add_global_irradiance_from_sh(vfx_frame.environmentTransform * vfx_frame.viewToCubeTransform, vfx_node.shCoefficients);\n#else\n    _lightingContribution.add_global_irradiance_from_sh(vfx_frame.viewToCubeTransform, vfx_node.shCoefficients);\n#endif \n\n#else\n\n#ifdef USE_IBL_TRANSFORM\n    _lightingContribution.add_global_irradiance_probe(u_irradianceTexture, vfx_frame.environmentTransform * vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#else\n    _lightingContribution.add_global_irradiance_probe(u_irradianceTexture, vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#endif \n\n#endif \n#endif\n\n    \n#ifdef CFX_USE_REFLECTION_PROBES\n    int probe_count = (cluster_offset_count.z & 0xff);\n    for (int i = 0 ; i < probe_count; ++i, ++lid) {\n        if ((vfx_node.categoryBitmask & vfx_lights[LightIndex(lid)].categoryBitmask) == 0) continue;\n        _lightingContribution.add_local_probe(vfx_lights[LightIndex(lid)], u_reflectionProbeTexture);\n    }\n#if PROBES_NORMALIZATION\n    float3 probesNormalization = 0;\n#if PROBES_OUTER_BLENDING\n    probesNormalization = _lightingContribution.probesWeightedSum.rgb / max(1.f, _lightingContribution.probesWeightedSum.a);\n#else\n    probesNormalization = _lightingContribution.probesWeightedSum.rgb / _lightingContribution.probesWeightedSum.a;\n#endif \n#ifdef DISABLE_SPECULAR\n    _lightingContribution.pbr.envDiffuse += probesNormalization;\n#else\n    _lightingContribution.specular += probesNormalization;\n#endif\n\n    float globalFactor = saturate(1.f - _lightingContribution.probesWeightedSum.a);\n#else\n    float globalFactor = _lightingContribution.probeRadianceRemainingFactor;\n#endif \n\n#ifndef DISABLE_SPECULAR\n#ifdef USE_IBL_TRANSFORM\n    _lightingContribution.add_global_probe(vfx_frame.environmentTransform * vfx_frame.viewToCubeTransform, globalFactor * vfx_frame.environmentIntensity,\n                                           u_reflectionProbeTexture);\n#else\n    _lightingContribution.add_global_probe(vfx_frame.viewToCubeTransform, globalFactor * vfx_frame.environmentIntensity,\n                                           u_reflectionProbeTexture);\n#endif \n#endif \n    \n#else \n\n#ifndef DISABLE_SPECULAR\n\n#ifdef USE_IBL_TRANSFORM\n    _lightingContribution.add_global_probe(u_radianceTexture, vfx_frame.environmentTransform * vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#else\n   _lightingContribution.add_global_probe(u_radianceTexture, vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#endif \n    \n#ifdef USE_CLEARCOAT\n    \n#ifdef USE_IBL_TRANSFORM\n    _lightingContribution.add_global_probeClearCoat(u_radianceTexture, vfx_frame.environmentTransform * vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#else\n    _lightingContribution.add_global_probeClearCoat(u_radianceTexture, vfx_frame.viewToCubeTransform, vfx_frame.environmentIntensity);\n#endif \n    \n#endif \n\n    \n#endif \n#endif \n\n#endif \n    #if DEBUG_PIXEL\n        switch (DEBUG_PIXEL) {\n            case 1: _output.color = float4(_surface.normal * 0.5f + 0.5f, 1.f); break;\n            case 2: _output.color = float4(_surface.geometryNormal * 0.5f + 0.5f, 1.f); break;\n            case 3: _output.color = float4(_surface.tangent * 0.5f + 0.5f, 1.f); break;\n            case 4: _output.color = float4(in.uv0, 0.f, 1.f); break;\n            case 5: _output.color = float4(_surface.diffuse.rgb, 1.f); break;\n            case 6: _output.color = float4(float3(_surface.roughness), 1.f); break;\n            case 7: _output.color = float4(float3(_surface.metalness), 1.f); break;\n            case 8: _output.color = float4(float3(_surface.ambientOcclusion), 1.f); break;\n                \n            #ifdef USE_BENTNORMALS\n                case 9: _output.color = float4(float3(_surface.bentNormal * 0.5f + 0.5f), 1.f); break;\n            #else\n                case 9: _output.color = float4(float3(_surface.normal * 0.5f + 0.5f), 1.f); break;\n            #endif\n            default: break;\n        }\n        return _output;\n    #endif\n    \n    __FragmentDoLighting__\n    \n    #ifdef USE_CLUSTERED_LIGHTING\n        \n        int omni_count = cluster_offset_count.y & 0xff;\n        for (int i = 0 ; i < omni_count; ++i, ++lid) {\n            if ((vfx_node.categoryBitmask & vfx_lights[LightIndex(lid)].categoryBitmask) == 0) continue;\n            _lightingContribution.add_local_omni(vfx_lights[LightIndex(lid)]);\n        }\n\n        \n        int spot_count = (cluster_offset_count.y >> 8);\n        for (int i = 0 ; i < spot_count; ++i, ++lid) {\n            if ((vfx_node.categoryBitmask & vfx_lights[LightIndex(lid)].categoryBitmask) == 0) continue;\n            _lightingContribution.add_local_spot(vfx_lights[LightIndex(lid)]);\n        }\n\n    #endif\n#else \n        _lightingContribution.diffuse = in.diffuse;\n    #ifdef USE_SPECULAR\n        _lightingContribution.specular = in.specular;\n    #endif\n#endif \n    #ifdef AVOID_OVERLIGHTING\n        _lightingContribution.diffuse = saturate(_lightingContribution.diffuse);\n    #ifdef USE_SPECULAR\n        _lightingContribution.specular = saturate(_lightingContribution.specular);\n    #endif \n    #endif \n#else \n    _lightingContribution.diffuse = float3(0.);\n#endif \n\n    \n    \n    \n    \n#ifndef USE_GBUFFER_OUTPUT\n#ifdef USE_PBR\n    { \n        float3 diffuseAlbedo = mix(_lightingContribution.pbr.albedo, float3(0.0), _surface.metalness);\n        \n        \n#ifdef USE_PBR_TRANSPARENCY\n        float3 color = (_lightingContribution.ambient * _surface.ambientOcclusion) * _lightingContribution.pbr.albedo;\n#else\n        float3 color = (_lightingContribution.ambient * _surface.ambientOcclusion) * _surface.diffuse.rgb;\n#endif\n        \n        color += _lightingContribution.pbr.envDiffuse;\n        color += _lightingContribution.diffuse * diffuseAlbedo;\n#ifndef DISABLE_SPECULAR\n#ifndef DISABLE_SPECULAR_IBL\n        color += _lightingContribution.pbr.envSpecular;\n#endif\n        color += _lightingContribution.specular;\n#endif\n#ifdef USE_EMISSION\n        color += _surface.emission.rgb;\n#endif\n#ifdef USE_MULTIPLY\n        color *= _surface.multiply.rgb;\n#endif\n#ifdef USE_MODULATE\n        color *= _lightingContribution.modulate;\n#endif\n#ifndef USE_GBUFFER_OUTPUT\n        _output.color.rgb = color;\n#endif\n    }\n#else \n\n#ifdef USE_SHADOWONLY\n    _output.color.rgb = float3(0.0);\n    _output.color.a = 1. - _lightingContribution.shadowFactor;\n#else\n#ifdef USE_CONSTANT\n    _output.color.rgb = _surface.diffuse.rgb;\n    \n#ifdef USE_EMISSION\n    _output.color.rgb += _surface.emission.rgb;\n#endif\n#ifdef USE_MULTIPLY\n    _output.color.rgb *= _surface.multiply.rgb;\n#endif\n    \n#else\n    _output.color.rgb = illuminate(_surface, _lightingContribution);\n#endif\n#endif \n#endif \n\n#ifndef USE_SHADOWONLY\n  #ifdef USE_PBR_TRANSPARENCY\n    _output.color.a = _lightingContribution.pbr.transparency;\n  #else\n    _output.color.a = _surface.diffuse.a;\n  #endif\n#endif\n\n#ifdef USE_FOG\n    applyFog(_output.color, length(_surface.position.xyz), vfx_frame.fogParameters, vfx_frame.fogColor);\n#endif\n\n#if !defined(DIFFUSE_PREMULTIPLIED) && !defined(USE_PBR_TRANSPARENCY)\n    _output.color.rgb *= _surface.diffuse.a;\n#endif\n    \n    \n    \n    \n    \n#ifdef USE_SHADOWONLY\n    float transparencyFactor = 1.0;\n  #ifdef USE_NODE_OPACITY\n    transparencyFactor *= in.nodeOpacity;\n  #endif\n    _output.color.a *= transparencyFactor; \n\n#else \n\n#ifdef USE_TRANSPARENT \n    \n#ifndef USE_PBR_TRANSPARENCY\n  _output.color *= _surface.transparent.a;\n#endif\n\n#endif \n    \n#ifdef USE_NODE_OPACITY\n    _output.color *= in.nodeOpacity;\n#endif\n    \n#endif \n#endif \n\n    \n    \n    \n    \n#ifdef USE_MODIFIER_FRAMEBUFFER\n    const VFXFramebuffer _framebuffer = {\n#if defined(CFX_SUPPORTS_PROGRAMMABLE_BLENDING) && defined(USE_MODIFIER_FRAMEBUFFER_COLOR0)\n        .color = framebufferColor0\n#else\n        .color = 0.f\n#endif\n    };\n#endif\n    \n#ifdef USE_FRAGMENT_MODIFIER\n    \n    __DoFragmentModifier__\n    \n#endif\n#if defined(USE_CLUSTERED_LIGHTING) && defined(DEBUG_CLUSTER_TILE)\n    _output.color.rgb = mix(_output.color.rgb, float3(vfx::debugColorForCount(clusterIndex.z).xyz), 0.1f);\n    _output.color.rgb = mix(_output.color.rgb, float3(clusterIndex.x & 0x1 ^ clusterIndex.y & 0x1).xyz, 0.01f);\n#endif\n    \n#ifdef USE_ALPHA_CUTOFF\n    if (_output.color.a <= vfx_commonprofile.alphaCutoff)\n        discard_fragment();\n#endif\n\n#ifdef USE_POINT_RENDERING\n    if ((dfdx(pointCoord.x) < 0.5f) && (length_squared(pointCoord * 2.f - 1.f) > 1.f)) {\n        discard_fragment();\n    }\n#endif\n    \n    \n#ifdef USE_OUTLINE\n    _output.color.rgb = in.outlineHash;\n#endif\n    \n\n#if defined(USE_MOTIONBLUR) && !defined(USE_GBUFFER_OUTPUT)\n#ifdef USE_MULTIPLE_RENDERING\n    _output.motionblur.xy = half2((in.mv_fragment.xy - vfx_frame.viewportSize.zw) / in.mv_fragment.z - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * vfx_frame.motionBlurIntensity;\n#else\n    _output.motionblur.xy = half2((in.mv_fragment.xy / in.mv_fragment.z) - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * vfx_frame.motionBlurIntensity;\n#endif\n    _output.motionblur.z = length(_output.motionblur.xy);\n    _output.motionblur.w = half(-_surface.position.z);\n#endif\n\n#ifdef USE_NORMAL_ROUGHNESS_OUTPUT\n#ifdef USE_PBR\n    _output.normalRoughness = half4( half3(_surface.normal.xyz), half(_surface.rawRoughness) );\n#else\n    _output.normalRoughness = half4( half3(_surface.normal.xyz), 0.h );\n#endif\n#endif\n                                 \n#ifdef USE_ALBEDO_METALNESS_OUTPUT\n#ifdef USE_PBR\n    _output.albedoMetalnessOutput = half4( half3(_surface.diffuse.rgb), half(_surface.metalness) );\n#else \n    _output.albedoMetalnessOutput = half4( 0.h );\n#endif\n#endif\n    \n#ifdef USE_RADIANCE_AO_OUTPUT\n#ifdef USE_PBR\n    _output.radianceAOOutput = half4(half3(_lightingContribution.pbr.envSpecular.rgb), half(_surface.ambientOcclusion));\n#else\n    _output.radianceAOOutput = half4(0.h, 0.h, 0.h, 0.h);\n#endif\n#endif\n    \n#ifdef USE_BARYCENTRIC_WIREFRAME\n#ifdef USE_BARYCENTRIC_COORD\n    const float3 d = 1.0f * fwidth(baryCoord);\n    const float3 s = smoothstep(d * 0.25f, d * 0.75, u_barycentricCoord);\n    _output.color = mix(float4(1.0), _output.color, min3(s.x, s.y, s.z));\n#endif\n#endif\n    \n#ifdef USE_GBUFFER_OUTPUT\n    float opacity = _surface.diffuse.a;\n#ifdef USE_NODE_OPACITY\n    opacity *= in.nodeOpacity;\n#endif\n    \n    float dither = vfx::interleaved_gradient_noise(in.fragmentPosition.xy);\n    dither = fract(dither + in.fragmentPosition.z * 1.61803398875);\n    dither = fract(dither + vfx_frame.frame * 1.61803398875);\n    if (opacity < dither) discard_fragment();\n    if (opacity < 0.01) discard_fragment();\n    \n    float3 emission = float3(0.);\n#ifdef USE_EMISSION\n    emission = _surface.emission.rgb;\n#endif\n    _output.albedo = float4(_surface.diffuse.rgb, opacity);\n    _output.normals = float4(_surface.normal.xyz, -_surface.position.z);\n    _output.roughmetal = float4(_surface.roughness, _surface.metalness, _surface.ambientOcclusion, 1.);\n    _output.color = float4(emission, 1.);\n    \n    float2 vfx_prevUv = (in.mv_lastFragment.xy / in.mv_lastFragment.z);\n    float2 vfx_uv = (in.mv_fragment.xy / in.mv_fragment.z);\n    _output.velocity.xy = (vfx_prevUv - vfx_uv) * float2(.5,-.5);\n    \n#ifdef USE_MOTIONBLUR\n    _output.velocity.z = length(_output.velocity.xy);\n    _output.velocity.w = -_surface.position.z;\n#endif\n    ushort clearcoatIR = packHalf2ToUShort(half2(_surface.clearCoat, _surface.clearCoatRoughness));\n    _output.clearCoat = half4(half3(_surface.clearCoatNormal), as_type<half>(clearcoatIR));\n    \n    _output.subsurface = half4(half3(_surface.subsurfaceRadius), half(_surface.subsurface));\n    \n    float transmissionColorLength = length(_surface.transmissionColor);\n    _surface.transmissionColor /= max(1e-4, transmissionColorLength);\n    ushort transmissionRG = packHalf2ToUShort(half2(_surface.transmissionColor.r, _surface.transmissionColor.g));\n    ushort transmissionBW = packHalf2ToUShort(half2(_surface.transmissionColor.b, _surface.transmission));\n    _output.transmission = ushort4(transmissionRG, transmissionBW,\n                                 as_type<ushort>(half(transmissionColorLength)), as_type<ushort>(half(vfx_commonprofile.indexOfRefraction)));\n#endif\n\n#ifdef USE_RE_SYSTEM_TREATMENTS\n\n#ifdef USE_MULTIPLE_RENDERING\n#ifdef USE_VERTEX_AMPLIFICATION\n    uint cameraIndex = amplificationID;\n#else\n    uint cameraIndex = in.sliceIndex;\n#endif\n#else\n    uint cameraIndex = 0;\n#endif \n\n    uint sampleMask = 0;\n\n    vfx::api_v2::re_buffers buffers = vfx::api_v2::re_buffers {\n        .entityConstants      = u_re_entityConstants,\n        .viewConstants        = u_re_viewConstants,\n        .globalConstants      = u_re_globalConstants,\n        .objectConstants      = u_re_vfx_objectConstants,\n        .entityArgumentBuffer = u_re_vfx_entityArgumentBuffer,\n        .sceneArgumentBuffer  = u_re_vfx_sceneArgumentBuffer,\n#ifdef USE_RE_SYSTEM_TREATMENTS_TIER_1_AB\n        .probeTextures        = u_re_vfx_virtualEnvProbeTextures\n#endif\n    };\n\n    auto params = vfx::api_v2::make_system_treatment_parameters(in.crworldPosition, in.fragmentPosition, cameraIndex, in.screen_uv);\n    _output.color = float4(vfx::api_v2::apply_system_treatments(half4(_output.color), params, buffers, sampleMask));\n#endif \n\n    return _output;\n}\n\n#pragma mark - Namespace End\n\n    \n"
- "#define USE_QUAT_FOR_IES 1\n#define USE_PBR_DOMINANT_DIRECTION 1\n\n#define PBR_INTENSITY_FACTOR M_PI_2_F\n#define BoostFactor (20.0f * PBR_INTENSITY_FACTOR)\n\n\nstruct vfx_light\n{\n    float4 color; \n    float3 pos; \n    float3 dir; \n    float shadowRadius; \n    uint8_t lightType; \n    uint8_t shadowSampleCount; \n                                \n    union {\n        struct {\n            float4      cascadeScale[4]; \n            float4      cascadeBias[4];\n        } directional; \n        struct {\n            float4      attenuationFactors; \n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n            float4x4    projection;\n            float       depthBias;\n#else\n            float3      shadowScaleBias; \n#endif\n        } omni;\n        struct {\n            float4      _attenuationFactors; \n            float2      scaleBias; \n        } spot;\n        struct {\n            float4      _attenuationFactors; \n            float2      scaleBias; \n#if USE_QUAT_FOR_IES\n            float4      light_from_view_quat; \n#else\n            float4x4    light_from_view; \n#endif\n        } ies;\n        union {\n            struct {\n                float2 halfExtents;\n                float doubleSided;\n            } rectangle;\n            struct {\n                uint32_t vertexCount;\n                float doubleSided;\n            } polygon;\n            struct {\n                float halfLength;\n            } line;\n            struct {\n                float2 halfExtents;\n                float doubleSided;\n            } ellipse;\n            struct {\n                float3 halfExtents;\n            } ellipsoid;\n        } area;\n        struct {\n            float3  offset;\n            float4  halfExtents; \n            float3  parallaxCenter;\n            float3  parallaxExtents;\n            int32_t index; \n            int32_t parallaxCorrection; \n        } probe;\n    } parameters; \n\n    float4x4    shadowMatrix; \n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    float4 tiles[6]; \n#endif\n\tuint8_t categoryBitmask;\n};\n\n#if defined(__METAL_VERSION__) \n\nusing namespace metal;\n\nnamespace vfx_lighting {\n    static constexpr sampler linearSampler = sampler(filter::linear, mip_filter::linear);\n}\n\nstruct VFXShaderSurface {\n    float3 view;                \n    float3 position;            \n    float3 normal;              \n#ifdef USE_BENTNORMALS\n    float3 bentNormal;          \n    float aoDirectionnal;       \n#endif\n    float3 geometryNormal;      \n    float2 normalTexcoord;      \n    float3 tangent;             \n    float3 bitangent;           \n    float4 diffuse;             \n    float2 diffuseTexcoord;     \n    float4 specular;            \n    float2 specularTexcoord;    \n    float4 emission;            \n    float2 emissionTexcoord;    \n    float4 selfIllumination;            \n    float2 selfIlluminationTexcoord;    \n    float4 multiply;            \n    float2 multiplyTexcoord;    \n    float4 transparent;         \n    float2 transparentTexcoord; \n    float4 reflective;          \n    float  metalness;           \n    float2 metalnessTexcoord;   \n    float  roughness;           \n    float2 roughnessTexcoord;   \n    float  rawRoughness;        \n    float clearCoat;            \n    float2 clearCoatTexcoord;   \n    float clearCoatRoughness;   \n    float2 clearCoatRoughnessTexcoord;\n    float3 clearCoatNormal;     \n    float2 clearCoatNormalTexcoord;\n#ifdef USE_SUBSURFACE\n    float subsurface;\n    float2 subsurfaceTexcoord;\n    float3 subsurfaceRadius;\n    float2 subsurfaceRadiusTexcoord;\n#endif\n#ifdef USE_TRANSMISSION\n    float transmission;\n    float2 transmissionTexcoord;\n    float3 transmissionColor;\n    float2 transmissionColorTexcoord;\n#endif\n    float shininess;            \n    float fresnel;              \n    float ambientOcclusion;     \n    float2 ambientOcclusionTexcoord;   \n    float3 _normalTS;           \n    float3 _clearCoatNormalTS;  \n#ifdef USE_SURFACE_EXTRA_DECL\n    __SurfaceExtraDecl__\n#endif\n};\n\n\n\nstruct VFXShaderLight {\n    float4 intensity;\n    float3 direction;\n\n    float  _att;\n    float3 _spotDirection;\n    float  _distance;\n};\n\nenum VFXShadingModel\n{\n    VFXShadingModelConstant,\n    VFXShadingModelPhong,\n    VFXShadingModelNone,\n    VFXShadingModelPhysicallyBased,\n    VFXShadingModelShadowOnly,\n\n    VFXShadingModelCustom \n};\n\n#define PROBES_NORMALIZATION 0\n#define PROBES_OUTER_BLENDING 1\n\nstruct VFXShaderLightingContribution\n{\n    float3 ambient;\n    float3 diffuse;\n    float3 specular;\n    float3 modulate;\n\n#ifdef USE_SHADOWONLY\n    float shadowFactor;\n#endif\n\n#if PROBES_NORMALIZATION\n    float4 probesWeightedSum; \n#else\n    float  probeRadianceRemainingFactor;\n#endif\n\n    thread VFXShaderSurface& surface;\n\n#ifdef USE_PER_VERTEX_LIGHTING\n    commonprofile_io out;\n#else\n    commonprofile_io in;\n#endif\n\n#ifdef USE_PBR\n    struct {\n        float3 albedo;\n        float3 envDiffuse;\n        float3 envSpecular;\n        float3 reflectance;\n        float3 probeReflectance;\n#ifndef USE_PBR_LAMBERTIAN_REFLECTION\n        float2 diffuseHammonFactors;\n#endif\n#ifdef USE_PBR_TRANSPARENCY\n        float  transparency;\n#endif\n        float  NoV;\n        float  selfIlluminationOcclusion;\n#ifdef USE_CLEARCOAT\n        float  NoVClearCoat;\n        float3 probeReflectanceClearCoat;\n#endif\n    } pbr;\n#endif\n    \n    VFXShaderLightingContribution(thread VFXShaderSurface& iSurface, commonprofile_io io):surface(iSurface)\n#ifdef USE_PER_VERTEX_LIGHTING\n    ,out(io)\n#else\n    ,in(io)\n#endif\n    {\n        ambient = 0.f;\n        diffuse = 0.f;\n        specular = 0.f;\n#ifdef USE_SHADOWONLY\n        shadowFactor = 1.f;\n#endif\n\n#if PROBES_NORMALIZATION\n#if PROBES_OUTER_BLENDING\n        probesWeightedSum = float4(0.f);\n#else\n        probesWeightedSum = float4(0.f, 0.f, 0.f, 0.000001f); \n#endif\n#else\n        probeRadianceRemainingFactor = 1.f;\n#endif\n\n#ifdef USE_MODULATE\n        modulate = 1.f;\n#else\n        modulate = 0.f;\n#endif\n    }\n\n#ifdef USE_PBR\n    void prepareForPBR(texture2d<float, access::sample> specularDFGDiffuseHammonTexture, float occ)\n    {\n        pbr.envDiffuse = 0.f;\n        pbr.envSpecular = 0.f;\n        pbr.selfIlluminationOcclusion = occ;\n      \n        pbr.albedo = surface.diffuse.rgb;\n#ifdef USE_PBR_TRANSPARENCY\n  #ifdef DIFFUSE_PREMULTIPLIED\n        \n        pbr.transparency = 1.f;\n  #else\n        pbr.transparency = surface.diffuse.a;\n  #endif\n  #ifdef USE_TRANSPARENCY\n    #ifdef USE_PER_VERTEX_LIGHTING\n        pbr.transparency *= out.transparency;\n    #else\n        pbr.transparency *= in.transparency;\n    #endif\n  #endif\n  #ifdef USE_TRANSPARENT\n        pbr.transparency *= surface.transparent.a;\n  #endif\n        pbr.albedo *= pbr.transparency;\n  #ifdef DIFFUSE_PREMULTIPLIED\n        \n        \n        pbr.transparency *= surface.diffuse.a;\n  #endif\n#endif\n        \n        float3 n = surface.normal;\n        float3 v = surface.view;\n        pbr.NoV = abs(dot(n, v));\n        \n        float roughness = surface.roughness;\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        float2 specularDFG = specularDFGDiffuseHammonTexture.sample(vfx_lighting::linearSampler, float2(pbr.NoV, roughness)).rg;\n#else\n#ifdef USE_RE_RADIANCE_IRRADIANCE_MAP_SAMPLING\n        float4 env = specularDFGDiffuseHammonTexture.sample(vfx_lighting::linearSampler, float2(roughness, 1.0f - pbr.NoV));\n#else\n        float4 env = specularDFGDiffuseHammonTexture.sample(vfx_lighting::linearSampler, float2(pbr.NoV, roughness));\n#endif\n        float2 specularDFG = env.xy;\n        pbr.diffuseHammonFactors = env.zw;\n#endif\n        \n        pbr.reflectance = mix(PBR_F0_NON_METALLIC, pbr.albedo, surface.metalness);\n        pbr.probeReflectance = pbr.reflectance * specularDFG.r + specularDFG.g;\n                                \n#ifdef USE_CLEARCOAT\n        pbr.NoVClearCoat = abs(dot(surface.clearCoatNormal, v));\n        float2 DFGClearCoat = specularDFGDiffuseHammonTexture.sample(vfx_lighting::linearSampler, float2(pbr.NoVClearCoat, surface.clearCoatRoughness)).rg;\n        pbr.probeReflectanceClearCoat = 0.04 * DFGClearCoat.r + DFGClearCoat.g;\n#endif\n    }\n#endif\n\n\n#ifdef USE_LIGHT_MODIFIER\n    __LightModifierExtraDecl__\n#endif\n\n    float4 debug_pixel(float2 fragmentPosition)\n    {\n        const int width = 64;\n        switch (int(fragmentPosition.x + fragmentPosition.y ) / width) {\n            case 0: return float4(surface.view, 1.f);\n            case 1: return float4(surface.position, 1.f);\n            case 2: return float4(surface.normal, 1.f);\n            case 3: return float4(surface.geometryNormal, 1.f);\n            case 4: return float4(float3(surface.ambientOcclusion), 1.f);\n            case 5: return surface.diffuse;\n            case 6: return float4(float3(surface.metalness), 1.f);\n            case 7: return float4(float3(surface.roughness), 1.f);\n            case 8: return float4(ambient, 1.f);\n            case 9: return float4(diffuse, 1.f);\n            default: return float4(specular, 1.f);\n        }\n    }\n\n    \n\n    static inline float3 lambert_diffuse(float3 l, float3 n, float3 color, float intensity) {\n        return color * (intensity * saturate(dot(n, l)));\n    }\n\n    void phong(float3 l, float3 color, float intensity)\n    {\n        float3 D = lambert_diffuse(l, surface.normal, color, intensity);\n        diffuse += D;\n\n        float3 r = reflect(-l, surface.normal);\n        specular += powr(saturate(dot(r, surface.view)), surface.shininess) * D;\n    }\n\n#ifdef USE_PBR\n    void physicallyBased(float3 l, float3 color, float intensity)\n    {\n        float3 n         = surface.normal;\n        float3 v         = surface.view;\n        float  roughness = surface.roughness;\n        float  alpha     = roughness * roughness;\n\n        float3 h = normalize(l + v);\n\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n        \n        float D   = vfx_brdf_D(alpha, NoH);\n        float3 F  = vfx_brdf_F_opt(pbr.reflectance, LoH);\n        float Vis = vfx_brdf_V(alpha, NoL, pbr.NoV);\n\n        \n        diffuse  += color * (NoL * M_1_PI_F * intensity);\n        specular += color * F * (NoL * D * Vis * intensity);\n        \n        #ifdef USE_CLEARCOAT\n            n = surface.clearCoatNormal;\n\n            roughness = max(surface.clearCoatRoughness, 0.089f);\n            alpha = roughness * roughness; \n        \n            \n            \n            float NoH_coat = saturate(dot(n, h));\n            float NoL_coat = saturate(dot(n, l));\n            D   = vfx_brdf_D(alpha, NoH_coat);\n            F   = vfx_brdf_F_opt(0.04, LoH) * surface.clearCoat;\n            Vis = vfx_brdf_V(alpha, NoL_coat, saturate(dot(n,v)));\n        \n            float attenuation = 1.0 - F.r;\n            specular *=  (attenuation * attenuation);\n            specular += color * F * ( NoL_coat * D * Vis * intensity);\n        #endif\n    }\n#endif\n\n    void custom(float3 _l, float3 _color, float _intensity)\n    {\n#ifdef USE_LIGHT_MODIFIER\n        thread VFXShaderLightingContribution &_lightingContribution = *this;\n        thread VFXShaderSurface& _surface = surface;\n        VFXShaderLight _light = {.direction = _l, .intensity = float4(_color, 1.f), ._att = _intensity };\n        \n        __DoLightModifier__\n        \n#endif\n    }\n\n    void shade(float3 l, float3 color, float intensity)\n    {\n#ifdef LIGHTING_MODEL\n        switch (LIGHTING_MODEL) {\n#ifdef USE_SHADOWONLY\n            case VFXShadingModelShadowOnly:      shadowFactor *= intensity; break;\n#endif\n            case VFXShadingModelPhong:           phong(l, color, intensity); break;\n#ifdef USE_PBR\n            case VFXShadingModelPhysicallyBased: physicallyBased(l, color, intensity); break;\n#endif\n            case VFXShadingModelCustom:          custom(l, color, intensity); break;\n            default:  break; \n        }\n#endif\n    }\n\n    \n    \n    \n    float pbr_dist_attenuation_alternate(float3 l, float cutoff) {\n        \n        float radius = 0.1f; \n        float factor = 1.f / (1.f + length(l)/radius);\n        float attenuation = saturate(factor * factor); \n        return saturate((attenuation - cutoff) / (1.f - cutoff));\n    }\n\n    float pbr_dist_attenuation(float3 l, float inv_square_radius) {\n        float sqr_dist = length_squared(l);\n        float atten = 1.f / max(sqr_dist, 0.0001f);\n\n        \n        float factor = saturate(1.f - vfx::sq(sqr_dist * inv_square_radius));\n        return atten * factor * factor;\n    }\n\n    float non_pbr_dist_attenuation(float3 l, float4 att)\n    {\n        return powr(saturate(length(l) * att.x + att.y), att.z);\n    }\n\n    float dist_attenuation(float3 unnormalized_l, vfx_light light)\n    {\n#ifdef USE_PBR\n        return pbr_dist_attenuation(unnormalized_l, light.parameters.omni.attenuationFactors.w);\n        \n        \n#else\n#ifdef USE_SHADOWONLY\n        return 1.f;\n#endif\n        return non_pbr_dist_attenuation(unnormalized_l, light.parameters.omni.attenuationFactors);\n#endif\n    }\n\n    float spot_attenuation(float3 l, vfx_light light)\n    {\n#ifdef USE_SHADOWONLY\n        return 1.f;\n#endif\n        \n        return saturate(dot(l, light.dir) * light.parameters.spot.scaleBias.x + light.parameters.spot.scaleBias.y);\n    }\n\n    void shade_modulate(float3 l, float4 color, float intensity)\n    {\n        constexpr half3 white = half3(1.h);\n        \n        modulate *= float3(mix(white, half3(color.rgb), half(color.a * intensity)));\n    }\n\n    float3 gobo(float3 pos, vfx_light light, texture2d<half> goboTexture, sampler goboSampler)\n    {\n        half3 g = texture2DProj(goboTexture, goboSampler, (light.shadowMatrix * float4(pos, 1.f))).rgb;\n        return light.color.rgb * float3(mix(1.h, g, half(light.color.a)));\n    }\n\n    float shadow(float3 pos, vfx_light light, depth2d<float> shadowMap)\n    {\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n        float4 tile = light.tiles[0];\n#else\n        float4 tile = {0.0, 0.0, 1.0, 1.0};\n#endif\n        float shadow = ComputeShadow(vfx_shadow_sampler, pos, light.shadowMatrix, shadowMap, tile);\n        return 1.f - shadow * light.color.a; \n    }\n\n    \n    float shadow(float3 pos, vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel)\n    {\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n        float4 tile = light.tiles[0];\n#else\n        float4 tile = {0.0, 0.0, 1.0, 1.0};\n#endif\n        float4 lightScreen = transformViewPosInShadowSpace(pos, light.shadowMatrix);\n        lightScreen.xyz /= lightScreen.w;\n        float shadow = ComputeSoftShadow(vfx_shadow_sampler, lightScreen.xyz, shadowMap, shadowKernel, light.shadowSampleCount, light.shadowRadius, tile);\n        return 1.f - shadow * light.color.a; \n    }\n\n    float shadow(float3 pos, vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int shadowSampleCount)\n    {\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n        float4 tile = light.tiles[0];\n#else\n        float4 tile = {0.0, 0.0, 1.0, 1.0};\n#endif\n        float4 lightScreen = transformViewPosInShadowSpace(pos, light.shadowMatrix);\n        lightScreen.xyz /= lightScreen.w;\n        float shadow = ComputeSoftShadow(vfx_shadow_sampler, lightScreen.xyz, shadowMap, shadowKernel, shadowSampleCount, light.shadowRadius, tile);\n        return 1.f - shadow * light.color.a; \n    }\n\n    float shadow(float3 pos, vfx_light light, depth2d<float> shadowMap, int shadowSampleCount)\n    {\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n        float4 tile = light.tiles[0];\n#else\n        float4 tile = {0.0, 0.0, 1.0, 1.0};\n#endif\n        float shadow = ComputeSoftShadowGrid(vfx_shadow_sampler, pos, light.shadowMatrix, shadowMap, shadowSampleCount, tile);\n        return 1.f - shadow * light.color.a; \n    }\n\n\nushort getCubeFace(float3 dir)\n{\n    \n    float3 absDir = abs(dir);\n    float maxAxis = max(absDir.x, max(absDir.y, absDir.z));\n    if (absDir.z == maxAxis) {\n        \n        return dir.z > 0.0f ? 4 : 5;\n    } else if (absDir.y == maxAxis) {\n        \n        return dir.y > 0.0f ? 2 : 3;\n    } else {\n        \n        \n        return dir.x > 0.0f ? 0 : 1;\n    }\n}\n\n\nfloat4x4 getFaceRotation(ushort face) {\n    float4 xAxis(1.0, 0.0, 0.0, 0.0);\n    float4 yAxis(0.0, 1.0, 0.0, 0.0);\n    float4 zAxis(0.0, 0.0, 1.0, 0.0);\n    float4 zero (0.0, 0.0, 0.0, 1.0);\n    switch (face) {\n        case 0: return float4x4(-zAxis, yAxis,  xAxis, zero); \n        case 1: return float4x4( zAxis, yAxis, -xAxis, zero); \n        case 2: return float4x4( xAxis,-zAxis,  yAxis, zero); \n        case 3: return float4x4( xAxis, zAxis, -yAxis, zero); \n        case 4: return float4x4(-xAxis, yAxis, -zAxis, zero); \n        default:  return float4x4( xAxis, yAxis,  zAxis, zero); \n    }\n}\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    float shadow_omni(float3 pos_vs, float3 nrm_vs, vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n#else\n    float shadow_omni(float3 pos_vs, float3 nrm_vs, vfx_light light, depthcube<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n#endif\n    {\n        \n#define USE_TANGENT_SAMPLING 0\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n        float  depthBias = light.parameters.omni.depthBias;\n#else\n        float2 scaleBias = light.parameters.omni.shadowScaleBias.xy;\n        float  depthBias = light.parameters.omni.shadowScaleBias.z;\n#endif\n\n        \n        pos_vs += nrm_vs * depthBias;\n\n        \n        float4 pos_ls = (light.shadowMatrix * float4(pos_vs, 1.f));\n\n#if !CFX_USE_ATLAS_FOR_SHADOW_MAP\n        \n        float z_lin = vfx::reduce_max(abs(pos_ls));\n\n        \n        \n        \n        \n        float z_ndc = (z_lin * scaleBias.x + scaleBias.y) / z_lin - depthBias;\n#endif\n\n        \n        float shadow;\n        if (sampleCount <= 1) {\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n            ushort face = getCubeFace(normalize(pos_ls.xyz));\n            float4 tile = light.tiles[face];\n            shadow = ComputeShadow(vfx_shadow_sampler, (getFaceRotation(face) * pos_ls).xyz, light.parameters.omni.projection, shadowMap, tile);\n#else\n            shadow = shadowMap.sample_compare(vfx_shadow_sampler, pos_ls.xyz, z_ndc);\n#endif\n        } else {\n\n            \n            float filteringSizeFactor = light.shadowRadius;\n\n#if USE_TANGENT_SAMPLING\n            float3 tgt_x, tgt_y;\n            vfx::orthogonal_basis(pos_ls, tgt_x, tgt_y);\n#else\n            float3 nrm_ls = (light.shadowMatrix * float4(nrm_vs, 0.f)).xyz;\n#endif\n\n            \n            float totalAccum = 0.0;\n            for(int i=0; i < sampleCount; i++){\n\n#if USE_TANGENT_SAMPLING\n                float2 scale = shadowKernel[i].xy * filteringSizeFactor * 2.f;\n                float3 smp_ls = pos_ls.xyz + tgt_x * scale.x + tgt_y * scale.y;\n#else\n                float3 smp_ls = pos_ls.xyz + vfx::randomHemisphereDir(nrm_ls, shadowKernel[i].xy * 0.5 + 0.5) * filteringSizeFactor;\n#endif\n\n                \n                \n                \n\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n                ushort face = getCubeFace(normalize(smp_ls.xyz));\n                float4 tile = light.tiles[face];\n                totalAccum += ComputeShadow(vfx_shadow_sampler, (getFaceRotation(face) * float4(smp_ls, 1.0)).xyz, light.parameters.omni.projection, shadowMap, tile);\n#else\n                totalAccum += shadowMap.sample_compare(vfx_shadow_sampler, smp_ls, z_ndc);\n#endif\n\n            }\n            shadow = totalAccum / float(sampleCount);\n        }\n\n        return 1.f - shadow * light.color.a; \n    }\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    float shadow(float3 pos, constant vfx_light& light, depth2d<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount)\n    {\n        float shadow = ComputeCascadedShadow(vfx_shadow_sampler, pos, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius, light.tiles).a;\n        return 1.f - shadow * light.color.a; \n    }\n#else\n    float shadow(float3 pos, constant vfx_light& light, depth2d_array<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount)\n    {\n        float shadow = ComputeCascadedShadow(vfx_shadow_sampler, pos, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius).a;\n        return 1.f - shadow * light.color.a; \n    }\n#endif\n\n    \n\n    void add_directional(vfx_light light)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n    void add_directional(vfx_light light, texture2d<half> goboTexture, sampler goboSampler)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n    void add_directional(vfx_light light, depth2d<float> shadowMap)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        intensity *= shadow(surface.position, light, shadowMap);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n    void add_directional(vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        intensity *= shadow(surface.position, light, shadowMap, shadowKernel);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    void add_directional(vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        intensity *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n    void add_directional(vfx_light light, depth2d<float> shadowMap, int sampleCount)\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        intensity *= shadow(surface.position, light, shadowMap, sampleCount);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    void add_directional(constant vfx_light& light, depth2d<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount, bool debugCascades)\n#else\n    void add_directional(constant vfx_light& light, depth2d_array<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount, bool debugCascades)\n#endif\n    {\n#ifdef USE_PBR\n        float intensity = PBR_INTENSITY_FACTOR;\n#else\n        float intensity = 1.0f;\n#endif\n        if (debugCascades) {\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n            float4 shadowDebug = ComputeCascadedShadow(vfx_shadow_sampler, surface.position, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius, light.tiles);\n#else\n            float4 shadowDebug = ComputeCascadedShadow(vfx_shadow_sampler, surface.position, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius);\n#endif\n            intensity *= (1.f - shadowDebug.a);\n            shade(light.dir, light.color.rgb, intensity);\n            diffuse.rgb = mix(diffuse.rgb, shadowDebug.rgb, light.color.a);\n        } else {\n            intensity *= shadow(surface.position, light, shadowMaps, cascadeCount, blendCascade, shadowKernel, sampleCount);\n            shade(light.dir, light.color.rgb, intensity);\n        }\n    }\n\n    \n\n    void add_omni(vfx_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        shade(l, light.color.rgb, dist_attenuation(unnormalized_l, light) * BoostFactor);\n    }\n\n#if CFX_USE_ATLAS_FOR_SHADOW_MAP\n    void add_omni(vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n#else\n    void add_omni(vfx_light light, depthcube<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n#endif\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light) * BoostFactor;\n        intensity *= shadow_omni(surface.position, surface.normal, light, shadowMap, shadowKernel, sampleCount);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    void add_local_omni(vfx_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        shade(l, light.color.rgb, dist_attenuation(unnormalized_l, light) * BoostFactor);\n    }\n\n    \n\n    void add_spot(vfx_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light) * BoostFactor;\n        intensity      *= spot_attenuation(l, light);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    void add_spot(vfx_light light, texture2d<half> goboTexture, sampler goboSampler)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light) * BoostFactor;\n        intensity      *= spot_attenuation(l, light);\n        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);\n\n        \n        \n        \n              shade(l, light.color.rgb, intensity);\n        \n    }\n\n    void add_local_spot(vfx_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light) * BoostFactor;\n        intensity      *= spot_attenuation(l, light);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    \n    void add_spot(vfx_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light) * BoostFactor;;\n        intensity      *= spot_attenuation(l, light);\n        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        shade(l, light.color.rgb, intensity);\n    }\n    \n    void add_spot(vfx_light light, \n                  depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount,\n                  texture2d<half> goboTexture, sampler goboSampler)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= spot_attenuation(l, light);\n        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    \n\n#ifdef USE_PBR\n\n    \n\n#ifdef CFX_SUPPORT_CUBE_ARRAY\n    void add_local_probe(vfx_light light, texturecube_array<half> probeTextureArray)\n#else\n    void add_local_probe(vfx_light light, texture2d_array<half> probeTextureArray)\n#endif\n    {\n#if !PROBES_NORMALIZATION\n        if (probeRadianceRemainingFactor <= 0.f)\n            return;\n#endif\n\n        bool parallaxCorrection = light.parameters.probe.parallaxCorrection;\n        int    probeIndex       = light.parameters.probe.index;\n        float3 probeExtents     = light.parameters.probe.halfExtents.xyz;\n        float  blendDist        = light.parameters.probe.halfExtents.w;\n        float3 probeOffset      = light.parameters.probe.offset;\n        float3 parallaxExtents  = light.parameters.probe.parallaxExtents;\n        float3 parallaxCenter   = light.parameters.probe.parallaxCenter;\n\n        float3 n = surface.normal;\n        float3 v = surface.view;\n        float3 r = reflect(-v, n); \n\n        float3 specDir = vfx::mat4_mult_float3(light.shadowMatrix, r);\n\n        \n        float3 pos_ls = (light.shadowMatrix * float4(surface.position, 1.f)).xyz;\n\n        \n        float3 d = abs(pos_ls) - probeExtents;\n#if PROBES_OUTER_BLENDING\n        if (any(d > blendDist))\n#else\n        if (any(d > 0.f))\n#endif\n        {\n            return;\n        }\n\n#if PROBES_NORMALIZATION\n        \n        \n#if PROBES_OUTER_BLENDING\n        float3 nd = saturate(-(d / blendDist) * 0.5f + 0.5f);\n#else\n        float3 nd = saturate(-(d / blendDist));\n#endif\n        float probeFactor = (nd.x * nd.y * nd.z) * light.color.r;\n#else\n        \n        float sd = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n#if PROBES_OUTER_BLENDING\n        float probeFactor = saturate(1.f - sd / blendDist);\n#else\n        float probeFactor = saturate(-sd / blendDist);\n#endif\n        \n        \n        \n        probeFactor *= probeRadianceRemainingFactor * light.color.r; \n#endif\n\n        if (parallaxCorrection ) {\n            \n            float3 pos_off = pos_ls + parallaxCenter;\n            float3 t1 = ( parallaxExtents - pos_off) / specDir;\n            float3 t2 = (-parallaxExtents - pos_off) / specDir;\n            float3 tmax = max(max(0, t1), t2); \n            float t = min(tmax.x, min(tmax.y, tmax.z));\n\n            \n            float3 hit_ls = pos_ls + specDir * t;\n            specDir = hit_ls - probeOffset;\n        }\n\n        \n        specDir.z *= -1.0;\n        \n        \n        \n        float ao = surface.ambientOcclusion;\n#ifdef USE_BENTNORMALS\n        ao = mix(mix(max(dot(surface.bentNormal, r), 0.), 1., ao), ao, surface.roughness*surface.roughness);\n#endif\n        \n        float mipd = float(probeTextureArray.get_num_mip_levels()) - 1.f;\n        const float intensity = ao * probeFactor;\n\n        float mips = surface.roughness * mipd;\n#ifdef CFX_SUPPORT_CUBE_ARRAY\n        float3 LD = float3(probeTextureArray.sample(vfx_lighting::linearSampler, specDir, probeIndex, level(mips)).rgb);\n#else\n        float2 specUV = vfx::dual_paraboloid_from_cartesian(normalize(specDir));\n        float3 LD = float3(probeTextureArray.sample(vfx_lighting::linearSampler, specUV, probeIndex, level(mips)).rgb);\n#endif\n\n        \n\n        \n#if PROBES_NORMALIZATION\n        probesWeightedSum += float4(LD * intensity * pbr.probeReflectance, probeFactor);\n#else\n        probeRadianceRemainingFactor = saturate(probeRadianceRemainingFactor - probeFactor);\n#ifdef DISABLE_SPECULAR\n        pbr.envDiffuse += LD * intensity * pbr.probeReflectance;\n#else\n        pbr.envSpecular += LD * intensity * pbr.probeReflectance;\n#endif\n#endif\n        \n#ifdef USE_CLEARCOAT\n        n = surface.clearCoatNormal;\n        r = reflect(-v, n);\n        specDir = vfx::mat4_mult_float3(light.shadowMatrix, r);\n        \n        specDir.z *= -1.0;\n        if (parallaxCorrection ) {\n            float3 pos_off = pos_ls + parallaxCenter;\n            \n            float3 t1 = ( parallaxExtents - pos_off) / specDir;\n            float3 t2 = (-parallaxExtents - pos_off) / specDir;\n            float3 tmax = max(max(0, t1), t2); \n            float t = min(tmax.x, min(tmax.y, tmax.z));\n            \n            \n            float3 hit_ls = pos_ls + specDir * t;\n            specDir = hit_ls - probeOffset;\n        }\n        mips = surface.clearCoatRoughness * mipd;\n#ifdef CFX_SUPPORT_CUBE_ARRAY\n        LD = float3(probeTextureArray.sample(vfx_lighting::linearSampler, specDir, probeIndex, level(mips)).rgb);\n#else\n        specUV = vfx::dual_paraboloid_from_cartesian(normalize(specDir));\n        LD = float3(probeTextureArray.sample(vfx_lighting::linearSampler, specUV, probeIndex, level(mips)).rgb);\n#endif\n#if PROBES_NORMALIZATION\n        probesWeightedSum += float4(LD * intensity * pbr.probeReflectanceClearCoat, probeFactor) * surface.clearCoat;\n#else\n\n#ifdef DISABLE_SPECULAR\n        pbr.envDiffuse += LD * intensity * pbr.probeReflectanceClearCoat  * surface.clearCoat;\n#else\n        specular += LD * intensity * pbr.probeReflectanceClearCoat  * surface.clearCoat;\n#endif\n#endif\n#endif\n    }\n\n    void add_global_probe(float4x4 localDirToWorldCubemapDir,\n                          float environmentIntensity,\n#ifdef CFX_SUPPORT_CUBE_ARRAY\n                          texturecube_array<half> probeTextureArray\n#else\n                          texture2d_array<half> probeTextureArray\n#endif\n                          )\n    {\n        float3 n = surface.normal;\n        float3 v = surface.view;\n        float3 r = reflect(-v, n); \n        \n        float3 specDir = vfx::mat4_mult_float3(localDirToWorldCubemapDir, r);\n        float mips = surface.roughness * float(probeTextureArray.get_num_mip_levels() - 1);\n        \n#ifdef CFX_SUPPORT_CUBE_ARRAY\n        float3 LD = float3(probeTextureArray.sample(vfx_lighting::linearSampler, specDir, 0, level(mips)).rgb);\n#else\n        float2 specUV = vfx::dual_paraboloid_from_cartesian(normalize(specDir));\n        float3 LD = float3(probeTextureArray.sample(vfx_lighting::linearSampler, specUV, 0, level(mips)).rgb);\n#endif\n        \n        \n        specular += pbr.probeReflectance * LD * surface.ambientOcclusion * environmentIntensity;\n    }\n\n    void add_global_probe(texturecube<float, access::sample> specularLD,\n                          float4x4                           localDirToWorldCubemapDir,\n                          float                              environmentIntensity)\n    {\n        float3 n        = surface.normal;\n        float3 v        = surface.view;\n        float3 r        = reflect(-v, n); \n        float roughness = surface.roughness;\n\n#if USE_PBR_DOMINANT_DIRECTION\n        float alpha = roughness * roughness;\n        float smoothness = 1.0f - alpha;\n        \n        float specularLerpFactor = (1. - smoothness * (sqrt(smoothness) + alpha));\n        \n        float3 specularDominantNDirection = mix(r, n, specularLerpFactor); \n#else\n        float3 specularDominantNDirection = r;\n#endif\n        \n        float ao = surface.ambientOcclusion;\n        \n        \n        \n#ifdef USE_BENTNORMALS\n        ao = mix(mix(max(dot(surface.bentNormal, r), 0.), 1., ao), ao, roughness*roughness);\n#endif\n        \n        \n#ifdef USE_RE_RADIANCE_IRRADIANCE_MAP_SAMPLING\n        float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);\n#else\n        float mipLevel = sqrt(roughness) * float(specularLD.get_num_mip_levels() - 1);\n#endif\n        float3 dir = vfx::mat4_mult_float3(localDirToWorldCubemapDir, specularDominantNDirection);\n        float3 LD = specularLD.sample(vfx_lighting::linearSampler, dir, level(mipLevel)).rgb;\n        pbr.envSpecular += pbr.probeReflectance * LD * ao * environmentIntensity;\n    }\n\n#ifdef USE_CLEARCOAT\n    void add_global_probeClearCoat(texturecube<float, access::sample> specularLD,\n                          float4x4                           localDirToWorldCubemapDir,\n                          float                              environmentIntensity)\n    {\n        float3 n = surface.clearCoatNormal;\n        \n        float3 v        = surface.view;\n        float3 r        = reflect(-v, n); \n        float roughness = surface.clearCoatRoughness;\n\n        \n        \n        float ao = surface.ambientOcclusion;\n        \n        \n#ifdef USE_BENTNORMALS\n        ao = mix(mix(max(dot(surface.bentNormal, r), 0.), 1., ao), ao, roughness*roughness);\n#endif\n        \n        \n        float mipLevel = sqrt(roughness) * float(specularLD.get_num_mip_levels() - 1);\n        float3 LD = specularLD.sample(vfx_lighting::linearSampler, vfx::mat4_mult_float3(localDirToWorldCubemapDir, r), level(mipLevel)).rgb;\n\n        \n        float Fc = vfx_brdf_F_opt(0.04f, pbr.NoVClearCoat).r * surface.clearCoat;\n        float attenuation = 1.0f - Fc;\n        specular *= (attenuation * attenuation);\n        \n        specular += pbr.probeReflectanceClearCoat * LD  * surface.clearCoat * ao * environmentIntensity;\n    }\n#endif\n    \n    \n\n    void add_irradiance_from_selfIllum()\n    {\n        float selfIlluminationAO = saturate(mix(1.f, surface.ambientOcclusion, pbr.selfIlluminationOcclusion));\n        float3 irradiance = surface.selfIllumination.rgb;\n        \n        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        pbr.envDiffuse += selfIlluminationAO * irradiance * diffuseAlbedo;\n#else\n        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);\n        pbr.envDiffuse += selfIlluminationAO * irradiance * diffuseReflectance;\n#endif\n    }\n\n    void add_global_irradiance_from_sh(float4x4         localDirToWorldCubemapDir,\n#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)\n                                       sh2_coefficients shCoefficients)\n#else\n    sh3_coefficients shCoefficients)\n#endif\n    {\n#ifdef USE_BENTNORMALS\n        float3 n = surface.bentNormal;\n        float ao = surface.aoDirectionnal;\n#else\n        float3 n = surface.normal;\n        float ao = surface.ambientOcclusion;\n#endif\n        float3 n_sh_space = vfx::mat4_mult_float3(localDirToWorldCubemapDir, n);\n        float3 irradiance = shEvalDirection(float4(n_sh_space.xy, -n_sh_space.z, 1.), shCoefficients);\n        \n        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        pbr.envDiffuse += ao * irradiance * diffuseAlbedo;\n#else\n        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);\n        pbr.envDiffuse += ao * irradiance * diffuseReflectance;\n#endif\n    }\n\n    void add_global_irradiance_probe(texturecube<float, access::sample> irradianceTexture,\n                                     float4x4                           localDirToWorldCubemapDir,\n                                     float                              environmentIntensity)\n    {\n#if USE_PBR_DOMINANT_DIRECTION\n#ifdef USE_BENTNORMALS\n        float3 n = surface.bentNormal;\n        float ao = surface.aoDirectionnal;\n#else\n        float3 n = surface.normal;\n        float ao = surface.ambientOcclusion;\n#endif\n        float3 v = surface.view;\n        \n        \n        const half a = 1.02341h * surface.roughness - 1.51174h; \n        const half b = -0.511705h * surface.roughness + 0.755868h;\n        const half diffuseBendFactor = saturate((pbr.NoV * a + b) * surface.roughness);\n        float3 diffuseDominantNDirection = mix(n, v, diffuseBendFactor);\n#else\n        float3 diffuseDominantNDirection = n;\n#endif\n        \n        float3 n_cube_space = vfx::mat4_mult_float3(localDirToWorldCubemapDir, diffuseDominantNDirection);\n        float3 irradiance = irradianceTexture.sample(vfx_lighting::linearSampler, n_cube_space).rgb;\n        \n        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);\n        \n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        pbr.envDiffuse += (ao * environmentIntensity) * irradiance * diffuseAlbedo;\n#else\n        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);\n        pbr.envDiffuse += (ao * environmentIntensity) * irradiance * diffuseReflectance;\n#endif\n    }\n\n#endif \n\n    \n\n    static constexpr sampler iesSampler = sampler(filter::linear, mip_filter::none, address::clamp_to_edge);\n    \n    float ies_attenuation(float3 l, vfx_light light, texture2d<half> iesTexture)\n    {\n#if USE_QUAT_FOR_IES\n        float3 v    = vfx::quaternion_rotate_vector(light.parameters.ies.light_from_view_quat, -l);\n#else\n        float3 v    = vfx::matrix_rotate(light.parameters.ies.light_from_view, -l);\n#endif\n        float phi   = (v.z * light.parameters.ies.scaleBias.x + light.parameters.ies.scaleBias.y);\n        float theta = atan2(v.y, v.x) * 0.5f * M_1_PI_F;\n        return iesTexture.sample(iesSampler, float2(phi, abs(theta))).r;\n    }\n\n    void add_ies(vfx_light light, texture2d<half> iesTexture)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= ies_attenuation(l, light, iesTexture);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    void add_ies(vfx_light light, texture2d<half> iesTexture, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= ies_attenuation(l, light, iesTexture);\n        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    \n\n    void add_area_rectangle(vfx_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n        float3 v = surface.view;\n        float3 n = surface.normal;\n        float3 p = surface.position;\n\n        \n        float3 tangent = normalize(v - n * dot(v, n));\n        float3 bitangent = cross(n, tangent);\n        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));\n\n        float3 lightCenter = light.shadowMatrix[3].xyz;\n        \n        \n        float sidedness = dot(light.dir, lightCenter - p);\n        if (light.parameters.area.rectangle.doubleSided == false && sidedness <= 0.f)\n            return;\n        \n        float3 lightRight = light.shadowMatrix[0].xyz * light.parameters.area.rectangle.halfExtents.x * sign(sidedness);\n        float3 lightTop   = light.shadowMatrix[1].xyz * light.parameters.area.rectangle.halfExtents.y;\n        \n        float4x3 cornerDirections = float4x3((lightCenter + lightRight + lightTop) - p,\n                                             (lightCenter + lightRight - lightTop) - p,\n                                             (lightCenter - lightRight - lightTop) - p,\n                                             (lightCenter - lightRight + lightTop) - p);\n\n        cornerDirections[0] = shadingSpaceTransform * cornerDirections[0];\n        cornerDirections[1] = shadingSpaceTransform * cornerDirections[1];\n        cornerDirections[2] = shadingSpaceTransform * cornerDirections[2];\n        cornerDirections[3] = shadingSpaceTransform * cornerDirections[3];\n\n        float diffuseAmount = pbr_area_light_eval_rectangle(cornerDirections);\n\n        float brdfNorm = 1.f;\n        float3x3 inverseLTCMatrix = vfx_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);\n\n        cornerDirections[0] = inverseLTCMatrix * cornerDirections[0];\n        cornerDirections[1] = inverseLTCMatrix * cornerDirections[1];\n        cornerDirections[2] = inverseLTCMatrix * cornerDirections[2];\n        cornerDirections[3] = inverseLTCMatrix * cornerDirections[3];\n\n        float specularAmount = brdfNorm * pbr_area_light_eval_rectangle(cornerDirections);\n\n        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); \n        \n        float3 lightColor = light.color.rgb;\n        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;\n        specular += specularAmount * lightColor * pbr.reflectance;\n#endif\n    }\n\n    void add_area_polygon(vfx_light light, texture2d_array<float> bakedDataTexture, device packed_float2 *vertexPositions)\n    {\n#ifdef USE_PBR\n        float3 v = surface.view;\n        float3 n = surface.normal;\n        float3 p = surface.position;\n\n        \n        float3 tangent = normalize(v - n * dot(v, n));\n        float3 bitangent = cross(n, tangent);\n        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));\n\n        float3 lightCenter = light.shadowMatrix[3].xyz;\n        \n        \n        float sidedness = dot(light.dir, lightCenter - p);\n        if (light.parameters.area.polygon.doubleSided == false && sidedness <= 0.f)\n            return;\n        \n        float3 lightRight = light.shadowMatrix[0].xyz * sign(sidedness);\n        float3 lightTop   = light.shadowMatrix[1].xyz;\n\n        p           = shadingSpaceTransform * p;\n        lightCenter = shadingSpaceTransform * lightCenter;\n        lightRight  = shadingSpaceTransform * lightRight;\n        lightTop    = shadingSpaceTransform * lightTop;\n\n        float diffuseAmount = pbr_area_light_eval_polygon(p, lightCenter, lightRight, lightTop, light.parameters.area.polygon.vertexCount, vertexPositions);\n\n        float brdfNorm = 1.f;\n        float3x3 inverseLTCMatrix = vfx_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);\n\n        p           = inverseLTCMatrix * p;\n        lightCenter = inverseLTCMatrix * lightCenter;\n        lightRight  = inverseLTCMatrix * lightRight;\n        lightTop    = inverseLTCMatrix * lightTop;\n\n        float specularAmount = brdfNorm * pbr_area_light_eval_polygon(p, lightCenter, lightRight, lightTop, light.parameters.area.polygon.vertexCount, vertexPositions);\n        \n        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); \n\n        float3 lightColor = light.color.rgb;\n        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;\n        specular += specularAmount * lightColor * pbr.reflectance;\n#endif\n    }\n\n    void add_area_line(vfx_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n        float3 v = surface.view;\n        float3 n = surface.normal;\n        float3 p = surface.position;\n\n        \n        float3 tangent = normalize(v - n * dot(v, n));\n        float3 bitangent = cross(n, tangent);\n        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));\n\n        float3 lightCenter = light.shadowMatrix[3].xyz;\n        float3 lightRight  = light.shadowMatrix[0].xyz * light.parameters.area.line.halfLength;\n\n        float2x3 cornerDirections = float2x3((lightCenter + lightRight) - p,\n                                             (lightCenter - lightRight) - p);\n\n        cornerDirections[0] = shadingSpaceTransform * cornerDirections[0];\n        cornerDirections[1] = shadingSpaceTransform * cornerDirections[1];\n\n        float diffuseAmount = pbr_area_light_eval_line(cornerDirections);\n\n        float brdfNorm = 1.f;\n        float3x3 inverseLTCMatrix = vfx_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);\n\n        cornerDirections[0] = inverseLTCMatrix * cornerDirections[0];\n        cornerDirections[1] = inverseLTCMatrix * cornerDirections[1];\n\n        float specularAmount = brdfNorm * pbr_area_light_eval_line(cornerDirections);\n\n        float3 ortho = normalize(cross(cornerDirections[0], cornerDirections[1]));\n        float ltcWidthFactor = 1.0 / length(vfx_ltc_matrix_invert_transpose(inverseLTCMatrix) * ortho);\n        specularAmount *= ltcWidthFactor;\n        \n        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); \n\n        float3 lightColor = light.color.rgb;\n        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;\n        specular += specularAmount * lightColor * pbr.reflectance;\n#endif\n    }\n\n    void add_area_ellipse(vfx_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n#endif\n    }\n\n    void add_area_ellipsoid(vfx_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n#endif\n    }\n};\n\n#endif \n"
- "CFXWorldHasOptions(_world, CFXWorldCreationOptionEnableVFXCoreFeatures)"
- "PointsOfInterest"
- "USE_METALNESS_ROUGHNESS_OUTPUT"
- "Welcome to VFX 203.0.21 (Jun 28 2025 03:04:30)"
- "r^v16@0:8"
- "uploadCustomParameters"

```
