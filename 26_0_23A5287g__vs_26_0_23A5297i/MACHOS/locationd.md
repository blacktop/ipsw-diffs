## locationd

> `/usr/libexec/locationd`

```diff

-3056.0.6.0.2
-  __TEXT.__text: 0x1c917f4
-  __TEXT.__auth_stubs: 0x63a0
-  __TEXT.__objc_stubs: 0x47000
-  __TEXT.__init_offsets: 0x954
-  __TEXT.__objc_methlist: 0x32f98
-  __TEXT.__const: 0x164469
-  __TEXT.__cstring: 0x1f2b9e
-  __TEXT.__gcc_except_tab: 0xe8ad0
-  __TEXT.__objc_methname: 0x67476
-  __TEXT.__oslogstring: 0x29dd40
-  __TEXT.__objc_classname: 0x82ab
-  __TEXT.__objc_methtype: 0x36ec3
+3056.0.14.0.0
+  __TEXT.__text: 0x1b5d8cc
+  __TEXT.__auth_stubs: 0x6310
+  __TEXT.__objc_stubs: 0x46b00
+  __TEXT.__init_offsets: 0x964
+  __TEXT.__objc_methlist: 0x32cc0
+  __TEXT.__const: 0x15c4a9
+  __TEXT.__cstring: 0x1de3fa
+  __TEXT.__gcc_except_tab: 0xd6e10
+  __TEXT.__objc_methname: 0x6742b
+  __TEXT.__oslogstring: 0x27fe9c
+  __TEXT.__objc_classname: 0x8299
+  __TEXT.__objc_methtype: 0x3724a
   __TEXT.__constg_swiftt: 0x290
   __TEXT.__swift5_typeref: 0x204
   __TEXT.__swift5_fieldmd: 0xd4

   __TEXT.__swift5_capture: 0x94
   __TEXT.__swift5_reflstr: 0x5c
   __TEXT.__swift5_builtin: 0x14
-  __TEXT.__unwind_info: 0x75fd0
-  __TEXT.__eh_frame: 0x948
-  __DATA_CONST.__auth_got: 0x31f0
-  __DATA_CONST.__got: 0x2e30
-  __DATA_CONST.__auth_ptr: 0x360
-  __DATA_CONST.__const: 0xc1db0
-  __DATA_CONST.__cfstring: 0x459a0
+  __TEXT.__unwind_info: 0x6f8b0
+  __TEXT.__eh_frame: 0x940
+  __DATA_CONST.__auth_got: 0x31a8
+  __DATA_CONST.__got: 0x2df0
+  __DATA_CONST.__auth_ptr: 0x358
+  __DATA_CONST.__const: 0xbb3b8
+  __DATA_CONST.__cfstring: 0x445a0
   __DATA_CONST.__objc_classlist: 0x15a0
   __DATA_CONST.__objc_catlist: 0xd8
-  __DATA_CONST.__objc_protolist: 0xe48
+  __DATA_CONST.__objc_protolist: 0xe40
   __DATA_CONST.__objc_imageinfo: 0x8
-  __DATA_CONST.__objc_protorefs: 0xa98
+  __DATA_CONST.__objc_protorefs: 0xa88
   __DATA_CONST.__objc_classrefs: 0x8
-  __DATA_CONST.__objc_superrefs: 0x13a0
+  __DATA_CONST.__objc_superrefs: 0x13a8
   __DATA_CONST.__objc_intobj: 0x3378
   __DATA_CONST.__objc_doubleobj: 0x150
   __DATA_CONST.__objc_arraydata: 0x1b20

   __DATA_CONST.__objc_arrayobj: 0x948
   __DATA_CONST.__objc_floatobj: 0x80
   __DATA_CONST.__linkguard: 0x15
-  __DATA.__objc_const: 0x530a0
-  __DATA.__objc_selrefs: 0x160c8
-  __DATA.__objc_ivar: 0x3dac
+  __DATA.__objc_const: 0x530a8
+  __DATA.__objc_selrefs: 0x160a8
+  __DATA.__objc_ivar: 0x3dd0
   __DATA.__objc_data: 0xdb78
-  __DATA.__data: 0x618e0
+  __DATA.__data: 0x61850
   __DATA.__common: 0x1fe18
-  __DATA.__bss: 0x10710
+  __DATA.__bss: 0x10788
   - /System/Library/Frameworks/Accelerate.framework/Accelerate
   - /System/Library/Frameworks/Accounts.framework/Accounts
   - /System/Library/Frameworks/ActivityKit.framework/ActivityKit

   - /usr/lib/swift/libswiftXPC.dylib
   - /usr/lib/swift/libswift_Builtin_float.dylib
   - /usr/lib/swift/libswiftos.dylib
-  UUID: 386A168E-5ADF-3950-AAC8-80F412893203
-  Functions: 108375
-  Symbols:   3156
-  CStrings:  96554
+  UUID: 98E15A00-9D82-3DCA-B941-74EBA1B76F3D
+  Functions: 104169
+  Symbols:   3141
+  CStrings:  94012
 
Symbols:
+ _CMDataProviderStreamIndexKey
+ _OBJC_CLASS_$_CLPCMAbsoluteAltitude
- _OBJC_CLASS_$_BMAppInFocus
- _OBJC_CLASS_$_BMLocationMicroLocationVisitNumDevicesPerTechnology
- _OBJC_CLASS_$_BMLocationMicroLocationVisitProbabilityPerLocation
- _OBJC_CLASS_$_BMMicroLocationNumDevicesPerTechnology
- _OBJC_CLASS_$_BMMicroLocationProbabilityPerLabel
- _OBJC_CLASS_$_BMMicroLocationRestrictedLocalizationEvent
- _OBJC_CLASS_$_BMMicroLocationRestrictedLocalizationStream
- _OBJC_CLASS_$_BMNowPlayingEvent
- __ZN20wireless_diagnostics6google8protobuf8internal20RepeatedPtrFieldBase4SwapEPS3_
- __ZNSt3__16__sortIRNS_6__lessIjjEEPjEEvT0_S5_T_
- __ZNSt3__19to_stringEx
- _cblas_dgemv
- _cblas_dnrm2
- _cblas_dscal
- _nan
- _nextafter
- _sandbox_extension_issue_file
CStrings:
+ "#ADL,#OutputBufferInterface, failed to queue fetch request, options, %{public}@"
+ "#ADL,#OutputBufferInterface, successfully queued fetch request, options, %{public}@"
+ "#ADL,#OutputBufferInterface,fetchLocationAtDate is nil"
+ "#ADL,#OutputBufferInterface,fetchLocationAtMachContinuousTime is nil"
+ "#ADL,#OutputBufferInterface,fetchLocationsInLastSeconds is nil"
+ "#ADL,#OutputBufferInterface,fetchSparseLocationsFromMachContinuousTime is nil"
+ "#ADL,#OutputBufferInterface,fetchSparseLocationsFromMachContinuousTime,trajectory sampler returned empty vector"
+ "#CLGNSSStateQueryAssertion,#warning,daemon,empty reason,request denied"
+ "#CLGNSSStateQueryAssertion,#warning,daemon,missing bundleID,request denied"
+ "#CLGNSSStateQueryAssertion,#warning,daemon,missing bundlePath,request denied"
+ "#CLGNSSStateQueryAssertion,#warning,daemon,missing reason,request denied"
+ "#CLGNSSStateQueryAssertion,#warning,daemon,no beneficiary,request denied"
+ "#CLGNSSStateQueryAssertion,#warning,feature not supported"
+ "#CLGNSSStateQueryAssertion,#warning,invalid entitlement"
+ "#CLPDM,#Warning,Pressure,registerAvlFileToCLFU,could not setUpdateRate AVl file updater"
+ "#CLPDM,#Warning,Pressure,registerAvlFileToCLFU,could not setUpdateSource AVL file updater"
+ "#CLPDM,LocationServiceEnabled,%{public}d"
+ "#CLPDM,MA-OTA,AvlFileExpAge,%{public}f,Url,%{private}s"
+ "#CLPDM,MA-OTA,could not setup AVL file downloader"
+ "#CLPDM,MA-OTA,expiration age or file URL changed,updating the AVL file downloader"
+ "#CLPDM,Pressure data URL,default,%{private}s,MA-OTA,%{private}s"
+ "#CLPDM,could not setup AVL file downloader"
+ "#CLPDM,refPressure URL defaults,%{private}s"
+ "#CLPDM,registerAvlFileToCLFU,file download scheduled via CLFU,url,%{private}s,storeTo,%{public}s,cellRateSec,%{public}.2lf,wifiRateSec,%{public}.2lf,retryInterval,%{public}.1lf"
+ "#CLPDM,request AVL file download,time,%{public}.3f"
+ "#Error,CLPDM,could not setup AVL file downloader"
+ "#Error,DEM,could not setup AVL file downloader"
+ "#Error,FusedLoc,hID,%{public}d,DataFusion predictState failed time aligning fused location,type,%{public}d,new location mct,%{public}.3f,fused location mct,%{public}.3f,lastFusedUpdateMCT,%{public}.3f,lastFusedLocationAge_s,%{public}.3f"
+ "#Error,FusedLoc,hID,%{public}d,DataFusion propagateLocation failed time aligning fused location,type,%{public}d,new location mct,%{public}.3f,fused location mct,%{public}.3f,lastFusedLocationAge_s,%{public}.3f"
+ "#Error,HRSE,could not setup AVL file downloader"
+ "#Error,ProviderLoc,toDaemonLocation,fused location type is Unknown"
+ "#Error,ProviderLoc,toDaemonLocation,get fused location failed,hunc <= 0"
+ "#RTTMA,#Warning,registerRTAvailabilityFileToFileUpdater,could not setUpdateRate AVl file updater"
+ "#RTTMA,#Warning,registerRTAvailabilityFileToFileUpdater,could not setUpdateSource AVL file updater"
+ "#RTTMA,registerRTAvailabilityFileToFileUpdater,download request,url,%{public}s,storeTo,%{public}s,retryInterval,%{public}.1lf"
+ "#Warning,CLFU, could not download from %{private}s to %{public}s"
+ "#Warning,CLFU,%{private}s downloading in progress, cannot change update settings"
+ "#Warning,HRSE,registerAvlFileToCLFU,could not setUpdateRate AVl file updater"
+ "#Warning,HRSE,registerAvlFileToCLFU,could not setUpdateSource AVL file updater"
+ "#altimeter,absolute altitude count is zero for the workout,now,%.3f"
+ "#altimeter,adding elevation profile transition point,now,%.3f,isNew,%d,sampleTimestamp,%.3f,altitude,%.3f,smoothedWorkoutProfileCount,%d"
+ "#altimeter,cleaning up elevation profile segment newer than timestamp,%.3f,now,%.3f,smoothedWorkoutProfileCount,%d"
+ "#altimeter,compute elevation delta,currentTimestamp,%.3f,currentElevationDelta,%lld,delayedElevationDeltaValid,%d,delayedTimestamp,%.3f,delayedElevationDelta,%lld,elevationDelta,%lld,isAscending,%d,now,%.3f"
+ "#altimeter,core analytics for workout elevation gain,workoutType,%d,workoutDuration,%d,realtimeElevationGain,%d,batchedElevationGain,%d,fusedElevationGain,%d,diffElevationRealtimeBatched,%d,diffElevationFusedBatched,%d,maxPressureAmplitude,%.3f,durationPressureQualityGoodInMin,%d,durationPressureQualityUnknownInMin,%d,durationPressureQualityBadInMin,%d,ratioWorkoutWithDEM,%.2f,dominantSignalEnv,%d,meanAbsoluteAltitude,%{private}.2f,numAscendingDescendingSegments,%d,timeToFirstBadStateInMin,%d,numBadStatePeriods,%d,durationBadStateInMin,%d,minimumUncertaintyInElevationProfile,%.2f,now,%.3f"
+ "#altimeter,could not add first transition point,now,%.3lf,smoothedWorkoutProfileCount,%d"
+ "#altimeter,duration of bad states exceeds durartion of workout,durationBadStateInSec,%.3f,workoutDurationInSec,%d,now,%.3f"
+ "#altimeter,elevation delta incorrect,realTimeElevation,%d,elevationDelta,%lld,isAscending,%d,now,%.3f"
+ "#altimeter,finished computing elevation gain from profile,timestamp,%.3f,batchedAscended,%d,batchedDescended,%d,delayedTimestamp,%.3f,delayedBatchedAscended,%d,delayedBatchedDescended,%d,now,%.3f"
+ "#altimeter,fused batched elevation,batchedElevation,%ud,latestRealTimeElevation,%ud,elevationDelta,%lld,currentFusedElevation,%ud,isAscending,%d,now,%.3f"
+ "#altimeter,fused real time elevation,latestRealTime,%ud,elevationDelta,%lld,currentFusedElevation,%ud,isAscending,%d,now,%.3f"
+ "#altimeter,location received,type,%d,time,%.3lf,alt,%.3lf,alt_unc,%.3lf,dem_alt,%.3lf,dem_alt_unc,%.3lf,time_pressure,%.3lf,pressure,%.3lf"
+ "#altimeter,no batched elevations are computed from profile,now,%.3f"
+ "#altimeter,numEpoch is zero for the workout,now,%.3f"
+ "#altimeter,reach size limit for hmmBadStatePeriods,remove the oldest period,now,%.3f"
+ "#altimeter,received profile with no usable elements,now,%.3lf,smoothedWorkoutProfileCount,%d"
+ "#altimeter,received profile with null last element,now,%.3lf,smoothedWorkoutProfileCount,%d"
+ "#altimeter,received profile with null pointer,now,%.3lf,smoothedWorkoutProfileCount,%d"
+ "#altimeter,received profile without end of workout indicator,now,%.3lf,smoothedWorkoutProfileCount,%d"
+ "#altimeter,sending core analytics for workout elevation gain,now,%.3f"
+ "#altimeter,skip analytics upload because end time precedes start time for the workout,startTime,%.3f,endTime,%.3f,now,%.3f"
+ "#altimeter,timestamp of transition point rolls back,lastTimestamp,%.3f,currentTimestamp,%.3f,now,%.3f"
+ "#altimeter,workout elevation gain updated,startTime,%{public}.3f,endTime,%{public}.3f,pressure,%{public}.2f,realtimeAscended,%{public}d,realtimeDescended,%{public}d,fusedAscended,%{public}d,fusedDescended,%{public}d,now,%{public}.3f"
+ "#fusion,#ADL,forwarding filtered WSB location (buffered) to output buffer at MCT %{public}.3f sec"
+ "#fusion,#ADL,forwarding filtered WSB location to output buffer at MCT %{public}.3f sec"
+ "#fusion,buffered Motion Activity,type,%{public}s,confidence,%{public}s,used to set dynamics to,%{public}d"
+ "#fusion,data association,catching up with WSB fix by inflating validation gate,lastFilterUpdateMCT,%{public}.3f,abs_deltaTimeToFusedState_s,%{public}.3f,innovation_sqrd,%{public}.3f,innovation_var,%{public}.3f,timealignedHunc,%{public}.3f,fusedStateHunc,%{public}.3f,wsbHunc,%{public}.3f,lastFusedStateMCT,%{public}.3f,MotionActivity,%{public}s"
+ "#fusion,io_mct,%{public}.3f,io_applicableTime_mct,%{public}.3f,InertialOdometry derived zupt update,AccumStaticTime_s,%{public}.1f,IO_MotionState,%{public}d,IO_dynamicsMode,%{public}d,CM_dynamicsMode,%{public}d,CM_indicates_driving,%{public}d"
+ "#fusion,mct_now,%{public}.3f,recent Cell locations diversity/transitions seen,#uniqueCell,%zu,but they are overlapping,skip motion state override,dt_sinceNonCell_s,%{public}.3f,input motion state,%{public}s,confidence,%{public}s"
+ "#fusion,wsb_mct,%{public}.3f,wsb_cfat,%{public}.3f,consuming WSB location (buffered),ignoringBufferedWSB_LL,%{sensitive}.7f,%{sensitive}.7f,hunc,%{public}.3f,confidence,%{public}d,lifespan,%{public}.1f,wsb fix is older than minimum accepted time-stamp with mct,%{public}.3f,delay_s,%{public}.3f,re-wind is set,%{public}d,lastFusionTime_cfat,%{public}.3f"
+ "#pbio, CLBackgroundInertialOdometryNorthAlignment::extractLocationsForMeasurementGeneration, cannot compute machContinuousToCFAbsoluteOffset_s, cannot extractLocations,isWatch,%d,isPhone,%d"
+ "#pbio,CLIO,CLBackgroundInertialOdometryCalibrationEstimator,workoutType,%d,fCurrentlyInAnIOSupported1HzGnssOrWorkoutSession,%d"
+ "#pbio,CLIO,initialize1HzGnssParameters,isWatch,%d,workoutType,%d,motionActivityType,%d,minMeasurementInterval,%.1f,maxMeasurementInterval,%.1f,minCalibrationInterval,%.1f"
+ "#pbio,defaults,CLBIOCourse_GpsCourseAcc_rad2,%.8f,CLBIOCourse_MinGpsSpeed_mps,%.3f,CLBIODeltaCourse_VariancePercentPerS2,%.3f,CLBIOCourse_MinInterval_s,%.3f,CLBIOCourse_MaxInterval_s,%.3f,CLBIOFilterUpdatesMinIntervalDefault_s,%.1lf,isWatch,%d,isPhone,%d"
+ "+[CLBarometerCalibrationImpl updateHMMBadStatePeriods:withWorkoutSmootherSample:]"
+ "-[CLContextManagerWorkout logAndClearStatistics]"
+ "-[CLFusedElevationMonotonicAccumulator computeElevationDelta:]"
+ "-[CLFusedElevationMonotonicAccumulator feedRealtimeElevation:endTime:]"
+ "-[CLSmootherMonitor shouldFetchIOSamplesForInterval:]"
+ "/AppleInternal/Library/BuildRoots/4~B5UWugBfGqSPvqZkZWa_qXpbA56EQscVnEYUzkc/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.0.Internal.sdk/usr/local/include/boost/geometry/algorithms/detail/throw_on_empty_input.hpp"
+ "/AppleInternal/Library/BuildRoots/4~B5UWugBfGqSPvqZkZWa_qXpbA56EQscVnEYUzkc/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.0.Internal.sdk/usr/local/include/boost/uuid/detail/random_provider_posix.ipp"
+ "/AppleInternal/Library/BuildRoots/4~B5UWugBfGqSPvqZkZWa_qXpbA56EQscVnEYUzkc/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.0.Internal.sdk/usr/local/include/boost/uuid/string_generator.hpp"
+ "/AppleInternal/Library/BuildRoots/4~B5UWugBfGqSPvqZkZWa_qXpbA56EQscVnEYUzkc/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.0.Internal.sdk/usr/local/include/google/protobuf/repeated_field.h"
+ "/AppleInternal/Library/BuildRoots/4~B5UWugBfGqSPvqZkZWa_qXpbA56EQscVnEYUzkc/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.0.Internal.sdk/usr/local/include/google/protobuf/wire_format_lite_inl.h"
+ "02:43:43"
+ "02:51:04"
+ "<%s> #Warning, unexpected gap, previousTime,%f,currentTime,%f,gap,%f"
+ "<%s> #Warning, unexpected latency, time,%f,latency,%f"
+ "@ClxWsb, Fix, 1, ll, %{sensitive}.7f, %{sensitive}.7f, acc, %{public}.2f, speed, %{private}.1f, course, %{private}.1f, type, %{public}d, alt, %{private}.1f, altunc, %{public}.1f, ellipsoidalAlt, %{private}.1f, speedUnc, %{public}.1f, courseUnc, %{public}.1f, signalEnv, %{private}d, timestamp, %{public}.3f"
+ "ActivityHiFiSEScaleFactorForOdometer"
+ "ActivityOdometerConfig"
+ "ActivityScaleFactorForOdometer"
+ "ActivityTypeForFuser"
+ "ActivityTypeForOdometer"
+ "ActivityTypeForPedScaling"
+ "Airpods"
+ "B32@0:8^{BatchedElevationData=IdId}16^{BatchedElevationData=IdId}24"
+ "BasicMutex *CMDataProviderFactory::getStreamLock(enum FactoryStream)"
+ "Body metrics snapshot,weight,%f,vo2max,%f,runvo2max,%f,hrmin,%f,hrmax,%f,pal,%f"
+ "CLAbsoluteAltitudeSubHarvesterPoiClientLocal"
+ "CLFU,%{private}s download timeout must be greater than 0. Forcing to 30 seconds."
+ "CLFU,Throttling download %{private}s due to retry delay, scheduling download for %{public}.3f (%{public}.3f away)"
+ "CLFU,current download of %{private}s has timed out, canceling"
+ "CLFU,data reachability is not available - not downloading %{private}s"
+ "CLFU,data reachability is not available - not retrying %{private}s"
+ "CLFU,delay %{public}.3f for retry count %{public}d exceeds current update period of %{public}.3f, setting delay to half the current update period for %{private}s"
+ "CLFU,download of %{private}s not yet timed out. Blocking current download request"
+ "CLFU,file %{public}s,setting next update before deadline: %{public}.3fs (override)"
+ "CLFU,last %{private}s downloaded less than %{public}.3f seconds ago (%{public}.3f), scheduling download for %{public}.3f (%{public}.3f away)"
+ "CLFU,last %{private}s downloaded over %{public}.3f seconds ago (%{public}.3f), starting a download now"
+ "CLFU,registered for kNotificationCompanionConnectionUpdate for %{private}s"
+ "CLFU,retry count %{public}d, will re-download for %{private}s after delay of %{public}.3f"
+ "CLFU,scheduled download %{private}s is after %{public}.3f deadline (%{public}.3f after) - overriding"
+ "CLFU,stopping download of %{private}s"
+ "CLFU,unregistered for kNotificationCompanionConnectionUpdate for %{private}s"
+ "CLFU,we are now on large reachability %{public}s, scheduling a download for %{private}s (period %{public}.3f)"
+ "CLGnssProvider,MA-OTA,step distance fuser configuration"
+ "CLGnssSDFScaler,processActivityOdometerScaleFactorFromMA, activityOdoConfigArray is empty"
+ "CLGnssSDFScaler,processOdoAndPedometerWeightsFromMA, odoAndPedoWeightsArray is empty"
+ "CLGnssSDFScaler,processPedometerScalingFromMA, pedometerConfigArray is empty"
+ "CLGnssSDFScaler,processWorkoutOdometerFromMA, workoutOdometerConfigArray is empty"
+ "CLGnssSDFScaler,updateActivityOdometerScaleFactor,activityType absent"
+ "CLGnssSDFScaler,updateActivityOdometerScaleFactor,new,signalEnv,%d,activitytype,%d,normalScaleFactor,%f,highSEFidelityScaleFactor,%f"
+ "CLGnssSDFScaler,updateActivityOdometerScaleFactor,normal scale factor absent"
+ "CLGnssSDFScaler,updateActivityOdometerScaleFactor,signal environment absent"
+ "CLGnssSDFScaler,updateActivityOdometerScaleFactor,update,signalEnv,%d,activitytype,%d,normalScaleFactor,%f,highSEFidelityScaleFactor,%f"
+ "CLGnssSDFScaler,updateOdometerAndPedometerWeights,activityType absent"
+ "CLGnssSDFScaler,updateOdometerAndPedometerWeights,activityType,%d,odometer weight,%f,pedometer weight,%f"
+ "CLGnssSDFScaler,updateOdometerAndPedometerWeights,odometer weight absent"
+ "CLGnssSDFScaler,updateOdometerAndPedometerWeights,pedometer weight absent"
+ "CLGnssSDFScaler,updateOdometerAndPedometerWeights,weights adds up more than 1.0, activityType,%d,odometer weight,%f,pedometer weight,%f"
+ "CLGnssSDFScaler,updatePedometerScaling,activityType absent"
+ "CLGnssSDFScaler,updatePedometerScaling,activityType,%d,pedometer scaling,%f"
+ "CLGnssSDFScaler,updatePedometerScaling,pedometer scale absent"
+ "CLGnssSDFScaler,updatePedometerUnc,unc1,%f"
+ "CLGnssSDFScaler,updatePedometerUnc,unc2,%f"
+ "CLGnssSDFScaler,updateWorkoutOdometerScaleFactor,WorkoutType,%d,ScaleFactor,%f"
+ "CLGnssSDFScaler,updateWorkoutOdometerScaleFactor,scale factor absent"
+ "CLGnssSDFScaler,updateWorkoutOdometerScaleFactor,workoutType absent"
+ "CLHarvestController"
+ "CLHighResolutionSignalEnvironmentDataManager::CLHighResolutionSignalEnvironmentDataManager(id<CLIntersiloUniverse>)"
+ "CLIOLocationSearchWindow1HzGnss_s"
+ "CLIOMaxMeasurementInterval1HzGnss_s"
+ "CLIOMaxScaleFactor1HzGnssValue"
+ "CLIOMinMeasurementInterval1HzGnss_s"
+ "CLIOMinimumIntervalBetweenCalibrationFilterUpdates1HzGnss_s"
+ "CLLocationBufferBase::LCBufferLocation CLLocationControllerOutputBuffer::propagateLocationUsingNearestBin(const CLLocationBufferBase::LCBufferLocation &, const CFTimeInterval, const CLLocationBufferBase::LCBufferLocation &) const"
+ "CLRS,Criteria not met to reconstruct,is1HzData,%{public}d,isIOSupportedWorkoutType,%d,ratioOfLocationsThatAreDenseUrban,%{public}.1lf,WorkoutActivityNotWalking,%{public}d"
+ "CLRS,No reconstruction intervals available,calling smoother directly"
+ "CLRS,shouldFetchIOSamplesForInterval,workoutActivity,%{public}d,totalLocations,%{public}lu,denseUrbanCount,%{public}lu,denseUrbanPercentage,%{public}.2f,ioSupportedWorkoutType,%{public}d,hasSufficientDenseUrbanLocations,%{public}d"
+ "CLRS,skipping IO sample fetch for workout activity type,%{public}d"
+ "CLRS,skipping elevation sample fetch for workout activity type,%{public}d"
+ "CMDataProviderAccel100Mutex"
+ "CMDataProviderAccel800Mutex"
+ "CMDataProviderAccessoryDMMutex"
+ "CMDataProviderActivityMutex"
+ "CMDataProviderDMMutex"
+ "CMDataProviderElevationMutex"
+ "CMDataProviderFactoryStream: release stream %s obs %p activeRefCount %d refCnt %d"
+ "CMDataProviderFactoryStream: request stream %s obs %p leech %d activeRefCnt %d refCnt %d use count %d"
+ "CMDataProviderFactoryStream: request stream created %s obs %p leech %d activeRefCnt %d refCnt %d use count %d"
+ "CMDataProviderFactoryStream: stream %d mutex %p"
+ "CMDataProviderFactoryStream: stream %d mutex %p acquired"
+ "CMDataProviderHRMutex"
+ "CMDataProviderOdometerMutex"
+ "CMDataProviderRawHRMutex"
+ "CMDataProviderStepsMutex"
+ "CollisionRetryDelay"
+ "Connection Lost During UARP FWUP"
+ "DEM,LocationServiceEnabled,%{public}d"
+ "DEM,Notification,%{public}d"
+ "DEM,downloadIfNeeded,download availability file,needAvailability,%{public}d,location_timestamp,%{public}.3f,timeOfLastDownloadRequestAvailability,%{public}.3f,numRingsToDownloadOverCellular,%{public}d"
+ "DEM,registerAvlFileToCLFU,file download scheduled via CLFU,url,%{private}s,storeTo,%{public}s,cellRateSec,%{public}.2lf,wifiRateSec,%{public}.2lf,retryInterval,%{public}.1lf"
+ "DEM,request AVL file download,time,%{public}.3f"
+ "Elliptical"
+ "Elliptical MOdel, METS, %f, hrMets, %f, wrMets, %f, hrAvail, %d, wrAvail, %d, hrGood, %d, a, %f, c, %f, fHR, %f"
+ "FusedLoc,hID,%{public}d,predicted fused location with large uncertainty and/or large DR interval, switching to CC Fusion,type,%{public}d,new loc hunc,%{public}.1f,fused loc hunc,%{public}.1f,fused loc DR interval_s,%{public}.1f,index,%{public}d,bufferSize,%{public}zu"
+ "GPSODOM%s,activity type,%{public}d,sigEnv,%{public}d,sigFidelity,%d,distance multiplier,%{public}.3f"
+ "GPSODOM%s,activity type,%{public}d,workout type,%{public}ld,sigEnv,%{public}d,sigFidelity,%d,distance multiplier,%{public}.3f"
+ "GnssSDFSettings"
+ "HRSE,LocationServiceEnabled,%{public}d"
+ "HRSE,Notification,%{public}d"
+ "HRSE,downloadFileIfNeeded,download availability file,needAvailability,%{public}d,location_timestamp,%{public}.3f,timeOfLastDownloadRequestAvailability,%{public}.3f"
+ "HRSE,registerAvlFileToCLFU,file download scheduled via CLFU,url,%{private}s,storeTo,%{public}s,cellRateSec,%{public}.2lf,wifiRateSec,%{public}.2lf,retryInterval,%{public}.1lf"
+ "HRSE,request AVL file download,time,%{public}.3f"
+ "InputPedometerScaleFactorConfig"
+ "Jul 15 2025"
+ "Jul 15 2025 02:47:31"
+ "LCOutputBuffer,created instance with timestamp_fetch_tolerance_sec,%{public}.3f"
+ "LCOutputBuffer,propagateToMct,%{public}.3f,#Warning: propagation time exceeds max threshold of %{public}.1f sec,propagated to MCT %{public}.3f sec"
+ "LCOutputBuffer,propagateToMct,%{public}.3f,invalid input locations"
+ "MiLo-request"
+ "OdoAndPedSDFWeightsConfig"
+ "Odometer notification startTime %f distance %f speed %f odometer %f"
+ "OdometerWeightForFuser"
+ "OtherFST Model, METS, %f, hrMets, %f, wrMets, %f, hrAvail, %d, wrAvail, %d, hrGood, %d"
+ "OutputBufferFetchToleranceSec"
+ "PBIOAllow1HzGnssOrWorkoutSpecificCalibrationParameters"
+ "ParamA"
+ "ParamB"
+ "PedometerScaleFactor"
+ "PedometerUncParams"
+ "PedometerWeightForFuser"
+ "ProtobufSerializer,%{public}s,closeInternal_race_detected,already_closed,thread=%{public}p"
+ "ProviderLoc,Location equality comparison failed, invalid location ios timestamp,%{public}.3f,%{public}.3f"
+ "ProviderLoc,Location equality comparison failed, unknown location type,%{public}d,%{public}d"
+ "ProviderLoc,Location equality comparison, location types and timestamps are identical."
+ "Received nil pressure data, skipping"
+ "SeparationAlertsUserFeedbackSamplingProbability"
+ "SignalEnvironmentForOdometer"
+ "StairClimb"
+ "StairClimb Model, METS, %f, hrMets, %f, wrMets, %f, hrAvail, %d, wrAvail, %d, hrGood, %d, a, %f, c, %f, fHR, %f"
+ "TB,V_shouldSubmitMetrics"
+ "Td,N,V_timeToActiveGiveupAfterLSToggle"
+ "TestObserver::TestObserver()"
+ "Ti,N,V_fHmmState"
+ "TimeToCountryCheapLocationAfterLSToggle"
+ "Type,%s,Pos,%d,%{sensitive}+.10f,%{sensitive}+.10f,Accuracy,%.3f,Type,%{public}d,LocationTimestamp,%{public}.3f,Age,%{public}.3f,Lifespan,%{public}.3f,Integrity,%{public}d"
+ "WifiZMetrics, publish metric, LastWiFiZAlt_m,%{public}.3lf, groundTruthAltitudeEstimate_m,%{public}.3lf, altitudeChangeFromPressureDifference_m,%{public}.3lf,LastWiFiZAltUnc_m,%{public}.3lf,LastOutdoorProbability,%{public}.3lf,timeSinceOutdoorProb_s,%{public}.3lf"
+ "WorkoutOdometerConfig"
+ "WorkoutScaleFactorForOdometer"
+ "WorkoutTypeForOdometer"
+ "[AccessoryHeartRate] Setting update interval to %{public}f, given minimumUpdateInterval, %f"
+ "[HRNotifier] unexpected HR data source, %d"
+ "_fHmmState"
+ "_isAscending"
+ "_notifyEnabledCharacteristics"
+ "_realtimeElevationBuffer"
+ "_shouldSubmitMetrics"
+ "_timeToActiveGiveupAfterLSToggle"
+ "_workoutElevationStatistics"
+ "acquiring accel100 lock %p "
+ "acquiring accel800 lock"
+ "acquiring accessory dm lock"
+ "acquiring activity lock"
+ "acquiring dm lock"
+ "acquiring elevation lock"
+ "acquiring hr lock"
+ "acquiring odometer lock"
+ "acquiring raw hr lock"
+ "acquiring steps lock"
+ "addAbsoluteAltitudes:"
+ "arm_only_high_fhr_hr_scale"
+ "arm_only_high_fhr_wr_weight"
+ "arm_only_low_fhr_hr_scale"
+ "arm_only_low_fhr_wr_weight"
+ "arm_only_mid_fhr_hr_scale"
+ "arm_only_mid_fhr_wr_weight"
+ "auto CLElevationGainFromProfile::computeAscendingDescendingSegments::(anonymous class)::operator()(const ElevationProfileSegmentTransitionPoint &, const int) const"
+ "averageSignalEnvironment"
+ "batchedElevationGain"
+ "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLCalorimetryDanceDMFeatures>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLCalorimetryDanceDMFeatures>, T = CLCalorimetryDanceDMFeatures, LegacyT = CLCalorimetryDanceDMFeatures, ConverterT = void]"
+ "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLCalorimetryFunctionalStrengthDMFeatures>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLCalorimetryFunctionalStrengthDMFeatures>, T = CLCalorimetryFunctionalStrengthDMFeatures, LegacyT = CLCalorimetryFunctionalStrengthDMFeatures, ConverterT = void]"
+ "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLCalorimetryKickboxingDMFeatures>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLCalorimetryKickboxingDMFeatures>, T = CLCalorimetryKickboxingDMFeatures, LegacyT = CLCalorimetryKickboxingDMFeatures, ConverterT = void]"
+ "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLCalorimetryRowingDMFeatures>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLCalorimetryRowingDMFeatures>, T = CLCalorimetryRowingDMFeatures, LegacyT = CLCalorimetryRowingDMFeatures, ConverterT = void]"
+ "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLCatherineData>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLCatherineData>, T = CLCatherineData, LegacyT = CLCatherineData, ConverterT = void]"
+ "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLCoarseElevationChangeEntry>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLCoarseElevationChangeEntry>, T = CLCoarseElevationChangeEntry, LegacyT = CLCoarseElevationChangeEntry, ConverterT = void]"
+ "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLElevationChangeEntry>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLElevationChangeEntry>, T = CLElevationChangeEntry, LegacyT = CLElevationChangeEntry, ConverterT = void]"
+ "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLMotionStateMediator_Type::MediatedMotionActivity>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLMotionStateMediator_Type::MediatedMotionActivity>, T = CLMotionStateMediator_Type::MediatedMotionActivity, LegacyT = CLMotionStateMediator_Type::MediatedMotionActivity, ConverterT = void]"
+ "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLOdometerEntry>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLOdometerEntry>, T = CMDataProvider::Types::CMDPOdometer, LegacyT = CLOdometerEntry, ConverterT = OdometerConverter]"
+ "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLRawHR>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLRawHR>, T = CLRawHR, LegacyT = CLRawHR, ConverterT = void]"
+ "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLSwimEntry>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLSwimEntry>, T = CLSwimEntry, LegacyT = CLSwimEntry, ConverterT = void]"
+ "bool CLCalorieSourceAdapter::Source<CLNatalieInput<_CLFitnessMachineData>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<_CLFitnessMachineData>, T = _CLFitnessMachineData, LegacyT = _CLFitnessMachineData, ConverterT = void]"
+ "bool CLDigitalElevationModel::registerAvlFileToCLFU()"
+ "bool CLHighResolutionSignalEnvironmentDataManager::registerAvlFileToCLFU()"
+ "bool CLPressureDataManager::registerAvlFileToCLFU(bool)"
+ "clearNotifyEnabledCharacteristics"
+ "com.apple.Motion.Altimeter.WorkoutElevationGain"
+ "com.apple.locationd.dataprovider"
+ "compactDictionaryForDevices:"
+ "compactSetForUUIDs:"
+ "computeElevationDelta:"
+ "const T &CMQueue<CMDataProvider::Types::CMDPOdometer>::operator[](const size_t) const [T = CMDataProvider::Types::CMDPOdometer]"
+ "const std::vector<T> CMDataProviderComposite::View::getStream(Strategy) const [StreamT = CMDataProviderFactory::FactoryStream::Odometer, T = CMDataProvider::Types::CMDPOdometer, Strategy = CMDataProviderComposite::View::PassThroughStrategy<CMDataProvider::Types::CMDPOdometer>]"
+ "creating queue %s"
+ "diffElevationFusedBatched"
+ "diffElevationRealtimeBatched"
+ "done waiting for %d seconds"
+ "durationBadState"
+ "durationPressureQualityBad"
+ "durationPressureQualityGood"
+ "durationPressureQualityUnknown"
+ "fActiveRefCount %d leech %d"
+ "fCoreAnalyticsInfo: checking distances %f %f"
+ "fHR_high_a"
+ "fHR_high_c"
+ "fHR_high_lower_bound"
+ "fHR_high_upper_bound"
+ "fHR_low_a"
+ "fHR_low_c"
+ "fHR_low_lower_bound"
+ "fHR_low_upper_bound"
+ "fHR_mid_a"
+ "fHR_mid_c"
+ "fHR_mid_lower_bound"
+ "fHR_mid_upper_bound"
+ "fHmmState"
+ "feedRealtimeElevation:endTime:"
+ "forceDownloadAvailabilityFileNow:"
+ "fusedElevationGain"
+ "getElevationDeltaForBatchedElevation:atTimestamp:"
+ "getNumAscendingDescendingSegments"
+ "hh:mm:ss"
+ "https://cl3.apple.com/5/3/v1/"
+ "initElevationIsAscending:"
+ "isStepPace"
+ "kCLConnectionMessageDataProviderStressTest"
+ "kCLHomePinPreauthorization"
+ "logAndClearStatistics"
+ "meanAbsoluteAltitude"
+ "minimumUncertaintyInElevationProfile"
+ "nbmmsRangingCount"
+ "no semaphore needed for stress test"
+ "numOfSegments"
+ "other_high_fhr_hr_scale"
+ "other_high_fhr_wr_weight"
+ "other_low_fhr_hr_scale"
+ "other_low_fhr_wr_weight"
+ "other_mid_fhr_hr_scale"
+ "other_mid_fhr_wr_weight"
+ "outdoor_probability"
+ "percentageOfWorkoutWithDEM"
+ "psapFeedbackCallTrigger"
+ "realtimeElevationGain"
+ "request/release cycle %d"
+ "requested stress test for %u useconds"
+ "sedentary_high_fhr_hr_scale"
+ "sedentary_high_fhr_wr_weight"
+ "sedentary_low_fhr_hr_scale"
+ "sedentary_low_fhr_wr_weight"
+ "sedentary_mid_fhr_hr_scale"
+ "sedentary_mid_fhr_wr_weight"
+ "setFHmmState:"
+ "setShouldSubmitMetrics:"
+ "setTimeToActiveGiveupAfterLSToggle:"
+ "shortUUIDString:"
+ "shouldFetchElevationSamplesForWorkout"
+ "shouldFetchIOSamplesForInterval:"
+ "shouldSubmitMetrics"
+ "sleeping for %u"
+ "std::string CLPressureDataManager::getPressureDataServerUrl(bool)"
+ "stream mutex is null"
+ "submitFWUPCompletionMetricWithEventData:deviceUuid:"
+ "supportsGnssStatusQueryAssertion"
+ "tempHighCount"
+ "tempLastPIn"
+ "tempLowCount"
+ "tempOkCount"
+ "tempVeryLowCount"
+ "timeToActiveGiveupAfterLSToggle"
+ "timeToFirstBadState"
+ "time_delay_outdoor_prob"
+ "updateHMMBadStatePeriods:withWorkoutSmootherSample:"
+ "v1228@0:8i16(NotificationData={CLNatalieData=i^{__CFString}diBBddqqd[16C]I}B{CLBodyMetrics=iiffffffffifBfBBB}f{CLExerciseMinuteData=id^{__CFString}}{CLStandMinuteInputData=dIId}{VO2MaxResult=didBBBBB[16C]Bddii}{VO2MaxSessionStats=dfBd}d{CLCalorieUpdate={CLNatalieData=i^{__CFString}diBBddqqd[16C]I}diddBddBfIIdB}B{CLCalorieThroughputData={CLCalorieUpdate={CLNatalieData=i^{__CFString}diBBddqqd[16C]I}diddBddBfIIdB}{Data=dddd{MediatedMotionActivity=d{CLMotionActivity=iiiiiidBfdBidi{FsmTransitionData=CCCS} dii{?=b1b1b1b1b1}iidQi}i{CLNatalieFeatures=fffffffiB}qqqBB[16C]}{CMPedometerStep=ddIdddCI}{CLCalorimetryPushCount=dI}{CLCatherineData=iiddBdddi}{CMDPOdometer=dddddddddCC}{CLElevationChangeEntry=ddIIidiifCSfBB}{CLSwimEntry=Q[16C][16C]dddddddiiiiffiiddi}{CLCoarseElevationChangeEntry=dIi}{_CLFitnessMachineData=dddddqqqddiddiddidddiB}{CLCalorimetryFunctionalStrengthDMFeatures=diB}{CLCalorimetryDanceDMFeatures=dfff}{CLCalorimetryRowingDMFeatures=dfffff}{CLCalorimetryKickboxingDMFeatures=dfff}{CLRawHR=dddB}dd}})20"
+ "v24@0:8^{BatchedElevationData=IdId}16"
+ "v28@0:8I16d20"
+ "v32@0:8r^i16r^(NotificationData={CLNatalieData=i^{__CFString}diBBddqqd[16C]I}B{CLBodyMetrics=iiffffffffifBfBBB}f{CLExerciseMinuteData=id^{__CFString}}{CLStandMinuteInputData=dIId}{VO2MaxResult=didBBBBB[16C]Bddii}{VO2MaxSessionStats=dfBd}d{CLCalorieUpdate={CLNatalieData=i^{__CFString}diBBddqqd[16C]I}diddBddBfIIdB}B{CLCalorieThroughputData={CLCalorieUpdate={CLNatalieData=i^{__CFString}diBBddqqd[16C]I}diddBddBfIIdB}{Data=dddd{MediatedMotionActivity=d{CLMotionActivity=iiiiiidBfdBidi{FsmTransitionData=CCCS} dii{?=b1b1b1b1b1}iidQi}i{CLNatalieFeatures=fffffffiB}qqqBB[16C]}{CMPedometerStep=ddIdddCI}{CLCalorimetryPushCount=dI}{CLCatherineData=iiddBdddi}{CMDPOdometer=dddddddddCC}{CLElevationChangeEntry=ddIIidiifCSfBB}{CLSwimEntry=Q[16C][16C]dddddddiiiiffiiddi}{CLCoarseElevationChangeEntry=dIi}{_CLFitnessMachineData=dddddqqqddiddiddidddiB}{CLCalorimetryFunctionalStrengthDMFeatures=diB}{CLCalorimetryDanceDMFeatures=dfff}{CLCalorimetryRowingDMFeatures=dfffff}{CLCalorimetryKickboxingDMFeatures=dfff}{CLRawHR=dddB}dd}})24"
+ "v40@0:8^v16{shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationSmoothedWorkoutElevation>=^{CLBarometerCalibrationSmoothedWorkoutElevation}^{__shared_weak_count}}24"
+ "virtual CLMetsInfo CLCalorieEllipticalModelPhone::computeMETS(const CLNatalieModelInput &)"
+ "virtual CLMetsInfo CLCalorieOtherFSTFusedModelPhone::computeMETS(const CLNatalieModelInput &)"
+ "virtual CLMetsInfo CLCalorieStairClimbingModelPhone::computeMETS(const CLNatalieModelInput &)"
+ "virtual void CLFileUpdate::updateBefore(const CFAbsoluteTime &)"
+ "virtual void CLNatalieInput<CLMotionStateMediator_Type::MediatedMotionActivity>::update(CFAbsoluteTime) [T = CLMotionStateMediator_Type::MediatedMotionActivity]"
+ "void CLBackgroundInertialOdometryCalibrationEstimator::initialize1HzGnssParameters()"
+ "void CLCatherineNotifier::handleFiveSecondStreamingHeartRateUpdate(const CLCatherineData &)"
+ "void CLCompanionNotifierCompanion::sendCompanionPressureData(NSData *)"
+ "void CLCompanionNotifierCompanion::sendCompanionPressureData(NSData *)_block_invoke"
+ "void CLDataProviderSubscription::handleMessageStressTest(std::shared_ptr<CLConnectionMessage>)"
+ "void CLDataProviderSubscription::repeatedlyRequestStreamAndRelease(int, enum CMDataProviderFactory::FactoryStream, CMDataProviderStreamObserver *)"
+ "void CLDataProviderSubscription::requestStreamWithRandomDelay(enum CMDataProviderFactory::FactoryStream, CMDataProviderStreamObserver *, uint32_t)"
+ "void CLDigitalElevationModel::forceDownloadAvailabilityFileNow(const CFAbsoluteTime &)"
+ "void CLGnssSDFScaler::processActivityOdometerScaleFactorFromMA(const CFArrayRef &)"
+ "void CLGnssSDFScaler::processOdoAndPedometerWeightsFromMA(const CFArrayRef &)"
+ "void CLGnssSDFScaler::processPedometerScalingFromMA(const CFArrayRef &)"
+ "void CLGnssSDFScaler::processWorkoutOdometerFromMA(const CFArrayRef &)"
+ "void CLGnssSDFScaler::updateActivityOdometerScaleFactor(const CLNameValuePair &)"
+ "void CLGnssSDFScaler::updateOdometerAndPedometerWeights(const CLNameValuePair &)"
+ "void CLGnssSDFScaler::updatePedometerScaling(const CLNameValuePair &)"
+ "void CLGnssSDFScaler::updatePedometerUnc(const CLNameValuePair &, PedometerUncParams &)"
+ "void CLGnssSDFScaler::updateWorkoutOdometerScaleFactor(const CLNameValuePair &)"
+ "void CLHighResolutionSignalEnvironmentDataManager::forceDownloadAvailabilityFileNow(const CFAbsoluteTime &)"
+ "void CLPressureDataManager::forceDownloadAvailabilityFileNow(const CFAbsoluteTime &)"
+ "void CMDataProvider::Util::logGapIfUnexpected(const T &, const T &, CFTimeInterval, GetTimeOperatorT) [T = CLCatherineNotifier_Type::NotificationData, GetTimeOperatorT = GetTimeOperator]"
+ "void CMDataProvider::Util::logLatencyIfUnexpected(const T &, CFTimeInterval, CFTimeInterval, GetTimeOperatorT) [T = CLCatherineNotifier_Type::NotificationData, GetTimeOperatorT = GetTimeOperator]"
+ "void CMDataProvider::Util::logLatencyIfUnexpected(const T &, CFTimeInterval, CFTimeInterval, GetTimeOperatorT) [T = CMDataProvider::Types::CMDPLegacySteps, GetTimeOperatorT = GetTimeOperator]"
+ "void CMDataProviderFactoryOdometer::onOdometer(const CMDataProvider::Types::CMDPOdometer &)"
+ "void displaySAUserFeedback(const std::string &, SADevice *)"
+ "whole_body_high_fhr_hr_scale"
+ "whole_body_high_fhr_wr_weight"
+ "whole_body_low_fhr_hr_scale"
+ "whole_body_low_fhr_wr_weight"
+ "whole_body_mid_fhr_hr_scale"
+ "whole_body_mid_fhr_wr_weight"
+ "workout elevation result updated with,altitude,%f,mslp,%f,sampleTimestamp,%f,verticalAccuracy,%f,hmmState,%d,rounds,%d"
+ "workoutDuration"
+ "wr_mets_correction_lower_bound"
+ "wr_mets_correction_offset"
+ "{\"msg%{public}.0s\":\"#ADL,#OutputBufferInterface,fetchLocationsInLastSeconds is nil\", \"index\":%{public}d, \"currentMctSec\":\"%{public}0.3f\"}"
+ "{\"msg%{public}.0s\":\"#authsync auth capabilities have changed. Merging now.\", \"OperationType\":%{public}d, \"clientKey\":%{public, location:escape_only}s, \"result\":%{public, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#authsync peer's auth capabilities haven't changed w.r.t to this device, so skipping this peer's capabilities.\"}"
+ "{\"msg%{public}.0s\":\"#authsync updated syncSessionRetryInterval\", \"syncSessionRetryInterval_s\":\"%{public}.09f\"}"
+ "{\"msg%{public}.0s\":\"#cms mode notify visit\", \"arrive\":%{public, location:escape_only}@, \"end\":%{public, location:escape_only}@, \"detect\":%{public, location:escape_only}@, \"entry\":%{public}hhd, \"fi\":%{public}d}"
+ "{\"msg%{public}.0s\":\"#durian #latency didUpdateConnectionInterval\", \"item\":%{private, location:escape_only}@, \"periph\":%{private, location:escape_only}@, \"task\":%{private, location:escape_only}@, \"new\":\"%{private}.2f\", \"prior\":\"%{private}.2f\"}"
+ "{\"msg%{public}.0s\":\"#durian #metric userstatsSubmission FW\", \"multiLeashTime\":%{public}lu, \"multiConnectionTime\":%{public}lu, \"nearOwnerTime\":%{public}lu, \"wildTime\":%{public}lu, \"singleLeashTime\":%{public}lu, \"singleConnectionTime\":%{public}lu, \"dualConnectionTime\":%{public}lu, \"dualConnectionLeashTime\":%{public}lu, \"utAccelCount\":%{public}lu, \"observationDurationFW\":%{public}lu, \"roseOnTime\":%{public}lu, \"fc1ndrangingTime\":%{public}lu, \"fc1ndrangingCount\":%{public}lu, \"ownerLongSoundCount\":%{public}lu, \"ownerShortSoundCount\":%{public}lu, \"playSoundLongUTCount\":%{public}lu, \"playSoundShortUTCount\":%{public}lu, \"BOMSoundCount\":%{public}lu, \"lastPIn\":%{public}lu, \"batteryState\":%{public}lu, \"nbmmsRangingTime\":%{public}lu, \"abandonedFWUpCount\":%{public}lu, \"abandonedFWUpTime\":%{public}lu, \"roseInitCount\":%{public}lu, \"pairingAttemptsCount\":%{public}lu, \"tempVeryLowCount\":%{public}lu, \"tempLowCount\":%{public}lu, \"tempOkCount\":%{public}lu, \"tempHighCount\":%{public}lu, \"proxPairingTime\":%{public}lu, \"tempLastPIn\":%{public}lu, \"nbmmsRangingCount\":%{public}lu}"
+ "{\"msg%{public}.0s\":\"#durian #metric userstatsSubmission iOS\", \"userStatsVersion\":%{public}d, \"pairedDeviceFirmwareVersion\":%{public, location:escape_only}@, \"productId\":%{public, location:escape_only}@, \"pairedDeviceID\":%{private, location:escape_only}@, \"serialNumber\":%{private, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#durian adv own\", \"addr\":%{private, location:escape_only}@, \"uuid\":%{private, location:escape_only}@, \"index\":%{public, location:escape_only}@, \"nap\":%{public}d, \"needsmaint\":%{private}d, \"t\":%{public, location:escape_only}@, \"core\":%{public, location:escape_only}@, \"rssi\":%{public}d, \"s\":%{private}d, \"b\":%{private, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#durian adv unowned\", \"addr\":%{private, location:escape_only}@, \"nap\":%{public}d, \"t\":%{public, location:escape_only}@, \"s\":%{private}d, \"b\":%{private, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#durian complete current active task on preemption\", \"item\":%{private, location:escape_only}@, \"opcode\":%{private}d}"
+ "{\"msg%{public}.0s\":\"#durian enqueuing preempted task\", \"item\":%{private, location:escape_only}@, \"opcode\":%{private}d}"
+ "{\"msg%{public}.0s\":\"#durian shouldComplete\", \"shouldComplete\":%{public}d, \"complete\":%{public}d, \"this\":%{public}d, \"preempting\":%{public}d}"
+ "{\"msg%{public}.0s\":\"#durian task attempted preempt, but awaiting ack\", \"item\":%{private, location:escape_only}@, \"active\":%{private}d, \"new\":%{private}d}"
+ "{\"msg%{public}.0s\":\"#pcHistorical min-criteria visits reply-handler\", \"Error\":%{public, location:escape_only}s, \"visits\":%{public}d}"
+ "{\"msg%{public}.0s\":\"#pcHistorical min-criteria visits reply-handler\", \"uniqueVisits\":%{public}d, \"fAtLeastThreeUniqueVisitsAvailable\":%{public}hhd}"
+ "{\"msg%{public}.0s\":\"Pruning altitudes\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"prunedAltitudeCount\":%{private}lu}"
+ "{\"msg%{public}.0s\":\"adding altitude within start/end range to harvest\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld}"
+ "{\"msg%{public}.0s\":\"ignoring invalid altitude\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld}"
+ "{\"msg%{public}.0s\":\"skipping altitude outside start/end range\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld}"
+ "{\"msg%{public}.0s\":\"workout elevation result updated with\", \"altitude\":\"%{private}f\", \"time_s\":\"%{private}.09f\", \"verticalAccuracy\":\"%{private}f\", \"hmmState\":%{private}d}"
+ "{CLWorkoutElevationStatistics=\"workoutType\"q\"workoutStartTime\"d\"workoutEndTime\"d\"numEpoch\"i\"realtimeElevationGain\"i\"batchedElevationGain\"i\"fusedElevationGain\"i\"maxPressureAmplitude\"f\"numEpochsPressureQualityGood\"i\"numEpochsPressureQualityUnknown\"i\"numEpochsPressureQualityBad\"i\"numEpochDEMAvailable\"i\"signalEnvOccurrenceCount\"{map<CLClientSignalEnvironmentType, int, std::less<CLClientSignalEnvironmentType>, std::allocator<std::pair<const CLClientSignalEnvironmentType, int>>>=\"__tree_\"{__tree<std::__value_type<CLClientSignalEnvironmentType, int>, std::__map_value_compare<CLClientSignalEnvironmentType, std::__value_type<CLClientSignalEnvironmentType, int>, std::less<CLClientSignalEnvironmentType>>, std::allocator<std::__value_type<CLClientSignalEnvironmentType, int>>>=\"__begin_node_\"^v\"__end_node_\"{__tree_end_node<std::__tree_node_base<void *> *>=\"__left_\"^v}\"__size_\"Q}}\"altitudeCumulativeSum\"d\"altitudeCount\"i\"firstBadStateTimestamp\"d\"hmmBadStatePeriods\"{deque<CLBarometerCalibration_Types::PressureQualityHmmBadStatePeriod, std::allocator<CLBarometerCalibration_Types::PressureQualityHmmBadStatePeriod>>=\"__map_\"{__split_buffer<CLBarometerCalibration_Types::PressureQualityHmmBadStatePeriod *, std::allocator<CLBarometerCalibration_Types::PressureQualityHmmBadStatePeriod *>>=\"__first_\"^^{PressureQualityHmmBadStatePeriod}\"__begin_\"^^{PressureQualityHmmBadStatePeriod}\"__end_\"^^{PressureQualityHmmBadStatePeriod}\"__cap_\"^^{PressureQualityHmmBadStatePeriod}}\"__start_\"Q\"__size_\"Q}\"minUncertaintyElevationProfile\"d}"
+ "{deque<RealtimeElevationData, std::allocator<RealtimeElevationData>>=\"__map_\"{__split_buffer<RealtimeElevationData *, std::allocator<RealtimeElevationData *>>=\"__first_\"^^{RealtimeElevationData}\"__begin_\"^^{RealtimeElevationData}\"__end_\"^^{RealtimeElevationData}\"__cap_\"^^{RealtimeElevationData}}\"__start_\"Q\"__size_\"Q}"
+ "{optional<long long>=(?=cq)B}28@0:8I16d20"
- "\tFROM "
- " \t\t(SELECT RecordingUUID FROM OTHER."
- " \tWHERE "
- "        (SELECT "
- "    ON "
- "    WHERE "
- "   FROM OTHER."
- "   WHERE "
- "   WHERE OTHER.MiLoCustomLoiTable.ServiceId IN (SELECT ServiceUUID FROM OTHER."
- " != ''"
- " > "
- " AND HEX("
- " DESC"
- " DESC "
- " DESC LIMIT "
- " DESC) AS rn FROM "
- " FROM (SELECT "
- " GROUP BY "
- " IN "
- " IN (SELECT ServiceUUID FROM MiLoServices WHERE UserId==\""
- " INNER JOIN OTHER."
- " LIKE '"
- " LIKE '%' || "
- " Running with FenceStatusTimeout: "
- " SELECT * FROM ("
- " WHERE LoiGroupId IN "
- " WHERE LoiId IN "
- " WHERE RtLoiGroupId IN "
- " WHERE UserId==\""
- " count: "
- " in "
- " || '%' "
- "!="
- "!clientIds.empty()"
- "!dendrogramLearningParams.clusterDistanceThresholdVector.empty()"
- "!distanceThresholdVector.empty()"
- "!eventTypes.empty()"
- "!loiGroupId.is_nil()"
- "!recordingUUIDs.empty()"
- "!std::isinf(min_dist)"
- "!std::isnan(dutyCyclePercentage)"
- "\")"
- "\") LIMIT "
- "\") || '%' LIMIT "
- "\"))"
- "# MiLo Logic -- tried to initialize with an invalid queue"
- "#ADL, failed to queue fetch request, options, %{public}@"
- "#ADL, successfully queued fetch request, options, %{public}@"
- "#CLPDM,#Warning,Pressure,downloadAvailabilityFile,could not setUpdateRate AVl file updater"
- "#CLPDM,#Warning,Pressure,downloadAvailabilityFile,could not setUpdateSource AVL file updater"
- "#CLPDM,AVL file update rate over cellular,%{public}.1lf,wifi,%{public}.1lf"
- "#CLPDM,MA-OTA,AvlFileExpAge,%f,Url,%s"
- "#CLPDM,Pressure data URL,default,%s,MA-OTA,%s"
- "#CLPDM,Pressure,downloadAvailabilityFile,download request,url,%{public}s,storeTo,%{public}s,retryInterval,%{public}.1lf"
- "#CLPDM,refPressue URL defaults,%s"
- "#Error,FusedLoc,hID,%{public}d,DataFusion failed time aligning fused location,type,%{public}d,new location mct,%{public}.3f,fused location mct,%{public}.3f"
- "#Error,toDaemonLocation,fused location type is Unknown"
- "#Error,toDaemonLocation,get fused location failed,hunc <= 0"
- "#LOI Manager, CoreAnalytics Disabled"
- "#LOI Manager, Error: tried to enable custom LOI at an active custom LOI"
- "#LOI Manager, Failed to RemoveGeofence"
- "#LOI Manager, In Home LOI, exit it before creating custom LOI process"
- "#LOI Manager, failed to get current location to enable MiLo"
- "#LOI Manager, failed to get current location to enable MiLo... aborting request"
- "#LOI Manager, failed to set geofence at current location to enable MiLo"
- "#LOI Manager, failed to set geofence at current location to enable MiLo, failing custom loi request"
- "#LOI Manager, got enable custom LOI request from the same service, ignoring"
- "#LOI Manager, got geofence entry for the current active LOI which shouldn't happen... ignoring"
- "#LOI Manager, got geofence exit for an LOI which is not the currently the active LOI, this may happen if we jumped from one geofence to another and the entry for the new geofence arrived first"
- "#LOI Manager, kick off creating custom LOI process"
- "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring"
- "#LOIManager, Received nil object in eventData, this shouldn't happen"
- "#LoiRecordingManager Tried to initialize with an invalid queue"
- "#RTTMA,#Warning,Pressure,downloadAvailabilityFile,could not setUpdateRate AVl file updater"
- "#RTTMA,#Warning,Pressure,downloadAvailabilityFile,could not setUpdateSource AVL file updater"
- "#RTTMA,Pressure,downloadAvailabilityFile,download request,url,%{public}s,storeTo,%{public}s,retryInterval,%{public}.1lf"
- "#Warning Activity runner: Activity didn't complete before the runner was destroyed. Most likely this means there was an exception during the activity. Please check the logs."
- "#Warning Attempt to call %s without a backing database"
- "#Warning Attempt to delete entries without a backing database"
- "#Warning Attempt to deleteDataOlderThan without a backing database"
- "#Warning Attempt to deleteUnneededModels without a backing database"
- "#Warning Attempt to drop tables without a backing database"
- "#Warning Attempt to freeDatabaseSpace() without a backing database"
- "#Warning Attempt to purgeSimilarityListLabels without a backing database"
- "#Warning Attempt to query %{public}s without a backing database"
- "#Warning Failed to add Service Id to LOI Id mapping"
- "#Warning Failed to connect to database"
- "#Warning Failed to update LOI Database Table with LOI Ids"
- "#Warning Fingerprint vector empty for model type %d at iteration %d"
- "#Warning Got a notification center notification that we weren't expecting: %s"
- "#Warning LOI Bridge not setup."
- "#Warning LOI Manager, Error retrieving related LOIs for Loi"
- "#Warning LOI Manager, Error retrieving the current LOI. %{private}s"
- "#Warning Learning cancelled because %{private}s"
- "#Warning Model was not generated properly. Inserted: %{public,bool}d"
- "#Warning No UUIDs are passed in to delete measurements entries"
- "#Warning No UUIDs are passed in to delete recording events"
- "#Warning No recording events for model type %{public}d"
- "#Warning No results for model type %{private}d because it is invalid"
- "#Warning Please update this switch statement."
- "#Warning Received unhandled daemon status notification %d"
- "#Warning Table is not valid so all services will not be deleted"
- "#Warning Table is not valid so can't remove service to custom LOI mapping"
- "#Warning Table is not valid so service maintenance will not run and nothing will be deleted"
- "#Warning Table is not valid so we can't Service"
- "#Warning Table is not valid so we can't delete measurements"
- "#Warning Table is not valid so we can't delete recording events"
- "#Warning Table is not valid so we can't delete recording labels"
- "#Warning Table is not valid so we can't deleteUnneededModels()"
- "#Warning Table is not valid so we can't get LOI Group Id for LOI"
- "#Warning Table is not valid so we can't get LOI Group Id for LOIs"
- "#Warning Table is not valid so we can't get most recent recording for supplied LOI Group Id"
- "#Warning Table is not valid so we can't get the most recent mode of client"
- "#Warning Table is not valid so we can't get the most recent model"
- "#Warning Table is not valid so we can't get the most recent wifi channel histogram"
- "#Warning Table is not valid so we can't get the services for UUID %s"
- "#Warning Table is not valid so we can't get the services for client ID %s"
- "#Warning Table is not valid so we can't get the services for service Type %s"
- "#Warning Table is not valid so we can't select"
- "#Warning Table is not valid so we can't select GroupIDs for current user"
- "#Warning Table is not valid so we can't select all"
- "#Warning Table is not valid so we can't select all Model IDs, Client IDs"
- "#Warning Table is not valid so we can't select all Service UUIDs"
- "#Warning Table is not valid so we can't select all client IDs"
- "#Warning Table is not valid so we can't select all loi groups"
- "#Warning Table is not valid so we can't select distinct Custom Loi Ids"
- "#Warning Table is not valid so we can't select entries between times at loi"
- "#Warning Table is not valid so we can't update service"
- "#Warning Table is not valid so we update LOIGroupId for specified LOI Ids"
- "#Warning Table is not valid, can't select LOI IDs for specified LOI Group Id"
- "#Warning The protobuf Anchor Appearance struct does not have a valid device ID"
- "#Warning The protobuf cluster recording does not have a valid cluster label uuid"
- "#Warning The protobuf cluster recording does not have a valid recording uuid"
- "#Warning The protobuf fingerprint does not have a cluster identifer"
- "#Warning The protobuf fingerprint does not have a valid cluster label uuid"
- "#Warning The protobuf fingerprint does not have a valid recording uuid"
- "#Warning The protobuf fingerprint is using a deprecated uint64 cluster label"
- "#Warning Tried to run learning, but database is not valid"
- "#Warning Tried to run learning, but learning is disabled"
- "#Warning Unable to mark activity as %{public}ld. current state is %{public}ld"
- "#Warning WifiBridge, Received unknown wifi service notification %{public}d"
- "#Warning failed to insert Anchor Appearances Map to MicroLocation DB"
- "#Warning microlocation probability should be non-negative %{public}f"
- "#Warning microlocation probability vector should sum to 1.0 %{public}f"
- "#Warning passed empty UUIDs so we can't select recording events"
- "#Warning,CLFU, could not download from %{public}s to %{public}s"
- "#Warning,CLFU,%{public}s downloading in progress, cannot change update settings"
- "#Warning,HRSE,downloadAvailabilityFile,could not setUpdateRate AVl file updater"
- "#Warning,HRSE,downloadAvailabilityFile,could not setUpdateSource AVL file updater"
- "#altimeter,adding elevation gain segment transition point,now,%.3f,sampleTimestamp,%.3f,altitude,%.3f"
- "#altimeter,cleaning up elevation profile segment newer than timestamp,%.3f,now,%.3f"
- "#altimeter,could not add first transition point,now,%.3lf"
- "#altimeter,feed batched elevation,ascended,%d,descended,%d,now,%.3f"
- "#altimeter,feed real time elevation,ascended,%d,descended,%d,now,%.3f"
- "#altimeter,finished computing elevation gain from profile,timestamp,%.3f,ascendedInM,%.3f,descendedInM,%.3f"
- "#altimeter,received profile with no usable elements,now,%.3lf"
- "#altimeter,received profile with null last element,now,%.3lf"
- "#altimeter,received profile with null pointer,now,%.3lf"
- "#altimeter,received profile without end of workout indicator,now,%.3lf"
- "#altimeter,signficant elevation updated,startTime,%{public}.3f,ascended,%{public}d,descended,%d,now,%{public}.3f"
- "#fusion,data association,catching up with WSB fix by inflating validation gate,lastFilterUpdateMCT,%{public}.3f,abs_deltaTimeToFusedState_s,%{public}.3f,innovation_sqrd,%{public}.3f,innovation_var,%{public}.3f,timealignedHunc,%{public}.3f,fusedStateHunc,%{public}.3f,wsbHunc,%{public}.3f,lastFusedStateMCT,%{public}.3f"
- "#fusion,io_mct,%{public}.3f,io_applicableTime_mct,%{public}.3f,InertialOdometry derived zupt update,IO_dynamicsMode,%{public}d,CM_dynamicsMode,%{public}d,CM_indicates_driving,%{public}d"
- "#fusion,wsb_mct,%{public}.3f,wsb_cfat,%{public}.3f,consuming WSB location (buffered),ignoringBufferedWSB_LL,%{sensitive}.7f,%{sensitive}.7f,hunc,%{public}.3f,confidence,%{public}d,lifespan,%{public}.1f,wsb fix is older than location at fusion roll-back index with mct,%{public}.3f,likely is a wsb fix before sleep,delay_s,%{public}.3f,lastFusionTime_cfat,%{public}.3f"
- "#pbio, CLBackgroundInertialOdometryNorthAlignment::extractLocationsForMeasurementGeneration, cannot compute machContinuousToCFAbsoluteOffset_s, cannot extractLocations"
- "#pbio,CLIO,CLBackgroundInertialOdometryCalibrationEstimator,workoutType,%d,fCurrentlyInAnIOSupportedWorkout,%d"
- "#pbio,defaults,CLBIOCourse_GpsCourseAcc_rad2,%.8f,CLBIOCourse_MinGpsSpeed_mps,%.3f,CLBIODeltaCourse_VariancePercentPerS2,%.3f,CLBIOCourse_MinInterval_s,%.3f,CLBIOCourse_MaxInterval_s,%.3f,CLBIOFilterUpdatesMinIntervalDefault_s,%.1lf,CLBIOFilterUpdatesMinIntervalWorkout_s,%.1lf"
- "#warning, this fingerprint does not have any measurements, all measurements might have been filtered out"
- "%'"
- "%s %02X:%02X:%02X:%02X:%02X:%02X"
- "%s INITIAL isWifiPowered=%d"
- "%s Start monitor for active scanning"
- "%s Stop monitor for active scanning"
- "%s WIFI EXECUTING IMMEDIATELY, now=%f nextRequestTime=%f"
- "%s WIFI GOT NOTIFICATION WHILE SCANNER NOT STARTED, type=%d"
- "%s WIFI IGNORING NOTIFICATION, cached=%d scantype=%d"
- "%s WIFI IS POWERED OFF - NOT ISSUING SCAN REQUEST"
- "%s WIFI POWER NOTIFICATION RECEIVED, power=%d nextFire=%f"
- "%s WIFI SCAN EFFECTIVELY NOT SCHEDULED"
- "%s WIFI SCAN SCHEDULED FOR %f"
- "%s WIFI SCAN SETTINGS EMPTY, TIMER RACE?"
- "%s WIFI TIMER TRIGGERED"
- "%s started"
- "' AND "
- "')"
- "'080111________________1A021002%'"
- "( SELECT "
- "(0 < *detectionThreshold) && (*detectionThreshold < 1.0)"
- "(SELECT "
- "(SELECT * FROM "
- "(SELECT *,MIN("
- "(SELECT DISTINCT LoiId from OTHER.MiLoLoiTable WHERE LoiGroupId IN ("
- "(startIndex >= 0) && (startIndex <= static_cast<int>(container.size()) - 2)"
- ") AND "
- ") FROM "
- ") IN ("
- ") LIKE "
- ") LIKE '%"
- ") ORDER BY "
- ") WHERE "
- "))"
- ")) GROUP BY "
- ", ROW_NUMBER() OVER (PARTITION BY "
- "-[CLElevationGainFromProfile addTransitionPointWithAltitude:andTimestamp:]"
- "-[CLFusedElevationMonotonicAccumulator feedRealtimeElevation:]"
- "-[CLInternalService getMicroLocationInternalVersionWithReplyBlock:]"
- "-[CLMicroLocationNotifierAdapter beginService]"
- ".ClientID, "
- ".LabelUUID, "
- ".ReceivedTimestamp, "
- ".RowId "
- ".TriggerUUID, "
- "/AppleInternal/Library/BuildRoots/4~B4WhugBquLrCbuiB1-zTe6mtVy3BG_NQdn7hTUc/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.0.Internal.sdk/usr/local/include/boost/geometry/algorithms/detail/throw_on_empty_input.hpp"
- "/AppleInternal/Library/BuildRoots/4~B4WhugBquLrCbuiB1-zTe6mtVy3BG_NQdn7hTUc/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.0.Internal.sdk/usr/local/include/boost/uuid/detail/random_provider_posix.ipp"
- "/AppleInternal/Library/BuildRoots/4~B4WhugBquLrCbuiB1-zTe6mtVy3BG_NQdn7hTUc/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.0.Internal.sdk/usr/local/include/boost/uuid/string_generator.hpp"
- "/AppleInternal/Library/BuildRoots/4~B4WhugBquLrCbuiB1-zTe6mtVy3BG_NQdn7hTUc/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.0.Internal.sdk/usr/local/include/google/protobuf/repeated_field.h"
- "/AppleInternal/Library/BuildRoots/4~B4WhugBquLrCbuiB1-zTe6mtVy3BG_NQdn7hTUc/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS26.0.Internal.sdk/usr/local/include/google/protobuf/wire_format_lite_inl.h"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MachineLearning/CLHierarchicalClustering.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMiLoCustomLoiRecordingManager.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationAlgorithms.h"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationAlgorithms.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationBackgroundActivities.h"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationBinaryRoiNullSpaceAlgorithm.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationBiomeMonitor.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationCosineSimilarityLocalize.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationDatabaseColumns.h"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationDendrogramAlgorithm.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationFingerprint.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationFingerprintDataSources.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationFingerprintDistanceFunction.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationFingerprintVector.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationKMeansAlgorithm.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationLearner.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationLocalizationController.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationLogic.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationMeasurementTable.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationModel.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationModelTable.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationNearestNeighborAlgorithm.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationNotifier.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationNullSpaceAlgorithm.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationProtobufHelper.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationPublishHelper.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationRecorder.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationRecordingEventsTable.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationRecordingLabelsTable.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationSemiSupervisedAlgorithm.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationSensorsDriver.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationSettings.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationSettingsTypes.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationSingleClusterNullSpaceAlgorithm.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationStateMachine.h"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationTimeUtils.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationUtils.h"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationWiFiChannelHistogramAnalyzer.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationWifiBridge.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/ServiceManager/CLMiLoService.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/ServiceManager/CLMiLoServiceManager.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/ServiceManager/CLMiLoServiceTable.mm"
- "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Utilities/CLWifiScanner.mm"
- "1 == model.use_count()"
- "2.0.9"
- "22:12:24"
- "22:18:38"
- "::CLMicroLocationProto::ConfidenceReason_IsValid(value)"
- "::CLMicroLocationProto::ServiceQualityReasonEnum_IsValid(value)"
- ":com.apple.locationd"
- "<"
- "<= "
- "= \""
- "= \"\""
- "=\""
- "=(SELECT "
- "ALGORITHM_BINARY_ROI"
- "ALGORITHM_BLUE_ATLAS"
- "ALGORITHM_DENDROGRAM"
- "ALGORITHM_KMEANS"
- "ALGORITHM_SELF_TRAINING"
- "ALGORITHM_UNKNOWN"
- "AcceptedEnqueued"
- "AcceptedOngoing"
- "AcceptedWillStart"
- "Adding a client for MiLo connection event updates failed, a client with same connection token exists"
- "Advanced from %{public}s to %{public}s"
- "All services released their models and shared_ptr count is more than expected"
- "Already monitoring App In Focus events"
- "Already monitoring Now Playing events"
- "Assertion failed, no current transaction when recording an event"
- "Assertion failed, no current transaction when recording batch of measurementWrappers"
- "Assigning a negative value to an unsigned type is probably not what you intended"
- "AudioAccessory1"
- "AudioAccessory5"
- "AudioAccessory6"
- "BLE spyscan buffer overflow"
- "BLE spyscan session already running"
- "BLE spyscan session already stopped"
- "BLE spyscan session set to %{public}s"
- "BLUE_ATLAS"
- "BTScanDuration"
- "BackLightSwitchedOff"
- "BackLightSwitchedOn"
- "Bad uwb range, range %{public}.2f, type %{public}d"
- "Battery saver mode"
- "Ble"
- "Ble requested scan timeout but the session state is not running"
- "BleActiveScanRate"
- "BleIdentitiesFamilyCount"
- "BleIdentitiesSameAccountCount"
- "BleIdentitiesTotal"
- "BleIsScanRequested"
- "CBDiscovery activation error:"
- "CFGetTypeID(cfType) == CFArrayGetTypeID()"
- "CFGetTypeID(cfType) == CFBooleanGetTypeID()"
- "CFGetTypeID(cfType) == CFNumberGetTypeID()"
- "CFType must be a CFArrayRef to convert to a const char*"
- "CFType must be a CFBoolean to convert to a bool"
- "CFType must be a CFNumber to convert to a double"
- "CFType must be a CFNumber to convert to an int"
- "CL: CLMicroLocationNotifier::onClientManagerNotification"
- "CL: CLMicroLocationNotifier::onDaemonStatusNotification"
- "CL: CLMicroLocationNotifier::onDarwinNotification"
- "CL: CLMicroLocationNotifier::onDataProtectionManagerNotification"
- "CL: CLMicroLocationNotifier::onLocationNotification"
- "CL: CLMicroLocationNotifier::onNotificationCenterNotification"
- "CL: CLWifiScanner::onWifiNotification"
- "CL: _CLDaemonGetMicroLocationInternalVersion (Fallback)"
- "CLBIOFilterUpdatesMinIntervalWorkout_s"
- "CLEventsBuffer<CLMicroLocationProto::Measurement, double, ProtoMeasurementGetTime>::CLEventsBuffer(size_t, std::string) [Event = CLMicroLocationProto::Measurement, Time = double, CallableEventGetTime = ProtoMeasurementGetTime]"
- "CLExponentialKernelFunction"
- "CLFU,%{public}s download timeout must be greater than 0. Forcing to 30 seconds."
- "CLFU,Throttling download %{public}s due to retry delay, scheduling download for %{public}.3f (%{public}.3f away)"
- "CLFU,current download of %{public}s has timed out, canceling"
- "CLFU,data reachability is not available - not downloading %{public}s"
- "CLFU,data reachability is not available - not retrying %{public}s"
- "CLFU,delay %{public}.3f for retry count %{public}d exceeds current update period of %{public}.3f, setting delay to half the current update period for %{public}s"
- "CLFU,download of %{public}s not yet timed out. Blocking current download request"
- "CLFU,last %{public}s downloaded less than %{public}.3f seconds ago (%{public}.3f), scheduling download for %{public}.3f (%{public}.3f away)"
- "CLFU,last %{public}s downloaded over %{public}.3f seconds ago (%{public}.3f), starting a download now"
- "CLFU,registered for kNotificationCompanionConnectionUpdate"
- "CLFU,retry count %{public}d, will re-download for %{public}s after delay of %{public}.3f"
- "CLFU,scheduled download %{public}s is after %{public}.3f deadline (%{public}.3f after) - overriding"
- "CLFU,stopping download of %{public}s"
- "CLFU,unregistered for kNotificationCompanionConnectionUpdate for %s"
- "CLFU,we are now on large reachability %{public}s, scheduling a download for %{public}s (period %{public}.3f)"
- "CLGaussianKernelFunction"
- "CLHierarchicalClustering"
- "CLKernelFunction.h"
- "CLLaplacianKernelFunction"
- "CLMiLoCustomLoiRecordingManager"
- "CLMiLoLeeching"
- "CLMiLoNonLeeching"
- "CLMiLoPDRFence"
- "CLMiLoService received localization results with unexpected / unmatching ID"
- "CLMiLoService tried to send cached results to client but no cache available:"
- "CLMiLoService::applyRecentLabelsToLSL, tried to apply a label which is already in the LSL"
- "CLMicroLocationAlgorithms::LocalizerResults CLMicroLocationLocalizer::localize(const CLMicroLocationModel &, const CLMicroLocationFingerprint &, const CLMicroLocationLocalizationSettings &, std::optional<boost::uuids::uuid> *, bool) const"
- "CLMicroLocationAnalytics, sendCoreAnalyticsEvent, not sending event because sending to CoreAnalytics is disabled"
- "CLMicroLocationAnchorAppearanceMap::CLMicroLocationAnchorAppearanceMap(const CLMicroLocationProto::anchorAppearancesVector &)"
- "CLMicroLocationBackgroundActivities::ActivityRunner<CLMicroLocationXPCActivityHelpers::XPCActivity, CLMicroLocationMaintenance>::~ActivityRunner() [ActivityT = CLMicroLocationXPCActivityHelpers::XPCActivity, WorkT = CLMicroLocationMaintenance]"
- "CLMicroLocationClientUtils, requireServiceLabelEntries, cannot load label entries for unknown LOI"
- "CLMicroLocationDatabase"
- "CLMicroLocationDatabase::CLMicroLocationDatabase(std::string, CLSqliteDatabase::SqlitePropertyProtection)"
- "CLMicroLocationDictionary"
- "CLMicroLocationFingerprint::CLMicroLocationFingerprint(const CLMicroLocationProto::Fingerprint &)"
- "CLMicroLocationFingerprint::CLMicroLocationFingerprint(const std::vector<CLMiLoProtobufWrapper::Measurement> &, const CLMicroLocationFingerprintConfiguration &, const std::optional<CLMicroLocationProto::RecordingEvent> &, const std::optional<boost::uuids::uuid> &)"
- "CLMicroLocationFingerprintStdVectorSource::CLMicroLocationFingerprintStdVectorSource(CLMicroLocationFingerprintDataSources::ShouldCancelFunction, CLMicroLocationFingerprintDataSources::ConfigurationLoaderFunction, const std::vector<CLMicroLocationRecordingEventsTable::Entry> &, CLMicroLocationDatabase &)"
- "CLMicroLocationLegacyClient: tryCreateServiceAndConnect: failed to create a new service"
- "CLMicroLocationLocalizationController, sendLocalizationCoreAnalyticsEvent, not sending event because sending to CoreAnalytics is disabled"
- "CLMicroLocationLogic"
- "CLMicroLocationLogic got previously stored LOI Group ID for LOI ID"
- "CLMicroLocationLogic never before seen LOI, so starting with this LOI ID as the group ID"
- "CLMicroLocationLogic received multiple Loi Group IDs for LOI -- this should never happen"
- "CLMicroLocationLogic: DTOR"
- "CLMicroLocationLogic: Settings updated so updating wifi strategies, allowed anchor models, and checking enabled flags"
- "CLMicroLocationMaintenance, collectMetricsPostMaintenance, not sending event because sending to CoreAnalytics is disabled"
- "CLMicroLocationNotifier got previously stored LOI Group ID for list of LOI IDs"
- "CLMicroLocationNotifier: register Biome"
- "CLMicroLocationNotifier: startSpectating"
- "CLMicroLocationNotifier: stopSpectating"
- "CLMicroLocationNotifier::CLMicroLocationNotifier(id<CLIntersiloUniverse>, std::string, std::unique_ptr<CLMicroLocationBackgroundActivities>)"
- "CLMicroLocationNotifier::onClientManagerNotification"
- "CLMicroLocationNotifier::onDaemonStatusNotification"
- "CLMicroLocationNotifier::onDarwinNotification"
- "CLMicroLocationNotifier::onDataProtectionManagerNotification"
- "CLMicroLocationNotifier::onLocationNotification"
- "CLMicroLocationNotifier::onNotificationCenterNotification"
- "CLMicroLocationNotifierAdapter"
- "CLMicroLocationNotifierProtocol"
- "CLMicroLocationNotifierSilo"
- "CLMicroLocationProto::NumberOfObservationsStates CLMicroLocationAnalytics::getLegacyClientNumberOfObservationsState(const cl::chrono::time_point<cl::chrono::CFAbsoluteTimeClock> &) const"
- "CLMicroLocationProto::TriggerRequestStatus CLMicroLocationTriggerManager::requestLocalization(const CLMicroLocationProto::RecordingEvent &, const bool, const bool, CLMicroLocationProto::TriggerReason)"
- "CLMicroLocationProto::TriggerRequestStatus CLMicroLocationTriggerManager::requestRecording(const CLMicroLocationProto::RecordingEvent &)"
- "CLMicroLocationProto::anchorAppearancesVector CLMicroLocationAnchorAppearanceMap::toProtobuf() const"
- "CLMicroLocationRecorder: received invalid truth label"
- "CLMicroLocationSensorDriver"
- "CLMicroLocationSensors"
- "CLMicroLocationSensorsLogic: DTOR"
- "CLMicroLocationSensorsLogic::getBleMeasurements, fState.fStartTime is nullopt!"
- "CLMicroLocationSensorsLogic::getUwbMeasurements, fState.fStartTime is nullopt!"
- "CLMicroLocationSensorsLogic::requestWiFiScan, fState.fStartTime is nullopt!"
- "CLMicroLocationSimilarityListData fromProtobuf - invalid LabelUuid conversion!"
- "CLMicroLocationSimilarityListData fromProtobuf - invalid clusterUuid conversion!"
- "CLMicroLocationSimilarityListData fromProtobuf - number of probabilities should match number of clusters"
- "CLMicroLocationSimilarityListData fromProtobuf - size of confidences doesn't equal event number, setting all event's confidence to invalid"
- "CLMicroLocationStopMotionDetectionBridge CTOR, wrong configuration, object did not initialize"
- "CLMicroLocationTriggerManager: Got localization trigger while localizing - AcceptedOngoing"
- "CLMicroLocationTriggerManager: Got localization trigger while waiting for rescheduled localization timer"
- "CLMicroLocationTriggerManager: Got unforced localization trigger in low latency - ReturnCache"
- "CLMicroLocationTriggerManager: requestRecording"
- "CLRS,Criteria not met to reconstruct,is1HzData,%{public}d,ratioOfLocationsThatAreDenseUrban,%{public}.1lf,WorkoutActivityNotWalking,%{public}d"
- "CLReducerFunction.h"
- "CLSqliteTransaction CLMicroLocationDatabase::openTransaction()"
- "CLUniformKernelFunction"
- "CLWifiScanner::CLWifiScanner(id<CLIntersiloUniverse>, std::shared_ptr<IWifiScanningStrategy>)"
- "CLWifiScanner::onWifiNotification"
- "CMDataProviderFactory"
- "COUNT(*) as RowCount FROM "
- "Can't clear current activity as it is already invalid"
- "Can't find a model type that corresponds to string"
- "Can't set new activity"
- "Cancelled, skipping generation of anchor appearance maps"
- "Cannot localize on invalid model!"
- "Cannot serve queued record requests because we're no longer enabled"
- "Checking in for %{public}s"
- "Client request"
- "ClusterAnchorValueStatistics feature is not enabled in setting, won't fetch data from DB"
- "ClusterAnchorValueStatistics has no data"
- "ConfidenceLevel:"
- "ConfidenceReason:"
- "Configuration_Candidate"
- "Configuration_Default"
- "Connect to service without connectionToken"
- "Connect to service without identifier"
- "CosineSimilarityLocalization, confidence vector size not equal to prob matrix row number!"
- "CosineSimilarityLocalization, did not find null space probability"
- "CosineSimilarityLocalization, error normalizing currentLocalizationVec!"
- "CosineSimilarityLocalization, model type is not similarity list!"
- "CosineSimilarityLocalization, multByVec failed!"
- "CosineSimilarityLocalization, unexpected identifier"
- "Could not determine legacy client low number of observation status."
- "Couldn't find key: "
- "Couldn't find key: onesided_jaccard"
- "Create service - No error code but response descriptor not available "
- "Current microlocation"
- "CurrentLocationUnsupported"
- "Custom"
- "Custom LOI Entry Failure"
- "Custom LOI entry notification"
- "Custom LOI exit notification"
- "Custom LOI logic"
- "Custom Loi"
- "DEM,download request,url,%{public}s,storeTo,%{public}s,retryInterval,%{public}.1lf"
- "Daemon settings"
- "Daemon status"
- "Darwin"
- "Data Source Cancelled at index "
- "Data available"
- "Data source cancelled learning"
- "DataProtection"
- "Database is not connected so we can't intialize our %{public}s table"
- "Database is not connected so we can't intialize our CLMicroLocationRapportTable"
- "Database is not connected so we can't intialize our table"
- "Database ready"
- "Database selection limit is not positive. Not selecting LOI Groups"
- "DaysWithRecordings"
- "Delete Olders rows in service table. Should never be here!"
- "Delete service - No error code but response descriptor not available "
- "Delete service without identifier"
- "Deleting %ld models which refer to deleted services"
- "Deleting microlocation data older than %.3Lf days"
- "Deleting similarity list labels older than %.3Lf days"
- "Denied"
- "Deregistering from leeched location updates"
- "Detection threshold must be: 0 < THR < 1.0!"
- "DeviceReadyEvent"
- "Did %{public}s delete old data"
- "Did %{public}s free database space"
- "Did not find matching entry for cached trigger UUID"
- "Did not receive status report for active fence"
- "Disable Custom LOI"
- "Disabled - not registering for leeched location updates"
- "Disconnect from service without identifier"
- "Display"
- "Does not support appending new events to a transposed matrix!"
- "Don't have a current wifi channel histogram for this LOI id %{private}s. Using histogram using LOI type only %{private}s."
- "Don't have wifi channel histogram for current LOI type %{private}s. Using default wifi histogram"
- "DurationBounded"
- "Duty cycle is NaN"
- "Duty cycle percentage should be between 0 and 1"
- "Elevation delta incorrect,realTimeElevation,%d,elevationDelta,%lld"
- "Enable Custom LOI"
- "Enabled state: microlocations defaults enabled: %{public}d; location services enabled: %{public}d; significant locations enabled: %{public}d; platform supported %{public}d; LowPowerMode %{public}d; overall enabled: %{public}d"
- "Entry"
- "Error - recording transaction does not have any valid recording events"
- "Error binding to statement for sql %{private}s"
- "Error converting database values %{public}s"
- "Error converting database values. %{public}s"
- "Error converting uint to location types: Value does not fit into bitset"
- "Error, localization probabilities were not sorted in descending order"
- "Error: Unable to export MicroLocation DB - local DB is not ready!"
- "Error: recording entry does not have trigger UUID"
- "Event Received without Timestamp!"
- "Expecting a wifi channel histogram"
- "Expecting some UUIDs to be passed in"
- "Expecting some clientIDs to be passed in"
- "Expecting valid LOI Group ID to be passed in"
- "Export DB requests are served in internal builds only!"
- "Export using paging, operation cancelled"
- "Export using paging. database object is invalid"
- "Export using paging. invalid pageSize should be greater than 0"
- "Export using paging. page select query is empty"
- "ExportDir"
- "ExportedMicroLocationDB.db"
- "ExportedMiloDB.db"
- "FAULT: Tried to initialize LOI Manager with a nil LOI Bridge Object"
- "FROM OTHER."
- "Failed To Fetched Place Inference"
- "Failed To Get Location Update"
- "Failed To Set Geofence"
- "Failed to Get LOI Event"
- "Failed to Get Related LOIs"
- "Failed to SELECT COUNT(*) rows"
- "Failed to bind on INSERT OR REPLACE for sql %{private}s"
- "Failed to connect to database"
- "Failed to decrypt backup file"
- "Failed to execute statement. %{private}s"
- "Failed to get a long value for key"
- "Failed to get key for backup decryption"
- "Failed to get locationDb directory"
- "Failed to get paths for exporting iCloud Restore db"
- "Failed to migrate labels table to updated schema"
- "Failed to run services maintenance"
- "Failed to set geofence"
- "False"
- "Fence: MiLo, microlocation localizer triggered"
- "Fence: MiLo, proxy not available"
- "FenceCross"
- "Fetch Place Inference For Reason"
- "Fetched Place Inference For Current Location"
- "FileName"
- "Force Recording received"
- "Force localization"
- "Force record"
- "Found too many matching entries for cached trigger UUID"
- "Fused batched elevation,batchedElevation,%ud,latestRealTime,%ud,elevationDelta,%lld,currentFusedElevation,%ud"
- "Fused real time elevation,latestRealTime,%ud,elevationDelta,%lld,currentFusedElevation,%ud"
- "FusedLoc,hID,%{public}d,predicted fused location with large uncertainty switching to CC Fusion,type,%{public}d,new loc hunc,%{public}.1f,fused loc hunc,%{public}.1f,fused loc DR time_s,%{public}.1f,index,%{public}d,bufferSize,%{public}zu"
- "GPSODOM%s,activity type,%{public}d,sigEnv,%{public}d,distance multiplier,%{public}.3f"
- "Generic Failure"
- "Geofence Entry"
- "Geofence Exit"
- "Get generation algorithm: Unknown learner type"
- "Get generation algorithm: Unknown service type"
- "Got LOI Event"
- "Got Location Update"
- "Got Related LOIs"
- "Got a data protection notification we weren't registered for: %{public}d"
- "Got a scan busy error so returning a scan delay of %{public}0.3Lfs"
- "Got a scan error so returning a scan delay of %{public}0.3Lfs"
- "Got nullptr from CLMicroLocationProto add_anchorappearances"
- "Got request to reset Location data. Dropping microlocation tables"
- "HRSE,downloadAvailabilityFile,download request,url,%{public}s,storeTo,%{public}s,retryInterval,%{public}.1lf"
- "HRSE,downloadFileIfNeeded,download availability file"
- "HighCandidateHigh"
- "HighCandidateLow"
- "HighNullSpaceProbability"
- "Home LOI Entry Failure"
- "IDS Identifier unavailable - device not buffered to monitor"
- "If run state is runnimg then suspend reason must be empty"
- "If run state is suspended then suspend reason cannot be empty"
- "Ignoring failure. "
- "Ignoring leeched location since horizontal accuracy (%.1f m) exceeds threshold"
- "Ignoring refreshRoutineStateAtLocation request since keybag is not unlocked"
- "Ignoring refreshRoutineStateAtLocation request since last request was too recent"
- "In Custom LOI State"
- "In Home LOI State"
- "In the process of entering Custom LOI"
- "In the process of entering Home LOI"
- "InFocus"
- "Ingested %{public}ld new AP measurements, too old %{public}ld, dupe %{public}ld, buffer size %{public}ld"
- "Initialize EventsBuffer %s"
- "InternalClientLogic"
- "InternalClientMac"
- "InternalClientScreenOnFallback"
- "InternalClientScreenUnlock"
- "Interrupted due to another request"
- "Invalid Address data"
- "Invalid CBDevice IDS UUID"
- "Invalid Fingerprint"
- "Invalid Geofence Entry"
- "Invalid Geofence Exit"
- "Invalid MiLo current activity"
- "Invalid algorithm chosen"
- "Invalid localization algorithm! No localization done"
- "Invalid model index"
- "Invalid scan activity"
- "Invalid scan activity on timer stop, state: NotSet"
- "Invalid type chosen"
- "InvalidTestFingerprint"
- "Invalidated"
- "IsBecomingHighQualityModelForTheFirstTime"
- "IsHighQualityModel"
- "Jul  1 2025"
- "Jul  1 2025 22:15:43"
- "Keeping %{public}d models for LSL models, %{public}d models per other types"
- "LCOutputBuffer,created instance with tolerance_sec,%{public}.3f"
- "LOI Bridge, Failed To fetch place inferences"
- "LOI Bridge, received nil LOI Identifier, possibly because there is no active user on macOS, we will start leeching and wait for next location update"
- "LOI Bridge, received no place inferences, we will start leeching and wait for next location update"
- "LOI Fetch Failure"
- "LOI Manager, Failed To fetch place inferences"
- "LOI Manager, Failed To request LOI for current visit location"
- "LOI Manager, Failed To request related LOIs"
- "LOI Manager, Got event when not expecting it"
- "LOI Manager, Got invalid geofence ID"
- "LOI Manager, Not a Home LOI"
- "LOI Manager, Received visit entry"
- "LOI Manager, Received visit exit"
- "LOI Manager, Returning to Inactive Location State"
- "LOI Manager, fetching related LOIs for LOI"
- "LOI Manager, got nil LOI for current Location.. perhaps not in an LOI"
- "LOI Manager, handleVisitNotification"
- "LOI Manager, received nil LOI Identifier from place inference, possibly because there is no active user on macOS, we will start leeching and wait for next location update"
- "LOI Manager, requested LOI for current visit location"
- "LOI Visit Entry"
- "LOI Visit Exit"
- "LSL"
- "Learning cancelled before onLearningBegin event"
- "Learning cancelled before onLearningCompleted event"
- "Learning model without old model. Setting number of days with recordings to %d"
- "Leeched Location Update"
- "Legacy client do not support labels form any other client than focus-mode ClientReceived: %s"
- "Localization stopped"
- "Localization trigger does not have a valid trigger UUID"
- "LocalizationController doesn't have any valid measurements to use, reporting empty results."
- "LocalizationProcessing_modelType_"
- "LocalizationRequest"
- "LocalizationRequest::setConfidenceAndReasons, invalid arguments"
- "Localizer returned empty results when learning semi-supervised model"
- "Localizing"
- "Location equality comparison failed, invalid location ios timestamp,%{public}.3f,%{public}.3f"
- "Location equality comparison failed, unknown location type,%{public}d,%{public}d"
- "Location equality comparison, location types and timestamps are identical."
- "Location leech"
- "Location notification"
- "Location refresh interval reached"
- "Location services set to %{public}s"
- "Location services toggled"
- "LocationOfInterestDidClear"
- "Log Post-Maintenance MiLoServiceTable client: %s has: %u services of serviceType: %llU"
- "Log Post-Maintenance MiLoServiceTable: no services found."
- "Log Pre-Maintenance MiLoServiceTable client: %s has: %u services of serviceType: %llU"
- "Log Pre-Maintenance MiLoServiceTable: no services found."
- "Logic, shouldExtendWifiScan was called when activity is NotSet"
- "LowCandidateHigh"
- "LowCandidateLow"
- "LowLatency"
- "LowMaxClusterRFDistance"
- "LowNumberBLEDevices"
- "LowNumberFingerprintsPostPruning"
- "LowNumberOfBLEAnchors"
- "LowNumberOfBLEOrUWBAnchors"
- "LowNumberOfDetectedLocations"
- "LowNumberOfObservations"
- "LowNumberOfWiFiAnchors"
- "LowNumberRobustWiFiSources"
- "MAGIACL_MOMENTS"
- "Mac changed user notification"
- "Mac screen on notification"
- "MacMini"
- "MacPro"
- "Maintenance deleted oldest services above max count per client"
- "MaxRecordingTimerFiredEvent"
- "Media"
- "MiLo must be enabled"
- "MiLo registration on App InFocus completed"
- "MiLo registration on NowPlaying completed"
- "MiLo send prediction unknown service type: %lu"
- "MiLoBecameUnavailable"
- "MiLoServiceManager, failed to insert to fServiceIdToConnectionIdMap"
- "MiLoStopMotionDetectionFence:radius:"
- "MiLoUnavailable"
- "MicroLocation became unavailable"
- "MicroLocation database has no connection. %{public}s"
- "MicroLocation database sqlite error. %{public}s"
- "MicroLocation database sqlite error. error: %{public}s"
- "MicroLocation donate truth label for recording events between dates"
- "MicroLocation learned model: %{private}s"
- "MicroLocation: shutdown"
- "MicroLocationAnalytics"
- "MicroLocationLearning"
- "MicroLocationMaintenance"
- "MicroLocationRecordingLabels"
- "MicroLocationSettings"
- "MicroLocations are now re-enabled. Clients should begin getting notifications again"
- "MicroLocations have been disabled. Clients will no longer get notifications until we are enabled again."
- "MicroLocations not supported on Base System"
- "MicroLocations not supported on stationary Macs"
- "MicroLocations not supported on this platform"
- "MicroLocations startClients"
- "MicroLocationsAdaptiveAnchorsEnable"
- "MicroLocationsAdaptiveAnchorsMaxEntriesInAppearanceMap"
- "MicroLocationsAdaptiveAnchorsNumDaysToKeepEnabled"
- "MicroLocationsAdaptiveAnchorsNumValidDaysForPurging"
- "MicroLocationsAdaptiveSensorsEnable"
- "MicroLocationsAnalyticsTriggerCountThreshold"
- "MicroLocationsAnalyticsTriggerMinimumSpectatingDuration"
- "MicroLocationsAnchorDeviceModelAllowedList"
- "MicroLocationsAssociatedStateTableMaxRows"
- "MicroLocationsAssociatedStateTableMigrationPageSize"
- "MicroLocationsBinaryModelDetectionThreshold"
- "MicroLocationsBinaryModelDetectionThreshold_IndoorOutdoor"
- "MicroLocationsBinaryModelNotRoiReductionPercentile"
- "MicroLocationsBinaryModelRoiReductionPercentile"
- "MicroLocationsBleActiveScanRate"
- "MicroLocationsBleBackgroundScanRate"
- "MicroLocationsBleForceRequestedType15Type16ScanWhenDeviceFilterIsEmpty"
- "MicroLocationsBleForceScanNearbyInfoV2"
- "MicroLocationsBleNonLeechingBackgroundScanEnabled"
- "MicroLocationsBleNonLeechingScannerEnabled"
- "MicroLocationsBleRequestedScanEnabled"
- "MicroLocationsBleRequestedScanLength"
- "MicroLocationsBleScanBufferSize"
- "MicroLocationsBleScanFlagRssiIsSet"
- "MicroLocationsBleScanMaximalAgeForValidity"
- "MicroLocationsBleScanMaximalAgeForValidityFromScanStart"
- "MicroLocationsBleType15andType16DeviceFilterIsSet"
- "MicroLocationsBleType22DeviceFilterIsSet"
- "MicroLocationsBluetoothIdentityTableMaxRows"
- "MicroLocationsBluetoothIdentityTableMigrationPageSize"
- "MicroLocationsClusterAnchorValueStatisticsBleRssiSentinelValue"
- "MicroLocationsClusterAnchorValueStatisticsEnabled"
- "MicroLocationsClusterAnchorValueStatisticsUwbRangeSentinelValue"
- "MicroLocationsClusterPersistenceDistanceThreshold"
- "MicroLocationsClusterSizeRatio"
- "MicroLocationsClusterSizeThreshold"
- "MicroLocationsCombinedEuclideanJaccardParams"
- "MicroLocationsConfigurationTableMaxRows"
- "MicroLocationsConfigurationTableMigrationLimit"
- "MicroLocationsConfigurationTableMigrationPageSize"
- "MicroLocationsCustomLoiMaxRecordingWindow"
- "MicroLocationsCustomLoiMaxRecordings"
- "MicroLocationsCustomLoiTableMigrationPageSize"
- "MicroLocationsCustomLoiWaitBetweenRecordings"
- "MicroLocationsDatabaseSelectionLimit"
- "MicroLocationsEnableInternalFallbackLocalization"
- "MicroLocationsEnableLearning"
- "MicroLocationsEnableSamplingForLearningAnalyticsOnInternal"
- "MicroLocationsEnableServiceInCustomLOI"
- "MicroLocationsEnabledModelTypes"
- "MicroLocationsFingerprintDataSource"
- "MicroLocationsFingerprintDistanceFunctionType"
- "MicroLocationsForcePredictionForLowLatencyServiceEnabled"
- "MicroLocationsHighConfidenceBleSourceNumThreshold"
- "MicroLocationsHighConfidenceUwbSourceNumThreshold"
- "MicroLocationsHomeLoiLocalizerFingerprintDistanceFunctionType"
- "MicroLocationsInitialDelayForFetchPlaceInference"
- "MicroLocationsLabelTableMigrationPageSize"
- "MicroLocationsLabelsTableMaxRowsToMigrate"
- "MicroLocationsLearnerAlgorithm"
- "MicroLocationsLearningLabeledRecordingTriggersLimit"
- "MicroLocationsLearningRecordingLimit"
- "MicroLocationsLeechedLocationHorizontalAccuracyThreshold"
- "MicroLocationsLinkageFunction"
- "MicroLocationsLocalizationRescheduleDelay"
- "MicroLocationsLocalizeWithRecordingMeasurements"
- "MicroLocationsLocalizerAlgorithm"
- "MicroLocationsLocalizerAlgorithm_HomeLOI"
- "MicroLocationsLocalizing80211Modes"
- "MicroLocationsLocalizing80211ScanType"
- "MicroLocationsLocalizingBacklightOnInitialScanDelay"
- "MicroLocationsLocalizingDurationMaximumIncrements"
- "MicroLocationsLocalizingDurationMinimum"
- "MicroLocationsLocalizingScanLowPriority"
- "MicroLocationsLocalizingTopChannels"
- "MicroLocationsLocalizingWifiDutyCyclePercentage"
- "MicroLocationsLocalizingWifiMaxAgeFirstScan"
- "MicroLocationsLoiTableMigrationPageSize"
- "MicroLocationsMagicalMomentsClusterDistanceThresholdVector"
- "MicroLocationsMaintenanceInterval"
- "MicroLocationsMaxBleIdentityNumber"
- "MicroLocationsMaxClusterRFDistanceDecisionTreeNodeThreshold"
- "MicroLocationsMaxDelayAfterFenceStatusReportTimerFires"
- "MicroLocationsMaxDurationBetweenLocalizationTriggers"
- "MicroLocationsMaxTimeAllowedWithoutFenceStatusReport"
- "MicroLocationsMaximumAgeForValidity"
- "MicroLocationsMaximumLocalizeNumRetryDisabledDueToWiFiError"
- "MicroLocationsMaximumLocalizeNumRetryDueToWiFiError"
- "MicroLocationsMaximumNearestNeighbors"
- "MicroLocationsMaximumNumberOfBleRssiMeasurementsForFingerprint"
- "MicroLocationsMaximumNumberOfClustersForLearningAnalytics"
- "MicroLocationsMaximumNumberOfConnectedBinaryRoiServicesPerClient"
- "MicroLocationsMaximumNumberOfConnectedMulticlassServicesPerClient"
- "MicroLocationsMaximumNumberOfConnectedSimilarityListServicesPerClient"
- "MicroLocationsMaximumNumberOfConnectedUnsupervisedServicesPerClient"
- "MicroLocationsMaximumNumberOfCreatedBinaryRoiServicesPerClient"
- "MicroLocationsMaximumNumberOfCreatedBinaryRoiServicesPerClientAfterMaintenance"
- "MicroLocationsMaximumNumberOfCreatedMulticlassServicesPerClient"
- "MicroLocationsMaximumNumberOfCreatedMulticlassServicesPerClientAfterMaintenance"
- "MicroLocationsMaximumNumberOfCreatedSimilarityListServicesPerClient"
- "MicroLocationsMaximumNumberOfCreatedSimilarityListServicesPerClientAfterMaintenance"
- "MicroLocationsMaximumNumberOfCreatedUnsupervisedServicesPerClient"
- "MicroLocationsMaximumNumberOfCreatedUnsupervisedServicesPerClientAfterMaintenance"
- "MicroLocationsMaximumNumberOfUwbRangeMeasurementsForFingerprint"
- "MicroLocationsMaximumNumberOfWifiRssiMeasurementsForFingerprint"
- "MicroLocationsMeasurementProcessingBleLeechEnable"
- "MicroLocationsMeasurementProcessingUwbRangeEnable"
- "MicroLocationsMeasurementProcessingWifiRssiEnable"
- "MicroLocationsMeasurementTableMaxRows"
- "MicroLocationsMeasurementTableMigrationPageSize"
- "MicroLocationsMiLoLoiTableMaxRows"
- "MicroLocationsMinDurationBetweenTriggers"
- "MicroLocationsMinimumBleDurationForFingerprintLocalizing"
- "MicroLocationsMinimumBleDurationForFingerprintRecording"
- "MicroLocationsMinimumBleNumberOfMeasurementsForFingerprintLocalizing"
- "MicroLocationsMinimumBleNumberOfMeasurementsForFingerprintRecording"
- "MicroLocationsMinimumMicroLocationProbabilityForLocalization"
- "MicroLocationsMinimumNumberOfDaysWithRecordingsInStableModel"
- "MicroLocationsMinimumNumberOfRecordingsInStableModel"
- "MicroLocationsMinimumTotalNumberOfMeasurementsForFingerprint"
- "MicroLocationsMinimumUwbNumberOfMeasurementsForFingerprintLocalizing"
- "MicroLocationsMinimumUwbNumberOfMeasurementsForFingerprintRecording"
- "MicroLocationsMinimumUwbRangeDurationForFingerprintLocalizing"
- "MicroLocationsMinimumUwbRangeDurationForFingerprintRecording"
- "MicroLocationsMinimumWiFiDurationForFingerprintLocalizing"
- "MicroLocationsMinimumWiFiDurationForFingerprintRecording"
- "MicroLocationsMinimumWiFiNumberOfMeasurementsForFingerprintLocalizing"
- "MicroLocationsMinimumWiFiNumberOfMeasurementsForFingerprintRecording"
- "MicroLocationsMinimumWiFiNumberOfMeasurementsForScanExtension"
- "MicroLocationsModelQualityNumFingerprintsWiFiBleThreshold"
- "MicroLocationsModelQualityNumFingerprintsWiFiOnlyThreshold"
- "MicroLocationsModelTableMaxRows"
- "MicroLocationsModelTableMigrationPageSize"
- "MicroLocationsMotionInvalidateConfidenceOnMotion"
- "MicroLocationsMotionStopDetectionModuleEnable"
- "MicroLocationsMotionStopDetectionModuleIpadOngoingTimerTimeout"
- "MicroLocationsMotionStopDetectionModuleIpadRadii"
- "MicroLocationsMotionStopDetectionModuleIpadTimeouts"
- "MicroLocationsMotionStopDetectionModuleOngoingTimerTimeout"
- "MicroLocationsMotionStopDetectionModuleRadiuses"
- "MicroLocationsMotionStopDetectionModuleTimeouts"
- "MicroLocationsNullClusterThresholdForLowConfidence"
- "MicroLocationsNullSpaceDistanceReductionFunction"
- "MicroLocationsNullSpaceDistanceReductionFunctionMaxPercentile"
- "MicroLocationsNullSpaceDistanceReductionFunctionMaxPercentile_HomeLOI"
- "MicroLocationsNullSpaceDistanceReductionFunctionMinPercentile"
- "MicroLocationsNullSpaceDistanceReductionFunctionMinPercentile_HomeLOI"
- "MicroLocationsNullSpaceKernelFunction"
- "MicroLocationsNullSpaceKernelFunction_HomeLOI"
- "MicroLocationsNullSpaceKernelFunction_IndoorOutdoor"
- "MicroLocationsNumBLESourcesDecisionTreeNodeThreshold"
- "MicroLocationsNumLSLModelsToKeep"
- "MicroLocationsNumMinFingerprintsPostPruningTreeBasedThreshold"
- "MicroLocationsNumModelsToKeepForNonLSL"
- "MicroLocationsNumRobustWifiSourcesDecisionTreeNodeThreshold"
- "MicroLocationsNumberDaysToAnalyzeAssociationState"
- "MicroLocationsNumberDaysToAnalyzeWiFiChannels"
- "MicroLocationsNumberDaysToUseBtIdentities"
- "MicroLocationsNumberOfLoggedProbabilityResults"
- "MicroLocationsNumberOfModelIterations"
- "MicroLocationsOverrideCurrentRTLOIType"
- "MicroLocationsPedestrianFenceEnabled"
- "MicroLocationsPedestrianFenceRadiusForIpadInMeters"
- "MicroLocationsPedestrianFenceRadiusInMeters"
- "MicroLocationsPedestrianFenceWhenSpectatingEnabled"
- "MicroLocationsPowerLogEnabled"
- "MicroLocationsProcessInvalidRssiAP"
- "MicroLocationsProcessOffChannelRssiAP"
- "MicroLocationsPruneDistanceThreshold"
- "MicroLocationsPruneDistanceThresholdSemiSupervised"
- "MicroLocationsRapportMonitorMaxEntries"
- "MicroLocationsRapportTableMaxRows"
- "MicroLocationsRapportTableMigrationPageSize"
- "MicroLocationsRapportUsageEnabled"
- "MicroLocationsRecording80211Modes"
- "MicroLocationsRecording80211ScanType"
- "MicroLocationsRecordingDuration"
- "MicroLocationsRecordingDurationMaximumIncrements"
- "MicroLocationsRecordingEventTableMigrationPageSize"
- "MicroLocationsRecordingEventsForModel"
- "MicroLocationsRecordingEventsTableMaxRows"
- "MicroLocationsRecordingInitialDelay"
- "MicroLocationsRecordingLabelsTableMaxRows"
- "MicroLocationsRecordingPurgeAge"
- "MicroLocationsRecordingScanLowPriority"
- "MicroLocationsRecordingWifiDutyCyclePercentage"
- "MicroLocationsRecordingWifiMaxAgeFirstScan"
- "MicroLocationsRefreshRoutineStateThrottle"
- "MicroLocationsRobustWiFiMinARDecisionTreeFeatureThreshold"
- "MicroLocationsSamplingRateForLearningAnalytics"
- "MicroLocationsScanBleLeechedBeaconsRSSIEnabled"
- "MicroLocationsScanDurationIncrement"
- "MicroLocationsScanDurationThreshold"
- "MicroLocationsScanUWBRangeEnabled"
- "MicroLocationsScanWifiRSSIEnabled"
- "MicroLocationsSemiSupervisedMaxNumIterations"
- "MicroLocationsSemiSupervisedNumSelfLearningSamplesPerIteration"
- "MicroLocationsSemiSupervisedStopProbabilityThreshold"
- "MicroLocationsServiceTableMigrationPageSize"
- "MicroLocationsServicesTableMaxRows"
- "MicroLocationsSimilarityListClusterDistanceThresholdVector"
- "MicroLocationsSimilarityListLabelsPurgeAge"
- "MicroLocationsSimilarityListMaxNumberOfItems"
- "MicroLocationsSimilarityListSmallClusterDistanceThreshold"
- "MicroLocationsSimilarityListSmallClusterRelativeSize"
- "MicroLocationsSimilarityListSmallClusterSize"
- "MicroLocationsTanimotoBaseParams"
- "MicroLocationsUseAlternativeSetting"
- "MicroLocationsUseKMeansClusterCenters"
- "MicroLocationsUwbRangeBufferSize"
- "MicroLocationsUwbRangeLocalizationMinValidSessionTime"
- "MicroLocationsUwbRangeMaximalAgeForValidityFromScanStart"
- "MicroLocationsUwbRangeRequestedUpdateDuration"
- "MicroLocationsUwbRangeRequestedUpdateRate"
- "MicroLocationsUwbRangeRequestedUpdateRateEnabled"
- "MicroLocationsVersion"
- "MicroLocationsWeightedEuclideanJaccardParams"
- "MicroLocationsWeightedEuclideanJaccardTwoSidedParams"
- "MicroLocationsWifiBusyRetryDelay"
- "MicroLocationsWifiErrorRetryDelay"
- "MicroLocationsWifiMaxAgeNextScan"
- "MicroLocationsWifiTimestampJitterThreshold"
- "Microlocation Ble rssi buffer"
- "Microlocation Uwb range buffer"
- "Microlocation error report: %s"
- "Microlocation is not enabled at this moment"
- "MicrolocationQE"
- "Missing key kSettingsNullSpaceNotRoiPercentile"
- "Missing key kSettingsNullSpaceRoiPercentile"
- "Model Type %{private}d disabled in settings"
- "Model cluster RF distances %@: %f (min), %f(max), %f (mean)"
- "Model cluster RF sizes %@: %f (min), %f(max), %f (mean)"
- "Model generated successfully for type %{public}d"
- "Model get prediction classes unknown model type"
- "Model has become invalid after pruning clusters with absolute size threshold"
- "Model type unavailable  - device not buffered to monitor"
- "Models have been regenerated, Letting service Manager know"
- "Models have been regenerated. Doing nothing"
- "Motion fence set to %{public}s"
- "MotionDuration"
- "MotionDurationBounded"
- "MotionDuringPrediction"
- "MotionLocalizationAndLegacyLocalizationsRatio"
- "MotionSM::transitionLogicGeofence, shouldn't receive StopMotion at Geofence state"
- "MotionSM::transitionLogicIdle, shouldn't receive FenceCross at Idle state"
- "MotionSM::transitionLogicIdle, shouldn't receive StopMotion at Idle state"
- "MotionSM::transitionLogicStopDetection, shouldn't receive ScreenOn at StopDetection state"
- "MotionSM::transitionLogicStopDetection, shouldn't receive SetFence at StopDetection state"
- "MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive FenceCross at PendingResumeStopDetection state"
- "MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive ScreenOff at PendingResumeStopDetection state"
- "MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive SetFence at PendingResumeStopDetection state"
- "MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive StopMotion at PendingResumeStopDetection state"
- "MotionWhileDisplayOnAndWhenDisplayTurnedOnRatio"
- "Must contain valid scan activity"
- "NOT"
- "NewLocalizationAndLegacyLocalizationsRatio"
- "Next scan expected to take %{public}.3Lfs (ending at %{public}0.3fs). Expected time that the scan timer will end: %{public}.03fs"
- "No LOI entries for specified LOI Group ID"
- "No Name Given"
- "No ble provided in dictionary"
- "No e2j_kernel_thr provided in dictionary"
- "No event types passed in"
- "No jaccard_scale_factor provided in dictionary"
- "No jaccard_threshold provided in dictionary"
- "No models were generated for model type %{public}d"
- "No per_source_params provided in dictionary"
- "No power provided in dictionary"
- "No sigma provided in dictionary"
- "No tanimoto_base provided in dictionary"
- "No type provided in dictionary"
- "No uwb provided in dictionary"
- "No valid connection to microlocation database."
- "No wifi provided in dictionary"
- "No wifi results so issue a scan with initial delay of %{public}0.3Lfs"
- "NoModelForCurrentLocation"
- "Not allowed to switch to new LOI"
- "Not enough time for another scan"
- "Not in Active Location State"
- "Notification center"
- "Notification,%{public}d"
- "NotificationCenter"
- "NotificationMicroLocation"
- "NowPlaying"
- "NumLocalizations"
- "NumRecordings"
- "NumberOfChannels"
- "NumberOfMacAddressAppearingOnMultipleChannels"
- "NumberOfMacAddresses"
- "Odometer notification %d startTime %f distance %f accuracy %f speed %f odometer %f"
- "Optional Model must have value here"
- "OutputBufferTimestampToleranceSec"
- "PBIOAllowWorkoutSpecificCalibrationParameters"
- "PendingResumeStopDetection"
- "PerHour"
- "Place Inference Fetch Failure"
- "Platform support for milo is set to %{public}s"
- "PowerLog is not enabled so not writing microlocation metrics"
- "Previous recording labels table does not exist, no need to migrate"
- "Privacy reset"
- "ProbabilityMatrix::normalizeRows, row with zero norm!"
- "Pruned %{public}ld AP measurements, buffer size %{public}ld"
- "Public"
- "Purge"
- "Random"
- "Ranging session set to %{public}s"
- "Rapport, rapport monitor buffered bad IDS UUID"
- "Rapport, rapport monitor exceeded max entries"
- "Rapport, rapport monitor read bad IDS UUID from DB"
- "Rapport, rapport session activation error:"
- "Rapport, rapport session already running"
- "Rapport, rapport session already stopped"
- "Rapport, register rapport session"
- "Rapport, start rapport session"
- "Rapport, stopping rapport session"
- "Rapport, unregister rapport session"
- "Read BLE spyscan buffer in Logic!. read %lu measurements (%lu unique)"
- "Received unhandled location notification"
- "Received unsupported event in state event handler"
- "Recording"
- "Recording completion status unset"
- "Recording scan request"
- "Recording stopped"
- "RecordingCompletedEvent"
- "RecordingFenceBreachedEvent"
- "RecordingPendingState"
- "RecordingState"
- "RecordingThrottledState"
- "Refresh Location on regular interval"
- "Register for BLE background-scan session"
- "Register for BLE initiated-scan session"
- "Registering for XPC Activity %s"
- "Registering for leeched location updates"
- "Related LOI Fetch Failure"
- "Reloaded wifi channel histogram"
- "Requested remove confidence reason for non-existent localization request"
- "Requested to remove confidence reason for motion for non-existent localization request"
- "RescheduleTrigger"
- "Restarting Geofence. "
- "Restricted power mode"
- "ReturnCache"
- "Returning scan delay: %{public}0.3Lfs"
- "Reversed from %{public}s to %{public}s"
- "RowId not expected as timestamp column"
- "SELECT * "
- "SELECT * FROM ("
- "SELECT * FROM (SELECT "
- "SELECT * FROM OTHER."
- "SELECT MIN("
- "SEMI_SUPERVISED"
- "SIMILARITY_LIST"
- "SandboxExt"
- "Saving Microlocation localization results to Biome public stream"
- "Saving Microlocation localization results to Biome restricted stream"
- "Scan duration is exceeded threshold"
- "ScanActivityInterrupted"
- "ScanEvent"
- "ScreenOff"
- "ScreenTurnedOff"
- "Selected %lu Legacy status updates"
- "SensorsDriver, Not scanning Wifi RSSI because it's not enabled"
- "SensorsDriver, ble, request timeout"
- "SensorsDriver, ble, start session"
- "SensorsDriver, ble, stop session"
- "SensorsDriver, received a BLE scan request but current scan activity is set"
- "SensorsDriver, received cancel wifi scan when current scan activity is not set"
- "SensorsDriver, uwb, reset ranging rate"
- "SensorsDriver, uwb, start session"
- "SensorsDriver, uwb, stop session"
- "SensorsDriver, wifi, start scanning"
- "SensorsUnavailable"
- "Service Quality is invalid"
- "Service Type unsupported "
- "Setting channels to scan: %{private}s"
- "Should not be starting a recording in this state: NotSet"
- "Similarity List Model Learning, Localizer must not return empty results"
- "Similarity List Model Learning, error normalizing probability matrix"
- "Similarity List Model Learning, labeled recording entry without trigger UUID"
- "Similarity List Model Learning, unexpected identifier"
- "Similarity List Model Learning, unexpectedly couldn't find LSL row for label identifier"
- "Similarity List appending new events, fail to append rows"
- "Similarity List appending new events, fail to normalize rows"
- "Similarity List appending new events, fail to remove nullspace column"
- "Similarity List fail to append new event, unexpected identifier"
- "SimilarityListData, appendNewEvents, fingerprints size not equal labelUuids size!"
- "Start BLE spyscan session"
- "StartRecordingSessionEvent"
- "Started Process of Activaing Geofence"
- "Starting Motion Session MiLo is starting spectating"
- "Starting clients"
- "State Machine: Failed to handle event because current state is NULL"
- "State Machine: Failed to handle event because it is not a valid event for the current state"
- "State Machine: Failed to initialize state because requested state doesn't exist in the state table"
- "State Machine: Failed to switch to new state because requested state doesn't exist in the state table"
- "StopDetection"
- "StopMotion"
- "StopRecordingSessionEvent"
- "Stopping BLE spyscan session"
- "Stopping PDR Fence because MiLo is no longer spectating"
- "Stopping motion based triggers"
- "Successfully migrated legacy labels table to updated schema"
- "Sucessfully created table if necessary: %s"
- "Sucessfully created table if necessary: %{public}s"
- "SuspendReasonLowPower"
- "Suspended"
- "Sysdiagnose Notification"
- "ThrottleTimerFiredEvent"
- "TotalCachedLegacyLocalizations"
- "TotalLegacyLocalizations"
- "TotalLocalizations"
- "TotalLocalizationsWhenDisplayTurnedOn"
- "TotalLocalizationsWhenRescheduled"
- "TotalMotionLocalizations"
- "TotalMotionLocalizationsWhenDisplayTurnedOn"
- "TotalMotionLocalizationsWhenRescheduled"
- "TotalMotionLocalizationsWhileDisplayOn"
- "TotalNewLocalizations"
- "TotalNonCachedLegacyLocalizations"
- "TotalRecordings"
- "Tried to add count per hour fields with duration equals 0."
- "Trigger event already have %s. Ignoring."
- "TriggerType"
- "Trying to assign a value that is bigger than the provided type can hold"
- "Type,%s,Pos,%d,%{sensitive}+.10f,%{sensitive}+.10f,Accuracy,%.3f,Type,%d,%s,LocationTimestamp,%.3f,Age,%.3f,Lifespan,%.3f,"
- "UWB range buffer overflow"
- "Unable to get the value from a CFNumber"
- "Unable to parse protobuf"
- "Undefined Model"
- "Unexpected generation algorithm for kMicroLocationSemisupervisedDomain!"
- "Unknown device id"
- "Unregister all BLE scan sessions"
- "Unsupported Service Type"
- "Unsupported distance function type"
- "Unsupported reducer function"
- "Update model - got null pointer"
- "Updating Significant Locations from Auth Changed Notification"
- "Updating Significant Locations from Location Services Toggle"
- "Updating localizing scan strategy"
- "Utilization"
- "Uwb"
- "Visit entry notification"
- "Visit exit notification"
- "WHERE UserId==\""
- "WHERE rn > "
- "WasInHighQualityBefore"
- "WiFiScanDuration"
- "WiFiScanError"
- "WifiBridge, Location services are disabled, ignore WiFi scan result"
- "WifiBridge, Received a wifi scan result that is not requested by MiLo, ignore this scan result"
- "WifiBridge, Received wifi notification %{public}d with scan type %{public}d"
- "WifiBridge, Wifi is powered off - not scanning"
- "WifiBridge, shouldn't request scanner when scan activity is not set"
- "WifiBridge, the wifi scan timer should have a nextFireTime when requesting scan duration extension"
- "WifiBridge, wifi, stop scanning"
- "WifiZMetrics, publish metric, LastWiFiZAlt_m,%{public}.3lf, groundTruthAltitudeEstimate_m,%{public}.3lf, altitudeChangeFromPressureDifference_m,%{public}.3lf,LastWiFiZAltUnc_m,%{public}.3lf"
- "Wrote microlocation metrics to power log: %{private}s"
- "XXXXXXXXXXXXXXXXX - accessoryDM config"
- "[AccessoryHeartRate] Setting update interval to %{public}f"
- "_exportMiloData:withUserIdentifier:WithReply:"
- "add_candidatequalityreasons"
- "add_confidencereasons"
- "add_eventconfidences"
- "ageOfNewestFingerprint"
- "ageOfOldModel"
- "ageOfOldestFingerprint"
- "ageOfOldestFingerprintBounded"
- "ageOfOldestRecordingDays"
- "airplay"
- "analyzeAssociationState, loiGroupId without unique rtLoiType"
- "and RaceDelayTimeout: "
- "appendNewEvents, set value error"
- "applyRecentChangesToModel, received invalid serviceType = CLMiLoServiceTypeMax"
- "applyRecentLabelsToLSL, model has no location similarity list"
- "applyRecentLabelsToLSL, no current model"
- "auto CLMiLoService::generationAlgorithmByServiceAndLocationType(CLMiLoServiceType, CLMiLoLocationTypeEnum)::(anonymous class)::operator()(CLMicroLocationAlgorithms::LearnerType) const"
- "auto CLMicroLocationAlgorithms::removeImprobableLocations(std::vector<CLMicroLocationResultInternal> &, LocalizerType)::(anonymous class)::operator()(auto, const auto &) const [currentSum:auto = double, result:auto = CLMicroLocationResultInternal]"
- "auto CLMicroLocationDatabase::deleteDataOlderThan(std::chrono::minutes, std::optional<std::chrono::minutes>)::(anonymous class)::operator()(const std::string &) const"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoCustomLoiTable, MemberFn = bool (CLMiLoCustomLoiTable::*)(const std::string &, const boost::uuids::uuid &), Args = <const std::string &, const boost::uuids::uuid &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoCustomLoiTable, MemberFn = std::vector<boost::uuids::uuid> (CLMiLoCustomLoiTable::*)(unsigned int), Args = <unsigned int &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoCustomLoiTable, MemberFn = std::vector<std::string> (CLMiLoCustomLoiTable::*)(const boost::uuids::uuid &), Args = <const boost::uuids::uuid &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoCustomLoiTable, MemberFn = std::vector<std::string> (CLMiLoCustomLoiTable::*)(const std::string &, unsigned int), Args = <const std::string &, unsigned int &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoLoiTable, MemberFn = bool (CLMiLoLoiTable::*)(const boost::uuids::uuid &, const std::vector<boost::uuids::uuid> &, const std::string &), Args = <const boost::uuids::uuid &, const std::vector<boost::uuids::uuid> &, const std::string &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoLoiTable, MemberFn = std::optional<boost::uuids::uuid> (CLMiLoLoiTable::*)(const boost::uuids::uuid &, unsigned int), Args = <const boost::uuids::uuid &, unsigned int &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoLoiTable, MemberFn = std::vector<CLMiLoLoiTable::Entry> (CLMiLoLoiTable::*)(const boost::uuids::uuid &, unsigned int), Args = <const boost::uuids::uuid &, unsigned int &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoLoiTable, MemberFn = std::vector<CLMiLoLoiTable::Entry> (CLMiLoLoiTable::*)(unsigned int), Args = <const unsigned int &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoLoiTable, MemberFn = std::vector<CLMiLoLoiTable::Entry> (CLMiLoLoiTable::*)(unsigned int), Args = <unsigned int &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoLoiTable, MemberFn = std::vector<boost::uuids::uuid> (CLMiLoLoiTable::*)(const std::vector<boost::uuids::uuid> &, unsigned int), Args = <const std::vector<boost::uuids::uuid> &, unsigned int &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoLoiTable, MemberFn = unsigned int (CLMiLoLoiTable::*)(), Args = <>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoServiceTable, MemberFn = bool (CLMiLoServiceTable::*)(), Args = <>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoServiceTable, MemberFn = bool (CLMiLoServiceTable::*)(boost::uuids::uuid), Args = <boost::uuids::uuid &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoServiceTable, MemberFn = bool (CLMiLoServiceTable::*)(boost::uuids::uuid, std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock, std::chrono::duration<long double>>), Args = <boost::uuids::uuid &, std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock, std::chrono::duration<long double>> &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoServiceTable, MemberFn = bool (CLMiLoServiceTable::*)(boost::uuids::uuid, unsigned long long), Args = <boost::uuids::uuid &, unsigned long long &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoServiceTable, MemberFn = bool (CLMiLoServiceTable::*)(const std::vector<std::string> &), Args = <const std::vector<std::string> &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoServiceTable, MemberFn = std::optional<CLMiLoServiceTable::Entry> (CLMiLoServiceTable::*)(boost::uuids::uuid), Args = <boost::uuids::uuid &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoServiceTable, MemberFn = std::vector<CLMiLoServiceTable::Entry> (CLMiLoServiceTable::*)(const std::string &, const std::string &, unsigned int), Args = <const std::string &, const std::string &, unsigned int &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoServiceTable, MemberFn = std::vector<CLMiLoServiceTable::Entry> (CLMiLoServiceTable::*)(unsigned int, unsigned int), Args = <unsigned int &, unsigned int &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationAssociatedStateTable, MemberFn = std::vector<CLMicroLocationAssociatedStateTable::Entry> (CLMicroLocationAssociatedStateTable::*)(const std::string &, const std::string &, boost::uuids::uuid, unsigned int), Args = <const std::string &, const std::string &, boost::uuids::uuid &, unsigned int &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationAssociatedStateTable, MemberFn = std::vector<boost::uuids::uuid> (CLMicroLocationAssociatedStateTable::*)(unsigned int), Args = <unsigned int &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationBluetoothIdentityTable, MemberFn = std::vector<CLMicroLocationBluetoothIdentityTable::Entry> (CLMicroLocationBluetoothIdentityTable::*)(const std::string &, const std::string &, unsigned int), Args = <const std::string &, const std::string &, unsigned int &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationConfigurationTable, MemberFn = std::optional<CLMicroLocationConfigurationTable::Entry> (CLMicroLocationConfigurationTable::*)(boost::uuids::uuid), Args = <const boost::uuids::uuid &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationConfigurationTable, MemberFn = std::optional<CLMicroLocationConfigurationTable::Entry> (CLMicroLocationConfigurationTable::*)(const CLMicroLocationProto::ConfigurationType &, const std::optional<const std::string> &, const std::optional<const boost::uuids::uuid> &), Args = <CLMicroLocationProto::ConfigurationType, const std::nullopt_t &, const boost::uuids::uuid &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationConfigurationTable, MemberFn = std::optional<CLMicroLocationConfigurationTable::Entry> (CLMicroLocationConfigurationTable::*)(const CLMicroLocationProto::ConfigurationType &, const std::optional<const std::string> &, const std::optional<const boost::uuids::uuid> &), Args = <CLMicroLocationProto::ConfigurationType, const std::string &, const std::nullopt_t &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationConfigurationTable, MemberFn = std::optional<CLMicroLocationConfigurationTable::Entry> (CLMicroLocationConfigurationTable::*)(const std::optional<const std::string> &, const std::optional<const boost::uuids::uuid> &, CLMicroLocationProto::ConfigurationType, const std::string &), Args = <const std::nullopt_t &, const boost::uuids::uuid &, const CLMicroLocationProto::ConfigurationType &, const std::string &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationLoggedEventsTable, MemberFn = std::optional<CLMicroLocationLoggedEventsTable::Entry> (CLMicroLocationLoggedEventsTable::*)(const std::string &, const std::vector<CLMicroLocationProto::EventType> &), Args = <const std::string &, const std::vector<CLMicroLocationProto::EventType> &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationLoggedEventsTable, MemberFn = std::vector<CLMicroLocationLoggedEventsTable::Entry> (CLMicroLocationLoggedEventsTable::*)(const std::string &, const std::string &, const std::vector<CLMicroLocationProto::EventType> &, unsigned int), Args = <const std::string &, const std::string &, const std::vector<CLMicroLocationProto::EventType> &, unsigned int &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationMeasurementTable, MemberFn = std::vector<CLMicroLocationMeasurementTable::Entry> (CLMicroLocationMeasurementTable::*)(const boost::uuids::uuid &, const std::string &, const std::string &, unsigned int), Args = <const boost::uuids::uuid &, const std::string &, const std::string &, unsigned int &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationMeasurementTable, MemberFn = std::vector<CLMicroLocationMeasurementTable::Entry> (CLMicroLocationMeasurementTable::*)(const std::vector<boost::uuids::uuid> &, unsigned int), Args = <const std::vector<boost::uuids::uuid> &, unsigned int &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationModelTable, MemberFn = std::optional<CLMicroLocationModelTable::Entry> (CLMicroLocationModelTable::*)(CLMicroLocationProto::Model_ModelType, boost::uuids::uuid), Args = <CLMicroLocationProto::Model_ModelType &, boost::uuids::uuid &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationModelTable, MemberFn = std::optional<CLMicroLocationModelTable::Entry> (CLMicroLocationModelTable::*)(CLMicroLocationProto::Model_ModelType, std::optional<const std::string>, std::optional<boost::uuids::uuid>), Args = <CLMicroLocationProto::Model_ModelType &, std::optional<const std::string> &, std::optional<boost::uuids::uuid> &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationModelTable, MemberFn = std::optional<CLMicroLocationModelTable::Entry> (CLMicroLocationModelTable::*)(const std::string &, boost::uuids::uuid), Args = <const std::string &, boost::uuids::uuid &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationModelTable, MemberFn = std::vector<std::string> (CLMicroLocationModelTable::*)(const std::string &, unsigned int), Args = <const std::string &, unsigned int &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationRapportTable, MemberFn = std::vector<CLMicroLocationRapportTable::Entry> (CLMicroLocationRapportTable::*)(const std::string &, const std::string &, const std::optional<const std::string> &, const std::optional<const boost::uuids::uuid> &, unsigned int), Args = <const std::string &, const std::string &, const std::nullopt_t &, const boost::uuids::uuid &, unsigned int &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationRecordingEventsTable, MemberFn = std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock, std::chrono::duration<long double>> (CLMicroLocationRecordingEventsTable::*)(), Args = <>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationRecordingEventsTable, MemberFn = std::optional<CLMiLoLoiTable::Entry> (CLMicroLocationRecordingEventsTable::*)(), Args = <>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationRecordingEventsTable, MemberFn = std::optional<CLMicroLocationRecordingEventsTable::Entry> (CLMicroLocationRecordingEventsTable::*)(const boost::uuids::uuid &), Args = <const boost::uuids::uuid &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationRecordingEventsTable, MemberFn = std::vector<CLMicroLocationRecordingEventsTable::Entry> (CLMicroLocationRecordingEventsTable::*)(const std::string &, const std::string &, const boost::uuids::uuid &, unsigned int), Args = <const std::string &, const std::string &, const boost::uuids::uuid &, unsigned int &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationRecordingEventsTable, MemberFn = std::vector<CLMicroLocationRecordingEventsTable::Entry> (CLMicroLocationRecordingEventsTable::*)(const std::vector<CLMicroLocationProto::EventType> &, const std::string &, const std::string &), Args = <const std::vector<CLMicroLocationProto::EventType> &, const std::string &, const std::string &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationRecordingEventsTable, MemberFn = std::vector<CLMicroLocationRecordingEventsTable::Entry> (CLMicroLocationRecordingEventsTable::*)(const std::vector<CLMicroLocationProto::EventType> &, unsigned int, const std::string &, std::optional<boost::uuids::uuid>), Args = <const std::vector<CLMicroLocationProto::EventType> &, unsigned int &, const std::string &, std::optional<boost::uuids::uuid> &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationRecordingEventsTable, MemberFn = std::vector<CLMicroLocationRecordingEventsTable::Entry> (CLMicroLocationRecordingEventsTable::*)(const std::vector<boost::uuids::uuid> &, unsigned int), Args = <const std::vector<boost::uuids::uuid> &, unsigned int &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationRecordingLabelsTable, MemberFn = std::vector<CLMicroLocationRecordingLabelsTable::Entry> (CLMicroLocationRecordingLabelsTable::*)(const std::string &, boost::uuids::uuid, unsigned int, std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock, std::chrono::duration<long double>>), Args = <const std::string &, boost::uuids::uuid &, unsigned int &, std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock, std::chrono::duration<long double>> &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationRecordingLabelsTable, MemberFn = std::vector<CLMicroLocationRecordingLabelsTable::Entry> (CLMicroLocationRecordingLabelsTable::*)(const std::string &, unsigned int), Args = <const std::string &, unsigned int &>]"
- "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationRecordingLabelsTable, MemberFn = std::vector<std::string> (CLMicroLocationRecordingLabelsTable::*)(unsigned int), Args = <unsigned int &>]"
- "auto CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationProto::Model::ModelType)::(anonymous class)::operator()() const"
- "auto CLMicroLocationModelTable::deleteUnneededModels(uint32_t, uint32_t)::(anonymous class)::operator()(const std::string &) const"
- "auto CLMicroLocationXPCActivityHelpers::XPCRegistration::XPCRegistration(std::string, const XPCCriteria &, XPCActivityHandler)::(anonymous class)::operator()(xpc_activity_t) const"
- "avgBleFingerprintSize"
- "avgClusterRfDistance"
- "avgClusterRfSize"
- "avgFingerprintDuration"
- "avgFingerprintSize"
- "avgUwbFingerprintSize"
- "avgWifiFingerprintSize"
- "biomePublicEventsFromLocalizationResultMeasurement"
- "biomeRestrictedEventsFromLocalizationResultMeasurement"
- "ble"
- "bleChannel"
- "bleFingerprintSize"
- "bleFingerprintSizeBounded"
- "bleRssiSamplesIgnore"
- "blob"
- "bool (anonymous namespace)::isGoodUwbRange(CLMicroLocationProto::UwbRange)"
- "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLCalorimetryDanceDMFeatures>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLCalorimetryDanceDMFeatures>, T = CLCalorimetryDanceDMFeatures]"
- "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLCalorimetryFunctionalStrengthDMFeatures>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLCalorimetryFunctionalStrengthDMFeatures>, T = CLCalorimetryFunctionalStrengthDMFeatures]"
- "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLCalorimetryKickboxingDMFeatures>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLCalorimetryKickboxingDMFeatures>, T = CLCalorimetryKickboxingDMFeatures]"
- "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLCalorimetryRowingDMFeatures>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLCalorimetryRowingDMFeatures>, T = CLCalorimetryRowingDMFeatures]"
- "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLCatherineData>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLCatherineData>, T = CLCatherineData]"
- "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLCoarseElevationChangeEntry>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLCoarseElevationChangeEntry>, T = CLCoarseElevationChangeEntry]"
- "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLElevationChangeEntry>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLElevationChangeEntry>, T = CLElevationChangeEntry]"
- "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLMotionStateMediator_Type::MediatedMotionActivity>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLMotionStateMediator_Type::MediatedMotionActivity>, T = CLMotionStateMediator_Type::MediatedMotionActivity]"
- "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLOdometerEntry>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLOdometerEntry>, T = CLOdometerEntry]"
- "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLRawHR>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLRawHR>, T = CLRawHR]"
- "bool CLCalorieSourceAdapter::Source<CLNatalieInput<CLSwimEntry>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<CLSwimEntry>, T = CLSwimEntry]"
- "bool CLCalorieSourceAdapter::Source<CLNatalieInput<_CLFitnessMachineData>>::lookup(CFAbsoluteTime, T &) const [LegacySourceT = CLNatalieInput<_CLFitnessMachineData>, T = _CLFitnessMachineData]"
- "bool CLMiLoCustomLoiTable::addServiceToCustomLoiMapping(const std::string &, const boost::uuids::uuid &)"
- "bool CLMiLoCustomLoiTable::insertOrReplace(const std::vector<CLMiLoCustomLoiTable::Entry> &)"
- "bool CLMiLoCustomLoiTable::removeServiceToCustomLoiMapping(const std::string &, const boost::uuids::uuid &)"
- "bool CLMiLoLoiTable::insertOrReplace(const std::vector<CLMiLoLoiTable::Entry> &)"
- "bool CLMiLoLoiTable::updateLoiGroupIdForLois(const boost::uuids::uuid &, const std::vector<boost::uuids::uuid> &, const std::string &)"
- "bool CLMiLoServiceTable::deleteAllServices(const std::vector<std::string> &)"
- "bool CLMiLoServiceTable::deleteOldestsServicesPerClientAboveMaxCount()"
- "bool CLMiLoServiceTable::deleteServiceForUuid(boost::uuids::uuid)"
- "bool CLMiLoServiceTable::insertOrReplace(const std::vector<CLMiLoServiceTable::Entry> &)"
- "bool CLMiLoServiceTable::updateServiceLastActiveTime(boost::uuids::uuid, cl::chrono::CFAbsoluteTimeClock::time_point)"
- "bool CLMiLoServiceTable::updateServiceLocationTypes(boost::uuids::uuid, uint64_t)"
- "bool CLMicroLocationAssociatedStateTable::deleteOldestRows(uint64_t)"
- "bool CLMicroLocationAssociatedStateTable::insertOrReplace(const std::vector<Entry> &)"
- "bool CLMicroLocationBackupAndRestore::exportiCloudBackupDatabaseInternal(std::string &)"
- "bool CLMicroLocationBluetoothIdentityTable::deleteOldestRows(uint64_t)"
- "bool CLMicroLocationBluetoothIdentityTable::insertOrReplace(const std::vector<CLMicroLocationBluetoothIdentityTable::Entry> &)"
- "bool CLMicroLocationConfigurationTable::deleteOldestRows(uint64_t)"
- "bool CLMicroLocationConfigurationTable::insertOrReplace(const std::vector<CLMicroLocationConfigurationTable::Entry> &)"
- "bool CLMicroLocationDatabase::deleteDataOlderThan(std::chrono::minutes, std::optional<std::chrono::minutes>)"
- "bool CLMicroLocationDatabase::deleteUnneededModels(uint32_t, uint32_t)"
- "bool CLMicroLocationDatabase::exportRecordsUsingPaging(const CLMicroLocationDatabase &, const std::string &, const std::string &, const bool, const std::string &, const int64_t, const int64_t, std::function<bool ()>)"
- "bool CLMicroLocationDatabase::freeDatabaseSpace()"
- "bool CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMiLoServiceTable]"
- "bool CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationAssociatedStateTable]"
- "bool CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationBluetoothIdentityTable]"
- "bool CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationConfigurationTable]"
- "bool CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationMeasurementTable]"
- "bool CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationModelTable]"
- "bool CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationRapportTable]"
- "bool CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationRecordingEventsTable]"
- "bool CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationRecordingLabelsTable]"
- "bool CLMicroLocationDatabase::getSqlQueryInt64Result(const std::string &, int64_t &)"
- "bool CLMicroLocationDatabase::getSqlQueryTimestampResult(const std::string &, CFAbsoluteTime &)"
- "bool CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMiLoServiceTable::Entry]"
- "bool CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationAssociatedStateTable::Entry]"
- "bool CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationBluetoothIdentityTable::Entry]"
- "bool CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationConfigurationTable::Entry]"
- "bool CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationMeasurementTable::Entry]"
- "bool CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationModelTable::Entry]"
- "bool CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationRapportTable::Entry]"
- "bool CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationRecordingEventsTable::Entry]"
- "bool CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationRecordingLabelsTable::Entry]"
- "bool CLMicroLocationDatabase::purgeDataForClient(const std::string &)"
- "bool CLMicroLocationDatabase::purgeSimilarityListLabels(std::chrono::minutes)"
- "bool CLMicroLocationDatabase::updateEntries(MemberFn, Args &&...) [Table = CLMicroLocationMeasurementTable, MemberFn = bool (CLMicroLocationMeasurementTable::*)(const std::vector<boost::uuids::uuid> &), Args = <std::vector<boost::uuids::uuid> &>]"
- "bool CLMicroLocationDatabase::updateEntries(MemberFn, Args &&...) [Table = CLMicroLocationModelTable, MemberFn = bool (CLMicroLocationModelTable::*)(const std::vector<std::string> &), Args = <std::vector<std::string>>]"
- "bool CLMicroLocationDatabase::updateEntries(MemberFn, Args &&...) [Table = CLMicroLocationRecordingEventsTable, MemberFn = bool (CLMicroLocationRecordingEventsTable::*)(const std::vector<boost::uuids::uuid> &), Args = <std::vector<boost::uuids::uuid> &>]"
- "bool CLMicroLocationDatabase::updateEntries(MemberFn, Args &&...) [Table = CLMicroLocationRecordingLabelsTable, MemberFn = bool (CLMicroLocationRecordingLabelsTable::*)(const std::vector<std::string> &), Args = <std::vector<std::string>>]"
- "bool CLMicroLocationLegacyClient::donateTruthTagLabel(const std::string &, const boost::uuids::uuid &, const boost::uuids::uuid &)"
- "bool CLMicroLocationLegacyClient::donateTruthTagLabelForRecordingEventsBetweenDates(const std::string &, const boost::uuids::uuid &, NSDate *, NSDate *)"
- "bool CLMicroLocationLoiManager::refreshRoutineStateAtLocation(double, double)"
- "bool CLMicroLocationMeasurementTable::deleteMeasurementsFromRecordingUUIDs(const std::vector<boost::uuids::uuid> &)"
- "bool CLMicroLocationMeasurementTable::deleteOldestRows(uint64_t)"
- "bool CLMicroLocationMeasurementTable::insertOrReplace(const std::vector<Entry> &)"
- "bool CLMicroLocationModelTable::deleteAllModelsOfDeletedServices()"
- "bool CLMicroLocationModelTable::deleteModelsForClients(const std::vector<std::string> &)"
- "bool CLMicroLocationModelTable::deleteOldestRows(uint64_t)"
- "bool CLMicroLocationModelTable::deleteUnneededModels(uint32_t, uint32_t)"
- "bool CLMicroLocationModelTable::insertOrReplace(const std::vector<Entry> &)"
- "bool CLMicroLocationRapportTable::deleteOldestRows(uint64_t)"
- "bool CLMicroLocationRapportTable::insertOrReplace(const std::vector<CLMicroLocationRapportTable::Entry> &)"
- "bool CLMicroLocationRecorder::recordTruthLabelBetweenDates(const std::string &, NSUUID *const, NSDate *const, NSDate *const, const std::string &)"
- "bool CLMicroLocationRecordingEventsTable::deleteOldestRows(uint64_t)"
- "bool CLMicroLocationRecordingEventsTable::deleteRecordingEventsFromRecordingUUIDs(const std::vector<boost::uuids::uuid> &)"
- "bool CLMicroLocationRecordingEventsTable::insertOrReplace(const std::vector<Entry> &)"
- "bool CLMicroLocationRecordingLabelsTable::deleteOldestRows(uint64_t)"
- "bool CLMicroLocationRecordingLabelsTable::deleteRecordingLabelsForClients(const std::vector<std::string> &)"
- "bool CLMicroLocationRecordingLabelsTable::insertOrReplace(const std::vector<Entry> &)"
- "bool CLMicroLocationRecordingLabelsTable::migratePreviousTableIfNecessary()"
- "bool CLMicroLocationTriggerManager::removePolicy(const boost::uuids::uuid &)"
- "bool CLWifiScanner::requestScan(std::shared_ptr<WifiScanSettings>)"
- "boost::uuids::uuid CLMicroLocationLogic::getLoiGroupIdForLoi(const boost::uuids::uuid &, const std::vector<boost::uuids::uuid> &)"
- "boostConnectionToken.has_value()"
- "calcCachedLocalizationResults, didn't find model for requested service"
- "calculateNormalizedProbabilitiesWithoutNullCluster"
- "calculatePerClusterPerAnchorValueStatistics (sentinel), received unhandled data type"
- "calculatePerClusterPerAnchorValueStatistics, received unhandled data type"
- "cancel a requested Ble and WiFi scan"
- "cancelWifiScan"
- "candidateModelQuality"
- "channel: "
- "cl::chrono::CFAbsoluteTimeClock::time_point CLMicroLocationRecordingEventsTable::selectOldestRecordingTimestamp()"
- "cl::chrono::CFAbsoluteTimeClock::time_point CLMicroLocationWifiScanStrategy::getExpectedNextScanEndTime(cl::chrono::CFAbsoluteTimeClock::time_point, cl::chrono::CFAbsoluteTimeClock::duration) const"
- "cl::chrono::milliseconds CLMicroLocationLogic::requestWifiScanExtension(cl::chrono::milliseconds, size_t)"
- "cl::chrono::seconds CLMicroLocationAnalytics::getMiLoSpectatingDuration(const cl::chrono::time_point<cl::chrono::CFAbsoluteTimeClock> &, const cl::chrono::time_point<cl::chrono::CFAbsoluteTimeClock> &, const std::vector<CLMicroLocationProto::EventType> &, const std::function<bool (const CLMicroLocationLoggedEventsTable::Entry &)> &) const"
- "cl::chrono::secondsf CLMicroLocationWifiScanStrategy::getScanDelay(std::optional<WifiNotificationResults>) const"
- "clearScanActivity"
- "cluster distance threshold must not be empty"
- "com.apple.MicroLocation.Analytics"
- "com.apple.MicroLocation.AssociatedState"
- "com.apple.MicroLocation.CustomLoiCreation"
- "com.apple.MicroLocation.CustomLoiVisitEvent"
- "com.apple.MicroLocation.LOIFailures"
- "com.apple.MicroLocation.Localization"
- "com.apple.MicroLocation.Location"
- "com.apple.MicroLocation.Maintenance"
- "com.apple.MicroLocation.ModelLearning"
- "com.apple.MicroLocation.Visit"
- "com.apple.app-sandbox.read"
- "com.apple.locationd.MicroLocationAction-localize"
- "com.apple.locationd.MicroLocationAction-purge"
- "com.apple.locationd.MicroLocationAction-record"
- "com.apple.locationd.microlocation-recording-transaction-commit"
- "com.apple.locationd.microlocation-service-connect"
- "com.apple.locationd.microlocation-update-all-models"
- "com.apple.locationd.microlocation.migrate-cloud-backup"
- "com.apple.locationd.microlocation.stop-localizing"
- "com.apple.locationd.microlocation.stop-recording"
- "com.apple.locationd.milo.appinfocus"
- "com.apple.locationd.milo.nowplaying"
- "com.apple.microlocation.triggers"
- "com.apple.microlocation.triggers.daily"
- "com.apple.milo.security.database.backup"
- "computeDifference"
- "computeExpectedScanDelay"
- "configSelect"
- "configuration.get(\"onesided_jaccard\", weightsDict)"
- "configuration.type() == CLMicroLocationProto::WIFI_HISTOGRAM"
- "configured e2jKernelThr illegal value"
- "connectToServiceForClient"
- "connectionId.has_value()"
- "const T &CMQueue<CLOdometerEntry>::operator[](const size_t) const [T = CLOdometerEntry]"
- "const std::vector<T> CMDataProviderComposite::View::getStream(Strategy) const [StreamT = CMDataProviderFactory::FactoryStream::Odometer, T = CLOdometerEntry, Strategy = CMDataProviderComposite::View::PassThroughStrategy<CLOdometerEntry>]"
- "container.size()>0"
- "convertDoubleVectorToFingerprint"
- "couldn't find label entry of label"
- "create"
- "createFingerprintDistanceFunction"
- "createKernelFunction"
- "createLearner"
- "createLinkageFunction"
- "createLocalizerAlgorithm"
- "createOneSidedWeights"
- "createPerSourceWeights"
- "createReducedDistancesMap"
- "createReducerFunction"
- "createServiceForClient"
- "createWeightedEuclideanJaccardDistanceFunction"
- "createdCustomLoi"
- "custom"
- "customLoiVisitOccurred"
- "deduplicatedLoiCount"
- "deleteModelsForClients"
- "deleteOldestRows"
- "deleteRecordingLabelsForClients"
- "deleteServiceForClient"
- "deltaDays <= 0 && \"deltaDays must be non positive\""
- "derivedEventData != __null"
- "device name unavailable"
- "deviceCapabilities"
- "deviceFlags"
- "dict.get(\"ble\", ble)"
- "dict.get(\"power\", power)"
- "dict.get(\"sigma\", sigma)"
- "dict.get(\"type\", primitiveType)"
- "dict.get(\"uwb\", uwb)"
- "dict.get(\"wifi\", wifi)"
- "didConvert"
- "didn't find recording event matching to fingerprint"
- "disconnectToServiceForClient"
- "discoveryFlags"
- "display on"
- "distanceFunctionConfiguration.get(\"e2j_kernel_thr\", e2jKernelThr)"
- "distanceFunctionConfiguration.get(\"jaccard_scale_factor\", jaccard_scale_factor)"
- "distanceFunctionConfiguration.get(\"per_source_params\", perSourceParams)"
- "distanceThresholdVector must not be empty"
- "donateTruthTagLabelForClient failed internally"
- "double CLMicroLocationFingerprintDistanceFunction::weightedEuclideanJaccardDistance(const CLMicroLocationFingerprint &, const CLMicroLocationFingerprint &, double, double, const CLMicroLocationUtils::Weights<double> &, const CLMicroLocationUtils::Weights<double> &, const CLMicroLocationUtils::Weights<double> &, const CLMicroLocationUtils::Weights<double> &, const CLMicroLocationUtils::Weights<bool> &, const EnabledTechnologiesConfig &, const std::optional<CLMicroLocationAnchorAppearanceMap> &)"
- "downloadAvailabilityFile:"
- "dutyCyclePercentage > 0.0 && dutyCyclePercentage <= 1"
- "e2jKernelThr>0 && e2jKernelThr<=1.0"
- "e2j_kernel_thr"
- "enable MiLo at current location called for a service which is not currently connected"
- "enable MiLo at current location, called without connectionToken"
- "enable MiLo at current location, called without requestId"
- "enable MiLo at current location, called without service identifier"
- "enableMiLoAtCurrentLocation"
- "enterLocationPerService"
- "environment"
- "error in kmeans algorithm"
- "error in mean shift algorithm"
- "euclidean denominator or jaccardDenominator are 0, this can only happen if weights are 0, check configuration!"
- "euclidean_weight"
- "executeStatement Failed. database object is invalid"
- "executeStatement, Failed to create SQL statement"
- "export using paging, table is missing"
- "exportMicroLocationDataForMigrationWithUserIdentifier:withReply:"
- "exportMicroLocationDatabaseTables failed internally."
- "exportRecordsUsingPaging"
- "extendWifiScanTimer"
- "fAppLaunchBiomeScheduler == nullptr"
- "fCurrentScanActivity != CLMicroLocationUtils::ScanActivity::NotSet"
- "fCurrentScanActivity == CLMicroLocationUtils::ScanActivity::NotSet"
- "fCurrentTransaction"
- "fFingerprintCache optional is empty, database likely changed since data source construction"
- "fLastTrigger is in the past"
- "fNextWifiScanTimerFireTime != cl::chrono::CFAbsoluteTimeClock::from_cf(1.7976931348623157e+308)"
- "fNowPlayingBiomeScheduler == nullptr"
- "fSameAccountBleIdentities exceeded max entries"
- "fState.enabled()"
- "failed to copy MiLo database tables!"
- "failed to create destination directory"
- "failed to dynamicly load protobuf lib symbol"
- "failed to issue sandbox extension for file"
- "failed to remove existing destination directory"
- "failed to remove existing directory"
- "failed to remove file"
- "failed to set attributes for file"
- "failureReason"
- "failureType"
- "feedRealtimeElevation:"
- "fingerprint distance type not supported"
- "fingerprintDistanceFunction.has_value()"
- "fingerprintVector must be non-empty"
- "fingerprintVector.size() > 0"
- "firstQuartileValueSorted"
- "focus-mode"
- "fromConfiguration"
- "fromProtobuf"
- "fsmStateDuringFailure"
- "generationAlgorithm"
- "geofenceLocationHorizontalAccuracy"
- "geofenceLocationVerticalAccuracy"
- "getAdjustmentPowerForBinaryRoiDetectionThreshold"
- "getClientLabelsAndLabeledRecordingEventsForLoi"
- "getClientLabelsAndLabeledRecordingEventsForLoi, labelEntries must be empty"
- "getClientLabelsAndLabeledRecordingEventsForLoi, labeledRecordingEvents must be empty"
- "getClusterLabels"
- "getCurrentStatus"
- "getFingerprintDistanceFunctionParamsForType"
- "getMicroLocationInternalVersionWithReplyBlock:"
- "getPredictionClasses"
- "getRecordingEventsForModelType"
- "getTimeDeltaDaysAgo"
- "getTransitionModelForClientAtLoi"
- "getWiFiScanParameters"
- "getWifiScannerForScanActivity"
- "got nullptr from CLMicroLocationProto add_anchorvaluestatistics"
- "got nullptr from CLMicroLocationProto add_clusteranchorvaluestatisticsvector"
- "got start time bigger than end time while calculating milo spectating duration"
- "got sufficient recording triggers, will ignore prior cluster number in learning"
- "got unexpected event type to indicate start/stop motion spectating"
- "got unexpected event type to indicate start/stop spectating"
- "handleFenceStatusTimerFire"
- "handleRaceDelayTimerFire"
- "hasLegacy"
- "hasRecordings"
- "histogramDiffCount"
- "histogramDiffCountPercentage"
- "histogramFromProtobuf"
- "histogramTotalChannelCount"
- "iCloud restore db file does not exist at %{private}s"
- "idsDeviceID"
- "idsDeviceIdentifier"
- "ii >= 0 && ii < size()"
- "index out of bounds"
- "initWithAbsoluteTimeStamp:clientBundleIdentifier:maxProbabilityLabelIdentifier:maxProbability:probabilityVector:numDevicesVector:"
- "initWithDictionary:copyItems:"
- "initWithDomain:maxProbabilityMicroLocationIdentifier:maxProbability:probabilityVector:isStable:numDevicesVector:"
- "initWithLabelIdentifier:probability:"
- "initWithMicroLocationIdentifier:probability:"
- "initWithTechnology:numDevices:"
- "invalid connection token in disconnectToServiceForClient"
- "invalid file protection class requested for the default CoreLocation Database"
- "invalid generation algorithm"
- "invalid model type"
- "isLoiLegacy"
- "isLowLatency"
- "isLowObservationLegacyClient"
- "isModelExists"
- "isModelStable"
- "isSupportedWorkoutTypeForIOFusion"
- "iterator != fServices.end()"
- "jaccard_neg_weight"
- "jaccard_pos_weight"
- "jaccard_scale_factor"
- "jaccard_threshold"
- "json string is invalid"
- "kMicroLocationConfigurationSelect"
- "labelEntries.size() == 0"
- "labeledRecordingEvents.size() == 0"
- "lastRecordingAge"
- "lastSeenAge"
- "learn"
- "learnBinaryRoiSemiSupervisedModel, couldn't find label of labeled fingerprint"
- "learnBinaryRoiSemiSupervisedModel, couldn't find trigger of labeled fingerprint"
- "learnCounter"
- "learnLocationSimilarityListModel"
- "learnLocationSimilarityListModel, didn't classify all labeled triggers to either recording or localization"
- "learnSelfTrainingSemiSupervisedModel"
- "learnSemiSupervisedModel, labeled fingerprint, label not found"
- "learnSemiSupervisedModel, labeled fingerprint, trigger not found"
- "learning"
- "listElement.probability().size() == clusterIds.size()"
- "localization results vector cannot be empty"
- "localizationPopularThreeAndPrevOneTopChannels"
- "localizationPopularThreeAndTopOneChannels"
- "localizationPopularThreeChannels"
- "localizationPrevTopFiveChannels"
- "localizationPrevTopFourChannels"
- "localizationPrevTopThreeChannels"
- "localizationRequestResultsPerModelInternal"
- "localizationRunTime"
- "localizationTop%dCommonChannels"
- "localizationTopFiveChannels"
- "localizationTopFourChannels"
- "localizationTopThreeChannels"
- "localizationTriggerEvent"
- "localizationTriggerEventCount"
- "localize"
- "loiAirplayCount"
- "loiCount"
- "loiHomeCount"
- "loiNotHomeCount"
- "loiRelatedFailureOccurred"
- "loiWorkCount"
- "low latency"
- "lowLatencySession"
- "lslEventConfidences.size() == static_cast<size_t>(cosineSimilarityOpt->getNumRows())"
- "m:timeout:"
- "maintenanceRunTime"
- "mapIdentifiers"
- "mapped cluster identifer already exists"
- "maxBleFingerprintSize"
- "maxClusterProbability"
- "maxClusterRfDistance"
- "maxClusterRfSize"
- "maxDistanceBelowPersistenceThreshold"
- "maxFingerprintDuration"
- "maxFingerprintSize"
- "maxUwbFingerprintSize"
- "maxWifiFingerprintSize"
- "maximumValue"
- "maximumValueSorted"
- "meanValue"
- "meas index: %{public}d, deviceId: %{private}s, range: %{private}f, age: %{public}f"
- "measVector.size() == uniqueMeasurementSet.size()"
- "medianValueSorted"
- "microLocationDB"
- "microLocationDiagnosticDB"
- "milo-internal-legacy-client-name-unsupervised"
- "milo_cache"
- "milo_restore.db"
- "minBleFingerprintSize"
- "minClusterLabel < numberOfClusters"
- "minClusterRfDistance"
- "minClusterRfSize"
- "minDistanceAbovePersistenceThreshold"
- "minFingerprintDuration"
- "minFingerprintSize"
- "minNumCluster must be greater than zero"
- "minNumClusters>0"
- "minPercentile >= 0 && minPercentile <= 1 && maxPercentile >= minPercentile && maxPercentile <= 1"
- "minProbabilityTagged == 0 || fpAndRes.second.fProbability <= minProbabilityTagged"
- "minUwbFingerprintSize"
- "minWifiFingerprintSize"
- "min_dist should not be infinity"
- "minimumValue"
- "minimumValueSorted"
- "model != nullptr"
- "model->fModel.modelType != CLMicroLocationProto::Model_ModelType_SEMI_SUPERVISED || model->fClientId.has_value()"
- "model.isValid()"
- "model.modelType == CLMicroLocationProto::Model::SIMILARITY_LIST"
- "modelLoadedByteSize"
- "modelQuality"
- "modelQualityBounded"
- "modelSizeNumBleMeasurements"
- "modelSizeNumFingerprints"
- "modelSizeNumMeasurements"
- "modelSizeNumUwbMeasurements"
- "modelSizeNumWiFiMeasurements"
- "modelTypeByServiceAndLocationType"
- "modelTypeFromString"
- "modelTypeIndex < recordingEventsForModel.size()"
- "must have fingerprints distance function"
- "newClusterIterAndBool.second"
- "no value found for key %s in %s CA event. Skipping it."
- "not low latency"
- "not running"
- "nsObject != nullptr && [nsObject isKindOfClass:[NSDictionary class]]"
- "nullspaceClusterProbability"
- "numClusters"
- "numClustersDiff"
- "numClustersPrunedIteration%u"
- "numConfiguationsDeleted"
- "numConfigurations"
- "numCustomLoiIds"
- "numElements>0"
- "numFingerprints"
- "numFingerprintsBounded"
- "numFingerprintsInCluster%zu"
- "numFingerprintsInRemainingClusters"
- "numFingerprintsInSmallestCluster"
- "numFingerprintsPrunedInIteration%u"
- "numLabeledFingerprints"
- "numLabeledFingerprintsBounded"
- "numMatchingClustersInt"
- "numMeasurements"
- "numMeasurementsDeleted"
- "numModels"
- "numModelsDeleted"
- "numOldClusters"
- "numRapportEntries"
- "numRapportEntriesDeleted"
- "numRecordingEvents"
- "numRecordingEventsDeleted"
- "numSourcesBle"
- "numSourcesBleBounded"
- "numSourcesUwb"
- "numSourcesUwbBounded"
- "numSourcesWifi"
- "numSourcesWifiBounded"
- "numUnlabeledFingerprints"
- "numUnlabeledFingerprintsBounded"
- "number of measurements still exceeds maximum"
- "numberOfClusters == clusterCenters.size()"
- "numberOfClusters == initialClusterCenters.size()"
- "numberOfClusters > 0"
- "offsetColumnName != ColumnTraits<CLMicroLocationMeasurementTable::DatabaseColumns::RowId>::name"
- "onFailureToReceiveGeofenceStatusReports: "
- "onMotionMeasurements, couldn't find StopMotionDetection element"
- "onScanActivityCompleted"
- "onStartRecordingOrLocalizing"
- "onStopWifiScanTimer"
- "onesided_jaccard"
- "ongoingTimer"
- "openTransaction"
- "optionalModel"
- "parameterizedTruncatedMeanValueSorted"
- "parametrizedPercentileSorted"
- "params.get(\"jaccard_scale_factor\", jaccard_scale_factor)"
- "params.get(\"jaccard_threshold\", jaccard_threshold)"
- "params.get(\"tanimoto_base\", tanimoto_base)"
- "perSourceParams.get(key.c_str(), weightsDict)"
- "per_source_params"
- "placeId.has_value()"
- "portionClustersPrunedIteration%u"
- "portionFingerprintsPrunedInIteration%u"
- "portionMatchingClusters"
- "power > 0.0"
- "pragma integrity_check;"
- "pragma quick_check;"
- "prctile >= 0.0 && prctile <= 1.0"
- "prevHistogramTotalChannelCount"
- "primitiveType < static_cast<uint32_t>(KernelFunctionType::kTypeCount)"
- "primitiveTypeToSettingType"
- "private.HomeKit.accessory.accessoryUUID"
- "private.HomeKit.accessory.characteristicType"
- "private.HomeKit.accessory.roomUUID"
- "private.HomeKit.accessory.serviceGroupUUID"
- "private.HomeKit.accessory.serviceType"
- "private.HomeKit.accessory.serviceUUID"
- "private.HomeKit.accessory.source"
- "private.HomeKit.accessory.stateString"
- "private.HomeKit.scene.actionSetName"
- "private.HomeKit.scene.actionSetType"
- "private.HomeKit.scene.actionSetUUID"
- "private.HomeKit.scene.clientName"
- "private.HomeKit.scene.homeName"
- "private.HomeKit.scene.source"
- "private.MicroLocation.recordingTriggerUUID"
- "private.MicroLocation.truthtag.identifier"
- "protection == CLSqliteDatabase::kSqliteProtectionEncryptedClassB"
- "prune threshold must be less than or equal to clusterDistance threshold"
- "pruneDistanceThreshold <= *std::min_element(dendrogramLearningParams.clusterDistanceThresholdVector.begin(), dendrogramLearningParams.clusterDistanceThresholdVector.end())"
- "qualityReasons"
- "ranging session already running"
- "ranging session already stopped"
- "received biome event data doesn't match event type BMAppInFocus"
- "received biome event data doesn't match event type BMNowPlayingEvent"
- "recordEvent"
- "recordMeasurementBatch"
- "recordTruthLabelBetweenDates, startDate is later than endDate"
- "recordingDuration"
- "recordingEntry.fTriggerUUID.has_value()"
- "recovered anchor value map"
- "registerForMiloPredictionEventUpdates, MicroLocations not supported on this platform"
- "registerForMiloPredictionEventUpdates:"
- "registerForMiloServiceEventUpdates, MicroLocations not supported on this platform"
- "registerForMiloServiceEventUpdatesForClient:withToken:"
- "release stream %s obs %p activeRefCount %d refCnt %d"
- "releaseAllModels"
- "removeExceedingMeasurements"
- "representativeFPsRatio"
- "request labeling without observation request identifier"
- "request labeling without place identifier"
- "request labeling without request identifier"
- "request labeling without service identifier"
- "request labling between times without place identifier"
- "request labling between times without request identifier"
- "request labling between times without service identifier"
- "request learning without request identifier"
- "request learning without service identifier"
- "request observation without request identifier"
- "request observation without service identifier"
- "request prediction  without service identifier"
- "request prediction without request identifier"
- "request remove custom Loi service identifier"
- "request removing labels without request identifier"
- "request start updating without request identifier"
- "request start updating without service identifier"
- "request stop updateing MicroLocation without request identifier"
- "request stop updating without service identifier"
- "request stream %s obs %p leech %d activeRefCnt %d refCnt %d use count %d"
- "request stream created %s obs %p leech %d activeRefCnt %d refCnt %d use count %d"
- "requestCurrentMicroLocation failed internally, MiLo is not at right state"
- "requestCurrentMicroLocationForClient:withAdditionalInformation:"
- "requestId.has_value()"
- "requestLabelObservationsBetweenDatesForClient"
- "requestLabelSingleObservationForClient"
- "requestMicroLocationLearningForClient"
- "requestMicroLocationRecordingScan failed internally, MiLo is not at right state"
- "requestMicroLocationRecordingScan failed internally, MicroLocation is not enabled"
- "requestObservationForClient"
- "requestPurgeAllMiLoData"
- "requestRemoveCustomLoi"
- "requestRemoveLabelsForClient"
- "requestSingleShotPredictionForClient"
- "requestStartUpdatingMicroLocationForClient"
- "requestStatus"
- "requestStopUpdatingMicroLocationForClient"
- "res"
- "response.fServiceDescriptor.has_value()"
- "results.resultsVector.size() > 0"
- "results.size()>0"
- "retriving anchor statistics map failed internally."
- "roiProbability"
- "rtLoiType"
- "runTime"
- "scanActivity == CLMicroLocationUtils::ScanActivity::Localizing || scanActivity == CLMicroLocationUtils::ScanActivity::Recording"
- "scanActivity == ScanActivity::Recording || scanActivity == ScanActivity::Localizing"
- "scanner type 15, 16 deviceFilter is empty for initiated scan"
- "selectMeasurementsFromRecordingUUIDs"
- "selectRecordingEventTriggersForLearningMeasurements"
- "selectRecordingEventsWithScanMeasurementsBetweenTimes"
- "semi-supervised model has no clientId value"
- "serviceId.has_value()"
- "set model to stable"
- "setDeviceFilter:"
- "setOobKeys:"
- "setScanActivity"
- "setTargetUserSession:"
- "setting BLE background-scan session status to paused"
- "settingsMap.count(CLMicroLocationLocalizationSettings::kSettingsNullSpaceNotRoiPercentile) > 0"
- "settingsMap.count(CLMicroLocationLocalizationSettings::kSettingsNullSpaceRoiPercentile) > 0"
- "settingsString"
- "should not call addNewTruthLabelToModelIfAppropriate with CLMiLoServiceTypeMax"
- "shouldTriggerLocalizationScan"
- "shouldTriggerRecordingScan"
- "sigma"
- "sigma > 0.0"
- "signedValue <= std::numeric_limits<IntType>::max()"
- "signedValue >= 0"
- "size(dataType) <= maximumNumberOfMeasurements"
- "stableIdentifier"
- "start a ranging session"
- "start motion state-machine geofence"
- "startBleRssiSession"
- "startMonitoringBiomeEvents"
- "startScanning"
- "stateFunction"
- "static CLMiLoServiceQuality CLMiLoService::internalToExternalServiceQuality(CLMicroLocationProto::Model_ModelQualityLevel, CLMicroLocationProto::Model_ModelQualityLevel)"
- "static CLMicroLocationFingerprint::Measurement CLMicroLocationFingerprint::Measurement::fromProtobuf(const CLMicroLocationProto::FingerprintMeasurement &)"
- "static CLMicroLocationModel CLMicroLocationModel::fromProtobuf(const CLMicroLocationProto::Model &, CLMicroLocationFingerprintPool &)"
- "static CLMicroLocationProto::Model_GenerationAlgorithm CLMiLoService::generationAlgorithmByServiceAndLocationType(CLMiLoServiceType, CLMiLoLocationTypeEnum)"
- "static cl::chrono::CFAbsoluteTimeClock::time_point CLMicroLocationProtobufHelper::getEventReceivedTS(const CLMicroLocationProto::RecordingEvent &)"
- "static std::optional<CLMicroLocationProto::BleLeechedBeacons> CLMicroLocationProtobufHelper::protobufFromNative(const CLMicroLocationBleWrapperForCBDevice &)"
- "static void CLMicroLocationCoreAnalyticsPublishHelper::sendCommonTriggerEvent(const CLMicroLocationProto::RecordingEvent &, const std::string &, const std::string &, const std::string &, const bool, const bool, NSMutableDictionary *)_block_invoke"
- "static void CLMicroLocationCoreAnalyticsPublishHelper::updateClusterRfDistanceCharacteristics(NSMutableDictionary *, const CLMicroLocationModel &)"
- "static_cast<uint32_t>(learnerType) < static_cast<uint32_t>(LearnerType::kAlgorithmCount)"
- "static_cast<uint32_t>(localizerType) < static_cast<uint32_t>(LocalizerType::kAlgorithmCount)"
- "static_cast<uint32_t>(type) < static_cast<uint32_t>(DataSourceType::kTypeCount)"
- "static_cast<uint32_t>(type) < static_cast<uint32_t>(LinkageFunctionType::kTypeCount)"
- "static_cast<uint32_t>(type) < static_cast<uint32_t>(ReducerFunctionType::kTypeCount)"
- "status.state != CLMiLoServiceState::CLMiLoServiceStateRunning || status.suspendReasons.empty()"
- "status.state != CLMiLoServiceState::CLMiLoServiceStateSuspended || !status.suspendReasons.empty()"
- "std::optional<CLMiLoServiceTable::Entry> CLMiLoServiceTable::getServiceByUuid(boost::uuids::uuid)"
- "std::optional<CLMicroLocationAnchorValueStatisticsMap> CLMicroLocationNotifier::getMicroLocationAnchorStatisticsMap()"
- "std::optional<CLMicroLocationConfigurationTable::Entry> CLMicroLocationConfigurationTable::getMostRecentConfigurationAtLoi(const CLMicroLocationProto::ConfigurationType &, const std::optional<const std::string> &, const std::optional<const boost::uuids::uuid> &)"
- "std::optional<CLMicroLocationModel> CLMicroLocationLearner::learnMagicalMomentsModelInternal(NSMutableDictionary *, std::vector<CLMicroLocationRecordingEventsTable::Entry> &, const CLMicroLocationLearner::ShouldCancelFunction &, const CLMicroLocationAnchorAppearanceMap &, CLMicroLocationFingerprintPool &, cl::chrono::CFAbsoluteTimeClock::time_point, const boost::uuids::uuid &, const std::optional<CLMicroLocationModelTable::Entry> &, const CLMicroLocationProto::Model::ModelType)"
- "std::optional<CLMicroLocationModelTable::Entry> CLMicroLocationLearner::learnMagicalMomentsModel(NSMutableDictionary *, std::vector<CLMicroLocationRecordingEventsTable::Entry> &, const CLMicroLocationLearner::ShouldCancelFunction &, const CLMicroLocationAnchorAppearanceMap &, CLMicroLocationFingerprintPool &, const std::string &, const boost::uuids::uuid &, const std::optional<CLMicroLocationModelTable::Entry> &)"
- "std::optional<CLMicroLocationModelTable::Entry> CLMicroLocationModelTable::getMostRecentModelByClientIdAndLocation(const std::string &, boost::uuids::uuid)"
- "std::optional<CLMicroLocationModelTable::Entry> CLMicroLocationModelTable::getMostRecentModelOfModelTypeForClientAndForLoi(CLMicroLocationProto::Model::ModelType, std::optional<const std::string>, std::optional<boost::uuids::uuid>)"
- "std::optional<CLMicroLocationModelTable::Entry> CLMicroLocationModelTable::getTransitionModelForClientAtLoi(const std::string &, boost::uuids::uuid)"
- "std::optional<CLMicroLocationRecordingEventsTable::Entry> CLMicroLocationRecordingEventsTable::getMostRecentRecordingForLoiGroupId(const boost::uuids::uuid &)"
- "std::optional<boost::uuids::uuid> CLMiLoLoiTable::getLoiGroupIdForLoi(const boost::uuids::uuid &, uint32_t)"
- "std::optional<std::string> CLMicroLocationBackupAndRestore::getLocationDbDirPath()"
- "std::optional<std::string> CLMicroLocationLoiManager::EnableCustomLoiWhileInHomeLoi(const CLMiLoLoiManagerEnableCustomLoiEvent *)"
- "std::optional<std::string> CLMicroLocationLoiManager::FailedToFetchedPlaceInference(const CLMiLoLoiManagerFailedToFetchPlaceInference *)"
- "std::optional<std::string> CLMicroLocationLoiManager::HandleLeechedLocation(const CLMiLoLoiManagerLeechedLocationEvent *)"
- "std::optional<std::string> CLMicroLocationLoiManager::LoiForGivenLocation(const CLMiLoLoiManagerReceivedLoiForLocationEvent *)"
- "std::optional<std::string> CLMicroLocationLoiManager::SuccessfullyFetchedPlaceInference(const CLMiLoLoiManagerFetchedPlaceInference *)"
- "std::optional<std::string> CLMicroLocationLoiManager::VisitEntry(const CLMiLoLoiManagerLoiVisitEntryEvent *)"
- "std::string CLMicroLocationLoiManager::convertPlaceInferenceUserPlaceTypeToString(_CLPlaceInferenceUserSpecificPlaceType)"
- "std::string CLMicroLocationLoiManager::convertRTLocationOfInterestTypeToString(RTLocationOfInterestType)"
- "std::string CLMicroLocationLoiManager::handleEnableCustomLoi(CLMiLoService::ServiceUuid)"
- "std::string CLPressureDataManager::getPressureDataServerUrl()"
- "std::tuple<bool, const CLMicroLocationProto::RecordingEvent> CLMicroLocationLegacyEventForcedRecording::handleEvent(const cl::chrono::CFAbsoluteTimeClock::time_point &)"
- "std::unordered_map<boost::uuids::uuid, CLMicroLocationFingerprint> CLMicroLocationClientUtils::requireFingerprintsForTriggerUuids(CLMicroLocationDatabase &, const std::vector<boost::uuids::uuid> &)"
- "std::vector<CLMiLoLoiTable::Entry> CLMiLoLoiTable::selectAllLoiGroups(uint32_t)"
- "std::vector<CLMiLoLoiTable::Entry> CLMiLoLoiTable::selectEntries(CLSqliteDatabase &, const std::string &, uint32_t)"
- "std::vector<CLMiLoLoiTable::Entry> CLMiLoLoiTable::selectLoiIdsInLoiGroupId(const boost::uuids::uuid &, uint32_t)"
- "std::vector<CLMiLoLoiTable::Entry> CLMicroLocationDatabase::selectAllLoiGroups()"
- "std::vector<CLMiLoProtobufWrapper::Measurement> CLMicroLocationSensorsLogic::getBleMeasurements()"
- "std::vector<CLMiLoProtobufWrapper::Measurement> CLMicroLocationSensorsLogic::getUwbMeasurements()"
- "std::vector<CLMiLoProtobufWrapper::WiFiRssi> CLMicroLocationScanBuffer::ingestAps(cl::chrono::CFAbsoluteTimeClock::time_point, const std::vector<CLMiLoProtobufWrapper::WiFiRssi> &)"
- "std::vector<CLMiLoProtobufWrapper::WiFiRssi> CLMicroLocationScanBuffer::pruneAps(cl::chrono::CFAbsoluteTimeClock::time_point, cl::chrono::CFAbsoluteTimeClock::duration)"
- "std::vector<CLMiLoServiceTable::ClientServices> CLMiLoServiceTable::getClientsServiceCountWithString()"
- "std::vector<CLMiLoServiceTable::Entry> (anonymous namespace)::selectEntries(CLSqliteDatabase &, const std::string &, uint32_t)"
- "std::vector<CLMiLoServiceTable::Entry> CLMiLoServiceTable::getAllServicesForClientAndUserId(const std::string &, const std::string &, uint32_t)"
- "std::vector<CLMiLoServiceTable::Entry> CLMiLoServiceTable::getAllServicesForServiceType(uint32_t, uint32_t)"
- "std::vector<CLMicroLocationAssociatedStateTable::Entry> (anonymous namespace)::selectEntries(CLSqliteDatabase &, const std::string &, uint32_t, const std::string &)"
- "std::vector<CLMicroLocationAssociatedStateTable::Entry> CLMicroLocationAssociatedStateTable::selectBetweenTimesAtLoi(const std::string &, const std::string &, boost::uuids::uuid, uint32_t)"
- "std::vector<CLMicroLocationBluetoothIdentityTable::Entry> (anonymous namespace)::selectEntries(CLSqliteDatabase &, const std::string &, uint32_t)"
- "std::vector<CLMicroLocationBluetoothIdentityTable::Entry> CLMicroLocationBluetoothIdentityTable::selectBetweenTimes(const std::string &, const std::string &, uint32_t)"
- "std::vector<CLMicroLocationConfigurationTable::Entry> (anonymous namespace)::selectEntries(CLSqliteDatabase &, const std::string &, uint32_t)"
- "std::vector<CLMicroLocationLoggedEventsTable::Entry> (anonymous namespace)::selectEntries(CLSqliteDatabase &, const std::string &, uint32_t, const std::string &)"
- "std::vector<CLMicroLocationLoggedEventsTable::Entry> CLMicroLocationLoggedEventsTable::selectByFields(const std::optional<std::string> &, const std::optional<std::string> &, const std::vector<CLMicroLocationProto::EventType> &, uint32_t)"
- "std::vector<CLMicroLocationMeasurementTable::Entry> (anonymous namespace)::selectEntries(CLSqliteDatabase &, const std::string &, uint32_t)"
- "std::vector<CLMicroLocationMeasurementTable::Entry> CLMicroLocationMeasurementTable::selectLearningMeasurementsAtLoiBetweenTimes(const boost::uuids::uuid &, const std::string &, const std::string &, uint32_t)"
- "std::vector<CLMicroLocationMeasurementTable::Entry> CLMicroLocationMeasurementTable::selectMeasurementsFromRecordingUUIDs(const std::vector<boost::uuids::uuid> &, uint32_t)"
- "std::vector<CLMicroLocationModelTable::Entry> (anonymous namespace)::selectEntries(CLSqliteDatabase &, const std::string &, uint32_t)"
- "std::vector<CLMicroLocationRapportTable::Entry> (anonymous namespace)::selectEntries(CLSqliteDatabase &, const std::string &, uint32_t)"
- "std::vector<CLMicroLocationRapportTable::Entry> CLMicroLocationRapportTable::selectBetweenTimesAtLoi(const std::string &, const std::string &, const std::optional<const std::string> &, const std::optional<const boost::uuids::uuid> &, uint32_t)"
- "std::vector<CLMicroLocationRecordingEventsTable::Entry> (anonymous namespace)::selectEntries(CLSqliteDatabase &, const std::string &, uint32_t, const std::string &)"
- "std::vector<CLMicroLocationRecordingEventsTable::Entry> CLMicroLocationRecordingEventsTable::selectRecordingEventTriggersForLearningMeasurements(const std::vector<CLMicroLocationProto::EventType> &, uint32_t, const std::string &, std::optional<boost::uuids::uuid>)"
- "std::vector<CLMicroLocationRecordingEventsTable::Entry> CLMicroLocationRecordingEventsTable::selectRecordingEventsBetweenTimesAtLoi(const std::string &, const std::string &, const boost::uuids::uuid &, uint32_t)"
- "std::vector<CLMicroLocationRecordingEventsTable::Entry> CLMicroLocationRecordingEventsTable::selectRecordingEventsFromUUIDs(const std::vector<boost::uuids::uuid> &, uint32_t) [UuidColumn_t = CLMicroLocationRecordingEventsTable::DatabaseColumns::RecordingUUID]"
- "std::vector<CLMicroLocationRecordingEventsTable::Entry> CLMicroLocationRecordingEventsTable::selectRecordingEventsFromUUIDs(const std::vector<boost::uuids::uuid> &, uint32_t) [UuidColumn_t = CLMicroLocationRecordingEventsTable::DatabaseColumns::TriggerUUID]"
- "std::vector<CLMicroLocationRecordingEventsTable::Entry> CLMicroLocationRecordingEventsTable::selectRecordingEventsWithScanMeasurementsBetweenTimes(const std::vector<CLMicroLocationProto::EventType> &, const std::string &, const std::string &)"
- "std::vector<CLMicroLocationRecordingLabelsTable::Entry> (anonymous namespace)::selectEntries(CLSqliteDatabase &, const std::string &, uint32_t, const std::string &, bool)"
- "std::vector<CLMicroLocationRecordingLabelsTable::Entry> CLMicroLocationClientUtils::requireServiceLabelEntries(CLMicroLocationDatabase &, const CLMiLoService::ServiceUuid &, const std::string &, const std::optional<CLMiLoService::MiLoLocation> &, cl::chrono::CFAbsoluteTimeClock::time_point)"
- "std::vector<CLMicroLocationRecordingLabelsTable::Entry> CLMicroLocationRecordingLabelsTable::selectRecordingLabelsForClient(const std::string &, uint32_t)"
- "std::vector<CLMicroLocationRecordingLabelsTable::Entry> CLMicroLocationRecordingLabelsTable::selectRecordingLabelsForClientAtLoi(const std::string &, boost::uuids::uuid, uint32_t, cl::chrono::CFAbsoluteTimeClock::time_point)"
- "std::vector<boost::uuids::uuid> CLMiLoCustomLoiTable::getAllCustomLoiIds(uint32_t)"
- "std::vector<boost::uuids::uuid> CLMiLoLoiTable::getLoiGroupIdsForLois(const std::vector<boost::uuids::uuid> &, uint32_t)"
- "std::vector<boost::uuids::uuid> CLMicroLocationAssociatedStateTable::selectAllLoiGroupIds(uint32_t)"
- "std::vector<std::pair<std::string, std::string>> CLMicroLocationModelTable::selectAllModelIdsClientIds(uint32_t)"
- "std::vector<std::string> CLMiLoCustomLoiTable::getAllServicesEnabledAtCustomLoiId(const boost::uuids::uuid &)"
- "std::vector<std::string> CLMiLoCustomLoiTable::selectLoiIdsForCurrentUser(const std::string &, uint32_t)"
- "std::vector<std::string> CLMicroLocationModelTable::getAllServicesUUIDs(uint32_t)"
- "std::vector<std::string> CLMicroLocationModelTable::selectLoiGroupIdsForCurrentUser(const std::string &, uint32_t)"
- "std::vector<std::string> CLMicroLocationRecordingLabelsTable::selectAllClientIds(uint32_t)"
- "stop a motion state-machine"
- "stop a ranging session"
- "stopAllStatusTimers"
- "stopReason != LocalizationStopReason::CompletedSuccessfully, but stopReasonToConfidenceReason returned nullopt! shouldn't happen"
- "supportsGnssGnssStatusQueryAssertion"
- "supportsPreciseDistanceMeasurement"
- "syncgetMicroLocationInternalVersion:"
- "tanimoto_base"
- "triggerFallbackLocalizationEvent: fLastTrigger is in the past"
- "truth label donation request"
- "try to set confidence for non-existent localization request"
- "uint32_t CLMiLoLoiTable::numLoiGroups()"
- "uint32_t CLMicroLocationDatabase::numEntries() [Table = CLMiLoLoiTable]"
- "uint32_t CLMicroLocationDatabase::numEntries(const char *const)"
- "uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMiLoLoiTable]"
- "uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMiLoServiceTable]"
- "uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMicroLocationAssociatedStateTable]"
- "uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMicroLocationBluetoothIdentityTable]"
- "uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMicroLocationConfigurationTable]"
- "uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMicroLocationMeasurementTable]"
- "uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMicroLocationModelTable]"
- "uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMicroLocationRapportTable]"
- "uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMicroLocationRecordingEventsTable]"
- "uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMicroLocationRecordingLabelsTable]"
- "uint64ToLocationTypesBitset"
- "unhandled serviceType"
- "unregisterForMiloPredictionEventUpdates, MicroLocations not supported on this platform"
- "unregisterForMiloServiceEventUpdates, MicroLocations not supported on this platform"
- "unsupervised"
- "unused location data,%s,%{sensitive}f,%s,%{sensitive}f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%d,%s,%d,%s,%f,%s,%f,%s,%f,%s,%f"
- "updateLocalizationConfidenceAndReasonsIfNeeded, no current localization"
- "updateMagicalMomentsNumPrunedFingerprints called incorrectly"
- "updateModel"
- "uwb"
- "uwb cached scan, read %{public}lu measurements"
- "uwbFingerprintSize"
- "uwbFingerprintSizeBounded"
- "uwbRangeSamplesIgnore"
- "v1340@0:8i16(NotificationData={CLNatalieData=i^{__CFString}diBBddqqd[16C]I}B{CLBodyMetrics=iiffffffffifBfBBB}f{CLExerciseMinuteData=id^{__CFString}}{CLStandMinuteInputData=dIId}{VO2MaxResult=didBBBBB[16C]Bddii}{VO2MaxSessionStats=dfBd}d{CLCalorieUpdate={CLNatalieData=i^{__CFString}diBBddqqd[16C]I}diddBddBfIIdB}B{CLCalorieThroughputData={CLCalorieUpdate={CLNatalieData=i^{__CFString}diBBddqqd[16C]I}diddBddBfIIdB}{Data=dddd{MediatedMotionActivity=d{CLMotionActivity=iiiiiidBfdBidi{FsmTransitionData=CCCS} dii{?=b1b1b1b1b1}iidQi}i{CLNatalieFeatures=fffffffiB}qqqBB[16C]}{CMPedometerStep=ddIdddCI}{CLCalorimetryPushCount=dI}{CLCatherineData=iiddBdddi}{CLOdometerEntry=ddddddddddiiiddddddddiiB{CLOdometerTrackProximityInfo=id}}{CLElevationChangeEntry=ddIIidiifCSfBB}{CLSwimEntry=Q[16C][16C]dddddddiiiiffiiddi}{CLCoarseElevationChangeEntry=dIi}{_CLFitnessMachineData=dddddqqqddiddiddidddiB}{CLCalorimetryFunctionalStrengthDMFeatures=diB}{CLCalorimetryDanceDMFeatures=dfff}{CLCalorimetryRowingDMFeatures=dfffff}{CLCalorimetryKickboxingDMFeatures=dfff}{CLRawHR=dddB}dd}})20"
- "v24@0:8@?<v@?@\"NSError\"@\"NSString\">16"
- "v24@0:8R@\"<CLMicroLocationNotifierClientProtocol>\"16"
- "v24@?0{time_point<cl::chrono::CFAbsoluteTimeClock, std::chrono::duration<long double>>={duration<long double, std::ratio<1>>=D}}8r^v16"
- "v32@0:8@\"NSString\"16@\"NSUUID\"24"
- "v32@0:8@\"NSString\"16@?<v@?@\"NSError\"@\"NSDictionary\">24"
- "v32@0:8R@\"<CLMicroLocationNotifierClientProtocol>\"16@\"NSUUID\"24"
- "v32@0:8^d16^d24"
- "v32@0:8r^i16r^(NotificationData={CLNatalieData=i^{__CFString}diBBddqqd[16C]I}B{CLBodyMetrics=iiffffffffifBfBBB}f{CLExerciseMinuteData=id^{__CFString}}{CLStandMinuteInputData=dIId}{VO2MaxResult=didBBBBB[16C]Bddii}{VO2MaxSessionStats=dfBd}d{CLCalorieUpdate={CLNatalieData=i^{__CFString}diBBddqqd[16C]I}diddBddBfIIdB}B{CLCalorieThroughputData={CLCalorieUpdate={CLNatalieData=i^{__CFString}diBBddqqd[16C]I}diddBddBfIIdB}{Data=dddd{MediatedMotionActivity=d{CLMotionActivity=iiiiiidBfdBidi{FsmTransitionData=CCCS} dii{?=b1b1b1b1b1}iidQi}i{CLNatalieFeatures=fffffffiB}qqqBB[16C]}{CMPedometerStep=ddIdddCI}{CLCalorimetryPushCount=dI}{CLCatherineData=iiddBdddi}{CLOdometerEntry=ddddddddddiiiddddddddiiB{CLOdometerTrackProximityInfo=id}}{CLElevationChangeEntry=ddIIidiifCSfBB}{CLSwimEntry=Q[16C][16C]dddddddiiiiffiiddi}{CLCoarseElevationChangeEntry=dIi}{_CLFitnessMachineData=dddddqqqddiddiddidddiB}{CLCalorimetryFunctionalStrengthDMFeatures=diB}{CLCalorimetryDanceDMFeatures=dfff}{CLCalorimetryRowingDMFeatures=dfffff}{CLCalorimetryKickboxingDMFeatures=dfff}{CLRawHR=dddB}dd}})24"
- "v40@0:8@\"NSString\"16@\"NSDictionary\"24@?<v@?@\"NSError\">32"
- "v40@0:8@\"NSString\"16@\"NSUUID\"24@\"NSString\"32"
- "v40@0:8@\"NSString\"16@\"NSUUID\"24@\"NSUUID\"32"
- "v40@0:8@\"NSUUID\"16@\"NSUUID\"24@\"NSUUID\"32"
- "v48@0:8@\"NSString\"16@\"NSUUID\"24@\"NSUUID\"32@\"NSString\"40"
- "v48@0:8@\"NSString\"16@\"NSUUID\"24@\"NSUUID\"32@\"NSUUID\"40"
- "v48@0:8@\"NSString\"16@\"NSUUID\"24@\"NSUUID\"32@?<v@?@\"NSError\">40"
- "v48@0:8@\"NSUUID\"16@\"NSUUID\"24@\"NSString\"32@\"NSUUID\"40"
- "v56@0:8@\"NSString\"16@\"NSUUID\"24@\"NSDate\"32@\"NSDate\"40@?<v@?@\"NSError\">48"
- "v56@0:8@\"NSString\"16@\"NSUUID\"24@\"NSUUID\"32@\"CLMiLoUpdateConfiguration\"40@\"NSUUID\"48"
- "v56@0:8@\"NSString\"16@\"NSUUID\"24@\"NSUUID\"32@\"NSArray\"40@\"NSUUID\"48"
- "v56@0:8@\"NSString\"16@\"NSUUID\"24@\"NSUUID\"32@\"NSUUID\"40@\"NSUUID\"48"
- "v56@0:8@\"NSString\"16Q24@\"NSArray\"32@\"NSUUID\"40@\"NSString\"48"
- "v64@0:8@\"NSString\"16@\"NSUUID\"24@\"NSUUID\"32@\"NSUUID\"40@\"NSUUID\"48@\"NSUUID\"56"
- "v72@0:8@\"NSString\"16@\"NSUUID\"24@\"NSUUID\"32@\"NSUUID\"40@\"NSDate\"48@\"NSDate\"56@\"NSUUID\"64"
- "value < (1ULL<<kMaxLocationTypes)"
- "value_scale_factor"
- "virtual CLMicroLocationAlgorithms::LocalizerResults CLMicroLocationCosineSimilarityLocalizationAlgorithm::localize(const CLMicroLocationModel &, const CLMicroLocationFingerprint &, const std::optional<CLMicroLocationFingerprintDistanceFunction::Signature> &, const CLMicroLocationLocalizationSettings &, std::optional<boost::uuids::uuid> *) const"
- "virtual CLMicroLocationLogic::~CLMicroLocationLogic()"
- "virtual CLMicroLocationModel CLMicroLocationKMeansAlgorithm::learn(const CLMicroLocationFingerprintVector &, CLMicroLocationProto::Model::ModelType, size_t, const CLMicroLocationAnchorAppearanceMap &, CLMicroLocationFingerprintPool &, size_t) const"
- "virtual CLMicroLocationSensorsLogic::~CLMicroLocationSensorsLogic()"
- "virtual T CLMicroLocationUtils::PerSourceWeights<bool>::operator[](const CLMicroLocationFingerprint::Measurement &) const [T = bool]"
- "virtual bool CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::clientRegistered(int, const Notification_T &) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]"
- "virtual bool CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]"
- "virtual bool CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]"
- "virtual std::shared_ptr<CLWifiScanner::WifiScanSettings> CLMicroLocationWifiScanStrategy::getNextScanSettings(cl::chrono::CFAbsoluteTimeClock::time_point, std::optional<WifiNotificationResults>)"
- "virtual void CLFenceMonitorNotifier::triggerMicroLocationLocalizer()"
- "virtual void CLMicroLocationBLERssiBridge::stopBleRssiSession()"
- "virtual void CLMicroLocationLogic::onStartRecordingOrLocalizing(const CLMicroLocationProto::RecordingEvent &, const CLMicroLocationUtils::ScanActivity, const cl::chrono::CFAbsoluteTimeClock::time_point &, NSMutableDictionary *)"
- "virtual void CLMicroLocationLogic::onUpdateSpectating(bool)"
- "virtual void CLMicroLocationLoiManager::handleFetchedLocationOfInterestAtLocation(CLMicroLocationLoi *, CLLocation *, NSError *)"
- "virtual void CLMicroLocationLoiManager::handleFetchedPlaceInferences(NSArray<_CLPlaceInference *> *, NSError *)"
- "virtual void CLMicroLocationLoiManager::handleVisitNotification(CLVisit *)"
- "virtual void CLMicroLocationNotifier::deregisterForLeechedLocationUpdates()"
- "virtual void CLMicroLocationNotifier::onSendPredictionResultsToClient(const CLMiLoService::ServiceDescriptor &, const std::optional<boost::uuids::uuid> &, const CLMicroLocationResultToPublish &, const CLMiLoService::ConnectionUuid &)"
- "virtual void CLMicroLocationNotifier::registerForLeechedLocationUpdates()"
- "virtual void CLMicroLocationNotifier::shutdown()"
- "virtual void CLMicroLocationNotifier::startRapportSession()"
- "virtual void CLMicroLocationNotifier::startSpectating()"
- "virtual void CLMicroLocationNotifier::stopRapportSession()"
- "virtual void CLMicroLocationNotifier::stopSpectating()"
- "virtual void CLMicroLocationSensorsDriver::onBLEScanRequestTimeout()"
- "virtual void CLMicroLocationSensorsDriver::updateWifiScanStrategiesIfNecessary()"
- "virtual void CLMicroLocationSensorsLogic::onFailureToReceiveGeofenceStatusReports()"
- "virtual void CLMicroLocationWifiBridge::startWifiRssiScanning(CLMicroLocationUtils::ScanActivity)"
- "virtual void CLMicroLocationWifiBridge::stopWifiRssiScanning(CLMicroLocationUtils::ScanActivity)"
- "virtual void CLNatalieInput<CLMotionStateMediator_Type::MediatedMotionActivity>::update(CFAbsoluteTime) [Data_T = CLMotionStateMediator_Type::MediatedMotionActivity]"
- "virtual void CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::listClients() [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]"
- "virtual void CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]"
- "virtual void CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::removeClient(int) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]"
- "visitEventType"
- "void (anonymous namespace)::registerActivity(const XPCCriteria &, CLMicroLocationBackgroundActivities::IBackgroundActivitiesDelegate &, std::vector<std::unique_ptr<XPCRegistration>> &, std::optional<ObserverRegistrationFunction>, RunActivity) [WorkT = CLMicroLocationMaintenance, RunActivity = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationBackgroundActivities.mm:100:15)]"
- "void CLDigitalElevationModel::downloadAvailabilityFile(const CFAbsoluteTime &)"
- "void CLHighResolutionSignalEnvironmentDataManager::downloadAvailabilityFile(const CFAbsoluteTime &)"
- "void CLMiLoCustomLoiTable::initTable()"
- "void CLMiLoLoiTable::initTable()"
- "void CLMiLoService::loadAnchorValueStatistics()"
- "void CLMiLoServiceTable::initTable()"
- "void CLMicroLocationAlgorithms::removeImprobableLocations(std::vector<CLMicroLocationResultInternal> &, LocalizerType)"
- "void CLMicroLocationAnalytics::addPerHoursFields(NSMutableDictionary *, NSArray<NSString *> *, NSString *, const cl::chrono::hoursf &) const"
- "void CLMicroLocationAnalytics::sendCoreAnalyticsEvent(const std::vector<CLMicroLocationWiFiChannelHistogram> &, const std::vector<CLMicroLocationWiFiChannelHistogram> &, const std::string &) const"
- "void CLMicroLocationAssociatedStateTable::initTable()"
- "void CLMicroLocationBiomeMonitor::startMonitoringBiomeEvents()_block_invoke"
- "void CLMicroLocationBluetoothIdentityTable::initTable()"
- "void CLMicroLocationConfigurationTable::initTable()"
- "void CLMicroLocationDatabase::connectIfNecessary()"
- "void CLMicroLocationDatabase::dropTables()"
- "void CLMicroLocationErrorHandling::reportError(const std::string &)"
- "void CLMicroLocationLearner::generateAnchorAppearanceMap(CLMicroLocationLearner::ShouldCancelFunction)"
- "void CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationProto::Model::ModelType)"
- "void CLMicroLocationLearner::onLearningBegin(CLMicroLocationLearner::ShouldCancelFunction)"
- "void CLMicroLocationLearner::onLearningCompleted(CLMicroLocationLearner::ShouldCancelFunction)"
- "void CLMicroLocationLearner::updateModelDaysWithRecordings(CLMicroLocationModel &, const cl::chrono::CFAbsoluteTimeClock::time_point &, const std::optional<struct ModelStabilityParameters> &, const boost::uuids::uuid &)"
- "void CLMicroLocationLocalizationController::localizationRequestResultsPerModel(const CLMicroLocationLocalizationController::LocalizationRequest &, const std::vector<std::shared_ptr<CLMiLoService::ModelAndConf>> &, CLMiLoServiceManager::LocalizationResults &)"
- "void CLMicroLocationLocalizationController::sendLocalizationCoreAnalyticsEvent(const CLMiLoService::ModelAndConf &, const std::vector<CLMicroLocationResultInternal> &, const std::optional<std::vector<CLMicroLocationResultInternal>> &, const CLMicroLocationFingerprint &, const CLMicroLocationProto::RecordingEvent &, const std::optional<cl::chrono::CFAbsoluteTimeClock::time_point> &) const"
- "void CLMicroLocationLogic::State::clearScanActivity()"
- "void CLMicroLocationLogic::State::setScanActivity(CLMicroLocationUtils::ScanActivity)"
- "void CLMicroLocationLogic::onLearningCompleted()"
- "void CLMicroLocationLogic::onModelGenerated(CLMicroLocationProto::Model::ModelType)"
- "void CLMicroLocationLogic::onResetLocationData()"
- "void CLMicroLocationLogic::reloadSettings()"
- "void CLMicroLocationLogic::reloadWifiChannelHistogram()"
- "void CLMicroLocationLogic::setLocationServicesEnabled(bool)"
- "void CLMicroLocationLogic::setPlatformSupport(bool)"
- "void CLMicroLocationLogic::startRapportSessionIfStopped()"
- "void CLMicroLocationLogic::stopLocalizing(LocalizationStopReason)"
- "void CLMicroLocationLogic::stopRapportSessionIfRunning()"
- "void CLMicroLocationLogic::stopRecording(RecordingMetaInformation &)"
- "void CLMicroLocationLogic::updateEnabled()"
- "void CLMicroLocationLoiManager::sendCoreAnalyticsEvent(NSString *, NSDictionary *)"
- "void CLMicroLocationLoiManager::setupWithLoiBridge(id<CLMicroLocationLoiBridgeProtocol>)"
- "void CLMicroLocationMaintenance::collectMetricsPostMaintenance()"
- "void CLMicroLocationMaintenance::deleteOldEntries()"
- "void CLMicroLocationMaintenance::freeDatabaseSpace()"
- "void CLMicroLocationMeasurementTable::initTable()"
- "void CLMicroLocationModel::mapIdentifiersFromOldModelAndPruneNoiseClusters(const std::optional<std::reference_wrapper<CLMicroLocationModel>> &, const bool, NSMutableDictionary *)"
- "void CLMicroLocationModelTable::initTable()"
- "void CLMicroLocationMotionBridge::handleFenceStatusTimerFire()"
- "void CLMicroLocationMotionBridge::handleRaceDelayTimerFire()"
- "void CLMicroLocationMotionBridge::stopAllStatusTimers()"
- "void CLMicroLocationNotifier::onClientManagerNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)"
- "void CLMicroLocationNotifier::onDaemonStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)"
- "void CLMicroLocationNotifier::onDataProtectionManagerNotification(int, const CLDataProtectionManager_Type::Notification &, const CLDataProtectionManager_Type::NotificationData &)"
- "void CLMicroLocationNotifier::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)"
- "void CLMicroLocationNotifier::onNotificationCenterNotification(CFNotificationCenterRef, CFStringRef, const void *, CFDictionaryRef)"
- "void CLMicroLocationNotifier::registerForMiloPredictionEventUpdates(id<CLMicroLocationNotifierClientProtocol>)"
- "void CLMicroLocationNotifier::registerForMiloServiceEventUpdates(id<CLMicroLocationNotifierClientProtocol>, NSUUID *)"
- "void CLMicroLocationNotifier::startClients()"
- "void CLMicroLocationNotifier::unregisterForMiloPredictionEventUpdates(id<CLMicroLocationNotifierClientProtocol>)"
- "void CLMicroLocationNotifier::unregisterForMiloServiceEventUpdates(id<CLMicroLocationNotifierClientProtocol>, NSUUID *)"
- "void CLMicroLocationPowerLog::logMetrics(std::optional<ObserverPowerLogFunction>, std::string, NSDictionary *) const"
- "void CLMicroLocationRapportTable::initTable()"
- "void CLMicroLocationRecorder::RecordingTransaction::updateFingerprintMetaInfoOfCurrentRecording(const CLMicroLocationFingerprintConfiguration &, CLMicroLocationRecordingCompletionMetaInformation::RecordingMetaInformation &)"
- "void CLMicroLocationRecordingEventsTable::initTable()"
- "void CLMicroLocationRecordingLabelsTable::initTable()"
- "void CLMicroLocationSensorsDriver::requestWifiScan(const CLMicroLocationSensorsDriver::WifiScanRequestParams &)"
- "void CLMicroLocationSensorsDriver::resetRangingRate()"
- "void CLMicroLocationSensorsDriver::startBleRssiSession(const CLMicroLocationUtils::BleScanConfiguration &)"
- "void CLMicroLocationSensorsDriver::startRanging()"
- "void CLMicroLocationSensorsDriver::stopBleRssiSession()"
- "void CLMicroLocationSensorsDriver::stopRanging()"
- "void CLMicroLocationSensorsLogic::State::setBleSpyscanSessionRunning(bool)"
- "void CLMicroLocationSensorsLogic::State::setMotionSessionState(bool)"
- "void CLMicroLocationSensorsLogic::State::setRangingSessionRunning(bool)"
- "void CLMicroLocationSensorsLogic::onRecordingOrLocalizingInterrupted()"
- "void CLMicroLocationSensorsLogic::pauseBackgroundBleSessionIfNeeded(const bool)"
- "void CLMicroLocationSensorsLogic::setFence(bool)"
- "void CLMicroLocationSensorsLogic::startBleRssiSession(const CLMicroLocationUtils::BleScanConfiguration &)"
- "void CLMicroLocationSensorsLogic::startBleSpyscanSessionIfStopped()"
- "void CLMicroLocationSensorsLogic::startRangingSessionIfStopped()"
- "void CLMicroLocationSensorsLogic::stopBleSpyscanSessionIfRunning()"
- "void CLMicroLocationSensorsLogic::stopMotionSM()"
- "void CLMicroLocationSensorsLogic::stopRangingSessionIfRunning()"
- "void CLMicroLocationTriggerManager::setCurrentLocalizationUUID(const CLMicroLocationProto::RecordingEvent &)"
- "void CLMicroLocationTriggerManager::setRescheduledTriggerLocalizationUUID(const CLMicroLocationProto::RecordingEvent &)"
- "void CLMicroLocationWifiBridge::onWifiNotification(int, const CLWifiService_Type::Notification &, const CLWifiService_Type::NotificationData &)"
- "void CLMicroLocationXPCActivityHelpers::XPCActivity::setState(xpc_activity_state_t)"
- "void CLMicrolocationBiomePublisherHelper::saveEventsToBiomeStream(NSArray<BMMicroLocationRestrictedLocalizationEvent *> *)"
- "void CLMicrolocationBiomePublisherHelper::saveEventsToPublicBiomeStream(NSArray<BMLocationMicroLocationVisit *> *)"
- "void CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]"
- "void CLPressureDataManager::downloadAvailabilityFile(const CFAbsoluteTime &)"
- "void CLWifiScanner::onTimerTriggered()"
- "void CLWifiScanner::onWifiNotification(int, const CLWifiService_Type::Notification &, const CLWifiService_Type::NotificationData &)"
- "void CLWifiScanner::scheduleNextScan(std::shared_ptr<WifiScanSettings>)"
- "void CLWifiScanner::start()"
- "void CLWifiScanner::stop()"
- "void CMDataProviderFactoryOdometer::onOdometer(const CLOdometerNotifier_Type::Notification &, const CLOdometerNotifier_Type::NotificationData &)"
- "void displaySAUserFeedback(const std::string &, SADeviceType)"
- "weightedEuclideanJaccardDistance"
- "when appending event to similarity list, model has no similarity list!"
- "when appending event to similarity list, service has no current model!"
- "wifiFingerprintSize"
- "wifiFingerprintSizeBounded"
- "workout elevation result updated with,altitude,%f,mslp,%f,sampleTimestamp,%f,verticalAccuracy,%f,rounds,%d"
- "x.dataType() == y.dataType()"
- "{\"jaccard_scale_factor\":1.0,\"e2j_kernel_thr\":0.5,\"per_source_params\": {\"value_scale_factor\" :{\"wifi\":0.05,\"ble\":0.025,\"uwb\":0.15}, \"euclidean_weight\":{\"wifi\":3.0,\"ble\":3.0,\"uwb\":50.0}, \"jaccard_pos_weight\":{\"wifi\":2.0,\"ble\":2.0,\"uwb\":2.0},\"jaccard_neg_weight\":{\"wifi\":1.0,\"ble\":5.0,\"uwb\":10.0},\"onesided_jaccard\":{\"wifi\":false,\"ble\":false,\"uwb\":false}}}"
- "{\"jaccard_scale_factor\":1.0,\"e2j_kernel_thr\":0.5,\"per_source_params\": {\"value_scale_factor\" :{\"wifi\":0.05,\"ble\":0.025,\"uwb\":0.15}, \"euclidean_weight\":{\"wifi\":3.0,\"ble\":3.0,\"uwb\":50.0}, \"jaccard_pos_weight\":{\"wifi\":2.0,\"ble\":2.0,\"uwb\":2.0},\"jaccard_neg_weight\":{\"wifi\":1.0,\"ble\":5.0,\"uwb\":10.0},\"onesided_jaccard\":{\"wifi\":true,\"ble\":false,\"uwb\":false}}}"
- "{\"jaccard_threshold\" : 0.75, \"jaccard_scale_factor\" : 20.0}"
- "{\"msg%{public}.0s\":\"# MiLo Logic -- tried to initialize with an invalid queue\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"#LOI Manager, Adding LOI to Service ID mapping\", \"Location ID\":%{private, location:escape_only}s, \"Service ID\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"#LOI Manager, Disabling geofence that we were trying to enable for custom LOI since we are failing the request\", \"loiID\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"#LOI Manager, Error: tried to enable custom LOI at an active custom LOI\"}"
- "{\"msg%{public}.0s\":\"#LOI Manager, Failed to RemoveGeofence\", \"regionId\":%{private, location:escape_only}@, \"error\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"#LOI Manager, No More services monitoring this LOI, disable geofence for LOI\", \"loiID\":%{private, location:escape_only}s, \"Service Id\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"#LOI Manager, Removing LOI to Service ID mapping\", \"Location ID\":%{private, location:escape_only}s, \"Service ID\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"#LOI Manager, Since we are in the LOI exit LOI\"}"
- "{\"msg%{public}.0s\":\"#LOI Manager, didRemoveGeofenceWithId\", \"regionId\":%{private, location:escape_only}@, \"error\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"#LOI Manager, failed to get current location to enable MiLo\", \"Error\":%{public, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"#LOI Manager, failed to get current location to enable MiLo... aborting request\"}"
- "{\"msg%{public}.0s\":\"#LOI Manager, failed to set geofence at current location to enable MiLo\", \"Error\":%{public, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"#LOI Manager, failed to set geofence at current location to enable MiLo, failing custom loi request\"}"
- "{\"msg%{public}.0s\":\"#LOI Manager, got enable custom LOI request from the same service, ignoring\", \"LOI ID\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry event for valid LOI\", \"LOI ID\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for LOI\", \"LOI ID\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for different valid LOI, entering it\", \"LOI ID\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for the current active LOI which shouldn't happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"#LOI Manager, got geofence exit for active LOI\", \"regionID\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"#LOI Manager, got geofence exit for an LOI which is not the currently the active LOI, this may happen if we jumped from one geofence to another and the entry for the new geofence arrived first\", \"regionID\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"#LOI Manager, got location update to enable custom geofence\", \"latitude\":\"%{sensitive}7f\", \"longitude\":\"%{sensitive}7f\"}"
- "{\"msg%{public}.0s\":\"#LOI Manager, got location update\", \"latitude\":\"%{sensitive}7f\", \"longitude\":\"%{sensitive}7f\"}"
- "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"#LOI Manager, sending core analytics\", \"event\":%{private, location:escape_only}s, \"eventFields\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"#LOI Manager, successfully set geofence, now waiting on fence entry update\", \"geofenceId\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"#LoiRecordingManager Tried to initialize with an invalid queue\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"#Spi,MicroLocationInternalVersion,#warning Couldn't get MicroLocation Internal Version\"}"
- "{\"msg%{public}.0s\":\"#Warning AP matches timestamp and mac in buffer, but values are not same\", \"mac address\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"#Warning Attempt to purge data for client without a backing database\", \"clientId\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"#Warning LOI Bridge not setup.\"}"
- "{\"msg%{public}.0s\":\"#Warning LOI Manager, Error retrieving related LOIs for Loi\", \"error\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"#Warning Wifi Channel Histogram was not generated properly\", \"Inserted\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"#Warning, number of total input fingerprints is smaller than number of labeled fingerprints, note labeled fingerprints include localization triggers which used a different fp generation configuration\", \"Number of Input ValidFingerprints\":%{public}u, \"Number of Input Valid Fingerprints Labeled\":%{public}u}"
- "{\"msg%{public}.0s\":\"#Warning, table is not valid so we can't get cluster anchor value statistics maps from it\"}"
- "{\"msg%{public}.0s\":\"#Warning, table is not valid so we can't get the most recent configuration before time\"}"
- "{\"msg%{public}.0s\":\"#Warning, the protobuf ClusterAnchorValueStatistics struct doesn not have a valid cluster UUID\"}"
- "{\"msg%{public}.0s\":\"#authsync #conflict in capabilities\", \"OperationType\":%{public}d, \"clientKey\":%{public, location:escape_only}s, \"result\":%{public, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"#cclp unregistration\", \"client-Id\":%{public}ld, \"client\":%{public, location:escape_only}@, \"notification\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"#cms mode notify visit\", \"arrive\":%{public, location:escape_only}@, \"end\":%{public, location:escape_only}@, \"detect\":%{public, location:escape_only}@, \"entry\":%{public}hhd, \"fi\":%{public}d, \"visit\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"#durian #latency didUpdateConnectionInterval after update\", \"item\":%{private, location:escape_only}@, \"periph\":%{private, location:escape_only}@, \"task\":%{private, location:escape_only}@, \"interval\":%{private, location:escape_only}@, \"current_interval\":\"%{private}.2f\"}"
- "{\"msg%{public}.0s\":\"#durian #latency didUpdateConnectionInterval\", \"item\":%{private, location:escape_only}@, \"periph\":%{private, location:escape_only}@, \"task\":%{private, location:escape_only}@, \"interval\":%{private, location:escape_only}@, \"current_interval\":\"%{private}.2f\"}"
- "{\"msg%{public}.0s\":\"#durian #metric userstatsSubmission\", \"userStatsVersion\":%{public}d, \"pairedDeviceFirmwareVersion\":%{public, location:escape_only}@, \"accessoryTypeName\":%{public, location:escape_only}@, \"pairedDeviceID\":%{private, location:escape_only}@, \"serialNumber\":%{private, location:escape_only}@, \"multiLeashTime\":%{public}lu, \"multiConnectionTime\":%{public}lu, \"nearOwnerTime\":%{public}lu, \"wildTime\":%{public}lu, \"singleLeashTime\":%{public}lu, \"singleConnectionTime\":%{public}lu, \"dualConnectionTime\":%{public}lu, \"dualConnectionLeashTime\":%{public}lu, \"utAccelCount\":%{public}lu, \"observationDurationFW\":%{public}lu, \"roseOnTime\":%{public}lu, \"fc1ndrangingTime\":%{public}lu, \"fc1ndrangingCount\":%{public}lu, \"ownerLongSoundCount\":%{public}lu, \"ownerShortSoundCount\":%{public}lu, \"playSoundLongUTCount\":%{public}lu, \"playSoundShortUTCount\":%{public}lu, \"BOMSoundCount\":%{public}lu, \"lastPIn\":%{public}lu, \"batteryState\":%{public}lu, \"nbmmsRangingTime\":%{public}lu, \"abandonedFWUpCount\":%{public}lu, \"abandonedFWUpTime\":%{public}lu, \"roseInitCount\":%{public}lu, \"pairingAttemptsCount\":%{public}lu, \"proxPairingTime\":%{public}lu}"
- "{\"msg%{public}.0s\":\"#durian adv own\", \"addr\":%{private, location:escape_only}@, \"uuid\":%{private, location:escape_only}@, \"index\":%{public, location:escape_only}@, \"nap\":%{public}d, \"needsmaint\":%{private}d, \"date\":%{public, location:escape_only}@, \"scanCore\":%{public, location:escape_only}@, \"status\":%{private}d, \"data\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"#durian adv unowned\", \"addr\":%{private, location:escape_only}@, \"nap\":%{public}d, \"date\":%{public, location:escape_only}@, \"status\":%{private}d, \"data\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"#durian complete current active task on preemption\", \"item\":%{private, location:escape_only}@, \"task\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"#durian enqueuing preempted task\", \"item\":%{private, location:escape_only}@, \"task\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"#durian task attempted preempt, but awaiting ack\", \"item\":%{private, location:escape_only}@, \"activetask\":%{private, location:escape_only}@, \"newtask\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"#pcHistorical min-criteria visits reply-handler\", \"Error\":%{public, location:escape_only}s, \"historicalVisits\":%{public}d, \"fAtLeastThreeUniqueVisitsAvailable\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"#warning integrity check failed\", \"path\":%{public, location:escape_only}s, \"rc\":%{public, location:SqliteResult}.*P, \"integrtiy_result\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Activity runner: activity finished\", \"State\":%{public}u, \"Time elapsed (ms)\":%{public}u}"
- "{\"msg%{public}.0s\":\"Activity runner: starting activty\", \"Activity\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Added a client for Milo prediction event updates\"}"
- "{\"msg%{public}.0s\":\"Adding Low Latency policy to trigger manager\", \"\":%{private, location:escape_only}s, \"Success\":%{private}hhd}"
- "{\"msg%{public}.0s\":\"Adding a client for MiLo connection event updates failed, a client with same connection token exists\"}"
- "{\"msg%{public}.0s\":\"Adding ratios to trigger analytics if appropriate\", \"TriggerThreshold\":%{public}d, \"TotalLegacyLocalizations\":%{public}lu, \"TotalMotionLocalizations\":%{public}lu, \"TotalNewLocalizations\":%{public}lu}"
- "{\"msg%{public}.0s\":\"All services released their models and shared_ptr count is more than expected\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Already monitoring App In Focus events\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Already monitoring Now Playing events\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Analytics events for learning\", \"model type\":%{public, location:escape_only}s, \"enabled\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"Assertion failed, no current transaction when recording an event\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Assertion failed, no current transaction when recording batch of measurementWrappers\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Assigning a negative value to an unsigned type is probably not what you intended\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Attempting to apply truth label for a currently running localization\", \"TriggerUUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"BLE Scan duration\", \"duration\":\"%{public}.5f\"}"
- "{\"msg%{public}.0s\":\"BLE cached scan\", \"rssi\":%{private}d, \"uuid\":%{private, location:escape_only}s, \"model\":%{private, location:escape_only}s, \"time_s\":\"%{public}.09f\"}"
- "{\"msg%{public}.0s\":\"Ble Beacon Received\", \"IDS ID\":%{private, location:escape_only}s, \"BT identifier\":%{private, location:escape_only}s, \"Model\":%{private, location:escape_only}s, \"is device nearbyInfo or nearbyAction type?\":%{private}hhd, \"is device same account?\":%{private}hhd, \"is device cloud paired?\":%{private}hhd, \"AdvertisementTimestamp\":\"%{public}.3f\", \"RSSI\":%{public}d}"
- "{\"msg%{public}.0s\":\"Ble requested scan timeout but the session state is not running\", \"fBleSessionStatusRequested\":%{public}u}"
- "{\"msg%{public}.0s\":\"BleNonLeechingBackgroundScanEnabled is disabled\"}"
- "{\"msg%{public}.0s\":\"CBDiscovery leeching not supported activated successfully\"}"
- "{\"msg%{public}.0s\":\"CBDiscovery leeching supported activated successfully\"}"
- "{\"msg%{public}.0s\":\"CBDiscovery, Starting BLE scan timer\", \"now\":\"%{public}.3f\", \"durationInMs\":%{public}lld, \"expected end time\":\"%{public}.3f\"}"
- "{\"msg%{public}.0s\":\"CBDiscovery, a BLE session timer stopped\", \"now\":\"%{public}.3f\"}"
- "{\"msg%{public}.0s\":\"CFType must be a CFArrayRef to convert to a const char*\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CFType must be a CFBoolean to convert to a bool\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CFType must be a CFNumber to convert to a double\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CFType must be a CFNumber to convert to an int\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMiLoService label observation request Between dates: \", \"ServiceId\":%{public, location:escape_only}s, \"ServiceType\":%{public}lu, \"RequestId\":%{public, location:escape_only}s, \"PlaceId\":%{public, location:escape_only}s, \"State\":%{public}u, \"Success\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"CLMiLoService label observation request: \", \"ServiceId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s, \"PlaceId\":%{public, location:escape_only}s, \"State\":%{public}u, \"Success\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"CLMiLoService received localization results with unexpected / unmatching ID\", \"ServiceId\":%{public, location:escape_only}s, \"Expected localization ID\":%{public, location:escape_only}s, \"Received trigger ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMiLoService received localization results, reporting to client with service updating params\", \"ServiceId\":%{public, location:escape_only}s, \"LocalizationId\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMiLoService received localization results, sending results to client: \", \"ServiceId\":%{public, location:escape_only}s, \"LocalizationId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMiLoService received observation request: \", \"ServiceId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s, \"PlaceId\":%{public, location:escape_only}s, \"State\":%{public}u, \"Success\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"CLMiLoService received prediction request: \", \"ServiceId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s, \"LocalizationId\":%{public, location:escape_only}s, \"State\":%{public}u, \"force verdict\":%{public}hhd, \"isForcedRequest\":%{public}hhd, \"Is low latency\":%{public}hhd, \"Has valid cache\":%{public}hhd, \"Success\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"CLMiLoService received recording stop: \", \"ServiceId\":%{public, location:escape_only}s, \"Success\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"CLMiLoService reject prediction request because other request in progress\", \"LocalizationId\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMiLoService releasing observation requsts: \", \"ServiceId\":%{public, location:escape_only}s, \"NumRequests\":%{public}hhd, \"Success\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"CLMiLoService releasing prediction requsts: \", \"ServiceId\":%{public, location:escape_only}s, \"NumRequests\":%{public}hhd, \"Success\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"CLMiLoService send status to client, MiLo Unavailable: \", \"ServiceId\":%{public, location:escape_only}s, \"State\":%{public}u, \"isMiLoEnabled\":%{public}hhd, \"isLowPowerMode\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"CLMiLoService send status to client: \", \"ServiceId\":%{public, location:escape_only}s, \"ClientId\":%{public, location:escape_only}s, \"Service Type\":%{public}u, \"State\":%{public, location:escape_only}s, \"Suspend Reasons\":%{public, location:escape_only}s, \"Quality\":%{public, location:escape_only}s, \"Quality Reasons\":%{public, location:escape_only}s, \"Current LOI ID\":%{private, location:escape_only}s, \"Current LOI Type\":%{private, location:escape_only}s, \"Updates Status:\":%{public, location:escape_only}s, \"Number of clusters learned in model\":%{public}u, \"Number of Recording triggers at current LOI\":%{public}u, \"Number of Input Valid Fingerprints\":%{public}u, \"Number of Input Valid Fingerprints Labeled\":%{public}u, \"Number of Input Valid Fingerprints Unlabeled\":%{public}u, \"Number of Fingerprints Before Pruning\":%{public}u, \"Number of Fingerprints After Pruning\":%{public}u, \"Number of WiFi Access Points\":%{public}u, \"Number of Ble Sources\":%{public}u, \"Number of Uwb Sources\":%{public}u}"
- "{\"msg%{public}.0s\":\"CLMiLoService sending cached results to client: \", \"ServiceId\":%{public, location:escape_only}s, \"ClientId\":%{public, location:escape_only}s, \"Cached LocalizationId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s, \"Succeeded to save trigger\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"CLMiLoService sending initial empty prediction to BlueAtlas client: \", \"ServiceId\":%{public, location:escape_only}s, \"ClientId\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMiLoService sending invalid confidence empty results to client: \", \"ServiceId\":%{public, location:escape_only}s, \"ClientId\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMiLoService state changed to running: \", \"ServiceId\":%{public, location:escape_only}s, \"Previous state\":%{public}u}"
- "{\"msg%{public}.0s\":\"CLMiLoService state changed to suspended: \", \"ServiceId\":%{public, location:escape_only}s, \"Previous state\":%{public}u}"
- "{\"msg%{public}.0s\":\"CLMiLoService tried to send cached results to client but no cache available:\", \"ServiceId\":%{public, location:escape_only}s, \"ClientId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMiLoService::applyRecentLabelsToLSL, tried to apply a label which is already in the LSL\", \"LabelUUID\":%{public, location:escape_only}s, \"TriggerUUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMiLoService::onLearningCompleted send completion to client\", \"RequestId\":%{public, location:escape_only}s, \"Error Code\":%{public}ld}"
- "{\"msg%{public}.0s\":\"CLMiLoService::onLocalizationStart send event to client\"}"
- "{\"msg%{public}.0s\":\"CLMiLoService::requestMicroLocationLearning\", \"RequestId\":%{public, location:escape_only}s, \"Will Start\":%{public}hhd, \"State\":%{public}u, \"Error Code\":%{public}ld}"
- "{\"msg%{public}.0s\":\"CLMiLoServiceManager Client queried services\", \"ClientId\":%{public, location:escape_only}s, \"NumServicesFound\":%{public}llu}"
- "{\"msg%{public}.0s\":\"CLMiLoServiceManager Client query result\", \"ClientId\":%{public, location:escape_only}s, \"ServiceType\":%{public}llu, \"ServiceUuid\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMiLoServiceManager loaded model from DB:\", \"ClientId\":%{public, location:escape_only}s, \"ModelUuid\":%{public, location:escape_only}s, \"ModelType\":%{public}lld, \"LOI ID\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMiLoServiceManager releasing create custom LOI at current location requests: \", \"NumRequests\":%{public}hhd, \"Success\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"CLMiLoServiceManager::disconnect, failed because not authorized to disconnect from this service created by another user\", \"ServiceUUID\":%{private, location:escape_only}s, \"clientId\":%{private, location:escape_only}s, \"loadedServiceClientId\":%{private, location:escape_only}s, \"userId\":%{private, location:escape_only}s, \"loadedServiceUserId\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMiLoServiceManager::disconnect, failed because not authorized to disconnect from this service\", \"ServiceUUID\":%{private, location:escape_only}s, \"clientId\":%{private, location:escape_only}s, \"loadedServiceClientId\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMiLoServiceManager::disconnect, failed because not connected to this service\", \"ServiceUUID\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMiLoServiceManager::disconnect, releasing model and updating service time\"}"
- "{\"msg%{public}.0s\":\"CLMiLoServiceManager::findInstantModelForServiceOfTypeLSL, new LSL service looking for unsupervised model\", \"FoundModelType\":%{public, location:escape_only}s, \"ServiceId\":%{public, location:escape_only}s, \"OriginalUnsupervisedModelUUID\":%{public, location:escape_only}s, \"UsedModelUUID\":%{public, location:escape_only}s, \"AtLoi\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMiLoServiceManager::findInstantModelForServiceOfTypeLSL, new LSL service looking for unsupervised model\", \"FoundModelType\":%{public, location:escape_only}s, \"ServiceId\":%{public, location:escape_only}s, \"UsingModelOf\":%{public, location:escape_only}s, \"OriginalLSLModelUUID\":%{public, location:escape_only}s, \"UsedModelUUID\":%{public, location:escape_only}s, \"AtLoi\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMiLoServiceManager::isNewServiceAllowed\", \"ServiceType\":%{public}lu, \"Allowed\":%{public}lu, \"AlreadyCreated\":%{public}lu, \"Verdict\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"CLMiLoServiceManager::releaseModel, released model\", \"ServiceUUID\":%{private, location:escape_only}s, \"NumModelsBefore\":%{public}lu, \"NumModelsAfter\":%{public}lu}"
- "{\"msg%{public}.0s\":\"CLMiLoServiceManager::requestMicroLocationLearning\", \"serviceId\":%{public, location:escape_only}s, \"requestId\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMiLoServiceManager::triggerLearning\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationAnalytics, analyzeAssociationState\", \"rtGroupLoiId\":%{private, location:escape_only}s, \"rtLoiType\":%{public, location:escape_only}s, \"Band\":%{public}d, \"numberOfMacAddresses\":%{public}llu, \"NumberOfChannels\":%{public}llu, \"NumberOfMacAddressAppearingOnMultipleChannels\":%{public}llu}"
- "{\"msg%{public}.0s\":\"CLMicroLocationAnchorValueStatisticsMap, anchorAppearanceMap\", \"Size\":%{public}lu}"
- "{\"msg%{public}.0s\":\"CLMicroLocationAnchorValueStatisticsMap, measurement set\", \"Size\":%{public}lu}"
- "{\"msg%{public}.0s\":\"CLMicroLocationAnchorValueStatisticsMap, start analysis\", \"Num Clusters\":%{public}lu, \"Num Found Fingerprints\":%{public}lu}"
- "{\"msg%{public}.0s\":\"CLMicroLocationClientUtils, requireFingerprintsForTriggerUuids, no fingerprint created for TriggerUUID\", \"TriggerUUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMicroLocationClientUtils, requireFingerprintsForTriggerUuids, recording entries found for trigger uuids\", \"NumTriggerUUID\":%{public}lu, \"NumEntries\":%{public}lu}"
- "{\"msg%{public}.0s\":\"CLMicroLocationLegacyClient Service Status update\", \"isSuspended\":%{public}hhd, \"isReasonModelUnavailable\":%{public}hhd, \"isQualityReasonLowObservations\":%{public}hhd, \"service quality\":%{public}d}"
- "{\"msg%{public}.0s\":\"CLMicroLocationLegacyClient: tryCreateServiceAndConnect\", \"clientName\":%{public, location:escape_only}s, \"serviceType\":%{public}lld}"
- "{\"msg%{public}.0s\":\"CLMicroLocationLegacyClient: tryCreateServiceAndConnect: failed to connect\", \"errorId\":%{public}lld}"
- "{\"msg%{public}.0s\":\"CLMicroLocationLegacyClient: tryCreateServiceAndConnect: failed to create a new service\", \"errorId\":%{public}lld, \"descriptorHasValue\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"CLMicroLocationLegacyEventRecordingRequest: client request recording scan\", \"client\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMicroLocationLocalizationController, invalidateCache\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationLogic State\", \"enabled\":%{public}hhd, \"LOI Type\":%{private, location:escape_only}s, \"LOI ID\":%{private, location:escape_only}s, \"locationServicesEnabled\":%{public}hhd, \"significantLocationsEnabled\":%{public}hhd, \"ScanActivity\":%{private, location:escape_only}s, \"Localizing Counter\":%{public}d, \"Recording Counter\":%{public}d, \"displayOn\":%{public}hhd, \"isOnLockScreen\":%{public}hhd, \"isWiFiErrorRetryEnabled\":%{public}hhd, \"WiFi Error Retry Counter\":%{public}d, \"WiFi Error Retry Disabled Period Counter\":%{public}d, \"isLowNumberOfObservation\":%{public}hhd, \"isLowPowerMode\":%{public}hhd, \"isBluetoothDisabled\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"CLMicroLocationLogic, onAssociatedState event ignored - nil currentRtLoiId\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationLogic, onAssociatedState event\", \"currentRTLOIType\":%{private, location:escape_only}s, \"currentRtLoiId\":%{private, location:escape_only}s, \"IsAssociated\":%{public}hhd, \"MAC Address\":%{private, location:escape_only}s, \"Band\":%{public}lu, \"Channel\":%{public}d}"
- "{\"msg%{public}.0s\":\"CLMicroLocationLogic: client request donate truth label (time window based)\", \"client\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMicroLocationLogic: client request localization scan\", \"client\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMicroLocationLogic::deleteService\", \"clientId\":%{private, location:escape_only}s, \"userId\":%{private, location:escape_only}s, \"serviceId\":%{private, location:escape_only}s, \"result\":%{private}d}"
- "{\"msg%{public}.0s\":\"CLMicroLocationLogic:requestWifiScanExtension\", \"requirement for min num measurements met\":%{public}hhd, \"Num measurements\":%{public}lu, \"Minimum num of measurements for scan extension\":%{public}lu, \"requestedExtension\":%{public}lld, \"singleScanIncrement\":%{public}lld, \"remainingExtensions\":%{public}lu, \"extendDuration\":%{public}lld, \"scanActivity\":%{public, location:CLMicroLocationUtils::ScanActivity}lld}"
- "{\"msg%{public}.0s\":\"CLMicroLocationMotionBridge::startMotionSession\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationMotionBridge::stopMotionSession\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationNotifier, Rescheduled Localization Timer stopped\", \"now\":\"%{public}.3f\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationNotifier, Starting Rescheduled Localization Timer\", \"now\":\"%{public}.3f\", \"durationInMs\":%{public}lld, \"expected end time\":\"%{public}.3f\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationNotifier, Starting periodic Trigger Event Timer\", \"now\":\"%{public}.3f\", \"durationInMs\":%{public}lld, \"expected end time\":\"%{public}.3f\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationNotifier, periodic Trigger Event Timer stopped\", \"now\":\"%{public}.3f\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationNotifier::onAppLaunchEvent\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationNotifier::onClientManagerNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationNotifier::onDaemonStatusNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationNotifier::onDarwinNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationNotifier::onDataProtectionManagerNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationNotifier::onLocationNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationNotifier::onNotificationCenterNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationNotifier::onNowPlayingEvent\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationNotifier::onNowPlayingQueryResult\", \"Number of events\":%{public}d}"
- "{\"msg%{public}.0s\":\"CLMicroLocationRecorder: adding label for recording event\", \"Recording UUID\":%{public, location:escape_only}s, \"Trigger UUID\":%{public, location:escape_only}s, \"Label UUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMicroLocationRecorder: commiting recording transaction\", \"Recording UUID\":%{public, location:escape_only}s, \"Num records\":%{public}lu, \"Num measurements\":%{public}lu}"
- "{\"msg%{public}.0s\":\"CLMicroLocationRecorder: received invalid truth label\", \"Client\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMicroLocationRecorder: record TruthLabel between dates\", \"Num Matching Events\":%{public}lu, \"Is Recorder Active\":%{public}hhd, \"Insertion Result\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"CLMicroLocationSensorsDriver, stop wifi scan\", \"now\":\"%{public}.3f\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationSensorsLogic::getBleMeasurements, fState.fStartTime is nullopt!\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationSensorsLogic::getUwbMeasurements, fState.fStartTime is nullopt!\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationSensorsLogic::requestWiFiScan, fState.fStartTime is nullopt!\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - invalid LabelUuid conversion!\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - invalid clusterUuid conversion!\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - number of probabilities should match number of clusters\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - size of confidences doesn't equal event number, setting all event's confidence to invalid\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf\", \"listElementInx\":%{public}d, \"event label\":%{public, location:escape_only}s, \"confidence level\":%{public}d}"
- "{\"msg%{public}.0s\":\"CLMicroLocationStopMotionDetectionBridge CTOR, setting is off so object did not initialize\", \"Stop detection enabled\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"CLMicroLocationStopMotionDetectionBridge CTOR, wrong configuration, object did not initialize\", \"Stop detection enabled\":%{public}hhd, \"Num Radiuses\":%{public}lu, \"Num Timeouts\":%{public}lu}"
- "{\"msg%{public}.0s\":\"CLMicroLocationTriggerManager: Reschedule trigger\", \"triggerTS\":\"%{public}.3f\", \"fLastTriggerTS\":\"%{public}.3f\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationTriggerManager: Wait For Display On\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationTriggerManager: get delayed trigger timeout, awaiting display on\"}"
- "{\"msg%{public}.0s\":\"CLMicroLocationTriggerManager: requestLocalization\", \"isForce\":%{public}hhd, \"isInMotionTrigger\":%{public}hhd, \"TriggerReason\":%{public}lu}"
- "{\"msg%{public}.0s\":\"CLMicroLocationTriggerManager: setSpectatingEnabled\", \"spectatingEnabled\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMicroLocationTriggerManager: shouldReject\", \"spectatingDiabled\":%{public}hhd, \"isRecordingRequestDuringWaitForRescheduledTrigger\":%{public}hhd, \"macTriggerThrottle\":%{public}hhd, \"result\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"CLMicroLocationTriggerManager: stopTrigger\", \"Reason\":%{public}d}"
- "{\"msg%{public}.0s\":\"CLMicroLocationTriggerManager::requestMotion - setting fence\", \"onlyIfNotRunning\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"CLMicroLocationTriggerManager::requestMotion, denied requestMotion\", \"Mode\":%{public, location:escape_only}s, \"isLowLatencyPolicyAvailable\":%{public}hhd, \"PedestrianFenceWhenSpectatingEnabled\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"CLMicroLocationTriggerManager::startTrigger\", \"TriggerUUID\":%{public, location:escape_only}s, \"ScanActivity\":%{public, location:escape_only}s, \"isInMotionTrigger\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"CLMicroLocationTriggerManager::startTrigger, setting medium confidence due to motion\"}"
- "{\"msg%{public}.0s\":\"CLWifiScanner::onWifiNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}"
- "{\"msg%{public}.0s\":\"Calculated microLocation motion spectating duration\", \"startTime\":%{public, location:escape_only}s, \"stopTime\":%{public, location:escape_only}s, \"duration (hours)\":\"%{private}5f\"}"
- "{\"msg%{public}.0s\":\"Calculated microLocation spectating duration\", \"startTime\":%{public, location:escape_only}s, \"stopTime\":%{public, location:escape_only}s, \"duration (hours)\":\"%{private}5f\"}"
- "{\"msg%{public}.0s\":\"Can't clear current activity as it is already invalid\", \"currentActivity\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Can't find a model type that corresponds to string\", \"string\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Can't set new activity\", \"currentActivity\":%{public, location:escape_only}s, \"providedNextActivity\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Cannot localize on invalid model!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Checking if should migrate from backup\", \"result\":%{public}hhd, \"numMainDBRecordingEvents\":%{public}d, \"numMainDBMeasurements\":%{public}d, \"numMainDBServices\":%{public}d, \"restoreDbExists\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"ClusterAnchorValueStatistics feature is not enabled in setting, won't fetch data from DB\"}"
- "{\"msg%{public}.0s\":\"ClusterAnchorValueStatistics loaded for model\", \"ModelUUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Configuration generated\", \"ModelType\":%{public}lu, \"Inserted\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"Connect to service without connectionToken\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Connect to service without identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, confidence vector size not equal to prob matrix row number!\", \"confidence vector size\":%{public}lu, \"number of prob matrix rows\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, error normalizing currentLocalizationVec!\"}"
- "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, internalLocalizer result\", \"MicrolocationId\":%{private, location:escape_only}s, \"Probability\":\"%{private}.6f\", \"ConfidenceLevel\":%{private}lu}"
- "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, internalLocalizer results\", \"numInternalResults\":%{public}lu}"
- "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, model type is not similarity list!\", \"Model Type\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, model with empty LSL, publishing empty results\"}"
- "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, multByVec failed!\"}"
- "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, running localization\", \"LSL Length\":%{public}lu, \"LSL Num Clusters\":%{public}lu}"
- "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, setting invalid confidence due to high null cluster probability\", \"nullClusterProbability\":\"%{private}.6f\"}"
- "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, unexpected identifier\", \"cluster ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Couldn't find key: \", \"key\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Couldn't find key: onesided_jaccard\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Create service - No error code but response descriptor not available \", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Creating analytics event.\", \"Event name\":%{public, location:escape_only}s, \"LOI Group ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Creating analytics event.\", \"Event name\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Delete Olders rows in service table. Should never be here!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Delete service - No error code but response descriptor not available \", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Delete service without identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Detection threshold must be: 0 < THR < 1.0!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Device lost\", \"device:\":%{public, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"Did not find matching entry for cached trigger UUID\", \"Cached trigger UUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Did not receive status report for active fence\", \"Status report\":%{public, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"Disabling Low Latency updates if exist for Service:\", \"ServiceId\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Disconnect from service without identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Does not support appending new events to a transposed matrix!\"}"
- "{\"msg%{public}.0s\":\"Duty cycle is NaN\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Duty cycle percentage should be between 0 and 1\", \"dutyCycle\":\"%{private}f\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Enabling Legacy updates for Service:\", \"ServiceId\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Enabling Low Latency updates for Service:\", \"ServiceId\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Error converting uint to location types: Value does not fit into bitset\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Error, localization probabilities were not sorted in descending order\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Error: Unable to export MicroLocation DB - local DB is not ready!\"}"
- "{\"msg%{public}.0s\":\"Executing migration query\", \"Query: \":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Expecting a wifi channel histogram\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Expecting some UUIDs to be passed in\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Expecting some clientIDs to be passed in\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Expecting valid LOI Group ID to be passed in\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Export DB requests are served in internal builds only!\"}"
- "{\"msg%{public}.0s\":\"Exporting table using paging\", \"table\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Failed to get a long value for key\", \"key\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Fingerprint creation\", \"NumWiFiMeasurements\":%{public}lu, \"NumBLEMeasurements\":%{public}lu, \"NumUWBMeasurements\":%{public}lu, \"number of total measurements\":%{public}lu, \"WiFi RSSI duration_s\":\"%{public}.09f\", \"enough WiFi measurements\":%{public}hhd, \"enough total measurements\":%{public}hhd, \"isDurationValid\":%{public}hhd, \"isFingerprintValid\":%{public}hhd, \"BLE Duration_s\":\"%{public}.09f\", \"UWB Duration_s\":\"%{public}.09f\"}"
- "{\"msg%{public}.0s\":\"Found too many matching entries for cached trigger UUID\", \"Cached trigger UUID\":%{public, location:escape_only}s, \"Number of matches\":%{public}lu}"
- "{\"msg%{public}.0s\":\"Generating anchor appearance maps\", \"LOI count\":%{public}ld}"
- "{\"msg%{public}.0s\":\"Got request to reset semi-supervised model related data for\", \"clientIdentifier\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"HomeKit Accessory\", \"accessoryUUID\":%{private, location:escape_only}s, \"accessoryState\":%{private, location:escape_only}s, \"serviceUUID\":%{private, location:escape_only}s, \"serviceGroupUUID\":%{private, location:escape_only}s, \"serviceType\":%{private, location:escape_only}s, \"characteristicType\":%{private, location:escape_only}s, \"source\":%{private, location:escape_only}s, \"roomUUID\":%{private, location:escape_only}s, \"triggerLocalization\":%{private}hhd, \"triggerRecording\":%{private}hhd}"
- "{\"msg%{public}.0s\":\"HomeKit Scene\", \"actionSetUUID\":%{private, location:escape_only}s, \"actionSetName\":%{private, location:escape_only}s, \"actionSetType\":%{private, location:escape_only}s, \"clientName\":%{private, location:escape_only}s, \"source\":%{private, location:escape_only}s, \"homeName\":%{private, location:escape_only}s, \"triggerLocalization\":%{private}hhd, \"triggerRecording\":%{private}hhd}"
- "{\"msg%{public}.0s\":\"If run state is runnimg then suspend reason must be empty\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"If run state is suspended then suspend reason cannot be empty\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Ingested UWB range measurement\", \"range\":\"%{public}.3f\", \"device ID\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Inserted Similarity list Model\", \"ClientIdAndServiceUuid\":%{public, location:escape_only}s, \"ModelUuid\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Invalid Address data\", \"address\":%{public, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"Invalid MiLo current activity\", \"state\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Invalid algorithm chosen\", \"enum value\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Invalid localization algorithm! No localization done\", \"Localization Algo\":%{public}lu}"
- "{\"msg%{public}.0s\":\"Invalid model index\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Invalid scan activity on timer stop, state: NotSet\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Invalid scan activity\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Invalid type chosen\", \"enum value\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"LOI Bridge, Failed To fetch place inferences\", \"Error:\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"LOI Manager, Adding new service to list of servies that have requested to enable custom LOI\", \"LOI ID\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"LOI Manager, Attempting to fetch place inference\", \"Reason:\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"LOI Manager, Failed To request LOI for current visit location\"}"
- "{\"msg%{public}.0s\":\"LOI Manager, Fetched LOI Group ID\", \"LOI Group ID \":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"LOI Manager, Got Geofence update\", \"Geofence Id\":%{private, location:escape_only}s, \"State\":%{private}d}"
- "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"LOI Manager, Got invalid geofence ID\", \"Geofence Id\":%{private, location:escape_only}s, \"State\":%{private}d}"
- "{\"msg%{public}.0s\":\"LOI Manager, Retrieved location of interest\", \"LOI ID\":%{private, location:escape_only}@, \"LOI TYPE\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"LOI Manager, Retrieved place infernce\", \"LOI ID\":%{private, location:escape_only}s, \"LOI TYPE\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"LOI Manager, received nil LOI Identifier from place inference, possibly because there is no active user on macOS, we will start leeching and wait for next location update\"}"
- "{\"msg%{public}.0s\":\"LOI Manager, refreshing location on XPC trigger\"}"
- "{\"msg%{public}.0s\":\"LOI Manager: handle leeched location notification\"}"
- "{\"msg%{public}.0s\":\"LOI Manager: handleVisitEntry\"}"
- "{\"msg%{public}.0s\":\"LOI Manager: handleVisitExit\"}"
- "{\"msg%{public}.0s\":\"LOI usage analytics canceled\", \"Activity\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"LOIs for LOI Group Id\", \"LOI Group ID\":%{public, location:escape_only}s, \"LOI IDs\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Learning Unsupervised Model for client\", \"Client ID\":%{public, location:escape_only}s, \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Learning Unsupervised Model for clients\", \"Num Clients\":%{public}lu}"
- "{\"msg%{public}.0s\":\"Learning binary model cancelled\"}"
- "{\"msg%{public}.0s\":\"Learning semi-supervised model cancelled\"}"
- "{\"msg%{public}.0s\":\"Learning semi-supervised model with BinaryRoi generation algorithm\", \"Client\":%{public, location:escape_only}s, \"Number of labeled recording triggers\":%{public}lu, \"Number of unlabeled recording triggers\":%{public}lu}"
- "{\"msg%{public}.0s\":\"Learning semi-supervised model with SelfTraining generation algorithm\", \"Client\":%{public, location:escape_only}s, \"Number of labeled recording triggers\":%{public}lu, \"Number of unlabeled recording triggers\":%{public}lu}"
- "{\"msg%{public}.0s\":\"Learning started\", \"modelType\":%{public}d, \"algorithmType\":%{public}d, \"numModelIters\":%{public}d, \"numRecordingTriggers\":%{public}lu}"
- "{\"msg%{public}.0s\":\"Learning, completed\", \"model-type\":%{public}lu, \"Total Time (sec)\":\"%{public}.4f\"}"
- "{\"msg%{public}.0s\":\"Legacy client Publishing focusMode localization results to Biome\"}"
- "{\"msg%{public}.0s\":\"Legacy client Publishing unsupervised localization results to Biome\"}"
- "{\"msg%{public}.0s\":\"Loaded model doesn't have model quality, calculate on the fly\", \"QualityIndicator\":%{public}d}"
- "{\"msg%{public}.0s\":\"LocalizationController test fingerprint was not created\", \"ModelType\":%{public}lu}"
- "{\"msg%{public}.0s\":\"LocalizationController, Requested stop for localization request\", \"Request ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"LocalizationController, Requested stop for non-existent localization request\", \"Request ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"LocalizationController, start localization request\", \"Request ID\":%{public, location:escape_only}s, \"Event Type\":%{public}lu}"
- "{\"msg%{public}.0s\":\"LocalizationController: ignored sensors\", \"isBleIgnore\":%{public}d, \"isNiIgnore\":%{public}d}"
- "{\"msg%{public}.0s\":\"LocalizationRequest::setConfidenceAndReasons\", \"RequestID\":%{public, location:escape_only}s, \"Confidence Levels and Reasons\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"LocalizationRequest::setConfidenceAndReasons, invalid arguments\", \"confidenceLevelsSize\":%{public}lu, \"confidenceReasonsSize\":%{public}lu}"
- "{\"msg%{public}.0s\":\"Localizer results, cluster\", \"microLocationId\":%{private, location:escape_only}s, \"probability\":\"%{private}.6f\", \"clientIdentifier\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Localizer results, model\", \"isStable\":%{private, location:escape_only}s, \"clientIdentifier\":%{private, location:escape_only}s, \"serviceUUID\":%{private, location:escape_only}s, \"requestId\":%{private, location:escape_only}s, \"numberOfMicroLocations\":%{private}lu}"
- "{\"msg%{public}.0s\":\"Localizer returned empty results when learning semi-supervised model\", \"RecordingUUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Logic, onAssociatedStateChange\", \"state\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"MiLo must be enabled\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"MiLoServiceManager Client tried to create service, failed since not allowed\", \"ClientId\":%{public, location:escape_only}s, \"ServiceType\":%{public}llu, \"NumIdenticalServices\":%{public}llu}"
- "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service because client's user mismatched with service\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ExpectedClientId\":%{public, location:escape_only}s, \"UserID\":%{public, location:escape_only}s, \"ExpectedUserID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service since client has maxed out number of connections\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ServiceType\":%{public}lu}"
- "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service since client unauthorised to connect\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ExpectedClientId\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service since database is not available\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service since service already has active connection\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service since service not found in database\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"MiLoServiceManager cannot create service since database is not available\", \"ClientId\":%{public, location:escape_only}s, \"ServiceType\":%{public}llu}"
- "{\"msg%{public}.0s\":\"MiLoServiceManager client connected to service\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ServiceType\":%{public}lu, \"NumberOfConnectionsToServiceType\":%{public}lu}"
- "{\"msg%{public}.0s\":\"MiLoServiceManager connection parameters: \", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"UserID\":%{public, location:escape_only}s, \"connectionToken\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"MiLoServiceManager new service created for client\", \"ClientId\":%{public, location:escape_only}s, \"UserId\":%{public, location:escape_only}s, \"ServiceType\":%{public}llu, \"ServiceUuid\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"MiLoServiceManager, failed to insert to fServiceIdToConnectionIdMap\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ConnectionToken\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"MicroLocation DB Tables exported\", \"path\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"MicroLocation DB Tables not exported\"}"
- "{\"msg%{public}.0s\":\"MicroLocation Internal Version request\", \"version\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"MicroLocation adapter requestExportMiLoDatabaseTablesFromClient\"}"
- "{\"msg%{public}.0s\":\"MicroLocation adapter requestMicroLocationLearningForClient\"}"
- "{\"msg%{public}.0s\":\"MicroLocation adapter requestPurgeAllMiLoData\"}"
- "{\"msg%{public}.0s\":\"Microlocation export restored backup for migration\", \"result\":%{private}hhd, \"duration [s]\":\"%{private}f\", \"restore file size [B]\":%{private}ld}"
- "{\"msg%{public}.0s\":\"Microlocation model learned\", \"numFingerprints before pruning\":%{public}lu, \"numFingerprints after pruning\":%{public}lu, \"numClusters\":%{public}lu, \"type\":%{public}d, \"numAnchors\":%{public}lu, \"Number of Recording triggers at current LOI\":%{public}u, \"Number of Input Valid Fingerprints\":%{public}u, \"Number of Input Valid Fingerprints Labeled\":%{public}u, \"Number of Input Valid Fingerprints Unlabeled\":%{public}d, \"Number of WiFi Access Points\":%{public}u, \"Number of Ble Sources\":%{public}u, \"Number of Uwb Sources\":%{public}u}"
- "{\"msg%{public}.0s\":\"Microlocation model learned\", \"numFingerprints before pruning\":%{public}lu, \"numFingerprints after pruning\":%{public}lu, \"numClusters\":%{public}lu, \"type\":%{public}d, \"numAnchors\":%{public}lu, \"Number of Recording triggers at current LOI\":%{public}u, \"Number of Input Valid Fingerprints\":%{public}u, \"Number of Input Valid Fingerprints Labeled\":%{public}u, \"Number of Input Valid Fingerprints Unlabeled\":%{public}u, \"Number of WiFi Access Points\":%{public}u, \"Number of Ble Sources\":%{public}u, \"Number of Uwb Sources\":%{public}u}"
- "{\"msg%{public}.0s\":\"Microlocation: createInUniverse\", \"Microlocation Version\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Missing key kSettingsNullSpaceNotRoiPercentile\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Missing key kSettingsNullSpaceRoiPercentile\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Model get prediction classes unknown model type\", \"modelType\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Model updated: \", \"ServiceId\":%{public, location:escape_only}s, \"ModelId\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"MotionSM::transitionLogic\", \"event\":%{public, location:escape_only}s, \"prevState\":%{public, location:escape_only}s, \"currState\":%{public, location:escape_only}s, \"startInMotion\":%{public}hhd, \"ongoingInMotion\":%{public}hhd, \"stopMotion\":%{public}hhd, \"resumeInMotion\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"MotionSM::transitionLogicGeofence, shouldn't receive StopMotion at Geofence state\"}"
- "{\"msg%{public}.0s\":\"MotionSM::transitionLogicIdle, shouldn't receive FenceCross at Idle state\"}"
- "{\"msg%{public}.0s\":\"MotionSM::transitionLogicIdle, shouldn't receive StopMotion at Idle state\"}"
- "{\"msg%{public}.0s\":\"MotionSM::transitionLogicStopDetection, shouldn't receive ScreenOn at StopDetection state\"}"
- "{\"msg%{public}.0s\":\"MotionSM::transitionLogicStopDetection, shouldn't receive SetFence at StopDetection state\"}"
- "{\"msg%{public}.0s\":\"MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive FenceCross at PendingResumeStopDetection state\"}"
- "{\"msg%{public}.0s\":\"MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive ScreenOff at PendingResumeStopDetection state\"}"
- "{\"msg%{public}.0s\":\"MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive SetFence at PendingResumeStopDetection state\"}"
- "{\"msg%{public}.0s\":\"MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive StopMotion at PendingResumeStopDetection state\"}"
- "{\"msg%{public}.0s\":\"Must contain valid scan activity\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"No LOI entries for specified LOI Group ID\", \"LOIGroupId\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"No SPI responses cached for learning completion\"}"
- "{\"msg%{public}.0s\":\"No SPI responses cached for recording/localization completion\"}"
- "{\"msg%{public}.0s\":\"No ble provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"No e2j_kernel_thr provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"No event types passed in\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"No jaccard_scale_factor provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"No jaccard_threshold provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"No per_source_params provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"No power provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"No sigma provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"No tanimoto_base provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"No type provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"No uwb provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"No wifi provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Not allowed to switch to new LOI\", \"Current LOI ID\":%{private, location:escape_only}s, \"Current LOI Type\":%{private, location:escape_only}s, \"New LOI ID\":%{private, location:escape_only}s, \"New LOI Type\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Not publishing to Legacy client\", \"because test FP is invalid\":%{public}hhd, \"because probability vector is empty\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"Notifier about to send create service response\", \"connectionToken\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Notifier about to send delete service response\", \"connectionToken\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Notifier about to send query milo connections status response\", \"connectionToken\":%{private, location:escape_only}s, \"connectionState\":%{public}d}"
- "{\"msg%{public}.0s\":\"Notifier about to send query service response\", \"connectionToken\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Notifier adding a client for Milo connection event updates\", \"connectionToken\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Notifier removed a client for Milo connection event updates\", \"connectionToken\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Optional Model must have value here\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Post-Pruning Model\", \"ClusterId\":%{public, location:escape_only}s, \"numFPs\":%{public}lu}"
- "{\"msg%{public}.0s\":\"Pre-Pruning Model\", \"ClusterId\":%{public, location:escape_only}s, \"numFPs\":%{public}lu}"
- "{\"msg%{public}.0s\":\"Previous anchor appearance not found for LOI ID. Using anchor appearance map for null uuid and loi type\", \"loi id\":%{public, location:escape_only}s, \"loi type\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"ProbabilityMatrix::normalizeRows, row with zero norm!\", \"RowIndex\":%{public}d}"
- "{\"msg%{public}.0s\":\"Rapport, back up rapport monitor data to DB\", \"Num Entries\":%{public}lu}"
- "{\"msg%{public}.0s\":\"Rapport, buffered a found device\", \"Device IDS identifier\":%{private, location:escape_only}s, \"Device name\":%{private, location:escape_only}s, \"CoreRoutine LOI Type\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Rapport, onRapportDeviceFound - rapport session device found is nil\"}"
- "{\"msg%{public}.0s\":\"Rapport, onRapportDeviceFound\", \"error\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Rapport, onRapportDeviceFound\", \"name\":%{private, location:escape_only}s, \"idsDeviceIdentifier\":%{private, location:escape_only}s, \"model\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Rapport, onRapportDeviceFound\", \"note\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Rapport, rapport monitor buffered bad IDS UUID\", \"IDS\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Rapport, rapport monitor exceeded max entries\", \"IDS\":%{private, location:escape_only}s, \"Size\":%{private}lu}"
- "{\"msg%{public}.0s\":\"Rapport, rapport monitor read bad IDS UUID from DB\"}"
- "{\"msg%{public}.0s\":\"Rapport, rapport session ready to listen for incoming devices\"}"
- "{\"msg%{public}.0s\":\"Rapport, setRapportSessionRunning\", \"session set to\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"RapportMonitor getDevicesSinceLearnEventTimeAtLoi\", \"Backup Entries\":%{public}lu, \"From time\":%{public, location:escape_only}s, \"LOI type\":%{public, location:escape_only}s, \"LOI id\":%{public, location:escape_only}s, \"Total number of devices\":%{public}lu}"
- "{\"msg%{public}.0s\":\"Received link status notification\", \"associatedState\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s, \"clientIdentifier\":%{private, location:escape_only}s, \"truthLabelUUID\":%{public, location:escape_only}s, \"triggerUUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s, \"clientIdentifier\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s, \"is enabled\":%{private}hhd}"
- "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s, \"is on\":%{private}hhd}"
- "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s, \"is restricted\":%{private}hhd}"
- "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s, \"truthLabelUUID\":%{public, location:escape_only}s, \"startDate\":%{public, location:escape_only}s, \"endDate\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Received notification\", \"source\":%{public, location:escape_only}s, \"trigger\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Received status report for active fence\", \"Status report\":%{public, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Received valid scan results, clearing WiFi scan error state\", \"number of APs in scan buffer\":%{public}llu}"
- "{\"msg%{public}.0s\":\"Relying on previous anchor appearance map from configuration table\", \"loiGroupId\":%{public, location:escape_only}s, \"timestamp\":%{public}d}"
- "{\"msg%{public}.0s\":\"Requested remove confidence reason for non-existent localization request\", \"Request ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Requested set Ignore Ble Rssi Measurements for non-existent localization request\", \"Request ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Requested set Ignore Uwb Range Measurements for non-existent localization request\", \"Request ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Requested to remove confidence reason for motion for non-existent localization request\", \"Request ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Restored iCloud Backup database tables contents\", \"numRecordingEventsEntries\":%{private}d, \"numMeasurementsEntries\":%{private}d, \"numConfigurationEntries\":%{private}d, \"numLoiEntries\":%{private}d}"
- "{\"msg%{public}.0s\":\"RowId not expected as timestamp column\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Scan duration is exceeded threshold\", \"duration\":\"%{public}.5f\", \"threshold\":\"%{public}.5f\"}"
- "{\"msg%{public}.0s\":\"Scan strategy extends scan\", \"by duration (ms)\":%{public}lld}"
- "{\"msg%{public}.0s\":\"Semi-supervised model\", \"GenerationAlgorithm\":%{public}lu, \"Client\":%{private, location:escape_only}s, \"size\":%{private}lu, \"numClusters\":%{private}lu, \"type\":%{private}d}"
- "{\"msg%{public}.0s\":\"Sending CA event.\", \"name\":%{private, location:escape_only}s, \"event\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"Sending analytics event\", \"Event name\":%{public, location:escape_only}s, \"event\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"Sending analytics event.\", \"Event name\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Sending analytics events.\", \"Event name\":%{public, location:escape_only}s, \"Number of events\":%{public}lu}"
- "{\"msg%{public}.0s\":\"SensorDriver, Wifi scan timer stopped but but scanned AP requirements not met, extend timer\", \"by duration (ms)\":%{public}lld}"
- "{\"msg%{public}.0s\":\"SensorsDriver, received a BLE scan request but current scan activity is set\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"SensorsDriver, received cancel wifi scan when current scan activity is not set\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"SensorsDriver, received cancel wifi scan\", \"scan activity\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"SensorsDriver, uwb, set ranging rate\", \"rate\":%{public}d, \"duration\":\"%{public}f\"}"
- "{\"msg%{public}.0s\":\"SensorsLogic, WiFi scan extention due to backlight on\", \"backlightOnExtention_s\":\"%{public}.09f\"}"
- "{\"msg%{public}.0s\":\"SensorsLogic, WiFi scan starts\", \"Num Valid Buffered WiFi APs\":%{public}lu}"
- "{\"msg%{public}.0s\":\"SensorsLogic, back up BT identities data to DB\", \"Num Entries\":%{public}lu}"
- "{\"msg%{public}.0s\":\"SensorsLogic, loadBleIdentitiesFromDb\", \"num of entries loaded\":%{public}lu, \"Total number of identities in memory\":%{public}lu}"
- "{\"msg%{public}.0s\":\"SensorsLogic, shouldScanNearbyInfoV2\", \"should scan?\":%{public}hhd, \"num of entries in oObkey\":%{public}lu, \"is motion session running?\":%{public}lu}"
- "{\"msg%{public}.0s\":\"SensorsLogic, started activity\", \"ActivityType\":%{public, location:escape_only}s, \"recOrLocStartTime_s\":\"%{public}.09f\"}"
- "{\"msg%{public}.0s\":\"Service Type unsupported \", \"service type\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Set current LOI.\", \"type\":%{private, location:escape_only}s, \"id\":%{private, location:escape_only}s, \"reason\":%{private, location:escape_only}s, \"is spectating\":%{private}hhd}"
- "{\"msg%{public}.0s\":\"Setting all BLE measurements as ignored\", \"displayStateOff\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"Setting all UWB measurements as ignored\", \"NI session not resumed\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"Setting model number of days with recordings\", \"numDaysWithRecordings\":%{private}u}"
- "{\"msg%{public}.0s\":\"Should not be starting a recording in this state: NotSet\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Similarity List Model Learning, Localizer must not return empty results\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Similarity List Model Learning, error normalizing probability matrix\"}"
- "{\"msg%{public}.0s\":\"Similarity List Model Learning, generated LSL\", \"NumLabels\":%{private}lu, \"Client ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Similarity List Model Learning, labeled recording entry without trigger UUID\", \"Client Id\":%{public, location:escape_only}s, \"Recording UUID\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Similarity List Model Learning, learned without labeled fingerprints\", \"Client ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Similarity List Model Learning, no labeled recording triggers\", \"Client ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Similarity List Model Learning, unexpected identifier\", \"cluster ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Similarity List Model Learning, unexpectedly couldn't find LSL row for label identifier\", \"Label UUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Similarity List Model Learning, unsupervised model not created or is invalid so learning is skipped\"}"
- "{\"msg%{public}.0s\":\"Similarity List appended new events\", \"Num new Labels\":%{public}lu, \"Old LSL length\":%{public}lu, \"New LSL length\":%{public}lu}"
- "{\"msg%{public}.0s\":\"Similarity List appending new events, fail to append rows\"}"
- "{\"msg%{public}.0s\":\"Similarity List appending new events, fail to normalize rows\"}"
- "{\"msg%{public}.0s\":\"Similarity List appending new events, fail to remove nullspace column\"}"
- "{\"msg%{public}.0s\":\"Similarity List fail to append new event, unexpected identifier\", \"cluster ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"SimilarityListData, appendNewEvents, fingerprints size not equal labelUuids size!\", \"Num Fingerprints\":%{public}lu, \"Num Labels\":%{public}lu}"
- "{\"msg%{public}.0s\":\"State Machine: \", \"New State\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"State Machine: Entering new state\", \"New State\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"State Machine: Exiting State\", \"State\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"State Machine: Failed to handle event because current state is NULL\", \"Event\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"State Machine: Failed to handle event because it is not a valid event for the current state\", \"Event\":%{private, location:escape_only}s, \"Current State\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"State Machine: Failed to initialize state because requested state doesn't exist in the state table\", \"State\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"State Machine: Failed to switch to new state because requested state doesn't exist in the state table\", \"State\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"State Machine: Handling Event\", \"Event\":%{private, location:escape_only}s, \"Current State\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"State Machine: No state change requested\", \"State\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"State Machine: State did not have an entry function\", \"State\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"State Machine: State did not have an exit function\", \"State\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"StateBase\"}"
- "{\"msg%{public}.0s\":\"StopMotionDetectionBridge::onMotionMeasurements\", \"fenceId\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"StopMotionDetectionBridge::onTimerTimeout\", \"fenceIdStr\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"StopMotionDetectionBridge::ongoingTimerTimeout\"}"
- "{\"msg%{public}.0s\":\"TimeProfile\", \"action\":%{public, location:escape_only}s, \"durationSecs\":\"%{public}f\"}"
- "{\"msg%{public}.0s\":\"Trigger types analytics canceled\"}"
- "{\"msg%{public}.0s\":\"Trying to assign a value that is bigger than the provided type can hold\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"UWB Scan duration\", \"duration\":\"%{public}.5f\"}"
- "{\"msg%{public}.0s\":\"Unable to get the value from a CFNumber\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Unexpected generation algorithm for kMicroLocationSemisupervisedDomain!\", \"Generation Algorithm\":%{public}lu}"
- "{\"msg%{public}.0s\":\"Unsupported Service Type\", \"ServiceType\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Unsupported distance function type\", \"type\":%{public}u, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Unsupported reducer function\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Update model - got null pointer\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"Updating Anchor ID Set\", \"Num. Rapport Anchor Devices\":%{public}lu, \"Num Rapport and Measured Anchor Devices\":%{public}lu, \"Number of recordings since last model\":%{public}lu, \"Anchor Appearance Map size\":%{public}lu}"
- "{\"msg%{public}.0s\":\"Wifi AP received\", \"rssi\":%{private}d, \"mac\":%{private, location:escape_only}s, \"channel\":%{private}d}"
- "{\"msg%{public}.0s\":\"Wifi Channel Histogram analytics was not sent since not enough time elapsed\"}"
- "{\"msg%{public}.0s\":\"Wifi Channel Histogram generated successfully\"}"
- "{\"msg%{public}.0s\":\"Wifi Channel Histogram was not generated\"}"
- "{\"msg%{public}.0s\":\"Wifi channel histogram:\", \"Histogram\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"WifiBridge, RecordingExtended\", \"by durationInMs\":%{public}lld}"
- "{\"msg%{public}.0s\":\"WifiBridge, RecordingStarted\", \"now\":\"%{public}.3f\", \"durationInMs\":%{public}lld, \"expected end time\":\"%{public}.3f\"}"
- "{\"msg%{public}.0s\":\"WifiBridge, scan complete\", \"scanDurationInMs\":\"%{public}.4f\", \"scanActivity\":%{public}d}"
- "{\"msg%{public}.0s\":\"WifiBridge, shouldn't request scanner when scan activity is not set\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"WifiBridge, the wifi scan timer should have a nextFireTime when requesting scan duration extension\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"WifiBridge, wifi scan timer stopped\", \"now\":\"%{public}.3f\"}"
- "{\"msg%{public}.0s\":\"_CLDaemonGetMicroLocationInternalVersion\", \"event\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"_nsDataToBTAddressString\", \"address\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"adding a label to the LSL out of learning flow\", \"Trigger UUID\":%{public, location:escape_only}s, \"Label UUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"analyzeAssociationState cancelled\", \"Activity\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"analyzeAssociationState, loiGroupId without unique rtLoiType\", \"LoiGroupId\":%{public, location:escape_only}s, \"LoiTypes\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"analyzeAssociationState, no LOI IDs found\"}"
- "{\"msg%{public}.0s\":\"analyzing LOI usage\"}"
- "{\"msg%{public}.0s\":\"analyzing WiFi channels\"}"
- "{\"msg%{public}.0s\":\"analyzing associated state\"}"
- "{\"msg%{public}.0s\":\"analyzing daily trigger usage\"}"
- "{\"msg%{public}.0s\":\"anchor statistics map retrieved\"}"
- "{\"msg%{public}.0s\":\"anchor statistics\", \"clusterId\":%{private, location:escape_only}s, \"fingerprint UUID\":%{public, location:escape_only}s, \"dataType\":%{public}d, \"deviceId\":%{private, location:escape_only}s, \"measured value\":\"%{private}f\"}"
- "{\"msg%{public}.0s\":\"anchor statistics\", \"clusterId\":%{private, location:escape_only}s, \"fingerprint UUID\":%{public, location:escape_only}s, \"dataType\":%{public}d, \"deviceId\":%{private, location:escape_only}s, \"setinel value\":\"%{private}f\"}"
- "{\"msg%{public}.0s\":\"appendNewEvents, set value error\", \"row\":%{public}lu, \"col\":%{public}d, \"numRows\":%{public}d, \"numCols\":%{public}d}"
- "{\"msg%{public}.0s\":\"appending rows\", \"NumOldRows\":%{public}d, \"NumOldRowsToKeep\":%{public}d, \"NumRowsToAppend\":%{public}d}"
- "{\"msg%{public}.0s\":\"applyRecentChangesToModel, received invalid serviceType = CLMiLoServiceTypeMax\"}"
- "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, found labels from database to apply to LSL\", \"NumLabels\":%{public}lu, \"ClientID\":%{private, location:escape_only}s, \"ClientUUID\":%{private, location:escape_only}s, \"ModelUUID\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, model has no location similarity list\"}"
- "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, no current model\"}"
- "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, no label entries for model\"}"
- "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, no labels from database to apply to LSL\", \"ClientID\":%{private, location:escape_only}s, \"ClientUUID\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, number of LSL items\", \"after update\":%{public}lu}"
- "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, number of LSL items\", \"before update\":%{public}lu}"
- "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, per label info\", \"LabelUUID\":%{private, location:escape_only}s, \"TriggerUUID\":%{private, location:escape_only}s, \"validFingerprint\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"applying model with recent changes is not applicable\", \"Service Type\":%{public}lu}"
- "{\"msg%{public}.0s\":\"applying model with recent changes\", \"ServiceUUID\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"batterylevel\", \"level\":\"%{private}f\", \"charged\":%{private}d, \"connected\":%{private}d, \"chargerType\":%{private}d, \"wasConnected\":%{private}d, \"isNewlyConnected\":%{private}d}"
- "{\"msg%{public}.0s\":\"buffered a same icloud account BT identity\", \"BT uuid\":%{private, location:escape_only}s, \"Device name\":%{private, location:escape_only}s, \"Stable identifier\":%{private, location:escape_only}s, \"device model\":%{private, location:escape_only}s, \"Time stamp_s\":\"%{public}.09f\"}"
- "{\"msg%{public}.0s\":\"calcCachedLocalizationResults, didn't find model for requested service\", \"Service Uuid\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"calculatePerClusterPerAnchorValueStatistics (sentinel), received unhandled data type\", \"data type\":%{public}d}"
- "{\"msg%{public}.0s\":\"calculatePerClusterPerAnchorValueStatistics, received unhandled data type\", \"data type\":%{public}d}"
- "{\"msg%{public}.0s\":\"calling SPI responses after recording/localization completion\"}"
- "{\"msg%{public}.0s\":\"cannot append rows more rows than allowed\", \"MaxNumRows\":%{public}d, \"NumRowsToAppend\":%{public}d}"
- "{\"msg%{public}.0s\":\"cannot append rows with incompatible number of columns\", \"NumColumns\":%{public}d, \"OtherNumColumns\":%{public}d}"
- "{\"msg%{public}.0s\":\"client request learning but Microlocation is not enabled\"}"
- "{\"msg%{public}.0s\":\"client request, recording scan\", \"client\":%{public, location:escape_only}s, \"forced?\":%{public, location:escape_only}s, \"truth label\":%{private, location:escape_only}s, \"recording trigger UUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"cluster distance threshold must not be empty\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"configured e2jKernelThr illegal value\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"cosine similarity results shape\", \"Rows\":%{public}lu, \"Cols\":%{public}lu}"
- "{\"msg%{public}.0s\":\"couldn't find label entry of label\", \"LabelUUID\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"couldn't get most recent cluster anchor value statistics. either database is inaccessible or no model anchor cluster value statistics has been learnt yet\"}"
- "{\"msg%{public}.0s\":\"daily trigger analytics event was not created.\"}"
- "{\"msg%{public}.0s\":\"decided to reschedule a localization but not rescheduling because not spectating\"}"
- "{\"msg%{public}.0s\":\"deleting restore database file\", \"filename\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"dendrogram\", \"left\":%{public}lu, \"right\":%{public}lu, \"dist\":\"%{public}f\", \"size\":%{public}lu}"
- "{\"msg%{public}.0s\":\"device doesn't support suggestions so suppressing request\"}"
- "{\"msg%{public}.0s\":\"didn't find recording event matching to fingerprint\", \"RecordingUUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"displayState\", \"isDisplayOn\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"distanceThresholdVector must not be empty\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"dropping MiLo database tables\"}"
- "{\"msg%{public}.0s\":\"enable MiLo at current location called for a service which is not currently connected\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"enable MiLo at current location, called without connectionToken\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"enable MiLo at current location, called without requestId\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"enable MiLo at current location, called without service identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"enableMiLoAtCurrentLocation completed for service\", \"serviceId\":%{public, location:escape_only}s, \"requestId\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"enableMiLoAtCurrentLocation for service\", \"serviceId\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"evaluateQualityTreeBased\", \"Num fingerprints (post-pruning)\":%{public}lu, \"NumRobustWifiSources\":%{public}lu, \"NumWiFiSources\":%{public}u, \"NumBLESources\":%{public}u, \"NumUWBSources\":%{public}u, \"maxClusterRfDistance\":\"%{public}f\"}"
- "{\"msg%{public}.0s\":\"evaluateQualityWithNumFingerprints\", \"Num fingerprints (unpruned)\":%{public}lu, \"Has BLE\":%{public}hhd, \"Threshold\":%{public}lu}"
- "{\"msg%{public}.0s\":\"event not appended to similarity list, fingerprint not created!\", \"ServiceUUID\":%{private, location:escape_only}s, \"TriggerUUID\":%{public, location:escape_only}s, \"LabelUUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"executeStatement Failed. database object is invalid\", \"sqlStatement\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"executeStatement, Failed to create SQL statement\", \"sqlStatement\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"export using paging, table is missing\", \"TableName\":%{public, location:escape_only}s, \"ExistsInTargetDB\":%{public}hhd, \"ExistsInSourceDB\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"exporting db filterred for user\", \"UserID:\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"fLastTrigger is in the past\", \"triggerTS\":\"%{public}.3f\", \"fLastTriggerTS\":\"%{public}.3f\"}"
- "{\"msg%{public}.0s\":\"fSameAccountBleIdentities exceeded max entries\", \"Size\":%{private}lu}"
- "{\"msg%{public}.0s\":\"failed to copy MiLo database tables!\"}"
- "{\"msg%{public}.0s\":\"failed to create destination directory\", \"directory\":%{private, location:escape_only}s, \"error\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"failed to issue sandbox extension for file\", \"filename\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"failed to remove existing destination directory\", \"directory\":%{private, location:escape_only}s, \"error\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"failed to remove existing directory\", \"directory\":%{public, location:escape_only}s, \"error\":%{public, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"failed to remove file\", \"filepath\":%{private, location:escape_only}s, \"error\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"failed to set attributes for file\", \"filename\":%{private, location:escape_only}s, \"error\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"fake processing requestRemoveLabelsForClient\", \"clientId\":%{public, location:escape_only}s, \"serviceIdentifier\":%{public, location:escape_only}@, \"requestIdentifier\":%{public, location:escape_only}@, \"labels\":%{public, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"filterStaleWiFiMeasurementsForFingerprint\", \"num measurements before\":%{public}lu, \"num measurements after filter\":%{public}lu, \"Recording UUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"fingerprint distance type not supported\", \"type\":%{public}u, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"fingerprintVector must be non-empty\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"first service to connect to low-latency: invalidating caches\", \"ServiceUUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"generating anchor appearance map for LOI\", \"LOI Id\":%{public, location:escape_only}s, \"LOI Type\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"getClientLabelsAndLabeledRecordingEventsForLoi, labelEntries must be empty\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"getClientLabelsAndLabeledRecordingEventsForLoi, labeledRecordingEvents must be empty\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"getClusterLabels - don't split\", \"left\":%{public}lu, \"right\":%{public}lu, \"dist\":\"%{public}f\", \"size\":%{public}lu}"
- "{\"msg%{public}.0s\":\"getClusterLabels - split\", \"left\":%{public}lu, \"right\":%{public}lu, \"dist\":\"%{public}f\", \"size\":%{public}lu}"
- "{\"msg%{public}.0s\":\"getClusterLabels\", \"smallNodeSize\":%{public}lu, \"distanceThresholdForSmallNode\":\"%{public}f\", \"minNumClusters\":%{public}lu}"
- "{\"msg%{public}.0s\":\"got nullptr from CLMicroLocationProto add_anchorvaluestatistics\"}"
- "{\"msg%{public}.0s\":\"got nullptr from CLMicroLocationProto add_clusteranchorvaluestatisticsvector\"}"
- "{\"msg%{public}.0s\":\"got unexpected event type to indicate start/stop motion spectating\", \"event type\":%{public}lu}"
- "{\"msg%{public}.0s\":\"got unexpected event type to indicate start/stop spectating\", \"event type\":%{public}lu}"
- "{\"msg%{public}.0s\":\"handeling rescheduled localizations while localizing, shouldn't happen\"}"
- "{\"msg%{public}.0s\":\"handeling rescheduled localizations while recording, shouldn't happen\"}"
- "{\"msg%{public}.0s\":\"index out of bounds\", \"ii\":%{public}llu, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"initially requesting best possible update accuracy to find where we are\", \"duration\":%{public}d}"
- "{\"msg%{public}.0s\":\"internalToExternalServiceQuality\", \"qualityLevel\":%{public}d, \"candidateQualityLevel\":%{public}d}"
- "{\"msg%{public}.0s\":\"interrupting an ongoing localization\"}"
- "{\"msg%{public}.0s\":\"interrupting an ongoing recording\"}"
- "{\"msg%{public}.0s\":\"invalid connection token in disconnectToServiceForClient\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"invalid file protection class requested for the default CoreLocation Database\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"invalid generation algorithm\", \"generation algorithm\":%{public}lu}"
- "{\"msg%{public}.0s\":\"invalid model type\", \"model type\":%{public}lu}"
- "{\"msg%{public}.0s\":\"invalid\", \"localizer type\":%{public}lu}"
- "{\"msg%{public}.0s\":\"isStable, dendrogram, initialization\", \"isStableflag\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"isStable, fromProtobuf\", \"isStableFlag\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"isStable, getter\", \"numRecordingsBeforePruning\":%{public}ld, \"numDaysWithRecordings\":%{public}ld, \"fIsStable\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"isStable, toProtobuf\", \"isStableflag\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"issued a sandbox extension\", \"path\":%{private, location:escape_only}s, \"data\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"json string is invalid\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"learnBinaryModel, Must have valid labeled fingerprints\", \"ClientId\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"learnBinaryModel, Must have valid unlabeled fingerprints to create a Non-ROI cluster\", \"ClientId\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"learnBinaryModel, fingeprint assigned to NotROI\", \"Recording UUID\":%{public, location:escape_only}s, \"Cluster UUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"learnBinaryModel, invalid binary model, not created\"}"
- "{\"msg%{public}.0s\":\"learnBinaryModel, labeled fingeprint assigned to cluster\", \"Recording UUID\":%{public, location:escape_only}s, \"Cluster UUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"learnBinaryModel, labeledFingerprintVector\", \"numTriggers\":%{public}lu, \"numFPs\":%{public}lu}"
- "{\"msg%{public}.0s\":\"learnBinaryModel, unlabeledFingerprintVector\", \"numTriggers\":%{public}lu, \"numFPs\":%{public}lu}"
- "{\"msg%{public}.0s\":\"learnBinaryRoiSemiSupervisedModel, couldn't find label of labeled fingerprint\", \"Recording UUID\":%{public, location:escape_only}s, \"Trigger UUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"learnBinaryRoiSemiSupervisedModel, couldn't find trigger of labeled fingerprint\", \"Recording UUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"learnLocationSimilarityListModel, didn't classify all labeled triggers to either recording or localization\", \"Num labeled triggers\":%{public}lu, \"Num inferred recordings\":%{public}lu, \"Num inferred localizations\":%{public}lu}"
- "{\"msg%{public}.0s\":\"learnSemiSupervisedModel, Must have valid labeled fingerprints\", \"ClientId\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"learnSemiSupervisedModel, invalid semi-supervised model, not created\"}"
- "{\"msg%{public}.0s\":\"learnSemiSupervisedModel, labeled fingeprint assigned to cluster\", \"Recording UUID\":%{public, location:escape_only}s, \"Cluster UUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"learnSemiSupervisedModel, labeled fingerprint, label not found\", \"Trigger UUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"learnSemiSupervisedModel, labeled fingerprint, trigger not found\", \"Recording UUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"learnSemiSupervisedModel, labeledFingerprintVector\", \"numTriggers\":%{public}lu, \"numFPs\":%{public}lu}"
- "{\"msg%{public}.0s\":\"learnSemiSupervisedModel, started iteration of self learning\", \"iteration number\":%{public}lu}"
- "{\"msg%{public}.0s\":\"learnSemiSupervisedModel, unLabeledFingerprintVector\", \"iteration\":%{public}lu, \"numFPs\":%{public}lu}"
- "{\"msg%{public}.0s\":\"learnSemiSupervisedModel, unlabeled fingeprint assigned to cluster\", \"Recording UUID\":%{public, location:escape_only}s, \"Cluster UUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"learning a Location Similarity List model for client\", \"ClientId\":%{public, location:escape_only}s, \"ClientIdAndServiceUuid\":%{public, location:escape_only}s, \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"learning a semi-supervised model for client\", \"ClientId\":%{public, location:escape_only}s, \"ClientIdAndServiceUuid\":%{public, location:escape_only}s, \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"learning callback, already exists, release it first\"}"
- "{\"msg%{public}.0s\":\"learning callback, block copy it\"}"
- "{\"msg%{public}.0s\":\"learning callback, calling SPI response block for learning request\"}"
- "{\"msg%{public}.0s\":\"learning internal model for LOI\", \"loiGroupId\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"legacy client low number of observation status found\", \"number of observation status\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"localization results vector cannot be empty\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"localization retries have been exhausted, reset counters and trying another localization\", \"reason\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"localizationRequestResultsPerModel\", \"ModelUUID\":%{public, location:escape_only}s, \"ModelType\":%{public}lu, \"SimilarityListLengthIfApplicable\":%{private, location:escape_only}s, \"ClientID\":%{private, location:escape_only}s, \"LoiGroupId\":%{public, location:escape_only}s, \"hasAnchorStatistics\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"mapped cluster identifer already exists\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"measurement\", \"Inserted to set\":%{public}hhd, \"DeviceId\":%{public, location:escape_only}s, \"DataType\":%{public}lu, \"Measured Value\":\"%{public}.3f\"}"
- "{\"msg%{public}.0s\":\"minNumCluster must be greater than zero\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"min_dist should not be infinity\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"model\", \"size\":%{private}lu, \"numClusters\":%{private}lu, \"type\":%{private}d}"
- "{\"msg%{public}.0s\":\"modelFingerprint\", \"recordingUUID\":%{private, location:escape_only}s, \"clusterUUID\":%{private, location:escape_only}s, \"size\":%{private}lu, \"duration\":%{private}d, \"start\":%{private}d, \"end\":%{private}d}"
- "{\"msg%{public}.0s\":\"most recent model is not valid, will not calculate per cluster per anchor statistics\"}"
- "{\"msg%{public}.0s\":\"must have fingerprints distance function\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"no AnchorValueStatistics for model\", \"ModelUUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"no LOI ids found\"}"
- "{\"msg%{public}.0s\":\"not adding new truth label out of learning flow\", \"ServiceType\":%{public}lu}"
- "{\"msg%{public}.0s\":\"not analyzing Locations of Interest usage, since sending to core-analytics is disabled\"}"
- "{\"msg%{public}.0s\":\"not analyzing associated state, since sending to core-analytics is disabled\"}"
- "{\"msg%{public}.0s\":\"not analyzing trigger types, since sending to core-analytics is disabled\"}"
- "{\"msg%{public}.0s\":\"nullspace\", \"identifier\":%{private, location:escape_only}s, \"weight\":\"%{private}f\", \"phat\":\"%{private}f\", \"reducedDistance\":\"%{private}f\"}"
- "{\"msg%{public}.0s\":\"number of measurements still exceeds maximum\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"onInMotion - setting medium confidence and resetting localization error retries\", \"ScreenOn\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"onMotionMeasurements, couldn't find StopMotionDetection element\", \"fenceIdStr\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"onStopMotion\", \"ScreenOn\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"operation cancelled\", \"Activity\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"prune threshold must be less than or equal to clusterDistance threshold\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"pruneSmallClusters\", \"cluster ID\":%{public, location:escape_only}s, \"cluster size\":%{public}lu, \"threshold\":%{public}lu}"
- "{\"msg%{public}.0s\":\"pruneSmallClusters\", \"clusterSizeThreshold\":%{public}lu, \"numFingerprintsPrePruning\":%{public}lu, \"numFingerprintsPostPruning\":%{public}lu}"
- "{\"msg%{public}.0s\":\"received low confidence rssi AP\", \"is invalid?\":%{public}hhd, \"is off channel?\":%{public}hhd, \"mac address\":%{private, location:escape_only}s, \"RSSI\":%{public}d, \"channel\":%{public}d}"
- "{\"msg%{public}.0s\":\"recorder setting confidence and reasons\", \"confidence level\":%{public}d, \"confidence reasons\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"refreshRoutineStateAtLastLocation, won't run, last location not set\"}"
- "{\"msg%{public}.0s\":\"removed a client for Milo prediction event updates\"}"
- "{\"msg%{public}.0s\":\"removing confidence reason\", \"Request ID\":%{public, location:escape_only}s, \"confidence reason\":%{public}lu}"
- "{\"msg%{public}.0s\":\"representativeFPsRatio, called with empty model\", \"isValid\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"request labeling without observation request identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"request labeling without place identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"request labeling without request identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"request labeling without service identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"request labling between times without place identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"request labling between times without request identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"request labling between times without service identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"request learning without request identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"request learning without service identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"request observation without request identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"request observation without service identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"request prediction  without service identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"request prediction without request identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"request remove custom Loi service identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"request removing labels without request identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"request start updating without request identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"request start updating without service identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"request stop updateing MicroLocation without request identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"request stop updating without service identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"retrieving anchor statistics map failed\"}"
- "{\"msg%{public}.0s\":\"rows to append are max length - copy\", \"MaxNumRows\":%{public}d, \"NumRowsToAppend\":%{public}d}"
- "{\"msg%{public}.0s\":\"scanner type 15, 16 deviceFilter is empty for initiated scan\"}"
- "{\"msg%{public}.0s\":\"scanner type 15, 16 deviceFilter is\", \"deviceFilter\":%{public, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"scanner type 22 deviceFilter is\", \"deviceFilter\":%{public, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"semi-supervised model has no clientId value\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"sending CoreAnalytics com.apple.MicroLocation.AssociatedState\", \"num events\":%{public}lu}"
- "{\"msg%{public}.0s\":\"sending CoreAnalytics com.apple.MicroLocation.ModelLearning\", \"sending enabled\":%{public}hhd, \"model type\":%{public}lu, \"has_value\":%{public}lu}"
- "{\"msg%{public}.0s\":\"sensorLogic, received wifi scan error busy\"}"
- "{\"msg%{public}.0s\":\"sensorLogic, received wifi scan error\"}"
- "{\"msg%{public}.0s\":\"service connects to low-latency while already in low-latency\", \"ServiceUUID\":%{public, location:escape_only}s, \"CachedLocalizationSuccess\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"service is appending an event to similarity list\", \"ServiceUUID\":%{private, location:escape_only}s, \"TriggerUUID\":%{public, location:escape_only}s, \"LabelUUID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"setting confidence in current Localization\", \"Request ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"setting fingerprint confidence due to number of RF sources\", \"number of Ble measurements\":%{public}lu, \"number of Uwb measurements\":%{public}lu, \"Recording UUID\":%{public, location:escape_only}s, \"confidence level\":%{public}d}"
- "{\"msg%{public}.0s\":\"setting ongoing timer\", \"Element ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"setting stopDetection element to Idle (clear fence and timer)\", \"Element ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"setting stopDetection ongoing timer to Idle (clear fence)\", \"Element ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"should not call addNewTruthLabelToModelIfAppropriate with CLMiLoServiceTypeMax\"}"
- "{\"msg%{public}.0s\":\"shouldProcess, ignore a measurement\", \"macAddress\":%{public, location:escape_only}s, \"shouldProcessPerInvalidRssiFlag\":%{public}hhd, \"shouldProcessPerOffChannelRssiFlag\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"shouldRescheduleLocalization, reached invalid result reschedule limit\", \"retried number\":%{public}d}"
- "{\"msg%{public}.0s\":\"shouldRescheduleLocalization, reached invalid result retry disabled count limit\", \"retry disabled trigger count\":%{public}d}"
- "{\"msg%{public}.0s\":\"shouldRescheduleLocalization, result contains reason:\", \"reason\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"shouldRescheduleLocalization, result is valid or low latency mode is disabled, resetting retry states\", \"confidenceLevelAllowReschedule\":%{public}hhd, \"localizationRetryReasonExists\":%{public}hhd, \"isLowLatencyMode\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"shouldRescheduleLocalization, will not reschedule a motion trigger due to motion reason\"}"
- "{\"msg%{public}.0s\":\"shouldRescheduleLocalization, will not reschedule, currently in motion\"}"
- "{\"msg%{public}.0s\":\"shouldRescheduleLocalization, will not retry\", \"retry disabled trigger count\":%{public}d}"
- "{\"msg%{public}.0s\":\"shouldRescheduleLocalization, will reschedule a localization trigger due to invalid result\", \"retried count\":%{public}d}"
- "{\"msg%{public}.0s\":\"shouldRescheduleLocalization, will reschedule a localization trigger due to motion during prediction\"}"
- "{\"msg%{public}.0s\":\"skipping Location Similarity List model learning because of LOI\", \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"skipping Location Similarity List model learning, no such clients\"}"
- "{\"msg%{public}.0s\":\"skipping Location Unsupervised model learning because of LOI\", \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"skipping Location semi-supervised model learning because of LOI\", \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"start learn model\", \"model-type\":%{public}lu}"
- "{\"msg%{public}.0s\":\"starting session for stopDetection element\", \"Element ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"starting stopDetection in element (set fence and timer)\", \"Element ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"stopAllStatusTimersAndStartFenceStatusTimer: setting fence status timer to fire in the future\", \"Delay to next fire\":\"%{public}f\"}"
- "{\"msg%{public}.0s\":\"stopAllStatusTimersAndStartRaceDelayTimer: setting race delay timer to fire in the future\", \"Delay to next fire\":\"%{public}f\"}"
- "{\"msg%{public}.0s\":\"stopReason != LocalizationStopReason::CompletedSuccessfully, but stopReasonToConfidenceReason returned nullopt! shouldn't happen\", \"stopReason\":%{public}lu}"
- "{\"msg%{public}.0s\":\"stopping session for stopDetection element\", \"Element ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"testFingerprint\", \"ModelType\":%{private}lu, \"size\":%{private}lu, \"NumWiFiMeasurements\":%{private}lu, \"NumBLEMeasurements\":%{private}lu, \"NumUWBMeasurements\":%{private}lu, \"WiFi RSSI duration_s\":\"%{private}.09f\", \"start\":%{private}d, \"end\":%{private}d}"
- "{\"msg%{public}.0s\":\"triggerFallbackLocalizationEvent: fLastTrigger is in the past\", \"triggerTS\":\"%{public}.3f\", \"fLastLocalizationTriggerTS\":\"%{public}.3f\"}"
- "{\"msg%{public}.0s\":\"triggerFallbackLocalizationEvent: requesting localization on screen on because we haven't localized for more than \", \"Max time between localizations\":\"%{public}f\", \"Time since last_s\":\"%{public}.09f\"}"
- "{\"msg%{public}.0s\":\"try to set confidence for non-existent localization request\", \"Request ID\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"trying to issue sandbox extension\", \"path\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"unhandled serviceType\", \"ServiceType\":%{public}lu}"
- "{\"msg%{public}.0s\":\"unique valid anchor\", \"dataType\":%{public}d, \"deviceId\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"unknown protobuf confidence level, deprecated?\"}"
- "{\"msg%{public}.0s\":\"update confidence of localization request due to localization stop reason\", \"stopReason\":%{public}lu, \"confidence level\":%{public}d}"
- "{\"msg%{public}.0s\":\"update confidence of localization request due to wifi scan error\"}"
- "{\"msg%{public}.0s\":\"update confidence of localization request\", \"confidence level\":%{public}d}"
- "{\"msg%{public}.0s\":\"updateLocalizationConfidenceAndReasonsIfNeeded, no current localization\"}"
- "{\"msg%{public}.0s\":\"updateMagicalMomentsNumPrunedFingerprints called incorrectly\", \"iteration\":%{public}lu, \"numFingerprintsPerIteration size\":%{public}lu}"
- "{\"msg%{public}.0s\":\"updateSeenAnchors\", \"Anchors map initial size\":%{private}lu, \"Received daily IDS ID set size\":%{private}lu, \"Size with new anchors\":%{private}lu, \"Size after purging\":%{private}lu, \"Size after max entries limit\":%{private}lu}"
- "{\"msg%{public}.0s\":\"when appending event to similarity list, model has no similarity list!\", \"ServiceUUID\":%{private, location:escape_only}s, \"ModelUUID\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"when appending event to similarity list, service has no current model!\"}"
- "{\"msg%{public}.0s\":\"wifi channels analyitcs operation cancelled\", \"Activity\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"will not conduct nearbyAction, nearbyInfo requested scan because device filter is empty\"}"
- "{\"msg%{public}.0s\":\"workout elevation result updated with\", \"altitude\":\"%{private}f\", \"time_s\":\"%{private}.09f\", \"verticalAccuracy\":\"%{private}f\"}"
- "{\"msg%{public}.0s\":\"~StateBase\"}"
- "{\"msg%{public}.0s\":\"~StateMachineBase\"}"
- "{\"type\" : 2, \"sigma\" : 0.375, \"power\" : 3.0}"
- "{\"type\" : 2, \"sigma\" : 0.6, \"power\" : 3.5}"
- "{\"type\" : 2, \"sigma\" : 0.625, \"power\" : 3.0}"
- "{}"

```
