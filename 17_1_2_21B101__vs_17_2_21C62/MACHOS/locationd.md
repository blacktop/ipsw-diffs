## locationd

> `/usr/libexec/locationd`

```diff

-2890.0.8.0.5
-  __TEXT.__text: 0x19e17b0
-  __TEXT.__auth_stubs: 0x68f0
-  __TEXT.__objc_stubs: 0x3a9c0
-  __TEXT.__init_offsets: 0x5f8
-  __TEXT.__objc_methlist: 0x23784
-  __TEXT.__const: 0x149ae1
-  __TEXT.__gcc_except_tab: 0xb2610
-  __TEXT.__objc_methname: 0x528a8
-  __TEXT.__objc_classname: 0x724d
-  __TEXT.__objc_methtype: 0x39a81
-  __TEXT.__cstring: 0x1b953c
-  __TEXT.__oslogstring: 0x2342b3
+2890.4.12.1.4
+  __TEXT.__text: 0x1a3b4a8
+  __TEXT.__auth_stubs: 0x6920
+  __TEXT.__objc_stubs: 0x3b8c0
+  __TEXT.__init_offsets: 0x604
+  __TEXT.__objc_methlist: 0x241ac
+  __TEXT.__const: 0x14cad1
+  __TEXT.__gcc_except_tab: 0xb5fac
+  __TEXT.__objc_methname: 0x540d8
+  __TEXT.__objc_classname: 0x74eb
+  __TEXT.__objc_methtype: 0x3da9b
+  __TEXT.__cstring: 0x1be871
+  __TEXT.__oslogstring: 0x23d2bd
   __TEXT.__constg_swiftt: 0xec
   __TEXT.__swift5_typeref: 0xad
   __TEXT.__swift5_fieldmd: 0x30
   __TEXT.__swift5_types: 0x10
   __TEXT.__dlopen_cstrs: 0xa0
   __TEXT.__ustring: 0x2ee
-  __TEXT.__unwind_info: 0x5d4d8
+  __TEXT.__unwind_info: 0x5ea84
   __TEXT.__eh_frame: 0x110
   __DATA_CONST.__linkguard: 0x15
-  __DATA.__auth_got: 0x3490
-  __DATA.__got: 0x1b78
-  __DATA.__auth_ptr: 0x2c8
-  __DATA.__const: 0xabdc8
-  __DATA.__cfstring: 0x348c0
-  __DATA.__objc_classlist: 0x1268
+  __DATA.__auth_got: 0x34a8
+  __DATA.__got: 0x1b88
+  __DATA.__auth_ptr: 0x2e0
+  __DATA.__const: 0xae720
+  __DATA.__cfstring: 0x35ac0
+  __DATA.__objc_classlist: 0x12d8
   __DATA.__objc_catlist: 0xb8
-  __DATA.__objc_protolist: 0xd10
+  __DATA.__objc_protolist: 0xd48
   __DATA.__objc_imageinfo: 0x8
-  __DATA.__objc_const: 0x50570
-  __DATA.__objc_selrefs: 0x11c10
-  __DATA.__objc_protorefs: 0x9d0
-  __DATA.__objc_classrefs: 0x1d20
-  __DATA.__objc_superrefs: 0x10e0
-  __DATA.__objc_ivar: 0x2f24
-  __DATA.__objc_data: 0xb940
-  __DATA.__data: 0x60f72
-  __DATA.__objc_intobj: 0x1f08
-  __DATA.__objc_arraydata: 0xce0
+  __DATA.__objc_const: 0x52150
+  __DATA.__objc_selrefs: 0x12050
+  __DATA.__objc_protorefs: 0x9f0
+  __DATA.__objc_classrefs: 0x1d88
+  __DATA.__objc_superrefs: 0x1148
+  __DATA.__objc_ivar: 0x3080
+  __DATA.__objc_data: 0xbda0
+  __DATA.__data: 0x612aa
+  __DATA.__objc_intobj: 0x2610
+  __DATA.__objc_arraydata: 0x1220
   __DATA.__objc_dictobj: 0x988
   __DATA.__objc_floatobj: 0x70
-  __DATA.__objc_arrayobj: 0x708
+  __DATA.__objc_arrayobj: 0x768
   __DATA.__objc_doubleobj: 0x190
-  __DATA.__common: 0x30a0
-  __DATA.__bss: 0x10790
+  __DATA.__common: 0x30b0
+  __DATA.__bss: 0x108d0
   - /System/Library/Frameworks/Accelerate.framework/Accelerate
   - /System/Library/Frameworks/Accounts.framework/Accounts
   - /System/Library/Frameworks/ActivityKit.framework/ActivityKit

   - /System/Library/PrivateFrameworks/MobileBluetooth.framework/MobileBluetooth
   - /System/Library/PrivateFrameworks/MobileKeyBag.framework/MobileKeyBag
   - /System/Library/PrivateFrameworks/MobileWiFi.framework/MobileWiFi
+  - /System/Library/PrivateFrameworks/MomentsOnboardingAndSettings.framework/MomentsOnboardingAndSettings
   - /System/Library/PrivateFrameworks/NanoPreferencesSync.framework/NanoPreferencesSync
   - /System/Library/PrivateFrameworks/NanoRegistry.framework/NanoRegistry
   - /System/Library/PrivateFrameworks/NetworkStatistics.framework/NetworkStatistics

   - /usr/lib/swift/libswiftSystem.dylib
   - /usr/lib/swift/libswiftXPC.dylib
   - /usr/lib/swift/libswiftos.dylib
-  UUID: A3D877B0-8709-31AA-A5B5-286662C1F46F
-  Functions: 85251
-  Symbols:   3154
-  CStrings:  82444
+  UUID: 7421E670-4C0F-3FB4-8856-989A6F905BDB
+  Functions: 86417
+  Symbols:   3160
+  CStrings:  83614
 
Symbols:
+ _CLLocationManagerGatheringBufferedDevicesReceived
+ _CMSafetyAnomalyPropertiesKey
+ _OBJC_CLASS_$_CLMiLoCustomLoiConfiguration
+ _OBJC_CLASS_$_CLMonitorConfiguration
+ _OBJC_CLASS_$_CLPOutdoorUpdate
+ _OBJC_CLASS_$_MOSettingsManager
+ _drand48
+ _objc_retain_x11
+ _srand48
- _OBJC_CLASS_$__DKEventQuery
- _OBJC_CLASS_$__DKNowPlayingMetadataKey
- _OBJC_CLASS_$__DKQuery
CStrings:
+ " WHERE startTime > ? and startTime <= ? ORDER BY startTime ASC"
+ "!fWeakSession.expired()"
+ "# MiLo Logic -- tried to initialize with an invalid queue"
+ "#LOI Bridge, Attempted LOI request when location manager was not available"
+ "#LOI Bridge, Attempted bootstraping when region monitor was not available"
+ "#LOI Bridge, Attempted geofence request when region monitor was not available"
+ "#LOI Bridge: location manager failed"
+ "#LOI Manager, CoreAnalytics Disabled"
+ "#LOI Manager, Error: tried to enable custom LOI at an active custom LOI"
+ "#LOI Manager, Failed to RemoveGeofence"
+ "#LOI Manager, In Home LOI, exit it before creating custom LOI process"
+ "#LOI Manager, failed to get current location to enable MiLo"
+ "#LOI Manager, failed to get current location to enable MiLo... aborting request"
+ "#LOI Manager, failed to set geofence at current location to enable MiLo"
+ "#LOI Manager, failed to set geofence at current location to enable MiLo, failing custom loi request"
+ "#LOI Manager, got enable custom LOI request from the same service, ignoring"
+ "#LOI Manager, got geofence entry for the current active LOI which shouldn't happen... ignoring"
+ "#LOI Manager, got geofence exit for an LOI which is not the currently the active LOI, this may happen if we jumped from one geofence to another and the entry for the new geofence arrived first"
+ "#LOI Manager, kick off creating custom LOI process"
+ "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring"
+ "#LOIManager, Received nil object in eventData, this shouldn't happen"
+ "#LoiBridge, was unable to retrieve monitor record for valid region identifier"
+ "#LoiRecordingManager Tried to initialize with an invalid queue"
+ "#MiLoNotifier: onMotionStateUpdate"
+ "#Warning Bundle,%{public}s, exceeds its fence limit,%{private}d. It has %{public}d Fences. Fence,%{private}s, will not be added"
+ "#Warning Failed to add Service Id to LOI Id mapping"
+ "#Warning LOI Bridge not setup."
+ "#Warning LOI Manager, Error retrieving related LOIs for Loi"
+ "#Warning LOI Manager, Error retrieving the current LOI. %{private}s"
+ "#Warning Table is not valid so can't remove service to custom LOI mapping"
+ "#Warning Table is not valid so we can't select distinct Custom Loi Ids"
+ "#Warning, out of valid range OTA value, failed to assign, %{private}0.1f, to cellCrossCheckDistanceThreshold"
+ "#Warning, out of valid range OTA value, failed to assign, %{private}0.1f, to multiApWifiCrossCheckDistanceThreshold"
+ "#Warning, out of valid range OTA value, failed to assign, %{private}0.1f, to referenceLocationAgeThreshold"
+ "#Warning, out of valid range OTA value, failed to assign, %{private}d, to minNumAps"
+ "#alsquery alsRequestReasonTally, reason: %s tally: %d"
+ "#beaconIdentityCondition Region is nil"
+ "#gnssca,GnssDailyPowerAnalyticsWithContext,Submit to CA,dailyClientGnssDisplayOnOutsideVisitSeconds,%{private}d,dailyDebouncePeriodDisplayOnOutsideVisitSeconds,%{private}d,dailyClientGnssDisplayOnInsideVisitSeconds,%{private}d,dailyDebouncePeriodDisplayOnInsideVisitSeconds,%{private}d,dailyClientGnssDisplayOffOutsideVisitSeconds,%{private}d,dailyDebouncePeriodDisplayOffOutsideVisitSeconds,%{private}d,dailyClientGnssDisplayOffInsideVisitSeconds,%{private}d,dailyDebouncePeriodDisplayOffInsideVisitSeconds,%{private}d,dailyGnssUsageWithShortOrWiFiAssociatedSessionsSeconds,%{private}d"
+ "#gnssca,GnssPowerAnalyticMetrics,Submit to CA,totalDailyGnssUsageSeconds,%{private}d,totalDailyClientGnssUsageSeconds,%{private}d,totalDailyProactiveGnssUsageSeconds,%{private}d,totalDailyGnssDebounceSeconds,%{private}d,totalDailyExclusiveProactiveGnssSeconds,%{private}d"
+ "#gnssca,dailyGnssUsageWithShortOrWiFiAssociatedSessions_s,%{public}.1lf,sessionDur,%{public}llu"
+ "#gnssca,handleDisplayEventForCA,display context unsupported"
+ "#gnssca,handleDisplayEventForCA,fDisplay,%{private}d"
+ "#gnssca,handleGnssSessionEventForAnalytics, eventTime,%{private}.1lf, eventType,%{private}d, eventStatus,%{private}d"
+ "#gnssca,initializeGnssDailyUseMetricsAtEventStart,isDisplayOn,%{private}d,isOutsideVisit,%{private}d"
+ "#gnssca,initializeGnssSessionDataAtEventStart,start time,%{private}.1lf,metricsContext,%{private}d,eventType,%{private}d"
+ "#gnssca,onVisit is nil"
+ "#gnssca,onVisit,received leeched visit notification, %{private}d"
+ "#gnssca,onVisit,visit context unsupported"
+ "#gnssca,submitGnssDailyUseMetricsOnDayChange,Set SecondsIntoDayAtLastGnssSessionStart,%{private}.1lf"
+ "#gnssca,submitGnssDailyUseMetricsOnDayChange,cleared daily usage metrics"
+ "#gnssca,submitGnssDailyUseMetricsOnDayChange,currentSecondsIntoDay_s,%{private}.1lf,secondsIntoDayAtLastGnssSessionStart_s,%{private}.1lf,timeSinceGnssDailyUseMetricsInitialization_s,%{private}.1lf,"
+ "#gnssca,submitGnssDailyUseMetricsOnDayChange,dailyGnssUsageSeconds,%{private}d,dailyClientSessionSeconds,%{private}d,dailyProactiveGnssSeconds,%{private}d,dailyDebouncePeriodSeconds,%{private}d,dailyExclusiveProactiveGnssSeconds,%{private}d,dailyClientGnssDisplayOnOutsideVisitSeconds,%{private}d,dailyDebouncePeriodDisplayOnOutsideVisitSeconds,%{private}d,dailyClientGnssDisplayOnInsideVisitSeconds,%{private}d,dailyDebouncePeriodDisplayOnInsideVisitSeconds,%{private}d,dailyClientGnssDisplayOffOutsideVisitSeconds,%{private}d,dailyDebouncePeriodDisplayOffOutsideVisitSeconds,%{private}d,dailyClientGnssDisplayOffInsideVisitSeconds,%{private}d,dailyDebouncePeriodDisplayOffInsideVisitSeconds,%{private}d,dailyGnssUsageWithShortOrWiFiAssociatedSessionsSeconds,%{private}d"
+ "#gnssca,updateGnssDailyUseMetricsAtEventEnd,isDisplayOn,%{private}d,isOutsideVisit,%{private}d"
+ "#gnssca,updateGnssSessionDataAtEventEnd,metricsContext,%{private}d,eventType,%{private}d,eventDuration_s,%{private}.1lf,totalDailyUsage_s,%{private}.1lf"
+ "#gnssca,updateGnssSessionDataAtEventEnd,start time in future,metricsContext,%{private}d,eventType,%{private}d,startTime,%{private}.1lf"
+ "#luHistorical entitlementDict for transcriptSession entitlement should not be nil"
+ "#luHistorical entitlementDict for wilderness entitlement should not be nil"
+ "#luHistorical routine monitor should not be empty"
+ "#luHistorical weak session should not be empty"
+ "#monitor #Warning oh wait, lastEvent state is unknown so not actually sending this condition update to the client"
+ "#monitor Fence: unable bind statement to clear Monitor fences"
+ "#monitor Fence: unable to clear Monitor fences"
+ "#monitor identifier nil onConditionUpdate"
+ "#monitor should be all cleared for migration but it isn't"
+ "#placeInfer last location, lat, %{private}.8lf, lon, %{private}.8lf, horAcc, %{public}.1lf, type, %{public}s, timestamp, %@"
+ "#placeInfer send last available location"
+ "#significantRegion: not set status"
+ "%@,<recordId %d, startTime %f, endTime %f, stepCount %u, distance %f, activeTime %f, elevationAscended %u, elevationDescended %u, stepCountGPS %u, distanceGPS %f, boutType %d>"
+ "%@,<recordId %llu, startTime %f, mets %f, gradeType %d, grade %f, userMets, %f, userMetsSource, %d>"
+ "%@@%@"
+ "%s analytics received invalid notification type, %u"
+ "%s, Extracting and submitting state change analytics"
+ "%s, Failure getting status from location"
+ "%s, FenceAnalyticsManager"
+ "%s, Previous fence states don't match, reseting historical states"
+ "%s, Received FenceMonitor notification, processing metrics for state change"
+ "%s, Unhandled notification %{public}d"
+ "%s, collecting state change metrics"
+ "%s, issuing state"
+ "%s, issuing state/transition"
+ "%s, issuing transition"
+ "(NotSet)"
+ "+[CLFenceAnalyticsCommon binForNumber:bins:]"
+ "-[CLDaemonBeaconIdentityCondition onNotification:withData:]"
+ "-[CLDaemonConditionLedger performMigration]"
+ "-[CLDaemonMonitoringRecord setupDaemonPartOfConditionWithAuthContext:clientKeyPath:universe:identifier:stopMonitoring:callbackHandler:]"
+ "-[CLElevationProfileEstimator _predictionUpdate:withElevation:withNextElevation:withTravelVelocity:]"
+ "-[CLFenceAnalyticsHistoricalStates updateCurrentState:previousState:]"
+ "-[CLFenceAnalyticsManager beginService]"
+ "-[CLFenceAnalyticsManager onMonitorNotification:data:]"
+ "-[CLFenceStateChangeAnalytics extractAnalyticsFromNotification:isInternal:]"
+ "-[CLFenceStateChangeAnalytics submitAllMetricsFromNotification:]"
+ "-[CLFenceStateChangeAnalytics submitAllMetricsFromNotification:]_block_invoke"
+ "-[CLGatheringBluetoothClient _armPeriodicScanTimer]"
+ "-[CLGatheringBluetoothClient _cancelPeriodicScanTimer]"
+ "-[CLGatheringBluetoothClient _isScanningEnabled]"
+ "-[CLGatheringBluetoothClient _onEnablementStatusUpdate]"
+ "-[CLGatheringBluetoothClient centralManagerDidUpdateState:]"
+ "-[CLGatheringBluetoothClient onStateChange:forSetting:]"
+ "-[CLGatheringBluetoothClient setupEnablementStatus]"
+ "-[CLGatheringBluetoothScanner initWithQueue:withSettings:withPolicy:]_block_invoke"
+ "-[CLGatheringDiscoveryStore markScanEndTimeFromBoot:withReason:withPolicy:]"
+ "-[CLGatheringDiscoveryStore markScanStartTimeFromBoot:withReason:withRate:]"
+ "-[CLGatheringSettings onUpdatedSettings:]"
+ "-[CLGnssAWDAdapterVisit onVisit:]"
+ "-[CLKappaNotifierAdapter forceTriggerIgneous:]"
+ "-[CLMeanSeaLevelPressureEstimator updateHistoricalMeanSeaLevelPressureArray:withRebaseTag:withForceTag:]"
+ "-[CLMicroLocationLoiBridge generateLocationManagerNotAvailableError]"
+ "-[CLMicroLocationLoiBridge generateRegionMonitorNotAvailableError]"
+ "-[CLMicroLocationLoiBridge initInUniverse:]"
+ "-[CLMicroLocationLoiBridge locationManager:didUpdateLocations:]"
+ "-[CLMicroLocationLoiBridge onVisit:]"
+ "-[CLMicroLocationLoiBridge requestBootstrapWithLastGeofenceStates]"
+ "-[CLPredictedWalkDistanceServiceWatch setUpAggregationOnTimer]_block_invoke"
+ "-[CMHealthColdStorageWatchService beginService]"
+ "-[CMHealthColdStorageWatchService checkDeferral:]"
+ "-[CMHealthColdStorageWatchService endService]"
+ "-[CMHealthColdStorageWatchService onCompanionNotification:data:]"
+ "-[CMHealthColdStorageWatchService onSyncActivity:]"
+ "-[CMHealthColdStorageWatchService setActivityAsDone:]"
+ "-[CMHealthColdStorageWatchService setupSyncActivity]_block_invoke"
+ "/!0/-0////#0"
+ "/AppleInternal/Library/BuildRoots/7ca2b31c-8e0a-11ee-855a-1ae9d66b0597/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.2.Internal.sdk/usr/local/include/boost/geometry/algorithms/detail/throw_on_empty_input.hpp"
+ "/AppleInternal/Library/BuildRoots/7ca2b31c-8e0a-11ee-855a-1ae9d66b0597/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.2.Internal.sdk/usr/local/include/boost/uuid/detail/random_provider_posix.ipp"
+ "/AppleInternal/Library/BuildRoots/7ca2b31c-8e0a-11ee-855a-1ae9d66b0597/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.2.Internal.sdk/usr/local/include/boost/uuid/string_generator.hpp"
+ "/AppleInternal/Library/BuildRoots/7ca2b31c-8e0a-11ee-855a-1ae9d66b0597/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.2.Internal.sdk/usr/local/include/google/protobuf/repeated_field.h"
+ "/AppleInternal/Library/BuildRoots/7ca2b31c-8e0a-11ee-855a-1ae9d66b0597/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.2.Internal.sdk/usr/local/include/google/protobuf/wire_format_lite_inl.h"
+ "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Core/ClientManagement/DaemonIdentifiableClients/CLDaemonBeaconIdentityCondition.mm"
+ "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Core/ClientManagement/DaemonIdentifiableClients/CLDaemonLocationUpdaterHistorical.mm"
+ "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMiLoCustomLoiRecordingManager.mm"
+ "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationBlueAtlasAlgorithms.h"
+ "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationBlueAtlasAlgorithms.mm"
+ "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationBlueAtlasLocalize.mm"
+ "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationStateMachine.h"
+ "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationTriggerManager.mm"
+ "/var/root/Library/Caches/locationd/"
+ "0123456789ABCDEF"
+ "1.4.20"
+ "20:35:18"
+ "20:42:25"
+ "@\"CLFenceAnalyticsManager\""
+ "@\"CLFenceStateChangeAnalytics\""
+ "@\"CLMonitor\""
+ "@\"CLMonitorConfiguration\""
+ "@\"CLRoutineMonitor\""
+ "@24@0:8r^{HRRecoveryInputWR=Qddiddi}16"
+ "@264@0:8{Fence={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}ddddddddiiidQiiBiiB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{CLStrongPtr<NSUUID *>=@}{vector<CLClientLocationCoordinate, std::allocator<CLClientLocationCoordinate>>=^{?}^{?}{__compressed_pair<CLClientLocationCoordinate *, std::allocator<CLClientLocationCoordinate>>=^{?}}}}16"
+ "@40@0:8d16Q24q32"
+ "@460@0:8{CLFenceStateChangeMetrics=QBBQQQQQQQQQQQQQQQQQQQQQQQQBBBBBBQQQQQQQBQQQQQQQQQQQQQQQQB@qB}16B456"
+ "@64@0:8@16@24@32@40@48@?56"
+ "@64@0:8Q16d24d32i40d44d52i60"
+ "@68@0:8@16@24@32@40@48B56@?60"
+ "ALGORITHM_BLUE_ATLAS"
+ "AP power changed callback with refcon"
+ "AllowOutdoorServiceNotifications"
+ "B272@0:8{Fence={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}ddddddddiiidQiiBiiB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{CLStrongPtr<NSUUID *>=@}{vector<CLClientLocationCoordinate, std::allocator<CLClientLocationCoordinate>>=^{?}^{?}{__compressed_pair<CLClientLocationCoordinate *, std::allocator<CLClientLocationCoordinate>>=^{?}}}}16i264i268"
+ "BLUE_ATLAS"
+ "Blue Atlas Localization, model type is not BLUE_ATLAS!"
+ "Bluetooth state changed to %@"
+ "CL: CLGatheringRoutineOTASubscription::onMobileAssetNotification"
+ "CL: CLMicroLocationNotifier::onMotionStateUpdate"
+ "CLActivityRecorderDb<CLMobility::SmoothedGaitMetrics, CLActivityDB::ClassBDataProtectionPolicy>::CLActivityRecorderDb(const char *, bool, float, const std::string &, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLMobility::SmoothedGaitMetrics, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]"
+ "CLDaemonLocationUpdaterHistorical"
+ "CLFenceAnalyticsCommon"
+ "CLFenceAnalyticsHistoricalStates"
+ "CLFenceAnalyticsManager"
+ "CLFenceAnalyticsManagerClientProtocol"
+ "CLFenceAnalyticsManagerServiceProtocol"
+ "CLFenceAnalyticsManagerSilo"
+ "CLFenceAnalyticsMotionActivityHistogram"
+ "CLFenceAnalyticsMotionActivityHistogramBin"
+ "CLFenceStateChangeAnalytics"
+ "CLGatheringRoutineOTASubscription Mobile asset notification data: %{private}@"
+ "CLGatheringRoutineOTASubscription::onMobileAssetNotification"
+ "CLGatheringRoutineOTASubscriptionDelegate"
+ "CLGatheringSettings Received OTA settings %{private}@"
+ "CLGnssAWD,Monitor proxy invalid"
+ "CLGnssAWD,register to leech visits"
+ "CLGnssAWD,routine Monitor invalid"
+ "CLGnssAWDAdapterVisit"
+ "CLLocationPreFilterEntry"
+ "CLMiLoConnectionCustomLoiConfiguration"
+ "CLMiLoConnectionLOIIdentifier"
+ "CLMiLoCustomLoiRecordingFence"
+ "CLMiLoCustomLoiRecordingManager"
+ "CLMiLoService failed to add trigger for future labeling: "
+ "CLMiLoServiceManager loaded incorrect model type for LSL service in custom LOI, this should never happen!!!"
+ "CLMicroLocationGeofence"
+ "CLMicroLocationLogic"
+ "CLMicroLocationLoi"
+ "CLMicroLocationLoiBridge"
+ "CLMicroLocationLoiBridgeProtocol"
+ "CLMicroLocationModel::BlueAtlasData fromProtobuf - invalid LabelUuid conversion!"
+ "CLMicroLocationNotifier::onMotionStateUpdate"
+ "CLMicroLocationProto.AssociatedAccessPointInfo"
+ "CLMicroLocationProto.BlueAtlasData"
+ "CLMicroLocationProto.EnableAtCurrentLocation"
+ "CLMicroLocationRegionMonitor"
+ "CLPredictedWalkDistanceCompanionSyncManager: Failed to fetch bouts for time range, startTime : %f, endTime: %f"
+ "CLPredictedWalkDistanceCompanionSyncManager::queryLatestRecords"
+ "CLPredictedWalkDistanceData"
+ "CLRGE,updateRhythmicGnssPerDayUsage,totalGnssInADay_s,%{public}d, totalLeechedGnssInADay_s,%{public}d,totalProactiveGnssInADay_s,%{public}d,hasDayChangedBeforeThisSession,%{public}d,hasDayChangedAfterThisSession,%{public}d,rhythmicSessionTime,%{public}.3lf,currentSecondsIntoToday,%{public}d,secondsInDayBeforeCurSession,%{public}.3lf"
+ "CLSubHarvesterTraceAdapterOutdoor"
+ "CMHealthColdStorageCompanionSyncActivityInterval"
+ "CMHealthColdStorageWatchService"
+ "CMHealthColdStorageWatchServiceClientProtocol"
+ "CMHealthColdStorageWatchServiceProtocol"
+ "CMHealthColdStorageWatchServiceSilo"
+ "ContactID %@ opted out, niv2df %x"
+ "CrossCheckOutcome CLMovingApDetector::crossCheckCentroid(const CLWifiAPLocation &, const CFAbsoluteTime &)"
+ "Custom"
+ "Custom LOI Entry Failure"
+ "Custom LOI Entry Timeout"
+ "Custom LOI entry notification"
+ "Custom LOI exit notification"
+ "Custom LOI logic"
+ "Custom Loi"
+ "DELETE FROM SmoothedGaitMetricsHistory WHERE startTime < ?"
+ "DeviceNotReadyEvent"
+ "DeviceReadyEvent"
+ "Disable Custom LOI"
+ "Enable Custom LOI"
+ "Entering Custom LOI Timeout"
+ "Entry"
+ "Error creating bins for number %@, bins, %@, invalid input"
+ "Estimator,computeTime,%{private}f,wrMets,%{private}f,gradeType,%{private}d,grade,%{private}f,userMets,%{private}f,userMetsSource,%{private}d"
+ "FAULT: Tried to initialize LOI Manager with a nil LOI Bridge Object"
+ "Failed To Fetched Place Inference"
+ "Failed To Get Location Update"
+ "Failed To Set Geofence"
+ "Failed to Get LOI Event"
+ "Failed to Get Related LOIs"
+ "Failed to get current Location"
+ "Failed to set geofence"
+ "Fence Status Not Set used for analytics received in FenceManager"
+ "Fence: fence not added, too many fences, %{private}s, %{private}d, %{private}u"
+ "Fetch Place Inference For Reason"
+ "Fetched Place Inference For Current Location"
+ "Force clearing fence %{public}@"
+ "GPS filter %d %f %d %d %d"
+ "GPS timestamp %.6f, delta %llu, notify(type) = %u, speed = %f accuracy = %f course = %f lat(tr) = %f long(tr) = %f horAcc = %f dem %d conf %f type %d"
+ "Generic Failure"
+ "GeoGenericBundleId"
+ "Geofence Entry"
+ "Geofence Exit"
+ "Get generation algorithm: Unknown learner type"
+ "GnssAWD,onVisit"
+ "GnssSession"
+ "Got LOI Event"
+ "Got Location Update"
+ "Got Related LOIs"
+ "Guid"
+ "HRRecoveryInputHRHistory not accessible"
+ "HRRecoveryInputWRHistory not accessible"
+ "HRRecoverySessionHistory not accessible"
+ "HandleEvent::alsRequestResultPair CL::Wifi1::Policies::AlsQuery::HandleEvent::defaultAlsRequestLogicUsedWhenComputingLocation(const Input &, const std::optional<CLWifiService_Type::ScanType> &) const"
+ "Home LOI Entry Failure"
+ "INSERT INTO HRRecoveryInputWRHistory (startTime, mets, gradeType, grade, userMets, userMetsSource) VALUES (?, ?, ?, ?, ?, ?)"
+ "INSERT INTO SmoothedGaitMetricsHistory (startTime, walkingSpeed, stepLength, cycleTime, distance, doubleSupportPercentage, asymmetryProbability, numGaitMetrics \t\t\t\t) VALUES (?, ?, ?, ?, ?, ?, ?, ?)"
+ "Igneous"
+ "IgneousForceOn"
+ "IgneousMaxArmMinutes"
+ "IgneousMaxScheduledArmSec"
+ "IgneousScheduledEnableRenewPeriod"
+ "IgneousTriggerProbability"
+ "In Custom LOI State"
+ "In Home LOI State"
+ "In the process of entering Custom LOI"
+ "In the process of entering Home LOI"
+ "Invalid Geofence Entry"
+ "Invalid Geofence Exit"
+ "Invalid apsUsedInCalculation, numberOfApsUsedInHorizontalCalculation. apsUsedInCalculation: %{public}u, numberOfApsUsedInHorizontalCalculation: %{public}u"
+ "Invalid percentage: %{public}u. count: %{public}u, total: %{public}u, defaultPercentage: %{public}u"
+ "LOI Bridge, Failed To fetch place inferences"
+ "LOI Bridge, received nil LOI Identifier, possibly because there is no active user on macOS, we will start leeching and wait for next location update"
+ "LOI Bridge, received no place inferences, we will start leeching and wait for next location update"
+ "LOI Bridge: Received location update when not waiting on one... Ignoring"
+ "LOI Bridge: Received nil visit notification"
+ "LOI Bridge: Received visit notification"
+ "LOI Fetch Failure"
+ "LOI Manager, Failed To fetch place inferences"
+ "LOI Manager, Failed To request LOI for current visit location"
+ "LOI Manager, Failed To request related LOIs"
+ "LOI Manager, Got event when not expecting it"
+ "LOI Manager, Not a Home LOI"
+ "LOI Manager, Received visit entry"
+ "LOI Manager, Received visit exit"
+ "LOI Manager, Returning to Inactive Location State"
+ "LOI Manager, fetching related LOIs for LOI"
+ "LOI Manager, got nil LOI for current Location.. perhaps not in an LOI"
+ "LOI Manager, handleVisitNotification"
+ "LOI Manager, received nil LOI Identifier from place inference, possibly because there is no active user on macOS, we will start leeching and wait for next location update"
+ "LOI Manager, requested LOI for current visit location"
+ "LOI Visit Entry"
+ "LOI Visit Exit"
+ "Leeched Location Update"
+ "Loaded Blue Atlas model doesn't have Blue Atlas data structure, create empty"
+ "LocalizerChannelIterator, invalid index"
+ "Location Manager not available"
+ "Look up table thresholds and scores vectors must be the same size"
+ "Look up table thresholds must be sorted"
+ "MOSettingsManagerDelegate"
+ "MaxRecordingTimerFiredEvent"
+ "MiLoCustomLoiTable"
+ "MicroLocationsBlueAtlasApSelectionScoreThreshold"
+ "MicroLocationsBlueAtlasAppearanceRateScores"
+ "MicroLocationsBlueAtlasAppearanceRateThresholds"
+ "MicroLocationsBlueAtlasAssociatedAccessPointLocalizerEnabled"
+ "MicroLocationsBlueAtlasFingerprintDistanceFunctionType"
+ "MicroLocationsBlueAtlasLocalizerEuclideanSimilarityScores"
+ "MicroLocationsBlueAtlasLocalizerEuclideanThresholds"
+ "MicroLocationsBlueAtlasLocalizerRssiScaleFactor"
+ "MicroLocationsBlueAtlasLocalizerRssiScaleNumberOfAps"
+ "MicroLocationsBlueAtlasModelMaxSources"
+ "MicroLocationsBlueAtlasModelMinRecordings"
+ "MicroLocationsBlueAtlasModelMinSources"
+ "MicroLocationsBlueAtlasModelValidationMinAppearanceRate"
+ "MicroLocationsBlueAtlasModelValidationMinNumberOfValidAps"
+ "MicroLocationsBlueAtlasModelValidationMinRssi"
+ "MicroLocationsBlueAtlasRssiScores"
+ "MicroLocationsBlueAtlasRssiThresholds"
+ "MicroLocationsBlueAtlasStrongAssociatedAccessPointThreshold"
+ "MicroLocationsCustomLoiEntryTimeout"
+ "MicroLocationsCustomLoiGeofenceRadius"
+ "MicroLocationsCustomLoiLocalizationFenceRadiusInMeters"
+ "MicroLocationsCustomLoiMaxRecordingWindow"
+ "MicroLocationsCustomLoiMaxRecordings"
+ "MicroLocationsCustomLoiRecordingFenceRadiusInMeters"
+ "MicroLocationsCustomLoiWaitBetweenRecordings"
+ "MicroLocationsLocalizingDurationMinimumDualBands"
+ "MicroLocationsLocalizingMaxNumChannelsDualBands"
+ "MicroLocationsLocalizingWifiDutyCyclePercentageDualBands"
+ "MicroLocationsMinimumTotalNumberOfMeasurementsForFingerprintInCustomLoi"
+ "MicroLocationsRecordingDurationDualBands"
+ "MicroLocationsRecordingInitialDelayDualBands"
+ "MicroLocationsRecordingWifiDutyCyclePercentageDualBands"
+ "Missing previous epoch before an epoch with steps, starttime, %{public}f"
+ "Model Type BlueAtlas disabled in settings"
+ "Monitor:%@:%@::validateClientMonitoringRecords"
+ "MonitorMigraiton:%@::%@"
+ "MovingApDetector, CellOnly, received location: %{private}s, success: %s"
+ "MovingApDetector, centroid: %{private}s, Rejected by Cell Only IM: %d, Rejected by GPS IM: %d"
+ "No Name Given"
+ "Not allowed to switch to new LOI"
+ "Not in Active Location State"
+ "Nov 28 2023"
+ "Nov 28 2023 20:38:21"
+ "Output CL::Wifi1::Policies::AlsQuery::HandleEvent::operator()(const Events::Wifi::Scan &) const"
+ "Output CL::Wifi1::Policies::PrePositionCalculationStateUpdate::HandleEvent::operator()(const Events::System::LeechLocation &) const"
+ "P6MWDStepEntry CLPredictedWalkDistanceBoutDetector::createP6MWDStepEntry(const CLStepCountEntry &, const int)"
+ "Place Inference Fetch Failure"
+ "PredictedWalkDistanceBoutHistory not accessible"
+ "PredictedWalkDistanceBoutKey"
+ "PredictedWalkDistanceBoutRecordId"
+ "Q136@0:8{CLMotionActivity=iiiiiidBfdBiddii{?=b1b1b1b1b1}iidQi}16"
+ "Q264@0:8{Fence={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}ddddddddiiidQiiBiiB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{CLStrongPtr<NSUUID *>=@}{vector<CLClientLocationCoordinate, std::allocator<CLClientLocationCoordinate>>=^{?}^{?}{__compressed_pair<CLClientLocationCoordinate *, std::allocator<CLClientLocationCoordinate>>=^{?}}}}16"
+ "Received %zu buffered devices, skipped %d, last timestamp %.3lf"
+ "Received nil GUID, setting to empty"
+ "Received unsupported event in state event handler"
+ "RecordingCompletedEvent"
+ "RecordingFenceBreachedEvent"
+ "RecordingPendingState"
+ "RecordingState"
+ "RecordingThrottledState"
+ "Refresh Location on regular interval"
+ "Related LOI Fetch Failure"
+ "Request to fetch place inference timed out"
+ "Retrieved %lu records between %.0f and %.0f, includeWatchStepBouts, %d"
+ "Routine Monitor is not active"
+ "SAEW enabled,%d,country,%d,coverage,%d,optedIn,%d\n"
+ "SELECT * FROM HRRecoveryInputHRHistory WHERE startTime BETWEEN ? and ? ORDER BY startTime ASC"
+ "SELECT * FROM HRRecoveryInputWRHistory WHERE startTime BETWEEN ? and ? ORDER BY startTime ASC"
+ "SELECT * FROM HRRecoverySessionHistory WHERE startTime BETWEEN ? and ? ORDER BY startTime ASC"
+ "SELECT * FROM PredictedWalkDistanceBoutHistory WHERE endTime BETWEEN ? and ? AND boutType != ? ORDER BY startTime ASC"
+ "SELECT * from PredictedWalkDistanceBoutHistory ORDER BY startTime ASC"
+ "SELECT * from SmoothedGaitMetricsHistory ORDER BY startTime ASC"
+ "SELECT COUNT(*) FROM SmoothedGaitMetricsHistory"
+ "ScanReasonBluetoothTurnedOff"
+ "ScanReasonBluetoothTurnedOn"
+ "ScanReasonPeriodicScanTrigger"
+ "ServiceId"
+ "Setting generic workout label for Workout Recorder as: %lu"
+ "Shutting down CMHealthColdStorageWatchService"
+ "SmoothedGaitMetricsHistory"
+ "SmoothedGaitMetricsHistory not accessible"
+ "StartRecordingSessionEvent"
+ "Started Process of Activaing Geofence"
+ "Starting up CMHealthColdStorageWatchService"
+ "State Machine: Failed to handle event because current state is NULL"
+ "State Machine: Failed to handle event because it is not a valid event for the current state"
+ "State Machine: Failed to initialize state because requested state doesn't exist in the state table"
+ "State Machine: Failed to switch to new state because requested state doesn't exist in the state table"
+ "StateChangeMetrics, %@, %@"
+ "StateChangeMetrics, isInternal(%s)"
+ "StopRecordingSessionEvent"
+ "T@\"CLFenceAnalyticsManager\",N,V_fenceAnalyticsManager"
+ "T@\"CLFenceStateChangeAnalytics\",&,N,V_stateChangeAnalytics"
+ "T@\"CLLocation\",&,N,V_regionCenterLocation"
+ "T@\"CLRoutineMonitor\",&,N,V_routineMonitor"
+ "T@\"NSDate\",&,N,V_timeOfNMinusOneStateChange"
+ "T@\"NSDate\",&,N,V_timeOfNMinusTwoStateChange"
+ "T@\"NSDictionary\",&,V_otaSettings"
+ "T@\"NSMutableDictionary\",&,N,V_bins"
+ "T@\"NSMutableDictionary\",&,N,V_historicalFenceStates"
+ "T@\"NSNumber\",R,N,V_ledgerVersionNumber"
+ "T@\"NSObject<OS_dispatch_source>\",&,V_periodicScanTimer"
+ "T@\"NSString\",&,N,V_regionId"
+ "T@\"NSUUID\",&,N,V_loiIdentifier"
+ "T@?,C,V_stopScanningBlock"
+ "TB,N,V_isRunningInLocationd"
+ "TB,N,V_isSimulatingLocation"
+ "TB,N,V_scanForceScreenOffOnly"
+ "TI,R,N,V_elevationAscended"
+ "TI,R,N,V_elevationDescended"
+ "TI,R,N,V_stepCount"
+ "TI,R,N,V_stepCountGPS"
+ "TQ,R,N,V_motionActivityType"
+ "T^v,N,V_updater"
+ "Td,N,V_interval"
+ "Td,N,V_timeToInitialStateChange"
+ "Td,N,V_totalInterval"
+ "Td,R,N,V_activeTime"
+ "Td,R,N,V_distance"
+ "Td,R,N,V_distanceGPS"
+ "Td,R,N,V_endTime"
+ "Td,R,N,V_userMets"
+ "ThrottleTimerFiredEvent"
+ "Ti,N,V_currentState"
+ "Ti,N,V_nMinusOneState"
+ "Ti,N,V_nMinusThreeState"
+ "Ti,N,V_nMinusTwoState"
+ "Ti,R,N,V_boutType"
+ "Ti,R,N,V_recordId"
+ "Ti,R,N,V_userMetsSource"
+ "Tq,N,V_motionActivityConfidence"
+ "Tq,N,V_scanPeriodicInterval"
+ "Tried to setup CLMicroLocationTriggerManager with an invalid recording manager"
+ "T{CLDaemonLocation=i{?=dd}ddddddddidi{?=dd}diIiiidB},N,V_nMinusOneStateChangeLocation"
+ "T{CLDaemonLocation=i{?=dd}ddddddddidi{?=dd}diIiiidB},N,V_nMinusTwoStateChangeLocation"
+ "Unable to convert the CFString to Int value"
+ "Unexpected remaining number of sources"
+ "WifiCalc, integrity, %{public}s, confidence, %{public}d, location, %{private}s, reference multi-AP wifi, %{private}s, reference cell, %{private}s"
+ "WifiCalc, integrity, age, %{public}.1f, distance, %{public}.1f, threshold, %{public}.1f, %{public}s"
+ "WifiCalc, integrity, age, %{public}.1f, threshold, %{public}.1f, fail"
+ "WifiCalc, integrity, bumping wifi location integrity from Medium to High"
+ "WifiCalc, integrity, cell reference location unavailable"
+ "WifiCalc, integrity, incorrect cell location type, %{public}d"
+ "WifiCalc, integrity, incorrect wifi location type, %{public}d"
+ "WifiCalc, integrity, invalid location %{private}s, fail"
+ "WifiCalc, integrity, invalid reference location %{private}s, fail"
+ "WifiCalc, integrity, multi-AP wifi fix unavailable, %{public}d APs, threshold, %{public}d, fail"
+ "WifiCalc, integrity, multi-AP wifi reference location unavailable"
+ "WifiCalc, integrity, not bumping integrity %{public}s as it is not Medium"
+ "WifiCalc, integrity, updating reference cell location to %{private}s"
+ "WifiCalc, integrity, updating reference multi-AP wifi location to %{private}s"
+ "WifiCalc, warning, associated AP %{private}s server-side centroid from tile/als is moving"
+ "WifiLocationIntegrityCalculator"
+ "WorkoutActivityGenericLabel"
+ "[CLMagicMountInterface] Sending config shouldKeepRunning,%{public}u,"
+ "[CompanionSyncService] Received cold storage data of type PredictedWalkDistanceBoutKey"
+ "[CompanionSyncService] Received malformed HRRecoveryInputHRKey %@"
+ "[CompanionSyncService] Received malformed HRRecoveryInputWRKey %@"
+ "[CompanionSyncService] Received malformed HRRecoverySessionKey %@"
+ "[CompanionSyncService] Received malformed PredictedWalkDistanceBoutKey %@"
+ "[CompanionSyncService] received empty message from watch"
+ "[MagicMount][DebugLogging]rollAngle,%{public}f,landscapeAngle,%{public}f,rotationRate,(%{public}f,%{public}f,%{public}f),userAccel,(%{public}f,%{public}f,%{public}f),isStationary,%{public}u"
+ "[SmoothedGaitMetricsHistory] Database inaccessible, unable to query"
+ "[SmoothedGaitMetricsHistory] Most recent smoothed gait metrics: No recent records in database"
+ "[SmoothedGaitMetricsHistory] Most recent smoothed gait metrics: Query error"
+ "[SmoothedGaitMetricsHistory] Most recent smoothed gait metrics: unexpected return type"
+ "[SmoothedGaitMetricsProcessor]: Could not access db"
+ "[SmoothedGaitMetricsProcessor]: Processed %{public}ld gait metrics entries, resulting in %{public}ld smoothed gait metrics entries"
+ "[SmoothedGaitMetricsProcessor]: Processed smoothed gait matrics, first entry startTime : %{public}f, last entry startTime : %{public}f"
+ "[SmoothedGaitMetricsProcessor]: Skipping last entry since we may not yet have all gait metrics entries, startTime : %{public}f, now : %{public}f"
+ "[SmoothedGaitMetricsRecorderDb] Invalid SQL statement"
+ "[WatchService] Activity deferred"
+ "[WatchService] Cancelling (%{public}s) early due to deferral."
+ "[WatchService] Cannot send data, companion not nearby"
+ "[WatchService] Failed to defer activity. Current state is %{public}ld"
+ "[WatchService] Failed to mark activity as Continue. Current state is %{public}ld"
+ "[WatchService] Invalid xpc activity (%s)."
+ "[WatchService] No watch data to send"
+ "[WatchService] Sync timer fired (%{public}ld)"
+ "[WatchService] Unexpected activity (%s) state: %ld"
+ "[WatchService] Unhandled notification type, %d"
+ "[WatchService] failed to mark %{public}s activity as Done. Current state is %{public}ld"
+ "[WifiReachIntersection] no intersection for %{public}zu centroid(s) after passing pairwise intersection check %{public}f > 0; something is wrong"
+ "[WifiReachIntersection] out of bound candidate index %{public}lu from %{public}lu input centroids"
+ "[WifiReachIntersection] pairwise intersection count is more than the total possibility; something is wrong."
+ "^{CLMicroLocationLoiClient=^^?}"
+ "_activeTime"
+ "_armPeriodicScanTimer"
+ "_bluetoothIsON"
+ "_boutType"
+ "_bridgeReady"
+ "_btClient"
+ "_cancelExistingStopScanningBlock"
+ "_cancelPeriodicScanTimer"
+ "_clLocationManager"
+ "_distanceGPS"
+ "_fenceAnalyticsManager"
+ "_fenceMonitorClient"
+ "_fetchPlaceInferenceTimer"
+ "_forceCalibrate"
+ "_hasAdvertisingEnablement"
+ "_hasAdvertisingEnablement %d _hasScanningEnablement %d"
+ "_hasScanningEnablement"
+ "_historicalFenceStates"
+ "_initWithUUID:major:minor:"
+ "_isAdvertisingEnabled"
+ "_isIgneousActive"
+ "_isRunningInLocationd"
+ "_isScanningEnabled"
+ "_isSimulatingLocation"
+ "_ledgerVersionNumber"
+ "_microlocationLoiClient"
+ "_momentsDiscoverableEnabled"
+ "_momentsPeopleNearbyEnabled"
+ "_motionActivityConfidence"
+ "_motionActivityType"
+ "_motionStateProxy"
+ "_nMinusOneState"
+ "_nMinusOneStateChangeLocation"
+ "_nMinusThreeState"
+ "_nMinusTwoState"
+ "_nMinusTwoStateChangeLocation"
+ "_onEnablementStatusUpdate"
+ "_overviewId"
+ "_periodicScanTimer"
+ "_predictionUpdate:withElevation:withNextElevation:withTravelVelocity:"
+ "_regionCenterLocation"
+ "_regionId"
+ "_regionMonitor"
+ "_regionMonitorConfiguration"
+ "_runAdv"
+ "_runScan"
+ "_scanForceScreenOffOnly"
+ "_scanPeriodicInterval"
+ "_startTimedScanningWithReason with unknown reason %ld!"
+ "_stateChangeAnalytics"
+ "_stepCount"
+ "_stepCountDb"
+ "_stepCountGPS"
+ "_stopScanning"
+ "_stopScanningBlock"
+ "_timeOfNMinusOneStateChange"
+ "_timeOfNMinusTwoStateChange"
+ "_timeToInitialStateChange"
+ "_timestampOfLastBufferedDevice"
+ "_totalInterval"
+ "_updater"
+ "_visitGnssAWD"
+ "_waitingOnLocationUpdate"
+ "addConditionForMonitoring:identifier:"
+ "addInterval:"
+ "addInterval:type:confidence:"
+ "addNewTruthLabelToModelIfAppropriate: model has no LSL or Blue Atlas data"
+ "adjustedDistance"
+ "adjustedDistanceToFenceBoundary"
+ "alsRequestReasonsTally metrics nothing to submit"
+ "apScores.size() == maxSources"
+ "apple"
+ "applyRecentChangesToModel, model has no LSL or Blue Atlas data"
+ "applyRecentLabelsToBlueAtlasModel, model has no Blue Atlas data"
+ "applyRecentLabelsToBlueAtlasModel, no current model"
+ "applyRecentLabelsToBlueAtlasModel, tried to apply a label which is already in the LSL"
+ "apsInScanGroup"
+ "apsWithLocationInScanGroup"
+ "apsWithoutLocationInScanGroup"
+ "auto CLMiLoService::generationAlgorithmByServiceAndLocationType(CLMiLoServiceType, CLMiLoLocationTypeEnum)::(anonymous class)::operator()(CLMicroLocationAlgorithms::LearnerType) const"
+ "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoCustomLoiTable, MemberFn = bool (CLMiLoCustomLoiTable::*)(const std::string &, const boost::uuids::uuid &), Args = <const std::string &, const boost::uuids::uuid &>]"
+ "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoCustomLoiTable, MemberFn = std::vector<boost::uuids::uuid> (CLMiLoCustomLoiTable::*)(unsigned int), Args = <unsigned int &>]"
+ "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoCustomLoiTable, MemberFn = std::vector<std::string> (CLMiLoCustomLoiTable::*)(const boost::uuids::uuid &), Args = <const boost::uuids::uuid &>]"
+ "auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMiLoServiceTable, MemberFn = bool (CLMiLoServiceTable::*)(boost::uuids::uuid, unsigned long long), Args = <boost::uuids::uuid &, unsigned long long &>]"
+ "binForNumber:bins:"
+ "bins"
+ "binsSortedByInterval"
+ "bool CLActivityRecorderDb<HRRecoveryInputWR, CLActivityDB::ClassBDataProtectionPolicy>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = HRRecoveryInputWR, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]"
+ "bool CLGnssAWD::initializeGnssDailyUseMetricsAtEventStart(const GNSS::GnssSessionEventType)"
+ "bool CLGnssAWD::initializeGnssSessionDataAtEventStart(const DailyUseMetricsContext, const GNSS::GnssSessionEventType)"
+ "bool CLGnssAWD::updateGnssDailyUseMetricsAtEventEnd(const GNSS::GnssSessionEventType)"
+ "bool CLGnssAWD::updateGnssSessionDataAtEventEnd(const DailyUseMetricsContext, const GNSS::GnssSessionEventType)"
+ "bool CLKappaNotifier::shouldEnableIgneous()"
+ "bool CLKappaNotifier::shouldTriggerIgneous()"
+ "bool CLMiLoCustomLoiTable::addServiceToCustomLoiMapping(const std::string &, const boost::uuids::uuid &)"
+ "bool CLMiLoCustomLoiTable::insertOrReplace(const std::vector<CLMiLoCustomLoiTable::Entry> &)"
+ "bool CLMiLoCustomLoiTable::removeServiceToCustomLoiMapping(const std::string &, const boost::uuids::uuid &)"
+ "bool CLMiLoServiceTable::updateServiceLocationTypes(boost::uuids::uuid, uint64_t)"
+ "bool CLMicroLocationLoiManager::refreshRoutineStateAtLocation(double, double)"
+ "bool CLMobility::SmoothedGaitMetricsProcessor::processGaitMetrics()"
+ "bool CLPlaceInferenceSubscription::sendLastLocation()"
+ "bool CLPredictedWalkDistanceCompanionSyncManager::queryLatestRecords(NSMutableDictionary *)"
+ "bool CLSafetyAnomalySubscription::sanityChecksForKappa(std::shared_ptr<CLConnectionMessage>)"
+ "bool CLWifiReachIntersection::ReachIntersection::removeCentroidIndicesWithNestedAps(std::vector<size_t> &)"
+ "bothCrossCheckersMatch"
+ "btclient not run: _iCloudSignedIn %d _bluetoothIsON %d"
+ "btclient run"
+ "calculateScoreForValue"
+ "canAddToMonitor"
+ "cellCrossCheckDistanceThreshold"
+ "centralManagerDidUpdateState %ld"
+ "com.apple.Geofence.StateChange.StateChangeExternal"
+ "com.apple.Geofence.StateChange.StateChangeInternal"
+ "com.apple.MicroLocation.CustomLoiCreation"
+ "com.apple.MicroLocation.CustomLoiVisitEvent"
+ "com.apple.MicroLocation.LOIFailures"
+ "com.apple.igneous.disableIgneousWithDelay"
+ "com.apple.igneous.enableIgneous"
+ "com.apple.igneous.enableIgneousWithDelay"
+ "com.apple.locationd.alsrequestreasontally"
+ "com.apple.locationd.crosscheckmismatchcode"
+ "com.apple.locationd.position.GnssDailyPowerAnalyticsWithContext"
+ "com.apple.locationd.position.GnssPowerAnalyticMetrics"
+ "com.apple.wifiPositionCalculatorWithReachIntersection.availability"
+ "configuration != nullptr"
+ "convertMonitoringEventToGeofenceState:"
+ "createMetricsDict:isInternal:"
+ "createdCustomLoi"
+ "custom"
+ "customLoiVisitOccurred"
+ "dailyClientGnssDisplayOffInsideVisitSeconds"
+ "dailyClientGnssDisplayOffOutsideVisitSeconds"
+ "dailyClientGnssDisplayOnInsideVisitSeconds"
+ "dailyClientGnssDisplayOnOutsideVisitSeconds"
+ "dailyDebouncePeriodDisplayOffInsideVisitSeconds"
+ "dailyDebouncePeriodDisplayOffOutsideVisitSeconds"
+ "dailyDebouncePeriodDisplayOnInsideVisitSeconds"
+ "dailyDebouncePeriodDisplayOnOutsideVisitSeconds"
+ "dailyGnssUsageWithShortOrWiFiAssociatedSessionsSeconds"
+ "derivedEventData != __null"
+ "did not _startAdvertising: advertiser %@ _hasAdvertisingEnablement %d featureFlag %d _bluetoothIsON %d _iCloudSignedIn %d"
+ "did not _stopAdvertising (null)"
+ "distanceFromNMinusOneStateChange"
+ "distanceFromNMinusTwoStateChange"
+ "dominantMotionState"
+ "effectiveRadius"
+ "enable MiLo at current location called for a service which is not currently connected"
+ "enable MiLo at current location, called without configuration"
+ "enable MiLo at current location, called without connectionToken"
+ "enable MiLo at current location, called without requestId"
+ "enable MiLo at current location, called without service identifier"
+ "enableMiLoAtCurrentLocation"
+ "enableMiLoAtCurrentLocationWithServiceIdentifier:withRequestIdentifier:configuration:connectionToken:"
+ "entryRadius"
+ "enumerate locations fetched from DB,taskType,%lu,timestamp,%f,elevation,%f,verticalAccuracy,%f,lat,%f,lon,%f,horizontalAccuracy,%f"
+ "enumerateObjectsWithOptions:usingBlock:"
+ "error on DAS,%s,now,%f"
+ "estimateTrueEventTime"
+ "evalScanForceScreenOffOnly"
+ "eventCfTimeSec"
+ "eventStatus"
+ "eventTypeNMinusOneStateChange"
+ "eventTypeNMinusTwoStateChange"
+ "exitRadius"
+ "extendScanRequest"
+ "extractAnalyticsFromNotification:isInternal:"
+ "fAllowOutdoorServiceNotifications,"
+ "fBoutRecorderDb"
+ "fEntitlementDict[@\"com.apple.developer.corelocation.wilderness-safety\"] != nullptr"
+ "fEntitlementDict[@\"com.apple.locationd.transcript-session\"] != nullptr"
+ "fHRRSyncManager"
+ "fPredWalkDistanceBoutDb"
+ "fPredWalkDistanceSyncManager"
+ "fRoutineMonitor != nullptr"
+ "fSmoothedGaitMetricsAggregator"
+ "fSmoothedGaitMetricsDb"
+ "fSmoothedGaitMetricsProcessor"
+ "failureReason"
+ "failureType"
+ "feedRhythmicGnssStatus,eventType,%{public}d,eventStatus,%{public}d"
+ "fenceAnalyticsManager"
+ "fenceCategoryForFence:"
+ "fenceCategoryType"
+ "fenceEventType:"
+ "fenceSizeForFence:"
+ "fetchAdvertisementsDetailedWithCompletion SPI disabled"
+ "fetchAdvertisementsWithCompletion SPI disabled"
+ "fetchDominantMotionActivityInInterval:"
+ "fetchIsSaewEnabledOnQueue:withReply:"
+ "fetchLocationOfInterestAtLocation:"
+ "fetchLocationOfInterestForFence:"
+ "fetchLocationSystemState"
+ "fetchMotionActivitiesInInterval:"
+ "fetchPlaceInferenceAtCurrentLocation"
+ "fetchPlaceInferenceAtCurrentLocation, timed out waiting for fetching place inference, this shouldn't happen"
+ "fetchRelatedLoisForLoi:"
+ "fetchStepCountInInterval:"
+ "finish on DAS,%s,now,%f"
+ "forceTriggerIgneous:"
+ "fsmStateDuringFailure"
+ "generateGeofenceUpdateToClient:"
+ "generateLocationManagerNotAvailableError"
+ "generateRegionMonitorNotAvailableError"
+ "geofenceLocationHorizontalAccuracy"
+ "geofenceLocationVerticalAccuracy"
+ "get run time on DAS,%s,now,%f"
+ "getAllActiveGeofences"
+ "getCurrentLocation"
+ "getSettings:fallback:"
+ "getSpiEnablementStatus"
+ "getStateForSetting:"
+ "getTravelVelocity:withCurrLocation:andNextLocation:"
+ "hUncAfterLocation"
+ "hUncAfterLocationConservative"
+ "hUncBeforeLocation"
+ "handleMessageSafetyAnomalyNotification, retrieved guid %s"
+ "hasLoiAtFence"
+ "historicalFenceStateForFence:"
+ "historicalFenceStates"
+ "initActivityHistogramWithActivities:dateInterval:"
+ "initFromClientCondition:clientKeyPath:authorizationContext:universe:identifier:callbackHandler:"
+ "initFromClientCondition:clientKeyPath:authorizationContext:universe:identifier:removePersistingFenceFromMonitoring:callbackHandler:"
+ "initRecordWithCondition:identifier:options:initialState:"
+ "initWithClientMonitoringRecord:clientKeyPath:authorizationContext:universe:identifier:initForStopMonitoring:callbackHandler:"
+ "initWithCurrentState:previousState:"
+ "initWithGnssAWD:"
+ "initWithIdentifier:andType:"
+ "initWithInterval:motionActivityType:motionActivityConfidence:"
+ "initWithName:path:onQueue:eventHandler:useMonitorQueueForVendingMonitor:vendingHandler:"
+ "initWithPredictedWalkDistanceBoutEntry:"
+ "initWithQueue:advStore:btClient:"
+ "initWithQueue:withSettings:withPolicy:"
+ "initWithRecordId:startTime:mets:gradeType:grade:userMets:userMetsSource:"
+ "initWithUniverse:fenceAnalyticsManager:"
+ "initialize Igneous arm status,0"
+ "initialize Igneous maxArmMin,%d,maxScheduledArmSec,%f"
+ "inject AOP trigger %d %d %d, delayUsec %d"
+ "int CLActivityRecorderDb<CLMobility::SmoothedGaitMetrics, CLActivityDB::ClassBDataProtectionPolicy>::estimateRecordsNeeded(const CLAggregationRules &) [T = CLMobility::SmoothedGaitMetrics, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]"
+ "invalidateFetchPlaceInferenceTimer"
+ "isConservativeEntry"
+ "isHelperFence"
+ "isInRoomDetectionEnabled"
+ "isOriginalLocUsedAfterUseOfReachIntersectionConservative"
+ "isRunningInLocationd"
+ "isSaewEnabledAsync invalid context"
+ "isSaewEnabledSync:"
+ "isSimulatingLocation"
+ "iterateAllIdentitiesForAnchor:withBlock:"
+ "iterator != fServices.end()"
+ "kCLConnectionMessageMiLoEnableMiLoAtCurrentLocation"
+ "kCLConnectionMessageMiLoEnableMiLoAtCurrentLocation incorrect dictionary"
+ "kCLConnectionMessageRemoveCustomLOI"
+ "kCLConnectionMessageSafetyAnomalyNotify"
+ "kCLLedgerVersionNumber"
+ "kTypeMotorcycle"
+ "keyPath:sharesAuthWithKeyPath:"
+ "lastHandledLocationAccuracy"
+ "lastHandledLocationAge"
+ "lastHandledLocationProvider"
+ "learnBlueAtlasModel"
+ "ledgerVersionNumber"
+ "loiRelatedFailureOccurred"
+ "long CLActivityAggregator<CLMobility::SmoothedGaitMetrics, CLActivityDB::ClassBDataProtectionPolicy>::aggregateRecords() [T = CLMobility::SmoothedGaitMetrics, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]"
+ "markScanEndTimeFromBoot:withReason:withPolicy:"
+ "markScanStartTimeFromBoot:withReason:withRate:"
+ "masqueradeBundleId:"
+ "minNumAps"
+ "mobilitySmoothedGaitMetrics"
+ "model.modelType == CLMicroLocationProto::Model::BLUE_ATLAS"
+ "modelTypeByServiceAndLocationType"
+ "monitoredIdentifier"
+ "motionActivityConfidence"
+ "motionActivityType"
+ "motionStateAfterNMinusOneStateChange"
+ "motionStateAfterNMinusTwoStateChange"
+ "motionStateBeforeNMinusOneStateChange"
+ "motionStateBeforeStateChange"
+ "motionTypeFromCLMotionActivity:"
+ "motionTypeFromMotionActivity:"
+ "mslp uncertainty model,deltaMslpDue2TimeAndDistance,%f,pressure2MslpFactor,%f,estBaroModelUncReflectedInMslp,%f,deltaPressure,%f,travelVelocity,%f,timeDifference,%f,slopeDiffDElevationDPressure,%f,dHdMslp,%f"
+ "multiApWifiCrossCheckDistanceThreshold"
+ "nMinusOneState"
+ "nMinusOneStateChangeLocation"
+ "nMinusOneStateChangeLocationAccuracy"
+ "nMinusThreeState"
+ "nMinusTwoState"
+ "nMinusTwoStateChangeLocation"
+ "nMinusTwoStateChangeLocationAccuracy"
+ "no change to advertising status"
+ "no change to scanning status"
+ "not _startPermanentScanning: s.scanEnabled %d, _bluetoothIsON %d, _hasScanningEnablement %d, _screenIsON %d, s.forceScreenOffOnly %d"
+ "not _startTimedScanningWithReason %s, s.scanEnabled %d, _hasScanningEnablement %d, _bluetoothIsON %d _screenIsON %d, timeSinceLastTimedScan %.1f, s.forceScreenOffOnly %d"
+ "numCustomLoiIds"
+ "numOfInputCentroids"
+ "numberOfAlsApsUsedInHorizontalCalculation"
+ "numberOfApsInDatabasesButNoValidCentroid"
+ "numberOfApsTotal"
+ "numberOfApsWithNoCentroidInformation"
+ "numberOfApsWithValidCentroids"
+ "numberOfApsWithoutValidCentroids"
+ "numberOfTileApsUsedInHorizontalCalculation"
+ "onCustomLoiRecordingSessionCompleted while current LOI is not custom"
+ "onMonitorNotification:data:"
+ "onMotionStateNotification"
+ "onStateChange:%d forSetting:%d"
+ "onStateChange:forSetting:"
+ "otaSettings"
+ "outdoorUpdate"
+ "pairwiseIntersectionRatio"
+ "percentApsInDatabasesButNoValidCentroid"
+ "percentApsInScanGroupUsedInLocation"
+ "percentApsUsedInHorizontalCalculation"
+ "percentApsWithLocationInScanGroup"
+ "percentApsWithLocationUsedInLocation"
+ "percentApsWithNoCentroidInformation"
+ "percentApsWithValidCentroids"
+ "percentApsWithValidCentroidsUsedInHorizontalCalculation"
+ "percentApsWithoutLocationInScanGroup"
+ "percentApsWithoutValidCentroids"
+ "performMigration"
+ "periodicScanTimer"
+ "previousLocationAccuracy"
+ "previousLocationAge"
+ "previousLocationProvider"
+ "q24@?0@\"CLFenceAnalyticsMotionActivityHistogramBin\"8@\"CLFenceAnalyticsMotionActivityHistogramBin\"16"
+ "reachabilityStatus"
+ "receive mobile assets,igneousMaxArmMinutes,%d"
+ "receive mobile assets,igneousMaxScheduledArmSec,%f"
+ "receive mobile assets,igneousTriggerProbability,%f"
+ "received force trigger,uid,%s"
+ "recordingManager"
+ "referenceLocationAgeThreshold"
+ "refillAwaitingMonitoringConditions:"
+ "region"
+ "regionCenterLocation"
+ "regionId"
+ "regionMonitor:didGenerateEvent:"
+ "register on DAS,%s,now,%f,delay,%lld"
+ "rehydrationPayload"
+ "rejectedByCellCrossCheck"
+ "rejectedByGpsCrossCheck"
+ "removeConditionFromMonitoringWithIdentifier:"
+ "removeGeofenceWithRegionId:"
+ "removeGeofencesNearLocationWithLatitude:andLongitude:"
+ "renewed Igneous random arm session,now,%{public}f,delay,%{public}f,startTime,%{public}f,endTime,%{public}f"
+ "replenish Igneous arm minutes,%{public}d,timestamp,%{public}f"
+ "request remove custom Loi service identifier"
+ "request to stop scanning for AOP path due to screen on transition "
+ "request to stop scanning for non-AOP path due to screen on transition "
+ "requestBootstrapWithLastGeofenceStates"
+ "requestLocation"
+ "requestMonitorWithConfiguration:completion:"
+ "requestRemoveCustomLoi"
+ "requestRemoveCustomLoiWithServiceIdentifier:withRequestIdentifier:withLoiIdentifier:withConnectionToken:"
+ "resetDaemonPartOfCondition"
+ "resetHistoricalStates"
+ "retrieveAllActiveGeofences"
+ "saEnablementStateInCountry"
+ "saEnablementStateInCoverageArea"
+ "saEnablementStateOptedIn"
+ "saved Igneous arm minutes,%{public}d,now,%{public}f"
+ "scanForceScreenOffOnly"
+ "scanPeriodicInterval"
+ "scanning enablement overall %d, _hasAdvertisingEnablement %d, peopleNearbyEnabled %d, safetyAlertEnabled %d"
+ "scanning is ongoing due to non-nil stopScanningBlock"
+ "screen wake monitor installed unexpectedly"
+ "self.monitoredIdentifiers.count == 0"
+ "setEstimatedStateProbabilityOutdoor:"
+ "setFenceAnalyticsManager:"
+ "setGeofenceAtLocation:"
+ "setHistoricalFenceStates:"
+ "setInterval:"
+ "setIsRunningInLocationd:"
+ "setLedgerVersionNumber:"
+ "setLoiIdentifier:"
+ "setMctTimestamp:"
+ "setMicroLocationLoiClient:"
+ "setMotionActivityConfidence:"
+ "setNMinusOneState:"
+ "setNMinusOneStateChangeLocation:"
+ "setNMinusThreeState:"
+ "setNMinusTwoState:"
+ "setNMinusTwoStateChangeLocation:"
+ "setOtaSettings:"
+ "setOutdoorUpdate:"
+ "setPath:"
+ "setPeriodicScanTimer:"
+ "setRegionCenterLocation:"
+ "setRegionId:"
+ "setScanForceScreenOffOnly:"
+ "setScanPeriodicInterval:"
+ "setStateChangeAnalytics:"
+ "setStopScanningBlock:"
+ "setTimeOfNMinusOneStateChange:"
+ "setTimeOfNMinusTwoStateChange:"
+ "setTimeToInitialStateChange:"
+ "setTotalInterval:"
+ "setUpdater:"
+ "settledState"
+ "setupCustomLoiRecordingManager"
+ "setupDaemonPartOfConditionWithAuthContext:clientKeyPath:universe:identifier:stopMonitoring:callbackHandler:"
+ "setupEnablementStatus"
+ "shouldEnableIgneous, %{public}u, %{public}u, %{public}u, %{public}u, %{public}u, %{public}u, %{public}u, %{public}u"
+ "shouldMigrate"
+ "shouldTriggerIgneous,%d,TriggerProb,%f"
+ "startVisitMonitoring"
+ "starting custom LOI recording scan"
+ "stateChangeAnalytics"
+ "stateFunction"
+ "static CLLocationIntegrity CLWifiLocationIntegrityCalculator::calculateLocationIntegrity(const CLDaemonLocation &, const CL::Wifi1::Types::ComputedLocation &, const CLDaemonLocation &)"
+ "static CLMicroLocationProto::Model_GenerationAlgorithm CLMiLoService::generationAlgorithmByServiceAndLocationType(CLMiLoServiceType, CLMiLoLocationTypeEnum)"
+ "static bool CLFenceMonitorLogic::getStatusFromLocation(const CLDaemonLocation &, const CLFenceManager_Type::Fence &, const CLFenceMonitorLogic::FenceMonitoringStatus &, const double, const bool, CLFenceMonitorLogic::FenceMonitorAnalytics &)"
+ "static bool CLWifiLocationIntegrityCalculator::shouldBumpLocationIntegrity(const CLDaemonLocation &, const CL::Wifi1::Types::ComputedLocation &, const CLDaemonLocation &)"
+ "static bool CLWifiLocationIntegrityCalculator::shouldBumpLocationIntegrity(const CLDaemonLocation &, const CLDaemonLocation &, const double)"
+ "static double CLWifiReachIntersection::ReachIntersection::computePairwiseIntersectionRatio(const std::shared_ptr<ReachIntersectionInputCentroids> &, const std::set<size_t> &)"
+ "std::is_sorted(valueThresholds.begin(), valueThresholds.end(), [descending](auto th1, auto th2) { if (descending) return th1 > th2; else return th1 < th2; })"
+ "std::optional<std::string> CLMicroLocationLoiManager::EnableCustomLoiWhileInHomeLoi(const CLMiLoLoiManagerEnableCustomLoiEvent *)"
+ "std::optional<std::string> CLMicroLocationLoiManager::FailedToFetchedPlaceInference(const CLMiLoLoiManagerFailedToFetchPlaceInference *)"
+ "std::optional<std::string> CLMicroLocationLoiManager::HandleLeechedLocation(const CLMiLoLoiManagerLeechedLocationEvent *)"
+ "std::optional<std::string> CLMicroLocationLoiManager::LoiForGivenLocation(const CLMiLoLoiManagerReceivedLoiForLocationEvent *)"
+ "std::optional<std::string> CLMicroLocationLoiManager::SuccessfullyFetchedPlaceInference(const CLMiLoLoiManagerFetchedPlaceInference *)"
+ "std::optional<std::string> CLMicroLocationLoiManager::VisitEntry(const CLMiLoLoiManagerLoiVisitEntryEvent *)"
+ "std::string CLMicroLocationLoiManager::convertPlaceInferenceUserPlaceTypeToString(_CLPlaceInferenceUserSpecificPlaceType)"
+ "std::string CLMicroLocationLoiManager::convertRTLocationOfInterestTypeToString(RTLocationOfInterestType)"
+ "std::string CLMicroLocationLoiManager::handleEnableCustomLoi(CLMiLoService::ServiceUuid)"
+ "std::vector<boost::uuids::uuid> CLMiLoCustomLoiTable::getAllCustomLoiIds(uint32_t)"
+ "std::vector<std::string> CLMiLoCustomLoiTable::getAllServicesEnabledAtCustomLoiId(const boost::uuids::uuid &)"
+ "stepsSinceNMinusOneStateChange"
+ "stepsSinceNMinusTwoStateChange"
+ "stopScanningBlock"
+ "submitAllMetricsFromNotification:"
+ "tally"
+ "term1 %f, dElevationdPresure(pmeas) %f std::abs(_pressureUncertainty) %f pmeas %f"
+ "term2 %f, slopeDiffDElevationDPressure(pbias) %f std::abs(pressure - _biasPressure) %f"
+ "term3 %f, slopeDiffDElevationDPressure(pmeas) %f std::abs(_pressureUncertainty %f"
+ "timeOfNMinusOneStateChange"
+ "timeOfNMinusTwoStateChange"
+ "timeSinceDominantActivityChange"
+ "timeSinceMotionActivityChange"
+ "timeSinceNMinusOneStateChange"
+ "timeSinceNMinusTwoStateChange"
+ "timeSinceWifiRoam"
+ "timeToInitialStateChange"
+ "totalDailyClientGnssUsageSeconds"
+ "totalDailyExclusiveProactiveGnssSeconds"
+ "totalDailyGnssDebounceSeconds"
+ "totalDailyGnssUsageSeconds"
+ "totalDailyProactiveGnssUsageSeconds"
+ "totalInterval"
+ "totalProactiveGnssInADay_s"
+ "traceAllowOutdoorServiceNotifications"
+ "truncated force trigger uid from %s to %s"
+ "uint32_t CL::Wifi1::Policies::PositionCalculation::percentage(uint32_t, uint32_t, uint32_t)"
+ "unregister on DAS,%s"
+ "update AOP arm status,%{public}u, %{public}u, %{public}u, %{public}u"
+ "updateConfidence:"
+ "updateCurrentState:previousState:"
+ "updateHistoricalFenceStateFromStateChange:previousStatus:currentStatus:"
+ "updateHistoricalMeanSeaLevelPressureArray:withRebaseTag:withForceTag:"
+ "updateTimeToInitialStateChange:"
+ "updateTimeToInitialStateChangeForFence:previousStatus:timeOfStateChange:"
+ "updater"
+ "v108@0:8i16{NotificationData=i{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}Bi}20"
+ "v16@?0@\"CLClientKeyPath\"8"
+ "v16@?0@\"CLMonitor\"8"
+ "v1840@0:8{NotificationData={Fence={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}ddddddddiiidQiiBiiB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{CLStrongPtr<NSUUID *>=@}{vector<CLClientLocationCoordinate, std::allocator<CLClientLocationCoordinate>>=^{?}^{?}{__compressed_pair<CLClientLocationCoordinate *, std::allocator<CLClientLocationCoordinate>>=^{?}}}}{Fence={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}ddddddddiiidQiiBiiB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{CLStrongPtr<NSUUID *>=@}{vector<CLClientLocationCoordinate, std::allocator<CLClientLocationCoordinate>>=^{?}^{?}{__compressed_pair<CLClientLocationCoordinate *, std::allocator<CLClientLocationCoordinate>>=^{?}}}}{CLDaemonLocation=i{?=dd}ddddddddidi{?=dd}diIiiidB}id{FenceMonitorAnalytics=i{CLFenceAnalyticsGeofenceEventTimes=Bdddddddddddddd}d{Fence={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}ddddddddiiidQiiBiiB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{CLStrongPtr<NSUUID *>=@}{vector<CLClientLocationCoordinate, std::allocator<CLClientLocationCoordinate>>=^{?}^{?}{__compressed_pair<CLClientLocationCoordinate *, std::allocator<CLClientLocationCoordinate>>=^{?}}}}{CLDaemonLocation=i{?=dd}ddddddddidi{?=dd}diIiiidB}{CLDaemonLocation=i{?=dd}ddddddddidi{?=dd}diIiiidB}{CLDaemonLocation=i{?=dd}ddddddddidi{?=dd}diIiiidB}iiiddddddd{CLMotionActivity=iiiiiidBfdBiddii{?=b1b1b1b1b1}iidQi}{CLMotionActivity=iiiiiidBfdBiddii{?=b1b1b1b1b1}iidQi}}}16"
+ "v1844@0:8i16{NotificationData={Fence={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}ddddddddiiidQiiBiiB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{CLStrongPtr<NSUUID *>=@}{vector<CLClientLocationCoordinate, std::allocator<CLClientLocationCoordinate>>=^{?}^{?}{__compressed_pair<CLClientLocationCoordinate *, std::allocator<CLClientLocationCoordinate>>=^{?}}}}{Fence={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}ddddddddiiidQiiBiiB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{CLStrongPtr<NSUUID *>=@}{vector<CLClientLocationCoordinate, std::allocator<CLClientLocationCoordinate>>=^{?}^{?}{__compressed_pair<CLClientLocationCoordinate *, std::allocator<CLClientLocationCoordinate>>=^{?}}}}{CLDaemonLocation=i{?=dd}ddddddddidi{?=dd}diIiiidB}id{FenceMonitorAnalytics=i{CLFenceAnalyticsGeofenceEventTimes=Bdddddddddddddd}d{Fence={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}ddddddddiiidQiiBiiB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{CLStrongPtr<NSUUID *>=@}{vector<CLClientLocationCoordinate, std::allocator<CLClientLocationCoordinate>>=^{?}^{?}{__compressed_pair<CLClientLocationCoordinate *, std::allocator<CLClientLocationCoordinate>>=^{?}}}}{CLDaemonLocation=i{?=dd}ddddddddidi{?=dd}diIiiidB}{CLDaemonLocation=i{?=dd}ddddddddidi{?=dd}diIiiidB}{CLDaemonLocation=i{?=dd}ddddddddidi{?=dd}diIiiidB}iiiddddddd{CLMotionActivity=iiiiiidBfdBiddii{?=b1b1b1b1b1}iidQi}{CLMotionActivity=iiiiiidBfdBiddii{?=b1b1b1b1b1}iidQi}}}20"
+ "v20@?0B8@\"NSDictionary\"12"
+ "v24@0:8^{CLMicroLocationLoiClient=^^?}16"
+ "v24@?0@\"CLMonitor\"8@\"CLMonitoringEvent\"16"
+ "v276@0:8{Fence={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}ddddddddiiidQiiBiiB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{CLStrongPtr<NSUUID *>=@}{vector<CLClientLocationCoordinate, std::allocator<CLClientLocationCoordinate>>=^{?}^{?}{__compressed_pair<CLClientLocationCoordinate *, std::allocator<CLClientLocationCoordinate>>=^{?}}}}16i264d268"
+ "v32@?0@\"CMMotionActivity\"8Q16^B24"
+ "v40@0:8^d16@24@32"
+ "v40@0:8d16Q24q32"
+ "v40@?0@\"NSString\"8@\"CLCondition\"16Q24@\"CLCondition\"32"
+ "v48@0:8@\"NSUUID\"16@\"NSUUID\"24@\"CLMiLoCustomLoiConfiguration\"32@\"NSUUID\"40"
+ "v48@0:8@\"NSUUID\"16@\"NSUUID\"24@\"NSString\"32@\"NSUUID\"40"
+ "v48@0:8@16@24@32d40"
+ "v60@0:8@16@24@32@40B48@?52"
+ "validAfterLocation"
+ "validAfterLocationConservative"
+ "validBeforeLocation"
+ "validGpsLocation"
+ "valueThresholds.size() == scores.size()"
+ "vehicleType"
+ "virtual CLMicroLocationAlgorithms::LocalizerResults CLMicroLocationCosineSimilarityLocalizationAlgorithm::localize(const CLMicroLocationModel &, const CLMicroLocationFingerprint &, const std::optional<CLMicroLocationFingerprintDistanceFunction::Signature> &, const CLMicroLocationLocalizationSettings &, std::optional<boost::uuids::uuid> *, std::optional<CLMicroLocationProto::AssociatedAccessPointInfo>) const"
+ "virtual CMError CLHRRecoveryInputHRRecorderDb::queryHRRecoveryInputHRAllRecords(std::vector<HRRecoveryInputHR> &) const"
+ "virtual CMError CLHRRecoveryInputHRRecorderDb::queryHRRecoveryInputHRInTimeRange(CFAbsoluteTime, CFAbsoluteTime, std::vector<HRRecoveryInputHR> &) const"
+ "virtual CMError CLHRRecoveryInputWRRecorderDb::queryHRRecoveryInputWRAllRecords(std::vector<HRRecoveryInputWR> &) const"
+ "virtual CMError CLHRRecoveryInputWRRecorderDb::queryHRRecoveryInputWRInTimeRange(CFAbsoluteTime, CFAbsoluteTime, std::vector<HRRecoveryInputWR> &) const"
+ "virtual CMError CLHRRecoverySessionRecorderDb::queryHRRecoverySessionAllRecords(std::vector<HRRecoverySession> &) const"
+ "virtual CMError CLHRRecoverySessionRecorderDb::queryHRRecoverySessionInTimeRange(CFAbsoluteTime, CFAbsoluteTime, std::vector<HRRecoverySession> &) const"
+ "virtual CMError CLMobility::SmoothedGaitMetricsRecorderDb::mostRecentSmoothedGaitMetrics(SmoothedGaitMetrics &) const"
+ "virtual CMError CLMobility::SmoothedGaitMetricsRecorderDb::querySmoothedGaitMetricsInTimeRange(CFAbsoluteTime, CFAbsoluteTime, std::vector<SmoothedGaitMetrics> &) const"
+ "virtual CMError CLPredictedWalkDistanceBoutRecorderDb::queryBoutAllRecords(std::vector<CLPredictedWalkDistanceBoutEntry> &) const"
+ "virtual CMError CLPredictedWalkDistanceBoutRecorderDb::queryBoutDataInTimeRange(CFAbsoluteTime, CFAbsoluteTime, std::vector<CLPredictedWalkDistanceBoutEntry> &, bool) const"
+ "virtual bool CLActivityRecorderDb<CLMobility::SmoothedGaitMetrics, CLActivityDB::ClassBDataProtectionPolicy>::setDatabaseAccessible() [T = CLMobility::SmoothedGaitMetrics, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]"
+ "virtual void CLActivityRecorderDb<CLMobility::SmoothedGaitMetrics, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndStoreRecordUL(const T &, bool) [T = CLMobility::SmoothedGaitMetrics, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]"
+ "virtual void CLMicroLocationLogic::onEnableMiLoAtCurrentLocationCompleted(const CLMiLoConnectionErrorCode, const boost::uuids::uuid &, const CLMiLoService::ConnectionUuid &)"
+ "virtual void CLMicroLocationLoiManager::handleFetchedLocationOfInterestAtLocation(CLMicroLocationLoi *, CLLocation *, NSError *)"
+ "virtual void CLMicroLocationLoiManager::handleFetchedPlaceInferences(NSArray<_CLPlaceInference *> *, NSError *)"
+ "virtual void CLMicroLocationLoiManager::handleVisitNotification(CLVisit *)"
+ "virtual void CLMicroLocationNotifier::deregisterForLeechedLocationUpdates()"
+ "virtual void CLMicroLocationNotifier::registerForLeechedLocationUpdates()"
+ "virtual void CLMobility::SmoothedGaitMetricsRecorderDb::insertRecordUL(const SmoothedGaitMetrics &, bool)"
+ "visitEventType"
+ "void CL::Wifi1::Policies::PrePositionCalculationStateUpdate::submitAlsRequestReasonsTally(Types::HeartbeatMetrics &)"
+ "void CLActivityAggregator<CLMobility::SmoothedGaitMetrics, CLActivityDB::ClassBDataProtectionPolicy>::setExpirationRule(CFTimeInterval) [T = CLMobility::SmoothedGaitMetrics, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]"
+ "void CLDaemonStats::submitMetric(const CLDaemonStats_Type::GnssPowerAnalyticsData &)"
+ "void CLGatheringRoutineOTASubscription::onMobileAssetNotification(int, const CLMobileAssetManager_Type::Notification &, const CLMobileAssetManager_Type::NotificationData &)"
+ "void CLGnssAWD::handleDisplayEventForCA()"
+ "void CLGnssAWD::handleGnssSessionEventForAnalytics(const GNSS::GnssSessionEventType, const bool)"
+ "void CLGnssAWD::onVisit(const CLVisit *)"
+ "void CLGnssAWD::submitGnssDailyUseMetricsOnDayChange()"
+ "void CLGnssController::feedRhythmicGnssStatus(const CLLocationProvider_Type::CLRhythmicGnssStatusUpdate &)"
+ "void CLHRRecoveryEstimator::feedCalorieUpdate(CFAbsoluteTime, double, GradeType, double, double, CLMetsSource)"
+ "void CLKappaNotifier::checkSaewEnablement()_block_invoke"
+ "void CLKappaNotifier::initIgneousConfig()"
+ "void CLKappaNotifier::injectTrigger(CMMotionCoprocessorCommand::Kappa::Trigger)"
+ "void CLKappaNotifier::saveIgneousArmMinutes()"
+ "void CLKappaNotifier::scheduleRandomArmSessionIgneous()"
+ "void CLKappaNotifier::scheduleXPCTaskIgneous(const char *, const int64_t)_block_invoke"
+ "void CLKappaNotifier::updateAOPArmStatus(CMMotionCoprocessorCommand::Kappa::On)"
+ "void CLMiLoCustomLoiTable::initTable()"
+ "void CLMiLoService::addNewTruthLabelToModelIfAppropriate(const boost::uuids::uuid &, const boost::uuids::uuid &)"
+ "void CLMiLoService::applyRecentChangesToModel()"
+ "void CLMicroLocationLearner::learnBlueAtlasModelWorkItem(CLMicroLocationLearner::ShouldCancelFunction)"
+ "void CLMicroLocationLoiManager::sendCoreAnalyticsEvent(NSString *, NSDictionary *)"
+ "void CLMicroLocationLoiManager::setupWithLoiBridge(id<CLMicroLocationLoiBridgeProtocol>)"
+ "void CLMicroLocationNotifier::onMotionStateUpdate(int, const CLMotionStateObserver_Type::Notification &, const CLMotionStateObserver_Type::NotificationData &)"
+ "void CLMobility::SmoothedGaitMetricsProcessor::calculateSmoothedGaitMetrics(const std::vector<GaitMetrics> &, std::vector<SmoothedGaitMetrics> &)"
+ "void CLSafetyAnomalySubscription::handleMessageKappaSendAPCommand(std::shared_ptr<CLConnectionMessage>)"
+ "void CLSafetyAnomalySubscription::handleMessageSafetyAnomalyNotification(std::shared_ptr<CLConnectionMessage>)"
+ "void CLWifiReachIntersectionAnalytics::sendCoreAnalyticsEventForWifiFixErrorAndHorizontalErrorRatio(const CLDaemonLocation &, const CLDaemonLocation &, size_t, double, const CLDaemonLocation &, bool)_block_invoke"
+ "void CLWifiReachIntersectionAnalytics::submitMetricsIfPossible(const CLDaemonLocation &, const CLDaemonLocation &, size_t, double, const CLDaemonLocation &, bool)"
+ "when appending label to Blue Atlas model, model has no Blue Atlas data"
+ "when appending label to Blue Atlas model, service has no current model!"
+ "{\"msg%{public}.0s\":\"# MiLo Logic -- tried to initialize with an invalid queue\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#LOI Bridge, geofence does not overlap the geofence at the requested location\", \"Geofence ID\":%{private, location:escape_only}s, \"Distance Between Geofences\":\"%{private}7f\"}"
+ "{\"msg%{public}.0s\":\"#LOI Bridge, removing geofence because it overlap the geofence at the requested location\", \"Geofence ID\":%{private, location:escape_only}s, \"Distance Between Geofences\":\"%{private}7f\"}"
+ "{\"msg%{public}.0s\":\"#LOI Bridge, setting geofence for custom LOI\", \"Custom LOI Geofence radius\":\"%{private}7f\"}"
+ "{\"msg%{public}.0s\":\"#LOI Bridge: location manager failed\", \"error:\":%{private, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, Adding LOI to Service ID mapping\", \"Location ID\":%{private, location:escape_only}s, \"Service ID\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, Disabling geofence that we were trying to enable for custom LOI since we are failing the request\", \"loiID\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, Error: tried to enable custom LOI at an active custom LOI\"}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, Failed to RemoveGeofence\", \"regionId\":%{private, location:escape_only}@, \"error\":%{private, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, No More services monitoring this LOI, disable geofence for LOI\", \"loiID\":%{private, location:escape_only}s, \"Service Id\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, No more services interested in this active LOI, exiting\"}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, Removing LOI to Service ID mapping\", \"Location ID\":%{private, location:escape_only}s, \"Service ID\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, Since we are in the LOI exit LOI\"}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, didRemoveGeofenceWithId\", \"regionId\":%{private, location:escape_only}@, \"error\":%{private, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, failed to get current location to enable MiLo\", \"Error\":%{public, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, failed to get current location to enable MiLo... aborting request\"}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, failed to set geofence at current location to enable MiLo\", \"Error\":%{public, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, failed to set geofence at current location to enable MiLo, failing custom loi request\"}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, got enable custom LOI request from the same service, ignoring\", \"LOI ID\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry event for valid LOI\", \"LOI ID\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for LOI\", \"LOI ID\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for different valid LOI, entering it\", \"LOI ID\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for the current active LOI which shouldn't happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, got geofence exit for active LOI\", \"regionID\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, got geofence exit for an LOI which is not the currently the active LOI, this may happen if we jumped from one geofence to another and the entry for the new geofence arrived first\", \"regionID\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, got location update to enable custom geofence\", \"latitude\":\"%{private}7f\", \"longitude\":\"%{private}7f\"}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, got location update\", \"latitude\":\"%{private}7f\", \"longitude\":\"%{private}7f\"}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, sending core analytics\", \"event\":%{private, location:escape_only}s, \"eventFields\":%{private, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#LOI Manager, successfully set geofence, now waiting on fence entry update\", \"geofenceId\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#LoiBridge, was unable to retrieve monitor record for valid region identifier\", \"identifier\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#LoiRecordingManager Tried to initialize with an invalid queue\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#LoiRecordingManager: Completed Recordings\", \"Recordings completed\":%{private}u}"
+ "{\"msg%{public}.0s\":\"#MiLoNotifier: Received motion state update notification kNotificationMotionState \", \"Type\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#MiLoNotifier: Received other motion state update notification\", \"notification\":%{private}u}"
+ "{\"msg%{public}.0s\":\"#Motion Bridge, getFenceRadius\", \"fence size in m\":\"%{public}.2f\"}"
+ "{\"msg%{public}.0s\":\"#MotionBridge: Setting whether we are in custom LOI\", \"isInCustomLoi\":%{private}hhd}"
+ "{\"msg%{public}.0s\":\"#Warning #monitor number for monitoring conditions limit reached. Sending unmonitoring state\", \"monitor\":%{public, location:escape_only}@, \"client\":%{public, location:escape_only}@, \"record\":%{private, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#Warning LOI Bridge not setup.\"}"
+ "{\"msg%{public}.0s\":\"#Warning LOI Manager, Error retrieving related LOIs for Loi\", \"error\":%{private, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#Warning Wifi Channel Histogram was not generated properly for custom LOI, failed to insert to DB\", \"Inserted\":%{public}hhd, \"LoiGroupId\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#Warning Wifi Channel Histogram was not generated properly for custom LOI, model doesn't contain BlueAtlas data\", \"LoiGroupId\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#Warning Wifi Channel Histogram was not generated properly for custom LOI, no Blue Atlas model found for LOI\", \"LoiGroupId\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#beaconIdentityCondition Region is nil\", \"notification\":%{public}d, \"state\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#circularGeographicCondition received notification\", \"notification\":%{public, location:CLFenceManager_Type::Notification}lld, \"fence\":%{private, location:escape_only}s, \"self\":\"%{public}p\", \"status\":%{private, location:CLFenceManager_Type::FenceStatus}lld}"
+ "{\"msg%{public}.0s\":\"#dic #bas marking eligible for destructionUponDisconnection due to UserTermination\", \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"#dic retirement completed\", \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"#luHistorical  LocationUpdaterHistoricalSession()\", \"adapter\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"#luHistorical #dic consumeMatchingButterfly\", \"dicType\":%{public}d, \"ClientKeyPath\":%{public, location:escape_only}@, \"fAdapter\":\"%{public}p\", \"updater\":\"%{public}p\", \"this\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"#luHistorical entitlementDict for transcriptSession entitlement should not be nil\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#luHistorical entitlementDict for wilderness entitlement should not be nil\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#luHistorical routine has responded with the lookbackWindow\", \"lookbackWindowStartDate\":%{public, location:escape_only}@, \"updater\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"#luHistorical routine monitor should not be empty\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#luHistorical weak session should not be empty\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#monitor #Warning oh wait, lastEvent state is unknown so not actually sending this condition update to the client\", \"ClientKeyPath\":%{public, location:escape_only}@, \"monitor\":%{public, location:escape_only}s, \"identifier\":%{public, location:escape_only}s, \"daemonState\":%{private, location:CLMonitoringState}lld}"
+ "{\"msg%{public}.0s\":\"#monitor #circularGeographicCondition startMonitoring\", \"fence\":%{private, location:escape_only}s, \"self\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"#monitor Fence: Removed fences installed under wrong identity\"}"
+ "{\"msg%{public}.0s\":\"#monitor Fence: unable bind statement to clear Monitor fences\"}"
+ "{\"msg%{public}.0s\":\"#monitor Fence: unable to clear Monitor fences\"}"
+ "{\"msg%{public}.0s\":\"#monitor Found ledger version number\", \"ledgerVersion\":%{public, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#monitor Migrating daemon ledger\", \"clientKey\":%{public, location:escape_only}@, \"ledger\":%{public, location:escape_only}@, \"ledgerExistingVersion\":%{public}d, \"newVersionToMigrateTo\":%{public}d}"
+ "{\"msg%{public}.0s\":\"#monitor identifier nil onConditionUpdate\", \"monitor\":%{public, location:escape_only}s, \"newDaemonState\":%{private, location:CLMonitoringState}lld}"
+ "{\"msg%{public}.0s\":\"#monitor no daemon monitoring record found\", \"monitor\":%{public, location:escape_only}s, \"identifier\":%{public, location:escape_only}s, \"newDaemonState\":%{private, location:CLMonitoringState}lld}"
+ "{\"msg%{public}.0s\":\"#monitor onConditionUpdate\", \"monitor\":%{public, location:escape_only}s, \"identifier\":%{public, location:escape_only}s, \"newDaemonState\":%{private, location:CLMonitoringState}lld, \"condition\":%{private, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#monitor received event from client but record doesn't exist\", \"event\":%{private, location:escape_only}@, \"monitor\":%{public, location:escape_only}@, \"this\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"#monitor removing condition due to migration\", \"identifier\":%{public, location:escape_only}@, \"record\":%{private, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"#monitor should be all cleared for migration but it isn't\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"#monitor update record to send to client\", \"monitor\":%{public, location:escape_only}s, \"identifier\":%{public, location:escape_only}s, \"clientState\":%{private, location:CLMonitoringState}lld, \"daemonState\":%{private, location:CLMonitoringState}lld, \"newDaemonState\":%{private, location:CLMonitoringState}lld}"
+ "{\"msg%{public}.0s\":\"AppMonitor notification - application installed\", \"BundleId\":%{public, location:escape_only}s, \"BundlePath\":%{public, location:escape_only}s, \"ExecutablePath\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"AppMonitor notification\", \"notification\":%{public, location:escape_only}s, \"pid\":%{public}d, \"bundleId\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"Blue Atlas Localization, model type is not BLUE_ATLAS!\", \"Model Type\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"BlueAtlasLocalization - Model Super fingerprint\", \"num dominant sources\":%{public}lu, \"super fingerprint size before filtering dominant sources\":%{public}lu, \"super fingerprint size\":%{public}lu, \"values\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"BlueAtlasLocalization\", \"euclideanDistance\":\"%{public}f\", \"euclideanScore\":\"%{public}f\", \"Num labels\":%{public}lu}"
+ "{\"msg%{public}.0s\":\"BlueAtlasLocalization\", \"euclideanDistance\":\"%{public}f\", \"euclideanScore\":\"%{public}f\", \"numSharedAPs\":\"%{public}f\", \"rssiScaleFactor\":\"%{public}f\", \"similarityScore\":\"%{public}f\", \"Num labels\":%{public}lu}"
+ "{\"msg%{public}.0s\":\"BlueAtlasLocalization, model with empty Blue Atlas Data, publishing empty results\"}"
+ "{\"msg%{public}.0s\":\"CLGatheringRoutineOTASubscription::onMobileAssetNotification\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"CLMiLoService failed to add trigger for future labeling: \", \"Trigger UUID\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"CLMiLoService sending initial empty prediction to BlueAtlas client: \", \"ServiceId\":%{public, location:escape_only}s, \"ClientId\":%{public, location:escape_only}s, \"Trigger UUID\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"CLMiLoServiceManager created empty model:\", \"ClientId\":%{public, location:escape_only}s, \"ModelUuid\":%{public, location:escape_only}s, \"ModelType\":%{public}lld, \"LOI ID\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"CLMiLoServiceManager loaded incorrect model type for LSL service in custom LOI, this should never happen!!!\", \"ClientId\":%{public, location:escape_only}s, \"ModelUuid\":%{public, location:escape_only}s, \"ModelType\":%{public}lld, \"LOI ID\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"CLMiLoServiceManager releasing create custom LOI at current location requests: \", \"NumRequests\":%{public}hhd, \"Success\":%{public}hhd}"
+ "{\"msg%{public}.0s\":\"CLMicroLocationCustomLoiRecordingBridge::startCustomLoiRecordingFence\"}"
+ "{\"msg%{public}.0s\":\"CLMicroLocationCustomLoiRecordingBridge::teardownCustomLoiRecordingFence\"}"
+ "{\"msg%{public}.0s\":\"CLMicroLocationLogic State\", \"enabled\":%{public}hhd, \"LOI Type\":%{private, location:escape_only}s, \"LOI ID\":%{private, location:escape_only}s, \"locationServicesEnabled\":%{public}hhd, \"significantLocationsEnabled\":%{public}hhd, \"ScanActivity\":%{private, location:escape_only}s, \"Localizing Counter\":%{public}d, \"Recording Counter\":%{public}d, \"displayOn\":%{public}hhd, \"isOnLockScreen\":%{public}hhd, \"isWiFiErrorRetryEnabled\":%{public}hhd, \"WiFi Error Retry Counter\":%{public}d, \"WiFi Error Retry Disabled Period Counter\":%{public}d, \"isLowNumberOfObservation\":%{public}hhd, \"isLowPowerMode\":%{public}hhd, \"isBluetoothDisabled\":%{public}hhd}"
+ "{\"msg%{public}.0s\":\"CLMicroLocationModel::BlueAtlasData fromProtobuf - invalid LabelUuid conversion!\"}"
+ "{\"msg%{public}.0s\":\"CLMicroLocationNotifier::onMotionStateUpdate\", \"event\":%{public, location:escape_only}s, \"this\":\"%{public}p\"}"
+ "{\"msg%{public}.0s\":\"CLMicroLocationSensorsDriver, setting dual bands mode\", \"is using dual bands ?\":%{public}hhd}"
+ "{\"msg%{public}.0s\":\"CLMicroLocationTriggerManager, set associated AP for a recording event failed, not associated\"}"
+ "{\"msg%{public}.0s\":\"CLMicroLocationTriggerManager, set associated AP for a recording event\", \"MAC Address\":%{private, location:escape_only}s, \"Rssi\":\"%{public}f\"}"
+ "{\"msg%{public}.0s\":\"CLMicroLocationTriggerManager: requestLocalization -- denying localization  because we are running recording session\"}"
+ "{\"msg%{public}.0s\":\"CLRG: submit DailyGnss usage detail\", \"totalGnssInADay_s\":%{public}d, \"totalLeechedGnssInADay_s\":%{public}d, \"totalProactiveGnssInADay_s\":%{public}d}"
+ "{\"msg%{public}.0s\":\"Harvest-Settings\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"maxEvents\":%{private}d, \"minGapTime\":\"%{private}f\", \"maxGapTime\":\"%{private}f\", \"minWifiTimespan\":\"%{private}f\", \"targetCompassUpdateInterval\":\"%{private}f\", \"traceDuration\":\"%{private}f\", \"traceFuzzInterval\":\"%{private}f\", \"traceOnDiskHarvestingOnly\":%{private}d, \"maxVisionEnabledTraces\":%{private}d, \"allowInertialOdometryNotifications\":%{private}d, \"allowOutdoorServiceNotifications\":%{private}d}"
+ "{\"msg%{public}.0s\":\"LOI Bridge, Failed To fetch place inferences\", \"Error:\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"LOI Bridge, generating bootstrap geofence update\", \"Geofence Id\":%{private, location:escape_only}s, \"state\":%{private}d}"
+ "{\"msg%{public}.0s\":\"LOI Bridge, got geofence update\", \"Geofence Id\":%{private, location:escape_only}s, \"state\":%{private}d}"
+ "{\"msg%{public}.0s\":\"LOI Bridge, received LOI Ids from CLRoutineMonitor\", \"LOI ID Count\":%{public}ld, \"LOI List\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"LOI Bridge, requested geofence at location\", \"latitude\":\"%{private}7f\", \"longitude\":\"%{private}7f\"}"
+ "{\"msg%{public}.0s\":\"LOI Manager, Adding new service to list of servies that have requested to enable custom LOI\", \"LOI ID\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"LOI Manager, Attempting to fetch place inference\", \"Reason:\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"LOI Manager, Failed To request LOI for current visit location\"}"
+ "{\"msg%{public}.0s\":\"LOI Manager, Fetched LOI Group ID\", \"LOI Group ID \":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"LOI Manager, Got Geofence update\", \"Geofence Id\":%{private, location:escape_only}s, \"State\":%{private}d}"
+ "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"LOI Manager, Retrieved location of interest\", \"LOI ID\":%{private, location:escape_only}@, \"LOI TYPE\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"LOI Manager, Retrieved place infernce\", \"LOI ID\":%{private, location:escape_only}s, \"LOI TYPE\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"LOI Manager, forcing LOI type\", \"LOI Override\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"LOI Manager, received nil LOI Identifier from place inference, possibly because there is no active user on macOS, we will start leeching and wait for next location update\"}"
+ "{\"msg%{public}.0s\":\"LOI Manager, refreshing location on XPC trigger\"}"
+ "{\"msg%{public}.0s\":\"LOI Manager, startCustomLoiEntryTimer\"}"
+ "{\"msg%{public}.0s\":\"LOI Manager, stopCustomLoiEntryTimer\"}"
+ "{\"msg%{public}.0s\":\"LOI Manager: handle leeched location notification\"}"
+ "{\"msg%{public}.0s\":\"LOI Manager: handleVisitEntry\"}"
+ "{\"msg%{public}.0s\":\"LOI Manager: handleVisitExit\"}"
+ "{\"msg%{public}.0s\":\"LocalizationController, setting associated AP's RSSI based on scan data\", \"RSSI\":\"%{public}f\", \"MAC Address\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"LocalizationController, setting empty associated AP\"}"
+ "{\"msg%{public}.0s\":\"LocalizerChannelIterator, invalid index\", \"index\":%{public}d, \"size of fWifiChannelHistogram\":%{public}llu}"
+ "{\"msg%{public}.0s\":\"Look up table thresholds and scores vectors must be the same size\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"Look up table thresholds must be sorted\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"Marked Unique - GSM\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"at\":\"%{public}f\"}"
+ "{\"msg%{public}.0s\":\"Marked Unique - LTE\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"at\":\"%{public}f\"}"
+ "{\"msg%{public}.0s\":\"Marked Unique - NR\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"at\":\"%{public}f\"}"
+ "{\"msg%{public}.0s\":\"Marked Unique OOS\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"at\":\"%{public}f\"}"
+ "{\"msg%{public}.0s\":\"Microlocation Blue Atlas model learned\", \"numFingerprints before pruning\":%{public}lu, \"numFingerprints after pruning\":%{public}lu, \"numClusters\":%{public}lu, \"type\":%{public}d, \"numAnchors\":%{public}lu, \"Number of Recording triggers at current LOI\":%{public}u, \"Number of Input Valid Fingerprints\":%{public}u, \"Number of Input Labels\":%{public}lu, \"Number of WiFi Access Points\":%{public}u}"
+ "{\"msg%{public}.0s\":\"MicrolocationLearner: kicking off Learning for Blue Atlas models\"}"
+ "{\"msg%{public}.0s\":\"Models have been regenerated\", \"model-type\":%{public}lu}"
+ "{\"msg%{public}.0s\":\"Not allowed to switch to new LOI\", \"Current LOI ID\":%{private, location:escape_only}s, \"Current LOI Type\":%{private, location:escape_only}s, \"New LOI ID\":%{private, location:escape_only}s, \"New LOI Type\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"SensorsLogic, should request short duration BLE scan\", \"should scan?\":%{public}hhd, \"should scan nearbyInfoV2 ?\":%{public}hhd, \"num of same account ble identifiers\":%{public}lu, \"num of entries in oObkey\":%{public}lu, \"is motion session running?\":%{public}lu}"
+ "{\"msg%{public}.0s\":\"Start learning Blue Atlas model\", \"client\":%{public, location:escape_only}s, \"LOI\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"State Machine: \", \"New State\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"State Machine: Entering new state\", \"New State\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"State Machine: Exiting State\", \"State\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"State Machine: Failed to handle event because current state is NULL\", \"Event\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"State Machine: Failed to handle event because it is not a valid event for the current state\", \"Event\":%{private, location:escape_only}s, \"Current State\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"State Machine: Failed to initialize state because requested state doesn't exist in the state table\", \"State\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"State Machine: Failed to switch to new state because requested state doesn't exist in the state table\", \"State\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"State Machine: Handling Event\", \"Event\":%{private, location:escape_only}s, \"Current State\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"State Machine: No state change requested\", \"State\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"State Machine: State did not have an entry function\", \"State\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"State Machine: State did not have an exit function\", \"State\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"StateBase\"}"
+ "{\"msg%{public}.0s\":\"Tried to setup CLMicroLocationTriggerManager with an invalid recording manager\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"Unable to convert the CFString to Int value\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"Unexpected remaining number of sources\", \"remaining APs\":%{public}lu, \"maxSources\":%{public}lu, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"WiFi Fallback for GSM\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"hasWiFiFallback\":%{public}hhd}"
+ "{\"msg%{public}.0s\":\"WiFi Fallback for LTE\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"hasWiFiFallback\":%{public}hhd}"
+ "{\"msg%{public}.0s\":\"WiFi Fallback for NR\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"hasWiFiFallback\":%{public}hhd}"
+ "{\"msg%{public}.0s\":\"Wifi Channel Histogram generated successfully for custom LOI\", \"LoiGroupId\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"Wifi Channel Histogram was not generated for custom LOI, no measurements to analyze\", \"LoiGroupId\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"analyzing WiFi channels for custom LOI\", \"LoiGroupId\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"applyRecentLabelsToBlueAtlasModel, model has no Blue Atlas data\"}"
+ "{\"msg%{public}.0s\":\"applyRecentLabelsToBlueAtlasModel, no current model\"}"
+ "{\"msg%{public}.0s\":\"applyRecentLabelsToBlueAtlasModel, no label entries for model\"}"
+ "{\"msg%{public}.0s\":\"applyRecentLabelsToBlueAtlasModel, number of labels\", \"after update\":%{public}lu}"
+ "{\"msg%{public}.0s\":\"applyRecentLabelsToBlueAtlasModel, number of labels\", \"before update\":%{public}lu}"
+ "{\"msg%{public}.0s\":\"applyRecentLabelsToBlueAtlasModel, tried to apply a label which is already in the LSL\", \"LabelUUID\":%{public, location:escape_only}s, \"TriggerUUID\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"countSharedAPsInTestFingerprintAndModel\", \"number of shared APs\":%{public}lu, \"shared AP addresses\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"enable MiLo at current location called for a service which is not currently connected\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"enable MiLo at current location, called without configuration\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"enable MiLo at current location, called without connectionToken\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"enable MiLo at current location, called without requestId\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"enable MiLo at current location, called without service identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"enableMiLoAtCurrentLocation completed for service\", \"serviceId\":%{public, location:escape_only}s, \"requestId\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"enableMiLoAtCurrentLocation for service\", \"serviceId\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"enableMiLoAtCurrentLocation\", \"In room enabled\":%{public}hhd, \"state\":%{public}hhd}"
+ "{\"msg%{public}.0s\":\"fetchPlaceInferenceAtCurrentLocation, failed to request place inference, we will start leeching and wait for next location update\", \"Error Reason\":%{private, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"fetchPlaceInferenceAtCurrentLocation, received Place Inference\", \"PI\":%{private, location:escape_only}@}"
+ "{\"msg%{public}.0s\":\"fetchPlaceInferenceAtCurrentLocation, timed out waiting for fetching place inference, this shouldn't happen\"}"
+ "{\"msg%{public}.0s\":\"gnssSessionEventPowerLog\", \"eventCfTimeSec\":\"%{public}f\", \"eventType\":%{public}d, \"eventStatus\":%{public}d}"
+ "{\"msg%{public}.0s\":\"kCLConnectionMessageMiLoEnableMiLoAtCurrentLocation incorrect dictionary\"}"
+ "{\"msg%{public}.0s\":\"kCLConnectionMessageMiLoEnableMiLoAtCurrentLocation received in CLMiLoConnectionSubscription\"}"
+ "{\"msg%{public}.0s\":\"kCLConnectionMessageRemoveCustomLOI received in CLMiLoConnectionSubscription\"}"
+ "{\"msg%{public}.0s\":\"learnBlueAtlasModel\", \"Num dominant APs\":%{public}lu}"
+ "{\"msg%{public}.0s\":\"learnBlueAtlasModel\", \"Num recording entries\":%{public}lu, \"Num valid fingerprints\":%{public}lu}"
+ "{\"msg%{public}.0s\":\"learnBlueAtlasModel\", \"Num unique APs\":%{public}lu}"
+ "{\"msg%{public}.0s\":\"learnBlueAtlasModel\", \"bssid\":%{public, location:escape_only}s, \"score\":\"%{public}f\"}"
+ "{\"msg%{public}.0s\":\"learnBlueAtlasModel, updating associated AP\", \"MAC Address\":%{private, location:escape_only}s, \"Rssi\":\"%{public}f\"}"
+ "{\"msg%{public}.0s\":\"localizationRequestResultsPerModel, found matching strong associated AP\", \"ModelType\":%{public}lu, \"MAC Address\":%{private, location:escape_only}s, \"Rssi\":\"%{public}f\", \"Num labels\":%{public}lu}"
+ "{\"msg%{public}.0s\":\"not set associated AP for a recording event, not associated\", \"client name\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"onCustomLoiRecordingSessionCompleted while current LOI is not custom\", \"current LOI type\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"request remove custom Loi service identifier\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"service is appending a label to Blue Atlas model\", \"ServiceUUID\":%{private, location:escape_only}s, \"LabelUUID\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"set associated AP for a recording event\", \"MAC Address\":%{private, location:escape_only}s, \"Rssi\":\"%{public}f\", \"client name\":%{public, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"updating Blue Atlas wifi channel histogram\"}"
+ "{\"msg%{public}.0s\":\"validateBlueAtlasModelQuality\", \"Num input fingerprints\":%{public}lu, \"Minimal num fingerprints\":%{public}lu, \"Num WiFi APs\":%{public}lu, \"Num APs with valid RSSI\":%{public}lu, \"Num APs with valid appearance rate\":%{public}lu, \"Model Quality\":%{public}lu}"
+ "{\"msg%{public}.0s\":\"when appending label to Blue Atlas model, model has no Blue Atlas data\", \"ServiceUUID\":%{private, location:escape_only}s, \"ModelUUID\":%{private, location:escape_only}s}"
+ "{\"msg%{public}.0s\":\"when appending label to Blue Atlas model, service has no current model!\"}"
+ "{\"msg%{public}.0s\":\"~StateBase\"}"
+ "{\"msg%{public}.0s\":\"~StateMachineBase\"}"
+ "{CLFenceStateChangeMetrics=QBBQQQQQQQQQQQQQQQQQQQQQQQQBBBBBBQQQQQQQBQQQQQQQQQQQQQQQQB@qB}1844@0:8{NotificationData={Fence={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}ddddddddiiidQiiBiiB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{CLStrongPtr<NSUUID *>=@}{vector<CLClientLocationCoordinate, std::allocator<CLClientLocationCoordinate>>=^{?}^{?}{__compressed_pair<CLClientLocationCoordinate *, std::allocator<CLClientLocationCoordinate>>=^{?}}}}{Fence={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}ddddddddiiidQiiBiiB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{CLStrongPtr<NSUUID *>=@}{vector<CLClientLocationCoordinate, std::allocator<CLClientLocationCoordinate>>=^{?}^{?}{__compressed_pair<CLClientLocationCoordinate *, std::allocator<CLClientLocationCoordinate>>=^{?}}}}{CLDaemonLocation=i{?=dd}ddddddddidi{?=dd}diIiiidB}id{FenceMonitorAnalytics=i{CLFenceAnalyticsGeofenceEventTimes=Bdddddddddddddd}d{Fence={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}ddddddddiiidQiiBiiB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{CLStrongPtr<NSUUID *>=@}{vector<CLClientLocationCoordinate, std::allocator<CLClientLocationCoordinate>>=^{?}^{?}{__compressed_pair<CLClientLocationCoordinate *, std::allocator<CLClientLocationCoordinate>>=^{?}}}}{CLDaemonLocation=i{?=dd}ddddddddidi{?=dd}diIiiidB}{CLDaemonLocation=i{?=dd}ddddddddidi{?=dd}diIiiidB}{CLDaemonLocation=i{?=dd}ddddddddidi{?=dd}diIiiidB}iiiddddddd{CLMotionActivity=iiiiiidBfdBiddii{?=b1b1b1b1b1}iidQi}{CLMotionActivity=iiiiiidBfdBiddii{?=b1b1b1b1b1}iidQi}}}16B1840"
+ "{CLStepDistance=iddiidi}24@0:8@16"
+ "{FFFFFFFF-AAAA-1111-EEEE-DDDDDDDDDDDD}"
+ "{LocationSystemState=BBBBBiBii}16@0:8"
+ "{shared_ptr<CLMobility::SmoothedGaitMetricsRecorderDb>=\"__ptr_\"^{SmoothedGaitMetricsRecorderDb}\"__cntrl_\"^{__shared_weak_count}}"
+ "{unique_ptr<CLActivityAggregator<CLMobility::SmoothedGaitMetrics, CLActivityDB::ClassBDataProtectionPolicy>, std::default_delete<CLActivityAggregator<CLMobility::SmoothedGaitMetrics, CLActivityDB::ClassBDataProtectionPolicy>>>=\"__ptr_\"{__compressed_pair<CLActivityAggregator<CLMobility::SmoothedGaitMetrics, CLActivityDB::ClassBDataProtectionPolicy> *, std::default_delete<CLActivityAggregator<CLMobility::SmoothedGaitMetrics, CLActivityDB::ClassBDataProtectionPolicy>>>=\"__value_\"^v}}"
+ "{unique_ptr<CLFenceManager_Type::Client, std::default_delete<CLFenceManager_Type::Client>>=\"__ptr_\"{__compressed_pair<CLFenceManager_Type::Client *, std::default_delete<CLFenceManager_Type::Client>>=\"__value_\"^{Client}}}"
+ "{unique_ptr<CLGatheringRoutineOTASubscription, std::default_delete<CLGatheringRoutineOTASubscription>>=\"__ptr_\"{__compressed_pair<CLGatheringRoutineOTASubscription *, std::default_delete<CLGatheringRoutineOTASubscription>>=\"__value_\"^{CLGatheringRoutineOTASubscription}}}"
+ "{unique_ptr<CLMobility::SmoothedGaitMetricsProcessor, std::default_delete<CLMobility::SmoothedGaitMetricsProcessor>>=\"__ptr_\"{__compressed_pair<CLMobility::SmoothedGaitMetricsProcessor *, std::default_delete<CLMobility::SmoothedGaitMetricsProcessor>>=\"__value_\"^{SmoothedGaitMetricsProcessor}}}"
+ "{unique_ptr<CLPredictedWalkDistanceCompanionSyncManager, std::default_delete<CLPredictedWalkDistanceCompanionSyncManager>>=\"__ptr_\"{__compressed_pair<CLPredictedWalkDistanceCompanionSyncManager *, std::default_delete<CLPredictedWalkDistanceCompanionSyncManager>>=\"__value_\"^{CLPredictedWalkDistanceCompanionSyncManager}}}"
- "#Warning Bundle,%{public}s, exceeds its fence limit,%{private}d. Fence,%{private}s, will not be added"
- "#Warning Error retrieving stored visits. %{private}s"
- "#Warning Error retrieving the current RT LOI. %{private}s"
- "#Warning Unable to query NowPlaying Event Stream. %{private}s"
- "#monitor received event from client but record doesn't exist"
- "#placeInfer use last available location, lat, %{private}.8lf, lon, %{private}.8lf, horAcc, %{public}.1lf, type, %{public}s, timestamp, %@"
- "%@,<recordId %llu, startTime %f, mets %f, gradeType %d, grade %f>"
- "%d:%d"
- "-[CLDaemonMonitoringRecord setupDaemonPartOfConditionWithAuthContext:universe:identifier:stopMonitoring:callbackHandler:]"
- "-[CLGatheringBluetoothClient onMoEventStreamsUpdated]"
- "-[CLGatheringBluetoothScanner initWithQueue:withSettings:]_block_invoke"
- "-[CLGatheringDiscoveryStore markScanEndTimeFromReferenceDate:withReason:withPolicy:]"
- "-[CLGatheringDiscoveryStore markScanStartTimeFromReferenceDate:withReason:withRate:]"
- "-[CLHRRecoveryService checkDeferral:]"
- "-[CLHRRecoveryService onCompanionNotification:data:]"
- "-[CLHRRecoveryService onSyncActivity:]"
- "-[CLHRRecoveryService setActivityAsDone:]"
- "-[CLHRRecoveryService setupSyncActivity]_block_invoke"
- "-[CLMeanSeaLevelPressureEstimator updateHistoricalMeanSeaLevelPressureArray:withRebaseTag:]"
- "/!0/-0"
- "/AppleInternal/Library/BuildRoots/5ae9d77c-6742-11ee-a800-0697ca55970a/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.1.Internal.sdk/usr/local/include/boost/geometry/algorithms/detail/throw_on_empty_input.hpp"
- "/AppleInternal/Library/BuildRoots/5ae9d77c-6742-11ee-a800-0697ca55970a/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.1.Internal.sdk/usr/local/include/boost/uuid/detail/random_provider_posix.ipp"
- "/AppleInternal/Library/BuildRoots/5ae9d77c-6742-11ee-a800-0697ca55970a/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.1.Internal.sdk/usr/local/include/boost/uuid/string_generator.hpp"
- "/AppleInternal/Library/BuildRoots/5ae9d77c-6742-11ee-a800-0697ca55970a/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.1.Internal.sdk/usr/local/include/google/protobuf/repeated_field.h"
- "/AppleInternal/Library/BuildRoots/5ae9d77c-6742-11ee-a800-0697ca55970a/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.1.Internal.sdk/usr/local/include/google/protobuf/wire_format_lite_inl.h"
- "02:50:50"
- "03:07:06"
- "1.3.4"
- "@24@0:8r^{HRRecoveryInputWR=Qddid}16"
- "@48@0:8@16@24@32@?40"
- "@52@0:8Q16d24d32i40d44"
- "CLMicroLocationNotifier fetching LOI Ids for LOI from CLRoutineMonitor"
- "CLMicroLocationNotifier::FetchState CLMicroLocationNotifier::onDuetAirPlayVideoCountQuery(NSObject *, NSError *)"
- "CLMicroLocationNotifier::FetchState CLMicroLocationNotifier::onReceivingLocationOfInterest(std::string, NSUUID *, CLMicroLocationProto::ChangedLoiReason)"
- "CLMicroLocationNotifier::FetchState CLMicroLocationNotifier::onRoutineFetchLoiIds(NSArray<NSUUID *> *, NSError *, CLMicroLocationProto::ChangedLoiReason)"
- "CLMicroLocationNotifier::FetchState CLMicroLocationNotifier::onRoutineLocationOfInterest(RTLocationOfInterest *, NSError *, CLMicroLocationProto::ChangedLoiReason)"
- "CLMicroLocationNotifier::FetchState CLMicroLocationNotifier::onRoutineVisits(NSArray<RTVisit *> *, NSError *, CLMicroLocationProto::ChangedLoiReason)"
- "CLRGE,updateRhythmicGnssPerDayUsage,fRhythmicGnssCoreAnalyticsPerDayData.totalGnssInADay_s,%{public}d, fRhythmicGnssCoreAnalyticsPerDayData.totalLeechedGnssInADay_s,%{public}d,hasDayChangedBeforeThisSession,%{public}d,hasDayChangedAfterThisSession,%{public}d,rhythmicSessionTime,%{public}.3lf,currentSecondsIntoToday,%{public}d,secondsInDayBeforeCurSession,%{public}.3lf"
- "Device lost: %@"
- "Estimator,computeTime,%{private}f,wrMets,%{private}f,gradeType,%{private}d,grade,%{private}f"
- "Fence: fence not added, too many fences, %{private}s, %{private}lu, %{private}u"
- "Found %{public}lu completed visits, of which %{public}lu are near current location"
- "Found %{public}lu relevant AirPlay events in NowPlaying Event Stream"
- "GPS timestamp %.6f, delta %llu, type = %u, speed = %f accuracy = %f course = %f lat(tr) = %f long(tr) = %f horAcc = %f dem %d conf %f"
- "Get generation algorithm: Unknown lerner type"
- "HRRecoveryCompanionSyncActivityInterval"
- "INSERT INTO HRRecoveryInputWRHistory (startTime, mets, gradeType, grade) VALUES (?, ?, ?, ?)"
- "Ignoring refreshRoutineStateAtLocation request since a request is already in progress"
- "Including last visit entry to now in interval query"
- "MOSensedEventCombinedSwitchPeople"
- "MicroLocationsEnableOnlyAtLOIs"
- "MicroLocationsMagicalMomentsAirPlayEnabled"
- "MicroLocationsMagicalMomentsHomeEnabled"
- "MicroLocationsMagicalMomentsWorkEnabled"
- "MicroLocationsMinimumAirPlayDuration"
- "MicroLocationsMinimumAirPlayEvents"
- "MicroLocationsRoutineLocationDistanceThreshold"
- "MicroLocationsSemiSupervisedAirPlayEnabled"
- "MicroLocationsSemiSupervisedHomeEnabled"
- "MicroLocationsSemiSupervisedWorkEnabled"
- "MicroLocationsSimilarityListAirPlayEnabled"
- "MicroLocationsSimilarityListHomeEnabled"
- "MicroLocationsSimilarityListWorkEnabled"
- "Missing previous epoch before an epoch with steps"
- "Models have been regenerated. Doing nothing"
- "NO: server_side_centroid_moving"
- "Not currently in a location of interest"
- "Oct 10 2023"
- "Oct 10 2023 03:10:01"
- "OnVisitNotification"
- "Process state from foregroundedClients cache"
- "Received visit entry"
- "Received visit exit"
- "Refreshing routine state associated with visit entry"
- "Refreshing the routine state associated with leeched location"
- "Retrieved %lu records between %.0f and %.0f"
- "Retrieved %{public}lu stored real-time visits"
- "RoutineFetch error - wait for the next leeched location/visit to det LOI"
- "Tq,N,V_scanMinRescanInterval"
- "Unhandled notification %{public}d"
- "WifiCalc, skip updating computed location using associated AP %{private}s as server-side centroid from tile/als is moving"
- "WombatCameraRollAngleLevelThreshold"
- "WombatMinimumStaticDuration"
- "[CLMagicMountInterface] Sending config shouldKeepRunning,%{public}u,minimumStaticDurationUs,%{public}lld,cameraRollAngleLevelThreshold,%{public}f"
- "[HealthColdStorage] Activity deferred"
- "[HealthColdStorage] Cancelling (%{public}s) early due to deferral."
- "[HealthColdStorage] Cannot send data, companion not nearby"
- "[HealthColdStorage] Failed to defer activity. Current state is %{public}ld"
- "[HealthColdStorage] Failed to mark activity as Continue. Current state is %{public}ld"
- "[HealthColdStorage] No HRRecovery data to send"
- "[HealthColdStorage] Received malformed HRRecoveryInputHRKey %@"
- "[HealthColdStorage] Received malformed HRRecoveryInputWRKey %@"
- "[HealthColdStorage] Received malformed HRRecoverySessionKey %@"
- "[HealthColdStorage] Sync timer fired (%{public}ld)"
- "[HealthColdStorage] Unexpected activity (%s) state: %ld"
- "[HealthColdStorage] failed to mark %{public}s activity as Done. Current state is %{public}ld"
- "[HealthColdStorage] received empty message from watch"
- "[MagicMount][DebugLogging]rollAngle,%{public}f,landscapeAngle,%{public}f,rotationRate,(%{public}f,%{public}f,%{public}f),userAccel,(%{public}f,%{public}f,%{public}f),motionState,%{public}u"
- "_advertisingEnabled"
- "_fenceName"
- "_predictionUpdate:withElevation:"
- "_scanMinRescanInterval"
- "_scanningEnabled"
- "_store"
- "addClientRecordForMonitoring:"
- "alsRequestReason"
- "auto CLMiLoService::generationAlgorithmByServiceType(CLMiLoServiceType)::(anonymous class)::operator()(CLMicroLocationAlgorithms::LearnerType) const"
- "bool CLKappaSubscription::sanityChecksForKappa(std::shared_ptr<CLConnectionMessage>)"
- "bool CLMicroLocationNotifier::refreshRoutineStateAtLocation(double, double, CLMicroLocationProto::ChangedLoiReason)"
- "btclient not run, iCloud status %d"
- "btclient run scanning"
- "btclient start"
- "com.apple.locationd.alsrequestreason"
- "com.apple.momentsd"
- "com.apple.momentsd.event-streams-updated"
- "dElevationDPressureSA:lapseRate:temperature:"
- "did not startAdvertising: advertiser %@ advertiseEnabled %d featureFlag %d"
- "did not stop advertiser"
- "enumerate locations fetched from DB,taskType,%lu,timestamp,%f,elevation,%f,verticalAccuracy,%f"
- "eventQueryWithPredicate:eventStreams:offset:limit:sortDescriptors:"
- "executeQuery:responseQueue:withCompletion:"
- "fSyncManager"
- "fetchPlaceInferences, Attempting to fetch place inference for reason: %{public}s"
- "fetchPlaceInferences, received nil LOI Identifier, possibly because there is no active user on macOS, we will start leeching and wait for next location update"
- "fetchPlaceInferences, received no place inferences, we will start leeching and wait for next location update"
- "fetchPlaceInferences,timed out waiting for fetching place inference, this shouldn't happen"
- "initFromClientCondition:withAuthorizationContext:universe:callbackHandker:"
- "initFromClientCondition:withAuthorizationContext:universe:identifier:removePersistingFenceFromMonitoring:callbackHandler:"
- "initWithClientMonitoringRecord:authorizationContext:universe:identifier:initForStopMonitoring:callbackHandler:"
- "initWithQueue:withStorage:"
- "initWithRecordId:startTime:mets:gradeType:grade:"
- "inject AOP trigger %d %d, delayUsec %d"
- "isAirPlayVideo"
- "markScanEndTimeFromReferenceDate:withReason:withPolicy:"
- "markScanStartTimeFromReferenceDate:withReason:withRate:"
- "modelTypeByServiceType"
- "not _startPermanentScanning: scanEnabled %d, featureFlag %d"
- "not _startTimedScanningWithReason %s, scanEnabled %d, featureFlag %d, _screenIsON %d, to next %.1f s"
- "onMoEventStreamsUpdated"
- "onMoEventStreamsUpdated, advertise enabled: %@, scan enabled: %@"
- "onStopWifiScanTimer"
- "playing"
- "predicateForEventsOfMinimumDuration:"
- "predicateForEventsWithStartInDateRangeFrom:to:"
- "predicateForObjectsWithMetadataKey:andIntegerValue:"
- "recordHasValidEvent:"
- "scanMinRescanInterval"
- "setResultType:"
- "setScanMinRescanInterval:"
- "setupDaemonPartOfConditionWithAuthContext:universe:identifier:stopMonitoring:callbackHandler:"
- "slopeDiffDElevationDPressureSA:"
- "startAdvertising"
- "static CLFenceManager_Type::FenceStatus CLFenceMonitorLogic::getStatusFromLocation(const CLDaemonLocation &, const CLFenceManager_Type::Fence &, const CLFenceMonitorLogic::FenceMonitoringStatus &, const double, const bool)"
- "static CLMicroLocationProto::Model_GenerationAlgorithm CLMiLoService::generationAlgorithmByServiceType(CLMiLoServiceType)"
- "std::optional<CL::Wifi1::Decisions::AlsRequest> CL::Wifi1::Policies::AlsQuery::HandleEvent::defaultAlsRequestLogicUsedWhenComputingLocation(const Input &, const std::optional<CLWifiService_Type::ScanType> &) const"
- "std::string (anonymous namespace)::convertPlaceInferenceUserPlaceTypeToString(_CLPlaceInferenceUserSpecificPlaceType)"
- "std::string (anonymous namespace)::convertRTLocationOfInterestTypeToString(RTLocationOfInterestType)"
- "term1 %f, dElevationdPresureSA(pmeas) %f std::abs(_pressureUncertainty) %f pmeas %f"
- "term2 %f, slopeDiffDElevationDPressureSA(pbias) %f std::abs(pressure - _biasPressure) %f"
- "term3 %f, slopeDiffDElevationDPressureSA(pmeas) %f std::abs(_pressureUncertainty %f"
- "updateHistoricalMeanSeaLevelPressureArray:withRebaseTag:"
- "v148@0:8i16{NotificationData=i{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=*Qb63b1}{__short=[23c][0C]b7b1}{__raw=[3Q]})}}}Bi{unordered_set<std::string, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::string>>={__hash_table<std::string, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::string>>={unique_ptr<std::__hash_node_base<std::__hash_node<std::string, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::string, void *> *> *>>>={__compressed_pair<std::__hash_node_base<std::__hash_node<std::string, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::string, void *> *> *>>>=^^v{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::string, void *> *> *>>={__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::string, void *> *> *>>=Q}}}}{__compressed_pair<std::__hash_node_base<std::__hash_node<std::string, void *> *>, std::allocator<std::__hash_node<std::string, void *>>>={__hash_node_base<std::__hash_node<std::string, void *> *>=^v}}{__compressed_pair<unsigned long, std::hash<std::string>>=Q}{__compressed_pair<float, std::equal_to<std::string>>=f}}}}20"
- "v32@?0@\"CLCondition\"8Q16@\"CLCondition\"24"
- "v52@0:8@16@24@32B40@?44"
- "virtual CLMicroLocationAlgorithms::LocalizerResults CLMicroLocationCosineSimilarityLocalizationAlgorithm::localize(const CLMicroLocationModel &, const CLMicroLocationFingerprint &, const std::optional<CLMicroLocationFingerprintDistanceFunction::Signature> &, const CLMicroLocationLocalizationSettings &, std::optional<boost::uuids::uuid> *) const"
- "virtual CMError CLPredictedWalkDistanceBoutRecorderDb::queryBoutDataInTimeRange(CFAbsoluteTime, CFAbsoluteTime, std::vector<CLPredictedWalkDistanceBoutEntry> &) const"
- "void CLHRRecoveryEstimator::feedCalorieUpdate(CFAbsoluteTime, double, GradeType, double)"
- "void CLKappaNotifier::injectTrigger(uint8_t, uint8_t, uint32_t)"
- "void CLKappaSubscription::handleMessageKappaSendAPCommand(std::shared_ptr<CLConnectionMessage>)"
- "void CLMicroLocationLogic::onModelGenerated(CLMicroLocationProto::Model::ModelType)"
- "void CLMicroLocationLogic::setSupportedModelTypes(std::string)"
- "void CLMicroLocationNotifier::deregisterForLeechedLocationUpdates()"
- "void CLMicroLocationNotifier::fetchPlaceInference(CLMicroLocationProto::ChangedLoiReason)"
- "void CLMicroLocationNotifier::fetchPlaceInference(CLMicroLocationProto::ChangedLoiReason)_block_invoke"
- "void CLMicroLocationNotifier::finishRefreshRoutineState(CLMicroLocationProto::ChangedLoiReason)"
- "void CLMicroLocationNotifier::onVisitNotification(CLVisit *)"
- "void CLMicroLocationNotifier::registerForLeechedLocationUpdates()"
- "void CLPlaceInferenceSubscription::sendLastLocation()"
- "void CLWifiReachIntersectionAnalytics::sendCoreAnalyticsEventForWifiFixErrorAndHorizontalErrorRatio(const CLDaemonLocation &, const CLDaemonLocation &, const CLDaemonLocation &)_block_invoke"
- "void CLWifiReachIntersectionAnalytics::submitMetricsIfPossible(const CLDaemonLocation &, const CLDaemonLocation &, const CLDaemonLocation &)"
- "{\"msg%{public}.0s\":\"#CLIUA known foregrounded client\", \"bundleId\":%{public, location:escape_only}s, \"ClientKey\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"#Warning CLRoutineMonitor is not supported.\"}"
- "{\"msg%{public}.0s\":\"#circularGeographicCondition received notification\", \"notification\":%{public, location:CLFenceManager_Type::Notification}lld, \"fence\":%{private, location:escape_only}s, \"self\":\"%{public}p\"}"
- "{\"msg%{public}.0s\":\"#dic marking eligible for destructionUponDisconnection due to UserTermination\", \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\"}"
- "{\"msg%{public}.0s\":\"#dic received UserTermination for App\", \"pid\":%{public}d, \"bundleId\":%{public, location:escape_only}s, \"ClientKeyPath\":%{public, location:escape_only}@, \"Registration\":%{public, location:CLClientRegistrationResult}lld}"
- "{\"msg%{public}.0s\":\"#luHistorical  LocationUpdaterHistoricalSession()\", \"updater\":\"%{public}p\"}"
- "{\"msg%{public}.0s\":\"#luHistorical #dic consumeMatchingButterfly\", \"dicType\":%{public}d, \"ClientKeyPath\":%{public, location:escape_only}@, \"this\":\"%{public}p\"}"
- "{\"msg%{public}.0s\":\"#minimumAltitudeCondition onAbsoluteAltitudeUpdate\"}"
- "{\"msg%{public}.0s\":\"#monitor onConditionUpdate\", \"monitor\":%{public, location:escape_only}s, \"identifier\":%{public, location:escape_only}s, \"clientState\":%{private, location:CLMonitoringState}lld, \"daemonState\":%{private, location:CLMonitoringState}lld, \"newState\":%{private, location:CLMonitoringState}lld}"
- "{\"msg%{public}.0s\":\"#monitor received event from client but record doesn't exist\", \"event\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"#monitor record has valid event\", \"record\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"AppMonitor notification\", \"notification\":%{public, location:escape_only}s, \"pid\":%{public}d, \"bundleId\":%{public, location:escape_only}s, \"numForegroundedApps\":%{public}ld}"
- "{\"msg%{public}.0s\":\"CLMicroLocationLogic State\", \"enabled\":%{public}hhd, \"LOI Type\":%{private, location:escape_only}s, \"LOI ID\":%{private, location:escape_only}s, \"supportedModelTypes\":%{public}hhd, \"locationServicesEnabled\":%{public}hhd, \"significantLocationsEnabled\":%{public}hhd, \"ScanActivity\":%{private, location:escape_only}s, \"Localizing Counter\":%{public}d, \"Recording Counter\":%{public}d, \"displayOn\":%{public}hhd, \"isOnLockScreen\":%{public}hhd, \"isWiFiErrorRetryEnabled\":%{public}hhd, \"WiFi Error Retry Counter\":%{public}d, \"WiFi Error Retry Disabled Period Counter\":%{public}d, \"isLowNumberOfObservation\":%{public}hhd, \"isLowPowerMode\":%{public}hhd, \"isBluetoothDisabled\":%{public}hhd}"
- "{\"msg%{public}.0s\":\"CLMicroLocationNotifier Fetched LOI Group ID\", \"LOI Group ID \":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLMicroLocationNotifier received LOI Ids from CLRoutineMonitor\", \"LOI ID Count\":%{public}ld, \"LOI List\":%{public, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"CLRG: submit DailyGnss usage detail\", \"totalGnssInADay_s\":%{public}d, \"totalLeechedGnssInADay_s\":%{public}d}"
- "{\"msg%{public}.0s\":\"Clearing unique-counted tiles cache. Updating fUniqueCountedTilesCacheClearedAt\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"From_s\":\"%{public}.09f\", \"to_s\":\"%{public}.09f\"}"
- "{\"msg%{public}.0s\":\"DSIM try updateOutOfServiceStartTime\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"SimInstance\":%{public}d, \"RegistrationStatus\":%{public}d, \"data\":%{public, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"Harvest-Settings\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"maxEvents\":%{private}d, \"minGapTime\":\"%{private}f\", \"maxGapTime\":\"%{private}f\", \"minWifiTimespan\":\"%{private}f\", \"targetCompassUpdateInterval\":\"%{private}f\", \"traceDuration\":\"%{private}f\", \"traceFuzzInterval\":\"%{private}f\", \"traceOnDiskHarvestingOnly\":%{private}d, \"maxVisionEnabledTraces\":%{private}d, \"allowInertialOdometryNotifications\":%{private}d}"
- "{\"msg%{public}.0s\":\"InUseSubscriptions zero. Skip updating OutOfServiceStartTime.\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld}"
- "{\"msg%{public}.0s\":\"Not in OutOfService. Invalidate OutOfServiceStartTime\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld}"
- "{\"msg%{public}.0s\":\"OOS marked as UniqueCount\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"outOfServiceDuration_s\":\"%{public}.09f\", \"tile\":%{private, location:escape_only}s, \"fUniqueCountedTiles\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"OutOfServiceStartTime already set, iginoring this OOS event\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"OutOfServiceStartTime_s\":\"%{public}.09f\", \"Now_s\":\"%{public}.09f\"}"
- "{\"msg%{public}.0s\":\"OutOfServiceStartTime not set, setting now\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"OutOfServiceStartTime_s\":\"%{public}.09f\"}"
- "{\"msg%{public}.0s\":\"Resetting OutOfServiceStartTime to now\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"From_s\":\"%{public}.09f\", \"To_s\":\"%{public}.09f\"}"
- "{\"msg%{public}.0s\":\"Retrieved location of interest\", \"LOI ID\":%{private, location:escape_only}@, \"LOI TYPE\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"SensorsLogic, shouldScanNearbyInfoV2\", \"should scan?\":%{public}hhd, \"num of entries in oObkey\":%{public}lu, \"is motion session running?\":%{public}lu}"
- "{\"msg%{public}.0s\":\"currentTile nil, setting now\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"CurrentTile\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"fetchPlaceInferences, failed to request place inference, we will start leeching and wait for next location update\", \"Error Reason\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"fetchPlaceInferences, received Place Inference\", \"PI\":%{private, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"fetchPlaceInferences,timed out waiting for fetching place inference, this shouldn't happen\"}"
- "{\"msg%{public}.0s\":\"refreshRoutineStateAtLastLocation, will run\"}"
- "{\"msg%{public}.0s\":\"tile hash computed from lat/lon\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"lat\":\"%{private}.6f\", \"lon\":\"%{private}.6f\", \"tile-hash\":%{private, location:escape_only}s}"
- "{\"msg%{public}.0s\":\"try updateOutOfServiceStartTime\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"SimInstance\":%{public}d, \"RegistrationStatus\":%{public}d, \"data\":%{public, location:escape_only}@}"
- "{\"msg%{public}.0s\":\"updating CurrentTile\", \"subHarvester\":%{public, location:CLSubHarvesterIdentifier}lld, \"From\":%{private, location:escape_only}s, \"To\":%{private, location:escape_only}s}"

```
