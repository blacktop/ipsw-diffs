## SceneKit

> `/System/Library/Frameworks/SceneKit.framework/SceneKit`

```diff

-599.108.0.0.0
-  __TEXT.__text: 0x3b0d28
-  __TEXT.__auth_stubs: 0x2e80
-  __TEXT.__objc_methlist: 0x11d74
+599.201.0.0.0
+  __TEXT.__text: 0x3b0b38
+  __TEXT.__auth_stubs: 0x2e90
+  __TEXT.__objc_methlist: 0x11d64
   __TEXT.__const: 0x26098
-  __TEXT.__oslogstring: 0x15cd2
-  __TEXT.__cstring: 0x96bda
+  __TEXT.__oslogstring: 0x15d42
+  __TEXT.__cstring: 0x96b6d
   __TEXT.__gcc_except_tab: 0x3cdc
   __TEXT.__dlopen_cstrs: 0x45
   __TEXT.__ustring: 0x1e
-  __TEXT.__unwind_info: 0xaee0
+  __TEXT.__unwind_info: 0xaee4
   __TEXT.__eh_frame: 0x38
-  __TEXT.__objc_classname: 0x1c4a
-  __TEXT.__objc_methname: 0x241fa
-  __TEXT.__objc_methtype: 0x11bce
-  __TEXT.__objc_stubs: 0x1d3c0
+  __TEXT.__objc_classname: 0x1c5f
+  __TEXT.__objc_methname: 0x2415c
+  __TEXT.__objc_methtype: 0x11c1e
+  __TEXT.__objc_stubs: 0x1d2a0
   __DATA_CONST.__got: 0x538
   __DATA_CONST.__const: 0x7068
   __DATA_CONST.__objc_classlist: 0x6c8
   __DATA_CONST.__objc_catlist: 0xa0
-  __DATA_CONST.__objc_protolist: 0x320
+  __DATA_CONST.__objc_protolist: 0x328
   __DATA_CONST.__objc_imageinfo: 0x8
-  __DATA_CONST.__objc_const: 0x27a20
-  __DATA_CONST.__objc_selrefs: 0x9128
+  __DATA_CONST.__objc_const: 0x27ad0
+  __DATA_CONST.__objc_selrefs: 0x90d8
   __DATA_CONST.__objc_arraydata: 0x270
   __AUTH_CONST.__const: 0xa390
-  __AUTH_CONST.__cfstring: 0x20a60
+  __AUTH_CONST.__cfstring: 0x20aa0
   __AUTH_CONST.__objc_const: 0x62f0
   __AUTH_CONST.__objc_intobj: 0x558
   __AUTH_CONST.__objc_arrayobj: 0xa8
   __AUTH_CONST.__objc_doubleobj: 0x20
   __AUTH_CONST.__objc_dictobj: 0xf0
   __AUTH_CONST.__objc_floatobj: 0x10
-  __AUTH_CONST.__auth_got: 0x1758
+  __AUTH_CONST.__auth_got: 0x1760
   __AUTH.__data: 0x3790
   __AUTH.__objc_data: 0x4290
   __DATA.__objc_protorefs: 0x220
-  __DATA.__objc_classrefs: 0xa40
+  __DATA.__objc_classrefs: 0xa38
   __DATA.__objc_superrefs: 0x5e8
-  __DATA.__objc_ivar: 0x1c38
-  __DATA.__data: 0x33ac
+  __DATA.__objc_ivar: 0x1c3c
+  __DATA.__data: 0x340c
   __DATA.__bss: 0x216d
   __DATA.__common: 0x1b1
   __DATA_DIRTY.__objc_data: 0x140

   - /usr/lib/libobjc.A.dylib
   - /usr/lib/libxml2.2.dylib
   - /usr/lib/libz.1.dylib
-  UUID: 6D0212D4-6541-31DC-83AB-204B5C56D0FA
-  Functions: 22170
-  Symbols:   55683
-  CStrings:  20208
+  UUID: 275DDA37-6A23-3A35-8862-BADDF68D43C1
+  Functions: 22169
+  Symbols:   55679
+  CStrings:  20205
 
Symbols:
+ -[SCNNode _appendFocusableNodesInRect:ofView:toFocusItems:]
+ -[SCNNode _focusFrameInView:]
+ -[SCNNode coordinateSpace]
+ -[SCNNode focusItemsInRect:]
+ -[SCNView focusItemsInRect:]
+ GCC_except_table271
+ GCC_except_table279
+ GCC_except_table284
+ GCC_except_table336
+ GCC_except_table362
+ _CGRectIntersectsRect
+ _OBJC_IVAR_$_SCNMTLSkinDeformer._useFallbackCopyKernel
+ __OBJC_$_PROP_LIST_UIFocusItemContainer
+ __OBJC_$_PROTOCOL_INSTANCE_METHODS_UIFocusItemContainer
+ __OBJC_$_PROTOCOL_METHOD_TYPES_UIFocusItemContainer
+ __OBJC_$_PROTOCOL_REFS_UIFocusItemContainer
+ __OBJC_LABEL_PROTOCOL_$_UIFocusItemContainer
+ __OBJC_PROTOCOL_$_UIFocusItemContainer
+ _objc_msgSend$_appendFocusableNodesInRect:ofView:toFocusItems:
+ _objc_msgSend$_focusFrameInView:
- -[SCNNode _focusableCandidates:]
- -[SCNNode _isEligibleForFocus]
- -[SCNView _focusFrameForSCNNode:]
- -[SCNView _focusedItemRegionContainer]
- -[SCNView _getFocusableNodes]
- -[SCNView _searchForFocusRegionsInContext:]
- GCC_except_table269
- GCC_except_table277
- GCC_except_table278
- GCC_except_table334
- GCC_except_table360
- _OBJC_CLASS_$__UIFocusItemRegion
- ___29-[SCNView _getFocusableNodes]_block_invoke
- _objc_msgSend$_convertFrameToView:
- _objc_msgSend$_focusFrameForSCNNode:
- _objc_msgSend$_focusableCandidates:
- _objc_msgSend$_getFocusNodes
- _objc_msgSend$_getFocusableNodes
- _objc_msgSend$_isEligibleForFocus
- _objc_msgSend$addRegion:
- _objc_msgSend$convertRect:toCoordinateSpace:
- _objc_msgSend$initWithFrame:coordinateSpace:item:
- _objc_msgSend$intersectsRect:
- _objc_msgSend$searchArea
CStrings:
+ "#define USE_QUAT_FOR_IES 1\n#define USE_PBR_DOMINANT_DIRECTION 1\n\n\nstruct scn_light\n{\n    float4 color; \n    float3 pos; \n    float3 dir; \n    float shadowRadius; \n    uint8_t lightType; \n    uint8_t attenuationType; \n    uint8_t shadowSampleCount; \n                                \n    union {\n        struct {\n            float4      cascadeScale[4]; \n            float4      cascadeBias[4];\n        } directional; \n        struct {\n            float4      attenuationFactors; \n            float3      shadowScaleBias; \n        } omni;\n        struct {\n            float4      _attenuationFactors; \n            float2      scaleBias; \n        } spot;\n        struct {\n            float4      _attenuationFactors; \n            float2      scaleBias; \n#if USE_QUAT_FOR_IES\n            float4      light_from_view_quat; \n#else\n            float4x4    light_from_view; \n#endif\n        } ies;\n        union {\n            struct {\n                float2 halfExtents;\n                float doubleSided;\n            } rectangle;\n            struct {\n                uint32_t vertexCount;\n                float doubleSided;\n            } polygon;\n            struct {\n                float halfLength;\n            } line;\n            struct {\n                float2 halfExtents;\n                float doubleSided;\n            } ellipse;\n            struct {\n                float3 halfExtents;\n            } ellipsoid;\n        } area;\n        struct {\n            float3  offset;\n            float4  halfExtents; \n            float3  parallaxCenter;\n            float3  parallaxExtents;\n            int32_t index; \n            int32_t parallaxCorrection; \n        } probe;\n    } parameters; \n\n    float4x4    shadowMatrix; \n\n};\n\n#if defined(__METAL_VERSION__) \n\nusing namespace metal;\n\nnamespace scn {\n    static constexpr sampler linearSampler = sampler(filter::linear, mip_filter::linear);\n}\n\n#define ambientOcclusionTexcoord ambientTexcoord\n\nstruct SCNShaderSurface {\n    float3 view;                \n    float3 position;            \n    float3 normal;              \n    float3 geometryNormal;      \n    float2 normalTexcoord;      \n    float3 tangent;             \n    float3 bitangent;           \n    float4 ambient;             \n    float2 ambientTexcoord;     \n    float4 diffuse;             \n    float2 diffuseTexcoord;     \n    float4 specular;            \n    float2 specularTexcoord;    \n    float4 emission;            \n    float2 emissionTexcoord;    \n    float4 selfIllumination;            \n    float2 selfIlluminationTexcoord;    \n    float4 multiply;            \n    float2 multiplyTexcoord;    \n    float4 transparent;         \n    float2 transparentTexcoord; \n    float4 reflective;          \n    float  metalness;           \n    float2 metalnessTexcoord;   \n    float  roughness;           \n    float2 roughnessTexcoord;   \n    float clearCoat;            \n    float2 clearCoatTexcoord;   \n    float clearCoatRoughness;   \n    float2 clearCoatRoughnessTexcoord;\n    float3 clearCoatNormal;     \n    float2 clearCoatNormalTexcoord;\n    float shininess;            \n    float fresnel;              \n    float ambientOcclusion;     \n    float3 _normalTS;           \n    float3 _clearCoatNormalTS;  \n#ifdef USE_SURFACE_EXTRA_DECL\n    __SurfaceExtraDecl__\n#endif\n};\n\n\n\nstruct SCNShaderLight {\n    float4 intensity;\n    float3 direction;\n\n    float  _att;\n    float3 _spotDirection;\n    float  _distance;\n};\n\nenum SCNLightingModel\n{\n    SCNLightingModelConstant,\n    SCNLightingModelLambert,\n    SCNLightingModelPhong,\n    SCNLightingModelBlinn,\n    SCNLightingModelNone,\n    SCNLightingModelPhysicallyBased,\n    SCNLightingModelShadowOnly,\n\n    SCNLightingModelCustom \n};\n\nenum C3DLightAttenuationType\n{\n    kC3DLightAttenuationTypeNone,\n    kC3DLightAttenuationTypeConstant,\n    kC3DLightAttenuationTypeLinear,\n    kC3DLightAttenuationTypeQuadratic,\n    kC3DLightAttenuationTypeExponent,\n    kC3DLightAttenuationTypePhysicallyBased,\n};\n\n#define PROBES_NORMALIZATION 0\n#define PROBES_OUTER_BLENDING 1\n\nstruct SCNShaderLightingContribution\n{\n    float3 ambient;\n    float3 diffuse;\n    float3 specular;\n    float3 modulate;\n\n#ifdef USE_SHADOWONLY\n    float shadowFactor;\n#endif\n\n#if PROBES_NORMALIZATION\n    float4 probesWeightedSum; \n#else\n    float  probeRadianceRemainingFactor;\n#endif\n\n    thread SCNShaderSurface& surface;\n\n#ifdef USE_PER_VERTEX_LIGHTING\n    commonprofile_io out;\n#else\n    commonprofile_io in;\n#endif\n\n#if USE_REVERSE_Z\n    constant static constexpr bool reverseZ = true;\n#else\n    constant static constexpr bool reverseZ = false;\n#endif\n\n#ifdef USE_PBR\n    struct {\n        float3 albedo;\n        float3 envDiffuse;\n        float3 envSpecular;\n        float3 reflectance;\n        float3 probeReflectance;\n#ifndef USE_PBR_LAMBERTIAN_REFLECTION\n        float2 diffuseHammonFactors;\n#endif\n#ifdef USE_PBR_TRANSPARENCY\n        float  transparency;\n#endif\n        float  NoV;\n        float  selfIlluminationOcclusion;\n#ifdef USE_CLEARCOAT\n        float  NoVClearCoat;\n        float3 probeReflectanceClearCoat;\n#endif\n    } pbr;\n#endif\n    \n    SCNShaderLightingContribution(thread SCNShaderSurface& iSurface, commonprofile_io io):surface(iSurface)\n#ifdef USE_PER_VERTEX_LIGHTING\n    ,out(io)\n#else\n    ,in(io)\n#endif\n    {\n        ambient = 0.f;\n        diffuse = 0.f;\n        specular = 0.f;\n#ifdef USE_SHADOWONLY\n        shadowFactor = 1.f;\n#endif\n\n#if PROBES_NORMALIZATION\n#if PROBES_OUTER_BLENDING\n        probesWeightedSum = float4(0.f);\n#else\n        probesWeightedSum = float4(0.f, 0.f, 0.f, 0.000001f); \n#endif\n#else\n        probeRadianceRemainingFactor = 1.f;\n#endif\n\n#ifdef USE_MODULATE\n        modulate = 1.f;\n#else\n        modulate = 0.f;\n#endif\n    }\n\n#ifdef USE_PBR\n    void prepareForPBR(texture2d<float, access::sample> specularDFGDiffuseHammonTexture, float occ)\n    {\n        pbr.envDiffuse = 0.f;\n        pbr.envSpecular = 0.f;\n        pbr.selfIlluminationOcclusion = occ;\n      \n        pbr.albedo = surface.diffuse.rgb;\n#ifdef USE_PBR_TRANSPARENCY\n  #ifdef DIFFUSE_PREMULTIPLIED\n        \n        pbr.transparency = 1.f;\n  #else\n        pbr.transparency = surface.diffuse.a;\n  #endif\n  #ifdef USE_TRANSPARENCY\n    #ifdef USE_PER_VERTEX_LIGHTING\n        pbr.transparency *= out.transparency;\n    #else\n        pbr.transparency *= in.transparency;\n    #endif\n  #endif\n  #ifdef USE_TRANSPARENT\n        \n        pbr.transparency *= surface.transparent.a;\n  #endif\n        pbr.albedo *= pbr.transparency;\n  #ifdef DIFFUSE_PREMULTIPLIED\n        \n        \n        pbr.transparency *= surface.diffuse.a;\n  #endif\n#endif\n        \n        float3 n = surface.normal;\n        float3 v = surface.view;\n        pbr.NoV = abs(dot(n, v));\n        \n        float roughness = surface.roughness;\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        float2 specularDFG = specularDFGDiffuseHammonTexture.sample(scn::linearSampler, float2(pbr.NoV, roughness)).rg;\n#else\n        float4 env = specularDFGDiffuseHammonTexture.sample(scn::linearSampler, float2(pbr.NoV, roughness));\n        float2 specularDFG = env.xy;\n        pbr.diffuseHammonFactors = env.zw;\n#endif\n        \n        pbr.reflectance = mix(PBR_F0_NON_METALLIC, pbr.albedo, surface.metalness);\n        pbr.probeReflectance = pbr.reflectance * specularDFG.r + specularDFG.g;\n                                \n#ifdef USE_CLEARCOAT\n        pbr.NoVClearCoat = abs(dot(surface.clearCoatNormal, v));\n        float2 DFGClearCoat = specularDFGDiffuseHammonTexture.sample(scn::linearSampler, float2(pbr.NoVClearCoat, surface.clearCoatRoughness)).rg;\n        pbr.probeReflectanceClearCoat = 0.04 * DFGClearCoat.r + DFGClearCoat.g;\n#endif\n    }\n#endif\n\n\n#ifdef USE_LIGHT_MODIFIER\n    __LightModifierExtraDecl__\n#endif\n\n    float4 debug_pixel(float2 fragmentPosition)\n    {\n        const int width = 64;\n        switch (int(fragmentPosition.x + fragmentPosition.y ) / width) {\n            case 0: return float4(surface.view, 1.f);\n            case 1: return float4(surface.position, 1.f);\n            case 2: return float4(surface.normal, 1.f);\n            case 3: return float4(surface.geometryNormal, 1.f);\n            case 4: return float4(float3(surface.ambientOcclusion), 1.f);\n            case 5: return surface.diffuse;\n            case 6: return float4(float3(surface.metalness), 1.f);\n            case 7: return float4(float3(surface.roughness), 1.f);\n            case 8: return float4(ambient, 1.f);\n            case 9: return float4(diffuse, 1.f);\n            default: return float4(specular, 1.f);\n        }\n    }\n\n    \n\n    static inline float3 lambert_diffuse(float3 l, float3 n, float3 color, float intensity) {\n        return color * (intensity * saturate(dot(n, l)));\n    }\n\n    void lambert(float3 l, float3 color, float intensity)\n    {\n        diffuse += lambert_diffuse(l, surface.normal, color, intensity);\n    }\n\n    void blinn(float3 l, float3 color, float intensity)\n    {\n        float3 D = lambert_diffuse(l, surface.normal, color, intensity);\n        diffuse += D;\n\n        float3 h = normalize(l + surface.view);\n        specular += powr(saturate(dot(surface.normal, h)), surface.shininess) * D;\n    }\n\n    void phong(float3 l, float3 color, float intensity)\n    {\n        float3 D = lambert_diffuse(l, surface.normal, color, intensity);\n        diffuse += D;\n\n        float3 r = reflect(-l, surface.normal);\n        specular += powr(saturate(dot(r, surface.view)), surface.shininess) * D;\n    }\n\n#ifdef USE_PBR\n    void physicallyBased(float3 l, float3 color, float intensity)\n    {\n        float3 n         = surface.normal;\n        float3 v         = surface.view;\n        float  roughness = surface.roughness;\n        float  alpha     = roughness * roughness;\n\n        float3 h = normalize(l + v);\n\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n        \n        float D   = scn_brdf_D(alpha, NoH);\n        float3 F  = scn_brdf_F_opt(pbr.reflectance, LoH);\n        float Vis = scn_brdf_V(alpha, NoL, pbr.NoV);\n\n        \n        diffuse  += color * (NoL * M_1_PI_F * intensity);\n        specular += color * F * (NoL * D * Vis * intensity);\n        \n        #ifdef USE_CLEARCOAT\n            n = surface.clearCoatNormal;\n\n            roughness = max(surface.clearCoatRoughness, 0.089f);\n            alpha = roughness * roughness; \n        \n            \n            \n            float NoH_coat = saturate(dot(n, h));\n            float NoL_coat = saturate(dot(n, l));\n            D   = scn_brdf_D(alpha, NoH_coat);\n            F   = scn_brdf_F_opt(0.04, LoH) * surface.clearCoat;\n            Vis = scn_brdf_V(alpha, NoL_coat, saturate(dot(n,v)));\n        \n            float attenuation = 1.0 - F.r;\n            specular *=  (attenuation * attenuation);\n            specular += color * F * ( NoL_coat * D * Vis * intensity);\n        #endif\n    }\n#endif\n\n    void custom(float3 _l, float3 _color, float _intensity)\n    {\n#ifdef USE_LIGHT_MODIFIER\n        thread SCNShaderLightingContribution &_lightingContribution = *this;\n        thread SCNShaderSurface& _surface = surface;\n        SCNShaderLight _light = {.direction = _l, .intensity = float4(_color, 1.f), ._att = _intensity };\n        \n        __DoLightModifier__\n        \n#endif\n    }\n\n    void shade(float3 l, float3 color, float intensity)\n    {\n#ifdef LIGHTING_MODEL\n        switch (LIGHTING_MODEL) {\n#ifdef USE_SHADOWONLY\n            case SCNLightingModelShadowOnly:        shadowFactor *= intensity; break;\n#endif\n            case SCNLightingModelLambert:           lambert(l, color, intensity); break;\n            case SCNLightingModelBlinn:             blinn(l, color, intensity);   break;\n            case SCNLightingModelPhong:             phong(l, color, intensity);   break;\n#ifdef USE_PBR\n            case SCNLightingModelPhysicallyBased:   physicallyBased(l, color, intensity); break;\n#endif\n            case SCNLightingModelCustom:            custom(l, color, intensity);  break;\n            default:  break; \n        }\n#endif\n    }\n\n    \n    \n    \n    float pbr_dist_attenuation_alternate(float3 l, float cutoff) {\n        \n        float radius = 0.1f; \n        float factor = 1.f / (1.f + length(l)/radius);\n        float attenuation = saturate(factor * factor); \n        return saturate((attenuation - cutoff) / (1.f - cutoff));\n    }\n\n    float pbr_dist_attenuation(float3 l, float inv_square_radius) {\n        float sqr_dist = length_squared(l);\n        float atten = 1.f / max(sqr_dist, 0.0001f);\n\n        \n        float factor = saturate(1.f - scn::sq(sqr_dist * inv_square_radius));\n        return atten * factor * factor;\n    }\n\n    float non_pbr_dist_attenuation(float3 l, float4 att)\n    {\n        return powr(saturate(length(l) * att.x + att.y), att.z);\n    }\n\n    float dist_attenuation(float3 unnormalized_l, scn_light light)\n    {\n#ifdef USE_PBR\n        return 1000.f * pbr_dist_attenuation(unnormalized_l, light.parameters.omni.attenuationFactors.w);\n        \n        \n#else\n#ifdef USE_SHADOWONLY\n        return 1.f;\n#endif\n        return non_pbr_dist_attenuation(unnormalized_l, light.parameters.omni.attenuationFactors);\n#endif\n    }\n\n    float spot_attenuation(float3 l, scn_light light)\n    {\n#ifdef USE_SHADOWONLY\n        return 1.f;\n#endif\n        \n        return saturate(dot(l, light.dir) * light.parameters.spot.scaleBias.x + light.parameters.spot.scaleBias.y);\n    }\n\n    void shade_modulate(float3 l, float4 color, float intensity)\n    {\n        constexpr half3 white = half3(1.h);\n        \n        modulate *= float3(mix(white, half3(color.rgb), half(color.a * intensity)));\n    }\n\n    float3 gobo(float3 pos, scn_light light, texture2d<half> goboTexture, sampler goboSampler)\n    {\n        half3 g = texture2DProj(goboTexture, goboSampler, (light.shadowMatrix * float4(pos, 1.f))).rgb;\n        return light.color.rgb * float3(mix(1.h, g, half(light.color.a)));\n    }\n\n    float shadow(float3 pos, scn_light light, depth2d<float> shadowMap)\n    {\n        float shadow = ComputeShadow(scn_shadow_sampler, pos, light.shadowMatrix, shadowMap, reverseZ);\n        return 1.f - shadow * light.color.a; \n    }\n\n    \n    float shadow(float3 pos, scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel)\n    {\n        float shadow = ComputeSoftShadow(scn_shadow_sampler, pos, light.shadowMatrix, shadowMap, shadowKernel, light.shadowSampleCount, light.shadowRadius, reverseZ);\n        return 1.f - shadow * light.color.a; \n    }\n\n    float shadow(float3 pos, scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int shadowSampleCount)\n    {\n        float shadow = ComputeSoftShadow(scn_shadow_sampler, pos, light.shadowMatrix, shadowMap, shadowKernel, shadowSampleCount, light.shadowRadius, reverseZ);\n        return 1.f - shadow * light.color.a; \n    }\n\n    float shadow(float3 pos, scn_light light, depth2d<float> shadowMap, int shadowSampleCount)\n    {\n        float shadow = ComputeSoftShadowGrid(scn_shadow_sampler, pos, light.shadowMatrix, shadowMap, shadowSampleCount, reverseZ);\n        return 1.f - shadow * light.color.a; \n    }\n\n    float shadow_omni(float3 pos_vs, float3 nrm_vs, scn_light light, depthcube<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n        \n#define USE_TANGENT_SAMPLING 0\n\n        float2 scaleBias = light.parameters.omni.shadowScaleBias.xy;\n        float  depthBias = light.parameters.omni.shadowScaleBias.z;\n\n        \n        pos_vs += nrm_vs * depthBias;\n\n        \n        float3 pos_ls = (light.shadowMatrix * float4(pos_vs, 1.f)).xyz;\n\n        \n        float z_lin = scn::reduce_max(abs(pos_ls));\n\n        \n        \n        \n\n        \n        float z_ndc = (z_lin * scaleBias.x + scaleBias.y) / z_lin - depthBias;\n\n        \n        float shadow;\n        if (sampleCount <= 1) {\n            shadow = shadowMap.sample_compare(scn_shadow_sampler, pos_ls.xyz, z_ndc);\n        } else {\n            \n            float filteringSizeFactor = light.shadowRadius;\n\n#if USE_TANGENT_SAMPLING\n            float3 tgt_x, tgt_y;\n            scn::orthogonal_basis(pos_ls, tgt_x, tgt_y);\n#else\n            float3 nrm_ls = (light.shadowMatrix * float4(nrm_vs, 0.f)).xyz;\n#endif\n\n            \n            float totalAccum = 0.0;\n            for(int i=0; i < sampleCount; i++){\n\n#if USE_TANGENT_SAMPLING\n                float2 scale = shadowKernel[i].xy * filteringSizeFactor * 2.f;\n                float3 smp_ls = pos_ls.xyz + tgt_x * scale.x + tgt_y * scale.y;\n#else\n                float3 smp_ls = pos_ls.xyz + scn::randomHemisphereDir(nrm_ls, shadowKernel[i].xy) * filteringSizeFactor;\n#endif\n\n                \n                \n                \n\n                totalAccum += shadowMap.sample_compare(scn_shadow_sampler, smp_ls, z_ndc);\n            }\n            shadow = totalAccum / float(sampleCount);\n        }\n\n        return 1.f - shadow * light.color.a; \n    }\n\n    float shadow(float3 pos, constant scn_light& light, depth2d_array<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount)\n    {\n        float shadow = ComputeCascadedShadow(scn_shadow_sampler, pos, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius).a;\n        return 1.f - shadow * light.color.a; \n    }\n\n    \n\n    void add_directional(scn_light light)\n    {\n#ifdef USE_PBR\n        float intensity = M_PI_F;\n#else\n        float intensity = 1.f;\n#endif\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n    void add_directional(scn_light light, texture2d<half> goboTexture, sampler goboSampler, bool modulated)\n    {\n#ifdef USE_PBR\n        float intensity = M_PI_F;\n#else\n        float intensity = 1.f;\n#endif\n        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);\n        if (modulated) {\n            shade_modulate(light.dir, light.color, 1.f);\n        } else {\n            shade(light.dir, light.color.rgb, intensity);\n        }\n    }\n\n    \n    void add_directional(scn_light light, depth2d<float> shadowMap)\n    {\n#ifdef USE_PBR\n        float intensity = M_PI_F;\n#else\n        float intensity = 1.f;\n#endif\n        intensity *= shadow(surface.position, light, shadowMap);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n    void add_directional(scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel)\n    {\n#ifdef USE_PBR\n        float intensity = M_PI_F;\n#else\n        float intensity = 1.f;\n#endif\n        intensity *= shadow(surface.position, light, shadowMap, shadowKernel);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    void add_directional(scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n#ifdef USE_PBR\n        float intensity = M_PI_F;\n#else\n        float intensity = 1.f;\n#endif\n        intensity *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n    void add_directional(scn_light light, depth2d<float> shadowMap, int sampleCount)\n    {\n#ifdef USE_PBR\n        float intensity = M_PI_F;\n#else\n        float intensity = 1.f;\n#endif\n        intensity *= shadow(surface.position, light, shadowMap, sampleCount);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n    void add_directional(constant scn_light& light, depth2d_array<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount, bool debugCascades)\n    {\n#ifdef USE_PBR\n        float intensity = M_PI_F;\n#else\n        float intensity = 1.f;\n#endif\n        if (debugCascades) {\n            float4 shadowDebug = ComputeCascadedShadow(scn_shadow_sampler, surface.position, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius);\n            intensity *= (1.f - shadowDebug.a);\n            shade(light.dir, light.color.rgb, intensity);\n            diffuse.rgb = mix(diffuse.rgb, shadowDebug.rgb, light.color.a);\n        } else {\n            intensity *= shadow(surface.position, light, shadowMaps, cascadeCount, blendCascade, shadowKernel, sampleCount);\n            shade(light.dir, light.color.rgb, intensity);\n        }\n    }\n\n    \n\n    void add_omni(scn_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        shade(l, light.color.rgb, dist_attenuation(unnormalized_l, light));\n    }\n\n    void add_omni(scn_light light, depthcube<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity *= shadow_omni(surface.position, surface.normal, light, shadowMap, shadowKernel, sampleCount);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    void add_local_omni(scn_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        shade(l, light.color.rgb, dist_attenuation(unnormalized_l, light));\n    }\n\n    \n\n    void add_spot(scn_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= spot_attenuation(l, light);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    void add_spot(scn_light light, texture2d<half> goboTexture, sampler goboSampler, bool modulated)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= spot_attenuation(l, light);\n        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);\n        if (modulated) {\n            shade_modulate(l, light.color, intensity);\n        } else {\n            shade(l, light.color.rgb, intensity);\n        }\n    }\n\n    void add_local_spot(scn_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= spot_attenuation(l, light);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    \n    void add_spot(scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= spot_attenuation(l, light);\n        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    \n\n#ifdef USE_PBR\n\n    \n\n#ifdef C3D_SUPPORT_CUBE_ARRAY\n    void add_local_probe(scn_light light, texturecube_array<half> probeTextureArray)\n#else\n    void add_local_probe(scn_light light, texture2d_array<half> probeTextureArray)\n#endif\n    {\n#if !PROBES_NORMALIZATION\n        if (probeRadianceRemainingFactor <= 0.f)\n            return;\n#endif\n\n        bool parallaxCorrection = light.parameters.probe.parallaxCorrection;\n        int    probeIndex       = light.parameters.probe.index;\n        float3 probeExtents     = light.parameters.probe.halfExtents.xyz;\n        float  blendDist        = light.parameters.probe.halfExtents.w;\n        float3 probeOffset      = light.parameters.probe.offset;\n        float3 parallaxExtents  = light.parameters.probe.parallaxExtents;\n        float3 parallaxCenter   = light.parameters.probe.parallaxCenter;\n\n        float3 n = surface.normal;\n        float3 v = surface.view;\n        float3 r = reflect(-v, n); \n\n        float3 specDir = scn::mat4_mult_float3(light.shadowMatrix, r);\n\n        \n        float3 pos_ls = (light.shadowMatrix * float4(surface.position, 1.f)).xyz;\n\n        \n        float3 d = abs(pos_ls) - probeExtents;\n#if PROBES_OUTER_BLENDING\n        if (any(d > blendDist))\n#else\n        if (any(d > 0.f))\n#endif\n        {\n            return;\n        }\n\n#if PROBES_NORMALIZATION\n        \n        \n#if PROBES_OUTER_BLENDING\n        float3 nd = saturate(-(d / blendDist) * 0.5f + 0.5f);\n#else\n        float3 nd = saturate(-(d / blendDist));\n#endif\n        float probeFactor = (nd.x * nd.y * nd.z) * light.color.r;\n#else\n        \n        float sd = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n#if PROBES_OUTER_BLENDING\n        float probeFactor = saturate(1.f - sd / blendDist);\n#else\n        float probeFactor = saturate(-sd / blendDist);\n#endif\n        \n        \n        \n        probeFactor *= probeRadianceRemainingFactor * light.color.r; \n#endif\n\n        if (parallaxCorrection ) {\n            \n            float3 pos_off = pos_ls + parallaxCenter;\n            float3 t1 = ( parallaxExtents - pos_off) / specDir;\n            float3 t2 = (-parallaxExtents - pos_off) / specDir;\n            float3 tmax = max(max(0, t1), t2); \n            float t = min(tmax.x, min(tmax.y, tmax.z));\n\n            \n            float3 hit_ls = pos_ls + specDir * t;\n            specDir = hit_ls - probeOffset;\n        }\n\n        float mipd = float(probeTextureArray.get_num_mip_levels()) - 1.f;\n        const float intensity = surface.ambientOcclusion * probeFactor;\n\n        float mips = surface.roughness * mipd;\n#ifdef C3D_SUPPORT_CUBE_ARRAY\n        float3 LD = float3(probeTextureArray.sample(scn::linearSampler, specDir, probeIndex, level(mips)).rgb);\n#else\n        float2 specUV = scn::dual_paraboloid_from_cartesian(normalize(specDir));\n        float3 LD = float3(probeTextureArray.sample(scn::linearSampler, specUV, probeIndex, level(mips)).rgb);\n#endif\n\n        \n\n        \n#if PROBES_NORMALIZATION\n        probesWeightedSum += float4(LD * intensity * pbr.probeReflectance, probeFactor);\n#else\n        probeRadianceRemainingFactor = saturate(probeRadianceRemainingFactor - probeFactor);\n        specular += LD * intensity * pbr.probeReflectance;\n#endif\n        \n#ifdef USE_CLEARCOAT\n        n = surface.clearCoatNormal;\n        r = reflect(-v, n);\n        specDir = scn::mat4_mult_float3(light.shadowMatrix, r);\n        if (parallaxCorrection ) {\n            float3 pos_off = pos_ls + parallaxCenter;\n            \n            float3 t1 = ( parallaxExtents - pos_off) / specDir;\n            float3 t2 = (-parallaxExtents - pos_off) / specDir;\n            float3 tmax = max(max(0, t1), t2); \n            float t = min(tmax.x, min(tmax.y, tmax.z));\n            \n            \n            float3 hit_ls = pos_ls + specDir * t;\n            specDir = hit_ls - probeOffset;\n        }\n        mips = surface.clearCoatRoughness * mipd;\n#ifdef C3D_SUPPORT_CUBE_ARRAY\n        LD = float3(probeTextureArray.sample(scn::linearSampler, specDir, probeIndex, level(mips)).rgb);\n#else\n        specUV = scn::dual_paraboloid_from_cartesian(normalize(specDir));\n        LD = float3(probeTextureArray.sample(scn::linearSampler, specUV, probeIndex, level(mips)).rgb);\n#endif\n#if PROBES_NORMALIZATION\n        probesWeightedSum += float4(LD * intensity * pbr.probeReflectanceClearCoat, probeFactor) * surface.clearCoat;\n#else\n        specular += LD * intensity * pbr.probeReflectanceClearCoat * surface.clearCoat;\n#endif\n#endif\n    }\n\n    void add_global_probe(float4x4 localDirToWorldCubemapDir,\n                          float environmentIntensity,\n#ifdef C3D_SUPPORT_CUBE_ARRAY\n                          texturecube_array<half> probeTextureArray\n#else\n                          texture2d_array<half> probeTextureArray\n#endif\n                          )\n    {\n        float3 n = surface.normal;\n        float3 v = surface.view;\n        float3 r = reflect(-v, n); \n        \n        float3 specDir = scn::mat4_mult_float3(localDirToWorldCubemapDir, r);\n        float mips = surface.roughness * float(probeTextureArray.get_num_mip_levels() - 1);\n#ifdef C3D_SUPPORT_CUBE_ARRAY\n        float3 LD = float3(probeTextureArray.sample(scn::linearSampler, specDir, 0, level(mips)).rgb);\n#else\n        float2 specUV = scn::dual_paraboloid_from_cartesian(normalize(specDir));\n        float3 LD = float3(probeTextureArray.sample(scn::linearSampler, specUV, 0, level(mips)).rgb);\n#endif\n        \n        \n        specular += pbr.probeReflectance * LD * surface.ambientOcclusion * environmentIntensity;\n    }\n\n    void add_global_probe(texturecube<float, access::sample> specularLD,\n                          float4x4                           localDirToWorldCubemapDir,\n                          float                              environmentIntensity)\n    {\n        float3 n        = surface.normal;\n        float3 v        = surface.view;\n        float3 r        = reflect(-v, n); \n        float roughness = surface.roughness;\n\n#if USE_PBR_DOMINANT_DIRECTION\n        float alpha = roughness * roughness;\n        float smoothness = 1.0f - alpha;\n        float specularLerpFactor = (1. - smoothness * (sqrt(smoothness) + alpha));\n        float3 specularDominantNDirection = mix(r, n, specularLerpFactor); \n#else\n        float3 specularDominantNDirection = r;\n#endif\n        \n        \n        float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);\n        float3 dir = scn::mat4_mult_float3(localDirToWorldCubemapDir, specularDominantNDirection);\n        float3 LD = specularLD.sample(scn::linearSampler, dir, level(mipLevel)).rgb;\n        pbr.envSpecular += pbr.probeReflectance * LD * surface.ambientOcclusion * environmentIntensity;\n    }\n\n#ifdef USE_CLEARCOAT\n    void add_global_probeClearCoat(texturecube<float, access::sample> specularLD,\n                          float4x4                           localDirToWorldCubemapDir,\n                          float                              environmentIntensity)\n    {\n        float3 n = surface.clearCoatNormal;\n        \n        float3 v        = surface.view;\n        float3 r        = reflect(-v, n); \n        float roughness = surface.clearCoatRoughness;\n\n        \n        float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);\n        float3 LD = specularLD.sample(scn::linearSampler, scn::mat4_mult_float3(localDirToWorldCubemapDir, r), level(mipLevel)).rgb;\n\n        LD *= surface.ambientOcclusion;\n        \n        \n        float Fc = scn_brdf_F_opt(0.04f, pbr.NoVClearCoat).r * surface.clearCoat;\n        float attenuation = 1.0f - Fc;\n        specular *= (attenuation * attenuation);\n        \n        specular += LD * environmentIntensity * pbr.probeReflectanceClearCoat * surface.clearCoat;\n    }\n#endif\n    \n    \n\n    void add_irradiance_from_selfIllum()\n    {\n        float selfIlluminationAO = saturate(mix(1.f, surface.ambientOcclusion, pbr.selfIlluminationOcclusion));\n        float3 irradiance = surface.selfIllumination.rgb;\n        \n        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        pbr.envDiffuse += selfIlluminationAO * irradiance * diffuseAlbedo;\n#else\n        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);\n        pbr.envDiffuse += selfIlluminationAO * irradiance * diffuseReflectance;\n#endif\n    }\n\n    void add_global_irradiance_from_sh(float4x4         localDirToWorldCubemapDir,\n#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)\n                                       sh2_coefficients shCoefficients)\n#else\n    sh3_coefficients shCoefficients)\n#endif\n    {\n        float3 n_sh_space = scn::mat4_mult_float3(localDirToWorldCubemapDir, surface.normal);\n        float3 irradiance = shEvalDirection(float4(n_sh_space, 1.), shCoefficients);\n        \n        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        pbr.envDiffuse += surface.ambientOcclusion * irradiance * diffuseAlbedo;\n#else\n        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);\n        pbr.envDiffuse += surface.ambientOcclusion * irradiance * diffuseReflectance;\n#endif\n    }\n\n    void add_global_irradiance_probe(texturecube<float, access::sample> irradianceTexture,\n                                     float4x4                           localDirToWorldCubemapDir,\n                                     float                              environmentIntensity)\n    {\n#if USE_PBR_DOMINANT_DIRECTION\n        float3 n = surface.normal;\n        float3 v = surface.view;\n        \n        \n        const half a = 1.02341h * surface.roughness - 1.51174h; \n        const half b = -0.511705h * surface.roughness + 0.755868h;\n        const half diffuseBendFactor = saturate((pbr.NoV * a + b) * surface.roughness);\n        float3 diffuseDominantNDirection = mix(n, v, diffuseBendFactor);\n#else\n        float3 diffuseDominantNDirection = n;\n#endif\n        \n        float3 n_cube_space = scn::mat4_mult_float3(localDirToWorldCubemapDir, diffuseDominantNDirection);\n        float3 irradiance = irradianceTexture.sample(scn::linearSampler, n_cube_space).rgb;\n        \n        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        pbr.envDiffuse += (surface.ambientOcclusion * environmentIntensity) * irradiance * diffuseAlbedo;\n#else\n        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);\n        pbr.envDiffuse += (surface.ambientOcclusion * environmentIntensity) * irradiance * diffuseReflectance;\n#endif\n    }\n\n#endif \n\n    \n\n    static constexpr sampler iesSampler = sampler(filter::linear, mip_filter::none, address::clamp_to_edge);\n    \n    float ies_attenuation(float3 l, scn_light light, texture2d<half> iesTexture)\n    {\n#if USE_QUAT_FOR_IES\n        float3 v    = scn::quaternion_rotate_vector(light.parameters.ies.light_from_view_quat, -l);\n#else\n        float3 v    = scn::matrix_rotate(light.parameters.ies.light_from_view, -l);\n#endif\n        float phi   = (v.z * light.parameters.ies.scaleBias.x + light.parameters.ies.scaleBias.y);\n        float theta = atan2(v.y, v.x) * 0.5f * M_1_PI_F;\n        return iesTexture.sample(iesSampler, float2(phi, abs(theta))).r;\n    }\n\n    void add_ies(scn_light light, texture2d<half> iesTexture)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= ies_attenuation(l, light, iesTexture);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    void add_ies(scn_light light, texture2d<half> iesTexture, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= ies_attenuation(l, light, iesTexture);\n        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    \n\n    void add_area_rectangle(scn_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n        float3 v = surface.view;\n        float3 n = surface.normal;\n        float3 p = surface.position;\n\n        \n        float3 tangent = normalize(v - n * dot(v, n));\n        float3 bitangent = cross(n, tangent);\n        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));\n\n        float3 lightCenter = light.shadowMatrix[3].xyz;\n        \n        \n        float sidedness = dot(light.dir, lightCenter - p);\n        if (light.parameters.area.rectangle.doubleSided == false && sidedness <= 0.f)\n            return;\n        \n        float3 lightRight = light.shadowMatrix[0].xyz * light.parameters.area.rectangle.halfExtents.x * sign(sidedness);\n        float3 lightTop   = light.shadowMatrix[1].xyz * light.parameters.area.rectangle.halfExtents.y;\n        \n        float4x3 cornerDirections = float4x3((lightCenter + lightRight + lightTop) - p,\n                                             (lightCenter + lightRight - lightTop) - p,\n                                             (lightCenter - lightRight - lightTop) - p,\n                                             (lightCenter - lightRight + lightTop) - p);\n\n        cornerDirections[0] = shadingSpaceTransform * cornerDirections[0];\n        cornerDirections[1] = shadingSpaceTransform * cornerDirections[1];\n        cornerDirections[2] = shadingSpaceTransform * cornerDirections[2];\n        cornerDirections[3] = shadingSpaceTransform * cornerDirections[3];\n\n        float diffuseAmount = pbr_area_light_eval_rectangle(cornerDirections);\n\n        float brdfNorm = 1.f;\n        float3x3 inverseLTCMatrix = scn_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);\n\n        cornerDirections[0] = inverseLTCMatrix * cornerDirections[0];\n        cornerDirections[1] = inverseLTCMatrix * cornerDirections[1];\n        cornerDirections[2] = inverseLTCMatrix * cornerDirections[2];\n        cornerDirections[3] = inverseLTCMatrix * cornerDirections[3];\n\n        float specularAmount = brdfNorm * pbr_area_light_eval_rectangle(cornerDirections);\n\n        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); \n        \n        float3 lightColor = light.color.rgb;\n        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;\n        specular += specularAmount * lightColor * pbr.reflectance;\n#endif\n    }\n\n    void add_area_polygon(scn_light light, texture2d_array<float> bakedDataTexture, device packed_float2 *vertexPositions)\n    {\n#ifdef USE_PBR\n        float3 v = surface.view;\n        float3 n = surface.normal;\n        float3 p = surface.position;\n\n        \n        float3 tangent = normalize(v - n * dot(v, n));\n        float3 bitangent = cross(n, tangent);\n        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));\n\n        float3 lightCenter = light.shadowMatrix[3].xyz;\n        \n        \n        float sidedness = dot(light.dir, lightCenter - p);\n        if (light.parameters.area.polygon.doubleSided == false && sidedness <= 0.f)\n            return;\n        \n        float3 lightRight = light.shadowMatrix[0].xyz * sign(sidedness);\n        float3 lightTop   = light.shadowMatrix[1].xyz;\n\n        p           = shadingSpaceTransform * p;\n        lightCenter = shadingSpaceTransform * lightCenter;\n        lightRight  = shadingSpaceTransform * lightRight;\n        lightTop    = shadingSpaceTransform * lightTop;\n\n        float diffuseAmount = pbr_area_light_eval_polygon(p, lightCenter, lightRight, lightTop, light.parameters.area.polygon.vertexCount, vertexPositions);\n\n        float brdfNorm = 1.f;\n        float3x3 inverseLTCMatrix = scn_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);\n\n        p           = inverseLTCMatrix * p;\n        lightCenter = inverseLTCMatrix * lightCenter;\n        lightRight  = inverseLTCMatrix * lightRight;\n        lightTop    = inverseLTCMatrix * lightTop;\n\n        float specularAmount = brdfNorm * pbr_area_light_eval_polygon(p, lightCenter, lightRight, lightTop, light.parameters.area.polygon.vertexCount, vertexPositions);\n        \n        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); \n\n        float3 lightColor = light.color.rgb;\n        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;\n        specular += specularAmount * lightColor * pbr.reflectance;\n#endif\n    }\n\n    void add_area_line(scn_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n        float3 v = surface.view;\n        float3 n = surface.normal;\n        float3 p = surface.position;\n\n        \n        float3 tangent = normalize(v - n * dot(v, n));\n        float3 bitangent = cross(n, tangent);\n        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));\n\n        float3 lightCenter = light.shadowMatrix[3].xyz;\n        float3 lightRight  = light.shadowMatrix[0].xyz * light.parameters.area.line.halfLength;\n\n        float2x3 cornerDirections = float2x3((lightCenter + lightRight) - p,\n                                             (lightCenter - lightRight) - p);\n\n        cornerDirections[0] = shadingSpaceTransform * cornerDirections[0];\n        cornerDirections[1] = shadingSpaceTransform * cornerDirections[1];\n\n        float diffuseAmount = pbr_area_light_eval_line(cornerDirections);\n\n        float brdfNorm = 1.f;\n        float3x3 inverseLTCMatrix = scn_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);\n\n        cornerDirections[0] = inverseLTCMatrix * cornerDirections[0];\n        cornerDirections[1] = inverseLTCMatrix * cornerDirections[1];\n\n        float specularAmount = brdfNorm * pbr_area_light_eval_line(cornerDirections);\n\n        float3 ortho = normalize(cross(cornerDirections[0], cornerDirections[1]));\n        float ltcWidthFactor = 1.0 / length(scn_ltc_matrix_invert_transpose(inverseLTCMatrix) * ortho);\n        specularAmount *= ltcWidthFactor;\n        \n        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); \n\n        float3 lightColor = light.color.rgb;\n        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;\n        specular += specularAmount * lightColor * pbr.reflectance;\n#endif\n    }\n\n    void add_area_ellipse(scn_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n#endif\n    }\n\n    void add_area_ellipsoid(scn_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n#endif\n    }\n};\n\n#endif \n"
+ "%c%c"
+ "@\"<UICoordinateSpace>\"16@0:8"
+ "@\"NSArray\"48@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16"
+ "Error: Skinning internal consistency error - out of range bone index ('%d < %d' assertion failed)"
+ "Error: Skinning internal consistency error - vertex count mismatch ('%d == %d' assertion failed)"
+ "Error: overflow reading mip[%d] (%zu > %zu)"
+ "Error: overflow reading slice[%d] / mip[%d] (%zu > %zu)"
+ "T@\"<UICoordinateSpace>\",R,N"
+ "UIFocusItemContainer"
+ "Welcome to SceneKit 599.201 (Nov 12 2023 08:07:52)"
+ "_appendFocusableNodesInRect:ofView:toFocusItems:"
+ "_focusFrameInView:"
+ "_useFallbackCopyKernel"
+ "focusItemsInRect:"
+ "self.focusItemContainer.coordinateSpace == focusEnvironmentView.coordinateSpace"
+ "skin_copy_as_fallback"
- "#define USE_QUAT_FOR_IES 1\n#define USE_PBR_DOMINANT_DIRECTION 1\n\n\nstruct scn_light\n{\n    float4 color; \n    float3 pos; \n    float3 dir; \n    float shadowRadius; \n    uint8_t lightType; \n    uint8_t attenuationType; \n    uint8_t shadowSampleCount; \n                                \n    union {\n        struct {\n            float4      cascadeScale[4]; \n            float4      cascadeBias[4];\n        } directional; \n        struct {\n            float4      attenuationFactors; \n            float3      shadowScaleBias; \n        } omni;\n        struct {\n            float4      _attenuationFactors; \n            float2      scaleBias; \n        } spot;\n        struct {\n            float4      _attenuationFactors; \n            float2      scaleBias; \n#if USE_QUAT_FOR_IES\n            float4      light_from_view_quat; \n#else\n            float4x4    light_from_view; \n#endif\n        } ies;\n        union {\n            struct {\n                float2 halfExtents;\n                float doubleSided;\n            } rectangle;\n            struct {\n                uint32_t vertexCount;\n                float doubleSided;\n            } polygon;\n            struct {\n                float halfLength;\n            } line;\n            struct {\n                float2 halfExtents;\n                float doubleSided;\n            } ellipse;\n            struct {\n                float3 halfExtents;\n            } ellipsoid;\n        } area;\n        struct {\n            float3  offset;\n            float4  halfExtents; \n            float3  parallaxCenter;\n            float3  parallaxExtents;\n            int32_t index; \n            int32_t parallaxCorrection; \n        } probe;\n    } parameters; \n\n    float4x4    shadowMatrix; \n\n};\n\n#if defined(__METAL_VERSION__) \n\nusing namespace metal;\n\nnamespace scn {\n    static constexpr sampler linearSampler = sampler(filter::linear, mip_filter::linear);\n}\n\n#define ambientOcclusionTexcoord ambientTexcoord\n\nstruct SCNShaderSurface {\n    float3 view;                \n    float3 position;            \n    float3 normal;              \n    float3 geometryNormal;      \n    float2 normalTexcoord;      \n    float3 tangent;             \n    float3 bitangent;           \n    float4 ambient;             \n    float2 ambientTexcoord;     \n    float4 diffuse;             \n    float2 diffuseTexcoord;     \n    float4 specular;            \n    float2 specularTexcoord;    \n    float4 emission;            \n    float2 emissionTexcoord;    \n    float4 selfIllumination;            \n    float2 selfIlluminationTexcoord;    \n    float4 multiply;            \n    float2 multiplyTexcoord;    \n    float4 transparent;         \n    float2 transparentTexcoord; \n    float4 reflective;          \n    float  metalness;           \n    float2 metalnessTexcoord;   \n    float  roughness;           \n    float2 roughnessTexcoord;   \n    float clearCoat;            \n    float2 clearCoatTexcoord;   \n    float clearCoatRoughness;   \n    float2 clearCoatRoughnessTexcoord;\n    float3 clearCoatNormal;     \n    float2 clearCoatNormalTexcoord;\n    float shininess;            \n    float fresnel;              \n    float ambientOcclusion;     \n    float3 _normalTS;           \n    float3 _clearCoatNormalTS;  \n#ifdef USE_SURFACE_EXTRA_DECL\n    __SurfaceExtraDecl__\n#endif\n};\n\n\n\nstruct SCNShaderLight {\n    float4 intensity;\n    float3 direction;\n\n    float  _att;\n    float3 _spotDirection;\n    float  _distance;\n};\n\nenum SCNLightingModel\n{\n    SCNLightingModelConstant,\n    SCNLightingModelLambert,\n    SCNLightingModelPhong,\n    SCNLightingModelBlinn,\n    SCNLightingModelNone,\n    SCNLightingModelPhysicallyBased,\n    SCNLightingModelShadowOnly,\n\n    SCNLightingModelCustom \n};\n\nenum C3DLightAttenuationType\n{\n    kC3DLightAttenuationTypeNone,\n    kC3DLightAttenuationTypeConstant,\n    kC3DLightAttenuationTypeLinear,\n    kC3DLightAttenuationTypeQuadratic,\n    kC3DLightAttenuationTypeExponent,\n    kC3DLightAttenuationTypePhysicallyBased,\n};\n\n#define PROBES_NORMALIZATION 0\n#define PROBES_OUTER_BLENDING 1\n\nstruct SCNShaderLightingContribution\n{\n    float3 ambient;\n    float3 diffuse;\n    float3 specular;\n    float3 modulate;\n\n#ifdef USE_SHADOWONLY\n    float shadowFactor;\n#endif\n\n#if PROBES_NORMALIZATION\n    float4 probesWeightedSum; \n#else\n    float  probeRadianceRemainingFactor;\n#endif\n\n    thread SCNShaderSurface& surface;\n\n#ifdef USE_PER_VERTEX_LIGHTING\n    commonprofile_io out;\n#else\n    commonprofile_io in;\n#endif\n\n#if USE_REVERSE_Z\n    constant static constexpr bool reverseZ = true;\n#else\n    constant static constexpr bool reverseZ = false;\n#endif\n\n#ifdef USE_PBR\n    struct {\n        float3 albedo;\n        float3 envDiffuse;\n        float3 envSpecular;\n        float3 reflectance;\n        float3 probeReflectance;\n#ifndef USE_PBR_LAMBERTIAN_REFLECTION\n        float2 diffuseHammonFactors;\n#endif\n#ifdef USE_PBR_TRANSPARENCY\n        float  transparency;\n#endif\n        float  NoV;\n        float  selfIlluminationOcclusion;\n#ifdef USE_CLEARCOAT\n        float  NoVClearCoat;\n        float3 probeReflectanceClearCoat;\n#endif\n    } pbr;\n#endif\n    \n    SCNShaderLightingContribution(thread SCNShaderSurface& iSurface, commonprofile_io io):surface(iSurface)\n#ifdef USE_PER_VERTEX_LIGHTING\n    ,out(io)\n#else\n    ,in(io)\n#endif\n    {\n        ambient = 0.f;\n        diffuse = 0.f;\n        specular = 0.f;\n#ifdef USE_SHADOWONLY\n        shadowFactor = 1.f;\n#endif\n\n#if PROBES_NORMALIZATION\n#if PROBES_OUTER_BLENDING\n        probesWeightedSum = float4(0.f);\n#else\n        probesWeightedSum = float4(0.f, 0.f, 0.f, 0.000001f); \n#endif\n#else\n        probeRadianceRemainingFactor = 1.f;\n#endif\n\n#ifdef USE_MODULATE\n        modulate = 1.f;\n#else\n        modulate = 0.f;\n#endif\n    }\n\n#ifdef USE_PBR\n    void prepareForPBR(texture2d<float, access::sample> specularDFGDiffuseHammonTexture, float occ)\n    {\n        pbr.envDiffuse = 0.f;\n        pbr.envSpecular = 0.f;\n        pbr.selfIlluminationOcclusion = occ;\n      \n        pbr.albedo = surface.diffuse.rgb;\n#ifdef USE_PBR_TRANSPARENCY\n  #ifdef DIFFUSE_PREMULTIPLIED\n        \n        pbr.transparency = 1.f;\n  #else\n        pbr.transparency = surface.diffuse.a;\n  #endif\n        pbr.transparency = surface.diffuse.a;\n  #ifdef USE_TRANSPARENCY\n    #ifdef USE_PER_VERTEX_LIGHTING\n        pbr.transparency *= out.transparency;\n    #else\n        pbr.transparency *= in.transparency;\n    #endif\n  #endif\n  #ifdef USE_TRANSPARENT\n        \n        pbr.transparency *= surface.transparent.a;\n  #endif\n        pbr.albedo *= pbr.transparency;\n  #ifdef DIFFUSE_PREMULTIPLIED\n        \n        \n        pbr.transparency *= surface.diffuse.a;\n  #endif\n#endif\n        \n        float3 n = surface.normal;\n        float3 v = surface.view;\n        pbr.NoV = abs(dot(n, v));\n        \n        float roughness = surface.roughness;\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        float2 specularDFG = specularDFGDiffuseHammonTexture.sample(scn::linearSampler, float2(pbr.NoV, roughness)).rg;\n#else\n        float4 env = specularDFGDiffuseHammonTexture.sample(scn::linearSampler, float2(pbr.NoV, roughness));\n        float2 specularDFG = env.xy;\n        pbr.diffuseHammonFactors = env.zw;\n#endif\n        \n        pbr.reflectance = mix(PBR_F0_NON_METALLIC, pbr.albedo, surface.metalness);\n        pbr.probeReflectance = pbr.reflectance * specularDFG.r + specularDFG.g;\n                                \n#ifdef USE_CLEARCOAT\n        pbr.NoVClearCoat = abs(dot(surface.clearCoatNormal, v));\n        float2 DFGClearCoat = specularDFGDiffuseHammonTexture.sample(scn::linearSampler, float2(pbr.NoVClearCoat, surface.clearCoatRoughness)).rg;\n        pbr.probeReflectanceClearCoat = 0.04 * DFGClearCoat.r + DFGClearCoat.g;\n#endif\n    }\n#endif\n\n\n#ifdef USE_LIGHT_MODIFIER\n    __LightModifierExtraDecl__\n#endif\n\n    float4 debug_pixel(float2 fragmentPosition)\n    {\n        const int width = 64;\n        switch (int(fragmentPosition.x + fragmentPosition.y ) / width) {\n            case 0: return float4(surface.view, 1.f);\n            case 1: return float4(surface.position, 1.f);\n            case 2: return float4(surface.normal, 1.f);\n            case 3: return float4(surface.geometryNormal, 1.f);\n            case 4: return float4(float3(surface.ambientOcclusion), 1.f);\n            case 5: return surface.diffuse;\n            case 6: return float4(float3(surface.metalness), 1.f);\n            case 7: return float4(float3(surface.roughness), 1.f);\n            case 8: return float4(ambient, 1.f);\n            case 9: return float4(diffuse, 1.f);\n            default: return float4(specular, 1.f);\n        }\n    }\n\n    \n\n    static inline float3 lambert_diffuse(float3 l, float3 n, float3 color, float intensity) {\n        return color * (intensity * saturate(dot(n, l)));\n    }\n\n    void lambert(float3 l, float3 color, float intensity)\n    {\n        diffuse += lambert_diffuse(l, surface.normal, color, intensity);\n    }\n\n    void blinn(float3 l, float3 color, float intensity)\n    {\n        float3 D = lambert_diffuse(l, surface.normal, color, intensity);\n        diffuse += D;\n\n        float3 h = normalize(l + surface.view);\n        specular += powr(saturate(dot(surface.normal, h)), surface.shininess) * D;\n    }\n\n    void phong(float3 l, float3 color, float intensity)\n    {\n        float3 D = lambert_diffuse(l, surface.normal, color, intensity);\n        diffuse += D;\n\n        float3 r = reflect(-l, surface.normal);\n        specular += powr(saturate(dot(r, surface.view)), surface.shininess) * D;\n    }\n\n#ifdef USE_PBR\n    void physicallyBased(float3 l, float3 color, float intensity)\n    {\n        float3 n         = surface.normal;\n        float3 v         = surface.view;\n        float  roughness = surface.roughness;\n        float  alpha     = roughness * roughness;\n\n        float3 h = normalize(l + v);\n\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n        \n        float D   = scn_brdf_D(alpha, NoH);\n        float3 F  = scn_brdf_F_opt(pbr.reflectance, LoH);\n        float Vis = scn_brdf_V(alpha, NoL, pbr.NoV);\n\n        \n        diffuse  += color * (NoL * M_1_PI_F * intensity);\n        specular += color * F * (NoL * D * Vis * intensity);\n        \n        #ifdef USE_CLEARCOAT\n            n = surface.clearCoatNormal;\n\n            roughness = max(surface.clearCoatRoughness, 0.089f);\n            alpha = roughness * roughness; \n        \n            \n            \n            float NoH_coat = saturate(dot(n, h));\n            float NoL_coat = saturate(dot(n, l));\n            D   = scn_brdf_D(alpha, NoH_coat);\n            F   = scn_brdf_F_opt(0.04, LoH) * surface.clearCoat;\n            Vis = scn_brdf_V(alpha, NoL_coat, saturate(dot(n,v)));\n        \n            float attenuation = 1.0 - F.r;\n            specular *=  (attenuation * attenuation);\n            specular += color * F * ( NoL_coat * D * Vis * intensity);\n        #endif\n    }\n#endif\n\n    void custom(float3 _l, float3 _color, float _intensity)\n    {\n#ifdef USE_LIGHT_MODIFIER\n        thread SCNShaderLightingContribution &_lightingContribution = *this;\n        thread SCNShaderSurface& _surface = surface;\n        SCNShaderLight _light = {.direction = _l, .intensity = float4(_color, 1.f), ._att = _intensity };\n        \n        __DoLightModifier__\n        \n#endif\n    }\n\n    void shade(float3 l, float3 color, float intensity)\n    {\n#ifdef LIGHTING_MODEL\n        switch (LIGHTING_MODEL) {\n#ifdef USE_SHADOWONLY\n            case SCNLightingModelShadowOnly:        shadowFactor *= intensity; break;\n#endif\n            case SCNLightingModelLambert:           lambert(l, color, intensity); break;\n            case SCNLightingModelBlinn:             blinn(l, color, intensity);   break;\n            case SCNLightingModelPhong:             phong(l, color, intensity);   break;\n#ifdef USE_PBR\n            case SCNLightingModelPhysicallyBased:   physicallyBased(l, color, intensity); break;\n#endif\n            case SCNLightingModelCustom:            custom(l, color, intensity);  break;\n            default:  break; \n        }\n#endif\n    }\n\n    \n    \n    \n    float pbr_dist_attenuation_alternate(float3 l, float cutoff) {\n        \n        float radius = 0.1f; \n        float factor = 1.f / (1.f + length(l)/radius);\n        float attenuation = saturate(factor * factor); \n        return saturate((attenuation - cutoff) / (1.f - cutoff));\n    }\n\n    float pbr_dist_attenuation(float3 l, float inv_square_radius) {\n        float sqr_dist = length_squared(l);\n        float atten = 1.f / max(sqr_dist, 0.0001f);\n\n        \n        float factor = saturate(1.f - scn::sq(sqr_dist * inv_square_radius));\n        return atten * factor * factor;\n    }\n\n    float non_pbr_dist_attenuation(float3 l, float4 att)\n    {\n        return powr(saturate(length(l) * att.x + att.y), att.z);\n    }\n\n    float dist_attenuation(float3 unnormalized_l, scn_light light)\n    {\n#ifdef USE_PBR\n        return 1000.f * pbr_dist_attenuation(unnormalized_l, light.parameters.omni.attenuationFactors.w);\n        \n        \n#else\n#ifdef USE_SHADOWONLY\n        return 1.f;\n#endif\n        return non_pbr_dist_attenuation(unnormalized_l, light.parameters.omni.attenuationFactors);\n#endif\n    }\n\n    float spot_attenuation(float3 l, scn_light light)\n    {\n#ifdef USE_SHADOWONLY\n        return 1.f;\n#endif\n        \n        return saturate(dot(l, light.dir) * light.parameters.spot.scaleBias.x + light.parameters.spot.scaleBias.y);\n    }\n\n    void shade_modulate(float3 l, float4 color, float intensity)\n    {\n        constexpr half3 white = half3(1.h);\n        \n        modulate *= float3(mix(white, half3(color.rgb), half(color.a * intensity)));\n    }\n\n    float3 gobo(float3 pos, scn_light light, texture2d<half> goboTexture, sampler goboSampler)\n    {\n        half3 g = texture2DProj(goboTexture, goboSampler, (light.shadowMatrix * float4(pos, 1.f))).rgb;\n        return light.color.rgb * float3(mix(1.h, g, half(light.color.a)));\n    }\n\n    float shadow(float3 pos, scn_light light, depth2d<float> shadowMap)\n    {\n        float shadow = ComputeShadow(scn_shadow_sampler, pos, light.shadowMatrix, shadowMap, reverseZ);\n        return 1.f - shadow * light.color.a; \n    }\n\n    \n    float shadow(float3 pos, scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel)\n    {\n        float shadow = ComputeSoftShadow(scn_shadow_sampler, pos, light.shadowMatrix, shadowMap, shadowKernel, light.shadowSampleCount, light.shadowRadius, reverseZ);\n        return 1.f - shadow * light.color.a; \n    }\n\n    float shadow(float3 pos, scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int shadowSampleCount)\n    {\n        float shadow = ComputeSoftShadow(scn_shadow_sampler, pos, light.shadowMatrix, shadowMap, shadowKernel, shadowSampleCount, light.shadowRadius, reverseZ);\n        return 1.f - shadow * light.color.a; \n    }\n\n    float shadow(float3 pos, scn_light light, depth2d<float> shadowMap, int shadowSampleCount)\n    {\n        float shadow = ComputeSoftShadowGrid(scn_shadow_sampler, pos, light.shadowMatrix, shadowMap, shadowSampleCount, reverseZ);\n        return 1.f - shadow * light.color.a; \n    }\n\n    float shadow_omni(float3 pos_vs, float3 nrm_vs, scn_light light, depthcube<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n        \n#define USE_TANGENT_SAMPLING 0\n\n        float2 scaleBias = light.parameters.omni.shadowScaleBias.xy;\n        float  depthBias = light.parameters.omni.shadowScaleBias.z;\n\n        \n        pos_vs += nrm_vs * depthBias;\n\n        \n        float3 pos_ls = (light.shadowMatrix * float4(pos_vs, 1.f)).xyz;\n\n        \n        float z_lin = scn::reduce_max(abs(pos_ls));\n\n        \n        \n        \n\n        \n        float z_ndc = (z_lin * scaleBias.x + scaleBias.y) / z_lin - depthBias;\n\n        \n        float shadow;\n        if (sampleCount <= 1) {\n            shadow = shadowMap.sample_compare(scn_shadow_sampler, pos_ls.xyz, z_ndc);\n        } else {\n            \n            float filteringSizeFactor = light.shadowRadius;\n\n#if USE_TANGENT_SAMPLING\n            float3 tgt_x, tgt_y;\n            scn::orthogonal_basis(pos_ls, tgt_x, tgt_y);\n#else\n            float3 nrm_ls = (light.shadowMatrix * float4(nrm_vs, 0.f)).xyz;\n#endif\n\n            \n            float totalAccum = 0.0;\n            for(int i=0; i < sampleCount; i++){\n\n#if USE_TANGENT_SAMPLING\n                float2 scale = shadowKernel[i].xy * filteringSizeFactor * 2.f;\n                float3 smp_ls = pos_ls.xyz + tgt_x * scale.x + tgt_y * scale.y;\n#else\n                float3 smp_ls = pos_ls.xyz + scn::randomHemisphereDir(nrm_ls, shadowKernel[i].xy) * filteringSizeFactor;\n#endif\n\n                \n                \n                \n\n                totalAccum += shadowMap.sample_compare(scn_shadow_sampler, smp_ls, z_ndc);\n            }\n            shadow = totalAccum / float(sampleCount);\n        }\n\n        return 1.f - shadow * light.color.a; \n    }\n\n    float shadow(float3 pos, constant scn_light& light, depth2d_array<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount)\n    {\n        float shadow = ComputeCascadedShadow(scn_shadow_sampler, pos, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius).a;\n        return 1.f - shadow * light.color.a; \n    }\n\n    \n\n    void add_directional(scn_light light)\n    {\n#ifdef USE_PBR\n        float intensity = M_PI_F;\n#else\n        float intensity = 1.f;\n#endif\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n    void add_directional(scn_light light, texture2d<half> goboTexture, sampler goboSampler, bool modulated)\n    {\n#ifdef USE_PBR\n        float intensity = M_PI_F;\n#else\n        float intensity = 1.f;\n#endif\n        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);\n        if (modulated) {\n            shade_modulate(light.dir, light.color, 1.f);\n        } else {\n            shade(light.dir, light.color.rgb, intensity);\n        }\n    }\n\n    \n    void add_directional(scn_light light, depth2d<float> shadowMap)\n    {\n#ifdef USE_PBR\n        float intensity = M_PI_F;\n#else\n        float intensity = 1.f;\n#endif\n        intensity *= shadow(surface.position, light, shadowMap);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n    void add_directional(scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel)\n    {\n#ifdef USE_PBR\n        float intensity = M_PI_F;\n#else\n        float intensity = 1.f;\n#endif\n        intensity *= shadow(surface.position, light, shadowMap, shadowKernel);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    void add_directional(scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n#ifdef USE_PBR\n        float intensity = M_PI_F;\n#else\n        float intensity = 1.f;\n#endif\n        intensity *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n    void add_directional(scn_light light, depth2d<float> shadowMap, int sampleCount)\n    {\n#ifdef USE_PBR\n        float intensity = M_PI_F;\n#else\n        float intensity = 1.f;\n#endif\n        intensity *= shadow(surface.position, light, shadowMap, sampleCount);\n        shade(light.dir, light.color.rgb, intensity);\n    }\n\n    \n    void add_directional(constant scn_light& light, depth2d_array<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount, bool debugCascades)\n    {\n#ifdef USE_PBR\n        float intensity = M_PI_F;\n#else\n        float intensity = 1.f;\n#endif\n        if (debugCascades) {\n            float4 shadowDebug = ComputeCascadedShadow(scn_shadow_sampler, surface.position, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius);\n            intensity *= (1.f - shadowDebug.a);\n            shade(light.dir, light.color.rgb, intensity);\n            diffuse.rgb = mix(diffuse.rgb, shadowDebug.rgb, light.color.a);\n        } else {\n            intensity *= shadow(surface.position, light, shadowMaps, cascadeCount, blendCascade, shadowKernel, sampleCount);\n            shade(light.dir, light.color.rgb, intensity);\n        }\n    }\n\n    \n\n    void add_omni(scn_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        shade(l, light.color.rgb, dist_attenuation(unnormalized_l, light));\n    }\n\n    void add_omni(scn_light light, depthcube<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity *= shadow_omni(surface.position, surface.normal, light, shadowMap, shadowKernel, sampleCount);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    void add_local_omni(scn_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        shade(l, light.color.rgb, dist_attenuation(unnormalized_l, light));\n    }\n\n    \n\n    void add_spot(scn_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= spot_attenuation(l, light);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    void add_spot(scn_light light, texture2d<half> goboTexture, sampler goboSampler, bool modulated)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= spot_attenuation(l, light);\n        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);\n        if (modulated) {\n            shade_modulate(l, light.color, intensity);\n        } else {\n            shade(l, light.color.rgb, intensity);\n        }\n    }\n\n    void add_local_spot(scn_light light)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= spot_attenuation(l, light);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    \n    void add_spot(scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= spot_attenuation(l, light);\n        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    \n\n#ifdef USE_PBR\n\n    \n\n#ifdef C3D_SUPPORT_CUBE_ARRAY\n    void add_local_probe(scn_light light, texturecube_array<half> probeTextureArray)\n#else\n    void add_local_probe(scn_light light, texture2d_array<half> probeTextureArray)\n#endif\n    {\n#if !PROBES_NORMALIZATION\n        if (probeRadianceRemainingFactor <= 0.f)\n            return;\n#endif\n\n        bool parallaxCorrection = light.parameters.probe.parallaxCorrection;\n        int    probeIndex       = light.parameters.probe.index;\n        float3 probeExtents     = light.parameters.probe.halfExtents.xyz;\n        float  blendDist        = light.parameters.probe.halfExtents.w;\n        float3 probeOffset      = light.parameters.probe.offset;\n        float3 parallaxExtents  = light.parameters.probe.parallaxExtents;\n        float3 parallaxCenter   = light.parameters.probe.parallaxCenter;\n\n        float3 n = surface.normal;\n        float3 v = surface.view;\n        float3 r = reflect(-v, n); \n\n        float3 specDir = scn::mat4_mult_float3(light.shadowMatrix, r);\n\n        \n        float3 pos_ls = (light.shadowMatrix * float4(surface.position, 1.f)).xyz;\n\n        \n        float3 d = abs(pos_ls) - probeExtents;\n#if PROBES_OUTER_BLENDING\n        if (any(d > blendDist))\n#else\n        if (any(d > 0.f))\n#endif\n        {\n            return;\n        }\n\n#if PROBES_NORMALIZATION\n        \n        \n#if PROBES_OUTER_BLENDING\n        float3 nd = saturate(-(d / blendDist) * 0.5f + 0.5f);\n#else\n        float3 nd = saturate(-(d / blendDist));\n#endif\n        float probeFactor = (nd.x * nd.y * nd.z) * light.color.r;\n#else\n        \n        float sd = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n#if PROBES_OUTER_BLENDING\n        float probeFactor = saturate(1.f - sd / blendDist);\n#else\n        float probeFactor = saturate(-sd / blendDist);\n#endif\n        \n        \n        \n        probeFactor *= probeRadianceRemainingFactor * light.color.r; \n#endif\n\n        if (parallaxCorrection ) {\n            \n            float3 pos_off = pos_ls + parallaxCenter;\n            float3 t1 = ( parallaxExtents - pos_off) / specDir;\n            float3 t2 = (-parallaxExtents - pos_off) / specDir;\n            float3 tmax = max(max(0, t1), t2); \n            float t = min(tmax.x, min(tmax.y, tmax.z));\n\n            \n            float3 hit_ls = pos_ls + specDir * t;\n            specDir = hit_ls - probeOffset;\n        }\n\n        float mipd = float(probeTextureArray.get_num_mip_levels()) - 1.f;\n        const float intensity = surface.ambientOcclusion * probeFactor;\n\n        float mips = surface.roughness * mipd;\n#ifdef C3D_SUPPORT_CUBE_ARRAY\n        float3 LD = float3(probeTextureArray.sample(scn::linearSampler, specDir, probeIndex, level(mips)).rgb);\n#else\n        float2 specUV = scn::dual_paraboloid_from_cartesian(normalize(specDir));\n        float3 LD = float3(probeTextureArray.sample(scn::linearSampler, specUV, probeIndex, level(mips)).rgb);\n#endif\n\n        \n\n        \n#if PROBES_NORMALIZATION\n        probesWeightedSum += float4(LD * intensity * pbr.probeReflectance, probeFactor);\n#else\n        probeRadianceRemainingFactor = saturate(probeRadianceRemainingFactor - probeFactor);\n        specular += LD * intensity * pbr.probeReflectance;\n#endif\n        \n#ifdef USE_CLEARCOAT\n        n = surface.clearCoatNormal;\n        r = reflect(-v, n);\n        specDir = scn::mat4_mult_float3(light.shadowMatrix, r);\n        if (parallaxCorrection ) {\n            float3 pos_off = pos_ls + parallaxCenter;\n            \n            float3 t1 = ( parallaxExtents - pos_off) / specDir;\n            float3 t2 = (-parallaxExtents - pos_off) / specDir;\n            float3 tmax = max(max(0, t1), t2); \n            float t = min(tmax.x, min(tmax.y, tmax.z));\n            \n            \n            float3 hit_ls = pos_ls + specDir * t;\n            specDir = hit_ls - probeOffset;\n        }\n        mips = surface.clearCoatRoughness * mipd;\n#ifdef C3D_SUPPORT_CUBE_ARRAY\n        LD = float3(probeTextureArray.sample(scn::linearSampler, specDir, probeIndex, level(mips)).rgb);\n#else\n        specUV = scn::dual_paraboloid_from_cartesian(normalize(specDir));\n        LD = float3(probeTextureArray.sample(scn::linearSampler, specUV, probeIndex, level(mips)).rgb);\n#endif\n#if PROBES_NORMALIZATION\n        probesWeightedSum += float4(LD * intensity * pbr.probeReflectanceClearCoat, probeFactor) * surface.clearCoat;\n#else\n        specular += LD * intensity * pbr.probeReflectanceClearCoat * surface.clearCoat;\n#endif\n#endif\n    }\n\n    void add_global_probe(float4x4 localDirToWorldCubemapDir,\n                          float environmentIntensity,\n#ifdef C3D_SUPPORT_CUBE_ARRAY\n                          texturecube_array<half> probeTextureArray\n#else\n                          texture2d_array<half> probeTextureArray\n#endif\n                          )\n    {\n        float3 n = surface.normal;\n        float3 v = surface.view;\n        float3 r = reflect(-v, n); \n        \n        float3 specDir = scn::mat4_mult_float3(localDirToWorldCubemapDir, r);\n        float mips = surface.roughness * float(probeTextureArray.get_num_mip_levels() - 1);\n#ifdef C3D_SUPPORT_CUBE_ARRAY\n        float3 LD = float3(probeTextureArray.sample(scn::linearSampler, specDir, 0, level(mips)).rgb);\n#else\n        float2 specUV = scn::dual_paraboloid_from_cartesian(normalize(specDir));\n        float3 LD = float3(probeTextureArray.sample(scn::linearSampler, specUV, 0, level(mips)).rgb);\n#endif\n        \n        \n        specular += pbr.probeReflectance * LD * surface.ambientOcclusion * environmentIntensity;\n    }\n\n    void add_global_probe(texturecube<float, access::sample> specularLD,\n                          float4x4                           localDirToWorldCubemapDir,\n                          float                              environmentIntensity)\n    {\n        float3 n        = surface.normal;\n        float3 v        = surface.view;\n        float3 r        = reflect(-v, n); \n        float roughness = surface.roughness;\n\n#if USE_PBR_DOMINANT_DIRECTION\n        float alpha = roughness * roughness;\n        float smoothness = 1.0f - alpha;\n        float specularLerpFactor = (1. - smoothness * (sqrt(smoothness) + alpha));\n        float3 specularDominantNDirection = mix(r, n, specularLerpFactor); \n#else\n        float3 specularDominantNDirection = r;\n#endif\n        \n        \n        float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);\n        float3 dir = scn::mat4_mult_float3(localDirToWorldCubemapDir, specularDominantNDirection);\n        float3 LD = specularLD.sample(scn::linearSampler, dir, level(mipLevel)).rgb;\n        pbr.envSpecular += pbr.probeReflectance * LD * surface.ambientOcclusion * environmentIntensity;\n    }\n\n#ifdef USE_CLEARCOAT\n    void add_global_probeClearCoat(texturecube<float, access::sample> specularLD,\n                          float4x4                           localDirToWorldCubemapDir,\n                          float                              environmentIntensity)\n    {\n        float3 n = surface.clearCoatNormal;\n        \n        float3 v        = surface.view;\n        float3 r        = reflect(-v, n); \n        float roughness = surface.clearCoatRoughness;\n\n        \n        float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);\n        float3 LD = specularLD.sample(scn::linearSampler, scn::mat4_mult_float3(localDirToWorldCubemapDir, r), level(mipLevel)).rgb;\n\n        LD *= surface.ambientOcclusion;\n        \n        \n        float Fc = scn_brdf_F_opt(0.04f, pbr.NoVClearCoat).r * surface.clearCoat;\n        float attenuation = 1.0f - Fc;\n        specular *= (attenuation * attenuation);\n        \n        specular += LD * environmentIntensity * pbr.probeReflectanceClearCoat * surface.clearCoat;\n    }\n#endif\n    \n    \n\n    void add_irradiance_from_selfIllum()\n    {\n        float selfIlluminationAO = saturate(mix(1.f, surface.ambientOcclusion, pbr.selfIlluminationOcclusion));\n        float3 irradiance = surface.selfIllumination.rgb;\n        \n        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        pbr.envDiffuse += selfIlluminationAO * irradiance * diffuseAlbedo;\n#else\n        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);\n        pbr.envDiffuse += selfIlluminationAO * irradiance * diffuseReflectance;\n#endif\n    }\n\n    void add_global_irradiance_from_sh(float4x4         localDirToWorldCubemapDir,\n#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)\n                                       sh2_coefficients shCoefficients)\n#else\n    sh3_coefficients shCoefficients)\n#endif\n    {\n        float3 n_sh_space = scn::mat4_mult_float3(localDirToWorldCubemapDir, surface.normal);\n        float3 irradiance = shEvalDirection(float4(n_sh_space, 1.), shCoefficients);\n        \n        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        pbr.envDiffuse += surface.ambientOcclusion * irradiance * diffuseAlbedo;\n#else\n        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);\n        pbr.envDiffuse += surface.ambientOcclusion * irradiance * diffuseReflectance;\n#endif\n    }\n\n    void add_global_irradiance_probe(texturecube<float, access::sample> irradianceTexture,\n                                     float4x4                           localDirToWorldCubemapDir,\n                                     float                              environmentIntensity)\n    {\n#if USE_PBR_DOMINANT_DIRECTION\n        float3 n = surface.normal;\n        float3 v = surface.view;\n        \n        \n        const half a = 1.02341h * surface.roughness - 1.51174h; \n        const half b = -0.511705h * surface.roughness + 0.755868h;\n        const half diffuseBendFactor = saturate((pbr.NoV * a + b) * surface.roughness);\n        float3 diffuseDominantNDirection = mix(n, v, diffuseBendFactor);\n#else\n        float3 diffuseDominantNDirection = n;\n#endif\n        \n        float3 n_cube_space = scn::mat4_mult_float3(localDirToWorldCubemapDir, diffuseDominantNDirection);\n        float3 irradiance = irradianceTexture.sample(scn::linearSampler, n_cube_space).rgb;\n        \n        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);\n#ifdef USE_PBR_LAMBERTIAN_REFLECTION\n        pbr.envDiffuse += (surface.ambientOcclusion * environmentIntensity) * irradiance * diffuseAlbedo;\n#else\n        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);\n        pbr.envDiffuse += (surface.ambientOcclusion * environmentIntensity) * irradiance * diffuseReflectance;\n#endif\n    }\n\n#endif \n\n    \n\n    static constexpr sampler iesSampler = sampler(filter::linear, mip_filter::none, address::clamp_to_edge);\n    \n    float ies_attenuation(float3 l, scn_light light, texture2d<half> iesTexture)\n    {\n#if USE_QUAT_FOR_IES\n        float3 v    = scn::quaternion_rotate_vector(light.parameters.ies.light_from_view_quat, -l);\n#else\n        float3 v    = scn::matrix_rotate(light.parameters.ies.light_from_view, -l);\n#endif\n        float phi   = (v.z * light.parameters.ies.scaleBias.x + light.parameters.ies.scaleBias.y);\n        float theta = atan2(v.y, v.x) * 0.5f * M_1_PI_F;\n        return iesTexture.sample(iesSampler, float2(phi, abs(theta))).r;\n    }\n\n    void add_ies(scn_light light, texture2d<half> iesTexture)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= ies_attenuation(l, light, iesTexture);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    void add_ies(scn_light light, texture2d<half> iesTexture, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)\n    {\n        float3 unnormalized_l = light.pos - surface.position;\n        float3 l = normalize(unnormalized_l);\n        float intensity = dist_attenuation(unnormalized_l, light);\n        intensity      *= ies_attenuation(l, light, iesTexture);\n        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);\n        shade(l, light.color.rgb, intensity);\n    }\n\n    \n\n    void add_area_rectangle(scn_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n        float3 v = surface.view;\n        float3 n = surface.normal;\n        float3 p = surface.position;\n\n        \n        float3 tangent = normalize(v - n * dot(v, n));\n        float3 bitangent = cross(n, tangent);\n        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));\n\n        float3 lightCenter = light.shadowMatrix[3].xyz;\n        \n        \n        float sidedness = dot(light.dir, lightCenter - p);\n        if (light.parameters.area.rectangle.doubleSided == false && sidedness <= 0.f)\n            return;\n        \n        float3 lightRight = light.shadowMatrix[0].xyz * light.parameters.area.rectangle.halfExtents.x * sign(sidedness);\n        float3 lightTop   = light.shadowMatrix[1].xyz * light.parameters.area.rectangle.halfExtents.y;\n        \n        float4x3 cornerDirections = float4x3((lightCenter + lightRight + lightTop) - p,\n                                             (lightCenter + lightRight - lightTop) - p,\n                                             (lightCenter - lightRight - lightTop) - p,\n                                             (lightCenter - lightRight + lightTop) - p);\n\n        cornerDirections[0] = shadingSpaceTransform * cornerDirections[0];\n        cornerDirections[1] = shadingSpaceTransform * cornerDirections[1];\n        cornerDirections[2] = shadingSpaceTransform * cornerDirections[2];\n        cornerDirections[3] = shadingSpaceTransform * cornerDirections[3];\n\n        float diffuseAmount = pbr_area_light_eval_rectangle(cornerDirections);\n\n        float brdfNorm = 1.f;\n        float3x3 inverseLTCMatrix = scn_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);\n\n        cornerDirections[0] = inverseLTCMatrix * cornerDirections[0];\n        cornerDirections[1] = inverseLTCMatrix * cornerDirections[1];\n        cornerDirections[2] = inverseLTCMatrix * cornerDirections[2];\n        cornerDirections[3] = inverseLTCMatrix * cornerDirections[3];\n\n        float specularAmount = brdfNorm * pbr_area_light_eval_rectangle(cornerDirections);\n\n        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); \n        \n        float3 lightColor = light.color.rgb;\n        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;\n        specular += specularAmount * lightColor * pbr.reflectance;\n#endif\n    }\n\n    void add_area_polygon(scn_light light, texture2d_array<float> bakedDataTexture, device packed_float2 *vertexPositions)\n    {\n#ifdef USE_PBR\n        float3 v = surface.view;\n        float3 n = surface.normal;\n        float3 p = surface.position;\n\n        \n        float3 tangent = normalize(v - n * dot(v, n));\n        float3 bitangent = cross(n, tangent);\n        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));\n\n        float3 lightCenter = light.shadowMatrix[3].xyz;\n        \n        \n        float sidedness = dot(light.dir, lightCenter - p);\n        if (light.parameters.area.polygon.doubleSided == false && sidedness <= 0.f)\n            return;\n        \n        float3 lightRight = light.shadowMatrix[0].xyz * sign(sidedness);\n        float3 lightTop   = light.shadowMatrix[1].xyz;\n\n        p           = shadingSpaceTransform * p;\n        lightCenter = shadingSpaceTransform * lightCenter;\n        lightRight  = shadingSpaceTransform * lightRight;\n        lightTop    = shadingSpaceTransform * lightTop;\n\n        float diffuseAmount = pbr_area_light_eval_polygon(p, lightCenter, lightRight, lightTop, light.parameters.area.polygon.vertexCount, vertexPositions);\n\n        float brdfNorm = 1.f;\n        float3x3 inverseLTCMatrix = scn_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);\n\n        p           = inverseLTCMatrix * p;\n        lightCenter = inverseLTCMatrix * lightCenter;\n        lightRight  = inverseLTCMatrix * lightRight;\n        lightTop    = inverseLTCMatrix * lightTop;\n\n        float specularAmount = brdfNorm * pbr_area_light_eval_polygon(p, lightCenter, lightRight, lightTop, light.parameters.area.polygon.vertexCount, vertexPositions);\n        \n        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); \n\n        float3 lightColor = light.color.rgb;\n        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;\n        specular += specularAmount * lightColor * pbr.reflectance;\n#endif\n    }\n\n    void add_area_line(scn_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n        float3 v = surface.view;\n        float3 n = surface.normal;\n        float3 p = surface.position;\n\n        \n        float3 tangent = normalize(v - n * dot(v, n));\n        float3 bitangent = cross(n, tangent);\n        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));\n\n        float3 lightCenter = light.shadowMatrix[3].xyz;\n        float3 lightRight  = light.shadowMatrix[0].xyz * light.parameters.area.line.halfLength;\n\n        float2x3 cornerDirections = float2x3((lightCenter + lightRight) - p,\n                                             (lightCenter - lightRight) - p);\n\n        cornerDirections[0] = shadingSpaceTransform * cornerDirections[0];\n        cornerDirections[1] = shadingSpaceTransform * cornerDirections[1];\n\n        float diffuseAmount = pbr_area_light_eval_line(cornerDirections);\n\n        float brdfNorm = 1.f;\n        float3x3 inverseLTCMatrix = scn_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);\n\n        cornerDirections[0] = inverseLTCMatrix * cornerDirections[0];\n        cornerDirections[1] = inverseLTCMatrix * cornerDirections[1];\n\n        float specularAmount = brdfNorm * pbr_area_light_eval_line(cornerDirections);\n\n        float3 ortho = normalize(cross(cornerDirections[0], cornerDirections[1]));\n        float ltcWidthFactor = 1.0 / length(scn_ltc_matrix_invert_transpose(inverseLTCMatrix) * ortho);\n        specularAmount *= ltcWidthFactor;\n        \n        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); \n\n        float3 lightColor = light.color.rgb;\n        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;\n        specular += specularAmount * lightColor * pbr.reflectance;\n#endif\n    }\n\n    void add_area_ellipse(scn_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n#endif\n    }\n\n    void add_area_ellipsoid(scn_light light, texture2d_array<float> bakedDataTexture)\n    {\n#ifdef USE_PBR\n#endif\n    }\n};\n\n#endif \n"
- "Assertion '%s' failed. Internal inconsistency"
- "Assertion '%s' failed. Skinning internal consistency error - vertex count mismatch"
- "Error: overflow reading slice[%d] / mip[%d] (%d > %d)"
- "Welcome to SceneKit 599.108 (Oct  3 2023 23:12:10)"
- "_baseVertexCount == deindexedVertexCount"
- "_baseVertexCount == skinVertexCount"
- "_convertFrameToView:"
- "_focusFrameForSCNNode:"
- "_focusableCandidates:"
- "_focusedItemRegionContainer"
- "_getFocusNodes"
- "_getFocusableNodes"
- "_isEligibleForFocus"
- "_searchForFocusRegionsInContext:"
- "addRegion:"
- "boneIndicesSInt16[i] < jointCount"
- "convertRect:toCoordinateSpace:"
- "focusItemContainer.coordinateSpace == focusEnvironmentView"
- "initWithFrame:coordinateSpace:item:"
- "intersectsRect:"
- "searchArea"

```
