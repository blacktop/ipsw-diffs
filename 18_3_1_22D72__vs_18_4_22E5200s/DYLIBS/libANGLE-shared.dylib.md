## libANGLE-shared.dylib

> `/System/Library/PrivateFrameworks/WebCore.framework/Frameworks/libANGLE-shared.dylib`

```diff

-620.2.4.10.7
-  __TEXT.__text: 0x2674b4
-  __TEXT.__auth_stubs: 0xe10
-  __TEXT.__const: 0x87db0
-  __TEXT.__cstring: 0x47e23
-  __TEXT.__gcc_except_tab: 0x2e60
+621.1.10.20.6
+  __TEXT.__text: 0x259680
+  __TEXT.__auth_stubs: 0xe70
+  __TEXT.__const: 0x881d0
+  __TEXT.__cstring: 0x418f6
+  __TEXT.__gcc_except_tab: 0x2e54
   __TEXT.__oslogstring: 0xf
-  __TEXT.__unwind_info: 0x1968
+  __TEXT.__unwind_info: 0x18b8
   __TEXT.__objc_classname: 0x1
-  __TEXT.__objc_methname: 0x17fd
-  __TEXT.__objc_stubs: 0x1f00
-  __DATA_CONST.__got: 0x138
-  __DATA_CONST.__const: 0x17228
+  __TEXT.__objc_methname: 0x1825
+  __TEXT.__objc_stubs: 0x1f20
+  __DATA_CONST.__got: 0x130
+  __DATA_CONST.__const: 0x14c78
   __DATA_CONST.__objc_imageinfo: 0x8
-  __DATA_CONST.__objc_selrefs: 0x7c0
-  __AUTH_CONST.__auth_got: 0x718
+  __DATA_CONST.__objc_selrefs: 0x7c8
+  __AUTH_CONST.__auth_got: 0x748
   __AUTH_CONST.__auth_ptr: 0x8
-  __AUTH_CONST.__const: 0x16b78
-  __AUTH_CONST.__cfstring: 0x9e0
-  __DATA.__data: 0x2ee18
-  __DATA.__common: 0x370
-  __DATA.__bss: 0x4
-  __DATA_DIRTY.__data: 0xfd8
-  __DATA_DIRTY.__common: 0x4a8
-  __DATA_DIRTY.__bss: 0x288
+  __AUTH_CONST.__const: 0x166b0
+  __AUTH_CONST.__cfstring: 0x9c0
+  __DATA.__data: 0x2b6c8
+  __DATA.__bss: 0xc
+  __DATA.__common: 0x3c0
+  __DATA_DIRTY.__data: 0xf10
+  __DATA_DIRTY.__bss: 0x278
+  __DATA_DIRTY.__common: 0x4f8
   - /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation
   - /System/Library/Frameworks/CoreGraphics.framework/CoreGraphics
   - /System/Library/Frameworks/Foundation.framework/Foundation

   - /usr/lib/libc++.1.dylib
   - /usr/lib/libobjc.A.dylib
   - /usr/lib/libz.1.dylib
-  Functions: 9526
-  Symbols:   9899
-  CStrings:  8073
+  Functions: 9107
+  Symbols:   9873
+  CStrings:  7206
 
Symbols:
+ _GL_BlendEquationOES
+ _GL_BlobCacheCallbacksANGLE
+ _GL_GetPointervANGLE
+ _GL_TexStorageAttribs2DEXT
+ _GL_TexStorageAttribs3DEXT
+ _ceilf
+ _dispatch_get_global_queue
+ _floorf
+ _ldexpf
+ _objc_retain_x27
+ _roundf
+ _sqrtf
+ _truncf
- __dispatch_main_q
- _dispatch_release
- _objc_retain_x26
CStrings:
+ "\n#define ANGLE_SAMPLE_COMPARE_GRADIENT_INDEX   0\n#define ANGLE_RASTERIZATION_DISCARD_INDEX     1\n#define ANGLE_MULTISAMPLED_RENDERING_INDEX    2\n#define ANGLE_DEPTH_WRITE_ENABLED_INDEX       3\n#define ANGLE_EMULATE_ALPHA_TO_COVERAGE_INDEX 4\n#define ANGLE_WRITE_HELPER_SAMPLE_MASK_INDEX  5\n\nconstant bool ANGLEUseSampleCompareGradient [[function_constant(ANGLE_SAMPLE_COMPARE_GRADIENT_INDEX)]];\nconstant bool ANGLERasterizerDisabled       [[function_constant(ANGLE_RASTERIZATION_DISCARD_INDEX)]];\nconstant bool ANGLEMultisampledRendering    [[function_constant(ANGLE_MULTISAMPLED_RENDERING_INDEX)]];\nconstant bool ANGLEDepthWriteEnabled        [[function_constant(ANGLE_DEPTH_WRITE_ENABLED_INDEX)]];\nconstant bool ANGLEEmulateAlphaToCoverage   [[function_constant(ANGLE_EMULATE_ALPHA_TO_COVERAGE_INDEX)]];\nconstant bool ANGLEWriteHelperSampleMask    [[function_constant(ANGLE_WRITE_HELPER_SAMPLE_MASK_INDEX)]];\n\n#define ANGLE_ALPHA0\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float3 const coord)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, coord.z);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float3 const coord,\n    float const bias)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, coord.z, metal::bias(bias));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::depth2d_array<float>> &env,\n    metal::float4 const coord)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::depth2d_array<float>> &env,\n    metal::float4 const coord,\n    float const bias)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::bias(bias));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::depthcube<float>> &env,\n    metal::float4 const coord)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xyz, coord.w);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::depthcube<float>> &env,\n    metal::float4 const coord,\n    float const bias)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xyz, coord.w, metal::bias(bias));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture2D(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float2 const coord)\n{\n    return env.texture->sample(*env.sampler, coord);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture2D(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float2 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord, metal::bias(bias));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DGradEXT(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float2 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord, metal::gradient2d(dPdx, dPdy));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DLod(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float2 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord, metal::level(level));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProj(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float3 const coord)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z);\n}\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProj(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float4 const coord)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProj(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float3 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z, metal::bias(bias));\n}\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProj(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float4 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w, metal::bias(bias));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjGradEXT(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z, metal::gradient2d(dPdx, dPdy));\n}\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjGradEXT(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjLod(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float3 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z, metal::level(level));\n}\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjLod(\n    thread ANGLE_TextureEnv<metal::texture2d<float>> &env,\n    metal::float4 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w, metal::level(level));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture3D(\n    thread ANGLE_TextureEnv<metal::texture3d<float>> &env,\n    metal::float3 const coord)\n{\n    return env.texture->sample(*env.sampler, coord);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture3D(\n    thread ANGLE_TextureEnv<metal::texture3d<float>> &env,\n    metal::float3 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord, metal::bias(bias));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture3DLod(\n    thread ANGLE_TextureEnv<metal::texture3d<float>> &env,\n    metal::float3 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord, metal::level(level));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture3DProj(\n    thread ANGLE_TextureEnv<metal::texture3d<float>> &env,\n    metal::float4 const coord)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture3DProj(\n    thread ANGLE_TextureEnv<metal::texture3d<float>> &env,\n    metal::float4 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w, metal::bias(bias));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_texture3DProjLod(\n    thread ANGLE_TextureEnv<metal::texture3d<float>> &env,\n    metal::float4 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w, metal::level(level));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureCube(\n    thread ANGLE_TextureEnv<metal::texturecube<float>> &env,\n    metal::float3 const coord)\n{\n    return env.texture->sample(*env.sampler, coord);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureCube(\n    thread ANGLE_TextureEnv<metal::texturecube<float>> &env,\n    metal::float3 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord, metal::bias(bias));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureCubeGradEXT(\n    thread ANGLE_TextureEnv<metal::texturecube<float>> &env,\n    metal::float3 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord, metal::gradientcube(dPdx, dPdy));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureCubeLod(\n    thread ANGLE_TextureEnv<metal::texturecube<float>> &env,\n    metal::float3 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord, metal::level(level));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return env.texture->sample_compare(*env.sampler, coord.xy, coord.z, metal::gradient2d(dPdx, dPdy));\n    }\n    else\n    {\n        const float2 dims = float2(env.texture->get_width(0), env.texture->get_height(0));\n        const float lod = 0.5 * metal::log2(metal::max(metal::length_squared(dPdx * dims), metal::length_squared(dPdy * dims)));\n        return env.texture->sample_compare(*env.sampler, coord.xy, coord.z, metal::level(lod));\n    }\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad(\n    thread ANGLE_TextureEnv<metal::depth2d_array<float>> &env,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return env.texture->sample_compare(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::gradient2d(dPdx, dPdy));\n    }\n    else\n    {\n        const float2 dims = float2(env.texture->get_width(0), env.texture->get_height(0));\n        const float lod = 0.5 * metal::log2(metal::max(metal::length_squared(dPdx * dims), metal::length_squared(dPdy * dims)));\n        return env.texture->sample_compare(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::level(lod));\n    }\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad(\n    thread ANGLE_TextureEnv<metal::depthcube<float>> &env,\n    metal::float4 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return env.texture->sample_compare(*env.sampler, coord.xyz, coord.w, metal::gradientcube(dPdx, dPdy));\n    }\n    else\n    {\n        const float3 coord_abs = metal::abs(coord.xyz);\n        const bool z_major = coord_abs.z >= metal::max(coord_abs.x, coord_abs.y);\n        const bool y_major = coord_abs.y >= metal::max(coord_abs.x, coord_abs.z);\n        const float3 Q = z_major ? coord.xyz : (y_major ? coord.xzy : coord.yzx);\n        const float3 dQdx = z_major ? dPdx : (y_major ? dPdx.xzy : dPdx.yzx);\n        const float3 dQdy = z_major ? dPdy : (y_major ? dPdy.xzy : dPdy.yzx);\n        const float4 d = (float4(dQdx.xy, dQdy.xy) - (Q.xy / Q.z).xyxy * float4(dQdx.zz, dQdy.zz)) / Q.z;\n        const float dim = float(env.texture->get_width(0));\n        const float lod = -1.0 + 0.5 * metal::log2(dim * dim * metal::max(metal::length_squared(d.xy), metal::length_squared(d.zw)));\n        return env.texture->sample_compare(*env.sampler, coord.xyz, coord.w, metal::level(lod));\n    }\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    metal::int2 const offset)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return env.texture->sample_compare(*env.sampler, coord.xy, coord.z, metal::gradient2d(dPdx, dPdy), offset);\n    }\n    else\n    {\n        const float2 dims = float2(env.texture->get_width(0), env.texture->get_height(0));\n        const float lod = 0.5 * metal::log2(metal::max(metal::length_squared(dPdx * dims), metal::length_squared(dPdy * dims)));\n        return env.texture->sample_compare(*env.sampler, coord.xy, coord.z, metal::level(lod), offset);\n    }\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset(\n    thread ANGLE_TextureEnv<metal::depth2d_array<float>> &env,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    metal::int2 const offset)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return env.texture->sample_compare(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::gradient2d(dPdx, dPdy), offset);\n    }\n    else\n    {\n        const float2 dims = float2(env.texture->get_width(0), env.texture->get_height(0));\n        const float lod = 0.5 * metal::log2(metal::max(metal::length_squared(dPdx * dims), metal::length_squared(dPdy * dims)));\n        return env.texture->sample_compare(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::level(lod), offset);\n    }\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float3 const coord,\n    float const level)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, coord.z, metal::level(level));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod(\n    thread ANGLE_TextureEnv<metal::depth2d_array<float>> &env,\n    metal::float4 const coord,\n    float const level)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::level(level));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod(\n    thread ANGLE_TextureEnv<metal::depthcube<float>> &env,\n    metal::float4 const coord,\n    float const level)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xyz, coord.w, metal::level(level));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float3 const coord,\n    float const level,\n    int2 const offset)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, coord.z, metal::level(level), offset);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset(\n    thread ANGLE_TextureEnv<metal::depth2d_array<float>> &env,\n    metal::float4 const coord,\n    float const level,\n    metal::int2 const offset)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::level(level), offset);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float3 const coord,\n    metal::int2 const offset)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, coord.z, offset);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float3 const coord,\n    metal::int2 const offset,\n    float const bias)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, coord.z, metal::bias(bias), offset);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset(\n    thread ANGLE_TextureEnv<metal::depth2d_array<float>> &env,\n    metal::float4 const coord,\n    metal::int2 const offset)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, offset);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset(\n    thread ANGLE_TextureEnv<metal::depth2d_array<float>> &env,\n    metal::float4 const coord,\n    metal::int2 const offset,\n    float const bias)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::bias(bias), offset);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float4 const coord)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy/coord.w, coord.z/coord.w);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float4 const coord,\n    float const bias)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy/coord.w, coord.z/coord.w, metal::bias(bias));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return env.texture->sample_compare(*env.sampler, coord.xy/coord.w, coord.z/coord.w, metal::gradient2d(dPdx, dPdy));\n    }\n    else\n    {\n        const float2 dims = float2(env.texture->get_width(0), env.texture->get_height(0));\n        const float lod = 0.5 * metal::log2(metal::max(metal::length_squared(dPdx * dims), metal::length_squared(dPdy * dims)));\n        return env.texture->sample_compare(*env.sampler, coord.xy/coord.w, coord.z/coord.w, metal::level(lod));\n    }\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    int2 const offset)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return env.texture->sample_compare(*env.sampler, coord.xy/coord.w, coord.z/coord.w, metal::gradient2d(dPdx, dPdy), offset);\n    }\n    else\n    {\n        const float2 dims = float2(env.texture->get_width(0), env.texture->get_height(0));\n        const float lod = 0.5 * metal::log2(metal::max(metal::length_squared(dPdx * dims), metal::length_squared(dPdy * dims)));\n        return env.texture->sample_compare(*env.sampler, coord.xy/coord.w, coord.z/coord.w, metal::level(lod), offset);\n    }\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float4 const coord,\n    float const level)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy/coord.w, coord.z/coord.w, metal::level(level));\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float4 const coord,\n    float const level,\n    int2 const offset)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy/coord.w, coord.z/coord.w, metal::level(level), offset);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float4 const coord,\n    int2 const offset)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy/coord.w, coord.z/coord.w, offset);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset(\n    thread ANGLE_TextureEnv<metal::depth2d<float>> &env,\n    metal::float4 const coord,\n    int2 const offset,\n    float const bias)\n{\n    return env.texture->sample_compare(*env.sampler, coord.xy/coord.w, coord.z/coord.w, metal::bias(bias), offset);\n}\n\n"
+ "\nANGLE_ALWAYS_INLINE auto ANGLE_textureSize(\n    thread ANGLE_TextureEnv<metal::depth2d_array<float>> &env,\n    int const level)\n{\n    return int3(env.texture->get_width(uint32_t(level)), env.texture->get_height(uint32_t(level)), env.texture->get_array_size());\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetch(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::int2 const coord,\n    int const level)\n{\n    return env.texture->read(uint2(coord), uint32_t(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetch(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    metal::int3 const coord,\n    int const level)\n{\n    return env.texture->read(uint2(coord.xy), uint32_t(coord.z), uint32_t(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetch(\n    thread ANGLE_TextureEnv<metal::texture2d_ms<T>> &env,\n    metal::int2 const coord,\n    int const sample)\n{\n    return env.texture->read(uint2(coord), uint32_t(sample));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetch(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::int3 const coord,\n    int const level)\n{\n    return env.texture->read(uint3(coord), uint32_t(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::int2 const coord,\n    int const level,\n    metal::int2 const offset)\n{\n    return env.texture->read(uint2(coord + offset), uint32_t(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    metal::int3 const coord,\n    int const level,\n    metal::int2 const offset)\n{\n    return env.texture->read(uint2(coord.xy + offset), uint32_t(coord.z), uint32_t(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::int3 const coord,\n    int const level,\n    metal::int3 const offset)\n{\n    return env.texture->read(uint3(coord + offset), uint32_t(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float2 const coord)\n{\n    return env.texture->sample(*env.sampler, coord);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float2 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord, metal::bias(bias));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    metal::float3 const coord)\n{\n    return env.texture->sample(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    metal::float3 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::bias(bias));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float3 const coord)\n{\n    return env.texture->sample(*env.sampler, coord);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float3 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord, metal::bias(bias));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::texturecube<T>> &env,\n    metal::float3 const coord)\n{\n    return env.texture->sample(*env.sampler, coord);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture(\n    thread ANGLE_TextureEnv<metal::texturecube<T>> &env,\n    metal::float3 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord, metal::bias(bias));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float2 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord, metal::gradient2d(dPdx, dPdy));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float3 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord, metal::gradient3d(dPdx, dPdy));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad(\n    thread ANGLE_TextureEnv<metal::texturecube<T>> &env,\n    metal::float3 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord, metal::gradientcube(dPdx, dPdy));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float2 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord, metal::gradient2d(dPdx, dPdy), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    metal::int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float3 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy,\n    int3 const offset)\n{\n    return env.texture->sample(*env.sampler, coord, metal::gradient3d(dPdx, dPdy), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float2 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord, metal::level(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    metal::float3 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::level(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float3 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord, metal::level(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod(\n    thread ANGLE_TextureEnv<metal::texturecube<T>> &env,\n    metal::float3 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord, metal::level(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float2 const coord,\n    float const level,\n    metal::int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord, metal::level(level), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    metal::float3 const coord,\n    float const level,\n    metal::int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::level(level), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float3 const coord,\n    float const level,\n    metal::int3 const offset)\n{\n    return env.texture->sample(*env.sampler, coord, metal::level(level), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float2 const coord,\n    metal::int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord, offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float2 const coord,\n    metal::int2 const offset,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord, metal::bias(bias), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    metal::float3 const coord,\n    metal::int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    metal::float3 const coord,\n    metal::int2 const offset,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::bias(bias), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float3 const coord,\n    metal::int3 const offset)\n{\n    return env.texture->sample(*env.sampler, coord, offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float3 const coord,\n    metal::int3 const offset,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord, metal::bias(bias), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float3 const coord)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float3 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z, metal::bias(bias));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float4 const coord)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float4 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w, metal::bias(bias));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float4 const coord)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float4 const coord,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w, metal::bias(bias));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z, metal::gradient2d(dPdx, dPdy));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float4 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w, metal::gradient3d(dPdx, dPdy));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z, metal::gradient2d(dPdx, dPdy), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float4 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy,\n    int3 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w, metal::gradient3d(dPdx, dPdy), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float3 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z, metal::level(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float4 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w, metal::level(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float4 const coord,\n    float const level)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w, metal::level(level));\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float3 const coord,\n    float const level,\n    int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z, metal::level(level), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float4 const coord,\n    float const level,\n    int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w, metal::level(level), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float4 const coord,\n    float const level,\n    int3 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w, metal::level(level), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float3 const coord,\n    int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z, offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float3 const coord,\n    int2 const offset,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.z, metal::bias(bias), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float4 const coord,\n    int2 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w, offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset(\n    thread ANGLE_TextureEnv<metal::texture2d<T>> &env,\n    metal::float4 const coord,\n    int2 const offset,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xy/coord.w, metal::bias(bias), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float4 const coord,\n    int3 const offset)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w, offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    metal::float4 const coord,\n    int3 const offset,\n    float const bias)\n{\n    return env.texture->sample(*env.sampler, coord.xyz/coord.w, metal::bias(bias), offset);\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureSize(\n    thread ANGLE_TextureEnv<metal::texture2d_array<T>> &env,\n    int const level)\n{\n    return int3(env.texture->get_width(uint32_t(level)), env.texture->get_height(uint32_t(level)), env.texture->get_array_size());\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureSize(\n    thread ANGLE_TextureEnv<metal::texture2d_ms<T>> &env)\n{\n    return int2(env.texture->get_width(), env.texture->get_height());\n}\n\n"
+ "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureSize(\n    thread ANGLE_TextureEnv<metal::texture3d<T>> &env,\n    int const level)\n{\n    return int3(env.texture->get_width(uint32_t(level)), env.texture->get_height(uint32_t(level)), env.texture->get_depth(uint32_t(level)));\n}\n\n"
+ "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureSize(\n    thread ANGLE_TextureEnv<Texture> &env,\n    int const level)\n{\n    return int2(env.texture->get_width(uint32_t(level)), env.texture->get_height(uint32_t(level)));\n}\n\n"
+ "%lld"
+ "0c78e2d5d697f629a5e1967a977603b7"
+ "2.1.24428 git hash: 96952a9b1b39"
+ ":ARM_shader_framebuffer_fetch_depth_stencil:"
+ ":EXT_texture_query_lod:"
+ ":EXT_texture_shadow_lod:"
+ "ANGLE_GL_RENDERER"
+ "ANGLE_GL_VENDOR"
+ "ARM_shader_framebuffer_fetch_depth_stencil"
+ "Active pixel local storage plane(s) are not referenced by the draw program."
+ "Blob cache callbacks must both be NULL or both be non-NULL."
+ "Call a function"
+ "Constant union"
+ "Draw program references pixel local storage plane(s) that are not currently active."
+ "EGL_ANDROID_front_buffer_auto_refresh"
+ "EGL_FRONT_BUFFER_AUTO_REFRESH_ANDROID cannot be used without EGL_ANDROID_front_buffer_auto_refresh support."
+ "EXT_texture_query_lod"
+ "EXT_texture_shadow_lod"
+ "Fixed rate compressed texture image not supported in glBindImageTexture."
+ "Found symbol with empty name"
+ "Framebuffer is incomplete: Combined depth/stencil formats cannot be used with separate depth and stencil buffers."
+ "GL_ANGLE_blob_cache"
+ "GL_ARM_rgba8"
+ "GL_ARM_shader_framebuffer_fetch_depth_stencil"
+ "GL_EXT_EGL_image_storage_compression"
+ "GL_EXT_separate_depth_stencil"
+ "GL_EXT_texture_query_lod"
+ "GL_EXT_texture_shadow_lod"
+ "GL_EXT_texture_storage_compression"
+ "GL_EXT_texture_storage_compression not enabled"
+ "GL_OES_blend_subtract"
+ "GL_OES_texture_mirrored_repeat"
+ "Invalid texture storage attrib list."
+ "LastFragDepthARM"
+ "LastFragStencilARM"
+ "Offset must not exceed the maximum atomic counter buffer size"
+ "Pixel local storage formats in the draw program do not match actively bound planes."
+ "abs(00C"
+ "abs(10C"
+ "abs(20C"
+ "abs(30C"
+ "all(10E"
+ "all(20E"
+ "all(30E"
+ "any(10E"
+ "any(20E"
+ "any(30E"
+ "areProgrammableSamplePositionsSupported"
+ "atomicAdd(00C00C"
+ "atomicAnd(00C00C"
+ "atomicCompSwap(00C00C00C"
+ "atomicCounter(00F"
+ "atomicCounterDecrement(00F"
+ "atomicCounterIncrement(00F"
+ "atomicExchange(00C00C"
+ "atomicMax(00C00C"
+ "atomicMin(00C00C"
+ "atomicOr(00C00C"
+ "atomicXor(00C00C"
+ "bitCount(00C"
+ "bitCount(10C"
+ "bitCount(20C"
+ "bitCount(30C"
+ "bitfieldExtract(00C00C00C"
+ "bitfieldExtract(00D00C00C"
+ "bitfieldExtract(10C00C00C"
+ "bitfieldExtract(10D00C00C"
+ "bitfieldExtract(20C00C00C"
+ "bitfieldExtract(20D00C00C"
+ "bitfieldExtract(30C00C00C"
+ "bitfieldExtract(30D00C00C"
+ "bitfieldInsert(00C00C00C00C"
+ "bitfieldInsert(00D00D00C00C"
+ "bitfieldInsert(10C10C00C00C"
+ "bitfieldInsert(10D10D00C00C"
+ "bitfieldInsert(20C20C00C00C"
+ "bitfieldInsert(20D20D00C00C"
+ "bitfieldInsert(30C30C00C00C"
+ "bitfieldInsert(30D30D00C00C"
+ "bitfieldReverse(00C"
+ "bitfieldReverse(10C"
+ "bitfieldReverse(20C"
+ "bitfieldReverse(30C"
+ "clamp(00C00C00C"
+ "clamp(10C00C00C"
+ "clamp(10C10C10C"
+ "clamp(20C00C00C"
+ "clamp(20C20C20C"
+ "clamp(30C00C00C"
+ "clamp(30C30C30C"
+ "equal(10C10C"
+ "equal(20C20C"
+ "equal(30C30C"
+ "expression statement is not allowed for interface blocks"
+ "findLSB(00C"
+ "findLSB(10C"
+ "findLSB(20C"
+ "findLSB(30C"
+ "findMSB(00C"
+ "findMSB(10C"
+ "findMSB(20C"
+ "findMSB(30C"
+ "frexp(00B00C"
+ "frexp(10B10C"
+ "frexp(20B20C"
+ "frexp(30B30C"
+ "glBlendEquationOES"
+ "glBlobCacheCallbacksANGLE"
+ "glGetPointervANGLE"
+ "glTexStorageAttribs2DEXT"
+ "glTexStorageAttribs3DEXT"
+ "gl_InstanceIndex"
+ "gl_LastFragDepthARM"
+ "gl_LastFragDepthARM and gl_LastFragStencilARM cannot be accessed because early_fragment_tests is specified"
+ "gl_LastFragStencilARM"
+ "gl_VertexIndex"
+ "greaterThan(10C10C"
+ "greaterThan(20C20C"
+ "greaterThan(30C30C"
+ "greaterThanEqual(10C10C"
+ "greaterThanEqual(20C20C"
+ "greaterThanEqual(30C30C"
+ "imageAtomicAdd(00q10C00C"
+ "imageAtomicAdd(00q10C00D"
+ "imageAtomicAdd(00r20C00C"
+ "imageAtomicAdd(00r20C00D"
+ "imageAtomicAdd(00s20C00C"
+ "imageAtomicAdd(00s20C00D"
+ "imageAtomicAdd(00t20C00C"
+ "imageAtomicAdd(00t20C00D"
+ "imageAtomicAdd(00u10C00C00C"
+ "imageAtomicAdd(00u10C00C00D"
+ "imageAtomicAdd(00v20C00C00C"
+ "imageAtomicAdd(00v20C00C00D"
+ "imageAtomicAdd(00w20C00C"
+ "imageAtomicAdd(00w20C00D"
+ "imageAtomicAdd(00x10C00C"
+ "imageAtomicAdd(00x10C00D"
+ "imageAtomicAdd(00y00C00C"
+ "imageAtomicAdd(00y00C00D"
+ "imageAtomicAdd(00z10C00C"
+ "imageAtomicAdd(00z10C00D"
+ "imageAtomicAdd(01A20C00C"
+ "imageAtomicAdd(01A20C00D"
+ "imageAtomicAdd(01B20C00C"
+ "imageAtomicAdd(01B20C00D"
+ "imageAtomicAdd(01C20C00C"
+ "imageAtomicAdd(01C20C00D"
+ "imageAtomicAdd(01D10C00C00C"
+ "imageAtomicAdd(01D10C00C00D"
+ "imageAtomicAdd(01E20C00C00C"
+ "imageAtomicAdd(01E20C00C00D"
+ "imageAtomicAdd(01F20C00C"
+ "imageAtomicAdd(01F20C00D"
+ "imageAtomicAdd(01G10C00C"
+ "imageAtomicAdd(01G10C00D"
+ "imageAtomicAdd(01H00C00C"
+ "imageAtomicAdd(01H00C00D"
+ "imageAtomicAdd(01I10C00C"
+ "imageAtomicAdd(01I10C00D"
+ "imageAtomicAdd(01J20C00C"
+ "imageAtomicAdd(01J20C00D"
+ "imageAtomicAdd(01K20C00C"
+ "imageAtomicAdd(01K20C00D"
+ "imageAtomicAdd(01L20C00C"
+ "imageAtomicAdd(01L20C00D"
+ "imageAtomicAdd(01M10C00C00C"
+ "imageAtomicAdd(01M10C00C00D"
+ "imageAtomicAdd(01N20C00C00C"
+ "imageAtomicAdd(01N20C00C00D"
+ "imageAtomicAdd(01O20C00C"
+ "imageAtomicAdd(01O20C00D"
+ "imageAtomicAdd(01P10C00C"
+ "imageAtomicAdd(01P10C00D"
+ "imageAtomicAdd(01Q00C00C"
+ "imageAtomicAdd(01Q00C00D"
+ "imageAtomicAnd(00q10C00C"
+ "imageAtomicAnd(00q10C00D"
+ "imageAtomicAnd(00r20C00C"
+ "imageAtomicAnd(00r20C00D"
+ "imageAtomicAnd(00s20C00C"
+ "imageAtomicAnd(00s20C00D"
+ "imageAtomicAnd(00t20C00C"
+ "imageAtomicAnd(00t20C00D"
+ "imageAtomicAnd(00u10C00C00C"
+ "imageAtomicAnd(00u10C00C00D"
+ "imageAtomicAnd(00v20C00C00C"
+ "imageAtomicAnd(00v20C00C00D"
+ "imageAtomicAnd(00w20C00C"
+ "imageAtomicAnd(00w20C00D"
+ "imageAtomicAnd(00x10C00C"
+ "imageAtomicAnd(00x10C00D"
+ "imageAtomicAnd(00y00C00C"
+ "imageAtomicAnd(00y00C00D"
+ "imageAtomicAnd(00z10C00C"
+ "imageAtomicAnd(00z10C00D"
+ "imageAtomicAnd(01A20C00C"
+ "imageAtomicAnd(01A20C00D"
+ "imageAtomicAnd(01B20C00C"
+ "imageAtomicAnd(01B20C00D"
+ "imageAtomicAnd(01C20C00C"
+ "imageAtomicAnd(01C20C00D"
+ "imageAtomicAnd(01D10C00C00C"
+ "imageAtomicAnd(01D10C00C00D"
+ "imageAtomicAnd(01E20C00C00C"
+ "imageAtomicAnd(01E20C00C00D"
+ "imageAtomicAnd(01F20C00C"
+ "imageAtomicAnd(01F20C00D"
+ "imageAtomicAnd(01G10C00C"
+ "imageAtomicAnd(01G10C00D"
+ "imageAtomicAnd(01H00C00C"
+ "imageAtomicAnd(01H00C00D"
+ "imageAtomicAnd(01I10C00C"
+ "imageAtomicAnd(01I10C00D"
+ "imageAtomicAnd(01J20C00C"
+ "imageAtomicAnd(01J20C00D"
+ "imageAtomicAnd(01K20C00C"
+ "imageAtomicAnd(01K20C00D"
+ "imageAtomicAnd(01L20C00C"
+ "imageAtomicAnd(01L20C00D"
+ "imageAtomicAnd(01M10C00C00C"
+ "imageAtomicAnd(01M10C00C00D"
+ "imageAtomicAnd(01N20C00C00C"
+ "imageAtomicAnd(01N20C00C00D"
+ "imageAtomicAnd(01O20C00C"
+ "imageAtomicAnd(01O20C00D"
+ "imageAtomicAnd(01P10C00C"
+ "imageAtomicAnd(01P10C00D"
+ "imageAtomicAnd(01Q00C00C"
+ "imageAtomicAnd(01Q00C00D"
+ "imageAtomicCompSwap(00q10C00C00C"
+ "imageAtomicCompSwap(00q10C00D00D"
+ "imageAtomicCompSwap(00r20C00C00C"
+ "imageAtomicCompSwap(00r20C00D00D"
+ "imageAtomicCompSwap(00s20C00C00C"
+ "imageAtomicCompSwap(00s20C00D00D"
+ "imageAtomicCompSwap(00t20C00C00C"
+ "imageAtomicCompSwap(00t20C00D00D"
+ "imageAtomicCompSwap(00u10C00C00C00C"
+ "imageAtomicCompSwap(00u10C00C00D00D"
+ "imageAtomicCompSwap(00v20C00C00C00C"
+ "imageAtomicCompSwap(00v20C00C00D00D"
+ "imageAtomicCompSwap(00w20C00C00C"
+ "imageAtomicCompSwap(00w20C00D00D"
+ "imageAtomicCompSwap(00x10C00C00C"
+ "imageAtomicCompSwap(00x10C00D00D"
+ "imageAtomicCompSwap(00y00C00C00C"
+ "imageAtomicCompSwap(00y00C00D00D"
+ "imageAtomicCompSwap(00z10C00C00C"
+ "imageAtomicCompSwap(00z10C00D00D"
+ "imageAtomicCompSwap(01A20C00C00C"
+ "imageAtomicCompSwap(01A20C00D00D"
+ "imageAtomicCompSwap(01B20C00C00C"
+ "imageAtomicCompSwap(01B20C00D00D"
+ "imageAtomicCompSwap(01C20C00C00C"
+ "imageAtomicCompSwap(01C20C00D00D"
+ "imageAtomicCompSwap(01D10C00C00C00C"
+ "imageAtomicCompSwap(01D10C00C00D00D"
+ "imageAtomicCompSwap(01E20C00C00C00C"
+ "imageAtomicCompSwap(01E20C00C00D00D"
+ "imageAtomicCompSwap(01F20C00C00C"
+ "imageAtomicCompSwap(01F20C00D00D"
+ "imageAtomicCompSwap(01G10C00C00C"
+ "imageAtomicCompSwap(01G10C00D00D"
+ "imageAtomicCompSwap(01H00C00C00C"
+ "imageAtomicCompSwap(01H00C00D00D"
+ "imageAtomicCompSwap(01I10C00C00C"
+ "imageAtomicCompSwap(01I10C00D00D"
+ "imageAtomicCompSwap(01J20C00C00C"
+ "imageAtomicCompSwap(01J20C00D00D"
+ "imageAtomicCompSwap(01K20C00C00C"
+ "imageAtomicCompSwap(01K20C00D00D"
+ "imageAtomicCompSwap(01L20C00C00C"
+ "imageAtomicCompSwap(01L20C00D00D"
+ "imageAtomicCompSwap(01M10C00C00C00C"
+ "imageAtomicCompSwap(01M10C00C00D00D"
+ "imageAtomicCompSwap(01N20C00C00C00C"
+ "imageAtomicCompSwap(01N20C00C00D00D"
+ "imageAtomicCompSwap(01O20C00C00C"
+ "imageAtomicCompSwap(01O20C00D00D"
+ "imageAtomicCompSwap(01P10C00C00C"
+ "imageAtomicCompSwap(01P10C00D00D"
+ "imageAtomicCompSwap(01Q00C00C00C"
+ "imageAtomicCompSwap(01Q00C00D00D"
+ "imageAtomicExchange(00q10C00B"
+ "imageAtomicExchange(00q10C00C"
+ "imageAtomicExchange(00q10C00D"
+ "imageAtomicExchange(00r20C00B"
+ "imageAtomicExchange(00r20C00C"
+ "imageAtomicExchange(00r20C00D"
+ "imageAtomicExchange(00s20C00B"
+ "imageAtomicExchange(00s20C00C"
+ "imageAtomicExchange(00s20C00D"
+ "imageAtomicExchange(00t20C00B"
+ "imageAtomicExchange(00t20C00C"
+ "imageAtomicExchange(00t20C00D"
+ "imageAtomicExchange(00u10C00C00B"
+ "imageAtomicExchange(00u10C00C00C"
+ "imageAtomicExchange(00u10C00C00D"
+ "imageAtomicExchange(00v20C00C00B"
+ "imageAtomicExchange(00v20C00C00C"
+ "imageAtomicExchange(00v20C00C00D"
+ "imageAtomicExchange(00w20C00B"
+ "imageAtomicExchange(00w20C00C"
+ "imageAtomicExchange(00w20C00D"
+ "imageAtomicExchange(00x10C00B"
+ "imageAtomicExchange(00x10C00C"
+ "imageAtomicExchange(00x10C00D"
+ "imageAtomicExchange(00y00C00B"
+ "imageAtomicExchange(00y00C00C"
+ "imageAtomicExchange(00y00C00D"
+ "imageAtomicExchange(00z10C00B"
+ "imageAtomicExchange(00z10C00C"
+ "imageAtomicExchange(00z10C00D"
+ "imageAtomicExchange(01A20C00B"
+ "imageAtomicExchange(01A20C00C"
+ "imageAtomicExchange(01A20C00D"
+ "imageAtomicExchange(01B20C00B"
+ "imageAtomicExchange(01B20C00C"
+ "imageAtomicExchange(01B20C00D"
+ "imageAtomicExchange(01C20C00B"
+ "imageAtomicExchange(01C20C00C"
+ "imageAtomicExchange(01C20C00D"
+ "imageAtomicExchange(01D10C00C00B"
+ "imageAtomicExchange(01D10C00C00C"
+ "imageAtomicExchange(01D10C00C00D"
+ "imageAtomicExchange(01E20C00C00B"
+ "imageAtomicExchange(01E20C00C00C"
+ "imageAtomicExchange(01E20C00C00D"
+ "imageAtomicExchange(01F20C00B"
+ "imageAtomicExchange(01F20C00C"
+ "imageAtomicExchange(01F20C00D"
+ "imageAtomicExchange(01G10C00B"
+ "imageAtomicExchange(01G10C00C"
+ "imageAtomicExchange(01G10C00D"
+ "imageAtomicExchange(01H00C00B"
+ "imageAtomicExchange(01H00C00C"
+ "imageAtomicExchange(01H00C00D"
+ "imageAtomicExchange(01I10C00B"
+ "imageAtomicExchange(01I10C00C"
+ "imageAtomicExchange(01I10C00D"
+ "imageAtomicExchange(01J20C00B"
+ "imageAtomicExchange(01J20C00C"
+ "imageAtomicExchange(01J20C00D"
+ "imageAtomicExchange(01K20C00B"
+ "imageAtomicExchange(01K20C00C"
+ "imageAtomicExchange(01K20C00D"
+ "imageAtomicExchange(01L20C00B"
+ "imageAtomicExchange(01L20C00C"
+ "imageAtomicExchange(01L20C00D"
+ "imageAtomicExchange(01M10C00C00B"
+ "imageAtomicExchange(01M10C00C00C"
+ "imageAtomicExchange(01M10C00C00D"
+ "imageAtomicExchange(01N20C00C00B"
+ "imageAtomicExchange(01N20C00C00C"
+ "imageAtomicExchange(01N20C00C00D"
+ "imageAtomicExchange(01O20C00B"
+ "imageAtomicExchange(01O20C00C"
+ "imageAtomicExchange(01O20C00D"
+ "imageAtomicExchange(01P10C00B"
+ "imageAtomicExchange(01P10C00C"
+ "imageAtomicExchange(01P10C00D"
+ "imageAtomicExchange(01Q00C00B"
+ "imageAtomicExchange(01Q00C00C"
+ "imageAtomicExchange(01Q00C00D"
+ "imageAtomicMax(00q10C00C"
+ "imageAtomicMax(00q10C00D"
+ "imageAtomicMax(00r20C00C"
+ "imageAtomicMax(00r20C00D"
+ "imageAtomicMax(00s20C00C"
+ "imageAtomicMax(00s20C00D"
+ "imageAtomicMax(00t20C00C"
+ "imageAtomicMax(00t20C00D"
+ "imageAtomicMax(00u10C00C00C"
+ "imageAtomicMax(00u10C00C00D"
+ "imageAtomicMax(00v20C00C00C"
+ "imageAtomicMax(00v20C00C00D"
+ "imageAtomicMax(00w20C00C"
+ "imageAtomicMax(00w20C00D"
+ "imageAtomicMax(00x10C00C"
+ "imageAtomicMax(00x10C00D"
+ "imageAtomicMax(00y00C00C"
+ "imageAtomicMax(00y00C00D"
+ "imageAtomicMax(00z10C00C"
+ "imageAtomicMax(00z10C00D"
+ "imageAtomicMax(01A20C00C"
+ "imageAtomicMax(01A20C00D"
+ "imageAtomicMax(01B20C00C"
+ "imageAtomicMax(01B20C00D"
+ "imageAtomicMax(01C20C00C"
+ "imageAtomicMax(01C20C00D"
+ "imageAtomicMax(01D10C00C00C"
+ "imageAtomicMax(01D10C00C00D"
+ "imageAtomicMax(01E20C00C00C"
+ "imageAtomicMax(01E20C00C00D"
+ "imageAtomicMax(01F20C00C"
+ "imageAtomicMax(01F20C00D"
+ "imageAtomicMax(01G10C00C"
+ "imageAtomicMax(01G10C00D"
+ "imageAtomicMax(01H00C00C"
+ "imageAtomicMax(01H00C00D"
+ "imageAtomicMax(01I10C00C"
+ "imageAtomicMax(01I10C00D"
+ "imageAtomicMax(01J20C00C"
+ "imageAtomicMax(01J20C00D"
+ "imageAtomicMax(01K20C00C"
+ "imageAtomicMax(01K20C00D"
+ "imageAtomicMax(01L20C00C"
+ "imageAtomicMax(01L20C00D"
+ "imageAtomicMax(01M10C00C00C"
+ "imageAtomicMax(01M10C00C00D"
+ "imageAtomicMax(01N20C00C00C"
+ "imageAtomicMax(01N20C00C00D"
+ "imageAtomicMax(01O20C00C"
+ "imageAtomicMax(01O20C00D"
+ "imageAtomicMax(01P10C00C"
+ "imageAtomicMax(01P10C00D"
+ "imageAtomicMax(01Q00C00C"
+ "imageAtomicMax(01Q00C00D"
+ "imageAtomicMin(00q10C00C"
+ "imageAtomicMin(00q10C00D"
+ "imageAtomicMin(00r20C00C"
+ "imageAtomicMin(00r20C00D"
+ "imageAtomicMin(00s20C00C"
+ "imageAtomicMin(00s20C00D"
+ "imageAtomicMin(00t20C00C"
+ "imageAtomicMin(00t20C00D"
+ "imageAtomicMin(00u10C00C00C"
+ "imageAtomicMin(00u10C00C00D"
+ "imageAtomicMin(00v20C00C00C"
+ "imageAtomicMin(00v20C00C00D"
+ "imageAtomicMin(00w20C00C"
+ "imageAtomicMin(00w20C00D"
+ "imageAtomicMin(00x10C00C"
+ "imageAtomicMin(00x10C00D"
+ "imageAtomicMin(00y00C00C"
+ "imageAtomicMin(00y00C00D"
+ "imageAtomicMin(00z10C00C"
+ "imageAtomicMin(00z10C00D"
+ "imageAtomicMin(01A20C00C"
+ "imageAtomicMin(01A20C00D"
+ "imageAtomicMin(01B20C00C"
+ "imageAtomicMin(01B20C00D"
+ "imageAtomicMin(01C20C00C"
+ "imageAtomicMin(01C20C00D"
+ "imageAtomicMin(01D10C00C00C"
+ "imageAtomicMin(01D10C00C00D"
+ "imageAtomicMin(01E20C00C00C"
+ "imageAtomicMin(01E20C00C00D"
+ "imageAtomicMin(01F20C00C"
+ "imageAtomicMin(01F20C00D"
+ "imageAtomicMin(01G10C00C"
+ "imageAtomicMin(01G10C00D"
+ "imageAtomicMin(01H00C00C"
+ "imageAtomicMin(01H00C00D"
+ "imageAtomicMin(01I10C00C"
+ "imageAtomicMin(01I10C00D"
+ "imageAtomicMin(01J20C00C"
+ "imageAtomicMin(01J20C00D"
+ "imageAtomicMin(01K20C00C"
+ "imageAtomicMin(01K20C00D"
+ "imageAtomicMin(01L20C00C"
+ "imageAtomicMin(01L20C00D"
+ "imageAtomicMin(01M10C00C00C"
+ "imageAtomicMin(01M10C00C00D"
+ "imageAtomicMin(01N20C00C00C"
+ "imageAtomicMin(01N20C00C00D"
+ "imageAtomicMin(01O20C00C"
+ "imageAtomicMin(01O20C00D"
+ "imageAtomicMin(01P10C00C"
+ "imageAtomicMin(01P10C00D"
+ "imageAtomicMin(01Q00C00C"
+ "imageAtomicMin(01Q00C00D"
+ "imageAtomicOr(00q10C00C"
+ "imageAtomicOr(00q10C00D"
+ "imageAtomicOr(00r20C00C"
+ "imageAtomicOr(00r20C00D"
+ "imageAtomicOr(00s20C00C"
+ "imageAtomicOr(00s20C00D"
+ "imageAtomicOr(00t20C00C"
+ "imageAtomicOr(00t20C00D"
+ "imageAtomicOr(00u10C00C00C"
+ "imageAtomicOr(00u10C00C00D"
+ "imageAtomicOr(00v20C00C00C"
+ "imageAtomicOr(00v20C00C00D"
+ "imageAtomicOr(00w20C00C"
+ "imageAtomicOr(00w20C00D"
+ "imageAtomicOr(00x10C00C"
+ "imageAtomicOr(00x10C00D"
+ "imageAtomicOr(00y00C00C"
+ "imageAtomicOr(00y00C00D"
+ "imageAtomicOr(00z10C00C"
+ "imageAtomicOr(00z10C00D"
+ "imageAtomicOr(01A20C00C"
+ "imageAtomicOr(01A20C00D"
+ "imageAtomicOr(01B20C00C"
+ "imageAtomicOr(01B20C00D"
+ "imageAtomicOr(01C20C00C"
+ "imageAtomicOr(01C20C00D"
+ "imageAtomicOr(01D10C00C00C"
+ "imageAtomicOr(01D10C00C00D"
+ "imageAtomicOr(01E20C00C00C"
+ "imageAtomicOr(01E20C00C00D"
+ "imageAtomicOr(01F20C00C"
+ "imageAtomicOr(01F20C00D"
+ "imageAtomicOr(01G10C00C"
+ "imageAtomicOr(01G10C00D"
+ "imageAtomicOr(01H00C00C"
+ "imageAtomicOr(01H00C00D"
+ "imageAtomicOr(01I10C00C"
+ "imageAtomicOr(01I10C00D"
+ "imageAtomicOr(01J20C00C"
+ "imageAtomicOr(01J20C00D"
+ "imageAtomicOr(01K20C00C"
+ "imageAtomicOr(01K20C00D"
+ "imageAtomicOr(01L20C00C"
+ "imageAtomicOr(01L20C00D"
+ "imageAtomicOr(01M10C00C00C"
+ "imageAtomicOr(01M10C00C00D"
+ "imageAtomicOr(01N20C00C00C"
+ "imageAtomicOr(01N20C00C00D"
+ "imageAtomicOr(01O20C00C"
+ "imageAtomicOr(01O20C00D"
+ "imageAtomicOr(01P10C00C"
+ "imageAtomicOr(01P10C00D"
+ "imageAtomicOr(01Q00C00C"
+ "imageAtomicOr(01Q00C00D"
+ "imageAtomicXor(00q10C00C"
+ "imageAtomicXor(00q10C00D"
+ "imageAtomicXor(00r20C00C"
+ "imageAtomicXor(00r20C00D"
+ "imageAtomicXor(00s20C00C"
+ "imageAtomicXor(00s20C00D"
+ "imageAtomicXor(00t20C00C"
+ "imageAtomicXor(00t20C00D"
+ "imageAtomicXor(00u10C00C00C"
+ "imageAtomicXor(00u10C00C00D"
+ "imageAtomicXor(00v20C00C00C"
+ "imageAtomicXor(00v20C00C00D"
+ "imageAtomicXor(00w20C00C"
+ "imageAtomicXor(00w20C00D"
+ "imageAtomicXor(00x10C00C"
+ "imageAtomicXor(00x10C00D"
+ "imageAtomicXor(00y00C00C"
+ "imageAtomicXor(00y00C00D"
+ "imageAtomicXor(00z10C00C"
+ "imageAtomicXor(00z10C00D"
+ "imageAtomicXor(01A20C00C"
+ "imageAtomicXor(01A20C00D"
+ "imageAtomicXor(01B20C00C"
+ "imageAtomicXor(01B20C00D"
+ "imageAtomicXor(01C20C00C"
+ "imageAtomicXor(01C20C00D"
+ "imageAtomicXor(01D10C00C00C"
+ "imageAtomicXor(01D10C00C00D"
+ "imageAtomicXor(01E20C00C00C"
+ "imageAtomicXor(01E20C00C00D"
+ "imageAtomicXor(01F20C00C"
+ "imageAtomicXor(01F20C00D"
+ "imageAtomicXor(01G10C00C"
+ "imageAtomicXor(01G10C00D"
+ "imageAtomicXor(01H00C00C"
+ "imageAtomicXor(01H00C00D"
+ "imageAtomicXor(01I10C00C"
+ "imageAtomicXor(01I10C00D"
+ "imageAtomicXor(01J20C00C"
+ "imageAtomicXor(01J20C00D"
+ "imageAtomicXor(01K20C00C"
+ "imageAtomicXor(01K20C00D"
+ "imageAtomicXor(01L20C00C"
+ "imageAtomicXor(01L20C00D"
+ "imageAtomicXor(01M10C00C00C"
+ "imageAtomicXor(01M10C00C00D"
+ "imageAtomicXor(01N20C00C00C"
+ "imageAtomicXor(01N20C00C00D"
+ "imageAtomicXor(01O20C00C"
+ "imageAtomicXor(01O20C00D"
+ "imageAtomicXor(01P10C00C"
+ "imageAtomicXor(01P10C00D"
+ "imageAtomicXor(01Q00C00C"
+ "imageAtomicXor(01Q00C00D"
+ "imageLoad(00q10C"
+ "imageLoad(00r20C"
+ "imageLoad(00s20C"
+ "imageLoad(00t20C"
+ "imageLoad(00w20C"
+ "imageLoad(00y00C"
+ "imageLoad(00z10C"
+ "imageLoad(01A20C"
+ "imageLoad(01B20C"
+ "imageLoad(01C20C"
+ "imageLoad(01F20C"
+ "imageLoad(01H00C"
+ "imageLoad(01I10C"
+ "imageLoad(01J20C"
+ "imageLoad(01K20C"
+ "imageLoad(01L20C"
+ "imageLoad(01O20C"
+ "imageLoad(01Q00C"
+ "imageSize(00q"
+ "imageSize(00r"
+ "imageSize(00s"
+ "imageSize(00t"
+ "imageSize(00w"
+ "imageSize(00y"
+ "imageSize(01F"
+ "imageSize(01I"
+ "imageSize(01O"
+ "imageSize(01Q"
+ "imageStore(00q10C30B"
+ "imageStore(00r20C30B"
+ "imageStore(00s20C30B"
+ "imageStore(00t20C30B"
+ "imageStore(00w20C30B"
+ "imageStore(00y00C30B"
+ "imageStore(00z10C30C"
+ "imageStore(01A20C30C"
+ "imageStore(01B20C30C"
+ "imageStore(01C20C30C"
+ "imageStore(01F20C30C"
+ "imageStore(01H00C30C"
+ "imageStore(01I10C30D"
+ "imageStore(01J20C30D"
+ "imageStore(01K20C30D"
+ "imageStore(01L20C30D"
+ "imageStore(01O20C30D"
+ "imageStore(01Q00C30D"
+ "imulExtended(00C00C00C00C"
+ "imulExtended(10C10C10C10C"
+ "imulExtended(20C20C20C20C"
+ "imulExtended(30C30C30C30C"
+ "intBitsToFloat(00C"
+ "intBitsToFloat(10C"
+ "intBitsToFloat(20C"
+ "intBitsToFloat(30C"
+ "interpolateAtSample(00B00C"
+ "interpolateAtSample(10B00C"
+ "interpolateAtSample(20B00C"
+ "interpolateAtSample(30B00C"
+ "ldexp(00B00C"
+ "ldexp(10B10C"
+ "ldexp(20B20C"
+ "ldexp(30B30C"
+ "lessThan(10C10C"
+ "lessThan(20C20C"
+ "lessThan(30C30C"
+ "lessThanEqual(10C10C"
+ "lessThanEqual(20C20C"
+ "lessThanEqual(30C30C"
+ "max(00C00C"
+ "max(10C00C"
+ "max(10C10C"
+ "max(20C00C"
+ "max(20C20C"
+ "max(30C00C"
+ "max(30C30C"
+ "metal::array<"
+ "min(00C00C"
+ "min(10C00C"
+ "min(10C10C"
+ "min(20C00C"
+ "min(20C20C"
+ "min(30C00C"
+ "min(30C30C"
+ "mix(00B00B00E"
+ "mix(00C00C00E"
+ "mix(00D00D00E"
+ "mix(00E00E00E"
+ "mix(10B10B10E"
+ "mix(10C10C10E"
+ "mix(10D10D10E"
+ "mix(10E10E10E"
+ "mix(20B20B20E"
+ "mix(20C20C20E"
+ "mix(20D20D20E"
+ "mix(20E20E20E"
+ "mix(30B30B30E"
+ "mix(30C30C30E"
+ "mix(30D30D30E"
+ "mix(30E30E30E"
+ "not(10E"
+ "not(20E"
+ "not(30E"
+ "notEqual(10C10C"
+ "notEqual(20C20C"
+ "notEqual(30C30C"
+ "pixel local storage binding out of range"
+ "pixelLocalLoadANGLE(01R"
+ "pixelLocalLoadANGLE(01S"
+ "pixelLocalLoadANGLE(01T"
+ "pixelLocalStoreANGLE(01R30B"
+ "pixelLocalStoreANGLE(01S30C"
+ "pixelLocalStoreANGLE(01T30D"
+ "rgb_2_yuv(20B00G"
+ "samplePosition(00D"
+ "sequence operator is not allowed for interface blocks"
+ "shadow2DEXT(00c20B"
+ "shadow2DProjEXT(00c30B"
+ "sign(00C"
+ "sign(10C"
+ "sign(20C"
+ "sign(30C"
+ "subpassLoad(01U"
+ "subpassLoad(01V"
+ "subpassLoad(01W"
+ "texelFetch(00H10C00C"
+ "texelFetch(00I20C00C"
+ "texelFetch(00K20C00C"
+ "texelFetch(00L10C00C"
+ "texelFetch(00M10C00C"
+ "texelFetch(00O10C00C"
+ "texelFetch(00P20C00C"
+ "texelFetch(00Q10C00C"
+ "texelFetch(00R20C00C"
+ "texelFetch(00T20C00C"
+ "texelFetch(00U10C00C"
+ "texelFetch(00V20C00C"
+ "texelFetch(00W10C00C"
+ "texelFetch(00X20C00C"
+ "texelFetch(00Z20C00C"
+ "texelFetch(00a10C00C"
+ "texelFetch(00b20C00C"
+ "texelFetch(00f00C"
+ "texelFetch(00k00C"
+ "texelFetch(00n00C"
+ "texelFetchOffset(00H10C00C10C"
+ "texelFetchOffset(00I20C00C20C"
+ "texelFetchOffset(00K20C00C10C"
+ "texelFetchOffset(00Q10C00C10C"
+ "texelFetchOffset(00R20C00C20C"
+ "texelFetchOffset(00T20C00C10C"
+ "texelFetchOffset(00W10C00C10C"
+ "texelFetchOffset(00X20C00C20C"
+ "texelFetchOffset(00Z20C00C10C"
+ "texture(00H10B"
+ "texture(00H10B00B"
+ "texture(00I20B"
+ "texture(00I20B00B"
+ "texture(00L10B"
+ "texture(00L10B00B"
+ "texture(00Q10B"
+ "texture(00Q10B00B"
+ "texture(00R20B"
+ "texture(00R20B00B"
+ "texture(00W10B"
+ "texture(00W10B00B"
+ "texture(00X20B"
+ "texture(00X20B00B"
+ "texture(00c20B"
+ "texture(00c20B00B"
+ "texture(00d30B"
+ "texture(00d30B00B"
+ "texture(00g30B"
+ "texture(00g30B00B"
+ "texture(00h30B00B"
+ "texture(00h30B00B00B"
+ "texture(00l30B"
+ "texture(00o30B"
+ "texture(00o30B00B"
+ "texture(00p10B"
+ "texture2D(00H10B"
+ "texture2D(00H10B00B"
+ "texture2D(00L10B"
+ "texture2DGradEXT(00H10B10B10B"
+ "texture2DLod(00H10B00B"
+ "texture2DLodEXT(00H10B00B"
+ "texture2DProj(00H20B"
+ "texture2DProj(00H20B00B"
+ "texture2DProj(00H30B"
+ "texture2DProj(00H30B00B"
+ "texture2DProj(00L20B"
+ "texture2DProj(00L30B"
+ "texture2DProjGradEXT(00H20B10B10B"
+ "texture2DProjGradEXT(00H30B10B10B"
+ "texture2DProjLod(00H20B00B"
+ "texture2DProjLod(00H30B00B"
+ "texture2DProjLodEXT(00H20B00B"
+ "texture2DProjLodEXT(00H30B00B"
+ "texture2DRect(00N10B"
+ "texture2DRectProj(00N20B"
+ "texture2DRectProj(00N30B"
+ "texture3D(00I20B"
+ "texture3D(00I20B00B"
+ "texture3DLod(00I20B00B"
+ "texture3DProj(00I30B"
+ "texture3DProj(00I30B00B"
+ "texture3DProjLod(00I30B00B"
+ "textureCube(00J20B"
+ "textureCube(00J20B00B"
+ "textureCubeGradEXT(00J20B20B20B"
+ "textureCubeLod(00J20B00B"
+ "textureCubeLodEXT(00J20B00B"
+ "textureGather(00H10B"
+ "textureGather(00H10B00C"
+ "textureGather(00J20B"
+ "textureGather(00J20B00C"
+ "textureGather(00K20B00C"
+ "textureGather(00Q10B"
+ "textureGather(00Q10B00C"
+ "textureGather(00S20B"
+ "textureGather(00S20B00C"
+ "textureGather(00T20B00C"
+ "textureGather(00W10B"
+ "textureGather(00W10B00C"
+ "textureGather(00Y20B"
+ "textureGather(00Y20B00C"
+ "textureGather(00Z20B00C"
+ "textureGather(00c10B"
+ "textureGather(00c10B00B"
+ "textureGather(00d20B"
+ "textureGather(00d20B00B"
+ "textureGather(00g30B"
+ "textureGather(00g30B00C"
+ "textureGather(00h30B00B"
+ "textureGather(00l30B"
+ "textureGather(00l30B00C"
+ "textureGather(00o30B"
+ "textureGather(00o30B00C"
+ "textureGatherOffset(00H10B10C"
+ "textureGatherOffset(00H10B10C00C"
+ "textureGatherOffset(00K20B10C"
+ "textureGatherOffset(00K20B10C00C"
+ "textureGatherOffset(00Q10B10C"
+ "textureGatherOffset(00Q10B10C00C"
+ "textureGatherOffset(00T20B10C"
+ "textureGatherOffset(00T20B10C00C"
+ "textureGatherOffset(00W10B10C"
+ "textureGatherOffset(00W10B10C00C"
+ "textureGatherOffset(00Z20B10C"
+ "textureGatherOffset(00Z20B10C00C"
+ "textureGatherOffset(00c10B00B10C"
+ "textureGatherOffset(00e20B00B10C"
+ "textureGatherOffsets(00H10B10Cx4"
+ "textureGatherOffsets(00H10B10Cx400C"
+ "textureGatherOffsets(00K20B10Cx4"
+ "textureGatherOffsets(00K20B10Cx400C"
+ "textureGatherOffsets(00Q10B10Cx4"
+ "textureGatherOffsets(00Q10B10Cx400C"
+ "textureGatherOffsets(00T20B10Cx4"
+ "textureGatherOffsets(00T20B10Cx400C"
+ "textureGatherOffsets(00W10B10Cx4"
+ "textureGatherOffsets(00W10B10Cx400C"
+ "textureGatherOffsets(00Z20B10Cx4"
+ "textureGatherOffsets(00Z20B10Cx400C"
+ "textureGatherOffsets(00c10B00B10Cx4"
+ "textureGatherOffsets(00e20B00B10Cx4"
+ "textureGrad(00H10B10B10B"
+ "textureGrad(00I20B20B20B"
+ "textureGrad(00K20B10B10B"
+ "textureGrad(00Q10B10B10B"
+ "textureGrad(00R20B20B20B"
+ "textureGrad(00T20B10B10B"
+ "textureGrad(00W10B10B10B"
+ "textureGrad(00X20B20B20B"
+ "textureGrad(00Z20B10B10B"
+ "textureGrad(00c20B10B10B"
+ "textureGrad(00d30B20B20B"
+ "textureGrad(00e30B10B10B"
+ "textureGrad(00g30B20B20B"
+ "textureGrad(00l30B20B20B"
+ "textureGrad(00o30B20B20B"
+ "textureGradOffset(00H10B10B10B10C"
+ "textureGradOffset(00I20B20B20B20C"
+ "textureGradOffset(00K20B10B10B10C"
+ "textureGradOffset(00Q10B10B10B10C"
+ "textureGradOffset(00R20B20B20B20C"
+ "textureGradOffset(00T20B10B10B10C"
+ "textureGradOffset(00W10B10B10B10C"
+ "textureGradOffset(00X20B20B20B20C"
+ "textureGradOffset(00Z20B10B10B10C"
+ "textureGradOffset(00c20B10B10B10C"
+ "textureGradOffset(00e30B10B10B10C"
+ "textureLod(00H10B00B"
+ "textureLod(00I20B00B"
+ "textureLod(00Q10B00B"
+ "textureLod(00R20B00B"
+ "textureLod(00W10B00B"
+ "textureLod(00X20B00B"
+ "textureLod(00c20B00B"
+ "textureLod(00d30B00B"
+ "textureLod(00e30B00B"
+ "textureLod(00g30B00B"
+ "textureLod(00h30B00B00B"
+ "textureLod(00l30B00B"
+ "textureLod(00o30B00B"
+ "textureLodOffset(00H10B00B10C"
+ "textureLodOffset(00I20B00B20C"
+ "textureLodOffset(00K20B00B10C"
+ "textureLodOffset(00Q10B00B10C"
+ "textureLodOffset(00R20B00B20C"
+ "textureLodOffset(00T20B00B10C"
+ "textureLodOffset(00W10B00B10C"
+ "textureLodOffset(00X20B00B20C"
+ "textureLodOffset(00Z20B00B10C"
+ "textureLodOffset(00c20B00B10C"
+ "textureLodOffset(00e30B00B10C"
+ "textureOffset(00H10B10C"
+ "textureOffset(00H10B10C00B"
+ "textureOffset(00I20B20C"
+ "textureOffset(00I20B20C00B"
+ "textureOffset(00K20B10C"
+ "textureOffset(00K20B10C00B"
+ "textureOffset(00Q10B10C"
+ "textureOffset(00Q10B10C00B"
+ "textureOffset(00R20B20C"
+ "textureOffset(00R20B20C00B"
+ "textureOffset(00T20B10C"
+ "textureOffset(00T20B10C00B"
+ "textureOffset(00W10B10C"
+ "textureOffset(00W10B10C00B"
+ "textureOffset(00X20B20C"
+ "textureOffset(00X20B20C00B"
+ "textureOffset(00Z20B10C"
+ "textureOffset(00Z20B10C00B"
+ "textureOffset(00c20B10C"
+ "textureOffset(00c20B10C00B"
+ "textureOffset(00e30B10C"
+ "textureOffset(00e30B10C00B"
+ "textureProj(00H20B"
+ "textureProj(00H20B00B"
+ "textureProj(00H30B"
+ "textureProj(00H30B00B"
+ "textureProj(00L20B"
+ "textureProj(00L20B00B"
+ "textureProj(00L30B"
+ "textureProj(00L30B00B"
+ "textureProj(00Q20B"
+ "textureProj(00Q20B00B"
+ "textureProj(00Q30B"
+ "textureProj(00Q30B00B"
+ "textureProj(00W20B"
+ "textureProj(00W20B00B"
+ "textureProj(00W30B"
+ "textureProj(00W30B00B"
+ "textureProj(00c30B"
+ "textureProj(00c30B00B"
+ "textureProjGrad(00H20B10B10B"
+ "textureProjGrad(00H30B10B10B"
+ "textureProjGrad(00I30B20B20B"
+ "textureProjGrad(00Q20B10B10B"
+ "textureProjGrad(00Q30B10B10B"
+ "textureProjGrad(00R30B20B20B"
+ "textureProjGrad(00W20B10B10B"
+ "textureProjGrad(00W30B10B10B"
+ "textureProjGrad(00X30B20B20B"
+ "textureProjGrad(00c30B10B10B"
+ "textureProjGradOffset(00H20B10B10B10C"
+ "textureProjGradOffset(00H30B10B10B10C"
+ "textureProjGradOffset(00I30B20B20B20C"
+ "textureProjGradOffset(00Q20B10B10B10C"
+ "textureProjGradOffset(00Q30B10B10B10C"
+ "textureProjGradOffset(00R30B20B20B20C"
+ "textureProjGradOffset(00W20B10B10B10C"
+ "textureProjGradOffset(00W30B10B10B10C"
+ "textureProjGradOffset(00X30B20B20B20C"
+ "textureProjGradOffset(00c30B10B10B10C"
+ "textureProjLod(00H20B00B"
+ "textureProjLod(00H30B00B"
+ "textureProjLod(00Q20B00B"
+ "textureProjLod(00Q30B00B"
+ "textureProjLod(00W20B00B"
+ "textureProjLod(00W30B00B"
+ "textureProjLod(00c30B00B"
+ "textureProjLodOffset(00H20B00B10C"
+ "textureProjLodOffset(00H30B00B10C"
+ "textureProjLodOffset(00I30B00B20C"
+ "textureProjLodOffset(00Q20B00B10C"
+ "textureProjLodOffset(00Q30B00B10C"
+ "textureProjLodOffset(00R30B00B20C"
+ "textureProjLodOffset(00W20B00B10C"
+ "textureProjLodOffset(00W30B00B10C"
+ "textureProjLodOffset(00X30B00B20C"
+ "textureProjLodOffset(00c30B00B10C"
+ "textureProjOffset(00H20B10C"
+ "textureProjOffset(00H20B10C00B"
+ "textureProjOffset(00H30B10C"
+ "textureProjOffset(00H30B10C00B"
+ "textureProjOffset(00I30B20C"
+ "textureProjOffset(00I30B20C00B"
+ "textureProjOffset(00Q20B10C"
+ "textureProjOffset(00Q20B10C00B"
+ "textureProjOffset(00Q30B10C"
+ "textureProjOffset(00Q30B10C00B"
+ "textureProjOffset(00R30B20C"
+ "textureProjOffset(00R30B20C00B"
+ "textureProjOffset(00W20B10C"
+ "textureProjOffset(00W20B10C00B"
+ "textureProjOffset(00W30B10C"
+ "textureProjOffset(00W30B10C00B"
+ "textureProjOffset(00X30B20C"
+ "textureProjOffset(00X30B20C00B"
+ "textureProjOffset(00c30B10C"
+ "textureProjOffset(00c30B10C00B"
+ "textureQueryLOD"
+ "textureQueryLOD(00H10B"
+ "textureQueryLOD(00I20B"
+ "textureQueryLOD(00J20B"
+ "textureQueryLOD(00K10B"
+ "textureQueryLOD(00Q10B"
+ "textureQueryLOD(00R20B"
+ "textureQueryLOD(00S20B"
+ "textureQueryLOD(00T10B"
+ "textureQueryLOD(00W10B"
+ "textureQueryLOD(00X20B"
+ "textureQueryLOD(00Y20B"
+ "textureQueryLOD(00Z10B"
+ "textureQueryLOD(00c10B"
+ "textureQueryLOD(00d20B"
+ "textureQueryLOD(00e10B"
+ "textureQueryLOD(00g20B"
+ "textureQueryLOD(00h20B"
+ "textureQueryLOD(00l20B"
+ "textureQueryLOD(00o20B"
+ "textureSize(00H00C"
+ "textureSize(00I00C"
+ "textureSize(00J00C"
+ "textureSize(00K00C"
+ "textureSize(00L00C"
+ "textureSize(00M00C"
+ "textureSize(00O"
+ "textureSize(00Q00C"
+ "textureSize(00R00C"
+ "textureSize(00S00C"
+ "textureSize(00T00C"
+ "textureSize(00U"
+ "textureSize(00W00C"
+ "textureSize(00X00C"
+ "textureSize(00Y00C"
+ "textureSize(00Z00C"
+ "textureSize(00a"
+ "textureSize(00c00C"
+ "textureSize(00d00C"
+ "textureSize(00e00C"
+ "textureSize(00f"
+ "textureSize(00g00C"
+ "textureSize(00h00C"
+ "textureSize(00k"
+ "textureSize(00l00C"
+ "textureSize(00n"
+ "textureSize(00o00C"
+ "textureVideoWEBGL(00p10B"
+ "uaddCarry(00D00D00D"
+ "uaddCarry(10D10D10D"
+ "uaddCarry(20D20D20D"
+ "uaddCarry(30D30D30D"
+ "uintBitsToFloat(00D"
+ "uintBitsToFloat(10D"
+ "uintBitsToFloat(20D"
+ "uintBitsToFloat(30D"
+ "umulExtended(00D00D00D00D"
+ "umulExtended(10D10D10D10D"
+ "umulExtended(20D20D20D20D"
+ "umulExtended(30D30D30D30D"
+ "unpackHalf2x16(00D"
+ "unpackSnorm2x16(00D"
+ "unpackSnorm4x8(00D"
+ "unpackUnorm2x16(00D"
+ "unpackUnorm4x8(00D"
+ "usubBorrow(00D00D00D"
+ "usubBorrow(10D10D10D"
+ "usubBorrow(20D20D20D"
+ "usubBorrow(30D30D30D"
+ "yuv_2_rgb(20B00G"
- "\n#define ANGLE_SAMPLE_COMPARE_GRADIENT_INDEX   0\n#define ANGLE_SAMPLE_COMPARE_LOD_INDEX        1\n#define ANGLE_RASTERIZATION_DISCARD_INDEX     2\n#define ANGLE_MULTISAMPLED_RENDERING_INDEX    3\n#define ANGLE_DEPTH_WRITE_ENABLED_INDEX       4\n#define ANGLE_EMULATE_ALPHA_TO_COVERAGE_INDEX 5\n#define ANGLE_WRITE_HELPER_SAMPLE_MASK_INDEX  6\n\nconstant bool ANGLEUseSampleCompareGradient [[function_constant(ANGLE_SAMPLE_COMPARE_GRADIENT_INDEX)]];\nconstant bool ANGLEUseSampleCompareLod      [[function_constant(ANGLE_SAMPLE_COMPARE_LOD_INDEX)]];\nconstant bool ANGLERasterizerDisabled       [[function_constant(ANGLE_RASTERIZATION_DISCARD_INDEX)]];\nconstant bool ANGLEMultisampledRendering    [[function_constant(ANGLE_MULTISAMPLED_RENDERING_INDEX)]];\nconstant bool ANGLEDepthWriteEnabled        [[function_constant(ANGLE_DEPTH_WRITE_ENABLED_INDEX)]];\nconstant bool ANGLEEmulateAlphaToCoverage   [[function_constant(ANGLE_EMULATE_ALPHA_TO_COVERAGE_INDEX)]];\nconstant bool ANGLEWriteHelperSampleMask    [[function_constant(ANGLE_WRITE_HELPER_SAMPLE_MASK_INDEX)]];\n\n#define ANGLE_ALPHA0\n\n"
- "\n#define ANGLE_texelFetch(env, ...) ANGLE_texelFetch_impl(*env.texture, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetch_impl(\n    thread Texture &texture,\n    metal::int2 const coord,\n    uint32_t level)\n{\n    return texture.read(uint2(coord), level);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetch_impl(\n    thread Texture &texture,\n    metal::int3 const coord,\n    uint32_t level)\n{\n    return texture.read(uint3(coord), level);\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetch_impl(\n    thread metal::texture2d_array<T> &texture,\n    metal::int3 const coord,\n    uint32_t level)\n{\n    return texture.read(uint2(coord.xy), uint32_t(coord.z), level);\n}\n\n"
- "\n#define ANGLE_texelFetchOffset(env, ...) ANGLE_texelFetchOffset_impl(*env.texture, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset_impl(\n    thread Texture &texture,\n    metal::int2 const coord,\n    uint32_t level,\n    metal::int2 const offset)\n{\n    return texture.read(uint2(coord + offset), level);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset_impl(\n    thread Texture &texture,\n    metal::int3 const coord,\n    uint32_t level,\n    metal::int3 const offset)\n{\n    return texture.read(uint3(coord + offset), level);\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset_impl(\n    thread metal::texture2d_array<T> &texture,\n    metal::int3 const coord,\n    uint32_t level,\n    metal::int2 const offset)\n{\n    return texture.read(uint2(coord.xy + offset), uint32_t(coord.z), level);\n}\n\n"
- "\n#define ANGLE_texture(env, ...) ANGLE_texture_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\n"
- "\n#define ANGLE_texture1DLod(env, ...) ANGLE_texture1DLod_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture1DLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    float const coord,\n    float level)\n{\n    return texture.sample(sampler, coord, metal::level(level));\n}\n\n"
- "\n#define ANGLE_texture1DProj(env, ...) ANGLE_texture1DProj_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture1DProj_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.x/coord.y, metal::bias(bias));\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture1DProj_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.x/coord.w, metal::bias(bias));\n}\n\n"
- "\n#define ANGLE_texture1DProjLod(env, ...) ANGLE_texture1DProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture1DProjLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.x/coord.y, metal::level(level));\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture1DProjLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.x/coord.w, metal::level(level));\n}\n\n"
- "\n#define ANGLE_texture2D(env, ...) ANGLE_texture2D_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2D_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord)\n{\n    return texture.sample(sampler, coord);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2D_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord,\n    float bias)\n{\n    return texture.sample(sampler, coord, metal::bias(bias));\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2D_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord)\n{\n    return texture.sample(sampler, coord);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2D_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float bias)\n{\n    return texture.sample(sampler, coord, metal::bias(bias));\n}\n\n"
- "\n#define ANGLE_texture2DGradEXT(env, ...) ANGLE_texture2DGradEXT_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DGradEXT_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return texture.sample(sampler, coord, metal::gradient2d(dPdx, dPdy));\n}\n\n"
- "\n#define ANGLE_texture2DLod(env, ...) ANGLE_texture2DLod_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord, metal::level(level));\n}\n\n"
- "\n#define ANGLE_texture2DProj(env, ...) ANGLE_texture2DProj_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProj_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.xy/coord.z, metal::bias(bias));\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProj_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.xy/coord.w, metal::bias(bias));\n}\n\n"
- "\n#define ANGLE_texture2DProjGradEXT(env, ...) ANGLE_texture2DProjGradEXT_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjGradEXT_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return texture.sample(sampler, coord.xy/coord.z, metal::gradient2d(dPdx, dPdy));\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjGradEXT_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy));\n}\n\n"
- "\n#define ANGLE_texture2DProjLod(env, ...) ANGLE_texture2DProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.xy/coord.z, metal::level(level));\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.xy/coord.w, metal::level(level));\n}\n\n"
- "\n#define ANGLE_texture2DRect(env, ...) ANGLE_texture2DRect_impl(*env.texture, *env.sampler, __VA_ARGS__)\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DRect_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord)\n{\n    return texture.sample(sampler, coord);\n}\n\n"
- "\n#define ANGLE_texture2DRectProj(env, ...) ANGLE_texture2DRectProj_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DRectProj_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord)\n{\n    return texture.sample(sampler, coord.xy/coord.z);\n}\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture2DRectProj_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord)\n{\n    return texture.sample(sampler, coord.xy/coord.w);\n}\n\n"
- "\n#define ANGLE_texture3DLod(env, ...) ANGLE_texture3DLod_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture3DLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord, metal::level(level));\n}\n\n"
- "\n#define ANGLE_texture3DProj(env, ...) ANGLE_texture3DProj_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture3DProj_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.xyz/coord.w, metal::bias(bias));\n}\n\n"
- "\n#define ANGLE_texture3DProjLod(env, ...) ANGLE_texture3DProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture3DProjLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.xyz/coord.w, metal::level(level));\n}\n\n"
- "\n#define ANGLE_textureCube(env, ...) ANGLE_textureCube_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureCube_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord)\n{\n    return texture.sample(sampler, coord);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureCube_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float bias)\n{\n    return texture.sample(sampler, coord, metal::bias(bias));\n}\n\n"
- "\n#define ANGLE_textureCubeGradEXT(env, ...) ANGLE_textureCubeGradEXT_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureCubeGradEXT_impl(\n    thread metal::texturecube<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy)\n{\n    return texture.sample(sampler, coord, metal::gradientcube(dPdx, dPdy));\n}\n\n"
- "\n#define ANGLE_textureCubeLod(env, ...) ANGLE_textureCubeLod_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureCubeLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord, metal::level(level));\n}\n\n"
- "\n#define ANGLE_textureCubeProj(env, ...) ANGLE_textureCubeProj_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureCubeProj_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.xyz/coord.w, metal::bias(bias));\n}\n\n"
- "\n#define ANGLE_textureCubeProjLod(env, ...) ANGLE_textureCubeProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureCubeProjLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.xyz/coord.w, metal::level(level));\n}\n\n"
- "\n#define ANGLE_textureGrad(env, ...) ANGLE_textureGrad_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\n"
- "\n#define ANGLE_textureGradOffset(env, ...) ANGLE_textureGradOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\n"
- "\n#define ANGLE_textureLod(env, ...) ANGLE_textureLod_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\n"
- "\n#define ANGLE_textureLodOffset(env, ...) ANGLE_textureLodOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord,\n    float level,\n    metal::int2 const offset)\n{\n    return texture.sample(sampler, coord, metal::level(level), offset);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level,\n    metal::int3 const offset)\n{\n    return texture.sample(sampler, coord, metal::level(level), offset);\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level,\n    int2 const offset)\n{\n    if (ANGLEUseSampleCompareLod)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xy, coord.z, metal::level(level), offset));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xy, metal::level(level), offset) > coord.z);\n    }\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(\n    thread metal::texture2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level,\n    metal::int2 const offset)\n{\n    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::level(level), offset);\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(\n    thread metal::texture2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level,\n    metal::int3 const offset)\n{\n    return texture.sample(sampler, coord.xyz, uint32_t(metal::round(coord.w)), metal::level(level), offset);\n}\n\n"
- "\n#define ANGLE_textureOffset(env, ...) ANGLE_textureOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord,\n    metal::int2 const offset)\n{\n    return texture.sample(sampler, coord, offset);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord,\n    metal::int2 const offset,\n    float bias)\n{\n    return texture.sample(sampler, coord, metal::bias(bias), offset);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::int2 const offset)\n{\n    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), offset);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::int2 const offset,\n    float bias)\n{\n    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::bias(bias), offset);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::int3 const offset)\n{\n    return texture.sample(sampler, coord, offset);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::int3 const offset,\n    float bias)\n{\n    return texture.sample(sampler, coord, metal::bias(bias), offset);\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::int2 const offset)\n{\n    return texture.sample_compare(sampler, coord.xy, coord.z, offset);\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::int2 const offset,\n    float bias)\n{\n    return texture.sample_compare(sampler, coord.xy, coord.z, metal::bias(bias), offset);\n}\n\n"
- "\n#define ANGLE_textureProj(env, ...) ANGLE_textureProj_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.xy/coord.z, metal::bias(bias));\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.xy/coord.w, metal::bias(bias));\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProj_impl(\n    thread metal::texture3d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.xyz/coord.w, metal::bias(bias));\n}\n\n"
- "\n#define ANGLE_textureProjGrad(env, ...) ANGLE_textureProjGrad_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\n"
- "\n#define ANGLE_textureProjGradOffset(env, ...) ANGLE_textureProjGradOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\n"
- "\n#define ANGLE_textureProjLod(env, ...) ANGLE_textureProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\n"
- "\n#define ANGLE_textureProjLodOffset(env, ...) ANGLE_textureProjLodOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level,\n    int2 const offset)\n{\n    return texture.sample(sampler, coord.xy/coord.z, metal::level(level), offset);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level,\n    int2 const offset)\n{\n    return texture.sample(sampler, coord.xy/coord.w, metal::level(level), offset);\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level,\n    int2 const offset)\n{\n    if (ANGLEUseSampleCompareLod)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xy/coord.w, coord.z/coord.w, metal::level(level), offset));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xy/coord.w, metal::level(level), offset) > coord.z/coord.w);\n    }\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset_impl(\n    thread metal::texture3d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level,\n    int3 const offset)\n{\n    return texture.sample(sampler, coord.xyz/coord.w, metal::level(level), offset);\n}\n\n"
- "\n#define ANGLE_textureProjOffset(env, ...) ANGLE_textureProjOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    int2 const offset,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.xy/coord.z, metal::bias(bias), offset);\n}\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    int2 const offset,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.xy/coord.w, metal::bias(bias), offset);\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset_impl(\n    thread metal::texture3d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    int3 const offset,\n    float bias = 0)\n{\n    return texture.sample(sampler, coord.xyz/coord.w, metal::bias(bias), offset);\n}\n\n"
- "\n#define ANGLE_textureSize(env, ...) ANGLE_textureSize_impl(*env.texture, __VA_ARGS__)\n\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureSize_impl(\n    thread Texture &texture,\n    int level)\n{\n    return int2(texture.get_width(uint32_t(level)), texture.get_height(uint32_t(level)));\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureSize_impl(\n    thread metal::texture3d<T> &texture,\n    int level)\n{\n    return int3(texture.get_width(uint32_t(level)), texture.get_height(uint32_t(level)), texture.get_depth(uint32_t(level)));\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureSize_impl(\n    thread metal::depth2d_array<T> &texture,\n    int level)\n{\n    return int3(texture.get_width(uint32_t(level)), texture.get_height(uint32_t(level)), texture.get_array_size());\n}\n\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureSize_impl(\n    thread metal::texture2d_array<T> &texture,\n    int level)\n{\n    return int3(texture.get_width(uint32_t(level)), texture.get_height(uint32_t(level)), texture.get_array_size());\n}\n\n"
- "\ntemplate <int N>\nstruct ANGLE_gradient_traits;\ntemplate <>\nstruct ANGLE_gradient_traits<2> { using type = metal::gradient2d; };\ntemplate <>\nstruct ANGLE_gradient_traits<3> { using type = metal::gradient3d; };\n\ntemplate <int N>\nusing ANGLE_gradient = typename ANGLE_gradient_traits<N>::type;\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    metal::int2 const offset)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xy, coord.z, metal::gradient2d(dPdx, dPdy), offset));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xy, metal::gradient2d(dPdx, dPdy), offset) > coord.z);\n    }\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(\n    thread metal::depth2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    metal::int2 const offset)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::gradient2d(dPdx, dPdy), offset));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy), offset) > coord.w);\n    }\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(\n    thread metal::depthcube<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy,\n    metal::int3 const offset)\n{\n    return texture.sample_compare(sampler, coord.xyz, coord.w, metal::gradientcube(dPdx, dPdy), offset);\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(\n    thread metal::texturecube<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy,\n    metal::int3 const offset)\n{\n    return texture.sample(sampler, coord, metal::gradientcube(dPdx, dPdy), offset);\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xy, coord.z, metal::gradient2d(dPdx, dPdy)));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xy, metal::gradient2d(dPdx, dPdy)) > coord.z);\n    }\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(\n    thread metal::depth2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::gradient2d(dPdx, dPdy)));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy)) > coord.w);\n    }\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(\n    thread metal::depthcube<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xyz, coord.w, metal::gradientcube(dPdx, dPdy)));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xyz, metal::gradientcube(dPdx, dPdy)) > coord.w);\n    }\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(\n    thread metal::texturecube<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy)\n{\n    return texture.sample(sampler, coord, metal::gradientcube(dPdx, dPdy));\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level)\n{\n    if (ANGLEUseSampleCompareLod)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xy, coord.z, metal::level(level)));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xy, metal::level(level)) > coord.z);\n    }\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(\n    thread metal::texture2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::level(level));\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(\n    thread metal::texture2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.xyz, uint32_t(metal::round(coord.w)), metal::level(level));\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    int2 const offset)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xy/coord.w, coord.z/coord.w, metal::gradient2d(dPdx, dPdy), offset));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy), offset) > coord.z/coord.w);\n    }\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset_impl(\n    thread metal::texture3d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy,\n    int3 const offset)\n{\n    return texture.sample(sampler, coord.xyz/coord.w, metal::gradient3d(dPdx, dPdy), offset);\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    if (ANGLEUseSampleCompareGradient)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xy/coord.w, coord.z/coord.w, metal::gradient2d(dPdx, dPdy)));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy)) > coord.z/coord.w);\n    }\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad_impl(\n    thread metal::texture3d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float3 const dPdx,\n    metal::float3 const dPdy)\n{\n    return texture.sample(sampler, coord.xyz/coord.w, metal::gradient3d(dPdx, dPdy));\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level)\n{\n    if (ANGLEUseSampleCompareLod)\n    {\n        return static_cast<T>(texture.sample_compare(sampler, coord.xy/coord.w, coord.z/coord.w, metal::level(level)));\n    }\n    else\n    {\n        return static_cast<T>(texture.sample(sampler, coord.xy/coord.w, metal::level(level)) > coord.z/coord.w);\n    }\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod_impl(\n    thread metal::texture3d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.xyz/coord.w, metal::level(level));\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord)\n{\n    return texture.sample_compare(sampler, coord.xy, coord.z);\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread metal::depth2d<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float bias)\n{\n    return texture.sample_compare(sampler, coord.xy, coord.z, metal::bias(bias));\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread metal::depth2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord)\n{\n    return texture.sample_compare(sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w);\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread metal::depth2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float compare)\n{\n    return texture.sample_compare(sampler, coord.xyz, uint32_t(metal::round(coord.w)), compare);\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread metal::depthcube<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord)\n{\n    return texture.sample_compare(sampler, coord.xyz, coord.w);\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread metal::depthcube<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float bias)\n{\n    return texture.sample_compare(sampler, coord.xyz, coord.w, metal::bias(bias));\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread metal::texture2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord)\n{\n    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)));\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread metal::texture2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float bias)\n{\n    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::bias(bias));\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread metal::texture2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord)\n{\n    return texture.sample(sampler, coord.xyz, uint32_t(metal::round(coord.w)));\n}\n\n"
- "\ntemplate <typename T>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread metal::texture2d_array<T> &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float bias)\n{\n    return texture.sample(sampler, coord.xyz, uint32_t(metal::round(coord.w)), metal::bias(bias));\n}\n\n"
- "\ntemplate <typename Texture, int N>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::vec<float, N> const coord,\n    metal::vec<float, N> const dPdx,\n    metal::vec<float, N> const dPdy,\n    metal::vec<int, N> const offset)\n{\n    return texture.sample(sampler, coord, ANGLE_gradient<N>(dPdx, dPdy), offset);\n}\n\n"
- "\ntemplate <typename Texture, int N>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::vec<float, N> const coord,\n    metal::vec<float, N> const dPdx,\n    metal::vec<float, N> const dPdy)\n{\n    return texture.sample(sampler, coord, ANGLE_gradient<N>(dPdx, dPdy));\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    metal::int2 const offset)\n{\n    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy), offset);\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    metal::int2 const offset)\n{\n    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy), offset);\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy));\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy));\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord, metal::level(level));\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord, metal::level(level));\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    int2 const offset)\n{\n    return texture.sample(sampler, coord.xy/coord.z, metal::gradient2d(dPdx, dPdy), offset);\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy,\n    int2 const offset)\n{\n    return texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy), offset);\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return texture.sample(sampler, coord.xy/coord.z, metal::gradient2d(dPdx, dPdy));\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    metal::float2 const dPdx,\n    metal::float2 const dPdy)\n{\n    return texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy));\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.xy/coord.z, metal::level(level));\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float4 const coord,\n    float level)\n{\n    return texture.sample(sampler, coord.xy/coord.w, metal::level(level));\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord)\n{\n    return texture.sample(sampler, coord);\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float2 const coord,\n    float bias)\n{\n    return texture.sample(sampler, coord, metal::bias(bias));\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord)\n{\n    return texture.sample(sampler, coord);\n}\n\n"
- "\ntemplate <typename Texture>\nANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(\n    thread Texture &texture,\n    thread metal::sampler const &sampler,\n    metal::float3 const coord,\n    float bias)\n{\n    return texture.sample(sampler, coord, metal::bias(bias));\n}\n\n"
- " (internal function)"
- " <anonymous>"
- "!isAMDFireProDevice()"
- "!isOSX && !isCatalyst && !isSimulator"
- "!isOSX || GetMacOSVersion() >= OSVersion(12, 0, 0)"
- "#define ANGLE_tensor metal::array\n"
- "' "
- "(isOSX || isCatalyst) && !isARM"
- "(symbol id "
- "2.1.23740 git hash: 5a8eab96c6b7"
- "2b88385687d0f98f9b90956bcbf626b2"
- "AMD Metal Drivers appear to have a bug this works around"
- "ANGLEUseSampleCompareLod"
- "ANGLE_tensor<"
- "Add shaderRead usage to some multisampled texture formats"
- "Allow compressed formats"
- "Allow creation of render passes without any attachments"
- "Always prefer to upload texture data via a staging buffer and avoid MTLTexture::replaceRegion."
- "Always update buffers by copying the data to a staging buffer and then blitting it to the actual buffer"
- "Apply a vendor-specific transformation to explicit cubemap derivatives"
- "Attempts to detect undefined behavior when in WebGL mode and reject shaders if any detected."
- "Attempts to generate shaders that are shareable. More specifically, shaders end up with conditionals that are decided at run time via input parameters vs compile time. This results in bigger shaders."
- "Cache MTLLibrary objects in memory."
- "Call a user-defined function"
- "Check the filesystem for shaders to use instead of those provided through glShaderSource"
- "Check the filesystem for translated shaders to use instead of the shader translator's"
- "Compile MTLLibrary in multiple threads."
- "Compiles metal shaders using command line tools and saves to BlobCache. Requires using --no-sandbox and disabling enableParallelMtlLibraryCompilation."
- "Disable fast math in atan and invariance cases when running below macOS 12.0"
- "Disable programmable blending in order to test read_write pixel local storage textures"
- "Disable raster order groups in order to test pixel local storage memory barriers"
- "Disable support for GL_OES_get_program_binary"
- "Disable support for OES_draw_buffers_indexed and EXT_draw_buffers_indexed"
- "Disable support for anisotropic filtering"
- "Disable tier2 read_write textures in order to test tier1 support"
- "Disables multi-threaded decompression of compressed texture formats"
- "Disables saving programs to the cache"
- "Do not create swizzled views of stencil textures"
- "EGL_ANGLE_device_eagl"
- "EGL_ANGLE_platform_device_context_volatile_eagl"
- "EXT/OES_draw_buffers_indexed is not available."
- "Emulate ANGLE_shader_pixel_local_storage using shader images"
- "Emulate DontCare loadAction with Clear loadAction. The clear values will be randomized."
- "Enable EXT_multisampled_render_to_texture on non tiled GPUs."
- "Enable multi-draw and base vertex base instance extensions for non-WebGL contexts if they are emulated."
- "Enable to cache compiled shaders"
- "Even if FrameCapture is enabled, enable GL_OES_get_program_binary"
- "Flush after calls to StreamVertexData to work around driver bugs."
- "Force Depth24Stencil8 format as unsupported."
- "Force GL error checking (i.e. prevent applications from disabling error checking"
- "Force depth attachment initialization on clear ops"
- "Force flush after drawcall use shadow map for intel device."
- "Force the minimum GL_MAX_VERTEX_ATTRIBS that the context's client version allows."
- "Force-enable robust resource init"
- "Force-enable shader variable initialization"
- "GL_"
- "If false, parts of the compile job cannot be parallelized"
- "If false, parts of the link job cannot be parallelized"
- "If true, sub tasks of the link job are always threaded, regardless of GL_KHR_parallel_shader_compile"
- "Inject asm() statements into loop bodies to force all loops to be treated as having side effects and not optimized out."
- "Insert explicit casts for float/double/unsigned/signed int on macOS 10.15 with Intel driver"
- "Invalid OpenGL profile mask."
- "Invalid value for EGL_PLATFORM_ANGLE_DEVICE_CONTEXT_VOLATILE_EAGL_ANGLE attrib"
- "Loads metal shaders from blob cache. Useful if compile_metal_shaders was used to generate shaders."
- "MSL 2.1 is required to support all the features of OpenGL ES 2.0"
- "Mac GPU Family 2 is required to support all the features of OpenGL ES 2.0"
- "Make egl surface uncurrent when calling eglDestroySurface(), if the surface is still bound by the context of current render thread"
- "Makes bufferSubData always update via CPU"
- "Metal buffers can be managed, shared, or private. Sometimes managed is fastest"
- "Metal buffers can be managed, shared, or private. Sometimes shared is fastest"
- "Metal iOS has a limit on the number of color target bits per pixel."
- "NVIDIA GPUs are unsupported due to scarcity of the hardware."
- "On some GPUs, program binaries don't contain transform feedback varyings"
- "On some architectures using a shadow buffer can be faster for certain size buffers"
- "On systems that support both buffer' memory allocation on GPU and shared memory (such as macOS), force using GPU memory allocation for buffers everytime or not."
- "OpenGL ES 1.x or 3.2 Required"
- "OpenGL GLSL "
- "OpenGL profile mask requires an OpenGL context."
- "PLS"
- "Packed depth stencil texture/buffer must not be mixed with other texture/buffer."
- "Prints the source to a shader before it's compiled."
- "Rescope global variables that are only used in one function to be function-local."
- "Set the context limits like frame capturing was enabled"
- "Some Apple platforms such as iOS allows separate depth and stencil buffers, whereas others such as macOS don't"
- "Some GPUs ignore alpha-to-coverage when [[sample_mask]] is written"
- "Some GPUs produce incorrect derivatives unless [[sample_mask]] is written"
- "Some users rely on a lost context notification if a GL_OUT_OF_MEMORY error occurs"
- "Staged GPU upload of some packed texture formats such as RGB9_E5 fail on Intel GPUs."
- "Surface not compatible with OpenGL Desktop."
- "The renderer can cheaply break a render pass."
- "The renderer supports MSAA depth auto resolve at the end of render pass"
- "The renderer supports MSAA stencil auto resolve at the end of render pass"
- "The renderer supports MSAA store and resolve in the same pass"
- "The renderer supports MTL(Shared)Event"
- "The renderer supports base vertex instanced draw"
- "The renderer supports buffer read and write in the same shader"
- "The renderer supports changing sampler's compare mode outside shaders"
- "The renderer supports explicit memory barrier"
- "The renderer supports generating multiple mipmaps per pass"
- "The renderer supports non uniform compute shader dispatch's group size"
- "The renderer supports sample_compare with gradients"
- "The renderer supports sample_compare with lod"
- "The renderer supports stencil output from fragment shader"
- "The renderer supports texture swizzle"
- "The renderer supports using inline constant data for small client vertex data"
- "The renderer supports variable rasterization rate"
- "Turn this feature on to disallow Compute Shader based mipmap generation. Compute Shader based mipmap generation might cause GPU hang on some older iOS devices."
- "Turn this on to allow transform feedback in Metal using a 2-pass VS for GLES3."
- "Used to check the backend works when the device's advertized limit is less than the code's limit"
- "ViewportIndex"
- "When uploading data to IOSurface-backed textures, use a staging buffer."
- "Write shader source to temp directory"
- "Write translated shaders to temp directory"
- "abs(00D"
- "abs(10D"
- "abs(20D"
- "abs(30D"
- "all(10F"
- "all(20F"
- "all(30F"
- "allowSamplerCompareLod"
- "any(10F"
- "any(20F"
- "any(30F"
- "atomicAdd(00E00E"
- "atomicAnd(00E00E"
- "atomicCompSwap(00E00E00E"
- "atomicCounter(00G"
- "atomicCounterDecrement(00G"
- "atomicCounterIncrement(00G"
- "atomicExchange(00E00E"
- "atomicMax(00E00E"
- "atomicMin(00E00E"
- "atomicOr(00E00E"
- "atomicXor(00E00E"
- "bitCount(00E"
- "bitCount(10E"
- "bitCount(20E"
- "bitCount(30E"
- "bitfieldExtract(00D00D00D"
- "bitfieldExtract(00E00D00D"
- "bitfieldExtract(10D00D00D"
- "bitfieldExtract(10E00D00D"
- "bitfieldExtract(20D00D00D"
- "bitfieldExtract(20E00D00D"
- "bitfieldExtract(30D00D00D"
- "bitfieldExtract(30E00D00D"
- "bitfieldInsert(00D00D00D00D"
- "bitfieldInsert(00E00E00D00D"
- "bitfieldInsert(10D10D00D00D"
- "bitfieldInsert(10E10E00D00D"
- "bitfieldInsert(20D20D00D00D"
- "bitfieldInsert(20E20E00D00D"
- "bitfieldInsert(30D30D00D00D"
- "bitfieldInsert(30E30E00D00D"
- "bitfieldReverse(00E"
- "bitfieldReverse(10E"
- "bitfieldReverse(20E"
- "bitfieldReverse(30E"
- "checkPackedDepthStencilAttachment"
- "clamp(00E00E00E"
- "clamp(10E00E00E"
- "clamp(10E10E10E"
- "clamp(20E00E00E"
- "clamp(20E20E20E"
- "clamp(30E00E00E"
- "clamp(30E30E30E"
- "cw"
- "dimension out of bounds"
- "eglQueryTimestampSupportedANDROID"
- "equal(10F10F"
- "equal(20F20F"
- "equal(30F30F"
- "false (override)"
- "findLSB(00E"
- "findLSB(10E"
- "findLSB(20E"
- "findLSB(30E"
- "findMSB(00E"
- "findMSB(10E"
- "findMSB(20E"
- "findMSB(30E"
- "frexp(00B00D"
- "frexp(10B10D"
- "frexp(20B20D"
- "frexp(30B30D"
- "function parameter array must be sized at compile time"
- "glAccum"
- "glAreTexturesResident"
- "glArrayElement"
- "glBegin"
- "glBeginConditionalRender"
- "glBeginQueryIndexed"
- "glBindBuffersBase"
- "glBindBuffersRange"
- "glBindFragDataLocation"
- "glBindFragDataLocationIndexed"
- "glBindImageTextures"
- "glBindSamplers"
- "glBindTextureUnit"
- "glBindTextures"
- "glBindVertexBuffers"
- "glBitmap"
- "glBlitNamedFramebuffer"
- "glBufferStorage"
- "glCallList"
- "glCallLists"
- "glCheckNamedFramebufferStatus"
- "glClampColor"
- "glClearAccum"
- "glClearBufferData"
- "glClearBufferSubData"
- "glClearDepth"
- "glClearIndex"
- "glClearNamedBufferData"
- "glClearNamedBufferSubData"
- "glClearNamedFramebufferfi"
- "glClearNamedFramebufferfv"
- "glClearNamedFramebufferiv"
- "glClearNamedFramebufferuiv"
- "glClearTexImage"
- "glClearTexSubImage"
- "glClipControl"
- "glClipPlane"
- "glColor3b"
- "glColor3bv"
- "glColor3d"
- "glColor3dv"
- "glColor3f"
- "glColor3fv"
- "glColor3i"
- "glColor3iv"
- "glColor3s"
- "glColor3sv"
- "glColor3ub"
- "glColor3ubv"
- "glColor3ui"
- "glColor3uiv"
- "glColor3us"
- "glColor3usv"
- "glColor4b"
- "glColor4bv"
- "glColor4d"
- "glColor4dv"
- "glColor4fv"
- "glColor4i"
- "glColor4iv"
- "glColor4s"
- "glColor4sv"
- "glColor4ubv"
- "glColor4ui"
- "glColor4uiv"
- "glColor4us"
- "glColor4usv"
- "glColorMaterial"
- "glColorP3ui"
- "glColorP3uiv"
- "glColorP4ui"
- "glColorP4uiv"
- "glCompressedTexImage1D"
- "glCompressedTexSubImage1D"
- "glCompressedTextureSubImage1D"
- "glCompressedTextureSubImage2D"
- "glCompressedTextureSubImage3D"
- "glCopyNamedBufferSubData"
- "glCopyPixels"
- "glCopyTexImage1D"
- "glCopyTexSubImage1D"
- "glCopyTextureSubImage1D"
- "glCopyTextureSubImage2D"
- "glCopyTextureSubImage3D"
- "glCreateBuffers"
- "glCreateFramebuffers"
- "glCreateProgramPipelines"
- "glCreateQueries"
- "glCreateRenderbuffers"
- "glCreateSamplers"
- "glCreateTextures"
- "glCreateTransformFeedbacks"
- "glCreateVertexArrays"
- "glDeleteLists"
- "glDepthRange"
- "glDepthRangeArrayv"
- "glDepthRangeIndexed"
- "glDisableVertexArrayAttrib"
- "glDrawArraysInstancedBaseInstance"
- "glDrawBuffer"
- "glDrawElementsInstancedBaseInstance"
- "glDrawElementsInstancedBaseVertexBaseInstance"
- "glDrawPixels"
- "glDrawTransformFeedback"
- "glDrawTransformFeedbackInstanced"
- "glDrawTransformFeedbackStream"
- "glDrawTransformFeedbackStreamInstanced"
- "glEdgeFlag"
- "glEdgeFlagPointer"
- "glEdgeFlagv"
- "glEnableVertexArrayAttrib"
- "glEnd"
- "glEndConditionalRender"
- "glEndList"
- "glEndQueryIndexed"
- "glEvalCoord1d"
- "glEvalCoord1dv"
- "glEvalCoord1f"
- "glEvalCoord1fv"
- "glEvalCoord2d"
- "glEvalCoord2dv"
- "glEvalCoord2f"
- "glEvalCoord2fv"
- "glEvalMesh1"
- "glEvalMesh2"
- "glEvalPoint1"
- "glEvalPoint2"
- "glFeedbackBuffer"
- "glFlushMappedNamedBufferRange"
- "glFogCoordPointer"
- "glFogCoordd"
- "glFogCoorddv"
- "glFogCoordf"
- "glFogCoordfv"
- "glFogi"
- "glFogiv"
- "glFramebufferTexture1D"
- "glFramebufferTexture3D"
- "glFrustum"
- "glGenLists"
- "glGenerateTextureMipmap"
- "glGetActiveAtomicCounterBufferiv"
- "glGetActiveSubroutineName"
- "glGetActiveSubroutineUniformName"
- "glGetActiveSubroutineUniformiv"
- "glGetActiveUniformName"
- "glGetBufferSubData"
- "glGetClipPlane"
- "glGetCompressedTexImage"
- "glGetCompressedTextureImage"
- "glGetCompressedTextureSubImage"
- "glGetDoublei_v"
- "glGetDoublev"
- "glGetFloati_v"
- "glGetFragDataIndex"
- "glGetInternalformati64v"
- "glGetLightiv"
- "glGetMapdv"
- "glGetMapfv"
- "glGetMapiv"
- "glGetMaterialiv"
- "glGetNamedBufferParameteri64v"
- "glGetNamedBufferParameteriv"
- "glGetNamedBufferPointerv"
- "glGetNamedBufferSubData"
- "glGetNamedFramebufferAttachmentParameteriv"
- "glGetNamedFramebufferParameteriv"
- "glGetNamedRenderbufferParameteriv"
- "glGetPixelMapfv"
- "glGetPixelMapuiv"
- "glGetPixelMapusv"
- "glGetPolygonStipple"
- "glGetProgramResourceLocationIndex"
- "glGetProgramStageiv"
- "glGetQueryBufferObjecti64v"
- "glGetQueryBufferObjectiv"
- "glGetQueryBufferObjectui64v"
- "glGetQueryBufferObjectuiv"
- "glGetQueryIndexediv"
- "glGetQueryObjecti64v"
- "glGetQueryObjectiv"
- "glGetQueryObjectui64v"
- "glGetSubroutineIndex"
- "glGetSubroutineUniformLocation"
- "glGetTexGendv"
- "glGetTexGenfv"
- "glGetTexGeniv"
- "glGetTexImage"
- "glGetTextureImage"
- "glGetTextureLevelParameterfv"
- "glGetTextureLevelParameteriv"
- "glGetTextureParameterIiv"
- "glGetTextureParameterIuiv"
- "glGetTextureParameterfv"
- "glGetTextureParameteriv"
- "glGetTextureSubImage"
- "glGetTransformFeedbacki64_v"
- "glGetTransformFeedbacki_v"
- "glGetTransformFeedbackiv"
- "glGetUniformSubroutineuiv"
- "glGetUniformdv"
- "glGetVertexArrayIndexed64iv"
- "glGetVertexArrayIndexediv"
- "glGetVertexArrayiv"
- "glGetVertexAttribLdv"
- "glGetVertexAttribdv"
- "glGetnColorTable"
- "glGetnCompressedTexImage"
- "glGetnConvolutionFilter"
- "glGetnHistogram"
- "glGetnMapdv"
- "glGetnMapfv"
- "glGetnMapiv"
- "glGetnMinmax"
- "glGetnPixelMapfv"
- "glGetnPixelMapuiv"
- "glGetnPixelMapusv"
- "glGetnPolygonStipple"
- "glGetnSeparableFilter"
- "glGetnTexImage"
- "glGetnUniformdv"
- "glIndexMask"
- "glIndexPointer"
- "glIndexd"
- "glIndexdv"
- "glIndexf"
- "glIndexfv"
- "glIndexi"
- "glIndexiv"
- "glIndexs"
- "glIndexsv"
- "glIndexub"
- "glIndexubv"
- "glInitNames"
- "glInterleavedArrays"
- "glInvalidateBufferData"
- "glInvalidateBufferSubData"
- "glInvalidateNamedFramebufferData"
- "glInvalidateNamedFramebufferSubData"
- "glInvalidateTexImage"
- "glInvalidateTexSubImage"
- "glIsList"
- "glLightModeli"
- "glLightModeliv"
- "glLighti"
- "glLightiv"
- "glLineStipple"
- "glListBase"
- "glLoadMatrixd"
- "glLoadName"
- "glLoadTransposeMatrixd"
- "glLoadTransposeMatrixf"
- "glMap1d"
- "glMap1f"
- "glMap2d"
- "glMap2f"
- "glMapBuffer"
- "glMapGrid1d"
- "glMapGrid1f"
- "glMapGrid2d"
- "glMapGrid2f"
- "glMapNamedBuffer"
- "glMapNamedBufferRange"
- "glMateriali"
- "glMaterialiv"
- "glMultMatrixd"
- "glMultTransposeMatrixd"
- "glMultTransposeMatrixf"
- "glMultiDrawArrays"
- "glMultiDrawArraysIndirect"
- "glMultiDrawArraysIndirectCount"
- "glMultiDrawElements"
- "glMultiDrawElementsBaseVertex"
- "glMultiDrawElementsIndirect"
- "glMultiDrawElementsIndirectCount"
- "glMultiTexCoord1d"
- "glMultiTexCoord1dv"
- "glMultiTexCoord1f"
- "glMultiTexCoord1fv"
- "glMultiTexCoord1i"
- "glMultiTexCoord1iv"
- "glMultiTexCoord1s"
- "glMultiTexCoord1sv"
- "glMultiTexCoord2d"
- "glMultiTexCoord2dv"
- "glMultiTexCoord2f"
- "glMultiTexCoord2fv"
- "glMultiTexCoord2i"
- "glMultiTexCoord2iv"
- "glMultiTexCoord2s"
- "glMultiTexCoord2sv"
- "glMultiTexCoord3d"
- "glMultiTexCoord3dv"
- "glMultiTexCoord3f"
- "glMultiTexCoord3fv"
- "glMultiTexCoord3i"
- "glMultiTexCoord3iv"
- "glMultiTexCoord3s"
- "glMultiTexCoord3sv"
- "glMultiTexCoord4d"
- "glMultiTexCoord4dv"
- "glMultiTexCoord4fv"
- "glMultiTexCoord4i"
- "glMultiTexCoord4iv"
- "glMultiTexCoord4s"
- "glMultiTexCoord4sv"
- "glMultiTexCoordP1ui"
- "glMultiTexCoordP1uiv"
- "glMultiTexCoordP2ui"
- "glMultiTexCoordP2uiv"
- "glMultiTexCoordP3ui"
- "glMultiTexCoordP3uiv"
- "glMultiTexCoordP4ui"
- "glMultiTexCoordP4uiv"
- "glNamedBufferData"
- "glNamedBufferStorage"
- "glNamedBufferSubData"
- "glNamedFramebufferDrawBuffer"
- "glNamedFramebufferDrawBuffers"
- "glNamedFramebufferParameteri"
- "glNamedFramebufferReadBuffer"
- "glNamedFramebufferRenderbuffer"
- "glNamedFramebufferTexture"
- "glNamedFramebufferTextureLayer"
- "glNamedRenderbufferStorage"
- "glNamedRenderbufferStorageMultisample"
- "glNewList"
- "glNormal3b"
- "glNormal3bv"
- "glNormal3d"
- "glNormal3dv"
- "glNormal3fv"
- "glNormal3i"
- "glNormal3iv"
- "glNormal3s"
- "glNormal3sv"
- "glNormalP3ui"
- "glNormalP3uiv"
- "glOrtho"
- "glPassThrough"
- "glPatchParameterfv"
- "glPixelMapfv"
- "glPixelMapuiv"
- "glPixelMapusv"
- "glPixelStoref"
- "glPixelTransferf"
- "glPixelTransferi"
- "glPixelZoom"
- "glPointParameteri"
- "glPointParameteriv"
- "glPolygonMode"
- "glPolygonOffsetClamp"
- "glPolygonStipple"
- "glPopAttrib"
- "glPopClientAttrib"
- "glPopName"
- "glPrimitiveRestartIndex"
- "glPrioritizeTextures"
- "glProgramUniform1d"
- "glProgramUniform1dv"
- "glProgramUniform2d"
- "glProgramUniform2dv"
- "glProgramUniform3d"
- "glProgramUniform3dv"
- "glProgramUniform4d"
- "glProgramUniform4dv"
- "glProgramUniformMatrix2dv"
- "glProgramUniformMatrix2x3dv"
- "glProgramUniformMatrix2x4dv"
- "glProgramUniformMatrix3dv"
- "glProgramUniformMatrix3x2dv"
- "glProgramUniformMatrix3x4dv"
- "glProgramUniformMatrix4dv"
- "glProgramUniformMatrix4x2dv"
- "glProgramUniformMatrix4x3dv"
- "glProvokingVertex"
- "glPushAttrib"
- "glPushClientAttrib"
- "glPushName"
- "glQueryCounter"
- "glRasterPos2d"
- "glRasterPos2dv"
- "glRasterPos2f"
- "glRasterPos2fv"
- "glRasterPos2i"
- "glRasterPos2iv"
- "glRasterPos2s"
- "glRasterPos2sv"
- "glRasterPos3d"
- "glRasterPos3dv"
- "glRasterPos3f"
- "glRasterPos3fv"
- "glRasterPos3i"
- "glRasterPos3iv"
- "glRasterPos3s"
- "glRasterPos3sv"
- "glRasterPos4d"
- "glRasterPos4dv"
- "glRasterPos4f"
- "glRasterPos4fv"
- "glRasterPos4i"
- "glRasterPos4iv"
- "glRasterPos4s"
- "glRasterPos4sv"
- "glRectd"
- "glRectdv"
- "glRectf"
- "glRectfv"
- "glRecti"
- "glRectiv"
- "glRects"
- "glRectsv"
- "glRenderMode"
- "glRotated"
- "glScaled"
- "glScissorArrayv"
- "glScissorIndexed"
- "glScissorIndexedv"
- "glSecondaryColor3b"
- "glSecondaryColor3bv"
- "glSecondaryColor3d"
- "glSecondaryColor3dv"
- "glSecondaryColor3f"
- "glSecondaryColor3fv"
- "glSecondaryColor3i"
- "glSecondaryColor3iv"
- "glSecondaryColor3s"
- "glSecondaryColor3sv"
- "glSecondaryColor3ub"
- "glSecondaryColor3ubv"
- "glSecondaryColor3ui"
- "glSecondaryColor3uiv"
- "glSecondaryColor3us"
- "glSecondaryColor3usv"
- "glSecondaryColorP3ui"
- "glSecondaryColorP3uiv"
- "glSecondaryColorPointer"
- "glSelectBuffer"
- "glShaderStorageBlockBinding"
- "glSpecializeShader"
- "glTexCoord1d"
- "glTexCoord1dv"
- "glTexCoord1f"
- "glTexCoord1fv"
- "glTexCoord1i"
- "glTexCoord1iv"
- "glTexCoord1s"
- "glTexCoord1sv"
- "glTexCoord2d"
- "glTexCoord2dv"
- "glTexCoord2f"
- "glTexCoord2fv"
- "glTexCoord2i"
- "glTexCoord2iv"
- "glTexCoord2s"
- "glTexCoord2sv"
- "glTexCoord3d"
- "glTexCoord3dv"
- "glTexCoord3f"
- "glTexCoord3fv"
- "glTexCoord3i"
- "glTexCoord3iv"
- "glTexCoord3s"
- "glTexCoord3sv"
- "glTexCoord4d"
- "glTexCoord4dv"
- "glTexCoord4f"
- "glTexCoord4fv"
- "glTexCoord4i"
- "glTexCoord4iv"
- "glTexCoord4s"
- "glTexCoord4sv"
- "glTexCoordP1ui"
- "glTexCoordP1uiv"
- "glTexCoordP2ui"
- "glTexCoordP2uiv"
- "glTexCoordP3ui"
- "glTexCoordP3uiv"
- "glTexCoordP4ui"
- "glTexCoordP4uiv"
- "glTexGend"
- "glTexGendv"
- "glTexGenf"
- "glTexGenfv"
- "glTexGeni"
- "glTexGeniv"
- "glTexImage1D"
- "glTexImage2DMultisample"
- "glTexImage3DMultisample"
- "glTexStorage1D"
- "glTexSubImage1D"
- "glTextureBarrier"
- "glTextureBuffer"
- "glTextureBufferRange"
- "glTextureParameterIiv"
- "glTextureParameterIuiv"
- "glTextureParameterf"
- "glTextureParameterfv"
- "glTextureParameteri"
- "glTextureParameteriv"
- "glTextureStorage1D"
- "glTextureStorage2D"
- "glTextureStorage2DMultisample"
- "glTextureStorage3D"
- "glTextureStorage3DMultisample"
- "glTextureSubImage1D"
- "glTextureSubImage2D"
- "glTextureSubImage3D"
- "glTextureView"
- "glTransformFeedbackBufferBase"
- "glTransformFeedbackBufferRange"
- "glTranslated"
- "glUniform1d"
- "glUniform1dv"
- "glUniform2d"
- "glUniform2dv"
- "glUniform3d"
- "glUniform3dv"
- "glUniform4d"
- "glUniform4dv"
- "glUniformMatrix2dv"
- "glUniformMatrix2x3dv"
- "glUniformMatrix2x4dv"
- "glUniformMatrix3dv"
- "glUniformMatrix3x2dv"
- "glUniformMatrix3x4dv"
- "glUniformMatrix4dv"
- "glUniformMatrix4x2dv"
- "glUniformMatrix4x3dv"
- "glUniformSubroutinesuiv"
- "glUnmapNamedBuffer"
- "glVertex2d"
- "glVertex2dv"
- "glVertex2f"
- "glVertex2fv"
- "glVertex2i"
- "glVertex2iv"
- "glVertex2s"
- "glVertex2sv"
- "glVertex3d"
- "glVertex3dv"
- "glVertex3f"
- "glVertex3fv"
- "glVertex3i"
- "glVertex3iv"
- "glVertex3s"
- "glVertex3sv"
- "glVertex4d"
- "glVertex4dv"
- "glVertex4f"
- "glVertex4fv"
- "glVertex4i"
- "glVertex4iv"
- "glVertex4s"
- "glVertex4sv"
- "glVertexArrayAttribBinding"
- "glVertexArrayAttribFormat"
- "glVertexArrayAttribIFormat"
- "glVertexArrayAttribLFormat"
- "glVertexArrayBindingDivisor"
- "glVertexArrayElementBuffer"
- "glVertexArrayVertexBuffer"
- "glVertexArrayVertexBuffers"
- "glVertexAttrib1d"
- "glVertexAttrib1dv"
- "glVertexAttrib1s"
- "glVertexAttrib1sv"
- "glVertexAttrib2d"
- "glVertexAttrib2dv"
- "glVertexAttrib2s"
- "glVertexAttrib2sv"
- "glVertexAttrib3d"
- "glVertexAttrib3dv"
- "glVertexAttrib3s"
- "glVertexAttrib3sv"
- "glVertexAttrib4Nbv"
- "glVertexAttrib4Niv"
- "glVertexAttrib4Nsv"
- "glVertexAttrib4Nub"
- "glVertexAttrib4Nubv"
- "glVertexAttrib4Nuiv"
- "glVertexAttrib4Nusv"
- "glVertexAttrib4bv"
- "glVertexAttrib4d"
- "glVertexAttrib4dv"
- "glVertexAttrib4iv"
- "glVertexAttrib4s"
- "glVertexAttrib4sv"
- "glVertexAttrib4ubv"
- "glVertexAttrib4uiv"
- "glVertexAttrib4usv"
- "glVertexAttribI1i"
- "glVertexAttribI1iv"
- "glVertexAttribI1ui"
- "glVertexAttribI1uiv"
- "glVertexAttribI2i"
- "glVertexAttribI2iv"
- "glVertexAttribI2ui"
- "glVertexAttribI2uiv"
- "glVertexAttribI3i"
- "glVertexAttribI3iv"
- "glVertexAttribI3ui"
- "glVertexAttribI3uiv"
- "glVertexAttribI4bv"
- "glVertexAttribI4sv"
- "glVertexAttribI4ubv"
- "glVertexAttribI4usv"
- "glVertexAttribL1d"
- "glVertexAttribL1dv"
- "glVertexAttribL2d"
- "glVertexAttribL2dv"
- "glVertexAttribL3d"
- "glVertexAttribL3dv"
- "glVertexAttribL4d"
- "glVertexAttribL4dv"
- "glVertexAttribLFormat"
- "glVertexAttribLPointer"
- "glVertexAttribP1ui"
- "glVertexAttribP1uiv"
- "glVertexAttribP2ui"
- "glVertexAttribP2uiv"
- "glVertexAttribP3ui"
- "glVertexAttribP3uiv"
- "glVertexAttribP4ui"
- "glVertexAttribP4uiv"
- "glVertexP2ui"
- "glVertexP2uiv"
- "glVertexP3ui"
- "glVertexP3uiv"
- "glVertexP4ui"
- "glVertexP4uiv"
- "glViewportArrayv"
- "glViewportIndexedf"
- "glViewportIndexedfv"
- "glWindowPos2d"
- "glWindowPos2dv"
- "glWindowPos2f"
- "glWindowPos2fv"
- "glWindowPos2i"
- "glWindowPos2iv"
- "glWindowPos2s"
- "glWindowPos2sv"
- "glWindowPos3d"
- "glWindowPos3dv"
- "glWindowPos3f"
- "glWindowPos3fv"
- "glWindowPos3i"
- "glWindowPos3iv"
- "glWindowPos3s"
- "glWindowPos3sv"
- "greaterThan(10E10E"
- "greaterThan(20E20E"
- "greaterThan(30E30E"
- "greaterThanEqual(10E10E"
- "greaterThanEqual(20E20E"
- "greaterThanEqual(30E30E"
- "http://anglebug.com/1423136"
- "http://anglebug.com/355645824"
- "http://anglebug.com/40096835"
- "http://anglebug.com/40096835 http://anglebug.com/40096850"
- "http://anglebug.com/40096838"
- "http://anglebug.com/40096850"
- "http://anglebug.com/40096869"
- "http://anglebug.com/40644888"
- "http://anglebug.com/40644905"
- "http://anglebug.com/40644912"
- "http://anglebug.com/41488637"
- "http://anglebug.com/42261786"
- "http://anglebug.com/42263580"
- "http://anglebug.com/42264193"
- "http://anglebug.com/42264287"
- "http://anglebug.com/42264571"
- "http://anglebug.com/42265509"
- "http://anglebug.com/42265518"
- "http://anglebug.com/42265754"
- "http://anglebug.com/42266101"
- "http://anglebug.com/42266194"
- "http://anglebug.com/42266231"
- "http://anglebug.com/42266232"
- "http://anglebug.com/42266609"
- "http://anglebug.com/42266694"
- "http://anglebug.com/42266744"
- "http://anglebug.com/42266842"
- "http://crbug.com/1380790"
- "http://crbug.com/1385510"
- "http://crbug.com/1423136"
- "http://crbug.com/1513738"
- "http://crbug.com/350528343"
- "https://anglebug.com/42265720"
- "https://issuetracker.google.com/220069903"
- "https://issuetracker.google.com/292285899"
- "https://issuetracker.google.com/349489248"
- "imageAtomicAdd(00z10D00D"
- "imageAtomicAdd(00z10D00E"
- "imageAtomicAdd(01A20D00D"
- "imageAtomicAdd(01A20D00E"
- "imageAtomicAdd(01B20D00D"
- "imageAtomicAdd(01B20D00E"
- "imageAtomicAdd(01C20D00D"
- "imageAtomicAdd(01C20D00E"
- "imageAtomicAdd(01D00D00D"
- "imageAtomicAdd(01D00D00E"
- "imageAtomicAdd(01E10D00D"
- "imageAtomicAdd(01E10D00E"
- "imageAtomicAdd(01F10D00D00D"
- "imageAtomicAdd(01F10D00D00E"
- "imageAtomicAdd(01G20D00D00D"
- "imageAtomicAdd(01G20D00D00E"
- "imageAtomicAdd(01H20D00D"
- "imageAtomicAdd(01H20D00E"
- "imageAtomicAdd(01I10D00D"
- "imageAtomicAdd(01I10D00E"
- "imageAtomicAdd(01J00D00D"
- "imageAtomicAdd(01J00D00E"
- "imageAtomicAdd(01K10D00D"
- "imageAtomicAdd(01K10D00E"
- "imageAtomicAdd(01L20D00D"
- "imageAtomicAdd(01L20D00E"
- "imageAtomicAdd(01M20D00D"
- "imageAtomicAdd(01M20D00E"
- "imageAtomicAdd(01N20D00D"
- "imageAtomicAdd(01N20D00E"
- "imageAtomicAdd(01O00D00D"
- "imageAtomicAdd(01O00D00E"
- "imageAtomicAdd(01P10D00D"
- "imageAtomicAdd(01P10D00E"
- "imageAtomicAdd(01Q10D00D00D"
- "imageAtomicAdd(01Q10D00D00E"
- "imageAtomicAdd(01R20D00D00D"
- "imageAtomicAdd(01R20D00D00E"
- "imageAtomicAdd(01S20D00D"
- "imageAtomicAdd(01S20D00E"
- "imageAtomicAdd(01T10D00D"
- "imageAtomicAdd(01T10D00E"
- "imageAtomicAdd(01U00D00D"
- "imageAtomicAdd(01U00D00E"
- "imageAtomicAdd(01V10D00D"
- "imageAtomicAdd(01V10D00E"
- "imageAtomicAdd(01W20D00D"
- "imageAtomicAdd(01W20D00E"
- "imageAtomicAdd(01X20D00D"
- "imageAtomicAdd(01X20D00E"
- "imageAtomicAdd(01Y20D00D"
- "imageAtomicAdd(01Y20D00E"
- "imageAtomicAdd(01Z00D00D"
- "imageAtomicAdd(01Z00D00E"
- "imageAtomicAdd(01a10D00D"
- "imageAtomicAdd(01a10D00E"
- "imageAtomicAdd(01b10D00D00D"
- "imageAtomicAdd(01b10D00D00E"
- "imageAtomicAdd(01c20D00D00D"
- "imageAtomicAdd(01c20D00D00E"
- "imageAtomicAdd(01d20D00D"
- "imageAtomicAdd(01d20D00E"
- "imageAtomicAdd(01e10D00D"
- "imageAtomicAdd(01e10D00E"
- "imageAtomicAdd(01f00D00D"
- "imageAtomicAdd(01f00D00E"
- "imageAtomicAnd(00z10D00D"
- "imageAtomicAnd(00z10D00E"
- "imageAtomicAnd(01A20D00D"
- "imageAtomicAnd(01A20D00E"
- "imageAtomicAnd(01B20D00D"
- "imageAtomicAnd(01B20D00E"
- "imageAtomicAnd(01C20D00D"
- "imageAtomicAnd(01C20D00E"
- "imageAtomicAnd(01D00D00D"
- "imageAtomicAnd(01D00D00E"
- "imageAtomicAnd(01E10D00D"
- "imageAtomicAnd(01E10D00E"
- "imageAtomicAnd(01F10D00D00D"
- "imageAtomicAnd(01F10D00D00E"
- "imageAtomicAnd(01G20D00D00D"
- "imageAtomicAnd(01G20D00D00E"
- "imageAtomicAnd(01H20D00D"
- "imageAtomicAnd(01H20D00E"
- "imageAtomicAnd(01I10D00D"
- "imageAtomicAnd(01I10D00E"
- "imageAtomicAnd(01J00D00D"
- "imageAtomicAnd(01J00D00E"
- "imageAtomicAnd(01K10D00D"
- "imageAtomicAnd(01K10D00E"
- "imageAtomicAnd(01L20D00D"
- "imageAtomicAnd(01L20D00E"
- "imageAtomicAnd(01M20D00D"
- "imageAtomicAnd(01M20D00E"
- "imageAtomicAnd(01N20D00D"
- "imageAtomicAnd(01N20D00E"
- "imageAtomicAnd(01O00D00D"
- "imageAtomicAnd(01O00D00E"
- "imageAtomicAnd(01P10D00D"
- "imageAtomicAnd(01P10D00E"
- "imageAtomicAnd(01Q10D00D00D"
- "imageAtomicAnd(01Q10D00D00E"
- "imageAtomicAnd(01R20D00D00D"
- "imageAtomicAnd(01R20D00D00E"
- "imageAtomicAnd(01S20D00D"
- "imageAtomicAnd(01S20D00E"
- "imageAtomicAnd(01T10D00D"
- "imageAtomicAnd(01T10D00E"
- "imageAtomicAnd(01U00D00D"
- "imageAtomicAnd(01U00D00E"
- "imageAtomicAnd(01V10D00D"
- "imageAtomicAnd(01V10D00E"
- "imageAtomicAnd(01W20D00D"
- "imageAtomicAnd(01W20D00E"
- "imageAtomicAnd(01X20D00D"
- "imageAtomicAnd(01X20D00E"
- "imageAtomicAnd(01Y20D00D"
- "imageAtomicAnd(01Y20D00E"
- "imageAtomicAnd(01Z00D00D"
- "imageAtomicAnd(01Z00D00E"
- "imageAtomicAnd(01a10D00D"
- "imageAtomicAnd(01a10D00E"
- "imageAtomicAnd(01b10D00D00D"
- "imageAtomicAnd(01b10D00D00E"
- "imageAtomicAnd(01c20D00D00D"
- "imageAtomicAnd(01c20D00D00E"
- "imageAtomicAnd(01d20D00D"
- "imageAtomicAnd(01d20D00E"
- "imageAtomicAnd(01e10D00D"
- "imageAtomicAnd(01e10D00E"
- "imageAtomicAnd(01f00D00D"
- "imageAtomicAnd(01f00D00E"
- "imageAtomicCompSwap(00z10D00D00D"
- "imageAtomicCompSwap(00z10D00E00E"
- "imageAtomicCompSwap(01A20D00D00D"
- "imageAtomicCompSwap(01A20D00E00E"
- "imageAtomicCompSwap(01B20D00D00D"
- "imageAtomicCompSwap(01B20D00E00E"
- "imageAtomicCompSwap(01C20D00D00D"
- "imageAtomicCompSwap(01C20D00E00E"
- "imageAtomicCompSwap(01D00D00D00D"
- "imageAtomicCompSwap(01D00D00E00E"
- "imageAtomicCompSwap(01E10D00D00D"
- "imageAtomicCompSwap(01E10D00E00E"
- "imageAtomicCompSwap(01F10D00D00D00D"
- "imageAtomicCompSwap(01F10D00D00E00E"
- "imageAtomicCompSwap(01G20D00D00D00D"
- "imageAtomicCompSwap(01G20D00D00E00E"
- "imageAtomicCompSwap(01H20D00D00D"
- "imageAtomicCompSwap(01H20D00E00E"
- "imageAtomicCompSwap(01I10D00D00D"
- "imageAtomicCompSwap(01I10D00E00E"
- "imageAtomicCompSwap(01J00D00D00D"
- "imageAtomicCompSwap(01J00D00E00E"
- "imageAtomicCompSwap(01K10D00D00D"
- "imageAtomicCompSwap(01K10D00E00E"
- "imageAtomicCompSwap(01L20D00D00D"
- "imageAtomicCompSwap(01L20D00E00E"
- "imageAtomicCompSwap(01M20D00D00D"
- "imageAtomicCompSwap(01M20D00E00E"
- "imageAtomicCompSwap(01N20D00D00D"
- "imageAtomicCompSwap(01N20D00E00E"
- "imageAtomicCompSwap(01O00D00D00D"
- "imageAtomicCompSwap(01O00D00E00E"
- "imageAtomicCompSwap(01P10D00D00D"
- "imageAtomicCompSwap(01P10D00E00E"
- "imageAtomicCompSwap(01Q10D00D00D00D"
- "imageAtomicCompSwap(01Q10D00D00E00E"
- "imageAtomicCompSwap(01R20D00D00D00D"
- "imageAtomicCompSwap(01R20D00D00E00E"
- "imageAtomicCompSwap(01S20D00D00D"
- "imageAtomicCompSwap(01S20D00E00E"
- "imageAtomicCompSwap(01T10D00D00D"
- "imageAtomicCompSwap(01T10D00E00E"
- "imageAtomicCompSwap(01U00D00D00D"
- "imageAtomicCompSwap(01U00D00E00E"
- "imageAtomicCompSwap(01V10D00D00D"
- "imageAtomicCompSwap(01V10D00E00E"
- "imageAtomicCompSwap(01W20D00D00D"
- "imageAtomicCompSwap(01W20D00E00E"
- "imageAtomicCompSwap(01X20D00D00D"
- "imageAtomicCompSwap(01X20D00E00E"
- "imageAtomicCompSwap(01Y20D00D00D"
- "imageAtomicCompSwap(01Y20D00E00E"
- "imageAtomicCompSwap(01Z00D00D00D"
- "imageAtomicCompSwap(01Z00D00E00E"
- "imageAtomicCompSwap(01a10D00D00D"
- "imageAtomicCompSwap(01a10D00E00E"
- "imageAtomicCompSwap(01b10D00D00D00D"
- "imageAtomicCompSwap(01b10D00D00E00E"
- "imageAtomicCompSwap(01c20D00D00D00D"
- "imageAtomicCompSwap(01c20D00D00E00E"
- "imageAtomicCompSwap(01d20D00D00D"
- "imageAtomicCompSwap(01d20D00E00E"
- "imageAtomicCompSwap(01e10D00D00D"
- "imageAtomicCompSwap(01e10D00E00E"
- "imageAtomicCompSwap(01f00D00D00D"
- "imageAtomicCompSwap(01f00D00E00E"
- "imageAtomicExchange(00z10D00B"
- "imageAtomicExchange(00z10D00D"
- "imageAtomicExchange(00z10D00E"
- "imageAtomicExchange(01A20D00B"
- "imageAtomicExchange(01A20D00D"
- "imageAtomicExchange(01A20D00E"
- "imageAtomicExchange(01B20D00B"
- "imageAtomicExchange(01B20D00D"
- "imageAtomicExchange(01B20D00E"
- "imageAtomicExchange(01C20D00B"
- "imageAtomicExchange(01C20D00D"
- "imageAtomicExchange(01C20D00E"
- "imageAtomicExchange(01D00D00B"
- "imageAtomicExchange(01D00D00D"
- "imageAtomicExchange(01D00D00E"
- "imageAtomicExchange(01E10D00B"
- "imageAtomicExchange(01E10D00D"
- "imageAtomicExchange(01E10D00E"
- "imageAtomicExchange(01F10D00D00B"
- "imageAtomicExchange(01F10D00D00D"
- "imageAtomicExchange(01F10D00D00E"
- "imageAtomicExchange(01G20D00D00B"
- "imageAtomicExchange(01G20D00D00D"
- "imageAtomicExchange(01G20D00D00E"
- "imageAtomicExchange(01H20D00B"
- "imageAtomicExchange(01H20D00D"
- "imageAtomicExchange(01H20D00E"
- "imageAtomicExchange(01I10D00B"
- "imageAtomicExchange(01I10D00D"
- "imageAtomicExchange(01I10D00E"
- "imageAtomicExchange(01J00D00B"
- "imageAtomicExchange(01J00D00D"
- "imageAtomicExchange(01J00D00E"
- "imageAtomicExchange(01K10D00B"
- "imageAtomicExchange(01K10D00D"
- "imageAtomicExchange(01K10D00E"
- "imageAtomicExchange(01L20D00B"
- "imageAtomicExchange(01L20D00D"
- "imageAtomicExchange(01L20D00E"
- "imageAtomicExchange(01M20D00B"
- "imageAtomicExchange(01M20D00D"
- "imageAtomicExchange(01M20D00E"
- "imageAtomicExchange(01N20D00B"
- "imageAtomicExchange(01N20D00D"
- "imageAtomicExchange(01N20D00E"
- "imageAtomicExchange(01O00D00B"
- "imageAtomicExchange(01O00D00D"
- "imageAtomicExchange(01O00D00E"
- "imageAtomicExchange(01P10D00B"
- "imageAtomicExchange(01P10D00D"
- "imageAtomicExchange(01P10D00E"
- "imageAtomicExchange(01Q10D00D00B"
- "imageAtomicExchange(01Q10D00D00D"
- "imageAtomicExchange(01Q10D00D00E"
- "imageAtomicExchange(01R20D00D00B"
- "imageAtomicExchange(01R20D00D00D"
- "imageAtomicExchange(01R20D00D00E"
- "imageAtomicExchange(01S20D00B"
- "imageAtomicExchange(01S20D00D"
- "imageAtomicExchange(01S20D00E"
- "imageAtomicExchange(01T10D00B"
- "imageAtomicExchange(01T10D00D"
- "imageAtomicExchange(01T10D00E"
- "imageAtomicExchange(01U00D00B"
- "imageAtomicExchange(01U00D00D"
- "imageAtomicExchange(01U00D00E"
- "imageAtomicExchange(01V10D00B"
- "imageAtomicExchange(01V10D00D"
- "imageAtomicExchange(01V10D00E"
- "imageAtomicExchange(01W20D00B"
- "imageAtomicExchange(01W20D00D"
- "imageAtomicExchange(01W20D00E"
- "imageAtomicExchange(01X20D00B"
- "imageAtomicExchange(01X20D00D"
- "imageAtomicExchange(01X20D00E"
- "imageAtomicExchange(01Y20D00B"
- "imageAtomicExchange(01Y20D00D"
- "imageAtomicExchange(01Y20D00E"
- "imageAtomicExchange(01Z00D00B"
- "imageAtomicExchange(01Z00D00D"
- "imageAtomicExchange(01Z00D00E"
- "imageAtomicExchange(01a10D00B"
- "imageAtomicExchange(01a10D00D"
- "imageAtomicExchange(01a10D00E"
- "imageAtomicExchange(01b10D00D00B"
- "imageAtomicExchange(01b10D00D00D"
- "imageAtomicExchange(01b10D00D00E"
- "imageAtomicExchange(01c20D00D00B"
- "imageAtomicExchange(01c20D00D00D"
- "imageAtomicExchange(01c20D00D00E"
- "imageAtomicExchange(01d20D00B"
- "imageAtomicExchange(01d20D00D"
- "imageAtomicExchange(01d20D00E"
- "imageAtomicExchange(01e10D00B"
- "imageAtomicExchange(01e10D00D"
- "imageAtomicExchange(01e10D00E"
- "imageAtomicExchange(01f00D00B"
- "imageAtomicExchange(01f00D00D"
- "imageAtomicExchange(01f00D00E"
- "imageAtomicMax(00z10D00D"
- "imageAtomicMax(00z10D00E"
- "imageAtomicMax(01A20D00D"
- "imageAtomicMax(01A20D00E"
- "imageAtomicMax(01B20D00D"
- "imageAtomicMax(01B20D00E"
- "imageAtomicMax(01C20D00D"
- "imageAtomicMax(01C20D00E"
- "imageAtomicMax(01D00D00D"
- "imageAtomicMax(01D00D00E"
- "imageAtomicMax(01E10D00D"
- "imageAtomicMax(01E10D00E"
- "imageAtomicMax(01F10D00D00D"
- "imageAtomicMax(01F10D00D00E"
- "imageAtomicMax(01G20D00D00D"
- "imageAtomicMax(01G20D00D00E"
- "imageAtomicMax(01H20D00D"
- "imageAtomicMax(01H20D00E"
- "imageAtomicMax(01I10D00D"
- "imageAtomicMax(01I10D00E"
- "imageAtomicMax(01J00D00D"
- "imageAtomicMax(01J00D00E"
- "imageAtomicMax(01K10D00D"
- "imageAtomicMax(01K10D00E"
- "imageAtomicMax(01L20D00D"
- "imageAtomicMax(01L20D00E"
- "imageAtomicMax(01M20D00D"
- "imageAtomicMax(01M20D00E"
- "imageAtomicMax(01N20D00D"
- "imageAtomicMax(01N20D00E"
- "imageAtomicMax(01O00D00D"
- "imageAtomicMax(01O00D00E"
- "imageAtomicMax(01P10D00D"
- "imageAtomicMax(01P10D00E"
- "imageAtomicMax(01Q10D00D00D"
- "imageAtomicMax(01Q10D00D00E"
- "imageAtomicMax(01R20D00D00D"
- "imageAtomicMax(01R20D00D00E"
- "imageAtomicMax(01S20D00D"
- "imageAtomicMax(01S20D00E"
- "imageAtomicMax(01T10D00D"
- "imageAtomicMax(01T10D00E"
- "imageAtomicMax(01U00D00D"
- "imageAtomicMax(01U00D00E"
- "imageAtomicMax(01V10D00D"
- "imageAtomicMax(01V10D00E"
- "imageAtomicMax(01W20D00D"
- "imageAtomicMax(01W20D00E"
- "imageAtomicMax(01X20D00D"
- "imageAtomicMax(01X20D00E"
- "imageAtomicMax(01Y20D00D"
- "imageAtomicMax(01Y20D00E"
- "imageAtomicMax(01Z00D00D"
- "imageAtomicMax(01Z00D00E"
- "imageAtomicMax(01a10D00D"
- "imageAtomicMax(01a10D00E"
- "imageAtomicMax(01b10D00D00D"
- "imageAtomicMax(01b10D00D00E"
- "imageAtomicMax(01c20D00D00D"
- "imageAtomicMax(01c20D00D00E"
- "imageAtomicMax(01d20D00D"
- "imageAtomicMax(01d20D00E"
- "imageAtomicMax(01e10D00D"
- "imageAtomicMax(01e10D00E"
- "imageAtomicMax(01f00D00D"
- "imageAtomicMax(01f00D00E"
- "imageAtomicMin(00z10D00D"
- "imageAtomicMin(00z10D00E"
- "imageAtomicMin(01A20D00D"
- "imageAtomicMin(01A20D00E"
- "imageAtomicMin(01B20D00D"
- "imageAtomicMin(01B20D00E"
- "imageAtomicMin(01C20D00D"
- "imageAtomicMin(01C20D00E"
- "imageAtomicMin(01D00D00D"
- "imageAtomicMin(01D00D00E"
- "imageAtomicMin(01E10D00D"
- "imageAtomicMin(01E10D00E"
- "imageAtomicMin(01F10D00D00D"
- "imageAtomicMin(01F10D00D00E"
- "imageAtomicMin(01G20D00D00D"
- "imageAtomicMin(01G20D00D00E"
- "imageAtomicMin(01H20D00D"
- "imageAtomicMin(01H20D00E"
- "imageAtomicMin(01I10D00D"
- "imageAtomicMin(01I10D00E"
- "imageAtomicMin(01J00D00D"
- "imageAtomicMin(01J00D00E"
- "imageAtomicMin(01K10D00D"
- "imageAtomicMin(01K10D00E"
- "imageAtomicMin(01L20D00D"
- "imageAtomicMin(01L20D00E"
- "imageAtomicMin(01M20D00D"
- "imageAtomicMin(01M20D00E"
- "imageAtomicMin(01N20D00D"
- "imageAtomicMin(01N20D00E"
- "imageAtomicMin(01O00D00D"
- "imageAtomicMin(01O00D00E"
- "imageAtomicMin(01P10D00D"
- "imageAtomicMin(01P10D00E"
- "imageAtomicMin(01Q10D00D00D"
- "imageAtomicMin(01Q10D00D00E"
- "imageAtomicMin(01R20D00D00D"
- "imageAtomicMin(01R20D00D00E"
- "imageAtomicMin(01S20D00D"
- "imageAtomicMin(01S20D00E"
- "imageAtomicMin(01T10D00D"
- "imageAtomicMin(01T10D00E"
- "imageAtomicMin(01U00D00D"
- "imageAtomicMin(01U00D00E"
- "imageAtomicMin(01V10D00D"
- "imageAtomicMin(01V10D00E"
- "imageAtomicMin(01W20D00D"
- "imageAtomicMin(01W20D00E"
- "imageAtomicMin(01X20D00D"
- "imageAtomicMin(01X20D00E"
- "imageAtomicMin(01Y20D00D"
- "imageAtomicMin(01Y20D00E"
- "imageAtomicMin(01Z00D00D"
- "imageAtomicMin(01Z00D00E"
- "imageAtomicMin(01a10D00D"
- "imageAtomicMin(01a10D00E"
- "imageAtomicMin(01b10D00D00D"
- "imageAtomicMin(01b10D00D00E"
- "imageAtomicMin(01c20D00D00D"
- "imageAtomicMin(01c20D00D00E"
- "imageAtomicMin(01d20D00D"
- "imageAtomicMin(01d20D00E"
- "imageAtomicMin(01e10D00D"
- "imageAtomicMin(01e10D00E"
- "imageAtomicMin(01f00D00D"
- "imageAtomicMin(01f00D00E"
- "imageAtomicOr(00z10D00D"
- "imageAtomicOr(00z10D00E"
- "imageAtomicOr(01A20D00D"
- "imageAtomicOr(01A20D00E"
- "imageAtomicOr(01B20D00D"
- "imageAtomicOr(01B20D00E"
- "imageAtomicOr(01C20D00D"
- "imageAtomicOr(01C20D00E"
- "imageAtomicOr(01D00D00D"
- "imageAtomicOr(01D00D00E"
- "imageAtomicOr(01E10D00D"
- "imageAtomicOr(01E10D00E"
- "imageAtomicOr(01F10D00D00D"
- "imageAtomicOr(01F10D00D00E"
- "imageAtomicOr(01G20D00D00D"
- "imageAtomicOr(01G20D00D00E"
- "imageAtomicOr(01H20D00D"
- "imageAtomicOr(01H20D00E"
- "imageAtomicOr(01I10D00D"
- "imageAtomicOr(01I10D00E"
- "imageAtomicOr(01J00D00D"
- "imageAtomicOr(01J00D00E"
- "imageAtomicOr(01K10D00D"
- "imageAtomicOr(01K10D00E"
- "imageAtomicOr(01L20D00D"
- "imageAtomicOr(01L20D00E"
- "imageAtomicOr(01M20D00D"
- "imageAtomicOr(01M20D00E"
- "imageAtomicOr(01N20D00D"
- "imageAtomicOr(01N20D00E"
- "imageAtomicOr(01O00D00D"
- "imageAtomicOr(01O00D00E"
- "imageAtomicOr(01P10D00D"
- "imageAtomicOr(01P10D00E"
- "imageAtomicOr(01Q10D00D00D"
- "imageAtomicOr(01Q10D00D00E"
- "imageAtomicOr(01R20D00D00D"
- "imageAtomicOr(01R20D00D00E"
- "imageAtomicOr(01S20D00D"
- "imageAtomicOr(01S20D00E"
- "imageAtomicOr(01T10D00D"
- "imageAtomicOr(01T10D00E"
- "imageAtomicOr(01U00D00D"
- "imageAtomicOr(01U00D00E"
- "imageAtomicOr(01V10D00D"
- "imageAtomicOr(01V10D00E"
- "imageAtomicOr(01W20D00D"
- "imageAtomicOr(01W20D00E"
- "imageAtomicOr(01X20D00D"
- "imageAtomicOr(01X20D00E"
- "imageAtomicOr(01Y20D00D"
- "imageAtomicOr(01Y20D00E"
- "imageAtomicOr(01Z00D00D"
- "imageAtomicOr(01Z00D00E"
- "imageAtomicOr(01a10D00D"
- "imageAtomicOr(01a10D00E"
- "imageAtomicOr(01b10D00D00D"
- "imageAtomicOr(01b10D00D00E"
- "imageAtomicOr(01c20D00D00D"
- "imageAtomicOr(01c20D00D00E"
- "imageAtomicOr(01d20D00D"
- "imageAtomicOr(01d20D00E"
- "imageAtomicOr(01e10D00D"
- "imageAtomicOr(01e10D00E"
- "imageAtomicOr(01f00D00D"
- "imageAtomicOr(01f00D00E"
- "imageAtomicXor(00z10D00D"
- "imageAtomicXor(00z10D00E"
- "imageAtomicXor(01A20D00D"
- "imageAtomicXor(01A20D00E"
- "imageAtomicXor(01B20D00D"
- "imageAtomicXor(01B20D00E"
- "imageAtomicXor(01C20D00D"
- "imageAtomicXor(01C20D00E"
- "imageAtomicXor(01D00D00D"
- "imageAtomicXor(01D00D00E"
- "imageAtomicXor(01E10D00D"
- "imageAtomicXor(01E10D00E"
- "imageAtomicXor(01F10D00D00D"
- "imageAtomicXor(01F10D00D00E"
- "imageAtomicXor(01G20D00D00D"
- "imageAtomicXor(01G20D00D00E"
- "imageAtomicXor(01H20D00D"
- "imageAtomicXor(01H20D00E"
- "imageAtomicXor(01I10D00D"
- "imageAtomicXor(01I10D00E"
- "imageAtomicXor(01J00D00D"
- "imageAtomicXor(01J00D00E"
- "imageAtomicXor(01K10D00D"
- "imageAtomicXor(01K10D00E"
- "imageAtomicXor(01L20D00D"
- "imageAtomicXor(01L20D00E"
- "imageAtomicXor(01M20D00D"
- "imageAtomicXor(01M20D00E"
- "imageAtomicXor(01N20D00D"
- "imageAtomicXor(01N20D00E"
- "imageAtomicXor(01O00D00D"
- "imageAtomicXor(01O00D00E"
- "imageAtomicXor(01P10D00D"
- "imageAtomicXor(01P10D00E"
- "imageAtomicXor(01Q10D00D00D"
- "imageAtomicXor(01Q10D00D00E"
- "imageAtomicXor(01R20D00D00D"
- "imageAtomicXor(01R20D00D00E"
- "imageAtomicXor(01S20D00D"
- "imageAtomicXor(01S20D00E"
- "imageAtomicXor(01T10D00D"
- "imageAtomicXor(01T10D00E"
- "imageAtomicXor(01U00D00D"
- "imageAtomicXor(01U00D00E"
- "imageAtomicXor(01V10D00D"
- "imageAtomicXor(01V10D00E"
- "imageAtomicXor(01W20D00D"
- "imageAtomicXor(01W20D00E"
- "imageAtomicXor(01X20D00D"
- "imageAtomicXor(01X20D00E"
- "imageAtomicXor(01Y20D00D"
- "imageAtomicXor(01Y20D00E"
- "imageAtomicXor(01Z00D00D"
- "imageAtomicXor(01Z00D00E"
- "imageAtomicXor(01a10D00D"
- "imageAtomicXor(01a10D00E"
- "imageAtomicXor(01b10D00D00D"
- "imageAtomicXor(01b10D00D00E"
- "imageAtomicXor(01c20D00D00D"
- "imageAtomicXor(01c20D00D00E"
- "imageAtomicXor(01d20D00D"
- "imageAtomicXor(01d20D00E"
- "imageAtomicXor(01e10D00D"
- "imageAtomicXor(01e10D00E"
- "imageAtomicXor(01f00D00D"
- "imageAtomicXor(01f00D00E"
- "imageLoad(00z10D"
- "imageLoad(01A20D"
- "imageLoad(01B20D"
- "imageLoad(01C20D"
- "imageLoad(01H20D"
- "imageLoad(01J00D"
- "imageLoad(01K10D"
- "imageLoad(01L20D"
- "imageLoad(01M20D"
- "imageLoad(01N20D"
- "imageLoad(01S20D"
- "imageLoad(01U00D"
- "imageLoad(01V10D"
- "imageLoad(01W20D"
- "imageLoad(01X20D"
- "imageLoad(01Y20D"
- "imageLoad(01d20D"
- "imageLoad(01f00D"
- "imageSize(01M"
- "imageSize(01N"
- "imageSize(01S"
- "imageSize(01U"
- "imageSize(01V"
- "imageSize(01W"
- "imageSize(01X"
- "imageSize(01Y"
- "imageSize(01d"
- "imageSize(01f"
- "imageStore(00z10D30B"
- "imageStore(01A20D30B"
- "imageStore(01B20D30B"
- "imageStore(01C20D30B"
- "imageStore(01H20D30B"
- "imageStore(01J00D30B"
- "imageStore(01K10D30D"
- "imageStore(01L20D30D"
- "imageStore(01M20D30D"
- "imageStore(01N20D30D"
- "imageStore(01S20D30D"
- "imageStore(01U00D30D"
- "imageStore(01V10D30E"
- "imageStore(01W20D30E"
- "imageStore(01X20D30E"
- "imageStore(01Y20D30E"
- "imageStore(01d20D30E"
- "imageStore(01f00D30E"
- "imulExtended(00D00D00D00D"
- "imulExtended(10D10D10D10D"
- "imulExtended(20D20D20D20D"
- "imulExtended(30D30D30D30D"
- "intBitsToFloat(00D"
- "intBitsToFloat(10D"
- "intBitsToFloat(20D"
- "intBitsToFloat(30D"
- "interpolateAtSample(00B00D"
- "interpolateAtSample(10B00D"
- "interpolateAtSample(20B00D"
- "interpolateAtSample(30B00D"
- "isAMD()"
- "isAMDBronzeDriver()"
- "isIntel()"
- "isIntel() && GetMacOSVersion() < OSVersion(11, 0, 0)"
- "isIntel() && GetMacOSVersion() < OSVersion(12, 0, 0)"
- "isIntel() || isAMD()"
- "isOSX || isCatalyst || supportsAppleGPUFamily(3)"
- "isOSX || isCatalyst || supportsAppleGPUFamily(4)"
- "isSimulator || !supportsAppleGPUFamily(1)"
- "isubpassInputMS"
- "ldexp(00B00D"
- "ldexp(10B10D"
- "ldexp(20B20D"
- "ldexp(30B30D"
- "lessThan(10E10E"
- "lessThan(20E20E"
- "lessThan(30E30E"
- "lessThanEqual(10E10E"
- "lessThanEqual(20E20E"
- "lessThanEqual(30E30E"
- "max(00E00E"
- "max(10E00E"
- "max(10E10E"
- "max(20E00E"
- "max(20E20E"
- "max(30E00E"
- "max(30E30E"
- "metal::texture1d<float>"
- "metal::texture1d<int>"
- "metal::texture1d<uint32_t>"
- "metal::texture1d_array<float>"
- "metal::texture1d_array<int>"
- "metal::texture1d_array<uint32_t>"
- "min(00E00E"
- "min(10E00E"
- "min(10E10E"
- "min(20E00E"
- "min(20E20E"
- "min(30E00E"
- "min(30E30E"
- "mix(00B00B00F"
- "mix(00D00D00F"
- "mix(00E00E00F"
- "mix(00F00F00F"
- "mix(10B10B10F"
- "mix(10D10D10F"
- "mix(10E10E10F"
- "mix(10F10F10F"
- "mix(20B20B20F"
- "mix(20D20D20F"
- "mix(20E20E20F"
- "mix(20F20F20F"
- "mix(30B30B30F"
- "mix(30D30D30F"
- "mix(30E30E30F"
- "mix(30F30F30F"
- "not(10F"
- "not(20F"
- "not(30F"
- "notEqual(10F10F"
- "notEqual(20F20F"
- "notEqual(30F30F"
- "pixelLocalLoadANGLE(01g"
- "pixelLocalLoadANGLE(01h"
- "pixelLocalLoadANGLE(01i"
- "pixelLocalStoreANGLE(01g30B"
- "pixelLocalStoreANGLE(01h30D"
- "pixelLocalStoreANGLE(01i30E"
- "pls"
- "requireMsl21"
- "rgb_2_yuv(20B00H"
- "samplePosition(00E"
- "shadow2DEXT(00d20B"
- "shadow2DProjEXT(00d30B"
- "sign(00D"
- "sign(10D"
- "sign(20D"
- "sign(30D"
- "some GPUs are faster to read a texture by first copying the texture to a buffer"
- "some GPUs are faster to read an IOSurface texture by first copying the texture to a non-IOSurface texture"
- "subpassInputMS"
- "subpassLoad(01j"
- "subpassLoad(01k"
- "subpassLoad(01l"
- "subpassLoad(01m00D"
- "subpassLoad(01n00D"
- "subpassLoad(01o00D"
- "supportsAppleGPUFamily(1)"
- "supportsEitherGPUFamily(3, 1)"
- "supportsEitherGPUFamily(3, 1) && !isAMD()"
- "supportsEitherGPUFamily(3, 2)"
- "supportsEitherGPUFamily(4, 2)"
- "supportsEitherGPUFamily(5, 2)"
- "supportsMetal2_1() && !isIntel() && !isNVIDIA()"
- "supportsMetal2_1() && !isNVIDIA()"
- "supportsMetal2_1() && (isOSX || isCatalyst) && !isARM"
- "supportsMetal2_2() && supportsEitherGPUFamily(3, 2) && !isSimulator"
- "supportsVariableRasterizationRate()"
- "texelFetch(00I10D00D"
- "texelFetch(00J20D00D"
- "texelFetch(00L20D00D"
- "texelFetch(00M10D00D"
- "texelFetch(00N10D00D"
- "texelFetch(00P10D00D"
- "texelFetch(00Q20D00D"
- "texelFetch(00R10D00D"
- "texelFetch(00S20D00D"
- "texelFetch(00U20D00D"
- "texelFetch(00V10D00D"
- "texelFetch(00W20D00D"
- "texelFetch(00X10D00D"
- "texelFetch(00Y20D00D"
- "texelFetch(00a20D00D"
- "texelFetch(00b10D00D"
- "texelFetch(00c20D00D"
- "texelFetch(00j00D"
- "texelFetch(00r00D"
- "texelFetch(00w00D"
- "texelFetchOffset(00I10D00D10D"
- "texelFetchOffset(00J20D00D20D"
- "texelFetchOffset(00L20D00D10D"
- "texelFetchOffset(00R10D00D10D"
- "texelFetchOffset(00S20D00D20D"
- "texelFetchOffset(00U20D00D10D"
- "texelFetchOffset(00X10D00D10D"
- "texelFetchOffset(00Y20D00D20D"
- "texelFetchOffset(00a20D00D10D"
- "texture(00I10B"
- "texture(00I10B00B"
- "texture(00L20B"
- "texture(00L20B00B"
- "texture(00N10B00B"
- "texture(00O10B"
- "texture(00R10B"
- "texture(00R10B00B"
- "texture(00U20B"
- "texture(00U20B00B"
- "texture(00X10B"
- "texture(00X10B00B"
- "texture(00a20B"
- "texture(00a20B00B"
- "texture(00d20B"
- "texture(00d20B00B"
- "texture(00f30B"
- "texture(00k30B"
- "texture(00k30B00B"
- "texture(00s30B"
- "texture(00s30B00B"
- "texture(00x30B"
- "texture(00x30B00B"
- "texture(00y10B"
- "texture1D"
- "texture1DLod"
- "texture1DProj"
- "texture1DProjLod"
- "texture2D(00I10B"
- "texture2D(00I10B00B"
- "texture2D(00M10B"
- "texture2DGradEXT(00I10B10B10B"
- "texture2DLod(00I10B00B"
- "texture2DLodEXT(00I10B00B"
- "texture2DProj(00I20B"
- "texture2DProj(00I20B00B"
- "texture2DProj(00I30B"
- "texture2DProj(00I30B00B"
- "texture2DProj(00M20B"
- "texture2DProj(00M30B"
- "texture2DProjGradEXT(00I20B10B10B"
- "texture2DProjGradEXT(00I30B10B10B"
- "texture2DProjLod(00I20B00B"
- "texture2DProjLod(00I30B00B"
- "texture2DProjLodEXT(00I20B00B"
- "texture2DProjLodEXT(00I30B00B"
- "texture2DRect(00O10B"
- "texture2DRectProj(00O20B"
- "texture2DRectProj(00O30B"
- "texture3D(00J20B"
- "texture3D(00J20B00B"
- "texture3DLod(00J20B00B"
- "texture3DProj(00J30B"
- "texture3DProj(00J30B00B"
- "texture3DProjLod(00J30B00B"
- "textureCube(00K20B"
- "textureCube(00K20B00B"
- "textureCubeGradEXT(00K20B20B20B"
- "textureCubeLod(00K20B00B"
- "textureCubeLodEXT(00K20B00B"
- "textureCubeProj"
- "textureCubeProjLod"
- "textureGather(00I10B"
- "textureGather(00I10B00D"
- "textureGather(00K20B00D"
- "textureGather(00L20B"
- "textureGather(00L20B00D"
- "textureGather(00R10B"
- "textureGather(00R10B00D"
- "textureGather(00T20B00D"
- "textureGather(00U20B"
- "textureGather(00U20B00D"
- "textureGather(00X10B"
- "textureGather(00X10B00D"
- "textureGather(00Z20B00D"
- "textureGather(00a20B"
- "textureGather(00a20B00D"
- "textureGather(00d10B"
- "textureGather(00d10B00B"
- "textureGather(00f20B"
- "textureGather(00f20B00B"
- "textureGather(00k30B"
- "textureGather(00k30B00D"
- "textureGather(00l30B00B"
- "textureGather(00s30B"
- "textureGather(00s30B00D"
- "textureGather(00x30B"
- "textureGather(00x30B00D"
- "textureGatherOffset(00I10B10D"
- "textureGatherOffset(00I10B10D00D"
- "textureGatherOffset(00L20B10D"
- "textureGatherOffset(00L20B10D00D"
- "textureGatherOffset(00R10B10D"
- "textureGatherOffset(00R10B10D00D"
- "textureGatherOffset(00U20B10D"
- "textureGatherOffset(00U20B10D00D"
- "textureGatherOffset(00X10B10D"
- "textureGatherOffset(00X10B10D00D"
- "textureGatherOffset(00a20B10D"
- "textureGatherOffset(00a20B10D00D"
- "textureGatherOffset(00d10B00B10D"
- "textureGatherOffset(00f20B00B10D"
- "textureGatherOffsets(00I10B10Dx4"
- "textureGatherOffsets(00I10B10Dx400D"
- "textureGatherOffsets(00L20B10Dx4"
- "textureGatherOffsets(00L20B10Dx400D"
- "textureGatherOffsets(00R10B10Dx4"
- "textureGatherOffsets(00R10B10Dx400D"
- "textureGatherOffsets(00U20B10Dx4"
- "textureGatherOffsets(00U20B10Dx400D"
- "textureGatherOffsets(00X10B10Dx4"
- "textureGatherOffsets(00X10B10Dx400D"
- "textureGatherOffsets(00a20B10Dx4"
- "textureGatherOffsets(00a20B10Dx400D"
- "textureGatherOffsets(00d10B00B10Dx4"
- "textureGatherOffsets(00f20B00B10Dx4"
- "textureGrad(00I10B10B10B"
- "textureGrad(00K20B20B20B"
- "textureGrad(00L20B10B10B"
- "textureGrad(00R10B10B10B"
- "textureGrad(00T20B20B20B"
- "textureGrad(00U20B10B10B"
- "textureGrad(00X10B10B10B"
- "textureGrad(00Z20B20B20B"
- "textureGrad(00a20B10B10B"
- "textureGrad(00d20B10B10B"
- "textureGrad(00e30B20B20B"
- "textureGrad(00f30B10B10B"
- "textureGrad(00k30B20B20B"
- "textureGrad(00s30B20B20B"
- "textureGrad(00x30B20B20B"
- "textureGradOffset(00I10B10B10B10D"
- "textureGradOffset(00J20B20B20B20D"
- "textureGradOffset(00L20B10B10B10D"
- "textureGradOffset(00R10B10B10B10D"
- "textureGradOffset(00S20B20B20B20D"
- "textureGradOffset(00U20B10B10B10D"
- "textureGradOffset(00X10B10B10B10D"
- "textureGradOffset(00Y20B20B20B20D"
- "textureGradOffset(00a20B10B10B10D"
- "textureGradOffset(00d20B10B10B10D"
- "textureGradOffset(00f30B10B10B10D"
- "textureLod(00I10B00B"
- "textureLod(00L20B00B"
- "textureLod(00R10B00B"
- "textureLod(00U20B00B"
- "textureLod(00X10B00B"
- "textureLod(00a20B00B"
- "textureLod(00d20B00B"
- "textureLod(00k30B00B"
- "textureLod(00s30B00B"
- "textureLod(00x30B00B"
- "textureLodOffset(00I10B00B10D"
- "textureLodOffset(00J20B00B20D"
- "textureLodOffset(00L20B00B10D"
- "textureLodOffset(00R10B00B10D"
- "textureLodOffset(00S20B00B20D"
- "textureLodOffset(00U20B00B10D"
- "textureLodOffset(00X10B00B10D"
- "textureLodOffset(00Y20B00B20D"
- "textureLodOffset(00a20B00B10D"
- "textureLodOffset(00d20B00B10D"
- "textureOffset(00I10B10D"
- "textureOffset(00I10B10D00B"
- "textureOffset(00J20B20D"
- "textureOffset(00J20B20D00B"
- "textureOffset(00L20B10D"
- "textureOffset(00L20B10D00B"
- "textureOffset(00R10B10D"
- "textureOffset(00R10B10D00B"
- "textureOffset(00S20B20D"
- "textureOffset(00S20B20D00B"
- "textureOffset(00U20B10D"
- "textureOffset(00U20B10D00B"
- "textureOffset(00X10B10D"
- "textureOffset(00X10B10D00B"
- "textureOffset(00Y20B20D"
- "textureOffset(00Y20B20D00B"
- "textureOffset(00a20B10D"
- "textureOffset(00a20B10D00B"
- "textureOffset(00d20B10D"
- "textureOffset(00d20B10D00B"
- "textureProj(00I20B"
- "textureProj(00I20B00B"
- "textureProj(00J30B"
- "textureProj(00J30B00B"
- "textureProj(00N20B00B"
- "textureProj(00N30B00B"
- "textureProj(00O20B"
- "textureProj(00O30B"
- "textureProj(00R20B"
- "textureProj(00R20B00B"
- "textureProj(00S30B"
- "textureProj(00S30B00B"
- "textureProj(00X20B"
- "textureProj(00X20B00B"
- "textureProj(00Y30B"
- "textureProj(00Y30B00B"
- "textureProj(00d30B"
- "textureProj(00d30B00B"
- "textureProjGrad(00I20B10B10B"
- "textureProjGrad(00I30B10B10B"
- "textureProjGrad(00J30B20B20B"
- "textureProjGrad(00R20B10B10B"
- "textureProjGrad(00R30B10B10B"
- "textureProjGrad(00S30B20B20B"
- "textureProjGrad(00X20B10B10B"
- "textureProjGrad(00X30B10B10B"
- "textureProjGrad(00Y30B20B20B"
- "textureProjGrad(00d30B10B10B"
- "textureProjGradOffset(00I20B10B10B10D"
- "textureProjGradOffset(00I30B10B10B10D"
- "textureProjGradOffset(00J30B20B20B20D"
- "textureProjGradOffset(00R20B10B10B10D"
- "textureProjGradOffset(00R30B10B10B10D"
- "textureProjGradOffset(00S30B20B20B20D"
- "textureProjGradOffset(00X20B10B10B10D"
- "textureProjGradOffset(00X30B10B10B10D"
- "textureProjGradOffset(00Y30B20B20B20D"
- "textureProjGradOffset(00d30B10B10B10D"
- "textureProjLod(00I20B00B"
- "textureProjLod(00J30B00B"
- "textureProjLod(00R20B00B"
- "textureProjLod(00S30B00B"
- "textureProjLod(00X20B00B"
- "textureProjLod(00Y30B00B"
- "textureProjLod(00d30B00B"
- "textureProjLodOffset(00I20B00B10D"
- "textureProjLodOffset(00I30B00B10D"
- "textureProjLodOffset(00J30B00B20D"
- "textureProjLodOffset(00R20B00B10D"
- "textureProjLodOffset(00R30B00B10D"
- "textureProjLodOffset(00S30B00B20D"
- "textureProjLodOffset(00X20B00B10D"
- "textureProjLodOffset(00X30B00B10D"
- "textureProjLodOffset(00Y30B00B20D"
- "textureProjLodOffset(00d30B00B10D"
- "textureProjOffset(00I20B10D"
- "textureProjOffset(00I20B10D00B"
- "textureProjOffset(00I30B10D"
- "textureProjOffset(00I30B10D00B"
- "textureProjOffset(00J30B20D"
- "textureProjOffset(00J30B20D00B"
- "textureProjOffset(00R20B10D"
- "textureProjOffset(00R20B10D00B"
- "textureProjOffset(00R30B10D"
- "textureProjOffset(00R30B10D00B"
- "textureProjOffset(00S30B20D"
- "textureProjOffset(00S30B20D00B"
- "textureProjOffset(00X20B10D"
- "textureProjOffset(00X20B10D00B"
- "textureProjOffset(00X30B10D"
- "textureProjOffset(00X30B10D00B"
- "textureProjOffset(00Y30B20D"
- "textureProjOffset(00Y30B20D00B"
- "textureProjOffset(00d30B10D"
- "textureProjOffset(00d30B10D00B"
- "textureSize(00I00D"
- "textureSize(00J00D"
- "textureSize(00K00D"
- "textureSize(00L00D"
- "textureSize(00M00D"
- "textureSize(00N00D"
- "textureSize(00Q"
- "textureSize(00R00D"
- "textureSize(00S00D"
- "textureSize(00T00D"
- "textureSize(00U00D"
- "textureSize(00W"
- "textureSize(00X00D"
- "textureSize(00Y00D"
- "textureSize(00Z00D"
- "textureSize(00a00D"
- "textureSize(00c"
- "textureSize(00d00D"
- "textureSize(00e00D"
- "textureSize(00f00D"
- "textureSize(00j"
- "textureSize(00k00D"
- "textureSize(00l00D"
- "textureSize(00r"
- "textureSize(00s00D"
- "textureSize(00w"
- "textureSize(00x00D"
- "textureVideoWEBGL(00y10B"
- "true (override)"
- "uaddCarry(00E00E00E"
- "uaddCarry(10E10E10E"
- "uaddCarry(20E20E20E"
- "uaddCarry(30E30E30E"
- "uintBitsToFloat(00E"
- "uintBitsToFloat(10E"
- "uintBitsToFloat(20E"
- "uintBitsToFloat(30E"
- "umulExtended(00E00E00E00E"
- "umulExtended(10E10E10E10E"
- "umulExtended(20E20E20E20E"
- "umulExtended(30E30E30E30E"
- "unpackHalf2x16(00E"
- "unpackSnorm2x16(00E"
- "unpackSnorm4x8(00E"
- "unpackUnorm2x16(00E"
- "unpackUnorm4x8(00E"
- "usubBorrow(00E00E00E"
- "usubBorrow(10E10E10E"
- "usubBorrow(20E20E20E"
- "usubBorrow(30E30E30E"
- "usubpassInputMS"
- "wglChoosePixelFormat"
- "wglCopyContext"
- "wglCreateContext"
- "wglCreateLayerContext"
- "wglDeleteContext"
- "wglDescribeLayerPlane"
- "wglDescribePixelFormat"
- "wglGetCurrentContext"
- "wglGetCurrentDC"
- "wglGetEnhMetaFilePixelFormat"
- "wglGetLayerPaletteEntries"
- "wglGetPixelFormat"
- "wglGetProcAddress"
- "wglMakeCurrent"
- "wglRealizeLayerPalette"
- "wglSetLayerPaletteEntries"
- "wglSetPixelFormat"
- "wglShareLists"
- "wglSwapBuffers"
- "wglSwapLayerBuffers"
- "wglUseFontBitmaps"
- "wglUseFontBitmapsA"
- "wglUseFontBitmapsW"
- "wglUseFontOutlines"
- "wglUseFontOutlinesA"
- "wglUseFontOutlinesW"
- "yuv_2_rgb(20B00H"

```
